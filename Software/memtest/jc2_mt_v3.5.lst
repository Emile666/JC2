mads 2.1.7 build 33 (1 Aug 24)
Source: jc2_mt_v3.5.asm
     1 				;---------------------------------------------------------------------------
     2 				; Memory-Test for Junior Computer ][
     3 				; v1: first version of mem-Test
     4 				; v2: table-driven version of mem-Test
     5 				; v3: PIA-detection + RAM-Banks test added
     6 				; v3.1: 628128 RAM IC test + Printing subroutines added
     7 				; v3.2: BASIC-ROM test added + IOL-card detection
     8 				; v3.3: MMU-banks detection improved
     9 				; v3.4: ATF1504 MMU detection added
    10 				;---------------------------------------------------------------------------
    11 				        OPT h- ; do not add file header
    12 				        OPT f+ ; save as single block
    13
    14 				; Defines and Constants ********************************************************
    15 = 000D			CR        	EQU     $0D    		; carriage return
    16 = 000A			LF	  	EQU     $0A    		; line feed
    17
    18 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    19 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    20
    21 				; Defines for RAM-table
    22 = 0000			TNO		EQU	$00		; No test
    23 = 0001			TRAM		EQU     $01		; RAM test only
    24 = 0002			TROM		EQU	$02		; ROM test and RAM test behind ROM
    25 = 0003			TPIA		EQU	$03		; 6520 PIA test
    26 = 0080			TRIOT		EQU	$80		; 6532 RIOT 128 B RAM test 
    27
    28 = 0003			NO_RAMBANK	EQU	$03		; No RAM-banks selected, both ROMs enabled
    29
    30 = 0E65			ROM_CS_MON	EQU     $0E65		; Checksum JC Monitor program (1K)
    31 = 65C3			ROM_CS_BIOS	EQU	$65C3		; Checksum BIOS v1.1.4 (8K)
    32 = 804C			ROM_CS_BASIC	EQU	$804C		; Checksum BASIC ROM v2.25 (12K)
    33
    34 = 0014			IOBASE		EQU	$14		; LSB of IO/ROM card if found (0 if not present)
    35 = 0015			IOBASEH		EQU	$15		; MSB of IO/ROM card if found (0 if not present)
    36
    37 = 00C7			PIA_PRESENT	EQU	$C7		; 1-byte, 0=no PIA, $80=PIA present
    38 = 00C8			BCNTR		EQU     $C8		; 1-byte RAM-bank counter
    39 = 00C9			MMU_BANKS	EQU     $C9		; 1-byte, #RAM-banks found, 0 = no RAM-banks found
    40 = 00CB			KB		EQU	$CB		; 1-byte Size in KB
    41 = 00CC			ROM_PTR		EQU	$CC		; 2-byte ROM pointer
    42 = 00CE			ROM_CS 		EQU 	$CE		; 2-byte ROM checksum
    43 = 00D0			SAVEX		EQU	$D0		; X-register back-up
    44 = 00D1			SAVEY		EQU	$D1		; Y-register back-up
    45 = 00D2			PPSTR		EQU	$D2		; 2-byte Post Print pointer
    46 = 00D4			PRBMSB          EQU     $D4		; MSB of begin-address to print
    47 = 00D5			PREMSB          EQU     $D5		; MSB of end-address to print
    48 = 00D6			CHK_MODE        EQU     $D6             ; 0=no RAM-check, 1=RAM-check 2=ROM checksum,
    49 				                                        ; 80=start halfway a memory page
    50 = 00D7			TBL_IDX		EQU     $D7		; 1-byte index in memory table
    51 = 00D8			PGCNTR		EQU     $D8		; 2-byte Memory end address
    52 = 00DA			RAMSAV1         EQU     $DA             ; 1-byte memory save
    53 = 00DB			RAMSAV2         EQU     $DB             ; 1-byte memory save
    54
    55 = 00EA			PSTR      	EQU   	$EA      	; 2-byte BIOS output string Pointer
    56
    57 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit
    58 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit
    59 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit
    60
    61 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
    62
    63 = 1700			PORTA		EQU	$1700		; CRA-2=1: PIA PORTA register
    64 = 1700			DDRA            EQU     $1700           ; CRA-2=0: PIA data-direction A register 
    65 = 1701			CRA             EQU     $1701           ; PIA control A register
    66 = 1702			PORTB		EQU	$1702		; CRB-2=1: PIA PORTB register
    67 = 1702			DDRB            EQU     $1702           ; CRB-2=0: PIA data-direction B register 
    68 = 1703			CRB             EQU     $1703           ; PIA control B register
    69
    70 				; BIOS v1.1.4 Routines *********************************************************
    71
    72 = E083			STROUT		EQU     $E083           ; string write routine v1.1.4 bios
    73 = E091			HEXOUT          EQU     $E091           ; print 2-byte hex number
    74 = E0A7			NUMOUT          EQU     $E0A7           ; print 3-byte decimal number
    75 = E0BD			DEC2STR		EQU	$E0BD		; convert decimal number to string
    76 = E044			BOUT		EQU     $E044           ; print 1 byte
    77 = E052			COUT		EQU     $E052           ; print 1 character
    78 = E003			MON_WARM_START	EQU  	$E003       	; BIOS monitor warm start
    79 = ECD1			DETECT_IOL_CARD EQU	$ECD1		; Detect IO / Basic card
    80
    81  00 20					.word RUN_ADR		; Needed for lm command (XMODEM load program)
    82
    83 						ORG $2000
    84 					
    85 				;----------------------------------------------------------------------------
    86 				; This is the main program for the JC2 Memory Tester.
    87 				;----------------------------------------------------------------------------
    88 2000 20 45 23		RUN_ADR 	JSR PR_TITLE        	; Print Program Title text
    89 2003 A9 00				LDA #$00            	; Init. table index
    90 2005 85 D7		                STA TBL_IDX
    91 2007 85 C7				STA PIA_PRESENT		; 0 = No PIA
    92 2009 85 C9				STA MMU_BANKS		; Init. nr. of RAM-banks found
    93 						
    94 200B 20 D1 EC				JSR DETECT_IOL_CARD	; Check if IO-Basic ROM card is present
    95 200E 20 23 24				JSR PR_IOL_CARD		; Print status of IOL-card
    96 2011 20 AB 21				JSR PIA_DETECT	    	; check if PIA or ATF1504 MMU is present
    97 2014 B0 03				BCS CHECK_BASIC	    	; branch if no PIA or MMU is present
    98 						
    99 						; A 6520 PIA or MMU is present, check number of RAM-banks
   100 2016 20 03 22				JSR RAM_BANKS_DET   	; Get #RAM-banks present
   101
   102 2019 A5 15		CHECK_BASIC	LDA IOBASEH		; 0=not present
   103 201B F0 03				BEQ MAIN_LOOP		; branch if no IO-card detected
   104 						
   105 201D 20 17 24				JSR COPY_B0_C0		; update RAM-table with BASIC ROM info
   106 						
   107 				;----------------------------------------------------------------------------
   108 				; This is the main loop of the memory-test program, 
   109 				; it tests all memory-areas defined in RAM_TABLE.
   110 				;----------------------------------------------------------------------------
   111 2020 20 34 21		MAIN_LOOP	JSR READ_TABLE	    	; Read values from memory-table
   112 2023 B0 43				BCS MAIN_EXIT	    	; branch if all entries are Read
   113 						
   114 2025 20 70 23				JSR PR_INFO	    	; Print line of text to screen
   115 2028 A5 D6				LDA CHK_MODE	    	; check mode
   116 202A C9 01				CMP #TRAM              	; Test RAM
   117 202C D0 06				BNE MLP1	    	; branch if no RAM-Test
   118
   119 						; Option 1: Check RAM
   120 202E 20 72 20				JSR CHK_RAM_MAIN	; Now check memory for this entry
   121 2031 4C 64 20				JMP MCONT	    	; branch always
   122 					
   123 2034 C9 02		MLP1		CMP #TROM	    	; Test ROM
   124 2036 D0 25				BNE MLP4	    	; branch if no ROM-Test
   125
   126 						; Option 2: Check ROM and RAM behind it
   127 2038 20 81 20				JSR CHK_ROM_MAIN	; Test ROM
   128 203B A0 00				LDY #0			; init page index
   129 203D A5 D9				LDA PGCNTR+1		; get original page-counter
   130 203F C9 1C				CMP #$1C		; $1C00-$1FFF, Monitor ROM
   131 2041 D0 06				BNE MLP2
   132 						
   133 2043 20 B9 22				JSR MON_RAM_TEST	; test RAM behind monitor ROM
   134 2046 4C 64 20				JMP MCONT		; branch always
   135 						
   136 2049 C9 E0		MLP2		CMP #$E0		; $E000-$FFFF, BIOS ROM
   137 204B D0 06				BNE MLP3		
   138 						
   139 204D 20 EB 22				JSR BIOS_RAM_TEST	; test RAM behind BIOS ROM
   140 2050 4C 64 20				JMP MCONT
   141 						
   142 2053 C9 B0		MLP3		CMP #$B0		; test RAM behind BASIC ROM
   143 2055 D0 06				BNE MLP4
   144 						
   145 2057 20 1D 23				JSR BASIC_RAM_TEST	; Test RAM
   146 205A 4C 64 20				JMP MCONT		; branch always
   147
   148 205D C9 03		MLP4		CMP #TPIA		; 6520 PIA?
   149 205F D0 03				BNE MCONT		; branch if not PIA entry
   150
   151 2061 20 50 24				JSR PR_PIA_RESULT	; Print PIA result
   152 						;JMP MCONT
   153 						
   154 2064 E6 D7		MCONT		INC TBL_IDX	    	; next entry
   155 2066 D0 B8				BNE MAIN_LOOP	    	; branch always
   156
   157 2068 A5 C9		MAIN_EXIT	LDA MMU_BANKS		; Nr. of RAM-banks found
   158 206A F0 03				BEQ EXIT_MON	    	; branch if no RAM-banks to Test
   159 						
   160 206C 20 66 22				JSR RAM_BANKS_TEST  	; test all memory in RAM-banks
   161 206F 4C 03 E0		EXIT_MON	JMP MON_WARM_START  	; exit program, jump to JC monitor again
   162
   163 				;----------------------------------------------------------------------------
   164 				; This routine is the entry-point for the check RAM function.
   165 				;----------------------------------------------------------------------------
   166 2072 20 94 20		CHK_RAM_MAIN	JSR CHECK_RAM	    	; Now check memory for this entry
   167 2075 B0 03				BCS MAERR	    	; branch if error
   168 						
   169 2077 4C C8 23				JMP PR_RAM_OK	    	; Print RAM OK message and return
   170 					
   171 207A A9 D4		MAERR	    	LDA #<TXT_RAM_NOK   	; Print RAM error
   172 207C A0 25				LDY #>TXT_RAM_NOK
   173 207E 4C 10 24				JMP SPRINT          	; print and return
   174 						
   175 				;----------------------------------------------------------------------------
   176 				; This routine is the entry-point for the check ROM function.
   177 				;----------------------------------------------------------------------------
   178 2081 A0 30		CHK_ROM_MAIN	LDY #$30		; IOBASE+$30 selects BASIC ROM
   179 2083 B1 14				LDA (IOBASE),Y		; Switch to BASIC ROM area
   180 						
   181 2085 20 DE 20				JSR CHECK_ROM	    	; Now check memory for this entry
   182 2088 B0 07				BCS MOERR	    	; branch if error
   183 						
   184 208A A9 EE				LDA #<TXT_ROM_OK    	; Print ROM OK message
   185 208C A0 25				LDY #>TXT_ROM_OK
   186 208E 4C 10 24				JMP SPRINT          	; print and return
   187 					
   188 2091 4C FA 23		MOERR	    	JMP PR_ROM_ERR         	; print and return
   189 						
   190 				;----------------------------------------------------------------------------
   191 				; This routine checks a RAM area for errors.
   192 				; PGCNTR should be set to the RAM begin-address to check.
   193 				; X-register: Number of pages - 1 (1 page = 256 B) to check: 3 = 1K block.
   194 				; Y-register: Number of bytes to check (0 = 256 bytes) on the first page.
   195 				; Returns   : C=0: RAM-check ok
   196 				;             C=1: RAM error
   197 				;----------------------------------------------------------------------------
   198 2094 A6 D0		CHECK_RAM	LDX SAVEX
   199 2096 CA					DEX		    	; X = 3 => 4 pages to check
   200 2097 A4 D1				LDY SAVEY
   201 2099 B1 D8		CHECK_RAM_LP	LDA (PGCNTR),Y
   202 209B 85 DA				STA RAMSAV1         	; save value
   203 209D A9 55				LDA #$55            	; 0101 0101
   204 209F 91 D8				STA (PGCNTR),Y
   205 20A1 C8					INY
   206 20A2 B1 D8				LDA (PGCNTR),Y
   207 20A4 85 DB				STA RAMSAV2	    	; save value
   208 20A6 A9 AA				LDA #$AA	    	; 1010 1010
   209 20A8 91 D8				STA (PGCNTR),Y
   210 20AA 88					DEY		    	; Go back to previous RAM byte
   211 20AB B1 D8				LDA (PGCNTR),Y
   212 20AD C9 55				CMP #$55
   213 20AF D0 1B				BNE RAM_ERR	    	; branch on RAM error
   214 						
   215 20B1 A5 DA				LDA RAMSAV1
   216 20B3 91 D8				STA (PGCNTR),Y      	; restore original value
   217 20B5 C8					INY
   218 20B6 B1 D8				LDA (PGCNTR),Y
   219 20B8 C9 AA				CMP #$AA
   220 20BA D0 10				BNE RAM_ERR	    	; branch on RAM error
   221 						
   222 20BC A5 DB				LDA RAMSAV2
   223 20BE 91 D8				STA (PGCNTR),Y      	; restore original value
   224 						
   225 20C0 C8					INY		    	; next 2 bytes
   226 20C1 D0 D6				BNE CHECK_RAM_LP	; continue checking this page
   227 						
   228 						; 1 page done, no errors
   229 20C3 84 D8				STY PGCNTR          	; in case PGCNTR started halfway a page
   230 20C5 E6 D9				INC PGCNTR+1	    	; Next page
   231 20C7 CA					DEX		    	; number of pages to check - 1
   232 20C8 10 CF				BPL CHECK_RAM_LP      	; new page, continue checking
   233 						
   234 						; Entire RAM-area checked, no errors
   235 20CA 18					CLC		    	; C=0, no error
   236 20CB 60					RTS
   237 						
   238 20CC 98			RAM_ERR		TYA	
   239 20CD 85 D1				STA SAVEY		; save Y-value
   240 20CF 29 01				AND #$01	    	; Odd or Even?
   241 20D1 A8					TAY		    	; Y=0 (RAMSAV1) or 1 (RAMSAV2)
   242 20D2 B9 DA 00				LDA RAMSAV1,Y       	; restore value of memory byte
   243 20D5 48					PHA			; save restored value
   244 20D6 A5 D1				LDA SAVEY		; 
   245 20D8 A8					TAY			; get original Y value back
   246 20D9 68					PLA			; get restored value back again
   247 20DA 91 D8		                STA (PGCNTR),Y      	; not really need in case of error, just to be sure
   248 20DC 38					SEC		    	; C=1, error!
   249 20DD 60					RTS
   250
   251 				;----------------------------------------------------------------------------
   252 				; This routine calculates the checksum of the ROM area starting in PRBMSB and
   253 				; ends in PREMSB. The result is stored in ROM_CS.
   254 				;----------------------------------------------------------------------------
   255 20DE A6 D0		CHECK_ROM    	LDX SAVEX
   256 20E0 CA					DEX		    	; X = 3 => 4 pages to check
   257 20E1 A0 00				LDY #0   		
   258 20E3 84 CE				STY ROM_CS
   259 20E5 84 CF				STY ROM_CS+1
   260 20E7 84 CC				STY ROM_PTR
   261 20E9 A5 D4				LDA PRBMSB	    	; MSB of ROM begin-addres to check
   262 20EB 85 CD				STA ROM_PTR+1
   263 20ED B1 CC		ROM_LP1		LDA (ROM_PTR),Y	    	; get byte from ROM
   264 20EF 18					CLC
   265 20F0 65 CE				ADC ROM_CS	    	; add to LSB checksum
   266 20F2 85 CE				STA ROM_CS
   267 20F4 90 02				BCC ROM_LP2
   268 						
   269 20F6 E6 CF				INC ROM_CS+1        	; increment MSB
   270 20F8 C8			ROM_LP2		INY
   271 20F9 D0 F2				BNE ROM_LP1
   272
   273 20FB E6 CD				INC ROM_PTR+1	    	; next ROM page
   274 20FD CA					DEX
   275 20FE 10 ED				BPL ROM_LP1         	; branch if not done yet
   276
   277 2100 A5 CD				LDA ROM_PTR+1
   278 2102 F0 20				BEQ ROM_BIOS_CHK	; BIOS end-address = $FFFF + 1
   279 						
   280 2104 C9 20				CMP #$20	    	; end address JC Monitor program
   281 2106 D0 0E				BNE ROM_BASIC_CHK	; branch if not Monitor ROM
   282 						
   283 						; Compare checksum with JC Monitor ROM checksum
   284 2108 A5 CE		ROM_MON_CHK	LDA ROM_CS
   285 210A C9 65				CMP #<ROM_CS_MON
   286 210C D0 24				BNE ROM_ERR	    	; branch on error
   287 						
   288 210E A5 CF				LDA ROM_CS+1
   289 2110 C9 0E				CMP #>ROM_CS_MON
   290 2112 D0 1E				BNE ROM_ERR	    	; branch on error
   291 2114 F0 1A				BEQ ROM_NOERR	    	; branch always
   292
   293 						; Compare checksum with BASIC ROM checksum
   294 2116 A5 CE		ROM_BASIC_CHK	LDA ROM_CS
   295 2118 C9 4C				CMP #<ROM_CS_BASIC
   296 211A D0 16				BNE ROM_ERR		; branch on error
   297 						
   298 211C A5 CF				LDA ROM_CS+1
   299 211E C9 80				CMP #>ROM_CS_BASIC
   300 2120 D0 10				BNE ROM_ERR		; branch on error
   301 2122 F0 0C				BEQ ROM_NOERR		; branch always
   302 						
   303 						; Compare checksum with JC2 BIOS ROM checksum
   304 2124 A5 CE		ROM_BIOS_CHK	LDA ROM_CS
   305 2126 C9 C3				CMP #<ROM_CS_BIOS
   306 2128 D0 08				BNE ROM_ERR	    	; branch on error
   307 						
   308 212A A5 CF				LDA ROM_CS+1
   309 212C C9 65				CMP #>ROM_CS_BIOS
   310 212E D0 02				BNE ROM_ERR	    	; branch on error
   311
   312 2130 18			ROM_NOERR	CLC		    	; ROM checksum OK
   313 2131 60					RTS		    	; return
   314
   315 2132 38			ROM_ERR		SEC		    	; ROM checksum error
   316 2133 60					RTS		    	; return
   317
   318 				;----------------------------------------------------------------------------
   319 				; This routine reads an entry from the memory-table.
   320 				; TBL_IDX is the index number and should be set to the RAM begin-address 
   321 				; to check. This routine updates the following:
   322 				; PGCNTR    : MSB is set to the begin-area in RAM to check
   323 				; CHK_MODE  : The mode selected (NO, RAM or ROM check)
   324 				; X-register: is set to the number of pages (256 B) to check
   325 				; Y-register: is set to the number of bytes to check on the 1st page (0 = all)
   326 				; Returns   : C=0: ok, C=1: TBL_IDX = TBL_MAX
   327 				;----------------------------------------------------------------------------
   328 2134 A9 00		READ_TABLE	LDA #0
   329 2136 85 D1				STA SAVEY           	; 0 = default value (full page)
   330 2138 85 D8				STA PGCNTR		; Init. page-counter to full page
   331 213A A6 D7				LDX TBL_IDX         	; get current index
   332 213C E0 11				CPX #TBL_MAX	    	; max. entries in memory table
   333 213E 90 01				BCC TBL1	    	; branch if TBL_IDX < TBL1
   334 							
   335 2140 60					RTS		    	; error (C=1), return
   336 						
   337 2141 E0 00		TBL1		CPX #0
   338 2143 F0 07				BEQ TBL2	    	; X=0? then exit multiply loop
   339 						
   340 2145 18			TBL1A		CLC
   341 2146 69 05				ADC #TBL1_SZ	    	;
   342 2148 CA					DEX
   343 2149 D0 FA				BNE TBL1A           	; branch always
   344
   345 214B AA			 		TAX		    	; X = TBL1_SZ * TBL_IDX
   346
   347 214C BD 97 24		TBL2		LDA RAM_TABLE,X	    	; RAM_TABLE[TBL_IDX].mode
   348 214F C9 80				CMP #TRIOT	    	; half a page to check?
   349 2151 D0 04				BNE TBL_FP         	; branch if not $80
   350 						
   351 2153 85 D1				STA SAVEY	    	; Y = $80 (half page)
   352 2155 A9 01				LDA #TRAM	    	; 1 = normal RAM-check
   353 						
   354 2157 85 D6		TBL_FP		STA CHK_MODE	    
   355 2159 E8					INX		    	; next entry in table (print begin-address)
   356 215A BD 97 24				LDA RAM_TABLE,X	    	; print begin-address MSB
   357 215D 85 D4				STA PRBMSB
   358 215F E8					INX		    	; next entry in table (RAM check begin-address)
   359 2160 BD 97 24				LDA RAM_TABLE,X	    	; RAM-check begin-address MSB
   360 2163 85 D9				STA PGCNTR+1        	; begin-address MSB for RAM-check
   361 2165 E8					INX		    	; next entry in table (pointer to print text)
   362 2166 BD 97 24				LDA RAM_TABLE,X	    	; pointer to print-text LSB
   363 2169 85 D2				STA PPSTR	    	; init. screen pointer LSB
   364 216B E8					INX 
   365 216C BD 97 24				LDA RAM_TABLE,X	    	; pointer to print-text MSB
   366 216F 85 D3				STA PPSTR+1         	; pointer to print-text MSB
   367 						
   368 2171 A5 D7				LDA TBL_IDX
   369 2173 C9 10				CMP #TBL_MAX-1
   370 2175 D0 0E				BNE TBL_NEND	    	; branch if not the last entry in the table
   371 						
   372 						;-------------------------------------------------------------
   373 						; This is the last entry in the memory table.
   374 						; Set Print end-address to $FF and number of
   375 						; pages to check to one-complement of PGCNTR+1
   376 						;-------------------------------------------------------------
   377 2177 A9 FF				LDA #$FF
   378 2179 85 D5				STA PREMSB	    	; Print end-address
   379 217B A5 D9				LDA PGCNTR+1	    	; MSB begin-address for RAM-check
   380 217D 49 FF				EOR #$FF	    	; one-complement
   381 217F 18					CLC
   382 2180 69 01				ADC #1		    	; two-complement
   383 2182 AA					TAX	 	    	; X = #pages till $FFFF
   384 2183 D0 22				BNE TBL_EXIT	    	; branch always
   385
   386 						;-------------------------------------------------------------
   387 						; This is NOT the last entry in the memory table.
   388 						; Set Print end-address to begin-address of next entry - 1 
   389 						; and number of pages to begin-address next entry - begin-address
   390 						; for RAM-check in the current entry.
   391 						;-------------------------------------------------------------
   392 2185 E8			TBL_NEND	INX		    	; now at mode next entry in memory-table
   393 2186 E8					INX		    	; now at MSB of print begin-address next entry
   394 2187 BD 97 24				LDA RAM_TABLE,X	    	; also the MSB end-address of the current entry
   395 218A 85 D5				STA PREMSB	    	; save print end-address
   396 218C 48					PHA                 	; save A
   397 218D 38					SEC
   398 218E E5 D4				SBC PRBMSB	    	; size in KB
   399 2190 85 CB				STA KB              	; save size
   400 2192 C6 D5				DEC PREMSB	    	; end-address = next begin-address - 1
   401 2194 68					PLA                 	; get value back
   402 2195 38					SEC
   403 2196 E5 D9				SBC PGCNTR+1
   404 2198 AA					TAX 		    	; X = #pages to check
   405 						
   406 						; Now check for 6532 128 bytes only RAM-check
   407 2199 A4 D1				LDY SAVEY	    	; this is 0 (full-page) or $80 (6532 half-page)
   408 219B C0 80				CPY #TRIOT
   409 219D D0 08				BNE TBL_EXIT	    	; branch if normal area
   410 						
   411 219F A2 01				LDX #1		    	; 1 (half) page to check
   412 21A1 C6 D9				DEC PGCNTR+1	    	; PGCNTR -= 128
   413 21A3 84 D8				STY PGCNTR	    	; 
   414 21A5 84 CB				STY KB              	; 128 B size
   415 						
   416 21A7 86 D0		TBL_EXIT	STX SAVEX	    	; save X-register
   417 21A9 18					CLC		    	; C=0, no errors
   418 21AA 60					RTS		    	; and return
   419 						
   420 				;----------------------------------------------------------------------------
   421 				; This routine checks if the 6520 PIA from the MMU is present.
   422 				;----------------------------------------------------------------------------
   423 21AB AD 02 16		PIA_DETECT	LDA COMM_REG       	; ACIA command register at $1602
   424 21AE 48					PHA		   	; save value
   425 21AF 49 FF				EOR #$FF 	   	; invert all bits
   426 21B1 8D 02 17				STA DDRB	   	; PIA DDRB register at $1702 or MMU-register
   427 21B4 CD 02 16				CMP COMM_REG	   	; If ACIA and (PIA or MMU) are present, value is different 
   428 21B7 D0 06				BNE PIA_DET2	   	; branch if PIA or MMU are present
   429 						
   430 						; no PIA or MMU present
   431 21B9 68					PLA		   	; restore value
   432 21BA 8D 02 16				STA COMM_REG	   	;
   433 21BD 38			NO_PIA_DET	SEC		   	; C=1, error, no PIA
   434 21BE 60					RTS
   435 						
   436 21BF 68			PIA_DET2	PLA		   	; restore previous value
   437 21C0 8D 02 16				STA COMM_REG	   	;
   438 						
   439 						; Area at $1700-$17FF either contains nothing, a PIA or the MMU-register
   440 21C3 20 E8 21				JSR PIA_INIT		; Init. the 6520 PIA output ports
   441 21C6 AD 02 17				LDA PORTB		; PIA PORTB or MMU-register
   442 21C9 C9 03				CMP #NO_RAMBANK		; PORTB init. value
   443 21CB D0 F0				BNE NO_PIA_DET		; if not, no PIA or MMU-register present
   444
   445 						; CRB bit 2 = 1 => PIA present
   446 						; CRB bit 2 = 0 => MMU-register present
   447 21CD AD 03 17				LDA CRB			; PIA CRB register (or MMU-register)
   448 21D0 29 04				AND #4			; test bit 2
   449 21D2 F0 04				BEQ MMU_REG		; branch if no PIA present
   450 						
   451 21D4 A9 80				LDA #$80		; $80 = PIA present
   452 21D6 D0 0C				BNE PIA_DET_END		; branch always
   453
   454 21D8 A9 60		MMU_REG		LDA #<TXT_MMU		; MMU text instead of PIA text
   455 21DA 8D B8 24				STA TBL_PIA_TXT		; LSB of text-pointer
   456 21DD A9 25				LDA #>TXT_MMU		;
   457 21DF 8D B9 24				STA TBL_PIA_TXT+1	; MSB of text-pointer
   458 21E2 A9 C0				LDA #$C0		; $C0 = MMU register (ATF1504) present
   459 						
   460 21E4 85 C7		PIA_DET_END	STA PIA_PRESENT		; $80 = PIA present, $C0 = ATF1504 MMU present
   461 21E6 18					CLC		   	; C=0, PIA or MMU is present
   462 21E7 60					RTS
   463
   464 				;----------------------------------------------------------------------------
   465 				; This routine initializes the 6520 PIA.
   466 				;----------------------------------------------------------------------------
   467 21E8 AD 03 17		PIA_INIT	LDA CRB            	; PIA control register B
   468 21EB 29 FB				AND #$FB	   	; CRB-2=0: select DDRB (MMU: MA14=0)
   469 21ED 8D 03 17				STA CRB
   470 21F0 A9 7F				LDA #$7F           	; PB6..PB0 are all output (MMU: MA17..14=1)
   471 21F2 8D 02 17				STA DDRB
   472 21F5 AD 03 17				LDA CRB
   473 21F8 09 04				ORA #$04	   	; CRB-2=1: select PORTB (MMU: MA14=1)
   474 21FA 8D 03 17				STA CRB
   475 21FD A9 03				LDA #NO_RAMBANK	   	; BIOS and Monitor ROM are enabled
   476 21FF 8D 02 17				STA PORTB	   	; Start with RAM-bank R1 in main-64K
   477 2202 60					RTS			; and return
   478 						
   479 				;----------------------------------------------------------------------------
   480 				; This routine checks how many RAM-banks are present. The result is
   481 				; stored in MMU_BANKS.
   482 				;----------------------------------------------------------------------------
   483 2203 20 44 22		RAM_BANKS_DET	JSR DET_628128		; start with detection of 628128 SRAM
   484 2206 90 0B				BCC NORMAL_RAM		; C=0, normal RAM
   485 						
   486 2208 A9 76				LDA #<TXT_628128    	; Print 628128 RAM IC found
   487 220A A0 27				LDY #>TXT_628128
   488 220C 20 10 24				JSR SPRINT	   	; print
   489
   490 220F A9 04				LDA #4			; 4 RAM-banks present
   491 2211 D0 28				BNE RAMB_DONE		; branch always
   492 						
   493 2213 A9 00		NORMAL_RAM	LDA #0			; 
   494 2215 8D 00 40				STA $4000          	; Init. first byte in RAM-bank
   495 2218 AA					TAX 	   		; First RAM-bank
   496 2219 BD 7B 24		RAMB_LP1	LDA RAMB_TABLE,X   	; get value for PORTB
   497 221C 8D 02 17				STA PORTB	   	; select RAM-bank
   498 221F 8E 00 40				STX $4000	   	; First byte in RAM-bank
   499 2222 E8					INX
   500 2223 E0 1C				CPX #28		   	; table done?
   501 2225 D0 F2				BNE RAMB_LP1	   	; branch if not done yet
   502 						
   503 2227 A9 03				LDA #NO_RAMBANK	   	; Main-bank, no RAM-bank
   504 2229 8D 02 17				STA PORTB
   505 						
   506 						; Load the value in the main RAM-bank again.
   507 						; 27=none, 23=4 banks (64K), 15=12 banks, 0 = 28 banks
   508 222C AD 00 40				LDA $4000 	   
   509 222F D0 04				BNE RAMB_LP2
   510 						
   511 2231 A9 1C				LDA #28		   	; 28 RAM-banks found
   512 2233 D0 06				BNE RAMB_DONE		; branch always
   513 						
   514 2235 A9 1B		RAMB_LP2	LDA #27
   515 2237 38					SEC
   516 2238 ED 00 40				SBC $4000               ; A = 27-X
   517 223B C9 1D		RAMB_DONE	CMP #29			; safety check
   518 223D 90 02				BCC MMU_OK		; branch if A < 29
   519 						
   520 223F A9 00				LDA #0			; error, set MMU_BANKS to 0
   521 2241 85 C9		MMU_OK		STA MMU_BANKS	    		
   522 2243 60					RTS
   523
   524 				;----------------------------------------------------------------------------
   525 				; This routine detects the presence of a 628128 SRAM (128Kx8). This is the
   526 				; default RAM for the JC2. If used in the 512K PCB, !MA17 is connected to
   527 				; CS2. So if MA17=1, the entire RAM is deselected. Any other RAM just 
   528 				; selects a RAM-bank.
   529 				;----------------------------------------------------------------------------
   530 2244 AD FF 3F		DET_628128	LDA $3FFF		; This is always RAM in every JC2 configuration
   531 2247 48					PHA			; save for now
   532 2248 A9 55				LDA #$55
   533 224A 8D FF 3F				STA $3FFF		; No RAM-bank, just normal RAM
   534 224D A9 23				LDA #$23		; MA17=1, RAM-bank enabled or RAM-deselected
   535 224F 8D 02 17				STA PORTB		; This is either PORTB or the MMU-register
   536 2252 AE FF 3F				LDX $3FFF		; Now find out
   537 						
   538 2255 A9 03				LDA #NO_RAMBANK		; select normal RAM again
   539 2257 8D 02 17				STA PORTB
   540 225A 68					PLA			; get saved value
   541 225B 8D FF 3F				STA $3FFF		; and restore it
   542 						
   543 225E E0 55				CPX #$55		; Same number again?
   544 2260 D0 02				BNE NO_RAM		; branch if 628128 detected
   545 						
   546 2262 18					CLC			; C=0, normal RAM detected
   547 2263 60					RTS			; and return
   548 						
   549 2264 38			NO_RAM		SEC			; C=1, 628128 RAM detected
   550 2265 60					RTS			; and return
   551 						
   552 				;----------------------------------------------------------------------------
   553 				; This routine tests the memory of every RAM-bank present.
   554 				;----------------------------------------------------------------------------
   555 2266 A9 0D		RAM_BANKS_TEST	LDA #CR			; empty line
   556 2268 20 52 E0				JSR COUT
   557 226B A9 00				LDA #0
   558 226D 85 C8				STA BCNTR          	; init ram-bank counter
   559
   560 226F AA			RB_TST1		TAX		   	; ram-bank counter
   561 2270 BD 7B 24				LDA RAMB_TABLE,X   	; get value for PORTB
   562 2273 8D 02 17				STA PORTB	   	; enable RAM-bank
   563 						
   564 2276 A9 7F				LDA #<TXT_RAMB1    	; Print RAM-bank number
   565 2278 A0 26				LDY #>TXT_RAMB1
   566 227A 20 10 24				JSR SPRINT	   	; print
   567 227D A5 C8				LDA BCNTR	   	;  
   568 227F 20 B7 23				JSR NUMOUT2	   	; print current ram-bank number
   569 2282 A9 3A				LDA #':'
   570 2284 20 52 E0				JSR COUT
   571 2287 A9 20				LDA #' '
   572 2289 20 52 E0				JSR COUT
   573 						
   574 228C A0 00				LDY #0	           	; 0 = full-page
   575 228E 84 D8				STY PGCNTR		; Zero LSB of PGCNTR
   576 2290 A2 40				LDX #$40	   	; 
   577 2292 86 D9				STX PGCNTR+1	   	; RAM-bank starts at $4000
   578 2294 CA					DEX                     ; X=$3F => $40 pages = 16K
   579 2295 20 99 20				JSR CHECK_RAM_LP   	; test memory in RAM-bank
   580
   581 2298 B0 0A				BCS RBTST_ERR	   	; branch if error
   582 						
   583 229A A9 89				LDA #<TXT_RAMB_OK  	; Print RAM-bank OK
   584 229C A0 26				LDY #>TXT_RAMB_OK
   585 229E 20 10 24				JSR SPRINT	   	; Print RAM OK message
   586 22A1 4C AB 22				JMP RBTST_CNT
   587 					
   588 22A4 A9 97		RBTST_ERR    	LDA #<TXT_RAMB_NOK 	; Print RAM-bank error
   589 22A6 A0 26				LDY #>TXT_RAMB_NOK
   590 22A8 20 10 24				JSR SPRINT	   	; Print error text
   591 						
   592 22AB E6 C8		RBTST_CNT	INC BCNTR	   	; increment RAM-bank counter
   593 22AD A5 C8				LDA BCNTR
   594 22AF C5 C9				CMP MMU_BANKS      	; all banks done?
   595 22B1 D0 BC				BNE RB_TST1        	; branch if not all banks done
   596 						
   597 22B3 A9 03				LDA #NO_RAMBANK	   	; BIOS and Monitor ROM are enabled
   598 22B5 8D 02 17				STA PORTB	   	; Disable RAM-banks
   599 22B8 60					RTS		   	; return
   600
   601 				;----------------------------------------------------------------------------
   602 				; This routine tests the memory behind the Monitor ROM.
   603 				;----------------------------------------------------------------------------
   604 22B9 A9 AE		MON_RAM_TEST	LDA #<TXT_MONRAM1  	;
   605 22BB A0 26				LDY #>TXT_MONRAM1
   606 22BD 20 10 24				JSR SPRINT	   	; print
   607 						
   608 22C0 78					SEI		   	; disable interrupts
   609 22C1 AD 02 17				LDA PORTB
   610 22C4 29 FD				AND #~MON_EN	   
   611 22C6 8D 02 17				STA PORTB	   	; disable monitor ROM, enable RAM behind it
   612 						
   613 22C9 A2 03				LDX #$03   	   	; 03 = 4 pages = 1K
   614 22CB A0 00				LDY #0	           	; 0 = full-page
   615 22CD 20 99 20				JSR CHECK_RAM_LP   	; test memory in RAM-bank
   616 22D0 08					PHP		   	; save processor status
   617 						
   618 22D1 AD 02 17				LDA PORTB
   619 22D4 09 02				ORA #MON_EN	   	; enable monitor ROM again
   620 22D6 8D 02 17				STA PORTB
   621 22D9 58					CLI		   	; enable interrupts again
   622 						
   623 22DA 28					PLP		   	; get processor status again
   624 22DB B0 07				BCS MONRAM_ERR	   	; branch if error
   625 						
   626 22DD A9 DF				LDA #<TXT_MONRAM_OK 	; RAM-bank OK
   627 22DF A0 26				LDY #>TXT_MONRAM_OK
   628 22E1 4C 10 24				JMP SPRINT          	; Print Monitor RAM OK message and return
   629 					
   630 22E4 A9 EC		MONRAM_ERR    	LDA #<TXT_MONRAM_NOK 	; Print RAM-bank error
   631 22E6 A0 26				LDY #>TXT_MONRAM_NOK
   632 22E8 4C 10 24				JMP SPRINT           	; Print error text and return
   633
   634 				;----------------------------------------------------------------------------
   635 				; This routine tests the memory behind the BIOS ROM.
   636 				;----------------------------------------------------------------------------
   637 22EB A9 FE		BIOS_RAM_TEST	LDA #<TXT_BIOSRAM1 	; First part of text
   638 22ED A0 26				LDY #>TXT_BIOSRAM1
   639 22EF 20 10 24				JSR SPRINT	   	; print
   640 						
   641 22F2 78					SEI		   	; disable interrupts
   642 22F3 AD 02 17				LDA PORTB
   643 22F6 29 FE				AND #~BIOS_EN	   
   644 22F8 8D 02 17				STA PORTB	   	; disable BIOS ROM, enable RAM behind it
   645 						
   646 22FB A2 1F				LDX #$1F   	   	; $1F = $20 pages = 8K
   647 22FD A0 00				LDY #0	           	; 0 = full-page
   648 22FF 20 99 20				JSR CHECK_RAM_LP   	; test memory in RAM-bank
   649 2302 08					PHP		   	; save processor status
   650 						
   651 2303 AD 02 17				LDA PORTB
   652 2306 09 01				ORA #BIOS_EN	   	; enable BIOS ROM again
   653 2308 8D 02 17				STA PORTB
   654 230B 58					CLI		   	; enable interrupts again
   655 						
   656 230C 28					PLP		   	; get processor status again
   657 230D B0 07				BCS BIOSRAM_ERR	   	; branch if error
   658 						
   659 230F A9 2C				LDA #<TXT_BIOSRAM_OK  	; Print RAM OK
   660 2311 A0 27				LDY #>TXT_BIOSRAM_OK
   661 2313 4C 10 24				JMP SPRINT            	; Print BIOS RAM OK message and return
   662 					
   663 2316 A9 EC		BIOSRAM_ERR    	LDA #<TXT_BIOSRAM_NOK	; Print RAM error
   664 2318 A0 26				LDY #>TXT_BIOSRAM_NOK
   665 231A 4C 10 24				JMP SPRINT            	; Print error text and return
   666
   667 				;----------------------------------------------------------------------------
   668 				; This routine tests the memory behind the BASIC ROM.
   669 				;----------------------------------------------------------------------------
   670 231D A9 39		BASIC_RAM_TEST	LDA #<TXT_BASICRAM1 	; First part of text
   671 231F A0 27				LDY #>TXT_BASICRAM1
   672 2321 20 10 24				JSR SPRINT	   	; print
   673 						
   674 2324 A0 20				LDY #$20		; IOBASE + $20 selects RAM area
   675 2326 B1 14				LDA (IOBASE),Y		; switch to RAM	   
   676 						
   677 2328 A2 2F				LDX #$2F   	   	; $2F = $30 pages = 12K
   678 232A A0 00				LDY #0	           	; 0 = full-page
   679 232C 20 99 20				JSR CHECK_RAM_LP   	; test memory in RAM-bank
   680 232F 08					PHP		   	; save processor status
   681 						
   682 2330 A0 30				LDY #$30		; IOBASE + $30 selects ROM area
   683 2332 B1 14				LDA (IOBASE),Y		; switch to ROM again	   
   684 						
   685 2334 28					PLP		   	; get processor status again
   686 2335 B0 07				BCS BASICRAM_ERR   	; branch if error
   687 						
   688 2337 A9 68				LDA #<TXT_BASICRAM_OK  	; Print RAM OK
   689 2339 A0 27				LDY #>TXT_BASICRAM_OK
   690 233B 4C 10 24				JMP SPRINT            	; Print BIOS RAM OK message and return
   691 					
   692 233E A9 EC		BASICRAM_ERR   	LDA #<TXT_BASICRAM_NOK	; Print RAM error
   693 2340 A0 26				LDY #>TXT_BASICRAM_NOK
   694 2342 4C 10 24				JMP SPRINT            	; Print error text and return
   695
   696 				;----------------------------------------------------------------------------
   697 				; This routine prints the title text and detects the CPU-type.
   698 				;----------------------------------------------------------------------------
   699 2345 A9 F1		PR_TITLE	LDA #<TXT_TITLE     	; Print block nr
   700 2347 A0 24				LDY #>TXT_TITLE
   701 2349 20 10 24				JSR SPRINT	    	; print
   702 						
   703 234C A9 99				LDA #$99	    	; test for NMOS or CMOS
   704 234E 18					CLC
   705 234F F8					SED
   706 2350 69 01				ADC #$01
   707 2352 D8					CLD
   708 2353 F0 07				BEQ CPU_CMOS	    	; 0 = CMOS
   709
   710 2355 A9 33				LDA #<TXT_6502      	; Print 6502 NMOS found
   711 2357 A0 26				LDY #>TXT_6502
   712 2359 4C 10 24				JMP SPRINT	    	; print and return
   713
   714 						OPT C+		    	; enable 65816 instructions
   715 235C A9 00		CPU_CMOS	LDA #0
   716 235E C2 02				rep #%00000010	    	; set Z-bit again
   717 2360 D0 07				BNE CPU_816
   718 						
   719 2362 A9 3E				LDA #<TXT_65C02     	; Print block nr
   720 2364 A0 26				LDY #>TXT_65C02
   721 2366 4C 10 24				JMP SPRINT	    	; print and return
   722
   723 2369 A9 4A		CPU_816		LDA #<TXT_65816     	; Print block nr
   724 236B A0 26				LDY #>TXT_65816
   725 236D 4C 10 24				JMP SPRINT	    	; print and return
   726 						OPT C-		    	; disable 65816 instructions
   727 						
   728 				;----------------------------------------------------------------------------
   729 				; This routine prints a line of text for a block. The text to
   730 				; print is already stored in PSTR by the READ_TABLE routine.
   731 				;----------------------------------------------------------------------------
   732 2370 A9 2F		PR_INFO		LDA #<TXT1          	; Print block nr
   733 2372 A0 25				LDY #>TXT1
   734 2374 20 10 24				JSR SPRINT
   735 2377 A5 D7				LDA TBL_IDX	    	; use table index as block number
   736 2379 20 91 E0				JSR HEXOUT          	; print block nr = page nr/4
   737 237C A9 37				LDA #<TXT1A          
   738 237E A0 25				LDY #>TXT1A
   739 2380 20 10 24				JSR SPRINT 		
   740 						
   741 2383 A5 D4				LDA PRBMSB
   742 2385 20 91 E0				JSR HEXOUT          	; print block begin-address
   743 2388 A9 3B				LDA #<TXT1B          
   744 238A A0 25				LDY #>TXT1B
   745 238C 20 10 24				JSR SPRINT 
   746 						
   747 238F A5 D5				LDA PREMSB
   748 2391 20 91 E0				JSR HEXOUT          	; print block end-address
   749 2394 A9 40				LDA #<TXT1C          
   750 2396 A0 25				LDY #>TXT1C
   751 2398 20 10 24				JSR SPRINT
   752 						
   753 239B A5 D7				LDA TBL_IDX	    	; Check for K2, K3 or K4 IO-Area
   754 239D F0 11				BEQ PP1		    	; branch if TBL_IDX = 0
   755 						
   756 239F C9 04				CMP #4
   757 23A1 B0 0D				BCS PP1	    	    	; branch if TBL_IDX > 3
   758 						
   759 						; K2, K3 or K4 area
   760 23A3 A9 4B				LDA #'K'
   761 23A5 20 52 E0				JSR COUT
   762 23A8 A5 D7				LDA TBL_IDX
   763 23AA 18					CLC
   764 23AB 69 31				ADC #'1'	    	; TBL_IDX=1,2,3 => K2,K3,K4
   765 23AD 20 52 E0				JSR COUT	    	; Print K number
   766 						
   767 23B0 A5 D2		PP1		LDA PPSTR	    	; Pointer to 2nd part text to print
   768 23B2 A4 D3				LDY PPSTR+1
   769 23B4 4C 10 24				JMP SPRINT	    	; Print last part and return
   770
   771 				; **** Print A Byte As Decimal Number ******************************************
   772 				; Input: A - number 00..63 (0..99)
   773 				; ******************************************************************************
   774 23B7 20 BD E0		NUMOUT2		JSR	DEC2STR
   775 23BA A5 F9			        LDA 	DIG1
   776 23BC C9 30				CMP 	#'0'
   777 23BE F0 03				BEQ	NU20		; no -leading-zero
   778
   779 23C0 20 44 E0				JSR	BOUT
   780 23C3 A5 F8		NU20:		LDA	DIG0
   781 23C5 4C 44 E0				JMP	BOUT		; print and return
   782
   783 				;----------------------------------------------------------------------------
   784 				; This routine prints a RAM OK message.
   785 				;----------------------------------------------------------------------------
   786 23C8 A5 CB		PR_RAM_OK       LDA KB		    	; size in KB or B
   787 23CA C9 64				CMP #100
   788 23CC 90 0A				BCC PRKB            	; branch if size in KB
   789 						
   790 23CE 20 A7 E0				JSR NUMOUT	    	; print size in bytes
   791 23D1 A9 C5		PR_RAM1		LDA #<TXT_RAM_OK    	; Print ' bytes RAM OK' message
   792 23D3 A0 25				LDY #>TXT_RAM_OK
   793 23D5 4C 10 24				JMP SPRINT          	; print and return
   794 						
   795 23D8 C9 04		PRKB		CMP #4
   796 23DA 90 0C				BCC PR512
   797 						
   798 23DC 4A					LSR
   799 23DD 4A					LSR
   800 23DE 20 B7 23				JSR NUMOUT2	    	; print size in KB
   801 23E1 A9 B9				LDA #<TXT_RAMKB_OK    	; Print RAM OK message
   802 23E3 A0 25				LDY #>TXT_RAMKB_OK
   803 23E5 4C 10 24				JMP SPRINT          	; print and return
   804
   805 23E8 A9 35		PR512		LDA #'5'	    	; 2 pages = 512 bytes
   806 23EA 20 52 E0				JSR COUT
   807 23ED A9 31				LDA #'1'
   808 23EF 20 52 E0				JSR COUT
   809 23F2 A9 32				LDA #'2'
   810 23F4 20 52 E0				JSR COUT
   811 23F7 4C D1 23				JMP PR_RAM1         	; print '512 bytes RAM OK'
   812 						
   813 				;----------------------------------------------------------------------------
   814 				; This routine prints a ROM ERROR message.
   815 				;----------------------------------------------------------------------------
   816 23FA A9 FF		PR_ROM_ERR      LDA #<TXT_ROM_NOK   	; Print ROM error
   817 23FC A0 25				LDY #>TXT_ROM_NOK
   818 23FE 20 10 24				JSR SPRINT
   819 2401 A5 CF				LDA ROM_CS+1
   820 2403 20 91 E0				JSR HEXOUT
   821 2406 A5 CE				LDA ROM_CS
   822 2408 20 91 E0				JSR HEXOUT	    
   823 240B A9 0D				LDA #CR
   824 240D 4C 52 E0				JMP COUT	    	; print and return
   825 						
   826 				;----------------------------------------------------------------------------
   827 				; This routine prints a string to the terminal
   828 				;----------------------------------------------------------------------------
   829 2410 85 EA		SPRINT		STA PSTR	    	; LSB of text-pointer
   830 2412 84 EB				STY PSTR+1	    	; MSB of text-pointer
   831 2414 4C 83 E0				JMP STROUT	    	; BIOS print string routine
   832 						
   833 				;----------------------------------------------------------------------------
   834 				; This routine copies the entry for the BASIC ROM aread into the RAM-table
   835 				;----------------------------------------------------------------------------
   836 2417 A2 04		COPY_B0_C0	LDX #4
   837 2419 BD EC 24		COPY_LP1	LDA RAM_TABLE_B0,X	; Get info for $B000-$DFFF area
   838 241C 9D E2 24				STA RAM_TABLE_C0,X	; and overwrite $C000-$DFFF area
   839 241F CA					DEX
   840 2420 10 F7				BPL COPY_LP1		; branch if not done yet
   841 2422 60					RTS			; return
   842 						
   843 				;----------------------------------------------------------------------------
   844 				; This routine prints the result of the BASIC-IO card detection, 
   845 				; including the number of RAM-banks found.
   846 				;----------------------------------------------------------------------------
   847 2423 A9 8F		PR_IOL_CARD	LDA #<TXT_IOL1      	; Print 1st part of message
   848 2425 A0 27				LDY #>TXT_IOL1
   849 2427 20 10 24				JSR SPRINT          	; print and return
   850 242A A5 15				LDA IOBASEH
   851 242C F0 1B				BEQ IOL_NOK		; 0 = no card detected
   852 						
   853 242E A9 9F				LDA #<TXT_IOL_OK      	; Print 2nd part of message
   854 2430 A0 27				LDY #>TXT_IOL_OK
   855 2432 20 10 24				JSR SPRINT
   856 2435 A5 15				LDA IOBASEH
   857 2437 20 91 E0				JSR HEXOUT		; print base-address
   858 243A A9 00				LDA #$00
   859 243C 20 91 E0				JSR HEXOUT
   860 243F A9 0D				LDA #CR			; print 2xCR and return
   861 2441 20 52 E0				JSR COUT
   862 2444 A9 0D				LDA #CR
   863 2446 4C 52 E0				JMP COUT
   864
   865 2449 A9 AD		IOL_NOK		LDA #<TXT_IOL_NOK      	; Print 2nd part of message
   866 244B A0 27				LDY #>TXT_IOL_NOK
   867 244D 4C 10 24				JMP SPRINT		; print and return
   868 						
   869 				;----------------------------------------------------------------------------
   870 				; This routine prints the results of the PIA detection.
   871 				;----------------------------------------------------------------------------
   872 2450 A5 C7		PR_PIA_RESULT	LDA PIA_PRESENT
   873 2452 D0 07				BNE PR_PIA_PRES		; branch if PIA present
   874
   875 2454 A9 70				LDA #<TXT_PIA_NOT
   876 2456 A0 26				LDY #>TXT_PIA_NOT
   877 2458 20 10 24				JSR SPRINT		; print 'not'
   878 						
   879 245B A9 75		PR_PIA_PRES	LDA #<TXT_PIA_DET
   880 245D A0 26				LDY #>TXT_PIA_DET
   881 245F 20 10 24				JSR SPRINT		; print 'detected'
   882 						
   883 2462 A5 C9				LDA MMU_BANKS	    	; #RAM-banks found
   884 2464 C9 0A				CMP #10
   885 2466 90 06				BCC PR_PIA_LT10		; branch if 0-9 RAM-banks found
   886 						
   887 2468 20 B7 23				JSR NUMOUT2	    	; >= 10, print 2-digit number
   888 246B 4C 74 24				JMP PR_PIA_RB1
   889 						
   890 246E 18			PR_PIA_LT10	CLC		    	; < 10, print 1-digit number
   891 246F 69 30				ADC #'0'
   892 2471 20 52 E0				JSR COUT
   893 						
   894 2474 A9 5E		PR_PIA_RB1	LDA #<TXT_PIA2      	; Print 2nd part of message
   895 2476 A0 26				LDY #>TXT_PIA2
   896 2478 4C 10 24				JMP SPRINT          	; print and return
   897
   898 				;--------------------------------------------------------------------------
   899 				; This table defines all PORTB values for the RAM-banks in the JC2 system.
   900 				; RAM-banks are numbered from R4..R28.
   901 				;--------------------------------------------------------------------------
   902 247B 13 17 1B 1F 23 27 + RAMB_TABLE	.byte $13,$17,$1B,$1F,$23,$27,$2B,$2F
   903 2483 33 37 3B 3F 43 47 +                 .byte $33,$37,$3B,$3F,$43,$47,$4B,$4F
   904 248B 53 57 5B 5F 63 67 +                 .byte $53,$57,$5B,$5F,$63,$67,$6B,$6F
   905 2493 73 77 7B 7F		                .byte $73,$77,$7B,$7F
   906 						
   907 				;--------------------------------------------------------------------------
   908 				; This table defines all memory areas of the JC2 computer system
   909 				; Entries are: Mode, Block begin MSB, Check begin MSB, text pointer
   910 				;--------------------------------------------------------------------------
   911 2497 01 00 02		RAM_TABLE	.byte $01, $00, $02     ; $0000 - $07FF, check from $0200
   912 249A 2E 25				.word TXT0
   913 = 0005			TBL1_SZ = (*-RAM_TABLE)		
   914 249C 00 08 08				.byte TNO, $08, $08     ; $0800 - $0BFF, K2 IO-area, no RAM-check  
   915 249F 15 26				.word TXT_KX	
   916 24A1 00 0C 0C				.byte TNO, $0C, $0C     ; $0C00 - $0FFF, K3 IO-area, no RAM-check
   917 24A4 15 26				.word TXT_KX   	
   918 24A6 00 10 10				.byte TNO, $10, $10     ; $1000 - $13FF, K4 IO-area, no RAM-check
   919 24A9 15 26				.word TXT_KX   	
   920 24AB 01 14 14				.byte TRAM, $14, $14    ; $1400 - $15FF, check all
   921 24AE 2E 25				.word TXT0   	
   922 24B0 00 16 16				.byte TNO, $16, $16     ; $1600 - $16FF, 6551 ACIA, no RAM-check
   923 24B3 45 25				.word TXT_ACIA   	
   924 24B5 03 17 17				.byte TPIA, $17, $17    ; $1700 - $17FF, 6520 PIA, no RAM-check
   925 24B8 50 25		TBL_PIA_TXT	.word TXT_PIA   	
   926 24BA 01 18 18				.byte TRAM, $18, $18    ; $1800 - $19FF, check all
   927 24BD 2E 25				.word TXT0   	
   928 24BF 80 1A 1A				.byte TRIOT, $1A, $1A   ; $1800 - $1AFF, 6532 RIOT
   929 24C2 6D 25				.word TXT_RIOT 		; 6532 RIOT, check RAM (128 B) at $1A00-$1A7F
   930 24C4 01 1B 1B				.byte TRAM, $1B, $1B    ; $1B00 - $1BFF, check all
   931 24C7 2E 25				.word TXT0   	
   932 24C9 02 1C 1C				.byte TROM, $1C, $1C    ; $1C00 - $1FFF, JC Monitor ROM
   933 24CC 79 25				.word TXT_MON   	
   934 24CE 01 20 27				.byte TRAM, $20, $27    ; $2000 - $3FFF, check from $2700 (this program!)
   935 24D1 2E 25				.word TXT0   	
   936 24D3 01 40 40				.byte TRAM, $40, $40    ; $4000 - $7FFF, check all
   937 24D6 2E 25				.word TXT0   	
   938 24D8 01 80 80				.byte TRAM, $80, $80    ; $8000 - $9FFF, check all
   939 24DB A3 25				.word TXT_USER_RAM   	
   940 24DD 01 A0 A0				.byte TRAM, $A0, $A0    ; $A000 - $BFFF, check all
   941 24E0 A3 25				.word TXT_USER_RAM   	
   942 24E2 01 C0 C0		RAM_TABLE_C0	.byte TRAM, $C0, $C0    ; $C000 - $DFFF, check all
   943 24E5 A3 25				.word TXT_USER_RAM  	
   944 24E7 02 E0 E0				.byte TROM, $E0, $E0    ; $E000 - $FFFF, JC2 BIOS ROM, ROM-checksum only
   945 24EA 8F 25				.word TXT_BIOS   	
   946 = 0011			TBL_MAX = (*-RAM_TABLE)/TBL1_SZ
   947
   948 				; If the IO card with BASIC ROM is present, this entry is copied
   949 				; over the existing $C000-$DFFF entry.
   950 24EC 02 B0 B0		RAM_TABLE_B0	.byte TROM, $B0, $B0    ; $B000 - $DFFF, BASIC ROM
   951 24EF A3 25				.word TXT_USER_RAM  	
   952
   953 24F1 4A 43 20 5D 5B 20 + TXT_TITLE	.by     'JC ][ Memory-Tester (ROM/RAM) v0.35 by Emile' CR
   954 251E 43 50 55 2D 74 79 + 		.by     'CPU-type     : ' $00
   955 252E 00			TXT0		.byte	$00
   956 252F 42 6C 6F 63 6B 20 + TXT1		.by 	'Block $' $00
   957 2537 3A 20 24 00		TXT1A		.by 	': $' $00
   958 253B 30 30 2D 24 00	TXT1B		.by 	'00-$' $00
   959 2540 46 46 2C 20 00	TXT1C		.by 	'FF, ' $00
   960 2545 36 35 35 31 20 41 + TXT_ACIA	.by     '6551 ACIA' CR $00
   961 2550 36 35 32 30 20 50 + TXT_PIA		.by     '6520 PIA (MMU) ' $00
   962 2560 41 54 46 31 35 30 + TXT_MMU		.by     'ATF1504 MMU ' $00
   963 256D 36 35 33 32 20 52 + TXT_RIOT	.by     '6532 RIOT, ' $00
   964 2579 4A 43 20 4D 6F 6E + TXT_MON		.by	'JC Monitor ROM 1 KB, ' $00
   965 258F 4A 43 32 20 42 49 + TXT_BIOS	.by 	'JC2 BIOS ROM 8 KB, ' $00
   966 25A3 55 73 65 72 20 52 + TXT_USER_RAM	.by 	'User RAM or IO-area, ' $00
   967 25B9 20 4B 42 20 52 41 + TXT_RAMKB_OK	.by 	' KB RAM OK' CR $00
   968 25C5 20 62 79 74 65 73 + TXT_RAM_OK	.by 	' bytes RAM OK' CR $00
   969 25D4 52 41 4D 20 65 72 + TXT_RAM_NOK	.by 	'RAM error or not present' CR $00
   970 25EE 52 4F 4D 20 63 68 + TXT_ROM_OK	.by 	'ROM checksum OK' CR $00
   971 25FF 52 4F 4D 20 63 68 + TXT_ROM_NOK	.by 	'ROM checksum error: $' $00
   972 2615 20 49 4F 2D 61 72 + TXT_KX		.by 	' IO-area, no RAM/ROM present' CR $00
   973 2633 4E 4D 4F 53 20 36 + TXT_6502	.by     'NMOS 6502'     CR $00
   974 263E 43 4D 4F 53 20 36 + TXT_65C02	.by     'CMOS 65C02'    CR $00
   975 264A 43 4D 4F 53 20 36 + TXT_65816	.by     'CMOS 65C816 16-bit' CR $00 
   976 265E 20 52 41 4D 2D 62 + TXT_PIA2        .by     ' RAM-banks found' CR $00
   977 2670 6E 6F 74 20 00	TXT_PIA_NOT	.by 	'not ' $00
   978 2675 70 72 65 73 65 6E + TXT_PIA_DET	.by	'present, ' $00
   979 267F 52 41 4D 2D 42 41 + TXT_RAMB1	.by 	'RAM-BANK ' $00
   980 2689 31 36 20 4B 42 20 + TXT_RAMB_OK	.by 	'16 KB RAM OK' CR $00
   981 2697 52 41 4D 2D 62 61 + TXT_RAMB_NOK	.by 	'RAM-bank memory error' CR $00
   982 26AE 20 20 20 20 20 20 + TXT_MONRAM1	.by	'           $1C00-$1FFF, RAM behind Monitor ROM, ' $00
   983 26DF 31 20 4B 42 20 52 + TXT_MONRAM_OK	.by     '1 KB RAM OK' CR $00
   984 26EC			TXT_BASICRAM_NOK
   985 26EC			TXT_BIOSRAM_NOK
   986 26EC 52 41 4D 20 6D 65 + TXT_MONRAM_NOK  .by	'RAM memory error' CR $00
   987 26FE 20 20 20 20 20 20 + TXT_BIOSRAM1	.by	'           $E000-$FFFF, RAM behind BIOS ROM, ' $00
   988 272C 38 20 4B 42 20 52 + TXT_BIOSRAM_OK	.by     '8 KB RAM OK' CR $00
   989 2739 20 20 20 20 20 20 + TXT_BASICRAM1	.by	'           $B000-$DFFF, RAM behind BASIC ROM, ' $00
   990 2768 31 32 20 4B 42 20 + TXT_BASICRAM_OK	.by     '12 KB RAM OK' CR $00
   991 2776 53 52 41 4D 20 36 + TXT_628128	.by	'SRAM 628128 IC detected' CR $00
   992 278F 42 41 53 49 43 2D + TXT_IOL1        .by     'BASIC-IO card: ' $00
   993 279F 64 65 74 65 63 74 + TXT_IOL_OK	.by	'detected at $' $00
   994 27AD 6E 6F 74 20 70 72 + TXT_IOL_NOK	.by	'not present' CR CR $00
   995 = 27BB			MEM_TEST_END = *
