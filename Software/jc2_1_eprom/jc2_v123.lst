mads 2.1.7 build 33 (1 Aug 24)
Source: jc2_main.asm
     1 				; ------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS Version 1.2.3 by Joerg Walke
     3 				;
     4 				; 21-04-25: v1.2.0 Emile, Integration into 1 eprom
     5 				; 08-05-25: v1.2.1 -Basic update (v2.22 patches + I2COUT, I2CIN and DOS commands)
     6 				;                  -CF_LOAD_VEC/CF_SAVE_VEC added, RETURN_VECT moved to $180A 
     7 				;                  -Address corrections to maintain V1.1.4 compatibility (broken in V1.2.0)
     8 				; 19-05-25: v1.2.2 -ZP addresses reorganised to avoid conflicts between Basic, BIOS & boot.sys.
     9 				;		   -NMI & IRQ JMP vectors moved from Monitor to here to prepare for Monitor ROM switching
    10 				; 24-05-25: v1.2.3 Bug-fix Basic LOAD command. 
    11 				; ------------------------------------------------------------------------------
    12 = 0031			VERMAIN   	EQU     '1'    			; BIOS main version
    13 = 0032			VERPSUB    	EQU     '2'    			; BIOS primary sub version
    14 = 0033			VERSSUB		EQU	'3'			; BIOS secondary sub version
    15
    16 				        	OPT h-                          ; no DOS file-header
    17 				        	OPT f+                          ; save as single block
    18
    19 				        	icl 	"jc2_defines.inc"  	; all address defines for the JC-II
Source: jc2_defines.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor CONSTANTS
     3 				;------------------------------------------------------------------------------ 
     4
     5 				; PIA Register Indices *********************************************************
     6 = 000C			PIA_PORTA       EQU     $0C             ; Port A input/output register
     7 = 000D			PIA_PORTB       EQU     $0D             ; Port B input/output register
     8 = 000E			PIA_PORTC       EQU     $0E             ; Port C input/output register
     9 = 000F			PIA_CONTROL     EQU     $0F             ; Control/Setup register
    10
    11 				; Memory Management Unit (MMU) Register Indices ********************************
    12 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    13 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    14 = 0080			BAS_EN		EQU	$80		; PORTB bit 7: 1 = enable BASIC at $B000
    15
    16 				; VIA 1 Register Indices *******************************************************
    17 = 0000			VIA_PORTB     	EQU  	$00  		; Port B input/output register
    18 = 0001			VIA_PORTA     	EQU  	$01  		; Port A input/output register
    19 = 0002			VIA_DDRB   	EQU  	$02		; Port B data direction register
    20 = 0003			VIA_DDRA   	EQU  	$03		; Port A data direction register
    21 = 0004			VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
    22 = 0005			VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
    23 = 0006			VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
    24 = 0007			VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
    25 = 0008			VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
    26 = 0009			VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
    27 = 000A			VIA_SR     	EQU  	$0A		; Shift register
    28 = 000B			VIA_ACR    	EQU  	$0B		; Auxilary control register
    29 = 000C			VIA_PCR    	EQU  	$0C		; Periheral control register
    30 = 000D			VIA_IFR    	EQU  	$0D		; Interrupt flag register
    31 = 000E			VIA_IER    	EQU  	$0E		; Interrupt enable register
    32 = 000F			VIA_PANOHS 	EQU  	$0F
    33
    34 				; VIA 2 Register Indices *******************************************************
    35 = 0010			PORTB     	EQU  	$10  		; Port B input/output register
    36 = 0011			PORTA     	EQU  	$11  		; Port A input/output register
    37 = 0012			DDRB   		EQU  	$12		; Port B data direction register
    38 = 0013			DDRA   		EQU  	$13		; Port A data direction register
    39 = 0014			T1CL   		EQU  	$14		; Timer 1 counter low byte register
    40 = 0015			T1CH   		EQU  	$15		; Timer 1 counter high byte register
    41 = 0016			T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
    42 = 0017			T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
    43 = 0018			T2CL   		EQU  	$18		; Timer 2 counter low byte register
    44 = 0019			T2CH   		EQU  	$19		; Timer 2 counter high byte register
    45 = 001A			SR     		EQU  	$1A		; Shift register
    46 = 001B			ACR    		EQU  	$1B		; Auxilary control register
    47 = 001C			PCR    		EQU  	$1C		; Peripheral control register
    48 = 001D			IFR    		EQU  	$1D		; Interrupt flag register
    49 = 001E			IER    		EQU  	$1E		; Interrupt enable register
    50 = 001F			PANOHS 		EQU  	$1F
    51
    52 = 0020			CENTURY		EQU	$20		; the 20th century. change to travel in time
    53 = 002E			DATEDIV		EQU	'.'		; divider char for date string
    54 = 003A			TIMEDIV		EQU	':'		; divider char for time string
    55 = 002A			PROMPT    	EQU     '*'    		; prompt character
    56 = 002D			ADIV      	EQU     '-'    		; address divider
    57 = 0001			SOH       	EQU     $01    		; start of header
    58 = 0004			EOT       	EQU     $04    		; end of text
    59 = 0006			ACK       	EQU     $06    		; acknowledged
    60 = 0008			BS        	EQU     $08    		; backspace key
    61 = 000D			CR        	EQU     $0D    		; carriage return
    62 = 000A			LF	  	EQU     $0A    		; line feed
    63 = 0015			NAK       	EQU     $15    		; not acknowledged
    64 = 0018			CAN		EQU     $18		; Cancel
    65 = 001B			ESC       	EQU     $1B    		; ESC
    66 = 0020			SPC		EQU     $20		; space char
    67
    68 				; Tape Reader/Writer Constants *************************************************
    69 = 002E			SYNCMARK	EQU	$2E		; synchronisation mark
    70 = 00A0			NAMEMARK	EQU	$A0		; start of name mark
    71 = 00A1			ADDRMARK	EQU	$A1		; start of address mark
    72 = 001F			FILEMARK	EQU	$1F		; start of file mark
    73
    74 = 0031			RPTIME		EQU	49		; read point time   49x8uS     = 392uS
    75 = 00BE			LPTIME		EQU	190		; long pulse time   190uS+50uS = 240uS
    76 = 003C			SPTIME		EQU	60		; short pulse time  60uS+50uS  = 120uS
    77
    78 				; Device Driver Constants ******************************************************
    79 = 0081			KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
    80
    81 = 0010			COM_DEV	        EQU	$10             ; COM devices base ID
    82 = 0020			STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
    83
    84 = 0000			NULL_ID		EQU	$00             ; the NULL device
    85
    86 = 0010			TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
    87 = 0011			PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
    88 = 0012			PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
    89 = 0013			KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
    90 = 0014			KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
    91 = 0015			VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
    92
    93 = 0020			XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
    94 = 0021			TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
    95 = 0022			FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
    96 = 0023			FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
    97 = 0024			SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
    98 = 0025			HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID (CF-card)
    99 = 0026			HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
   100
   101 				; Device Command Constants *****************************************************
   102 = 0000			CMD_INIT	EQU	0               ; Init device
   103 = 0001			CMD_IDENTIFY	EQU	1               ; Identify device
   104 = 0002			CMD_NORMAL	EQU	2               ; Set normal text
   105 = 0003			CMD_INVERSE	EQU	3               ; Set inverse text
   106 = 0004			CMD_FLASH	EQU	4               ; Set blinking text
   107 = 0005			CMD_HOME	EQU	5               ; Set cursor to home position
   108 = 0006			CMD_CLRLINE	EQU	6               ; Clear line at cursor
   109 = 0007			CMD_CLRSCRN	EQU	7               ; Clear screen
   110 = 0008			CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   111
   112 = 0010			CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   113 = 0011			CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
   114
   115 = 0020			CMD_LOAD	EQU	32              ; Load data byte from device
   116 = 0021			CMD_SAVE	EQU	33              ; Save data byte to device
   117 = 0022			CMD_READ	EQU	34              ; Read data block from device
   118 = 0023			CMD_WRITE	EQU	35              ; Write data block to device
   119 = 0024			CMD_BOOT        EQU     36              ; Boot from device
   120 = 0025			CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   121 = 0026			CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
   122
   123 				; SD Command Constants *********************************************************
   124 = 0040			CMD0		EQU	$40		; Reset SD-Card
   125 = 0041			CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   126 = 0048			CMD8		EQU	CMD0 + 8	; Check voltage range
   127 = 004D			CMD13		EQU	CMD0 + 13	;
   128 = 0050			CMD16		EQU	CMD0 + 16	; Change block size
   129 = 0051			CMD17		EQU	CMD0 + 17	; Read single block
   130 = 0058			CMD24		EQU	CMD0 + 24	; Write single block
   131 = 0077			CMD55		EQU	CMD0 + 55	; Application command prefix
   132 = 007A			CMD58		EQU	CMD0 + 58	; Get OCR
   133 = 0069			ACMD41		EQU	CMD0 + 41	; Initialize SDC
   134
   135 = 00FE			DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
   136
   137 				;----------------------------------------------------------------------------
   138 				; CF-IDE Hardware Registers
   139 				;----------------------------------------------------------------------------
   140 = 0C80			CFBASE		EQU 	$0C80		; Base card-address for CF-IDE card
   141 = 0C80			CFREG0		EQU	CFBASE+0	; Data port
   142 = 0C81			CFREG1		EQU	CFBASE+1	; Read: error-code, write: feature
   143 = 0C82			CFREG2		EQU	CFBASE+2	; Number of sectors to transfer
   144 = 0C83			CFREG3		EQU	CFBASE+3	; Sector address LBA 0 [0:7] (LSB)
   145 = 0C84			CFREG4		EQU	CFBASE+4	; Sector address LBA 1 [8:15]
   146 = 0C85			CFREG5		EQU	CFBASE+5	; Sector address LBA 2 [16:23]
   147 = 0C86			CFREG6		EQU	CFBASE+6	; Sector address LBA 3 [24:27] (MSB)
   148 = 0C87			CFREG7		EQU	CFBASE+7	; Read: Status, Write: Command
   149 = 0C88			CFREG8		EQU	CFBASE+8	; A write with 0x00 is a HW reset
   150
   151 				; Block Device Constants *******************************************************
   152 = 0400			MOUNT_TABLE     EQU     $0400           ; Table of mounted devices
   153 = 0400			BOOT_PART       EQU     MOUNT_TABLE     ; Boot Medium Descriptor
   154 = 0600			BLOCK_BUF	EQU	$0600           ; Block Device Block Buffer
   155 = 0600			MBR             EQU     BLOCK_BUF       ; Master Boot Block Code
   156 = 07BE			PART0		EQU	$07BE		; Partition 0 start
   157 = 07C6			PART0_RS	EQU	PART0 + 8 	; Partition 0 relative sector field
   158 = 07CE			PART0_SIZE	EQU	PART0 + 16	; Partition 0 sector size field
   159
   160 = 07FE			BOOTBLK_TAG     EQU     $07FE           ; Address of Boot Block Tag ($55 $AA)
   161
   162 				; Miscellaneous Constants ******************************************************
   163 = 0068			I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
   164
   165 = 1000			FGC_BASE        EQU     $1000
   166 = 1010			FGC_INFO        EQU     FGC_BASE+$10
   167 = 1013			FGC_SET_PAGE    EQU     FGC_BASE+$13
   168 = 1017			FGC_FDC_CMD     EQU     FGC_BASE+$17
   169 = 101F			FGC_VPU_CMD     EQU     FGC_BASE+$1F
   170 = 1027			FGC_VPU_OUT     EQU     FGC_BASE+$27
   171
   172 = 1009			VPU_PORT1       EQU     FGC_BASE+$09    ; VPU Port 1
   173 = 0080			VPU_REG0        EQU     $80             ; VPU register 0
   174 = 008F			VPU_REG15       EQU     VPU_REG0+15     ; VPU status register pointer
   175 = 0000			VPU_STAT0       EQU     0               ; VPU status register 0
   176
   177 				;------------------------------------------------------------------------------
   178 				; Junior Computer ][ BIOS & Monitor Address defines
   179 				;------------------------------------------------------------------------------ 
   180
   181 				; Card Base Addresses **********************************************************
   182 = 0014			IOBASE		EQU	$14		; pointer to IO card base
   183 = 0014			IOBASEL		EQU	$14		; always $00
   184 = 0015			IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
   185 = 0016			FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
   186 = 0016			FGCBASEL	EQU	$16		; always $00
   187 = 0017			FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always be K4 = $10
   188 = 0018			CARD3BASE	EQU	$18		; reserved (controller base)
   189 = 0018			CARD3BASEL	EQU	$18		; always $00
   190 = 0019			CARD3BASEH	EQU	$19		;K2 = $08, K3 = $0C, K4 = $10
   191
   192 				;-----------------------------------------------------------------------------
   193 				; Addresses up to $9C are in use by BASIC, see jc2_basic.asm
   194 				; Addresses from $A0 up to $AF are in use by DOS and boot.sys
   195 				;-----------------------------------------------------------------------------
   196
   197 = 00C9			DEVID		EQU	$C9		; 1-byte temp device id (moved from $03 to avoid Basic collision)
   198 = 00CA			PRSTR		EQU	$CA		; 2-bytes replacement for PSTR
   199 = 00CC			END_PTR		EQU	$CC		; ROM end-pointer (2 bytes), also used by BASIC
   200 = 00CE			ROM_PTR		EQU	$CE		; ROM pointer (2 bytes)
   201 = 00D0			ROM_CS		EQU	$D0		; ROM checksum counter (2 bytes)
   202 = 00D2			CFLBA0          EQU     $D2		; CF-card LBA 0 [0:7]
   203 = 00D3			CFLBA1          EQU     $D3		; CF-card LBA 1 [8:15]
   204 = 00D4			CFLBA2          EQU     $D4		; CF-card LBA 2 [16:23]
   205 = 00D5			CFLBA3          EQU     $D5		; CF-card LBA 3 [24:27]
   206 = 00D6			MSEC		EQU	$D6		; msec time-out counter
   207 = 00D7			RSTACT		EQU	$D7		; 1 = Reset Pending
   208 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register
   209 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register
   210 = 00DA			TICKCNT         EQU     $DA             ; current tick counter
   211 = 00DB			SD_TYPE		EQU	$DB		; SD Card Type: $00 Byte mode, $40 LBA mode
   212 = 00DC			BLKBUF		EQU	$DC             ; pointer to block buffer
   213 = 00DC			BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
   214 = 00DC			CHECKSUM	EQU	$DC		; TAPE file checksum
   215 = 00DC			CRCL      	EQU   	$DC      	; XModem CRC lo byte
   216 = 00DD			BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
   217 = 00DD			OUTBYTE		EQU	$DD		; TAPE data byte read/written from/to tape
   218 = 00DD			CRCH      	EQU   	$DD     	; XModem CRC hi byte
   219 = 00DE			SD_CMD		EQU	$DE		; SD-Card CMD Byte
   220 = 00DE			RETRYL    	EQU   	$DE      	; XModem retry counter lo byte
   221 = 00DE			PDEV		EQU	$DE		; device descriptor pointer
   222 = 00DE			PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
   223 = 00DF			SD_PB3      	EQU   	$DF   		; SD-Card Parameter Byte 3
   224 = 00DF			RETRYH    	EQU   	$DF      	; XModem retry counter hi byte
   225 = 00DF			PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
   226
   227 = 00E0			SD_PB2		EQU   	$E0   		; SD-Card Parameter Byte 2
   228 = 00E0			BAUDRATE  	EQU   	$E0    		; ACIA current baud rate
   229 = 00E0			OPCODE		EQU	$E0		; DISASSEM current opcode
   230 = 00E0			I2C_DATA	EQU	$E0		; I2C current I2C data byte
   231 = 00E0			BLKEND      	EQU     $E0		; XModem block end flag
   232 = 00E1			KEY     	EQU     $E1   		; MON 1-byte Editor 
   233 = 00E1			SD_PB1      	EQU   	$E1   		; SD-Card Parameter Byte 1
   234 = 00E1			LINECNT		EQU	$E1		; DISASSEM number of disassembled lines
   235 = 00E1			BFLAG     	EQU   	$E1      	; XModem block flag
   236 = 00E1			EQUFLAG		EQU	$E1		; TAPE file name equal flag
   237 = 00E2			BEGADR  	EQU     $E2   		; MON 2-byte Editor Begin Address Pointer
   238 = 00E2			SD_PB0		EQU	$E2   		; SD-Card Parameter Byte 0
   239 = 00E2			ADRMODE		EQU	$E2		; DISASSEM addressing mode
   240 = 00E2			BLKNO     	EQU   	$E2      	; XModem block number
   241 = 00E3			SD_CRC		EQU	$E3   		; SD-Card CRC Byte
   242 = 00E3			IBYTES		EQU	$E3		; DISASSEM instruction byte count
   243 = 00E3			ERRCNT    	EQU   	$E3      	; XModem error counter 10 is the limit
   244 = 00E4			ENDADR  	EQU     $E4   		; MON 2-byte Editor End Address Pointer
   245 = 00E4			VIA_STATUS 	EQU	$E4 		; VIA2 current VIA2 PortB output status
   246 = 00E5			KEY_SENSE	EQU	$E5		; TAPE datasette key sense flag
   247 = 00E6			CURADR  	EQU     $E6   		; MON 2-byte Editor Current Address Pointer
   248 = 00E6			ASCL	  	EQU   	$E6     	; MON ASCII list start address low
   249 = 00E6			PLBA		EQU	$E6		; LBA pointer
   250 = 00E6			PLBAL		EQU	$E6		; LBA pointer low byte
   251 = 00E7			ASCH      	EQU   	$E7     	; MON ASCII list start address high
   252 = 00E7			PLBAH		EQU	$E7		; LBA pointer high byte
   253 = 00E8			CENDADR 	EQU     $E8   		; MON 2-byte Editor Current End Address Pointer
   254 = 00E8			STOL      	EQU   	$E8     	; MON store address Low
   255 = 00E9			STOH      	EQU   	$E9     	; MON store address High
   256 = 00EA			MOVADR  	EQU     $EA   		; MON 2-byte Editor 
   257 = 00EA			PSTR      	EQU   	$EA      	; ACIA output string Pointer
   258 = 00EA			PSTRL     	EQU   	$EA      	; ACIA lower address byte of output string pointer
   259 = 00EB			PSTRH     	EQU   	$EB      	; ACIA upper address byte of output string pointer
   260 = 00EC			TABLEA  	EQU     $EC   		; MON 2-byte Editor 
   261 = 00EC			WBUF      	EQU   	$EC      	; ACIA character output buffer
   262 = 00ED			BITCNT		EQU	$ED		; TAPE current read bit count
   263 = 00EE			LABELS  	EQU     $EE   		; MON 1-byte Editor 
   264 = 00EE			PSAV            EQU     $EE		; MON
   265 = 00EF			PCL		EQU	$EF		; CPU program counter Low
   266
   267 = 00F0			PCH		EQU	$F0		; CPU program counter High
   268 = 00F1			PREG		EQU	$F1		; CPU processor status register
   269 = 00F2			SPUSER		EQU	$F2		; CPU stack pointer
   270 = 00F2			DIVCHAR		EQU	$F2             ; CLOCK current divider char (. or / for date : for time)
   271 = 00F3			ACC		EQU	$F3		; CPU accumulator
   272 = 00F4			YREG		EQU	$F4		; CPU y-register
   273 = 00F5			XREG		EQU	$F5		; CPU x-register
   274 = 00F6			BYTES   	EQU     $F6   		; MON 1-byte Number of bytes to be displayed
   275 = 00F7			COUNT   	EQU     $F7   		; MON 1-byte
   276 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
   277 = 00F8			NUML      	EQU   	$F8     	; MON low number byte
   278 = 00F8			INL     	EQU     $F8   		; MON 1-byte hex display buffer
   279 = 00F9			INH     	EQU     $F9   		; MON 1-byte hex display buffer
   280 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
   281 = 00F9			NUMH	  	EQU   	$F9	 	; MON high number byte
   282 = 00FA			POINT   	EQU     $FA   		; MON 2-byte
   283 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
   284 = 00FA			ADRL      	EQU   	$FA     	; MON last address Low
   285 = 00FB			ADRH      	EQU   	$FB     	; MON last address High
   286 = 00FC			TEMP      	EQU   	$FC     	; MON temp storage
   287 = 00FD			TEMPX   	EQU     $FD   		; MON 1-byte temp. data-buffer
   288 = 00FD			YSAV      	EQU   	$FD     	; MON Y register storage
   289 = 00FE			NIBBLE  	EQU     $FE   		; MON 1-byte temp. data-buffer
   290 = 00FE			PDBCNT    	EQU   	$FE     	; MON number of printed data bytes
   291 = 00FF			MODE      	EQU   	$FF     	; MON current edit mode
   292
   293 				; IO Base Addresses ************************************************************
   294 = 0800			K2		EQU	$0800		; Base address of IO select K2
   295 = 0C00			K3		EQU	$0C00		; Base address of IO select K3
   296 = 1000			K4		EQU	$1000		; Base address of IO select K4
   297
   298 				; Buffers **********************************************************************
   299 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400
   300 = 1500			RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
   301
   302 				; ACIA Registers ***************************************************************
   303 = 1600			DATA_REG  	EQU   	$1600    	; ACIA Data Register
   304 = 1601			STAT_REG  	EQU   	$1601    	; ACIA Status Register
   305 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
   306 = 1603			CTRL_REG  	EQU   	$1603    	; ACIA Control Register
   307
   308 				; ATF1504 Memory Management Unit (MMU) Register ********************************
   309 = 1700			MMU		EQU	$1700		; MMU Register
   310
   311 				;------------------------------------------------------------------------------
   312 				; $1800 - $19FF 512 Bytes, this was previously unused, with the new MMU this
   313 				; has become RAM.
   314 				;------------------------------------------------------------------------------
   315 = 1800			PPORTLOAD	EQU	$1800		; jump location for test code
   316 = 1803			PPORTSAVE	EQU	$1803		; jump location for test code
   317 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
   318 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
   319 = 180A			RETURN_VECT     EQU     $180A           ; 2-byte return vector to monitor caller (moved from $01 to avoid Basic collision)
   320
   321 				; INPBUF is the BASIC Input Buffer. It is defined from $1868 - $18FF
   322 = 1868			INPBUF	  	EQU 	$1868		; change input buffer to last 151 bytes in page
   323 = 1868			ccflag		EQU	INPBUF		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   324 = 1869			ccbyte		EQU 	ccflag+1	; BASIC CTRL-C byte
   325 = 186A			ccnull		EQU 	ccbyte+1	; BASIC CTRL-C byte timeout
   326 = 186B			VEC_CC		EQU 	ccnull+1	; ctrl c check vector
   327
   328 				; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   329 = 187F			Ibuffs		EQU 	VEC_CC+$14	; start of input buffer after IRQ/NMI code
   330 = 18FE			Ibuffe		EQU 	Ibuffs+$7F	; end of input buffer
   331
   332 				; RIOT RAM Area ****************************************************************
   333 = 1A00			IO_INFO         EQU     $1A00           ; Initialization info call for IO card
   334
   335 = 1A24			KEY_HANDLER     EQU     $1A24           ; character input handler
   336 = 1A26			NKEY_HANDLER    EQU     $1A26           ; no character input handler
   337 = 1A28			DEVLIST		EQU	$1A28		; start of device driver list
   338
   339 = 1A66			STDBEEP		EQU	$1A66		; current standard beep routine
   340 = 1A68			DEVIN		EQU	$1A68		; current opened device input routine
   341 = 1A6A			DEVOUT		EQU	$1A6A		; current opened device output routine
   342 = 1A6C			DEVCMD		EQU	$1A6C		; current opened device command routine
   343 = 1A6E			STDIN		EQU	$1A6E		; current standard input routine
   344 = 1A70			STDOUT		EQU	$1A70		; current standard output routine
   345 = 1A72			STDCMD		EQU	$1A72		; current standard command routine
   346 = 1A74			STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   347 = 1A75			STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   348 = 1A76			STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   349 = 1A77			STOACC		EQU	$1A77		; last accumulator before interrupt
   350
   351 				; Interrupt Vectors ************************************************************
   352 = 1A78			BRKUSR		EQU	$1A78		; address of user BREAK vector
   353 = 1A7A			NMIVECT		EQU     $1A7A           ; address of NMI vector
   354 = 1A7C			IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   355 = 1A7E			IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
   356
   357 				; Port Register ****************************************************************
   358 = 1A80			PAD		EQU     $1A80		; Port A Data Register
   359 = 1A81			PADD		EQU	$1A81		; Port A Data Direction Register
   360 = 1A82			PBD		EQU	$1A82		; Port B Data Register
   361 = 1A83			PBDD		EQU	$1A83		; Port B Data Direction Register
   362
   363 = 1A85			WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
   364 									; Read = get Edge Control Interrupt Register
   365
   366 				; Timer Register ***************************************************************
   367 = 1A94			CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   368 = 1A95			CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   369 = 1A96			CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   370 = 1A97			CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
   371 = 1A9F			CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
   372
   373 				;------------------------------------------------------------------------------
   374 				; MACROS for use with the MAD-Assembler
   375 				;------------------------------------------------------------------------------ 
   376 				.macro		ADCAW			; Add A to word and store in word
   377 						CLC
   378 						ADC	:1
   379 						STA	:1
   380 						LDA	:1+1
   381 						ADC	#0
   382 						STA	:1+1
   383 				.endm
   384
   385 				.macro		SBCAW			; Subtract A from word and store in word
   386 						SEC
   387 						SBC	:1
   388 						STA	:1
   389 						LDA	:1+1
   390 						SBC	#0
   391 						STA	:1+1
   392 				.endm
   393
   394 				.macro		SBWB	b16 b8	      	; Subtract a byte from a word
   395 						SEC
   396 						LDA	:b16
   397 						SBC	:b8
   398 						STA	:b16
   399 						LDA	:b16+1
   400 						SBC	#0
   401 						STA	:b16+1
   402 				.endm
   403 						
    20
    21 						ORG	$8000
    22 8000 FF					.byte	$FF			; Fill entire eprom
    23 						
    24 8001					ORG	$9C00			; start address of 1K Monitor in 32K combined EPROM
    25 				;-------------------------------------------------------------------------------------------------------
    26 1C00			MONITOR_BLOCK	.local, $1C00
    27 				;-------------------------------------------------------------------------------------------------------
    28 1C00					icl 	"jc2_mon.asm"		; Monitor source-file
Source: jc2_mon.asm
     1 				;-------------------------------------------------------------------------------------------------------
     2 				; SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER
     3 				;
     4 				; Written by: A. NACHTMANN
     5 				; Date      :  7 FEB. 1980
     6 				;
     7 				; The features of Junior's monitor program are:
     8 				; - Hex address data display (entry via RST)
     9 				; - Hex editor (start address is $1CB5)
    10 				; - Hex assembler (start address is $1F51)
    11 				;----------------------------------------------------------------------------
    12 				; Original code restored and adapted for the 
    13 				; TASM (Telemark Assembler) by : A.J. Prosman, October 26, 2019
    14 				; MADS (MAD-Assembler) by : E. v.d. Logt,      December 2024
    15 				;----------------------------------------------------------------------------
    16
    17 				;       Beginners may load these locations
    18 				;       $1C00 for step by step modus and BRK command
    19
    20 				;----------------------------------------------------------------------------
    21 				;        JUNIOR'S MAIN ROUTINES
    22 				;----------------------------------------------------------------------------
    23 1C00 85 F3		SAVE    STA     ACC         ; Save ACCU
    24 1C02 68			        PLA                 ; Get current P-Register
    25 1C03 85 F1		        STA     PREG        ; Save P-Register
    26
    27 1C05 68			SAVEA   PLA                 ; Get current PCL
    28 1C06 85 EF		        STA	PCL         ; Save current PCL
    29 1C08 85 FA		        STA     POINT       ; PCL to display buffer
    30 1C0A 68			        PLA                 ; Get current PCH
    31 1C0B 85 F0		        STA     PCH         ; Save current PCH
    32 1C0D 85 FB		        STA     POINT+1     ; PCH to display buffer
    33
    34 1C0F 84 F4		SAVEB   STY     YREG        ; Save current Y-Register
    35 1C11 86 F5		        STX     XREG        ; Save current X-Register 
    36 1C13 BA			        TSX                 ; Get current SP
    37 1C14 86 F2		        STX     SPUSER      ; Save current SP
    38 1C16 A2 01		        LDX     #$01        ; Set AD-Mode
    39 1C18 86 FF		        STX     MODE
    40 1C1A 4C 33 1C		        JMP     START
    41
    42 				; RESET vector 6502
    43 1C1D A9 3F		RESET   LDA     #$3F        ; PB5---PB0
    44 1C1F 8D 83 1A		        STA     PBDD        ; IS output
    45 1C22 A9 04		        LDA     #$04        ; Reset P-Register
    46 1C24 85 F1		        STA     PREG
    47 1C26 A9 03		        LDA     #$03
    48 1C28 85 FF		        STA     MODE        ; Set AD-Mode
    49 1C2A 85 F6		        STA     BYTES       ; Display POINT, INH
    50 1C2C A2 FF		        LDX     #$FF
    51 1C2E 9A			        TXS 
    52 1C2F 86 F2		        STX     SPUSER
    53 1C31 D8			        CLD 
    54 1C32 78			        SEI 
    55
    56 1C33 20 88 1D		START   JSR     SCAND       ; Display data specified by POINT
    57 1C36 D0 FB		        BNE     START       ; Wait until key is released
    58
    59 1C38 20 88 1D		STARA   JSR     SCAND       ; Display data specified by point
    60 1C3B F0 FB		        BEQ     STARA       ;  Any key pressed
    61 1C3D 20 88 1D		        JSR     SCAND       ;  Debounce key
    62 1C40 F0 F6		        BEQ     STARA       ; Any key still pressed
    63 1C42 20 F9 1D		        JSR     GETKEY      ; If Yes, decode key, return with key in ACC
    64
    65 1C45 C9 13		GOEXEC  CMP     #$13        ; GO-Key ?
    66 1C47 D0 13		        BNE     ADMODE
    67 1C49 A6 F2		        LDX     SPUSER      ; Get current SP
    68 1C4B 9A			        TXS 
    69 1C4C A5 FB		        LDA     POINT+1     ; Start execution at POINT
    70 1C4E 48			        PHA 
    71 1C4F A5 FA		        LDA     POINT
    72 1C51 48			        PHA 
    73 1C52 A5 F1		        LDA     PREG        ; Restore current P register
    74 1C54 48			        PHA 
    75 1C55 A6 F5		        LDX     XREG
    76 1C57 A4 F4		        LDY     YREG
    77 1C59 A5 F3		        LDA     ACC
    78 1C5B 40			        RTI                 ; Execute program
    79
    80 1C5C C9 10		ADMODE  CMP     #$10        ; AD-Key ?
    81 1C5E D0 06		        BNE     DAMODE
    82 1C60 A9 03		        LDA     #$03        ; Set AD-Mode
    83 1C62 85 FF		        STA     MODE
    84 1C64 D0 14		        BNE     STEPA       ; Always
    85 				        
    86 1C66 C9 11		DAMODE  CMP     #$11        ; DA-Key ?
    87 1C68 D0 06		        BNE     STEP
    88 1C6A A9 00		        LDA     #$00        ; Set DA-Mode
    89 1C6C 85 FF		        STA     MODE
    90 1C6E F0 0A		        BEQ     STEPA
    91
    92 1C70 C9 12		STEP    CMP     #$12        ; PLUS-Key ?
    93 1C72 D0 09		        BNE     PCKEY
    94 1C74 E6 FA		        INC     POINT
    95 1C76 D0 02		        BNE     STEPA
    96 1C78 E6 FB		        INC     POINT+1
    97
    98 1C7A 4C 33 1C		STEPA   JMP     START
    99
   100 1C7D C9 14		PCKEY   CMP     #$14        ; PC-Key
   101 1C7F D0 0B		        BNE     ILLKEY
   102 1C81 A5 EF		        LDA     PCL
   103 1C83 85 FA		        STA     POINT      ; Last PC to display buffer
   104 1C85 A5 F0		        LDA     PCH
   105 1C87 85 FB		        STA     POINT+1
   106 1C89 4C 7A 1C		        JMP     STEPA
   107 				        
   108 1C8C C9 15		ILLKEY  CMP     #$15        ; Illegal key?
   109 1C8E 10 EA		        BPL     STEPA       ; If Yes, ignore it
   110
   111 1C90 85 E1		DATA    STA     KEY         ; Save key
   112 1C92 A4 FF		        LDY     MODE        ; Y=0 Is data mode, else address mode
   113 1C94 D0 0D		        BNE     ADDRESS
   114 1C96 B1 FA		        LDA     (POINT),Y   ; Get Data specified
   115 1C98 0A			        ASL                 ; by point
   116 1C99 0A			        ASL                 ; shift low order
   117 1C9A 0A			        ASL                 ; nibble into high order nibble
   118 1C9B 0A			        ASL      
   119 1C9C 05 E1		        ORA     KEY         ; Data with key
   120 1C9E 91 FA		        STA     (POINT),Y   ; Restore data
   121 1CA0 4C 7A 1C		        JMP     STEPA
   122
   123 1CA3 A2 04		ADDRESS LDX     #$04        ; 4 Shifts
   124 1CA5 06 FA		ADLOOP  ASL     POINT       ; POINT+1, POINT 4 Positions to the left
   125 1CA7 26 FB		        ROL     POINT+1
   126 1CA9 CA			        DEX 
   127 1CAA D0 F9		        BNE     ADLOOP
   128 1CAC A5 FA		        LDA     POINT
   129 1CAE 05 E1		        ORA     KEY         ; Restore address
   130 1CB0 85 FA		        STA     POINT
   131 1CB2 4C 7A 1C		        JMP     STEPA
   132
   133 				;-------------------------------------------------------------------------------
   134 				;       JUNIOR'S HEX EDITOR
   135 				;
   136 				;       FOLLOWING COMMANDS ARE VALID:
   137 				;       "INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
   138 				;       "INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
   139 				;       "SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2BYTE PATTERN
   140 				;       "SKIP": SKIP TO NEXT INSTRUCTION
   141 				;       "DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
   142 				;
   143 				;       AN ERROR IS INDICATED, IF THE INSTRUCTION POINTER CURAD IS OUT OF RANGE
   144 				;-------------------------------------------------------------------------------
   145 1CB5 20 D3 1E		EDITOR  JSR     BEGIN       ; CURAD := BEGAD
   146 1CB8 A4 E3		        LDY     BEGADR+1
   147 1CBA A6 E2		        LDX     BEGADR
   148 1CBC E8			        INX 
   149 1CBD D0 01		        BNE     EDIT
   150 1CBF C8			        INY 
   151
   152 1CC0 86 E8		EDIT    STX     CENDADR     ; CEND := BEGAD + 1
   153 1CC2 84 E9		        STY     CENDADR+1
   154 1CC4 A9 77		        LDA     #$77        ; Display "77"
   155 1CC6 A0 00		        LDY     #$00
   156 1CC8 91 E6		        STA     (CURADR),Y
   157 1CCA 20 4D 1D		CMND    JSR     SCAN        ; Display current instruction,
   158 				                            ; wait for a key
   159 1CCD C9 14		SEARCH  CMP     #$14        ; Search command ?
   160 1CCF D0 2A		        BNE     INSERT
   161 1CD1 20 6F 1D		        JSR     GETBYT      ; Read 1st byte
   162 1CD4 10 F7		        BPL     SEARCH      ; COM. Key ?
   163 1CD6 85 FB		        STA     POINT+1     ; Discard data
   164 1CD8 20 6F 1D		        JSR     GETBYT      ; Read 2nd byte
   165 1CDB 10 F0		        BPL     SEARCH      ; COM. Key ?
   166 1CDD 85 FA		        STA     POINT       ; Discard data
   167 1CDF 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   168
   169 1CE2 A0 00		SELOOP  LDY     #$00
   170 1CE4 B1 E6		        LDA     (CURADR),Y  ; Compare instruction
   171 1CE6 C5 FB		        CMP     POINT+1     ; against data to be searched
   172 1CE8 D0 07		        BNE     SEARA       ; Skip to the next instruction, if not equal
   173 1CEA C8			        INY 
   174 1CEB B1 E6		        LDA     (CURADR),Y
   175 1CED C5 FA		        CMP     POINT
   176 1CEF F0 D9		        BEQ     CMND        ; Return if 2byte pattern is found
   177
   178 1CF1 20 5C 1E		SEARA   JSR     OPLEN       ; Get length of the current instruction
   179 1CF4 20 F8 1E		        JSR     NEXT        ; Skip to the next instruction
   180 1CF7 30 E9		        BMI     SELOOP      ; Search again, if CURAD is less than CEND
   181 1CF9 10 3E		        BPL     ERRA
   182
   183 1CFB C9 10		INSERT  CMP     #$10        ; Insert command ?
   184 1CFD D0 0A		        BNE     INPUT
   185 1CFF 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   186 1D02 10 C9		        BPL     SEARCH      ; COM. key?
   187 1D04 20 47 1E		        JSR     FILLWS      ; Move data in WS downward by the amount in bytes
   188 1D07 F0 C1		        BEQ     CMND        ; Return to display the inserted instruction
   189
   190 1D09 C9 13		INPUT   CMP     #$13        ; Input command ?
   191 1D0B D0 14		        BNE     SKIP
   192 1D0D 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   193 1D10 10 BB		        BPL     SEARCH      ; COM. key ?
   194 1D12 20 5C 1E		        JSR     OPLEN       ; Length of the current instruction
   195 1D15 20 F8 1E		        JSR     NEXT        ; Return with N=1, if CURAD is less than CEND
   196 1D18 A5 FD		        LDA     TEMPX       ; Length of instr. to be inserted
   197 1D1A 85 F6		        STA     BYTES
   198 1D1C 20 47 1E		        JSR     FILLWS      ; Move data in ws downward by the amount in bytes
   199 1D1F F0 A9		        BEQ     CMND        ; Return to display the inserted data
   200
   201 1D21 C9 12		SKIP    CMP     #$12        ; Skip command ?
   202 1D23 D0 07		        BNE     DELETE
   203 1D25 20 F8 1E		        JSR     NEXT        ; Skip to next instruction. CURAD less than CEND?
   204 1D28 30 A0		        BMI     CMND
   205 1D2A 10 0D		        BPL     ERRA
   206
   207 1D2C C9 11		DELETE  CMP     #$11        ; Delete command ?
   208 1D2E D0 09		        BNE     ERRA
   209 1D30 20 83 1E		        JSR     UP          ; Delete current instruction by moving up the WS
   210 1D33 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   211 1D36 4C CA 1C		        JMP     CMND
   212
   213 1D39 A9 EE		ERRA    LDA     #$EE
   214 1D3B 85 FB		        STA     POINT+1
   215 1D3D 85 FA		        STA     POINT
   216 1D3F 85 F9		        STA     INH
   217 1D41 A9 03		        LDA     #$03
   218 1D43 85 F6		        STA     BYTES
   219
   220 1D45 20 8E 1D		ERRB    JSR     SCANDS      ; Display "EEEEEE" until key is released
   221 1D48 D0 FB		        BNE     ERRB
   222 1D4A 4C CA 1C		        JMP     CMND
   223
   224 				;----------------------------------------------------------------------------
   225 				;       EDITOR'S SUBROUTINES
   226 				;
   227 				;       SCAN is a subroutine, filling up the display-buffer determined by
   228 				;       CURADR. Then the display is scanned depending on the length of the  
   229 				;       instruction pointed to by CURADR if a keypress is detected.
   230 				;----------------------------------------------------------------------------
   231
   232 				;       SCAN RETURNS WITH VALUE IN A
   233 1D4D A2 02		SCAN    LDX     #$02        ; Fill up the display buffer
   234 1D4F A0 00		        LDY     #$00
   235
   236 1D51 B1 E6		FILBUF  LDA     (CURADR),Y  ; Start filling at OPCode
   237 1D53 95 F9		        STA     INH,X
   238 1D55 C8			        INY 
   239 1D56 CA			        DEX 
   240 1D57 10 F8		        BPL     FILBUF
   241 1D59 20 5C 1E		        JSR     OPLEN       ; Store instruction length in bytes
   242
   243 1D5C 20 8E 1D		SCANA   JSR     SCANDS      ; Display current instruction
   244 1D5F D0 FB		        BNE     SCANA       ; Key released ?
   245
   246 1D61 20 8E 1D		SCANB   JSR     SCANDS      ; Display current instruction
   247 1D64 F0 FB		        BEQ     SCANB       ; Any key pressed
   248 1D66 20 8E 1D		        JSR     SCANDS      ; Display current instruction
   249 1D69 F0 F6		        BEQ     SCANB       ; Any key still pressed ?
   250 1D6B 20 F9 1D		        JSR     GETKEY      ; If yes, return with key in ACC
   251 1D6E 60			        RTS 
   252
   253 				;----------------------------------------------------------------------------
   254 				;       GETBYT reads 2 hex-keys and composes their values in the A register.
   255 				;       If only hex-keys were pressed, it returns with N=1. If a command-key
   256 				;       was pressed, it returns with N=0;
   257 				;----------------------------------------------------------------------------
   258 1D6F 20 5C 1D		GETBYT  JSR     SCANA       ; Read high order nibble
   259 1D72 C9 10		        CMP     #$10
   260 1D74 10 11		        BPL     BYTEND      ; Command key ?
   261 1D76 0A			        ASL     
   262 1D77 0A			        ASL                 ; If not, save high order nibble
   263 1D78 0A			        ASL     
   264 1D79 0A			        ASL     
   265 1D7A 85 FE		        STA     NIBBLE
   266 1D7C 20 5C 1D		        JSR     SCANA       ; Read low order nibble
   267 1D7F C9 10		        CMP     #$10
   268 1D81 10 04		        BPL     BYTEND      ; Command key ?
   269 1D83 05 FE		        ORA     NIBBLE      ; If not, compose byte
   270 1D85 A2 FF		        LDX     #$FF        ; Set N=1
   271 1D87 60			BYTEND  RTS 
   272
   273 				;----------------------------------------------------------------------------
   274 				;       SCAND is a subroutine showing data specified by POINT.
   275 				;       SCANDS is a subroutine showing the contents of the display-buffer as
   276 				;       a function of BYTES.
   277 				;       The next subroutine AK scans the keyboard, it returns with A=0 if no
   278 				;       key was pressed and with A > 0 if a key was pressed.
   279 				;       When SCAND or SCANDS are exit, PA0..PA7 are set to input.
   280 				;----------------------------------------------------------------------------
   281 1D88 A0 00		SCAND   LDY     #$00
   282 1D8A B1 FA		        LDA     (POINT),Y   ; Get data specified by point
   283 1D8C 85 F9		        STA     INH
   284
   285 1D8E A9 7F		SCANDS  LDA     #$7F
   286 1D90 8D 81 1A		        STA     PADD        ; PA0..PA6 is output
   287 1D93 A2 08		        LDX     #$08        ; Enable display
   288 1D95 A4 F6		        LDY     BYTES       ; Fetch length from bytes
   289
   290 1D97 A5 FB		SCDSA   LDA     POINT+1     ; Output 1st byte
   291 1D99 20 CC 1D		        JSR     SHOW
   292 1D9C 88			        DEY 
   293 1D9D F0 0D		        BEQ     SCDSB       ; More bytes ?
   294 1D9F A5 FA		        LDA     POINT
   295 1DA1 20 CC 1D		        JSR     SHOW        ; If yes, output 2nd byte
   296 1DA4 88			        DEY 
   297 1DA5 F0 05		        BEQ     SCDSB       ; More bytes ?
   298 1DA7 A5 F9		        LDA     INH
   299 1DA9 20 CC 1D		        JSR     SHOW        ; If yes, output 3rd byte
   300
   301 1DAC A9 00		SCDSB   LDA     #$00
   302 1DAE 8D 81 1A		        STA     PADD        ; PA0..PA7 is input
   303 1DB1 A0 03		AK      LDY     #$03        ; Scan 3 rows
   304 1DB3 A2 00		        LDX     #$00        ; Reset row counter
   305
   306 1DB5 A9 FF		ONEKEY  LDA     #$FF
   307 1DB7 8E 82 1A		AKA     STX     PBD         ; Output row number
   308 1DBA E8			        INX                 ; Enable next row
   309 1DBB E8			        INX 
   310 1DBC 2D 80 1A		        AND     PAD         ; Input row pattern
   311 1DBF 88			        DEY                 ; All rows scanned ?
   312 1DC0 D0 F5		        BNE     AKA
   313 1DC2 A0 06		        LDY     #$06        ; Turn display off
   314 1DC4 8C 82 1A		        STY     PBD
   315 1DC7 09 80		        ORA     #$80        ; Set BIT7=1
   316 1DC9 49 FF		        EOR     #$FF        ; Invert key pattern
   317 1DCB 60			        RTS 
   318
   319 				;----------------------------------------------------------------------------
   320 				;       Subroutine SHOW copies the contents of a display-buffer to the display.
   321 				;       The X-register is used as a scan-counter. It determines if POINT+1,
   322 				;       POINT or INH is transported to the displays.
   323 				;----------------------------------------------------------------------------
   324 1DCC 48			SHOW    PHA                 ; Save display 
   325 1DCD 84 FC		        STY     TEMP        ; Save Y register
   326 1DCF 4A			        LSR     
   327 1DD0 4A			        LSR                 ; Get high order nibble
   328 1DD1 4A			        LSR     
   329 1DD2 4A			        LSR     
   330 1DD3 20 DF 1D		        JSR     CONVD       ; Output high order nibble
   331 1DD6 68			        PLA                 ; Get display again
   332 1DD7 29 0F		        AND     #$0F        ; Mask off high order nibble
   333 1DD9 20 DF 1D		        JSR     CONVD       ; Output low order nibble
   334 1DDC A4 FC		        LDY     TEMP
   335 1DDE 60			        RTS 
   336
   337 				;----------------------------------------------------------------------------
   338 				;       Subroutine CONVD controls the display scanning. It converts the
   339 				;       contents of the display-buffer to be displayed into a segment pattern.
   340 				;----------------------------------------------------------------------------
   341 1DDF A8			CONVD   TAY                 ; Use nibble as index
   342 1DE0 B9 0F 1F		        LDA     LOOK,Y      ; Fetch segment pattern
   343 1DE3 8D 80 1A		        STA     PAD         ; Output segment pattern
   344 1DE6 8E 82 1A		        STX     PBD         ; Output digit enable
   345 1DE9 A0 7F		        LDY     #$7F
   346
   347 1DEB 88			DELAY   DEY                 ; Delay 500uS approx
   348 1DEC 10 FD		        BPL     DELAY
   349 1DEE 8C 80 1A		        STY     PAD         ; Turns segments off
   350 1DF1 A0 06		        LDY     #$06
   351 1DF3 8C 82 1A		        STY     PBD         ; Turn display off
   352 1DF6 E8			        INX                 ; Enable next digit
   353 1DF7 E8			        INX 
   354 1DF8 60			        RTS 
   355
   356 				;----------------------------------------------------------------------------
   357 				;       GETKEY converts a key-press into a hex number. It returns with the
   358 				;       key value in A. 
   359 				;       If an invalid key was pressed ?
   360 				;----------------------------------------------------------------------------
   361 1DF9 A2 00		GETKEY  LDX     #$00        ; Start at row 0
   362 1DFB A0 01		GETKEA  LDY     #$01        ; Get one row
   363 1DFD 20 B5 1D		        JSR     ONEKEY      ; A=0, No key pressed
   364 1E00 D0 07		        BNE     KEYIN
   365 1E02 E0 06		        CPX     #$06
   366 1E04 D0 F5		        BNE     GETKEA      ; Each row scanned ?
   367 1E06 A9 15		        LDA     #$15        ; Return if invalid key
   368 1E08 60			        RTS 
   369
   370 1E09 A0 FF		KEYIN   LDY     #$FF
   371 1E0B 0A			KEYINA  ASL                 ; Shift left until Y=Key number
   372 1E0C B0 03		        BCS     KEYINB
   373 1E0E C8			        INY 
   374 1E0F 10 FA		        BPL     KEYINA
   375
   376 1E11 8A			KEYINB  TXA 
   377 1E12 29 0F		        AND     #$0F        ; Mask MSD
   378 1E14 4A			        LSR                 ; Divide by 2
   379 1E15 AA			        TAX 
   380 1E16 98			        TYA 
   381 1E17 10 03		        BPL     KEYIND
   382
   383 1E19 18			KEYINC  CLC 
   384 1E1A 69 07		        ADC     #$07        ; Add row offset
   385 1E1C CA			KEYIND  DEX 
   386 1E1D D0 FA		        BNE     KEYINC
   387 1E1F 60			        RTS 
   388
   389 				;----------------------------------------------------------------------------
   390 				;       RDINST transfers an instruction from the keyboard to the display-buffer. 
   391 				;       It returns with N=0 if a command-key was pressed. Once the entire
   392 				;       instruction is read, RDINST returns with N=1;
   393 				;----------------------------------------------------------------------------
   394 1E20 20 6F 1D		RDINST  JSR     GETBYT      ; Read OPCode
   395 1E23 10 21		        BPL     RDB         ; Return if it is the command key
   396 1E25 85 FB		        STA     POINT+1     ; Store OP cod in the display buffer
   397 1E27 20 60 1E		        JSR     LENACC      ; Calculate instruction length
   398 1E2A 84 F7		        STY     COUNT
   399 1E2C 84 FD		        STY     TEMPX
   400 1E2E C6 F7		        DEC     COUNT
   401 1E30 F0 12		        BEQ     RDA         ; 1 Byte instruction ?
   402 1E32 20 6F 1D		        JSR     GETBYT      ; If not, read first operand
   403 1E35 10 0F		        BPL     RDB         ; Return if it is the command key
   404 				        
   405 1E37 85 FA		        STA     POINT       ; Store 1st operand in the display buffer
   406 1E39 C6 F7		        DEC     COUNT
   407 1E3B F0 07		        BEQ     RDA         ; 2 Byte instruction ?
   408 				        
   409 1E3D 20 6F 1D		        JSR     GETBYT      ; If not, read second operand
   410 1E40 10 04		        BPL     RDB         ; Return if it is the command key
   411 				        
   412 1E42 85 F9		        STA     INH         ; Store 2nd operand in the display buffer
   413 1E44 A2 FF		RDA     LDX     #$FF        ; N=1
   414 1E46 60			RDB     RTS 
   415
   416 				;----------------------------------------------------------------------------
   417 				;       WILLWS transfers data from the display to the workspace. It always
   418 				;       returns with Z=1.
   419 				;----------------------------------------------------------------------------
   420 1E47 20 A6 1E		FILLWS  JSR     DOWN        ; Move data down by the amount in bytes
   421 1E4A 20 DC 1E		        JSR     ADCEND      ; Adjust current end address
   422 1E4D A2 02		        LDX     #$02
   423 1E4F A0 00		        LDY     #$00
   424 1E51 B5 F9		WS      LDA     INH,X       ; Fetch data from display buffer
   425 1E53 91 E6		        STA     (CURADR),Y  ; Insert data into the data field
   426 1E55 CA			        DEX 
   427 1E56 C8			        INY 
   428 1E57 C4 F6		        CPY     BYTES       ; All inserted ?
   429 1E59 D0 F6		        BNE     WS          ; If not, continue
   430 1E5B 60			        RTS 
   431
   432 				;----------------------------------------------------------------------------
   433 				;       OPLEN calculates the length of a 6502 instruction.
   434 				;       Instruction length is saved in BYTES.
   435 				;----------------------------------------------------------------------------
   436 1E5C A0 00		OPLEN   LDY     #$00
   437 1E5E B1 E6		        LDA     (CURADR),Y  ; Fetch OPCode from WS
   438 1E60 A0 01		LENACC  LDY     #$01        ; Length of the OPCode is 1 byte
   439 1E62 C9 00		        CMP     #$00
   440 1E64 F0 1A		        BEQ     LENEND      ; BRK Instruction ?
   441 				        
   442 1E66 C9 40		        CMP     #$40
   443 1E68 F0 16		        BEQ     LENEND      ; TRI Instruction ?
   444 				        
   445 1E6A C9 60		        CMP     #$60
   446 1E6C F0 12		        BEQ     LENEND      ; RTS Instruction ?
   447 				        
   448 1E6E A0 03		        LDY     #$03
   449 1E70 C9 20		        CMP     #$20
   450 1E72 F0 0C		        BEQ     LENEND      ; JSR Instruction ?
   451 				        
   452 1E74 29 1F		        AND     #$1F        ; Strip to 5 bits
   453 1E76 C9 19		        CMP     #$19
   454 1E78 F0 06		        BEQ     LENEND      ; Any ABS,Y instruction ?
   455 				        
   456 1E7A 29 0F		        AND     #$0F        ; Strip to 4 bits
   457 1E7C AA			        TAX                 ; Use nibble as index
   458 1E7D BC 1F 1F		        LDY     LEN,X       ; Fetch length from LEN
   459 1E80 84 F6		LENEND  STY     BYTES       ; Discard length in bytes
   460 1E82 60			        RTS 
   461
   462 				;----------------------------------------------------------------------------
   463 				;       UP moves a data-field between CURADR and CENDADR upwards by the
   464 				;       amount in BYTES.
   465 				;----------------------------------------------------------------------------
   466 1E83 A5 E6		UP      LDA     CURADR
   467 1E85 85 EA		        STA     MOVADR
   468 1E87 A5 E7		        LDA     CURADR+1    ; MOVAD := CURADR
   469 1E89 85 EB		        STA     MOVADR+1
   470 1E8B A4 F6		UPLOOP  LDY     BYTES
   471 1E8D B1 EA		        LDA     (MOVADR),Y  ; Move upward by the number of bytes
   472 1E8F A0 00		        LDY     #$00
   473 1E91 91 EA		        STA     (MOVADR),Y
   474 1E93 E6 EA		        INC     MOVADR
   475 1E95 D0 02		        BNE     UPA
   476 				        
   477 1E97 E6 EB		        INC     MOVADR+1    ; MOVADR+1 := MOVADR+1 + 1
   478 1E99 A5 EA		UPA     LDA     MOVADR
   479 1E9B C5 E8		        CMP     CENDADR
   480 1E9D D0 EC		        BNE     UPLOOP      ; All data moved ?
   481 1E9F A5 EB		        LDA     MOVADR+1    ; If not continue
   482 1EA1 C5 E9		        CMP     CENDADR+1
   483 1EA3 D0 E6		        BNE     UPLOOP
   484 1EA5 60			        RTS 
   485
   486 				;----------------------------------------------------------------------------
   487 				;       DOWN moves a data-field between CURADR and CENDADR downwards by the
   488 				;       amount in BYTES.
   489 				;----------------------------------------------------------------------------
   490 1EA6 A5 E8		DOWN    LDA     CENDADR
   491 1EA8 85 EA		        STA     MOVADR      ; MOVAD := CEND
   492 1EAA A5 E9		        LDA     CENDADR+1
   493 1EAC 85 EB		        STA     MOVADR+1
   494 1EAE A0 00		DNLOOP  LDY     #$00
   495 1EB0 B1 EA		        LDA     (MOVADR),Y  ; Move downward by the number of bytes
   496 1EB2 A4 F6		        LDY     BYTES
   497 1EB4 91 EA		        STA     (MOVADR),Y
   498 1EB6 A5 EA		        LDA     MOVADR
   499 1EB8 C5 E6		        CMP     CURADR
   500 1EBA D0 06		        BNE     DNA         ; All data moved ?
   501 				        
   502 1EBC A5 EB		        LDA     MOVADR+1    ; If not, continue
   503 1EBE C5 E7		        CMP     CURADR+1
   504 1EC0 F0 10		        BEQ     DNEND
   505 1EC2 38			DNA     SEC 
   506 1EC3 A5 EA		        LDA     MOVADR
   507 1EC5 E9 01		        SBC     #$01
   508 1EC7 85 EA		        STA     MOVADR
   509 1EC9 A5 EB		        LDA     MOVADR+1    ; MOVAD := MOVAD - 1
   510 1ECB E9 00		        SBC     #$00
   511 1ECD 85 EB		        STA     MOVADR+1
   512 1ECF 4C AE 1E		        JMP     DNLOOP
   513 1ED2 60			DNEND   RTS 
   514
   515 				;----------------------------------------------------------------------------
   516 				;       BEGIN sets CURADR TO BEGADR
   517 				;----------------------------------------------------------------------------
   518 1ED3 A5 E2		BEGIN   LDA     BEGADR
   519 1ED5 85 E6		        STA     CURADR
   520 1ED7 A5 E3		        LDA     BEGADR+1    ; CURAD := BEGADR
   521 1ED9 85 E7		        STA     CURADR+1
   522 1EDB 60			        RTS 
   523
   524 				;----------------------------------------------------------------------------
   525 				;       ADCEND increases the current end-address by the number in BYTES.
   526 				;----------------------------------------------------------------------------
   527 1EDC 18			ADCEND  CLC 
   528 1EDD A5 E8		        LDA     CENDADR
   529 1EDF 65 F6		        ADC     BYTES       ; CEND := CEND + BYTES
   530 1EE1 85 E8		        STA     CENDADR
   531 1EE3 A5 E9		        LDA     CENDADR+1
   532 1EE5 69 00		        ADC     #$00
   533 1EE7 85 E9		        STA     CENDADR+1
   534 1EE9 60			        RTS 
   535
   536 				;----------------------------------------------------------------------------
   537 				;       RECEND decreases the current end-address by the number in BYTES.
   538 				;----------------------------------------------------------------------------
   539 1EEA 38			RECEND  SEC 
   540 1EEB A5 E8		        LDA     CENDADR
   541 1EED E5 F6		        SBC     BYTES       ; CEND := CEND - BYTES
   542 1EEF 85 E8		        STA     CENDADR
   543 1EF1 A5 E9		        LDA     CENDADR+1
   544 1EF3 E9 00		        SBC     #$00
   545 1EF5 85 E9		        STA     CENDADR+1
   546 1EF7 60			        RTS 
   547
   548 				;----------------------------------------------------------------------------
   549 				;       NEXT increases the current displayed address by the number in BYTES.
   550 				;----------------------------------------------------------------------------
   551 1EF8 18			NEXT    CLC 
   552 1EF9 A5 E6		        LDA     CURADR
   553 1EFB 65 F6		        ADC     BYTES       ; CURAD := CURAD + BYTES
   554 1EFD 85 E6		        STA     CURADR
   555 1EFF A5 E7		        LDA     CURADR+1
   556 1F01 69 00		        ADC     #$00
   557 1F03 85 E7		        STA     CURADR+1
   558 1F05 38			        SEC 
   559 1F06 A5 E6		        LDA     CURADR
   560 1F08 E5 E8		        SBC     CENDADR
   561 1F0A A5 E7		        LDA     CURADR+1
   562 1F0C E5 E9		        SBC     CENDADR+1
   563 1F0E 60			        RTS 
   564
   565 				;----------------------------------------------------------------------------
   566 				;       Lookup table "LOOK"" is used to convert a hex number into a pattern
   567 				;       for the seven-segment displays. 
   568 				;       Lookup table "LEN" is used to convert an instruction into an 
   569 				;       instruction length.
   570 				;----------------------------------------------------------------------------
   571 1F0F 40			LOOK    .byte   $40         ; "0"
   572 1F10 79			        .byte   $79         ; "1"
   573 1F11 24			        .byte   $24         ; "2"
   574 1F12 30			        .byte   $30         ; "3"
   575 1F13 19			        .byte   $19         ; "4"
   576 1F14 12			        .byte   $12         ; "5"
   577 1F15 02			        .byte   $02         ; "6"
   578 1F16 78			        .byte   $78         ; "7"
   579 1F17 00			        .byte   $00         ; "8"
   580 1F18 10			        .byte   $10         ; "9"
   581 1F19 08			        .byte   $08         ; "A"
   582 1F1A 03			        .byte   $03         ; "B"
   583 1F1B 46			        .byte   $46         ; "C"
   584 1F1C 21			        .byte   $21         ; "D"
   585 1F1D 06			        .byte   $06         ; "E"
   586 1F1E 0E			        .byte   $0E         ; "F"
   587
   588 1F1F 02			LEN     .byte   $02
   589 1F20 02			        .byte   $02
   590 1F21 02			        .byte   $02
   591 1F22 01			        .byte   $01
   592 1F23 02			        .byte   $02
   593 1F24 02			        .byte   $02
   594 1F25 02			        .byte   $02
   595 1F26 01			        .byte   $01
   596 1F27 01			        .byte   $01
   597 1F28 02			        .byte   $02
   598 1F29 01			        .byte   $01
   599 1F2A 01			        .byte   $01
   600 1F2B 03			        .byte   $03
   601 1F2C 03			        .byte   $03
   602 1F2D 03			        .byte   $03
   603 1F2E 03			        .byte   $03
   604
   605 				; NMI and IRQ JMP vectors are now moved to jc2_main.asm
   606
   607 1F2F				ORG	$1F35		; maintain compatibility with original Monitor
   608 				;----------------------------------------------------------------------------
   609 				;       GETLBL is an assembler subroutine. It searches for labels on the
   610 				;       symbol pseudo stack. If this stack contains a valid label, it returns
   611 				;       with the high-order label address in X and the low-order label
   612 				;       address in A. If no valid label is found, it returns with Z=1.
   613 				;----------------------------------------------------------------------------
   614 1F35 B1 E6		GETLBL  LDA     (CURADR),Y  ; Fetch current label number from WS
   615 1F37 A0 FF		        LDY     #$FF        ; Reset pseudo stack
   616 1F39 C4 EE		SYMA    CPY     LABELS      ; Upper most symbol table address ?
   617 1F3B F0 0D		        BEQ     SYMB        ; If yes, return, no label on pseudo stack
   618 				        
   619 1F3D D1 EC		        CMP     (TABLEA),Y  ; Label Nr. in WS = Label Nr. on pseudo stack
   620 1F3F D0 0A		        BNE     SYMNXT
   621 				        
   622 1F41 88			        DEY                 ; If yes, get high order address
   623 1F42 B1 EC		        LDA     (TABLEA),Y
   624 1F44 AA			        TAX                 ; Discard high order, add in X
   625 1F45 88			        DEY 
   626 1F46 B1 EC		        LDA     (TABLEA),Y  ; Get low order add
   627 1F48 A0 01		        LDY     #$01        ; Prepare Y register
   628 1F4A 60			SYMB    RTS 
   629
   630 1F4B 88			SYMNXT  DEY                 ; *********   *********
   631 1F4C 88			        DEY                 ; * X=ADH *   * A=ADL *
   632 1F4D 88			        DEY                 ; *********   *********
   633 1F4E D0 E9		        BNE     SYMA
   634 1F50 60			        RTS 
   635
   636 				;----------------------------------------------------------------------------
   637 				;       ASSEMBLER main routine.
   638 				;
   639 				;       The following instructions are assembled:
   640 				;       - JSR instruction
   641 				;       - JMP instruction 
   642 				;       - BRANCH instructions
   643 				;----------------------------------------------------------------------------
   644 1F51 38			ASSEMB  SEC 
   645 1F52 A5 E4		        LDA     ENDADR
   646 1F54 E9 FF		        SBC     #$FF
   647 1F56 85 EC		        STA     TABLEA      ; TABLE := ENDAD - $FF
   648 1F58 A5 E5		        LDA     ENDADR+1
   649 1F5A E9 00		        SBC     #$00
   650 1F5C 85 ED		        STA     TABLEA+1
   651 1F5E A9 FF		        LDA     #$FF
   652 1F60 85 EE		        STA     LABELS
   653 1F62 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   654
   655 1F65 20 5C 1E		PASSA   JSR     OPLEN       ; Start pass one, get current instruction
   656 1F68 A0 00		        LDY     #$00
   657 1F6A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   658 1F6C C9 FF		        CMP     #$FF        ; Is the current instruction a label ? 
   659 1F6E D0 1D		        BNE     NXTINS
   660 				        
   661 1F70 C8			        INY 
   662 1F71 B1 E6		        LDA     (CURADR),Y  ; If yes, fetch label number
   663 1F73 A4 EE		        LDY     LABELS
   664 1F75 91 EC		        STA     (TABLEA),Y  ; Push label number on symbol stack
   665 1F77 88			        DEY 
   666 1F78 A5 E7		        LDA     CURADR+1    ; Get high order address
   667 1F7A 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   668 1F7C 88			        DEY 
   669 1F7D A5 E6		        LDA     CURADR      ; Get high order address
   670 1F7F 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   671 1F81 88			        DEY 
   672 1F82 84 EE		        STY     LABELS      ; Adjust pseudo stack pointer
   673 1F84 20 83 1E		        JSR     UP          ; Delete current label in ws
   674 1F87 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   675 1F8A 4C 65 1F		        JMP     PASSA       ; Look for more labels
   676
   677 1F8D 20 F8 1E		NXTINS  JSR     NEXT        ; If no label skip to the next instruction
   678 1F90 30 D3		        BMI     PASSA       ; All labels in WS collected ?
   679 1F92 20 D3 1E		        JSR     BEGIN       ; Start pass 2
   680 				        
   681 1F95 20 5C 1E		PASSB   JSR     OPLEN       ; Get length of the current instruction
   682 1F98 A0 00		        LDY     #$00
   683 1F9A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   684 1F9C C9 4C		        CMP     #$4C        ; JMP instruction ?
   685 1F9E F0 16		        BEQ     JUMPS
   686 				        
   687 1FA0 C9 20		        CMP     #$20        ; JSR Instruction ?
   688 1FA2 F0 12		        BEQ     JUMPS
   689 				        
   690 1FA4 29 1F		        AND     #$1F        ; Strip to 5 bits
   691 1FA6 C9 10		        CMP     #$10        ; Any branch instruction ?
   692 1FA8 F0 1A		        BEQ     BRINST
   693 				        
   694 1FAA 20 F8 1E		PB      JSR     NEXT        ; If not, return
   695 1FAD 30 E6		        BMI     PASSB       ; All labels between CURAD and ENDAD assembled ?
   696 				        
   697 1FAF A9 03		        LDA     #$03        ; Enable 3 display buffers
   698 1FB1 85 F6		        STA     BYTES
   699 1FB3 4C 33 1C		        JMP     START       ; Exit here
   700
   701 1FB6 C8			JUMPS   INY                 ; Set pointer to label number
   702 1FB7 20 35 1F		        JSR     GETLBL      ; Get label address
   703 1FBA F0 EE		        BEQ     PB          ; Return if not found
   704 				        
   705 1FBC 91 E6		        STA     (CURADR),Y  ; Store low order address
   706 1FBE 8A			        TXA 
   707 1FBF C8			        INY 
   708 1FC0 91 E6		        STA     (CURADR),Y  ; Store high order address
   709 1FC2 D0 E6		        BNE     PB
   710
   711 1FC4 C8			BRINST  INY                 ; Set pointer to label number
   712 1FC5 20 35 1F		        JSR     GETLBL      ; Get label address
   713 1FC8 F0 E0		        BEQ     PB          ; Return if label not found
   714 				        
   715 1FCA 38			        SEC 
   716 1FCB E5 E6		        SBC     CURADR      ; Calculate branch offset
   717 1FCD 38			        SEC 
   718 1FCE E9 02		        SBC     #$02        ; DESTINATION - SOURCE - 2 = OFFSET
   719 1FD0 91 E6		        STA     (CURADR),Y  ; Insert branch offset in WS
   720 1FD2 4C AA 1F		        JMP     PB
   721
   722 				;----------------------------------------------------------------------------
   723 				;       BRANCH calculates the offset of branch instructions. The 2 right-hand
   724 				;       displays show the calculated offset defined by the 4 left-hand
   725 				;       displays. The program must be stopped by the RESET key.
   726 				;----------------------------------------------------------------------------
   727 1FD5 D8			BRANCH  CLD 
   728 1FD6 A9 00		        LDA     #$00        ; Reset display buffer
   729 1FD8 85 FB		        STA     POINT+1
   730 1FDA 85 FA		        STA     POINT
   731 1FDC 85 F9		        STA     INH
   732 1FDE 20 6F 1D		BR      JSR     GETBYT      ; Read source
   733 1FE1 10 F2		        BPL     BRANCH      ; Command key ?
   734 				        
   735 1FE3 85 FB		        STA     POINT+1    ; Save source in buffer
   736 1FE5 20 6F 1D		        JSR     GETBYT      ; Read destination
   737 1FE8 10 EB		        BPL     BRANCH      ; Command key ?
   738
   739 1FEA 85 FA		        STA     POINT       ; Save destination in buffer
   740 1FEC 18			        CLC 
   741 1FED A5 FA		        LDA     POINT       ; Fetch destination
   742 1FEF E5 FB		        SBC     POINT+1     ; Substract source
   743 1FF1 85 F9		        STA     INH
   744 1FF3 C6 F9		        DEC     INH         ; Equalize and save offset in buffer
   745 1FF5 4C DE 1F		        JMP     BR
   746
   747 				;----------------------------------------------------------------------------
   748 				;       END OF JUNIOR'S MONITOR
   749 				;----------------------------------------------------------------------------
    29 				;-------------------------------------------------------------------------------------------------------
    30 1FF8			MONITOR_END	
    31 						.endl
    32 				;-------------------------------------------------------------------------------------------------------
    33
    34 9FF8					ORG 	$B000       		; start address of BASIC (12K)
    35 B000			RAM_TOP		icl 	"jc2_basic.asm"		; end of user RAM+1 (set as needed, should be page aligned)
Source: jc2_basic.asm
     1
     2 				; Enhanced BASIC ver 2.28
     3
     4 				; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     5
     6 				; 2.00	new revision numbers start here
     7 				; 2.01	fixed LCASE$() and UCASE$()
     8 				; 2.02	new get value routine done
     9 				; 2.03	changed RND() to galoise method
    10 				; 2.04	fixed SPC()
    11 				; 2.05	new get value routine fixed
    12 				; 2.06	changed USR() code
    13 				; 2.07	fixed STR$()
    14 				; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    15 				; 2.09	fixed RND()
    16 				; 2.10	integrated missed changes from an earlier version
    17 				; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    18 				; 2.21	fixed IF .. THEN RETURN to not cause error
    19 				; 2.22	fixed RND() breaking the get byte routine
    20 				; 2.25  Emile: I2C addresses corrected for V1.1.4 bios and integrated with BIOS & MON source-files.
    21 				; 2.26  - I2Cout, I2Cin() and DOS commands added
    22 				;	- Destructive RAM memory test disabled
    23 				;       - Patches from EhBASIC 2.22 added: 
    24 				;         - RAM above code/Ibuff above patch (LAB_20DC)
    25 				;	  - Some function outputs (e.g. FRE()) limited to integers are negative (LAB_UAYFC)
    26 				;         - Use of decimal mode and invalid BCD (LAB_AL2X)
    27 				;	  - First statement after direct mode does not set continue pointer (LAB_1491, LAB_15C2, LAB_163B, LAB_CONT, LAB_1934)
    28 				;	  - String compare of equal strings in direct mode returns FALSE (LAB_1C25)
    29 				;	  - FALSE value stored to a variable after string compare is not exactly zero (LAB_LET)
    30 				;	  - Stack floor protection does not cater for background interrupts (LAB_1212)
    31 				;	  - Allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack (LAB_174D)
    32 				; 2.27	  - INPBUF moved from $768 to $1868. Also moved Decss, Decssp1, ADREL, ADREH, ADRSL, ADRSH to lower ZP-addresses
    33 				; 2.28	  Bugfix ADREL/ADREH, ADRSL/ADRSH. They had other names in BIOS, so should not be removed!
    34 				;	  Bugfix MODE and NUML/NUMH no init. in LAB_LOAD.
    35 				; ********************************************************************************************************
    36
    37 				; changes by Joerg Walke
    38 				; ----------------------
    39 				; 2022/05/14 added command BEEP
    40 				; 2022/05/15 added command PLIST
    41 				; 2022/05/16 changed BPL SwapErr to BNE SwapErr in LAB_SWAP to avoid command always throwing 'Type mismatch Error'
    42 				; 2024/02/03 Source adapted for MAD-Assembler
    43 				; ********************************************************************************************************
    44
    45 				; zero page use ..
    46 = 0000			LAB_WARM		= $00			; BASIC warm start entry point
    47 = 0001			Wrmjpl 			= LAB_WARM+1		; BASIC warm start vector jump low byte
    48 = 0002			Wrmjph 			= LAB_WARM+2		; BASIC warm start vector jump high byte
    49
    50 				; *** moved from $DC-$E1 - J.Walke 2022/07/29 *****************************
    51 = 0003			NmiBase			= $03			; NMI handler enabled/setup/triggered flags
    52 										; bit	function
    53 										; ===	========
    54 										; 7	interrupt enabled
    55 										; 6	interrupt setup
    56 										; 5	interrupt happened
    57
    58 				;			= $04		; NMI handler addr low byte
    59 				;			= $05		; NMI handler addr high byte
    60 = 0006			IrqBase			= $06		; IRQ handler enabled/setup/triggered flags
    61 				;			= $07		; IRQ handler addr low byte
    62 				;			= $08		; IRQ handler addr high byte
    63
    64 				; *************************************************************************
    65
    66 = 000A			Usrjmp			= $0A		; USR function JMP address
    67 = 000B			Usrjpl			= Usrjmp+1	; USR function JMP vector low byte
    68 = 000C			Usrjph			= Usrjmp+2	; USR function JMP vector high byte
    69 = 000D			Nullct			= $0D		; nulls output after each line
    70 = 000E			TPos			= $0E		; BASIC terminal position byte
    71 = 000F			TWidth			= $0F		; BASIC terminal width byte
    72 = 0010			Iclim			= $10		; input column limit
    73 = 0011			Itempl			= $11		; temporary integer low byte
    74 = 0012			Itemph			= Itempl+1	; temporary integer high byte
    75
    76 = 0011			nums_1			= Itempl	; number to bin/hex string convert MSB
    77 = 0012			nums_2			= nums_1+1	; number to bin/hex string convert
    78 = 0013			nums_3			= nums_1+2	; number to bin/hex string convert LSB
    79
    80 				; *** free space **********************************************************
    81 				;			= $14		; *used by JC2 system
    82 				;			= $15		; *used by JC2 system
    83 				;			= $16		; *used by JC2 system
    84 				;			= $17		; *used by JC2 system
    85 				;			= $18		; *used by JC2 system
    86 				;			= $19		; *used by JC2 system 
    87 				; *************************************************************************
    88
    89 = 001A			Temp1			= $1A		; temporary byte for free use
    90
    91 = 001B			Srchc			= $1B		; search character
    92 = 001B			Temp3			= Srchc		; temp byte used in number routines
    93 = 001C			Scnquo			= $1C		; scan-between-quotes flag
    94 = 001C			Asrch			= Scnquo	; alt search character
    95
    96 = 001B			XOAw_l			= Srchc		; eXclusive OR, OR and AND word low byte
    97 = 001C			XOAw_h			= Scnquo	; eXclusive OR, OR and AND word high byte
    98
    99 = 001D			Ibptr			= $1D		; input buffer pointer
   100 = 001D			Dimcnt			= Ibptr		; # of dimensions
   101 = 001D			Tindx			= Ibptr		; token index
   102
   103 = 001E			Defdim			= $1E		; default DIM flag
   104 = 001F			Dtypef			= $1F		; data type flag, $FF=string, $00=numeric
   105 = 0020			Oquote			= $20		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
   106 = 0020			Gclctd			= $20		; garbage collected flag
   107 = 0021			Sufnxf			= $21		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   108 = 0022			Imode			= $22		; input mode flag, $00=INPUT, $80=READ
   109
   110 = 0023			Cflag			= $23		; comparison evaluation flag
   111
   112 = 0024			TabSiz			= $24		; TAB step size (was input flag)
   113
   114 = 0025			next_s			= $25		; next descriptor stack address
   115
   116 									; these two bytes form a word pointer to the item
   117 									; currently on top of the descriptor stack
   118
   119 = 0026			last_sl			= $26		; last descriptor stack address low byte
   120 = 0027			last_sh			= $27		; last descriptor stack address high byte (always $00)
   121
   122 = 0028			des_sk			= $28		; descriptor stack start address (temp strings)
   123
   124 				;			= $30		; End of descriptor stack
   125
   126 = 0031			ut1_pl			= $31		; utility pointer 1 low byte
   127 = 0032			ut1_ph			= ut1_pl+1	; utility pointer 1 high byte
   128 = 0033			ut2_pl			= $33		; utility pointer 2 low byte
   129 = 0034			ut2_ph			= ut2_pl+1	; utility pointer 2 high byte
   130
   131 = 0031			Temp_2			= ut1_pl	; temp byte for block move	
   132
   133 = 0035			FACt_1			= $35		; FAC temp mantissa1
   134 = 0036			FACt_2			= FACt_1+1	; FAC temp mantissa2
   135 = 0037			FACt_3			= FACt_2+1	; FAC temp mantissa3
   136
   137 = 0036			dims_l			= FACt_2	; array dimension size low byte
   138 = 0037			dims_h			= FACt_3	; array dimension size high byte
   139
   140 = 0038			TempB			= $38		; temp page 0 byte
   141
   142 = 0039			Smeml			= $39		; start of mem low byte		(Start-of-Basic)
   143 = 003A			Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
   144 = 003B			Svarl			= $3B		; start of vars low byte	(Start-of-Variables)
   145 = 003C			Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
   146 = 003D			Sarryl			= $3D		; var mem end low byte		(Start-of-Arrays)
   147 = 003E			Sarryh			= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
   148 = 003F			Earryl			= $3F		; array mem end low byte	(End-of-Arrays)
   149 = 0040			Earryh			= Earryl+1	; array mem end high byte	(End-of-Arrays)
   150 = 0041			Sstorl			= $41		; string storage low byte	(String storage (moving down))
   151 = 0042			Sstorh			= Sstorl+1	; string storage high byte	(String storage (moving down))
   152 = 0043			Sutill			= $43		; string utility ptr low byte
   153 = 0044			Sutilh			= Sutill+1	; string utility ptr high byte
   154 = 0045			Ememl			= $45		; end of mem low byte		(Limit-of-memory)
   155 = 0046			Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
   156 = 0047			Clinel			= $47		; current line low byte		(Basic line number)
   157 = 0048			Clineh			= Clinel+1	; current line high byte	(Basic line number)
   158 = 0049			Blinel			= $49		; break line low byte		(Previous Basic line number)
   159 = 004A			Blineh			= Blinel+1	; break line high byte		(Previous Basic line number)
   160
   161 = 004B			Cpntrl			= $4B		; continue pointer low byte
   162 = 004C			Cpntrh			= Cpntrl+1	; continue pointer high byte
   163
   164 = 004D			Dlinel			= $4D		; current DATA line low byte
   165 = 004E			Dlineh			= Dlinel+1	; current DATA line high byte
   166
   167 = 004F			Dptrl			= $4F		; DATA pointer low byte
   168 = 0050			Dptrh			= Dptrl+1	; DATA pointer high byte
   169
   170 = 0051			Rdptrl			= $51		; read pointer low byte
   171 = 0052			Rdptrh			= Rdptrl+1	; read pointer high byte
   172
   173 = 0053			Varnm1			= $53		; current var name 1st byte
   174 = 0054			Varnm2			= Varnm1+1	; current var name 2nd byte
   175
   176 = 0055			Cvaral			= $55		; current var address low byte
   177 = 0056			Cvarah			= Cvaral+1	; current var address high byte
   178
   179 = 0057			Frnxtl			= $57		; var pointer for FOR/NEXT low byte
   180 = 0058			Frnxth			= Frnxtl+1	; var pointer for FOR/NEXT high byte
   181
   182 = 0057			Tidx1			= Frnxtl	; temp line index
   183
   184 = 0057			Lvarpl			= Frnxtl	; let var pointer low byte
   185 = 0058			Lvarph			= Frnxth	; let var pointer high byte
   186
   187 = 0059			prstk			= $59		; precedence stacked flag
   188
   189 = 005B			comp_f			= $5B		; compare function flag, bits 0,1 and 2 used
   190 									; bit 2 set if >
   191 									; bit 1 set if =
   192 									; bit 0 set if <
   193
   194 = 005C			func_l			= $5C		; function pointer low byte
   195 = 005D			func_h			= func_l+1	; function pointer high byte
   196
   197 = 005C			garb_l			= func_l	; garbage collection working pointer low byte
   198 = 005D			garb_h			= func_h	; garbage collection working pointer high byte
   199
   200 = 005E			des_2l			= $5E		; string descriptor_2 pointer low byte
   201 = 005F			des_2h			= des_2l+1	; string descriptor_2 pointer high byte
   202
   203 = 0060			g_step			= $60		; garbage collect step size
   204
   205 = 0061			Fnxjmp			= $61		; jump vector for functions
   206 = 0062			Fnxjpl			= Fnxjmp+1	; functions jump vector low byte
   207 = 0063			Fnxjph			= Fnxjmp+2	; functions jump vector high byte
   208
   209 = 0062			g_indx			= Fnxjpl	; garbage collect temp index
   210 					
   211 = 0063			FAC2_r			= $63		; FAC2 rounding byte
   212
   213 = 0064			Adatal			= $64		; array data pointer low byte
   214 = 0065			Adatah			= Adatal+1	; array data pointer high  byte
   215
   216 = 0064			Nbendl			= Adatal	; new block end pointer low byte
   217 = 0065			Nbendh			= Adatah	; new block end pointer high  byte
   218
   219 = 0066			Obendl			= $66		; old block end pointer low byte
   220 = 0067			Obendh			= Obendl+1	; old block end pointer high  byte
   221
   222 = 0068			numexp			= $68		; string to float number exponent count
   223 = 0069			expcnt			= $69		; string to float exponent count
   224
   225 = 0068			numbit			= numexp	; bit count for array element calculations
   226
   227 = 006A			numdpf			= $6A		; string to float decimal point flag
   228 = 006B			expneg			= $6B		; string to float eval exponent -ve flag
   229
   230 = 006A			Astrtl			= numdpf	; array start pointer low byte
   231 = 006B			Astrth			= expneg	; array start pointer high  byte
   232
   233 = 006A			Histrl			= numdpf	; highest string low byte
   234 = 006B			Histrh			= expneg	; highest string high  byte
   235
   236 = 006A			Baslnl			= numdpf	; BASIC search line pointer low byte
   237 = 006B			Baslnh			= expneg	; BASIC search line pointer high  byte
   238
   239 = 006A			Fvar_l			= numdpf	; find/found variable pointer low byte
   240 = 006B			Fvar_h			= expneg	; find/found variable pointer high  byte
   241
   242 = 006A			Ostrtl			= numdpf	; old block start pointer low byte
   243 = 006B			Ostrth			= expneg	; old block start pointer high  byte
   244
   245 = 006A			Vrschl			= numdpf	; variable search pointer low byte
   246 = 006B			Vrschh			= expneg	; variable search pointer high  byte
   247
   248 = 006C			FAC1_e			= $6C		; FAC1 exponent
   249 = 006D			FAC1_1			= FAC1_e+1	; FAC1 mantissa1
   250 = 006E			FAC1_2			= FAC1_e+2	; FAC1 mantissa2
   251 = 006F			FAC1_3			= FAC1_e+3	; FAC1 mantissa3
   252 = 0070			FAC1_s			= FAC1_e+4	; FAC1 sign (b7)
   253
   254 = 006C			str_ln			= FAC1_e	; string length
   255 = 006D			str_pl			= FAC1_1	; string pointer low byte
   256 = 006E			str_ph			= FAC1_2	; string pointer high byte
   257
   258 = 006E			des_pl			= FAC1_2	; string descriptor pointer low byte
   259 = 006F			des_ph			= FAC1_3	; string descriptor pointer high byte
   260
   261 = 006F			mids_l			= FAC1_3	; MID$ string temp length byte
   262
   263 = 0071			negnum			= $71		; string to float eval -ve flag
   264 = 0071			numcon			= $71		; series evaluation constant count
   265
   266 = 0072			FAC1_o			= $72		; FAC1 overflow byte
   267
   268 = 0073			FAC2_e			= $73		; FAC2 exponent
   269 = 0074			FAC2_1			= FAC2_e+1	; FAC2 mantissa1
   270 = 0075			FAC2_2			= FAC2_e+2	; FAC2 mantissa2
   271 = 0076			FAC2_3			= FAC2_e+3	; FAC2 mantissa3
   272 = 0077			FAC2_s			= FAC2_e+4	; FAC2 sign (b7)
   273
   274 = 0078			FAC_sc			= $78		; FAC sign comparison, Acc#1 vs #2
   275 = 0079			FAC1_r			= $79		; FAC1 rounding byte
   276
   277 = 0078			ssptr_l			= FAC_sc	; string start pointer low byte
   278 = 0079			ssptr_h			= FAC1_r	; string start pointer high byte
   279
   280 = 0078			sdescr			= FAC_sc	; string descriptor pointer
   281
   282 = 007A			csidx			= $7A		; line crunch save index
   283 = 007A			Asptl			= csidx		; array size/pointer low byte
   284 = 007B			Aspth			= $7B		; array size/pointer high byte
   285
   286 = 007A			Btmpl			= Asptl		; BASIC pointer temp low byte
   287 = 007B			Btmph			= Aspth		; BASIC pointer temp low byte
   288
   289 = 007A			Cptrl			= Asptl		; BASIC pointer temp low byte
   290 = 007B			Cptrh			= Aspth		; BASIC pointer temp low byte
   291
   292 = 007A			Sendl			= Asptl		; BASIC pointer temp low byte
   293 = 007B			Sendh			= Aspth		; BASIC pointer temp low byte
   294
   295 = 007C			LAB_IGBY		= $7C		; get next BASIC byte subroutine
   296
   297 = 0082			LAB_GBYT		= $82		; get current BASIC byte subroutine
   298 = 0083			Bpntrl			= $83		; BASIC execute (get byte) pointer low byte
   299 = 0084			Bpntrh			= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   300
   301 				;			= $97		; end of get BASIC char subroutine
   302
   303 = 0098			Rbyte4			= $98		; extra PRNG byte
   304 = 0099			Rbyte1			= Rbyte4+1	; most significant PRNG byte
   305 = 009A			Rbyte2			= Rbyte4+2	; middle PRNG byte
   306 = 009B			Rbyte3			= Rbyte4+3	; least significant PRNG byte
   307
   308 = 009C			I2Cstat			= $9C		; BASIC I2C read byte or ACK/NACK bit
   309 = 009D			Decss			= $9D		; BASIC number to decimal string start LSB (moved from $EF)
   310 = 009E			Decssp1			= $9E		; BASIC number to decimal string start MSB (moved from $F0)
   311
   312 				; token values needed for BASIC
   313
   314 				; primary command tokens (can start a statement)
   315
   316 = 0080			TK_END		= $80			; END token
   317 = 0081			TK_FOR		= TK_END+1		; FOR token
   318 = 0082			TK_NEXT		= TK_FOR+1		; NEXT token
   319 = 0083			TK_DATA		= TK_NEXT+1		; DATA token
   320 = 0084			TK_INPUT	= TK_DATA+1		; INPUT token
   321 = 0085			TK_DIM		= TK_INPUT+1		; DIM token
   322 = 0086			TK_READ		= TK_DIM+1		; READ token
   323 = 0087			TK_LET		= TK_READ+1		; LET token
   324 = 0088			TK_DEC		= TK_LET+1		; DEC token
   325 = 0089			TK_GOTO		= TK_DEC+1		; GOTO token
   326 = 008A			TK_RUN		= TK_GOTO+1		; RUN token
   327 = 008B			TK_IF		= TK_RUN+1		; IF token
   328 = 008C			TK_RESTORE	= TK_IF+1		; RESTORE token
   329 = 008D			TK_GOSUB	= TK_RESTORE+1		; GOSUB token
   330 = 008E			TK_RETIRQ	= TK_GOSUB+1		; RETIRQ token
   331 = 008F			TK_RETNMI	= TK_RETIRQ+1		; RETNMI token
   332 = 0090			TK_RETURN	= TK_RETNMI+1		; RETURN token
   333 = 0091			TK_REM		= TK_RETURN+1		; REM token
   334 = 0092			TK_STOP		= TK_REM+1		; STOP token
   335 = 0093			TK_ON		= TK_STOP+1		; ON token
   336 = 0094			TK_NULL		= TK_ON+1		; NULL token
   337 = 0095			TK_INC		= TK_NULL+1		; INC token
   338 = 0096			TK_WAIT		= TK_INC+1		; WAIT token
   339 = 0097			TK_LOAD		= TK_WAIT+1		; LOAD token
   340 = 0098			TK_SAVE		= TK_LOAD+1		; SAVE token
   341 = 0099			TK_DEF		= TK_SAVE+1		; DEF token
   342 = 009A			TK_POKE		= TK_DEF+1		; POKE token
   343 = 009B			TK_DOKE		= TK_POKE+1		; DOKE token
   344 = 009C			TK_CALL		= TK_DOKE+1		; CALL token
   345 = 009D			TK_DO		= TK_CALL+1		; DO token
   346 = 009E			TK_LOOP		= TK_DO+1		; LOOP token
   347 = 009F			TK_PRINT	= TK_LOOP+1		; PRINT token
   348 = 00A0			TK_CONT		= TK_PRINT+1		; CONT token
   349 = 00A1			TK_LIST		= TK_CONT+1		; LIST token
   350 = 00A2			TK_CLEAR	= TK_LIST+1		; CLEAR token
   351 = 00A3			TK_NEW		= TK_CLEAR+1		; NEW token
   352 = 00A4			TK_WIDTH	= TK_NEW+1		; WIDTH token
   353 = 00A5			TK_GET		= TK_WIDTH+1		; GET token
   354 = 00A6			TK_SWAP		= TK_GET+1		; SWAP token
   355 = 00A7			TK_BITSET	= TK_SWAP+1		; BITSET token
   356 = 00A8			TK_BITCLR	= TK_BITSET+1		; BITCLR token
   357 = 00A9			TK_IRQ		= TK_BITCLR+1		; IRQ token
   358 = 00AA			TK_NMI		= TK_IRQ+1		; NMI token
   359 = 00AB			TK_BEEP		= TK_NMI+1		; BEEP token
   360 = 00AC			TK_PLIST    	= TK_BEEP+1		; PLIST token
   361 = 00AD			TK_HOME		= TK_PLIST+1		; HOME token
   362 = 00AE			TK_CLS		= TK_HOME+1		; CLS token
   363 = 00AF			TK_NORMAL	= TK_CLS+1		; NORMAL token
   364 = 00B0			TK_INVERSE	= TK_NORMAL+1		; INVERSE token
   365 = 00B1			TK_FLASH	= TK_INVERSE+1		; FLASH token
   366 = 00B2			TK_LOCATE	= TK_FLASH+1		; LOCATE token	
   367 = 00B3			TK_INNUM	= TK_LOCATE+1		; IN# token
   368 = 00B4			TK_PRNUM	= TK_INNUM+1		; PR# token
   369 = 00B5			TK_PORTIO	= TK_PRNUM+1		; PORTIO token
   370 = 00B6			TK_PORTOUT	= TK_PORTIO+1		; PORTOUT token
   371 = 00B7			TK_SCREEN	= TK_PORTOUT+1		; SCREEN token ###
   372 = 00B8			TK_PIXEL	= TK_SCREEN+1		; PIXEL token ###
   373 = 00B9			TK_LINE		= TK_PIXEL+1		; LINE token ###
   374 = 00BA			TK_OVAL		= TK_LINE+1		; OVAL token ###
   375 = 00BB			TK_RECT		= TK_OVAL+1		; RECT token ###
   376 = 00BC			TK_COLOR	= TK_RECT+1		; COLOR token ###
   377 = 00BD			TK_DELAY	= TK_COLOR+1		; DELAY token
   378 = 00BE			TK_I2COUT	= TK_DELAY+1		; I2Cout token
   379 = 00BF			TK_DOS		= TK_I2COUT+1		; DOS token
   380
   381 				; secondary command tokens, can't start a statement
   382
   383 = 00C0			TK_TAB		= TK_DOS+1		; TAB token
   384 = 00C1			TK_ELSE		= TK_TAB+1		; ELSE token
   385 = 00C2			TK_TO		= TK_ELSE+1		; TO token
   386 = 00C3			TK_FN		= TK_TO+1		; FN token
   387 = 00C4			TK_SPC		= TK_FN+1		; SPC token
   388 = 00C5			TK_THEN		= TK_SPC+1		; THEN token
   389 = 00C6			TK_NOT		= TK_THEN+1		; NOT token
   390 = 00C7			TK_STEP		= TK_NOT+1		; STEP token
   391 = 00C8			TK_UNTIL	= TK_STEP+1		; UNTIL token
   392 = 00C9			TK_WHILE	= TK_UNTIL+1		; WHILE token
   393 = 00CA			TK_OFF		= TK_WHILE+1		; OFF token
   394
   395 				; opperator tokens
   396
   397 = 00CB			TK_PLUS		= TK_OFF+1		; + token
   398 = 00CC			TK_MINUS	= TK_PLUS+1		; - token
   399 = 00CD			TK_MUL		= TK_MINUS+1		; * token
   400 = 00CE			TK_DIV		= TK_MUL+1		; / token
   401 = 00CF			TK_MOD		= TK_DIV+1		; MOD token ###
   402 = 00D0			TK_POWER	= TK_MOD+1		; ^ token
   403 = 00D1			TK_AND		= TK_POWER+1		; AND token
   404 = 00D2			TK_EOR		= TK_AND+1		; EOR token
   405 = 00D3			TK_OR		= TK_EOR+1		; OR token
   406 = 00D4			TK_RSHIFT	= TK_OR+1		; RSHIFT token
   407 = 00D5			TK_LSHIFT	= TK_RSHIFT+1		; LSHIFT token
   408 = 00D6			TK_GT		= TK_LSHIFT+1		; > token
   409 = 00D7			TK_EQUAL	= TK_GT+1		; = token
   410 = 00D8			TK_LT		= TK_EQUAL+1		; < token
   411
   412 				; functions tokens
   413
   414 = 00D9			TK_SGN		= TK_LT+1		; SGN token
   415 = 00DA			TK_INT		= TK_SGN+1		; INT token
   416 = 00DB			TK_ABS		= TK_INT+1		; ABS token
   417 = 00DC			TK_USR		= TK_ABS+1		; USR token
   418 = 00DD			TK_FRE		= TK_USR+1		; FRE token
   419 = 00DE			TK_POS		= TK_FRE+1		; POS token
   420 = 00DF			TK_SQR		= TK_POS+1		; SQR token
   421 = 00E0			TK_RND		= TK_SQR+1		; RND token
   422 = 00E1			TK_LOG		= TK_RND+1		; LOG token
   423 = 00E2			TK_EXP		= TK_LOG+1		; EXP token
   424 = 00E3			TK_COS		= TK_EXP+1		; COS token
   425 = 00E4			TK_SIN		= TK_COS+1		; SIN token
   426 = 00E5			TK_TAN		= TK_SIN+1		; TAN token
   427 = 00E6			TK_ATN		= TK_TAN+1		; ATN token
   428 = 00E7			TK_PEEK		= TK_ATN+1		; PEEK token
   429 = 00E8			TK_DEEK		= TK_PEEK+1		; DEEK token
   430 = 00E9			TK_SADD		= TK_DEEK+1		; SADD token
   431 = 00EA			TK_LEN		= TK_SADD+1		; LEN token
   432 = 00EB			TK_STRS		= TK_LEN+1		; STR$ token
   433 = 00EC			TK_VAL		= TK_STRS+1		; VAL token
   434 = 00ED			TK_ASC		= TK_VAL+1		; ASC token
   435 = 00EE			TK_UCASES	= TK_ASC+1		; UCASE$ token
   436 = 00EF			TK_LCASES	= TK_UCASES+1		; LCASE$ token
   437 = 00F0			TK_CHRS		= TK_LCASES+1		; CHR$ token
   438 = 00F1			TK_HEXS		= TK_CHRS+1		; HEX$ token
   439 = 00F2			TK_BINS		= TK_HEXS+1		; BIN$ token
   440 = 00F3			TK_BITTST	= TK_BINS+1		; BITTST token
   441 = 00F4			TK_MAX		= TK_BITTST+1		; MAX token
   442 = 00F5			TK_MIN		= TK_MAX+1		; MIN token
   443 = 00F6			TK_PI		= TK_MIN+1		; PI token
   444 = 00F7			TK_TWOPI	= TK_PI+1		; TWOPI token
   445 = 00F8			TK_VPTR		= TK_TWOPI+1		; VARPTR token
   446 = 00F9			TK_LEFTS	= TK_VPTR+1		; LEFT$ token
   447 = 00FA			TK_RIGHTS	= TK_LEFTS+1		; RIGHT$ token
   448 = 00FB			TK_MIDS		= TK_RIGHTS+1		; MID$ token
   449 = 00FC			TK_PORTIN	= TK_MIDS+1		; PORTIN token
   450 = 00FD			TK_I2CIN	= TK_PORTIN+1		; I2CIN token
   451 = 00FE			TK_RES5		= TK_I2CIN+1		; RESERVED ###
   452 = 00FF			TK_RES6		= TK_RES5+1		; RESERVED ###
   453
   454 				; offsets from a base of X or Y
   455 = 0000			PLUS_0		= $00			; X or Y plus 0
   456 = 0001			PLUS_1		= $01			; X or Y plus 1
   457 = 0002			PLUS_2		= $02			; X or Y plus 2
   458 = 0003			PLUS_3		= $03			; X or Y plus 3
   459
   460 = 0100			LAB_STAK	= $0100			; stack bottom, no offset
   461 = 01FE			LAB_SKFE	= LAB_STAK+$FE		; flushed stack address
   462 = 01FF			LAB_SKFF	= LAB_STAK+$FF		; flushed stack address
   463
   464 = 2001			Ram_base	= $2001			; start of user RAM (set as needed, should be page aligned)
   465 = 0010			Stack_floor	= 16			; bytes left free on stack for background interrupts
   466
   467 				; INPBUF moved to jc2_defines.inc 
   468
   469 				; Constants defined for I2Cin() and I2Cout functions
   470 = 0001			I2C_STA		= 1			; I2Cout Start command
   471 = 0000			I2C_STAT	= 0			; I2Cin return I2Cstat value
   472 = 0001			I2C_RD_ACK	= 1			; I2Cin Read + ACK
   473 = 0002			I2C_RD_NAK	= 2			; I2Cin Read + NACK + Stop
   474 = 0003			I2C_STO		= 3			; I2Cin Stop only
   475
   476 				; BASIC cold start entry point
   477 				; new page 2 initialisation, copy block to ccflag on
   478 B000			LAB_COLD
   479 B000 A0 04			LDY	#PG2_TABE-PG2_TABS-1
   480 										; byte count-1
   481 B002			LAB_2D13
   482 B002 B9 13 D3			LDA	PG2_TABS,Y			; get byte
   483 B005 99 68 18			STA	ccflag,Y			; store in page 2
   484 B008 88				DEY					; decrement count
   485 B009 10 F7			BPL	LAB_2D13			; loop if not done
   486
   487 B00B A2 FF			LDX	#$FF				; set byte
   488 B00D 86 48			STX	Clineh				; set current line high byte (set immediate mode)
   489 B00F 9A				TXS					; reset stack pointer
   490
   491 B010 A9 4C			LDA	#$4C				; code for JMP
   492 B012 85 61			STA	Fnxjmp				; save for jump vector for functions
   493
   494 				; copy block from LAB_2CEE to $00BC - $00D3
   495 B014 A2 1C			LDX	#StrTab-LAB_2CEE		; set byte count
   496 B016			LAB_2D4E
   497 B016 BD 17 D3			LDA	LAB_2CEE-1,X			; get byte from table
   498 B019 95 7B			STA	LAB_IGBY-1,X			; save byte in page zero
   499 B01B CA				DEX					; decrement count
   500 B01C D0 F8			BNE	LAB_2D4E			; loop if not all done
   501
   502 				; copy block from StrTab to $0000 - $0012
   503 B01E			LAB_GMEM
   504 B01E A2 12			LDX	#EndTab-StrTab-1; set byte count-1
   505 B020			TabLoop
   506 B020 BD 34 D3			LDA	StrTab,X			; get byte from table
   507 B023 95 00			STA	PLUS_0,X			; save byte in page zero
   508 B025 CA				DEX					; decrement count
   509 B026 10 F8			BPL	TabLoop				; loop if not all done
   510
   511 				; set-up start values
   512
   513 B028 A9 00			LDA	#$00				; clear A
   514 B02A 85 03			STA	NmiBase				; clear NMI handler enabled flag
   515 B02C 85 06			STA	IrqBase				; clear IRQ handler enabled flag
   516 B02E 85 72			STA	FAC1_o				; clear FAC1 overflow byte
   517 B030 85 27			STA	last_sh				; clear descriptor stack top item pointer high byte
   518
   519 B032 A9 0E			LDA	#$0E				; set default tab size
   520 B034 85 24			STA	TabSiz				; save it
   521 B036 A9 03			LDA	#$03				; set garbage collect step size for descriptor stack
   522 B038 85 60			STA	g_step				; save it
   523 B03A A2 28			LDX	#des_sk				; descriptor stack start
   524 B03C 86 25			STX	next_s				; set descriptor stack pointer
   525 B03E 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   526 				; #########################	
   527 B041 20 C2 D1			JSR	CLEAR_BASE			; clear first two bytes of memory to avoid crash
   528 				; #########################	
   529 B044 A9 47			LDA	#<LAB_MSZM			; point to memory size message (low addr)
   530 B046 A0 D3			LDY	#>LAB_MSZM			; point to memory size message (high addr)
   531 B048 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   532 				;	JSR	LAB_INLN			; print '? ' and get BASIC input
   533 B04B 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   534 B04D 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   535 				;	JSR	LAB_GBYT			; get last byte back
   536
   537 				;	BNE	LAB_2DAA			; branch if not null (user typed something)
   538
   539 				;	LDY	#$00				; else clear Y
   540 										; character was null so get memory size the hard way
   541 										; we get here with Y=0 and Itempl/h = Ram_base
   542 B04F			LAB_2D93	; Disable destructive RAM-test, which did set all available memory to $AA
   543 B04F A9 00			LDA	#<RAM_TOP			; A = LSB of RAM_TOP
   544 B051 A0 B0			LDY	#>RAM_TOP			; Y = MSB of RAM_TOP
   545 				;	INC	Itempl				; increment temporary integer low byte
   546 				;	BNE	LAB_2D99			; branch if no overflow
   547 				;
   548 				;	INC	Itemph				; increment temporary integer high byte
   549 				;	LDA	Itemph				; get high byte
   550 				;	CMP	#>RAM_TOP			; compare with top of RAM+1
   551 				;	BEQ	LAB_2DB6			; branch if match (end of user RAM)
   552 				;
   553 				;LAB_2D99
   554 				;	LDA	#$55				; set test byte
   555 				;	STA	(Itempl),Y			; save via temporary integer
   556 				;	CMP	(Itempl),Y			; compare via temporary integer
   557 				;	BNE	LAB_2DB6			; branch if fail
   558 				;
   559 				;	ASL					; shift test byte left (now $AA)
   560 				;	STA	(Itempl),Y			; save via temporary integer
   561 				;	CMP	(Itempl),Y			; compare via temporary integer
   562 				;	BEQ	LAB_2D93			; if ok go do next byte
   563 				;
   564 				;	BNE	LAB_2DB6			; branch if fail
   565 				;
   566 				;LAB_2DAA
   567 				;	JSR	LAB_2887			; get FAC1 from string
   568 				;	LDA	FAC1_e				; get FAC1 exponent
   569 				;	CMP	#$98				; compare with exponent = 2^24
   570 				;	BCS	LAB_GMEM			; if too large go try again
   571 				;
   572 				;	JSR	LAB_F2FU			; save integer part of FAC1 in temporary integer
   573 				;						; (no range check)
   574 				;
   575 				;LAB_2DB6
   576 				;	LDA	Itempl				; get temporary integer low byte
   577 				;	LDY	Itemph				; get temporary integer high byte
   578 				;	CPY	#<Ram_base+1			; compare with start of RAM+$100 high byte
   579 				;	BCC	LAB_GMEM			; if too small go try again
   580 				;
   581 				;
   582 				; uncomment these lines if you want to check on the high limit of memory. Note if
   583 				; RAM_TOP is set too low then this will fail. default is ignore it and assume the
   584 				; users know what they're doing!
   585
   586 				;	CPY	#>RAM_TOP			; compare with top of RAM high byte
   587 				;	BCC	MEM_OK				; branch if < RAM top
   588
   589 				;	BNE	LAB_GMEM			; if too large go try again
   590 										; else was = so compare low bytes
   591 				;	CMP	#<RAM_TOP			; compare with top of RAM low byte
   592 				;	BEQ	MEM_OK				; branch if = RAM top
   593
   594 				;	BCS	LAB_GMEM			; if too large go try again
   595 				;MEM_OK
   596 B053 85 45			STA	Ememl				; set end of mem low byte
   597 B055 84 46			STY	Ememh				; set end of mem high byte
   598 B057 85 41			STA	Sstorl				; set bottom of string space low byte
   599 B059 84 42			STY	Sstorh				; set bottom of string space high byte
   600
   601 B05B A0 01			LDY	#<Ram_base			; set start addr low byte
   602 B05D A2 20			LDX	#>Ram_base			; set start addr high byte
   603 B05F 84 39			STY	Smeml				; save start of mem low byte
   604 B061 86 3A			STX	Smemh				; save start of mem high byte
   605
   606 				; this line is only needed if Ram_base is not $xx00
   607
   608 				;	LDY	#$00				; clear Y
   609 B063 98				TYA					; clear A
   610 B064 91 39			STA	(Smeml),Y			; clear first byte
   611 B066 E6 39			INC	Smeml				; increment start of mem low byte
   612
   613 				; these two lines are only needed if Ram_base is $xxFF
   614
   615 				;	BNE	LAB_2E05			; branch if no rollover
   616
   617 				;	INC	Smemh				; increment start of mem high byte
   618 B068			LAB_2E05
   619 B068 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   620 B06B 20 33 B3			JSR	LAB_1463			; do 'NEW' and 'CLEAR'
   621 B06E A5 45			LDA	Ememl				; get end of mem low byte
   622 B070 38				SEC					; set carry for subtract
   623 B071 E5 39			SBC	Smeml				; subtract start of mem low byte
   624 B073 AA				TAX					; copy to X
   625 B074 A5 46			LDA	Ememh				; get end of mem high byte
   626 B076 E5 3A			SBC	Smemh				; subtract start of mem high byte
   627 B078 20 6F CA			JSR	LAB_295E			; print XA as unsigned integer (bytes free)
   628 B07B A9 5C			LDA	#<LAB_SMSG			; point to sign-on message (low addr)
   629 B07D A0 D3			LDY	#>LAB_SMSG			; point to sign-on message (high addr)
   630 B07F 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   631 B082 A9 2C			LDA	#<LAB_1274			; warm start vector low byte
   632 B084 A0 B1			LDY	#>LAB_1274			; warm start vector high byte
   633 B086 85 01			STA	Wrmjpl				; save warm start vector low byte
   634 B088 84 02			STY	Wrmjph				; save warm start vector high byte
   635 B08A 6C 01 00			JMP	(Wrmjpl)			; go do warm start
   636
   637 				; open up space in memory
   638 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   639
   640 				; Nbendl,Nbendh - new block end address (A/Y)
   641 				; Obendl,Obendh - old block end address
   642 				; Ostrtl,Ostrth - old block start address
   643
   644 				; returns with ..
   645
   646 				; Nbendl,Nbendh - new block start address (high byte - $100)
   647 				; Obendl,Obendh - old block start address (high byte - $100)
   648 				; Ostrtl,Ostrth - old block start address (unchanged)
   649 B08D			LAB_11CF
   650 B08D 20 DA B0			JSR	LAB_121F			; check available memory, 'Out of memory' error if no room
   651 										; addr to check is in AY (low/high)
   652 B090 85 3F			STA	Earryl				; save new array mem end low byte
   653 B092 84 40			STY	Earryh				; save new array mem end high byte
   654
   655 				; open up space in memory
   656 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   657 				; don't set array end
   658 B094			LAB_11D6
   659 B094 38				SEC					; set carry for subtract
   660 B095 A5 66			LDA	Obendl				; get block end low byte
   661 B097 E5 6A			SBC	Ostrtl				; subtract block start low byte
   662 B099 A8				TAY					; copy MOD(block length/$100) byte to Y
   663 B09A A5 67			LDA	Obendh				; get block end high byte
   664 B09C E5 6B			SBC	Ostrth				; subtract block start high byte
   665 B09E AA				TAX					; copy block length high byte to X
   666 B09F E8				INX					; +1 to allow for count=0 exit
   667 B0A0 98				TYA					; copy block length low byte to A
   668 B0A1 F0 24			BEQ	LAB_120A			; branch if length low byte=0
   669
   670 										; block is (X-1)*256+Y bytes, do the Y bytes first
   671
   672 B0A3 38				SEC					; set carry for add + 1, two's complement
   673 B0A4 49 FF			EOR	#$FF				; invert low byte for subtract
   674 B0A6 65 66			ADC	Obendl				; add block end low byte
   675
   676 B0A8 85 66			STA	Obendl				; save corrected old block end low byte
   677 B0AA B0 03			BCS	LAB_11F3			; branch if no underflow
   678
   679 B0AC C6 67			DEC	Obendh				; else decrement block end high byte
   680 B0AE 38				SEC					; set carry for add + 1, two's complement
   681 B0AF			LAB_11F3
   682 B0AF 98				TYA					; get MOD(block length/$100) byte
   683 B0B0 49 FF			EOR	#$FF				; invert low byte for subtract
   684 B0B2 65 64			ADC	Nbendl				; add destination end low byte
   685 B0B4 85 64			STA	Nbendl				; save modified new block end low byte
   686 B0B6 B0 08			BCS	LAB_1203			; branch if no underflow
   687
   688 B0B8 C6 65			DEC	Nbendh				; else decrement block end high byte
   689 B0BA 90 04			BCC	LAB_1203			; branch always
   690
   691 B0BC			LAB_11FF
   692 B0BC B1 66			LDA	(Obendl),Y			; get byte from source
   693 B0BE 91 64			STA	(Nbendl),Y			; copy byte to destination
   694 B0C0			LAB_1203
   695 B0C0 88				DEY					; decrement index
   696 B0C1 D0 F9			BNE	LAB_11FF			; loop until Y=0
   697
   698 										; now do Y=0 indexed byte
   699 B0C3 B1 66			LDA	(Obendl),Y			; get byte from source
   700 B0C5 91 64			STA	(Nbendl),Y			; save byte to destination
   701 B0C7			LAB_120A
   702 B0C7 C6 67			DEC	Obendh				; decrement source pointer high byte
   703 B0C9 C6 65			DEC	Nbendh				; decrement destination pointer high byte
   704 B0CB CA				DEX					; decrement block count
   705 B0CC D0 F2			BNE	LAB_1203			; loop until count = $0
   706
   707 B0CE 60				RTS
   708
   709 				; check room on stack for A bytes
   710 				; stack too deep? do OM error
   711 B0CF			LAB_1212
   712 					.if	Stack_floor			; Stack floor protection patch
   713 B0CF 18				CLC					; prep ADC
   714 B0D0 69 10			ADC	#Stack_floor			; stack pointer lower limit before interrupts
   715 					.endif
   716 B0D2 85 38			STA	TempB				; save result in temp byte
   717 B0D4 BA				TSX					; copy stack
   718 B0D5 E4 38			CPX	TempB				; compare new 'limit' with stack
   719 B0D7 90 30			BCC	LAB_OMER			; if stack < limit do 'Out of memory' error then warm start
   720
   721 B0D9 60				RTS
   722
   723 				; check available memory, 'Out of memory' error if no room
   724 				; addr to check is in AY (low/high)
   725 B0DA			LAB_121F
   726 B0DA C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   727 B0DC 90 2A			BCC	LAB_124B			; if less then exit (is ok)
   728
   729 B0DE D0 04			BNE	LAB_1229			; skip next test if greater (tested <)
   730
   731 										; high byte was =, now do low byte
   732 B0E0 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   733 B0E2 90 24			BCC	LAB_124B			; if less then exit (is ok)
   734
   735 										; addr is > string storage ptr (oops!)
   736 B0E4			LAB_1229
   737 B0E4 48				PHA					; push addr low byte
   738 B0E5 A2 08			LDX	#$08				; set index to save Adatal to expneg inclusive
   739 B0E7 98				TYA					; copy addr high byte (to push on stack)
   740
   741 										; save misc numeric work area
   742 B0E8			LAB_122D
   743 B0E8 48				PHA					; push byte
   744 B0E9 B5 63			LDA	Adatal-1,X			; get byte from Adatal to expneg ( ,$00 not pushed)
   745 B0EB CA				DEX					; decrement index
   746 B0EC 10 FA			BPL	LAB_122D			; loop until all done
   747
   748 B0EE 20 CC C1			JSR	LAB_GARB			; garbage collection routine
   749
   750 										; restore misc numeric work area
   751 B0F1 A2 00			LDX	#$00				; clear the index to restore bytes
   752 B0F3			LAB_1238
   753 B0F3 68				PLA					; pop byte
   754 B0F4 95 64			STA	Adatal,X			; save byte to Adatal to expneg
   755 B0F6 E8				INX					; increment index
   756 B0F7 E0 08			CPX	#$08				; compare with end + 1
   757 B0F9 30 F8			BMI	LAB_1238			; loop if more to do
   758
   759 B0FB 68				PLA					; pop addr high byte
   760 B0FC A8				TAY					; copy back to Y
   761 B0FD 68				PLA					; pop addr low byte
   762 B0FE C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   763 B100 90 06			BCC	LAB_124B			; if less then exit (is ok)
   764
   765 B102 D0 05			BNE	LAB_OMER			; if greater do 'Out of memory' error then warm start
   766
   767 										; high byte was =, now do low byte
   768 B104 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   769 B106 B0 01			BCS	LAB_OMER			; if >= do 'Out of memory' error then warm start
   770
   771 										; ok exit, carry clear
   772 B108			LAB_124B
   773 B108 60				RTS
   774
   775 				; do 'Out of memory' error then warm start
   776 B109			LAB_OMER
   777 B109 A2 0C			LDX	#$0C				; error code $0C ('Out of memory' error)
   778
   779 				; do error #X, then warm start
   780 B10B			LAB_XERR
   781 B10B 20 D1 D1			JSR	LAB_SYSBEEP
   782 B10E 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   783
   784 B111 BD DF D9			LDA	LAB_BAER,X			; get error message pointer low byte
   785 B114 BC E0 D9			LDY	LAB_BAER+1,X			; get error message pointer high byte
   786 B117 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   787
   788 B11A 20 6C B3			JSR	LAB_1491			; flush stack and clear continue flag
   789 B11D A9 1C			LDA	#<LAB_EMSG			; point to ' Error' low addr
   790 B11F A0 DB			LDY	#>LAB_EMSG			; point to ' Error' high addr
   791 B121			LAB_1269
   792 B121 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   793 B124 A4 48			LDY	Clineh				; get current line high byte
   794 B126 C8				INY					; increment it
   795 B127 F0 03			BEQ	LAB_1274			; go do warm start (was immediate mode)
   796
   797 										; else print line number
   798 B129 20 64 CA			JSR	LAB_2953			; print ' in line [LINE #]'
   799
   800 				; BASIC warm start entry point
   801 				; wait for Basic command
   802 B12C			LAB_1274
   803 										; clear ON IRQ/NMI bytes
   804 B12C A9 00			LDA	#$00				; clear A
   805 B12E 85 06			STA	IrqBase				; clear enabled byte
   806 B130 85 03			STA	NmiBase				; clear enabled byte
   807 B132 A9 2D			LDA	#<LAB_RMSG			; point to 'Ready' message low byte
   808 B134 A0 DB			LDY	#>LAB_RMSG			; point to 'Ready' message high byte
   809
   810 B136 20 B1 B8			JSR	LAB_18C3			; go do print string
   811
   812 				; wait for Basic command (no 'Ready')
   813 B139			LAB_127D
   814 B139 20 1F B2			JSR	LAB_1357			; call for BASIC input
   815 B13C			LAB_1280
   816 B13C 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   817 B13E 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   818 B140 20 82 00			JSR	LAB_GBYT			; scan memory
   819 B143 F0 F4			BEQ	LAB_127D			; loop while null
   820
   821 				; got to interpret input line now ..
   822 B145 A2 FF			LDX	#$FF				; current line to null value
   823 B147 86 48			STX	Clineh				; set current line high byte
   824 B149 90 06			BCC	LAB_1295			; branch if numeric character (handle new BASIC line)
   825
   826 										; no line number .. immediate mode
   827 B14B 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   828 B14E 4C D2 B4			JMP	LAB_15F6			; go scan and interpret code
   829
   830 				; handle new BASIC line
   831 B151			LAB_1295
   832 B151 20 33 B7			JSR	LAB_GFPN			; get fixed-point number into temp integer
   833 B154 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   834 B157 84 1D			STY	Ibptr				; save index pointer to end of crunched line
   835 B159 20 07 B3			JSR	LAB_SSLN			; search BASIC for temp integer line number
   836 B15C 90 44			BCC	LAB_12E6			; branch if not found
   837
   838 										; aroooogah! line # already exists! delete it
   839 B15E A0 01			LDY	#$01				; set index to next line pointer high byte
   840 B160 B1 6A			LDA	(Baslnl),Y			; get next line pointer high byte
   841 B162 85 32			STA	ut1_ph				; save it
   842 B164 A5 3B			LDA	Svarl				; get start of vars low byte
   843 B166 85 31			STA	ut1_pl				; save it
   844 B168 A5 6B			LDA	Baslnh				; get found line pointer high byte
   845 B16A 85 34			STA	ut2_ph				; save it
   846 B16C A5 6A			LDA	Baslnl				; get found line pointer low byte
   847 B16E 88				DEY					; decrement index
   848 B16F F1 6A			SBC	(Baslnl),Y			; subtract next line pointer low byte
   849 B171 18				CLC					; clear carry for add
   850 B172 65 3B			ADC	Svarl				; add start of vars low byte
   851 B174 85 3B			STA	Svarl				; save new start of vars low byte
   852 B176 85 33			STA	ut2_pl				; save destination pointer low byte
   853 B178 A5 3C			LDA	Svarh				; get start of vars high byte
   854 B17A 69 FF			ADC	#$FF				; -1 + carry
   855 B17C 85 3C			STA	Svarh				; save start of vars high byte
   856 B17E E5 6B			SBC	Baslnh				; subtract found line pointer high byte
   857 B180 AA				TAX					; copy to block count
   858 B181 38				SEC					; set carry for subtract
   859 B182 A5 6A			LDA	Baslnl				; get found line pointer low byte
   860 B184 E5 3B			SBC	Svarl				; subtract start of vars low byte
   861 B186 A8				TAY					; copy to bytes in first block count
   862 B187 B0 03			BCS	LAB_12D0			; branch if overflow
   863
   864 B189 E8				INX					; increment block count (correct for =0 loop exit)
   865 B18A C6 34			DEC	ut2_ph				; decrement destination high byte
   866 B18C			LAB_12D0
   867 B18C 18				CLC					; clear carry for add
   868 B18D 65 31			ADC	ut1_pl				; add source pointer low byte
   869 B18F 90 03			BCC	LAB_12D8			; branch if no overflow
   870
   871 B191 C6 32			DEC	ut1_ph				; else decrement source pointer high byte
   872 B193 18				CLC					; clear carry
   873
   874 										; close up memory to delete old line
   875 B194			LAB_12D8
   876 B194 B1 31			LDA	(ut1_pl),Y			; get byte from source
   877 B196 91 33			STA	(ut2_pl),Y			; copy to destination
   878 B198 C8				INY					; increment index
   879 B199 D0 F9			BNE	LAB_12D8			; while <> 0 do this block
   880
   881 B19B E6 32			INC	ut1_ph				; increment source pointer high byte
   882 B19D E6 34			INC	ut2_ph				; increment destination pointer high byte
   883 B19F CA				DEX					; decrement block count
   884 B1A0 D0 F2			BNE	LAB_12D8			; loop until all done
   885
   886 										; got new line in buffer and no existing same #
   887 B1A2			LAB_12E6
   888 B1A2 AD 7F 18			LDA	Ibuffs				; get byte from start of input buffer
   889 B1A5 F0 3F			BEQ	LAB_1319			; if null line just go flush stack/vars and exit
   890
   891 										; got new line and it isn't empty line
   892 B1A7 A5 45			LDA	Ememl				; get end of mem low byte
   893 B1A9 A4 46			LDY	Ememh				; get end of mem high byte
   894 B1AB 85 41			STA	Sstorl				; set bottom of string space low byte
   895 B1AD 84 42			STY	Sstorh				; set bottom of string space high byte
   896 B1AF A5 3B			LDA	Svarl				; get start of vars low byte	(end of BASIC)
   897 B1B1 85 66			STA	Obendl				; save old block end low byte
   898 B1B3 A4 3C			LDY	Svarh				; get start of vars high byte	(end of BASIC)
   899 B1B5 84 67			STY	Obendh				; save old block end high byte
   900 B1B7 65 1D			ADC	Ibptr				; add input buffer pointer	(also buffer length)
   901 B1B9 90 01			BCC	LAB_1301			; branch if no overflow from add
   902
   903 B1BB C8				INY					; else increment high byte
   904 B1BC			LAB_1301
   905 B1BC 85 64			STA	Nbendl				; save new block end low byte	(move to, low byte)
   906 B1BE 84 65			STY	Nbendh				; save new block end high byte
   907 B1C0 20 8D B0			JSR	LAB_11CF			; open up space in memory
   908 										; old start pointer Ostrtl,Ostrth set by the find line call
   909 B1C3 A5 3F			LDA	Earryl				; get array mem end low byte
   910 B1C5 A4 40			LDY	Earryh				; get array mem end high byte
   911 B1C7 85 3B			STA	Svarl				; save start of vars low byte
   912 B1C9 84 3C			STY	Svarh				; save start of vars high byte
   913 B1CB A4 1D			LDY	Ibptr				; get input buffer pointer	(also buffer length)
   914 B1CD 88				DEY					; adjust for loop type
   915 B1CE			LAB_1311
   916 B1CE B9 7B 18			LDA	Ibuffs-4,Y			; get byte from crunched line
   917 B1D1 91 6A			STA	(Baslnl),Y			; save it to program memory
   918 B1D3 88				DEY					; decrement count
   919 B1D4 C0 03			CPY	#$03				; compare with first byte-1
   920 B1D6 D0 F6			BNE	LAB_1311			; continue while count <> 3
   921
   922 B1D8 A5 12			LDA	Itemph				; get line # high byte
   923 B1DA 91 6A			STA	(Baslnl),Y			; save it to program memory
   924 B1DC 88				DEY					; decrement count
   925 B1DD A5 11			LDA	Itempl				; get line # low byte
   926 B1DF 91 6A			STA	(Baslnl),Y			; save it to program memory
   927 B1E1 88				DEY					; decrement count
   928 B1E2 A9 FF			LDA	#$FF				; set byte to allow chain rebuild. if you didn't set this
   929 										; byte then a zero already here would stop the chain rebuild
   930 										; as it would think it was the [EOT] marker.
   931 B1E4 91 6A			STA	(Baslnl),Y			; save it to program memory
   932
   933 B1E6			LAB_1319
   934 B1E6 20 48 B3			JSR	LAB_1477			; reset execution to start, clear vars and flush stack
   935 B1E9 A6 39			LDX	Smeml				; get start of mem low byte
   936 B1EB A5 3A			LDA	Smemh				; get start of mem high byte
   937 B1ED A0 01			LDY	#$01				; index to high byte of next line pointer
   938 B1EF			LAB_1325
   939 B1EF 86 31			STX	ut1_pl				; set line start pointer low byte
   940 B1F1 85 32			STA	ut1_ph				; set line start pointer high byte
   941 B1F3 B1 31			LDA	(ut1_pl),Y			; get it
   942 B1F5 F0 18			BEQ	LAB_133E			; exit if end of program
   943
   944 				; rebuild chaining of Basic lines
   945 B1F7 A0 04			LDY	#$04				; point to first code byte of line
   946 										; there is always 1 byte + [EOL] as null entries are deleted
   947 B1F9			LAB_1330
   948 B1F9 C8				INY					; next code byte
   949 B1FA B1 31			LDA	(ut1_pl),Y			; get byte
   950 B1FC D0 FB			BNE	LAB_1330			; loop if not [EOL]
   951
   952 B1FE 38				SEC					; set carry for add + 1
   953 B1FF 98				TYA					; copy end index
   954 B200 65 31			ADC	ut1_pl				; add to line start pointer low byte
   955 B202 AA				TAX					; copy to X
   956 B203 A0 00			LDY	#$00				; clear index, point to this line's next line pointer
   957 B205 91 31			STA	(ut1_pl),Y			; set next line pointer low byte
   958 B207 98				TYA					; clear A
   959 B208 65 32			ADC	ut1_ph				; add line start pointer high byte + carry
   960 B20A C8				INY					; increment index to high byte
   961 B20B 91 31			STA	(ut1_pl),Y			; save next line pointer low byte
   962 B20D 90 E0			BCC	LAB_1325			; go do next line, branch always, carry clear
   963
   964
   965 B20F			LAB_133E
   966 B20F 4C 39 B1			JMP	LAB_127D			; else we just wait for Basic command, no 'Ready'
   967
   968 				; print '? ' and get BASIC input
   969 B212			LAB_INLN
   970 B212 20 C9 B8			JSR	LAB_18E3			; print '?' character
   971 B215 20 C6 B8			JSR	LAB_18E0			; print ' '
   972 B218 D0 05			BNE	LAB_1357			; call for BASIC input and return
   973
   974 				; receive line from keyboard
   975 										; $08 as delete key (BACKSPACE on standard keyboard)
   976 B21A			LAB_134B
   977 B21A 20 CB B8			JSR	LAB_PRNA			; go print the character
   978 B21D CA				DEX					; decrement the buffer counter (delete)
   979 B21E 2C				.byte	$2C				; make LDX into BIT abs
   980
   981 				; call for BASIC input (main entry point)
   982 B21F			LAB_1357
   983 B21F A2 00			LDX	#$00			; clear BASIC line buffer pointer
   984 B221			LAB_1359
   985 B221 20 0D D3			JSR	V_INPT			; call scan input device
   986 B224 90 FB			BCC	LAB_1359		; loop if no byte
   987
   988 B226 F0 F9			BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   989
   990 B228 C9 07			CMP	#$07			; compare with [BELL]
   991 B22A F0 10			BEQ	LAB_1378		; branch if [BELL]
   992
   993 B22C C9 0D			CMP	#$0D			; compare with [CR]
   994 B22E F0 19			BEQ	LAB_1384		; do CR/LF exit if [CR]
   995
   996 B230 E0 00			CPX	#$00			; compare pointer with $00
   997 B232 D0 04			BNE	LAB_1374		; branch if not empty
   998
   999 				; next two lines ignore any non print character and [SPACE] if input buffer empty
  1000 B234 C9 21			CMP	#$21			; compare with [SP]+1
  1001 B236 90 E9			BCC	LAB_1359		; if < ignore character
  1002
  1003 B238			LAB_1374
  1004 B238 C9 08			CMP	#$08			; compare with [BACKSPACE] (delete last character)
  1005 B23A F0 DE			BEQ	LAB_134B		; go delete last character
  1006
  1007 B23C			LAB_1378
  1008 B23C E0 7F			CPX	#Ibuffe-Ibuffs		; compare character count with max
  1009 B23E B0 0C			BCS	LAB_138E		; skip store and do [BELL] if buffer full
  1010
  1011 B240 9D 7F 18			STA	Ibuffs,X		; else store in buffer
  1012 B243 E8				INX				; increment pointer
  1013 B244			LAB_137F
  1014 B244 20 CB B8			JSR	LAB_PRNA		; go print the character
  1015 B247 D0 D8			BNE	LAB_1359		; always loop for next character
  1016
  1017 B249			LAB_1384
  1018 B249 4C 67 B8			JMP	LAB_1866		; do CR/LF exit to BASIC
  1019
  1020 				; announce buffer full
  1021 B24C			LAB_138E
  1022 B24C A9 07			LDA	#$07			; [BELL] character into A
  1023 B24E D0 F4			BNE	LAB_137F		; go print the [BELL] but ignore input character
  1024 									; branch always
  1025
  1026 				; crunch keywords into Basic tokens
  1027 				; position independent buffer version ..
  1028 				; faster, dictionary search version ....
  1029 B250			LAB_13A6
  1030 B250 A0 FF			LDY	#$FF			; set save index (makes for easy math later)
  1031
  1032 B252 38				SEC				; set carry for subtract
  1033 B253 A5 83			LDA	Bpntrl			; get basic execute pointer low byte
  1034 B255 E9 7F			SBC	#<Ibuffs		; subtract input buffer start pointer
  1035 B257 AA				TAX				; copy result to X (index past line # if any)
  1036
  1037 B258 86 20			STX	Oquote			; clear open quote/DATA flag
  1038 B25A			LAB_13AC
  1039 B25A BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1040 B25D F0 62			BEQ	LAB_13EC		; if null save byte then exit
  1041
  1042 B25F C9 7B			CMP   	#'{'           		; convert lower to upper case
  1043 B261 B0 5E			BCS   	LAB_13EC       	 	; is above lower case
  1044 B263 C9 61			CMP   	#'a'
  1045 B265 90 02			BCC   	PATCH_LC       		; is below lower case
  1046 B267 29 DF			AND   	#$DF           		; mask lower case bit
  1047 				      
  1048 B269			PATCH_LC
  1049 B269 C9 5F			CMP	#'_'			; compare with '_'
  1050 B26B B0 54			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1051
  1052 B26D C9 3C			CMP	#'<'			; compare with '<'
  1053 B26F B0 0E			BCS	LAB_13CC		; if >= go crunch now
  1054
  1055 B271 C9 30			CMP	#'0'			; compare with '0'
  1056 B273 B0 4C			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1057
  1058 B275 85 1C			STA	Scnquo			; save buffer byte as search character
  1059 B277 C9 22			CMP	#$22			; is it quote character?
  1060 B279 F0 68			BEQ	LAB_1410		; branch if so (copy quoted string)
  1061
  1062 B27B C9 2A			CMP	#'*'			; compare with '*'
  1063 B27D 90 42			BCC	LAB_13EC		; if < go save byte then continue crunching
  1064 									; else crunch now
  1065 B27F			LAB_13CC
  1066 B27F 24 20			BIT	Oquote			; get open quote/DATA token flag
  1067 B281 70 3E			BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
  1068 									; go save byte then continue crunching
  1069
  1070 B283 86 38			STX	TempB			; save buffer read index
  1071 B285 84 7A			STY	csidx			; copy buffer save index
  1072 B287 A0 62			LDY	#<TAB_1STC		; get keyword first character table low address
  1073 B289 84 33			STY	ut2_pl			; save pointer low byte
  1074 B28B A0 D5			LDY	#>TAB_1STC		; get keyword first character table high address
  1075 B28D 84 34			STY	ut2_ph			; save pointer high byte
  1076 B28F A0 00			LDY	#$00			; clear table pointer
  1077
  1078 B291			LAB_13D0
  1079 B291 D1 33			CMP	(ut2_pl),Y		; compare with keyword first character table byte
  1080 B293 F0 05			BEQ	LAB_13D1		; go do word_table_chr if match
  1081
  1082 B295 90 60			BCC   	PATCH_LC2		; if < keyword first character table byte go restore
  1083 									; Y and save to crunched
  1084
  1085 B297 C8				INY				; else increment pointer
  1086 B298 D0 F7			BNE	LAB_13D0		; and loop (branch always)
  1087
  1088 				; have matched first character of some keyword
  1089 B29A			LAB_13D1
  1090 B29A 98				TYA				; copy matching index
  1091 B29B 0A				ASL				; *2 (bytes per pointer)
  1092 B29C AA				TAX				; copy to new index
  1093 B29D BD 80 D5			LDA	TAB_CHRT,X		; get keyword table pointer low byte
  1094 B2A0 85 33			STA	ut2_pl			; save pointer low byte
  1095 B2A2 BD 81 D5			LDA	TAB_CHRT+1,X		; get keyword table pointer high byte
  1096 B2A5 85 34			STA	ut2_ph			; save pointer high byte
  1097
  1098 B2A7 A0 FF			LDY	#$FF			; clear table pointer (make -1 for start)
  1099
  1100 B2A9 A6 38			LDX	TempB			; restore buffer read index
  1101 B2AB			LAB_13D6
  1102 B2AB C8				INY				; next table byte
  1103 B2AC B1 33			LDA	(ut2_pl),Y		; get byte from table
  1104 B2AE			LAB_13D8
  1105 B2AE 30 0F			BMI	LAB_13EA		; all bytes matched so go save token
  1106
  1107 B2B0 E8				INX				; next buffer byte
  1108 B2B1 DD 7F 18			CMP	Ibuffs,X		; compare with byte from input buffer
  1109 B2B4 F0 F5			BEQ	LAB_13D6		; go compare next if match
  1110 				    
  1111 B2B6 09 20			ORA 	#$20                	; repeat with lower case
  1112 B2B8 DD 7F 18			CMP 	Ibuffs,X            	; compare with byte from input buffer
  1113 B2BB F0 EE			BEQ 	LAB_13D6            	; go compare next if match
  1114 					
  1115 B2BD D0 2B			BNE	LAB_1417		; branch if >< (not found keyword)
  1116
  1117 B2BF			LAB_13EA
  1118 B2BF A4 7A			LDY	csidx			; restore save index
  1119 									; save crunched to output
  1120 B2C1			LAB_13EC
  1121 B2C1 E8				INX				; increment buffer index (to next input byte)
  1122 B2C2 C8				INY				; increment save index (to next output byte)
  1123 B2C3 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1124 B2C6 C9 00			CMP	#$00			; set the flags, set carry
  1125 B2C8 F0 32			BEQ	LAB_142A		; do exit if was null [EOL]
  1126
  1127 									; A holds token or byte here
  1128 B2CA E9 3A			SBC	#':'			; subtract ':' (carry set by CMP #00)
  1129 B2CC F0 04			BEQ	LAB_13FF		; branch if it was ':' (is now $00)
  1130
  1131 									; A now holds token-$3A
  1132 B2CE C9 49			CMP	#TK_DATA-$3A		; compare with DATA token - $3A
  1133 B2D0 D0 02			BNE	LAB_1401		; branch if not DATA
  1134 									; token was : or DATA
  1135 B2D2			LAB_13FF
  1136 B2D2 85 20			STA	Oquote			; save token-$3A (clear for ':', TK_DATA-$3A for DATA)
  1137 B2D4			LAB_1401
  1138 B2D4 49 57			EOR	#TK_REM-$3A		; effectively subtract REM token offset
  1139 B2D6 D0 82			BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
  1140
  1141 B2D8 85 1C			STA	Asrch			; else was REM so set search for [EOL]
  1142 									; loop for REM, '...' etc.
  1143 B2DA			LAB_1408
  1144 B2DA BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1145 B2DD F0 E2			BEQ	LAB_13EC		; branch if null [EOL]
  1146
  1147 B2DF C5 1C			CMP	Asrch			; compare with stored character
  1148 B2E1 F0 DE			BEQ	LAB_13EC		; branch if match (end quote)
  1149
  1150 									; entry for copy string in quotes, don't crunch
  1151 B2E3			LAB_1410
  1152 B2E3 C8				INY				; increment buffer save index
  1153 B2E4 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1154 B2E7 E8				INX				; increment buffer read index
  1155 B2E8 D0 F0			BNE	LAB_1408		; loop while <> 0 (should never be 0!)
  1156
  1157 									; not found keyword this go
  1158 B2EA			LAB_1417
  1159 B2EA A6 38			LDX	TempB			; compare has failed, restore buffer index (start byte!)
  1160
  1161 									; now find the end of this word in the table
  1162 B2EC			LAB_141B
  1163 B2EC B1 33			LDA	(ut2_pl),Y		; get table byte
  1164 B2EE 08				PHP				; save status
  1165 B2EF C8				INY				; increment table index
  1166 B2F0 28				PLP				; restore byte status
  1167 B2F1 10 F9			BPL	LAB_141B		; if not end of keyword go do next
  1168
  1169 B2F3 B1 33			LDA	(ut2_pl),Y		; get byte from keyword table
  1170 B2F5 D0 B7			BNE	LAB_13D8		; go test next word if not zero byte (end of table)
  1171
  1172 B2F7			PATCH_LC2
  1173 									; reached end of table with no match
  1174 B2F7 BD 7F 18			LDA	Ibuffs,X		; restore byte from input buffer
  1175 B2FA 10 C3			BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
  1176 									; go save byte in output and continue crunching
  1177
  1178 									; reached [EOL]
  1179 B2FC			LAB_142A
  1180 B2FC C8				INY				; increment pointer
  1181 B2FD C8				INY				; increment pointer (makes it next line pointer high byte)
  1182 B2FE 99 7F 18			STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
  1183 B301 C8				INY				; adjust for line copy
  1184 B302 C8				INY				; adjust for line copy
  1185 B303 C8				INY				; adjust for line copy
  1186 B304 C6 83			DEC	Bpntrl			; allow for increment (change if buffer starts at $xxFF)
  1187 B306 60				RTS
  1188
  1189 				; search Basic for temp integer line number from start of mem
  1190 B307			LAB_SSLN
  1191 B307 A5 39			LDA	Smeml			; get start of mem low byte
  1192 B309 A6 3A			LDX	Smemh			; get start of mem high byte
  1193
  1194 				; search Basic for temp integer line number from AX
  1195 				; returns carry set if found
  1196 				; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1197
  1198 				; old 541 new 507
  1199 B30B			LAB_SHLN
  1200 B30B A0 01			LDY	#$01			; set index
  1201 B30D 85 6A			STA	Baslnl			; save low byte as current
  1202 B30F 86 6B			STX	Baslnh			; save high byte as current
  1203 B311 B1 6A			LDA	(Baslnl),Y		; get pointer high byte from addr
  1204 B313 F0 1A			BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
  1205
  1206 B315 A0 03			LDY	#$03			; set index to line # high byte
  1207 B317 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1208 B319 88				DEY				; decrement index (point to low byte)
  1209 B31A C5 12			CMP	Itemph			; compare with temporary integer high byte
  1210 B31C D0 04			BNE	LAB_1455		; if <> skip low byte check
  1211
  1212 B31E B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1213 B320 C5 11			CMP	Itempl			; compare with temporary integer low byte
  1214 B322			LAB_1455
  1215 B322 B0 09			BCS	LAB_145E		; else if temp < this line, exit (passed line#)
  1216
  1217 B324			LAB_1456
  1218 B324 88				DEY				; decrement index to next line ptr high byte
  1219 B325 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1220 B327 AA				TAX				; copy to X
  1221 B328 88				DEY				; decrement index to next line ptr low byte
  1222 B329 B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1223 B32B 90 DE			BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
  1224 									; (carry always clear)
  1225
  1226 B32D			LAB_145E
  1227 B32D F0 01			BEQ	LAB_1460		; exit if temp = found line #, carry is set
  1228
  1229 B32F			LAB_145F
  1230 B32F 18				CLC				; clear found flag
  1231 B330			LAB_1460
  1232 B330 60				RTS
  1233
  1234 				; perform NEW
  1235 B331			LAB_NEW
  1236 B331 D0 FD			BNE	LAB_1460		; exit if not end of statement (to do syntax error)
  1237
  1238 B333			LAB_1463
  1239 B333 A9 00			LDA	#$00			; clear A
  1240 B335 A8				TAY				; clear Y
  1241 B336 91 39			STA	(Smeml),Y		; clear first line, next line pointer, low byte
  1242 B338 C8				INY				; increment index
  1243 B339 91 39			STA	(Smeml),Y		; clear first line, next line pointer, high byte
  1244 B33B 18				CLC				; clear carry
  1245 B33C A5 39			LDA	Smeml			; get start of mem low byte
  1246 B33E 69 02			ADC	#$02			; calculate end of BASIC low byte
  1247 B340 85 3B			STA	Svarl			; save start of vars low byte
  1248 B342 A5 3A			LDA	Smemh			; get start of mem high byte
  1249 B344 69 00			ADC	#$00			; add any carry
  1250 B346 85 3C			STA	Svarh			; save start of vars high byte
  1251
  1252 				; reset execution to start, clear vars and flush stack
  1253 B348			LAB_1477
  1254 B348 18				CLC				; clear carry
  1255 B349 A5 39			LDA	Smeml			; get start of mem low byte
  1256 B34B 69 FF			ADC	#$FF			; -1
  1257 B34D 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1258 B34F A5 3A			LDA	Smemh			; get start of mem high byte
  1259 B351 69 FF			ADC	#$FF			; -1+carry
  1260 B353 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1261
  1262 				; 'CLEAR' command gets here
  1263 B355			LAB_147A
  1264 B355 A5 45			LDA	Ememl			; get end of mem low byte
  1265 B357 A4 46			LDY	Ememh			; get end of mem high byte
  1266 B359 85 41			STA	Sstorl			; set bottom of string space low byte
  1267 B35B 84 42			STY	Sstorh			; set bottom of string space high byte
  1268 B35D A5 3B			LDA	Svarl			; get start of vars low byte
  1269 B35F A4 3C			LDY	Svarh			; get start of vars high byte
  1270 B361 85 3D			STA	Sarryl			; save var mem end low byte
  1271 B363 84 3E			STY	Sarryh			; save var mem end high byte
  1272 B365 85 3F			STA	Earryl			; save array mem end low byte
  1273 B367 84 40			STY	Earryh			; save array mem end high byte
  1274 B369 20 1D B5			JSR	LAB_161A		; perform RESTORE command
  1275
  1276 				; flush stack and clear continue flag
  1277 B36C			LAB_1491
  1278 B36C A2 28			LDX	#des_sk			; set descriptor stack pointer
  1279 B36E 86 25			STX	next_s			; save descriptor stack pointer
  1280 B370 68				PLA				; pull return address low byte
  1281 B371 AA				TAX				; copy return address low byte
  1282 B372 68				PLA				; pull return address high byte
  1283 B373 8E FE 01			STX	LAB_SKFE		; save to cleared stack
  1284 B376 8D FF 01			STA	LAB_SKFF		; save to cleared stack
  1285 B379 A2 FD			LDX	#$FD			; new stack pointer
  1286 B37B 9A				TXS				; reset stack
  1287 B37C A9 00			LDA	#$00			; clear byte
  1288 					;STA	Cpntrh			; clear continue pointer high byte (patched)
  1289 B37E 85 21			STA	Sufnxf			; clear subscript/FNX flag
  1290 B380			LAB_14A6
  1291 B380 60				RTS
  1292
  1293 				; perform CLEAR
  1294 B381			LAB_CLEAR
  1295 B381 F0 D2			BEQ	LAB_147A		; if no following token go do 'CLEAR'
  1296 									; else there was a following token (go do syntax error)
  1297 B383 60				RTS
  1298
  1299 				; perform LIST [n][-m]
  1300 				; bigger, faster version (a _lot_ faster)
  1301 B384			LAB_LIST
  1302 B384 90 06			BCC	LAB_14BD		; branch if next character numeric (LIST n..)
  1303
  1304 B386 F0 04			BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
  1305
  1306 B388 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1307 B38A D0 F4			BNE	LAB_14A6		; exit if not - (LIST -m)
  1308
  1309 									; LIST [[n][-m]]
  1310 									; this bit sets the n , if present, as the start and end
  1311 B38C			LAB_14BD
  1312 B38C 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1313 B38F 20 07 B3			JSR	LAB_SSLN		; search BASIC for temp integer line number
  1314 									; (pointer in Baslnl/Baslnh)
  1315 B392 20 82 00			JSR	LAB_GBYT		; scan memory
  1316 B395 F0 0C			BEQ	LAB_14D4		; branch if no more characters
  1317
  1318 									; this bit checks the - is present
  1319 B397 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1320 B399 D0 95			BNE	LAB_1460		; return if not '-' (will be Syntax error)
  1321
  1322 									; LIST [n]-m
  1323 									; the - was there so set m as the end value
  1324 B39B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1325 B39E 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1326 B3A1 D0 8D			BNE	LAB_1460		; exit if not ok
  1327
  1328 B3A3			LAB_14D4
  1329 B3A3 A5 11			LDA	Itempl			; get temporary integer low byte
  1330 B3A5 05 12			ORA	Itemph			; OR temporary integer high byte
  1331 B3A7 D0 06			BNE	LAB_14E2		; branch if start set
  1332
  1333 B3A9 A9 FF			LDA	#$FF			; set for -1
  1334 B3AB 85 11			STA	Itempl			; set temporary integer low byte
  1335 B3AD 85 12			STA	Itemph			; set temporary integer high byte
  1336 B3AF			LAB_14E2
  1337 B3AF A0 01			LDY	#$01			; set index for line
  1338 B3B1 84 20			STY	Oquote			; clear open quote flag
  1339 B3B3 20 70 B8			JSR	LAB_CRLF		; print CR/LF
  1340 B3B6 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1341 									; pointer initially set by search at LAB_14BD
  1342 B3B8 F0 3E			BEQ	LAB_152B		; if null all done so exit
  1343 B3BA 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1344
  1345 B3BD C8				INY				; increment index for line
  1346 B3BE B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1347 B3C0 AA				TAX				; copy to X
  1348 B3C1 C8				INY				; increment index
  1349 B3C2 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1350 B3C4 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1351 B3C6 D0 04			BNE	LAB_14FF		; branch if no high byte match
  1352
  1353 B3C8 E4 11			CPX	Itempl			; compare with temporary integer low byte
  1354 B3CA F0 02			BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
  1355
  1356 B3CC			LAB_14FF				; else ..
  1357 B3CC B0 2A			BCS	LAB_152B		; if greater all done so exit
  1358
  1359 B3CE			LAB_1501
  1360 B3CE 84 57			STY	Tidx1			; save index for line
  1361 B3D0 20 6F CA			JSR	LAB_295E		; print XA as unsigned integer
  1362 B3D3 A9 20			LDA	#$20			; space is the next character
  1363 B3D5			LAB_1508
  1364 B3D5 A4 57			LDY	Tidx1			; get index for line
  1365 B3D7 29 7F			AND	#$7F			; mask top out bit of character
  1366 B3D9			LAB_150C
  1367 B3D9 20 CB B8			JSR	LAB_PRNA		; go print the character
  1368 B3DC C9 22			CMP	#$22			; was it ' character
  1369 B3DE D0 06			BNE	LAB_1519		; branch if not
  1370
  1371 									; we are either entering or leaving a pair of quotes
  1372 B3E0 A5 20			LDA	Oquote			; get open quote flag
  1373 B3E2 49 FF			EOR	#$FF			; toggle it
  1374 B3E4 85 20			STA	Oquote			; save it back
  1375 B3E6			LAB_1519
  1376 B3E6 C8				INY				; increment index
  1377 B3E7 B1 6A			LDA	(Baslnl),Y		; get next byte
  1378 B3E9 D0 0E			BNE	LAB_152E		; branch if not [EOL] (go print character)
  1379 B3EB A8				TAY				; else clear index
  1380 B3EC B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1381 B3EE AA				TAX				; copy to X
  1382 B3EF C8				INY				; increment index
  1383 B3F0 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1384 B3F2 86 6A			STX	Baslnl			; set pointer to line low byte
  1385 B3F4 85 6B			STA	Baslnh			; set pointer to line high byte
  1386 B3F6 D0 B7			BNE	LAB_14E2		; go do next line if not [EOT]
  1387 									; else ..
  1388 B3F8			LAB_152B
  1389 B3F8 60				RTS
  1390
  1391 B3F9			LAB_152E
  1392 B3F9 10 DE			BPL	LAB_150C		; just go print it if not token byte
  1393
  1394 									; else was token byte so uncrunch it (maybe)
  1395 B3FB 24 20			BIT	Oquote			; test the open quote flag
  1396 B3FD 30 DA			BMI	LAB_150C		; just go print character if open quote set
  1397
  1398 B3FF A2 D7			LDX	#>LAB_KEYT		; get table address high byte
  1399 B401 0A				ASL				; *2
  1400 B402 0A				ASL				; *4
  1401 B403 90 02			BCC	LAB_152F		; branch if no carry
  1402
  1403 B405 E8				INX				; else increment high byte
  1404 B406 18				CLC				; clear carry for add
  1405 B407			LAB_152F
  1406 B407 69 DF			ADC	#<LAB_KEYT		; add low byte
  1407 B409 90 01			BCC	LAB_1530		; branch if no carry
  1408
  1409 B40B E8				INX				; else increment high byte
  1410 B40C			LAB_1530
  1411 B40C 85 33			STA	ut2_pl			; save table pointer low byte
  1412 B40E 86 34			STX	ut2_ph			; save table pointer high byte
  1413 B410 84 57			STY	Tidx1			; save index for line
  1414 B412 A0 00			LDY	#$00			; clear index
  1415 B414 B1 33			LDA	(ut2_pl),Y		; get length
  1416 B416 AA				TAX				; copy length
  1417 B417 C8				INY				; increment index
  1418 B418 B1 33			LDA	(ut2_pl),Y		; get 1st character
  1419 B41A CA				DEX				; decrement length
  1420 B41B F0 B8			BEQ	LAB_1508		; if no more characters exit and print
  1421
  1422 B41D 20 CB B8			JSR	LAB_PRNA		; go print the character
  1423 B420 C8				INY				; increment index
  1424 B421 B1 33			LDA	(ut2_pl),Y		; get keyword address low byte
  1425 B423 48				PHA				; save it for now
  1426 B424 C8				INY				; increment index
  1427 B425 B1 33			LDA	(ut2_pl),Y		; get keyword address high byte
  1428 B427 A0 00			LDY	#$00
  1429 B429 85 34			STA	ut2_ph			; save keyword pointer high byte
  1430 B42B 68				PLA				; pull low byte
  1431 B42C 85 33			STA	ut2_pl			; save keyword pointer low byte
  1432 B42E			LAB_1540
  1433 B42E B1 33			LDA	(ut2_pl),Y		; get character
  1434 B430 CA				DEX				; decrement character count
  1435 B431 F0 A2			BEQ	LAB_1508		; if last character exit and print
  1436
  1437 B433 20 CB B8			JSR	LAB_PRNA		; go print the character
  1438 B436 C8				INY				; increment index
  1439 B437 D0 F5			BNE	LAB_1540		; loop for next character
  1440
  1441 				; perform FOR
  1442 B439			LAB_FOR
  1443 B439 A9 80			LDA	#$80			; set FNX
  1444 B43B 85 21			STA	Sufnxf			; set subscript/FNX flag
  1445 B43D 20 92 B7			JSR	LAB_LET			; go do LET
  1446 B440 68				PLA				; pull return address
  1447 B441 68				PLA				; pull return address
  1448 B442 A9 10			LDA	#$10			; we need 16d bytes !
  1449 B444 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1450 B447 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1451 B44A 18				CLC				; clear carry for add
  1452 B44B 98				TYA				; copy index to A
  1453 B44C 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1454 B44E 48				PHA				; push onto stack
  1455 B44F A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1456 B451 69 00			ADC	#$00			; add carry
  1457 B453 48				PHA				; push onto stack
  1458 B454 A5 48			LDA	Clineh			; get current line high byte
  1459 B456 48				PHA				; push onto stack
  1460 B457 A5 47			LDA	Clinel			; get current line low byte
  1461 B459 48				PHA				; push onto stack
  1462 B45A A9 C2			LDA	#TK_TO			; get 'TO' token
  1463 B45C 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1464 B45F 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1465 B462 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1466 									; else do type mismatch
  1467 B465 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  1468 B467 09 7F			ORA	#$7F			; set all non sign bits
  1469 B469 25 6D			AND	FAC1_1			; and FAC1 mantissa1
  1470 B46B 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  1471 B46D A9 78			LDA	#<LAB_159F		; set return address low byte
  1472 B46F A0 B4			LDY	#>LAB_159F		; set return address high byte
  1473 B471 85 31			STA	ut1_pl			; save return address low byte
  1474 B473 84 32			STY	ut1_ph			; save return address high byte
  1475 B475 4C 61 BB			JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1476
  1477 B478			LAB_159F
  1478 B478 A9 F5			LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1479 B47A A0 D3			LDY	#>LAB_259C		; set 1 pointer high addr
  1480 B47C 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1481 B47F 20 82 00			JSR	LAB_GBYT		; scan memory
  1482 B482 C9 C7			CMP	#TK_STEP		; compare with STEP token
  1483 B484 D0 06			BNE	LAB_15B3		; jump if not 'STEP'
  1484
  1485 									;.was step so ..
  1486 B486 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1487 B489 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1488 									; else do type mismatch
  1489 B48C			LAB_15B3
  1490 B48C 20 D6 C8			JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1491 B48F 85 70			STA	FAC1_s			; set FAC1 sign (b7)
  1492 									; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1493 									; compare the FOR value and the TO value and return +1 if
  1494 									; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1495 									; here (+/-1) is then compared to that result and if they
  1496 									; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1497 									; the loop is done
  1498 B491 20 56 BB			JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1499 B494 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  1500 B496 48				PHA				; push on stack
  1501 B497 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  1502 B499 48				PHA				; push on stack
  1503 B49A A9 81			LDA	#TK_FOR			; get FOR token
  1504 B49C 48				PHA				; push on stack
  1505
  1506 				; interpreter inner loop
  1507 B49D			LAB_15C2
  1508 B49D 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1509 B4A0 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1510 B4A2 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  1511
  1512 B4A4 A6 48			LDX	Clineh			; continue line is $FFxx for immediate mode
  1513 									; ($00xx for RUN from immediate mode)
  1514 B4A6 E8				INX				; increment it (now $00 if immediate mode)
  1515 					;BEQ	LAB_15D1		; branch if null (immediate mode) (patched)
  1516
  1517 B4A7 85 4B			STA	Cpntrl			; save continue pointer low byte
  1518 B4A9 84 4C			STY	Cpntrh			; save continue pointer high byte
  1519 B4AB			LAB_15D1
  1520 B4AB A0 00			LDY	#$00			; clear index
  1521 B4AD B1 83			LDA	(Bpntrl),Y		; get next byte
  1522 B4AF F0 07			BEQ	LAB_15DC		; branch if null [EOL]
  1523
  1524 B4B1 C9 3A			CMP	#':'			; compare with ':'
  1525 B4B3 F0 1D			BEQ	LAB_15F6		; branch if = (statement separator)
  1526
  1527 B4B5			LAB_15D9
  1528 B4B5 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  1529
  1530 									; have reached [EOL]
  1531 B4B8			LAB_15DC
  1532 B4B8 A0 02			LDY	#$02			; set index
  1533 B4BA B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  1534 B4BC 18				CLC				; clear carry for no 'BREAK' message
  1535 B4BD F0 50			BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1536 									; marker)
  1537
  1538 B4BF C8				INY				; increment index
  1539 B4C0 B1 83			LDA	(Bpntrl),Y		; get line # low byte
  1540 B4C2 85 47			STA	Clinel			; save current line low byte
  1541 B4C4 C8				INY				; increment index
  1542 B4C5 B1 83			LDA	(Bpntrl),Y		; get line # high byte
  1543 B4C7 85 48			STA	Clineh			; save current line high byte
  1544 B4C9 98				TYA				; A now = 4
  1545 B4CA 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1546 B4CC 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1547 B4CE 90 02			BCC	LAB_15F6		; branch if no overflow
  1548
  1549 B4D0 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1550 B4D2			LAB_15F6
  1551 B4D2 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1552
  1553 B4D5			LAB_15F9
  1554 B4D5 20 DB B4			JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
  1555
  1556 B4D8			LAB_15FC
  1557 B4D8 4C 9D B4			JMP	LAB_15C2		; loop
  1558
  1559 				; interpret BASIC code from (Bpntrl)
  1560 B4DB			LAB_15FF
  1561 B4DB F0 4E			BEQ	LAB_1628		; exit if zero [EOL]
  1562
  1563 B4DD			LAB_1602
  1564 B4DD 0A				ASL				; *2 bytes per vector and normalise token
  1565 B4DE B0 03			BCS	LAB_1609		; branch if was token
  1566
  1567 B4E0 4C 92 B7			JMP	LAB_LET			; else go do implied LET
  1568
  1569 B4E3			LAB_1609
  1570 B4E3 C9 80			CMP	#(TK_TAB-$80)*2		; compare normalised token * 2 with TAB
  1571 B4E5 B0 CE			BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  1572 									; only tokens before TAB can start a line
  1573 B4E7 A8				TAY				; copy to index
  1574 B4E8 B9 1D D4			LDA	LAB_CTBL+1,Y		; get vector high byte
  1575 B4EB 48				PHA				; onto stack
  1576 B4EC B9 1C D4			LDA	LAB_CTBL,Y		; get vector low byte
  1577 B4EF 48				PHA				; onto stack
  1578 B4F0 4C 7C 00			JMP	LAB_IGBY		; jump to increment and scan memory
  1579 									; then 'return' to vector
  1580
  1581 				; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1582 				; key press is detected.
  1583 B4F3			LAB_1629
  1584 B4F3 6C 6B 18			JMP	(VEC_CC)		; ctrl c check vector
  1585
  1586 				; if there was a key press it gets back here ..
  1587 B4F6			LAB_1636
  1588 B4F6 C9 03			CMP	#$03			; compare with CTRL-C
  1589
  1590 				; perform STOP
  1591 B4F8			LAB_STOP
  1592 B4F8 B0 01			BCS	LAB_163B		; branch if token follows STOP
  1593 									; else just END
  1594 				; END
  1595 B4FA			LAB_END
  1596 B4FA 18				CLC				; clear the carry, indicate a normal program end
  1597 B4FB			LAB_163B
  1598 B4FB D0 61			BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1599
  1600 B4FD A5 84			LDA	Bpntrh			; get the BASIC execute pointer high byte
  1601 					;EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1602 					;BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1603 									; (can't continue in immediate mode)
  1604
  1605 									; else ..
  1606 					;EOR	#>Ibuffs		; correct the bits (patched 3 lines)
  1607 B4FF A4 83			LDY	Bpntrl			; get BASIC execute pointer low byte
  1608 B501 84 4B			STY	Cpntrl			; save continue pointer low byte
  1609 B503 85 4C			STA	Cpntrh			; save continue pointer high byte
  1610 B505			LAB_1647
  1611 B505 A5 47			LDA	Clinel			; get current line low byte
  1612 B507 A4 48			LDY	Clineh			; get current line high byte
  1613 B509 85 49			STA	Blinel			; save break line low byte
  1614 B50B 84 4A			STY	Blineh			; save break line high byte
  1615 B50D			LAB_164F
  1616 B50D 68				PLA				; pull return address low
  1617 B50E 68				PLA				; pull return address high
  1618 B50F			LAB_1651
  1619 B50F 90 07			BCC	LAB_165E		; if was program end just do warm start
  1620
  1621 									; else ..
  1622 B511 A9 14			LDA	#<LAB_BMSG		; point to 'Break' low byte
  1623 B513 A0 DB			LDY	#>LAB_BMSG		; point to 'Break' high byte
  1624 B515 4C 21 B1			JMP	LAB_1269		; print 'Break' and do warm start
  1625
  1626 B518			LAB_165E
  1627 B518 4C 2C B1			JMP	LAB_1274		; go do warm start
  1628
  1629 				; perform RESTORE
  1630 B51B			LAB_RESTORE
  1631 B51B D0 0F			BNE	LAB_RESTOREn		; branch if next character not null (RESTORE n)
  1632
  1633 B51D			LAB_161A
  1634 B51D 38				SEC				; set carry for subtract
  1635 B51E A5 39			LDA	Smeml			; get start of mem low byte
  1636 B520 E9 01			SBC	#$01			; -1
  1637 B522 A4 3A			LDY	Smemh			; get start of mem high byte
  1638 B524 B0 01			BCS	LAB_1624		; branch if no underflow
  1639
  1640 B526			LAB_uflow
  1641 B526 88				DEY				; else decrement high byte
  1642 B527			LAB_1624
  1643 B527 85 4F			STA	Dptrl			; save DATA pointer low byte
  1644 B529 84 50			STY	Dptrh			; save DATA pointer high byte
  1645 B52B			LAB_1628
  1646 B52B 60				RTS
  1647
  1648 									; is RESTORE n
  1649 B52C			LAB_RESTOREn
  1650 B52C 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1651 B52F 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  1652 B532 A5 48			LDA	Clineh			; get current line high byte
  1653 B534 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1654 B536 B0 0B			BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1655
  1656 B538 98				TYA				; else copy line index to A
  1657 B539 38				SEC				; set carry (+1)
  1658 B53A 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1659 B53C A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1660 B53E 90 07			BCC	LAB_go_search		; branch if no overflow to high byte
  1661
  1662 B540 E8				INX				; increment high byte
  1663 B541 B0 04			BCS	LAB_go_search		; branch always (can never be carry clear)
  1664
  1665 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1666 B543			LAB_reset_search
  1667 B543 A5 39			LDA	Smeml			; get start of mem low byte
  1668 B545 A6 3A			LDX	Smemh			; get start of mem high byte
  1669
  1670 				; search for line # in temp (Itempl/Itemph) from (AX)
  1671 B547			LAB_go_search
  1672
  1673 B547 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1674 B54A B0 03			BCS	LAB_line_found		; if carry set go set pointer
  1675
  1676 B54C 4C 4D B6			JMP	LAB_16F7		; else go do 'Undefined statement' error
  1677
  1678 B54F			LAB_line_found
  1679 									; carry already set for subtract
  1680 B54F A5 6A			LDA	Baslnl			; get pointer low byte
  1681 B551 E9 01			SBC	#$01			; -1
  1682 B553 A4 6B			LDY	Baslnh			; get pointer high byte
  1683 B555 B0 D0			BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1684
  1685 B557 90 CD			BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1686 									; return (branch always)
  1687
  1688 				; perform NULL
  1689 B559			LAB_NULL
  1690 B559 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  1691 B55C 86 0D			STX	Nullct			; save new NULL count
  1692 B55E			LAB_167A
  1693 B55E 60				RTS
  1694
  1695 				; perform CONT
  1696 B55F			LAB_CONT
  1697 B55F D0 FD			BNE	LAB_167A		; if following byte exit to do syntax error
  1698
  1699 B561 A4 4C			LDY	Cpntrh			; get continue pointer high byte
  1700 B563 C0 18			CPY   	#>Ibuffs          	; *** fix p2: test direct mode 
  1701 B565 D0 05			BNE	LAB_166C		; go do continue if we can
  1702
  1703 B567 A2 1E			LDX	#$1E			; error code $1E ('Can't continue' error)
  1704 B569 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1705 									; we can continue so ..
  1706 B56C			LAB_166C
  1707 B56C A9 93			LDA	#TK_ON			; set token for ON
  1708 B56E 20 03 CF			JSR	LAB_IRQ			; set IRQ flags
  1709 B571 A9 93			LDA	#TK_ON			; set token for ON
  1710 B573 20 06 CF			JSR	LAB_NMI			; set NMI flags
  1711
  1712 B576 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  1713 B578 A5 4B			LDA	Cpntrl			; get continue pointer low byte
  1714 B57A 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1715 B57C A5 49			LDA	Blinel			; get break line low byte
  1716 B57E A4 4A			LDY	Blineh			; get break line high byte
  1717 B580 85 47			STA	Clinel			; set current line low byte
  1718 B582 84 48			STY	Clineh			; set current line high byte
  1719 B584 60				RTS
  1720
  1721 				; perform RUN
  1722 B585			LAB_RUN
  1723 B585 D0 03			BNE	LAB_1696		; branch if RUN n
  1724 B587 4C 48 B3			JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1725 									; return
  1726
  1727 				; does RUN n
  1728 B58A			LAB_1696
  1729 B58A 20 55 B3			JSR	LAB_147A		; go do 'CLEAR'
  1730 B58D F0 2E			BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1731
  1732 				; perform DO
  1733 B58F			LAB_DO
  1734 B58F A9 05			LDA	#$05			; need 5 bytes for DO
  1735 B591 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1736 B594 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1737 B596 48				PHA				; push on stack
  1738 B597 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1739 B599 48				PHA				; push on stack
  1740 B59A A5 48			LDA	Clineh			; get current line high byte
  1741 B59C 48				PHA				; push on stack
  1742 B59D A5 47			LDA	Clinel			; get current line low byte
  1743 B59F 48				PHA				; push on stack
  1744 B5A0 A9 9D			LDA	#TK_DO			; token for DO
  1745 B5A2 48				PHA				; push on stack
  1746 B5A3 20 82 00			JSR	LAB_GBYT		; scan memory
  1747 B5A6 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1748
  1749 				; perform GOSUB
  1750 B5A9			LAB_GOSUB
  1751 B5A9 A9 05			LDA	#$05			; need 5 bytes for GOSUB
  1752 B5AB 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1753 B5AE A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1754 B5B0 48				PHA				; push on stack
  1755 B5B1 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1756 B5B3 48				PHA				; push on stack
  1757 B5B4 A5 48			LDA	Clineh			; get current line high byte
  1758 B5B6 48				PHA				; push on stack
  1759 B5B7 A5 47			LDA	Clinel			; get current line low byte
  1760 B5B9 48				PHA				; push on stack
  1761 B5BA A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  1762 B5BC 48				PHA				; push on stack
  1763 B5BD			LAB_16B0
  1764 B5BD 20 82 00			JSR	LAB_GBYT		; scan memory
  1765 B5C0 20 C6 B5			JSR	LAB_GOTO		; perform GOTO n
  1766 B5C3 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1767 									; (can't RTS, we used the stack!)
  1768
  1769 				; perform GOTO
  1770 B5C6			LAB_GOTO
  1771 B5C6 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1772 B5C9 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  1773 B5CC A5 48			LDA	Clineh			; get current line high byte
  1774 B5CE C5 12			CMP	Itemph			; compare with temporary integer high byte
  1775 B5D0 B0 0B			BCS	LAB_16D0		; branch if >= (start search from beginning)
  1776
  1777 B5D2 98				TYA				; else copy line index to A
  1778 B5D3 38				SEC				; set carry (+1)
  1779 B5D4 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1780 B5D6 A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1781 B5D8 90 07			BCC	LAB_16D4		; branch if no overflow to high byte
  1782
  1783 B5DA E8				INX				; increment high byte
  1784 B5DB B0 04			BCS	LAB_16D4		; branch always (can never be carry)
  1785
  1786 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1787 B5DD			LAB_16D0
  1788 B5DD A5 39			LDA	Smeml			; get start of mem low byte
  1789 B5DF A6 3A			LDX	Smemh			; get start of mem high byte
  1790
  1791 				; search for line # in temp (Itempl/Itemph) from (AX)
  1792 B5E1			LAB_16D4
  1793 B5E1 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1794 B5E4 90 67			BCC	LAB_16F7		; if carry clear go do 'Undefined statement' error
  1795 									; (unspecified statement)
  1796
  1797 									; carry already set for subtract
  1798 B5E6 A5 6A			LDA	Baslnl			; get pointer low byte
  1799 B5E8 E9 01			SBC	#$01			; -1
  1800 B5EA 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1801 B5EC A5 6B			LDA	Baslnh			; get pointer high byte
  1802 B5EE E9 00			SBC	#$00			; subtract carry
  1803 B5F0 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1804 B5F2			LAB_16E5
  1805 B5F2 60				RTS
  1806
  1807 B5F3			LAB_DONOK
  1808 B5F3 A2 22			LDX	#$22			; error code $22 ('LOOP without DO' error)
  1809 B5F5 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1810
  1811 				; perform LOOP
  1812 B5F8			LAB_LOOP
  1813 B5F8 A8				TAY				; save following token
  1814 B5F9 BA				TSX				; copy stack pointer
  1815 B5FA BD 03 01			LDA	LAB_STAK+3,X		; get token byte from stack
  1816 B5FD C9 9D			CMP	#TK_DO			; compare with DO token
  1817 B5FF D0 F2			BNE	LAB_DONOK		; branch if no matching DO
  1818
  1819 B601 E8				INX				; dump calling routine return address
  1820 B602 E8				INX				; dump calling routine return address
  1821 B603 9A				TXS				; correct stack
  1822 B604 98				TYA				; get saved following token back
  1823 B605 F0 20			BEQ	LoopAlways		; if no following token loop forever
  1824 									; (stack pointer in X)
  1825
  1826 B607 C9 3A			CMP	#':'			; could be ':'
  1827 B609 F0 1C			BEQ	LoopAlways		; if :... loop forever
  1828
  1829 B60B E9 C8			SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1830 B60D AA				TAX				; copy to X (if it was UNTIL then Y will be correct)
  1831 B60E F0 04			BEQ	DoRest			; branch if was UNTIL
  1832
  1833 B610 CA				DEX				; decrement result
  1834 B611 D0 62			BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1835 									; only if the token was WHILE will this fail
  1836
  1837 B613 CA				DEX				; set invert result byte
  1838 B614			DoRest
  1839 B614 86 58			STX	Frnxth			; save invert result byte
  1840 B616 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1841 B619 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  1842 B61C A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1843 B61E F0 02			BEQ	DoCmp			; if =0 go do straight compare
  1844
  1845 B620 A9 FF			LDA	#$FF			; else set all bits
  1846 B622			DoCmp
  1847 B622 BA				TSX				; copy stack pointer
  1848 B623 45 58			EOR	Frnxth			; EOR with invert byte
  1849 B625 D0 1A			BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1850
  1851 									; loop condition wasn't met so do it again
  1852 B627			LoopAlways
  1853 B627 BD 02 01			LDA	LAB_STAK+2,X		; get current line low byte
  1854 B62A 85 47			STA	Clinel			; save current line low byte
  1855 B62C BD 03 01			LDA	LAB_STAK+3,X		; get current line high byte
  1856 B62F 85 48			STA	Clineh			; save current line high byte
  1857 B631 BD 04 01			LDA	LAB_STAK+4,X		; get BASIC execute pointer low byte
  1858 B634 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1859 B636 BD 05 01			LDA	LAB_STAK+5,X		; get BASIC execute pointer high byte
  1860 B639 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1861 B63B 20 82 00			JSR	LAB_GBYT		; scan memory
  1862 B63E 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1863
  1864 									; clear stack and back to interpreter loop
  1865 B641			LoopDone
  1866 B641 E8				INX				; dump DO token
  1867 B642 E8				INX				; dump current line low byte
  1868 B643 E8				INX				; dump current line high byte
  1869 B644 E8				INX				; dump BASIC execute pointer low byte
  1870 B645 E8				INX				; dump BASIC execute pointer high byte
  1871 B646 9A				TXS				; correct stack
  1872 B647 4C 67 B6			JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1873
  1874 				; do the return without gosub error
  1875 B64A			LAB_16F4
  1876 B64A A2 04			LDX	#$04			; error code $04 ('RETURN without GOSUB' error)
  1877 B64C 2C				.byte	$2C			; makes next line BIT LAB_0EA2
  1878
  1879 B64D			LAB_16F7				; do undefined statement error
  1880 B64D A2 0E			LDX	#$0E			; error code $0E ('Undefined statement' error)
  1881 B64F 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1882
  1883 				; perform RETURN
  1884 B652			LAB_RETURN
  1885 B652 D0 9E			BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1886
  1887 B654			LAB_16E8
  1888 B654 68				PLA				; dump calling routine return address
  1889 B655 68				PLA				; dump calling routine return address
  1890 B656 68				PLA				; pull token
  1891 B657 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  1892 B659 D0 EF			BNE	LAB_16F4		; branch if no matching GOSUB
  1893
  1894 B65B			LAB_16FF
  1895 B65B 68				PLA				; pull current line low byte
  1896 B65C 85 47			STA	Clinel			; save current line low byte
  1897 B65E 68				PLA				; pull current line high byte
  1898 B65F 85 48			STA	Clineh			; save current line high byte
  1899 B661 68				PLA				; pull BASIC execute pointer low byte
  1900 B662 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1901 B664 68				PLA				; pull BASIC execute pointer high byte
  1902 B665 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1903
  1904 									; now do the DATA statement as we could be returning into
  1905 									; the middle of an ON <var> GOSUB n,m,p,q line
  1906 									; (the return address used by the DATA statement is the one
  1907 									; pushed before the GOSUB was executed!)
  1908
  1909 				; perform DATA
  1910 B667			LAB_DATA
  1911 B667 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1912 									; set BASIC execute pointer
  1913 B66A			LAB_170F
  1914 B66A 98				TYA				; copy index to A
  1915 B66B 18				CLC				; clear carry for add
  1916 B66C 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1917 B66E 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1918 B670 90 02			BCC	LAB_1719		; skip next if no carry
  1919
  1920 B672 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1921 B674			LAB_1719
  1922 B674 60				RTS
  1923
  1924 B675			LAB_16FC
  1925 B675 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  1926
  1927 				; scan for next BASIC statement ([:] or [EOL])
  1928 				; returns Y as index to [:] or [EOL]
  1929 B678			LAB_SNBS
  1930 B678 A2 3A			LDX	#':'			; set look for character = ':'
  1931 B67A 2C				.byte	$2C			; makes next line BIT $00A2
  1932
  1933 				; scan for next BASIC line
  1934 				; returns Y as index to [EOL]
  1935 B67B			LAB_SNBL
  1936 B67B A2 00			LDX	#$00			; set alt search character = [EOL]
  1937 B67D A0 00			LDY	#$00			; set search character = [EOL]
  1938 B67F 84 1C			STY	Asrch			; store search character
  1939 B681			LAB_1725
  1940 B681 8A				TXA				; get alt search character
  1941 B682 45 1C			EOR	Asrch			; toggle search character, effectively swap with $00
  1942 B684 85 1C			STA	Asrch			; save swapped search character
  1943 B686			LAB_172D
  1944 B686 B1 83			LDA	(Bpntrl),Y		; get next byte
  1945 B688 F0 EA			BEQ	LAB_1719		; exit if null [EOL]
  1946
  1947 B68A C5 1C			CMP	Asrch			; compare with search character
  1948 B68C F0 E6			BEQ	LAB_1719		; exit if found
  1949
  1950 B68E C8				INY				; increment index
  1951 B68F C9 22			CMP	#$22			; compare current character with open quote
  1952 B691 D0 F3			BNE	LAB_172D		; if not open quote go get next character
  1953
  1954 B693 F0 EC			BEQ	LAB_1725		; if found go swap search character for alt search character
  1955
  1956 				; perform IF
  1957 B695			LAB_IF
  1958 B695 20 BE BA			JSR	LAB_EVEX		; evaluate the expression
  1959 B698 20 82 00			JSR	LAB_GBYT		; scan memory
  1960 B69B C9 C5			CMP	#TK_THEN		; compare with THEN token
  1961 B69D F0 11			BEQ	LAB_174B		; if it was THEN go do IF
  1962
  1963 									; wasn't IF .. THEN so must be IF .. GOTO
  1964 B69F C9 89			CMP	#TK_GOTO		; compare with GOTO token
  1965 B6A1 D0 D2			BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  1966
  1967 B6A3 A6 83			LDX	Bpntrl			; save the basic pointer low byte
  1968 B6A5 A4 84			LDY	Bpntrh			; save the basic pointer high byte
  1969 B6A7 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1970 B6AA B0 C9			BCS	LAB_16FC		; if not numeric go do syntax error
  1971
  1972 B6AC 86 83			STX	Bpntrl			; restore the basic pointer low byte
  1973 B6AE 84 84			STY	Bpntrh			; restore the basic pointer high byte
  1974 B6B0			LAB_174B
  1975 B6B0 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1976 B6B2 F0 1E			BEQ	LAB_174E		; if the result was zero go look for an ELSE
  1977
  1978 B6B4 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  1979 B6B7 B0 03			BCS	LAB_174D		; if not numeric go do var or keyword
  1980
  1981 B6B9			LAB_174C
  1982 B6B9 4C C6 B5			JMP	LAB_GOTO		; else was numeric so do GOTO n
  1983
  1984 									; is var or keyword
  1985 B6BC			LAB_174D	; Patch: allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack
  1986 B6BC 68				PLA                     	; discard interpreter loop return address
  1987 B6BD 68				PLA                     	; so data structures are at the correct stack offset
  1988 B6BE 20 82 00			JSR   	LAB_GBYT          	; restore token or variable
  1989 B6C1 20 DB B4			JSR   	LAB_15FF          	; interpret BASIC code from (Bpntrl)
  1990
  1991 				; the IF was executed and there may be a following ELSE so the code needs to return
  1992 				; here to check and ignore the ELSE if present
  1993
  1994 B6C4 A0 00			LDY   	#$00              	; clear the index
  1995 B6C6 B1 83			LDA   	(Bpntrl),Y        	; get the next BASIC byte
  1996 B6C8 C9 C1			CMP   	#TK_ELSE          	; compare it with the token for ELSE
  1997 B6CA D0 03			BNE   	LAB_no_ELSE       	; no - continue on this line
  1998 B6CC 20 67 B6			JSR   	LAB_DATA          	; yes - skip the rest of the line
  1999
  2000 				; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2001 				; following ELSE will, correctly, cause a syntax error
  2002
  2003 B6CF			LAB_no_ELSE
  2004 B6CF 4C 9D B4			JMP 	LAB_15C2            	; return to the interpreter inner loop 
  2005 				;	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  2006 				;	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  2007 				;					; and return to this code to process any following code
  2008 				;
  2009 				;	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
  2010 				;					; but don't return here
  2011 				;
  2012 				;LAB_174G
  2013 				;	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2014 				;
  2015 				;; the IF was executed and there may be a following ELSE so the code needs to return
  2016 				;; here to check and ignore the ELSE if present
  2017 				;
  2018 				;	LDY	#$00			; clear the index
  2019 				;	LDA	(Bpntrl),Y		; get the next BASIC byte
  2020 				;	CMP	#TK_ELSE		; compare it with the token for ELSE
  2021 				;	BEQ	LAB_DATA		; if ELSE ignore the following statement
  2022 				;
  2023 				;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2024 				;; following ELSE will, correctly, cause a syntax error
  2025 				;
  2026 				;	RTS				; else return to the interpreter inner loop
  2027 				;
  2028 				; perform ELSE after IF
  2029 B6D2			LAB_174E
  2030 B6D2 A0 00			LDY	#$00			; clear the BASIC byte index
  2031 B6D4 A2 01			LDX	#$01			; clear the nesting depth
  2032 B6D6			LAB_1750
  2033 B6D6 C8				INY				; increment the BASIC byte index
  2034 B6D7 B1 83			LDA	(Bpntrl),Y		; get the next BASIC byte
  2035 B6D9 F0 0F			BEQ	LAB_1753		; if EOL go add the pointer and return
  2036
  2037 B6DB C9 8B			CMP	#TK_IF			; compare the byte with the token for IF
  2038 B6DD D0 03			BNE	LAB_1752		; if not IF token skip the depth increment
  2039
  2040 B6DF E8				INX				; else increment the nesting depth ..
  2041 B6E0 D0 F4			BNE	LAB_1750		; .. and continue looking
  2042
  2043 B6E2			LAB_1752
  2044 B6E2 C9 C1			CMP	#TK_ELSE		; compare the byte with the token for ELSE
  2045 B6E4 D0 F0			BNE	LAB_1750		; if not ELSE token continue looking
  2046
  2047 B6E6 CA				DEX				; was ELSE so decrement the nesting depth
  2048 B6E7 D0 ED			BNE	LAB_1750		; loop if still nested
  2049
  2050 B6E9 C8				INY				; increment the BASIC byte index past the ELSE
  2051
  2052 				; found the matching ELSE, now do <{n|statement}>
  2053 B6EA			LAB_1753
  2054 B6EA 98				TYA				; else copy line index to A
  2055 B6EB 18				CLC				; clear carry for add
  2056 B6EC 65 83			ADC	Bpntrl			; add the BASIC execute pointer low byte
  2057 B6EE 85 83			STA	Bpntrl			; save the BASIC execute pointer low byte
  2058 B6F0 90 02			BCC	LAB_1754		; branch if no overflow to high byte
  2059
  2060 B6F2 E6 84			INC	Bpntrh			; else increment the BASIC execute pointer high byte
  2061 B6F4			LAB_1754
  2062 B6F4 20 82 00			JSR	LAB_GBYT		; scan memory
  2063 B6F7 90 C0			BCC	LAB_174C		; if numeric do GOTO n
  2064 									; the code will return to the interpreter loop at the
  2065 									; tail end of the GOTO <n>
  2066
  2067 B6F9 4C DB B4			JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2068 									; the code will return to the interpreter loop at the
  2069 									; tail end of the <statement>
  2070
  2071 				; perform REM, skip (rest of) line
  2072 B6FC			LAB_REM
  2073 B6FC 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  2074 B6FF 4C 6A B6			JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  2075
  2076 B702			LAB_16FD
  2077 B702 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2078
  2079 				; perform ON
  2080 B705			LAB_ON
  2081 B705 C9 A9			CMP	#TK_IRQ			; was it IRQ token ?
  2082 B707 D0 03			BNE	LAB_NOIN		; if not go check NMI
  2083
  2084 B709 4C 27 CF			JMP	LAB_SIRQ		; else go set-up IRQ
  2085
  2086 B70C			LAB_NOIN
  2087 B70C C9 AA			CMP	#TK_NMI			; was it NMI token ?
  2088 B70E D0 03			BNE	LAB_NONM		; if not go do normal ON command
  2089
  2090 B710 4C 2B CF			JMP	LAB_SNMI		; else go set-up NMI
  2091
  2092 B713			LAB_NONM
  2093 B713 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  2094 B716 48				PHA				; push GOTO/GOSUB token
  2095 B717 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  2096 B719 F0 04			BEQ	LAB_176B		; branch if GOSUB
  2097
  2098 B71B C9 89			CMP	#TK_GOTO		; compare with GOTO token
  2099 B71D			LAB_1767
  2100 B71D D0 E3			BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  2101
  2102
  2103 				; next character was GOTO or GOSUB
  2104 B71F			LAB_176B
  2105 B71F C6 6F			DEC	FAC1_3			; decrement index (byte value)
  2106 B721 D0 04			BNE	LAB_1773		; branch if not zero
  2107
  2108 B723 68				PLA				; pull GOTO/GOSUB token
  2109 B724 4C DD B4			JMP	LAB_1602		; go execute it
  2110
  2111 B727			LAB_1773
  2112 B727 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2113 B72A 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  2114 									; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2115 									; just BNE LAB_176B for the loop. should be quicker ..
  2116 									; no we can't, what if we meet a colon or [EOL]?)
  2117 B72D C9 2C			CMP	#$2C			; compare next character with ','
  2118 B72F F0 EE			BEQ	LAB_176B		; loop if ','
  2119
  2120 B731			LAB_177E
  2121 B731 68				PLA				; else pull keyword token (run out of options)
  2122 									; also dump +/-1 pointer low byte and exit
  2123 B732			LAB_177F
  2124 B732 60				RTS
  2125
  2126 				; takes n * 106 + 11 cycles where n is the number of digits
  2127 				; get fixed-point number into temp integer
  2128 B733			LAB_GFPN
  2129 B733 A2 00			LDX	#$00			; clear reg
  2130 B735 86 11			STX	Itempl			; clear temporary integer low byte
  2131 B737			LAB_1785
  2132 B737 86 12			STX	Itemph			; save temporary integer high byte
  2133 B739 B0 F7			BCS	LAB_177F		; return if carry set, end of scan, character was
  2134 									; not 0-9
  2135
  2136 B73B E0 19			CPX	#$19			; compare high byte with $19
  2137 B73D A8				TAY				; ensure Zb = 0 if the branch is taken
  2138 B73E B0 DD			BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  2139 									; bit does *$0A, = 64000, compare at target will fail
  2140 									; and do syntax error
  2141
  2142 B740 E9 2F			SBC	#'0'-1			; subtract '0', $2F + carry, from byte
  2143 B742 A8				TAY				; copy binary digit
  2144 B743 A5 11			LDA	Itempl			; get temporary integer low byte
  2145 B745 0A				ASL				; *2 low byte
  2146 B746 26 12			ROL	Itemph			; *2 high byte
  2147 B748 0A				ASL				; *2 low byte
  2148 B749 26 12			ROL	Itemph			; *2 high byte, *4
  2149 B74B 65 11			ADC	Itempl			; + low byte, *5
  2150 B74D 85 11			STA	Itempl			; save it
  2151 B74F 8A				TXA				; get high byte copy to A
  2152 B750 65 12			ADC	Itemph			; + high byte, *5
  2153 B752 06 11			ASL	Itempl			; *2 low byte, *10d
  2154 B754 2A				ROL				; *2 high byte, *10d
  2155 B755 AA				TAX				; copy high byte back to X
  2156 B756 98				TYA				; get binary digit back
  2157 B757 65 11			ADC	Itempl			; add number low byte
  2158 B759 85 11			STA	Itempl			; save number low byte
  2159 B75B 90 01			BCC	LAB_17B3		; if no overflow to high byte get next character
  2160
  2161 B75D E8				INX				; else increment high byte
  2162 B75E			LAB_17B3
  2163 B75E 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2164 B761 4C 37 B7			JMP	LAB_1785		; loop for next character
  2165
  2166 				; perform DEC
  2167 B764			LAB_DEC
  2168 B764 A9 F9			LDA	#<LAB_2AFD		; set -1 pointer low byte
  2169 B766 2C				.byte	$2C			; BIT abs to skip the LDA below
  2170
  2171 				; perform INC
  2172 B767			LAB_INC
  2173 B767 A9 F5			LDA	#<LAB_259C		; set 1 pointer low byte
  2174 B769			LAB_17B5
  2175 B769 48				PHA				; save +/-1 pointer low byte
  2176 B76A			LAB_17B7
  2177 B76A 20 89 BD			JSR	LAB_GVAR		; get var address
  2178 B76D A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2179 B76F 30 1E			BMI	IncrErr			; exit if string
  2180
  2181 B771 85 57			STA	Lvarpl			; save var address low byte
  2182 B773 84 58			STY	Lvarph			; save var address high byte
  2183 B775 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  2184 B778 68				PLA				; get +/-1 pointer low byte
  2185 B779 48				PHA				; save +/-1 pointer low byte
  2186 B77A A0 D3			LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  2187 B77C 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  2188 B77F 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
  2189
  2190 B782 20 82 00			JSR	LAB_GBYT		; scan memory
  2191 B785 C9 2C			CMP	#','			; compare with ','
  2192 B787 D0 A8			BNE	LAB_177E		; exit if not ',' (either end or error)
  2193
  2194 									; was ',' so another INCR variable to do
  2195 B789 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2196 B78C 4C 6A B7			JMP	LAB_17B7		; go do next var
  2197
  2198 B78F			IncrErr
  2199 B78F 4C B9 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  2200
  2201 				; perform LET
  2202 B792			LAB_LET
  2203 B792 20 89 BD			JSR	LAB_GVAR		; get var address
  2204 B795 85 57			STA	Lvarpl			; save var address low byte
  2205 B797 84 58			STY	Lvarph			; save var address high byte
  2206 B799 A9 D7			LDA	#TK_EQUAL		; get = token
  2207 B79B 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2208 B79E A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  2209 B7A0 48				PHA				; push data type flag
  2210 B7A1 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2211 B7A4 68				PLA				; pop data type flag
  2212 B7A5 2A				ROL				; set carry if type = string
  2213 					; patch result of a string compare stores string pointer to variable
  2214 B7A6 20 B0 BA			JSR	LAB_CKTM		; type match check, keep C (expected type)
  2215 B7A9 B0 03			BCS	LAB_17D5		; branch if string
  2216
  2217 B7AB 4C 90 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2218
  2219 				; string LET
  2220 B7AE			LAB_17D5
  2221 B7AE A0 02			LDY	#$02			; set index to pointer high byte
  2222 B7B0 B1 6E			LDA	(des_pl),Y		; get string pointer high byte
  2223 B7B2 C5 42			CMP	Sstorh			; compare bottom of string space high byte
  2224 B7B4 90 17			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2225
  2226 B7B6 D0 07			BNE	LAB_17E6		; branch if >
  2227 									; else was equal so compare low bytes
  2228 B7B8 88				DEY				; decrement index
  2229 B7B9 B1 6E			LDA	(des_pl),Y		; get pointer low byte
  2230 B7BB C5 41			CMP	Sstorl			; compare bottom of string space low byte
  2231 B7BD 90 0E			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2232 									; pointer was >= to bottom of string space pointer
  2233 B7BF			LAB_17E6
  2234 B7BF A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2235 B7C1 C4 3C			CPY	Svarh			; compare start of vars high byte
  2236 B7C3 90 08			BCC	LAB_17F4		; branch if less (descriptor is on stack)
  2237
  2238 B7C5 D0 0D			BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  2239
  2240 									; else high bytes were equal so ..
  2241 B7C7 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2242 B7C9 C5 3B			CMP	Svarl			; compare start of vars low byte
  2243 B7CB B0 07			BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  2244
  2245 B7CD			LAB_17F4
  2246 B7CD A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2247 B7CF A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2248 B7D1 4C EA B7			JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  2249
  2250 									; make space and copy string
  2251 B7D4			LAB_17FB
  2252 B7D4 A0 00			LDY	#$00			; index to length
  2253 B7D6 B1 6E			LDA	(des_pl),Y		; get string length
  2254 B7D8 20 1D C1			JSR	LAB_209C		; copy string
  2255 B7DB A5 5E			LDA	des_2l			; get descriptor pointer low byte
  2256 B7DD A4 5F			LDY	des_2h			; get descriptor pointer high byte
  2257 B7DF 85 78			STA	ssptr_l			; save descriptor pointer low byte
  2258 B7E1 84 79			STY	ssptr_h			; save descriptor pointer high byte
  2259 B7E3 20 FE C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  2260 B7E6 A9 6C			LDA	#<FAC1_e		; set descriptor pointer low byte
  2261 B7E8 A0 00			LDY	#>FAC1_e		; get descriptor pointer high byte
  2262
  2263 									; clean stack and assign value to string variable
  2264 B7EA			LAB_1811
  2265 B7EA 85 5E			STA	des_2l			; save descriptor_2 pointer low byte
  2266 B7EC 84 5F			STY	des_2h			; save descriptor_2 pointer high byte
  2267 B7EE 20 60 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  2268 B7F1 A0 00			LDY	#$00			; index to length
  2269 B7F3 B1 5E			LDA	(des_2l),Y		; get string length
  2270 B7F5 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2271 B7F7 C8				INY				; index to string pointer low byte
  2272 B7F8 B1 5E			LDA	(des_2l),Y		; get string pointer low byte
  2273 B7FA 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2274 B7FC C8				INY				; index to string pointer high byte
  2275 B7FD B1 5E			LDA	(des_2l),Y		; get string pointer high byte
  2276 B7FF 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2277 B801 60				RTS
  2278
  2279 				; perform GET
  2280 B802			LAB_GET
  2281 B802 20 89 BD			JSR	LAB_GVAR		; get var address
  2282 B805 85 57			STA	Lvarpl			; save var address low byte
  2283 B807 84 58			STY	Lvarph			; save var address high byte
  2284 B809 20 EF CE			JSR	INGET			; get input byte
  2285 B80C A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2286 B80E 30 07			BMI	LAB_GETS		; go get string character
  2287
  2288 									; was numeric get
  2289 B810 A8				TAY				; copy character to Y
  2290 B811 20 51 C0			JSR	LAB_1FD0		; convert Y to byte in FAC1
  2291 B814 4C 90 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2292
  2293 B817			LAB_GETS
  2294 B817 48				PHA				; save character
  2295 B818 A9 01			LDA	#$01			; string is single byte
  2296 B81A B0 01			BCS	LAB_IsByte		; branch if byte received
  2297
  2298 B81C 68				PLA				; string is null
  2299 B81D			LAB_IsByte
  2300 B81D 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  2301 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2302 B820 F0 05			BEQ	LAB_NoSt		; skip store if null string
  2303
  2304 B822 68				PLA				; get character back
  2305 B823 A0 00			LDY	#$00			; clear index
  2306 B825 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  2307 B827			LAB_NoSt
  2308 B827 20 72 C1			JSR	LAB_RTST		; check for space on descriptor stack then put address
  2309 									; and length on descriptor stack and update stack pointers
  2310
  2311 B82A 4C AE B7			JMP	LAB_17D5		; do string LET and return
  2312
  2313 				; perform PRINT
  2314 B82D			LAB_1829
  2315 B82D 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2316 B830			LAB_182C
  2317 B830 20 82 00			JSR	LAB_GBYT		; scan memory
  2318
  2319 				; PRINT
  2320 B833			LAB_PRINT
  2321 B833 F0 3B			BEQ	LAB_CRLF		; if nothing following just print CR/LF
  2322
  2323 B835			LAB_1831
  2324 B835 C9 C0			CMP	#TK_TAB			; compare with TAB( token
  2325 B837 F0 56			BEQ	LAB_18A2		; go do TAB/SPC
  2326
  2327 B839 C9 C4			CMP	#TK_SPC			; compare with SPC( token
  2328 B83B F0 52			BEQ	LAB_18A2		; go do TAB/SPC
  2329
  2330 B83D C9 2C			CMP	#','			; compare with ','
  2331 B83F F0 38			BEQ	LAB_188B		; go do move to next TAB mark
  2332
  2333 B841 C9 3B			CMP	#';'			; compare with ';'
  2334 B843 F0 66			BEQ	LAB_18BD		; if ';' continue with PRINT processing
  2335
  2336 B845 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2337 B848 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2338 B84A 30 E1			BMI	LAB_1829		; branch if string
  2339
  2340 B84C 20 82 CA			JSR	LAB_296E		; convert FAC1 to string
  2341 B84F 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2342 B852 A0 00			LDY	#$00			; clear index
  2343
  2344 				; don't check fit if terminal width byte is zero
  2345
  2346 B854 A5 0F			LDA	TWidth			; get terminal width byte
  2347 B856 F0 0A			BEQ	LAB_185E		; skip check if zero
  2348
  2349 B858 38				SEC				; set carry for subtract
  2350 B859 E5 0E			SBC	TPos			; subtract terminal position
  2351 B85B F1 6E			SBC	(des_pl),Y		; subtract string length
  2352 B85D B0 03			BCS	LAB_185E		; branch if less than terminal width
  2353
  2354 B85F 20 70 B8			JSR	LAB_CRLF		; else print CR/LF
  2355 B862			LAB_185E
  2356 B862 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2357 B865 F0 C9			BEQ	LAB_182C		; always go continue processing line
  2358
  2359 				; CR/LF return to BASIC from BASIC input handler
  2360 B867			LAB_1866
  2361 B867 A9 00			LDA	#$00			; clear byte
  2362 B869 9D 7F 18			STA	Ibuffs,X		; null terminate input
  2363 B86C A2 7F			LDX	#<Ibuffs		; set X to buffer start-1 low byte
  2364 B86E A0 18			LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  2365
  2366 				; print CR/LF
  2367 B870			LAB_CRLF
  2368 B870 A9 0D			LDA	#$0D			; load [CR]
  2369 B872 20 CB B8			JSR	LAB_PRNA		; go print the character
  2370 B875 A9 0A			LDA	#$0A			; load [LF]
  2371 B877 D0 52			BNE	LAB_PRNA		; go print the character and return, branch always
  2372
  2373 B879			LAB_188B
  2374 B879 A5 0E			LDA	TPos			; get terminal position
  2375 B87B C5 10			CMP	Iclim			; compare with input column limit
  2376 B87D 90 05			BCC	LAB_1897		; branch if less
  2377
  2378 B87F 20 70 B8			JSR	LAB_CRLF		; else print CR/LF (next line)
  2379 B882 D0 27			BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2380
  2381 B884			LAB_1897
  2382 B884 38				SEC				; set carry for subtract
  2383 B885			LAB_1898
  2384 B885 E5 24			SBC	TabSiz			; subtract TAB size
  2385 B887 B0 FC			BCS	LAB_1898		; loop if result was +ve
  2386
  2387 B889 49 FF			EOR	#$FF			; complement it
  2388 B88B 69 01			ADC	#$01			; +1 (twos complement)
  2389 B88D D0 12			BNE	LAB_18B6		; always print A spaces (result is never $00)
  2390 									; do TAB/SPC
  2391 B88F			LAB_18A2
  2392 B88F 48				PHA				; save token
  2393 B890 20 76 C4			JSR	LAB_SGBY		; scan and get byte parameter
  2394 B893 C9 29			CMP	#$29			; is next character )
  2395 B895 D0 7B			BNE	LAB_1910		; if not do syntax error then warm start
  2396
  2397 B897 68				PLA				; get token back
  2398 B898 C9 C0			CMP	#TK_TAB			; was it TAB ?
  2399 B89A D0 06			BNE	LAB_18B7		; if not go do SPC
  2400
  2401 									; calculate TAB offset
  2402 B89C 8A				TXA				; copy integer value to A
  2403 B89D E5 0E			SBC	TPos			; subtract terminal position
  2404 B89F 90 0A			BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  2405 									; print A spaces
  2406 B8A1			LAB_18B6
  2407 B8A1 AA				TAX				; copy result to X
  2408 B8A2			LAB_18B7
  2409 B8A2 8A				TXA				; set flags on size for SPC
  2410 B8A3 F0 06			BEQ	LAB_18BD		; branch if result was = $0, already here
  2411
  2412 									; print X spaces
  2413 B8A5			LAB_18BA
  2414 B8A5 20 C6 B8			JSR	LAB_18E0		; print ' '
  2415 B8A8 CA				DEX				; decrement count
  2416 B8A9 D0 FA			BNE	LAB_18BA		; loop if not all done
  2417
  2418 									; continue with PRINT processing
  2419 B8AB			LAB_18BD
  2420 B8AB 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2421 B8AE D0 85			BNE	LAB_1831		; if more to print go do it
  2422
  2423 B8B0 60				RTS
  2424
  2425 				; print null terminated string from memory
  2426 B8B1			LAB_18C3
  2427 B8B1 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2428
  2429 				; print string from Sutill/Sutilh
  2430 B8B4			LAB_18C6
  2431 B8B4 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2432 									; space returns with A = length, X=$71=pointer low byte,
  2433 									; Y=$72=pointer high byte
  2434 B8B7 A0 00			LDY	#$00			; reset index
  2435 B8B9 AA				TAX				; copy length to X
  2436 B8BA F0 49			BEQ	LAB_188C		; exit (RTS) if null string
  2437
  2438 B8BC			LAB_18CD
  2439
  2440 B8BC B1 31			LDA	(ut1_pl),Y		; get next byte
  2441 B8BE 20 CB B8			JSR	LAB_PRNA		; go print the character
  2442 B8C1 C8				INY				; increment index
  2443 B8C2 CA				DEX				; decrement count
  2444 B8C3 D0 F7			BNE	LAB_18CD		; loop if not done yet
  2445
  2446 B8C5 60				RTS
  2447
  2448 									; Print single format character
  2449 				; print ' '
  2450 B8C6			LAB_18E0
  2451 B8C6 A9 20			LDA	#$20			; load ' '
  2452 B8C8 2C				.byte	$2C			; change next line to BIT LAB_3FA9
  2453
  2454 				; print '?' character
  2455 B8C9			LAB_18E3
  2456 B8C9 A9 3F			LDA	#$3F			; load '?' character
  2457
  2458 				; print character in A
  2459 				; now includes the null handler
  2460 				; also includes infinite line length code
  2461 				; note! some routines expect this one to exit with Zb=0
  2462 B8CB			LAB_PRNA
  2463 B8CB C9 20			CMP	#' '			; compare with ' '
  2464 B8CD 90 19			BCC	LAB_18F9		; branch if less (non printing)
  2465
  2466 									; else printable character
  2467 B8CF 48				PHA				; save the character
  2468
  2469 				; don't check fit if terminal width byte is zero
  2470 B8D0 A5 0F			LDA	TWidth			; get terminal width
  2471 B8D2 D0 0A			BNE	LAB_18F0		; branch if not zero (not infinite length)
  2472
  2473 				; is 'infinite line' so check TAB position
  2474 B8D4 A5 0E			LDA	TPos			; get position
  2475 B8D6 E5 24			SBC	TabSiz			; subtract TAB size, carry set by CMP #$20 above
  2476 B8D8 D0 0B			BNE	LAB_18F7		; skip reset if different
  2477
  2478 B8DA 85 0E			STA	TPos			; else reset position
  2479 B8DC F0 07			BEQ	LAB_18F7		; go print character
  2480
  2481 B8DE			LAB_18F0
  2482 B8DE C5 0E			CMP	TPos			; compare with terminal character position
  2483 B8E0 D0 03			BNE	LAB_18F7		; branch if not at end of line
  2484
  2485 B8E2 20 70 B8			JSR	LAB_CRLF		; else print CR/LF
  2486 B8E5			LAB_18F7
  2487 B8E5 E6 0E			INC	TPos			; increment terminal position
  2488 B8E7 68				PLA				; get character back
  2489 B8E8			LAB_18F9
  2490 B8E8 20 10 D3			JSR	V_OUTP			; output byte via output vector
  2491 B8EB C9 0D			CMP	#$0D			; compare with [CR]
  2492 B8ED D0 14			BNE	LAB_188A		; branch if not [CR]
  2493
  2494 									; else print nullct nulls after the [CR]
  2495 B8EF 86 38			STX	TempB			; save buffer index
  2496 B8F1 A6 0D			LDX	Nullct			; get null count
  2497 B8F3 F0 0A			BEQ	LAB_1886		; branch if no nulls
  2498
  2499 B8F5 A9 00			LDA	#$00			; load [NULL]
  2500 B8F7			LAB_1880
  2501 B8F7 20 CB B8			JSR	LAB_PRNA		; go print the character
  2502 B8FA CA				DEX				; decrement count
  2503 B8FB D0 FA			BNE	LAB_1880		; loop if not all done
  2504
  2505 B8FD A9 0D			LDA	#$0D			; restore the character (and set the flags)
  2506 B8FF			LAB_1886
  2507 B8FF 86 0E			STX	TPos			; clear terminal position (X always = zero when we get here)
  2508 B901 A6 38			LDX	TempB			; restore buffer index
  2509 B903			LAB_188A
  2510 B903 29 FF			AND	#$FF			; set the flags
  2511 B905			LAB_188C
  2512 B905 60				RTS
  2513
  2514 				; handle bad input data
  2515 B906			LAB_1904
  2516 B906 A5 22			LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
  2517 B908 10 0B			BPL	LAB_1913		; branch if INPUT (go do redo)
  2518
  2519 B90A A5 4D			LDA	Dlinel			; get current DATA line low byte
  2520 B90C A4 4E			LDY	Dlineh			; get current DATA line high byte
  2521 B90E 85 47			STA	Clinel			; save current line low byte
  2522 B910 84 48			STY	Clineh			; save current line high byte
  2523 B912			LAB_1910
  2524 B912 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2525
  2526 									; mode was INPUT
  2527 B915			LAB_1913
  2528 B915 A9 48			LDA	#<LAB_REDO		; point to redo message (low addr)
  2529 B917 A0 DB			LDY	#>LAB_REDO		; point to redo message (high addr)
  2530 B919 20 B1 B8			JSR	LAB_18C3		; print null terminated string from memory
  2531 B91C A5 4B			LDA	Cpntrl			; get continue pointer low byte
  2532 B91E A4 4C			LDY	Cpntrh			; get continue pointer high byte
  2533 B920 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2534 B922 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  2535 B924 60				RTS
  2536
  2537 				; perform INPUT
  2538 B925			LAB_INPUT
  2539 B925 C9 22			CMP	#$22			; compare next byte with open quote
  2540 B927 D0 0B			BNE	LAB_1934		; branch if no prompt string
  2541
  2542 B929 20 9B BB			JSR	LAB_1BC1		; print '...' string
  2543 B92C A9 3B			LDA	#$3B			; load A with ';'
  2544 B92E 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2545 B931 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2546
  2547 									; done with prompt, now get data
  2548 B934			LAB_1934
  2549 B934 20 55 C0			JSR	LAB_CKRN		; check not Direct, back here if ok
  2550 B937 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2551 B93A A9 00			LDA	#$00			; set mode = INPUT
  2552 B93C CD 7F 18			CMP	Ibuffs			; test first byte in buffer
  2553 B93F D0 09			BNE	LAB_1953		; branch if not null input
  2554
  2555 					; *** change p2: keep carry set to throw break message
  2556 					;CLC				; was null input so clear carry to exit program
  2557 B941 4C 05 B5			JMP	LAB_1647		; go do BREAK exit
  2558
  2559 				; perform READ
  2560 B944			LAB_READ
  2561 B944 A6 4F			LDX	Dptrl			; get DATA pointer low byte
  2562 B946 A4 50			LDY	Dptrh			; get DATA pointer high byte
  2563 B948 A9 80			LDA	#$80			; set mode = READ
  2564
  2565 B94A			LAB_1953
  2566 B94A 85 22			STA	Imode			; set input mode flag, $00=INPUT, $80=READ
  2567 B94C 86 51			STX	Rdptrl			; save READ pointer low byte
  2568 B94E 84 52			STY	Rdptrh			; save READ pointer high byte
  2569 									; READ or INPUT next variable from list
  2570 B950			LAB_195B
  2571 B950 20 89 BD			JSR	LAB_GVAR		; get (var) address
  2572 B953 85 57			STA	Lvarpl			; save address low byte
  2573 B955 84 58			STY	Lvarph			; save address high byte
  2574 B957 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2575 B959 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2576 B95B 85 11			STA	Itempl			; save as temporary integer low byte
  2577 B95D 84 12			STY	Itemph			; save as temporary integer high byte
  2578 B95F A6 51			LDX	Rdptrl			; get READ pointer low byte
  2579 B961 A4 52			LDY	Rdptrh			; get READ pointer high byte
  2580 B963 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2581 B965 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2582 B967 20 82 00			JSR	LAB_GBYT		; scan memory
  2583 B96A D0 11			BNE	LAB_1988		; branch if not null
  2584
  2585 									; pointer was to null entry
  2586 B96C 24 22			BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
  2587 B96E 30 65			BMI	LAB_19DD		; branch if READ
  2588
  2589 									; mode was INPUT
  2590 B970 20 C9 B8			JSR	LAB_18E3		; print '?' character (double ? for extended input)
  2591 B973 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2592 B976 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2593 B978 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2594 B97A			LAB_1985
  2595 B97A 20 82 00			JSR	LAB_GBYT		; scan memory
  2596 B97D			LAB_1988
  2597 B97D 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2598 B97F 10 24			BPL	LAB_19B0		; branch if numeric
  2599
  2600 									; else get string
  2601 B981 85 1B			STA	Srchc			; save search character
  2602 B983 C9 22			CMP	#$22			; was it ' ?
  2603 B985 F0 07			BEQ	LAB_1999		; branch if so
  2604
  2605 B987 A9 3A			LDA	#':'			; else search character is ':'
  2606 B989 85 1B			STA	Srchc			; set new search character
  2607 B98B A9 2C			LDA	#','			; other search character is ','
  2608 B98D 18				CLC				; clear carry for add
  2609 B98E			LAB_1999
  2610 B98E 85 1C			STA	Asrch			; set second search character
  2611 B990 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2612 B992 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2613
  2614 B994 69 00			ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2615 B996 90 01			BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2616
  2617 B998 C8				INY				; else increment high byte
  2618 B999			LAB_19A4
  2619 B999 20 35 C1			JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
  2620 B99C 20 BC C4			JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2621 B99F 20 AE B7			JSR	LAB_17D5		; go do string LET
  2622 B9A2 4C AB B9			JMP	LAB_19B6		; go check string terminator
  2623
  2624 									; get numeric INPUT
  2625 B9A5			LAB_19B0
  2626 B9A5 20 93 C9			JSR	LAB_2887		; get FAC1 from string
  2627 B9A8 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
  2628 B9AB			LAB_19B6
  2629 B9AB 20 82 00			JSR	LAB_GBYT		; scan memory
  2630 B9AE F0 0A			BEQ	LAB_19C5		; branch if null (last entry)
  2631
  2632 B9B0 C9 2C			CMP	#','			; else compare with ','
  2633 B9B2 F0 03			BEQ	LAB_19C2		; branch if ','
  2634
  2635 B9B4 4C 06 B9			JMP	LAB_1904		; else go handle bad input data
  2636
  2637 									; got good input data
  2638 B9B7			LAB_19C2
  2639 B9B7 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2640 B9BA			LAB_19C5
  2641 B9BA A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2642 B9BC A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2643 B9BE 85 51			STA	Rdptrl			; save for now
  2644 B9C0 84 52			STY	Rdptrh			; save for now
  2645 B9C2 A5 11			LDA	Itempl			; get temporary integer low byte (temp BASIC execute ptr)
  2646 B9C4 A4 12			LDY	Itemph			; get temporary integer high byte (temp BASIC execute ptr)
  2647 B9C6 85 83			STA	Bpntrl			; set BASIC execute pointer low byte
  2648 B9C8 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2649 B9CA 20 82 00			JSR	LAB_GBYT		; scan memory
  2650 B9CD F0 2C			BEQ	LAB_1A03		; if null go do extra ignored message
  2651
  2652 B9CF 20 DB BB			JSR	LAB_1C01		; else scan for ',' , else do syntax error then warm start
  2653 B9D2 4C 50 B9			JMP	LAB_195B		; go INPUT next variable from list
  2654
  2655 									; find next DATA statement or do 'Out of DATA' error
  2656 B9D5			LAB_19DD
  2657 B9D5 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2658 B9D8 C8				INY				; increment index
  2659 B9D9 AA				TAX				; copy character ([:] or [EOL])
  2660 B9DA D0 12			BNE	LAB_19F6		; branch if [:]
  2661
  2662 B9DC A2 06			LDX	#$06			; set for 'Out of DATA' error
  2663 B9DE C8				INY				; increment index, now points to next line pointer high byte
  2664 B9DF B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  2665 B9E1 F0 73			BEQ	LAB_1A54		; branch if end (eventually does error X)
  2666
  2667 B9E3 C8				INY				; increment index
  2668 B9E4 B1 83			LDA	(Bpntrl),Y		; get next line # low byte
  2669 B9E6 85 4D			STA	Dlinel			; save current DATA line low byte
  2670 B9E8 C8				INY				; increment index
  2671 B9E9 B1 83			LDA	(Bpntrl),Y		; get next line # high byte
  2672 B9EB C8				INY				; increment index
  2673 B9EC 85 4E			STA	Dlineh			; save current DATA line high byte
  2674 B9EE			LAB_19F6
  2675 B9EE B1 83			LDA	(Bpntrl),Y		; get byte
  2676 B9F0 C8				INY				; increment index
  2677 B9F1 AA				TAX				; copy to X
  2678 B9F2 20 6A B6			JSR	LAB_170F		; set BASIC execute pointer
  2679 B9F5 E0 83			CPX	#TK_DATA		; compare with 'DATA' token
  2680 B9F7 F0 81			BEQ	LAB_1985		; was 'DATA' so go do next READ
  2681
  2682 B9F9 D0 DA			BNE	LAB_19DD		; go find next statement if not 'DATA'
  2683
  2684 				; end of INPUT/READ routine
  2685 B9FB			LAB_1A03
  2686 B9FB A5 51			LDA	Rdptrl			; get temp READ pointer low byte
  2687 B9FD A4 52			LDY	Rdptrh			; get temp READ pointer high byte
  2688 B9FF A6 22			LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
  2689 BA01 10 03			BPL	LAB_1A0E		; branch if INPUT
  2690
  2691 BA03 4C 27 B5			JMP	LAB_1624		; save AY as DATA pointer and return
  2692
  2693 									; we were getting INPUT
  2694 BA06			LAB_1A0E
  2695 BA06 A0 00			LDY	#$00			; clear index
  2696 BA08 B1 51			LDA	(Rdptrl),Y		; get next byte
  2697 BA0A D0 01			BNE	LAB_1A1B		; error if not end of INPUT
  2698
  2699 BA0C 60				RTS
  2700
  2701 									; user typed too much
  2702 BA0D			LAB_1A1B
  2703 BA0D A9 37			LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2704 BA0F A0 DB			LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2705 BA11 4C B1 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  2706
  2707 				; search the stack for FOR activity
  2708 				; exit with z=1 if FOR else exit with z=0
  2709 BA14			LAB_11A1
  2710 BA14 BA				TSX				; copy stack pointer
  2711 BA15 E8				INX				; +1 pass return address
  2712 BA16 E8				INX				; +2 pass return address
  2713 BA17 E8				INX				; +3 pass calling routine return address
  2714 BA18 E8				INX				; +4 pass calling routine return address
  2715 BA19			LAB_11A6
  2716 BA19 BD 01 01			LDA	LAB_STAK+1,X		; get token byte from stack
  2717 BA1C C9 81			CMP	#TK_FOR			; is it FOR token
  2718 BA1E D0 21			BNE	LAB_11CE		; exit if not FOR token
  2719
  2720 									; was FOR token
  2721 BA20 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  2722 BA22 D0 0A			BNE	LAB_11BB		; branch if not null
  2723
  2724 BA24 BD 02 01			LDA	LAB_STAK+2,X		; get FOR variable pointer low byte
  2725 BA27 85 57			STA	Frnxtl			; save var pointer for FOR/NEXT low byte
  2726 BA29 BD 03 01			LDA	LAB_STAK+3,X		; get FOR variable pointer high byte
  2727 BA2C 85 58			STA	Frnxth			; save var pointer for FOR/NEXT high byte
  2728 BA2E			LAB_11BB
  2729 BA2E DD 03 01			CMP	LAB_STAK+3,X		; compare var pointer with stacked var pointer (high byte)
  2730 BA31 D0 07			BNE	LAB_11C7		; branch if no match
  2731
  2732 BA33 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  2733 BA35 DD 02 01			CMP	LAB_STAK+2,X		; compare var pointer with stacked var pointer (low byte)
  2734 BA38 F0 07			BEQ	LAB_11CE		; exit if match found
  2735
  2736 BA3A			LAB_11C7
  2737 BA3A 8A				TXA				; copy index
  2738 BA3B 18				CLC				; clear carry for add
  2739 BA3C 69 10			ADC	#$10			; add FOR stack use size
  2740 BA3E AA				TAX				; copy back to index
  2741 BA3F D0 D8			BNE	LAB_11A6		; loop if not at start of stack
  2742
  2743 BA41			LAB_11CE
  2744 BA41 60				RTS
  2745
  2746 				; perform NEXT
  2747 BA42			LAB_NEXT
  2748 BA42 D0 04			BNE	LAB_1A46		; branch if NEXT var
  2749
  2750 BA44 A0 00			LDY	#$00			; else clear Y
  2751 BA46 F0 03			BEQ	LAB_1A49		; branch always (no variable to search for)
  2752
  2753 				; NEXT var
  2754 BA48			LAB_1A46
  2755 BA48 20 89 BD			JSR	LAB_GVAR		; get variable address
  2756 BA4B			LAB_1A49
  2757 BA4B 85 57			STA	Frnxtl			; store variable pointer low byte
  2758 BA4D 84 58			STY	Frnxth			; store variable pointer high byte
  2759 									; (both cleared if no variable defined)
  2760 BA4F 20 14 BA			JSR	LAB_11A1		; search the stack for FOR activity
  2761 BA52 F0 04			BEQ	LAB_1A56		; branch if found
  2762
  2763 BA54 A2 00			LDX	#$00			; else set error $00 ('NEXT without FOR' error)
  2764 BA56			LAB_1A54
  2765 BA56 F0 63			BEQ	LAB_1ABE		; do error #X, then warm start
  2766
  2767 BA58			LAB_1A56
  2768 BA58 9A				TXS				; set stack pointer, X set by search, dumps return addresses
  2769
  2770 BA59 8A				TXA				; copy stack pointer
  2771 BA5A 38				SEC				; set carry for subtract
  2772 BA5B E9 F7			SBC	#$F7			; point to TO var
  2773 BA5D 85 33			STA	ut2_pl			; save pointer to TO var for compare
  2774 BA5F 69 FB			ADC	#$FB			; point to STEP var
  2775
  2776 BA61 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2777 BA63 20 6A C8			JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
  2778 BA66 BA				TSX				; get stack pointer back
  2779 BA67 BD 08 01			LDA	LAB_STAK+8,X		; get step sign
  2780 BA6A 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  2781 BA6C A5 57			LDA	Frnxtl			; get FOR variable pointer low byte
  2782 BA6E A4 58			LDY	Frnxth			; get FOR variable pointer high byte
  2783 BA70 20 AB C5			JSR	LAB_246C		; add (FOR variable) to FAC1
  2784 BA73 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2785 BA76 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2786 BA78 20 06 C9			JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
  2787 BA7B BA				TSX				; get stack pointer back
  2788 BA7C DD 08 01			CMP	LAB_STAK+8,X		; compare step sign
  2789 BA7F F0 17			BEQ	LAB_1A9B		; branch if = (loop complete)
  2790
  2791 									; loop back and do it all again
  2792 BA81 BD 0D 01			LDA	LAB_STAK+$0D,X		; get FOR line low byte
  2793 BA84 85 47			STA	Clinel			; save current line low byte
  2794 BA86 BD 0E 01			LDA	LAB_STAK+$0E,X		; get FOR line high byte
  2795 BA89 85 48			STA	Clineh			; save current line high byte
  2796 BA8B BD 10 01			LDA	LAB_STAK+$10,X		; get BASIC execute pointer low byte
  2797 BA8E 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2798 BA90 BD 0F 01			LDA	LAB_STAK+$0F,X		; get BASIC execute pointer high byte
  2799 BA93 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  2800 BA95			LAB_1A98
  2801 BA95 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  2802
  2803 									; loop complete so carry on
  2804 BA98			LAB_1A9B
  2805 BA98 8A				TXA				; stack copy to A
  2806 BA99 69 0F			ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
  2807 BA9B AA				TAX				; copy back to index
  2808 BA9C 9A				TXS				; copy to stack pointer
  2809 BA9D 20 82 00			JSR	LAB_GBYT		; scan memory
  2810 BAA0 C9 2C			CMP	#','			; compare with ','
  2811 BAA2 D0 F1			BNE	LAB_1A98		; branch if not ',' (go do interpreter inner loop)
  2812
  2813 									; was ',' so another NEXT variable to do
  2814 BAA4 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  2815 BAA7 20 48 BA			JSR	LAB_1A46		; do NEXT (var)
  2816
  2817 				; evaluate expression and check is numeric, else do type mismatch
  2818 BAAA			LAB_EVNM
  2819 BAAA 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2820
  2821 				; check if source is numeric, else do type mismatch
  2822 BAAD			LAB_CTNM
  2823 BAAD 18				CLC				; destination is numeric
  2824 BAAE 24				.byte	$24			; makes next line BIT $38
  2825
  2826 				; check if source is string, else do type mismatch
  2827 BAAF			LAB_CTST
  2828 BAAF 38				SEC				; required type is string
  2829
  2830 				; type match check, set C for string, clear C for numeric
  2831 BAB0			LAB_CKTM
  2832 BAB0 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2833 BAB2 30 03			BMI	LAB_1ABA		; branch if data type is string
  2834
  2835 									; else data type was numeric
  2836 BAB4 B0 03			BCS	LAB_1ABC		; if required type is string do type mismatch error
  2837 BAB6			LAB_1AB9
  2838 BAB6 60				RTS
  2839
  2840 									; data type was string, now check required type
  2841 BAB7			LAB_1ABA
  2842 BAB7 B0 FD			BCS	LAB_1AB9		; exit if required type is string
  2843
  2844 									; else do type mismatch error
  2845 BAB9			LAB_1ABC
  2846 BAB9 A2 18			LDX	#$18			; error code $18 ('Type mismatch' error)
  2847 BABB			LAB_1ABE
  2848 BABB 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  2849
  2850 				; evaluate expression
  2851 BABE			LAB_EVEX
  2852 BABE A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2853 BAC0 D0 02			BNE	LAB_1AC7		; skip next if not zero
  2854
  2855 BAC2 C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2856 BAC4			LAB_1AC7
  2857 BAC4 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2858
  2859 BAC6			LAB_EVEZ
  2860 BAC6 A9 00			LDA	#$00			; set null precedence (flag done)
  2861 BAC8			LAB_1ACC
  2862 BAC8 48				PHA				; push precedence byte
  2863 BAC9 A9 02			LDA	#$02			; 2 bytes
  2864 BACB 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  2865 BACE 20 AA BB			JSR	LAB_GVAL		; get value from line
  2866 BAD1 A9 00			LDA	#$00			; clear A
  2867 BAD3 85 5B			STA	comp_f			; clear compare function flag
  2868 BAD5			LAB_1ADB
  2869 BAD5 20 82 00			JSR	LAB_GBYT		; scan memory
  2870 BAD8			LAB_1ADE
  2871 BAD8 38				SEC				; set carry for subtract
  2872 BAD9 E9 D6			SBC	#TK_GT			; subtract token for > (lowest comparison function)
  2873 BADB 90 17			BCC	LAB_1AFA		; branch if < TK_GT
  2874
  2875 BADD C9 03			CMP	#$03			; compare with '>' to '<' tokens
  2876 BADF B0 13			BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2877
  2878 									; was token for > = or < (A = 0, 1 or 2)
  2879 BAE1 C9 01			CMP	#$01			; compare with token for =
  2880 BAE3 2A				ROL				; *2, b0 = carry (=1 if token was = or <)
  2881 									; (A = 0, 3 or 5)
  2882 BAE4 49 01			EOR	#$01			; toggle b0
  2883 									; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2884 BAE6 45 5B			EOR	comp_f			; EOR with compare function flag bits
  2885 BAE8 C5 5B			CMP	comp_f			; compare with compare function flag
  2886 BAEA 90 67			BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
  2887 									; was more than one <, = or >)
  2888
  2889 BAEC 85 5B			STA	comp_f			; save new compare function flag
  2890 BAEE 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2891 BAF1 4C D8 BA			JMP	LAB_1ADE		; go do next character
  2892
  2893 									; token is < '>' or > '<' tokens
  2894 BAF4			LAB_1AFA
  2895 BAF4 A6 5B			LDX	comp_f			; get compare function flag
  2896 BAF6 D0 2C			BNE	LAB_1B2A		; branch if compare function
  2897
  2898 BAF8 B0 79			BCS	LAB_1B78		; go do functions
  2899
  2900 									; else was <  TK_GT so is operator or lower
  2901 BAFA 69 0B			ADC	#TK_GT-TK_PLUS		; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2902 BAFC 90 75			BCC	LAB_1B78		; branch if < + operator
  2903
  2904 									; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2905 BAFE D0 07			BNE	LAB_1B0B		; branch if not + token
  2906
  2907 BB00 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2908 BB02 10 03			BPL	LAB_1B0B		; branch if not string
  2909
  2910 									; will only be $00 if type is string and token was +
  2911 BB04 4C C1 C2			JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
  2912 									; is in line, and return
  2913
  2914 BB07			LAB_1B0B
  2915 BB07 85 31			STA	ut1_pl			; save it
  2916 BB09 0A				ASL				; *2
  2917 BB0A 65 31			ADC	ut1_pl			; *3
  2918 BB0C A8				TAY				; copy to index
  2919 BB0D			LAB_1B13
  2920 BB0D 68				PLA				; pull previous precedence
  2921 BB0E D9 38 D5			CMP	LAB_OPPT,Y		; compare with precedence byte
  2922 BB11 B0 65			BCS	LAB_1B7D		; branch if A >=
  2923
  2924 BB13 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2925 BB16			LAB_1B1C
  2926 BB16 48				PHA				; save precedence
  2927 BB17			LAB_1B1D
  2928 BB17 20 3F BB			JSR	LAB_1B43		; get vector, execute function then continue evaluation
  2929 BB1A 68				PLA				; restore precedence
  2930 BB1B A4 59			LDY	prstk			; get precedence stacked flag
  2931 BB1D 10 19			BPL	LAB_1B3C		; branch if stacked values
  2932
  2933 BB1F AA				TAX				; copy precedence (set flags)
  2934 BB20 F0 76			BEQ	LAB_1B9D		; exit if done
  2935
  2936 BB22 D0 5D			BNE	LAB_1B86		; else pop FAC2 and return, branch always
  2937
  2938 BB24			LAB_1B2A
  2939 BB24 26 1F			ROL	Dtypef			; shift data type flag into Cb
  2940 BB26 8A				TXA				; copy compare function flag
  2941 BB27 85 1F			STA	Dtypef			; clear data type flag, X is 0xxx xxxx
  2942 BB29 2A				ROL				; shift data type into compare function byte b0
  2943 BB2A A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2944 BB2C D0 02			BNE	LAB_1B34		; branch if no underflow
  2945
  2946 BB2E C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2947 BB30			LAB_1B34
  2948 BB30 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2949 = 000D			TK_LT_PLUS	= TK_LT-TK_PLUS
  2950 BB32 A0 27			LDY	#TK_LT_PLUS*3		; set offset to last operator entry
  2951 BB34 85 5B			STA	comp_f			; save new compare function flag
  2952 BB36 D0 D5			BNE	LAB_1B13		; branch always
  2953
  2954 BB38			LAB_1B3C
  2955 BB38 D9 38 D5			CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  2956 BB3B B0 44			BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  2957
  2958 BB3D 90 D7			BCC	LAB_1B1C		; branch always
  2959
  2960 				;.get vector, execute function then continue evaluation
  2961 BB3F			LAB_1B43
  2962 BB3F B9 3A D5			LDA	LAB_OPPT+2,Y		; get function vector high byte
  2963 BB42 48				PHA				; onto stack
  2964 BB43 B9 39 D5			LDA	LAB_OPPT+1,Y		; get function vector low byte
  2965 BB46 48				PHA				; onto stack
  2966 									; now push sign, round FAC1 and put on stack
  2967 BB47 20 56 BB			JSR	LAB_1B5B		; function will return here, then the next RTS will call
  2968 									; the function
  2969 BB4A A5 5B			LDA	comp_f			; get compare function flag
  2970 BB4C 48				PHA				; push compare evaluation byte
  2971 BB4D B9 38 D5			LDA	LAB_OPPT,Y		; get precedence byte
  2972 BB50 4C C8 BA			JMP	LAB_1ACC		; continue evaluating expression
  2973
  2974 BB53			LAB_1B53
  2975 BB53 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2976
  2977 				; push sign, round FAC1 and put on stack
  2978 BB56			LAB_1B5B
  2979 BB56 68				PLA				; get return addr low byte
  2980 BB57 85 31			STA	ut1_pl			; save it
  2981 BB59 E6 31			INC	ut1_pl			; increment it (was ret-1 pushed? yes!)
  2982 									; note! no check is made on the high byte! if the calling
  2983 									; routine assembles to a page edge then this all goes
  2984 									; horribly wrong !!!
  2985 BB5B 68				PLA				; get return addr high byte
  2986 BB5C 85 32			STA	ut1_ph			; save it
  2987 BB5E A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  2988 BB60 48				PHA				; push sign
  2989
  2990 				; round FAC1 and put on stack
  2991 BB61			LAB_1B66
  2992 BB61 20 C6 C8			JSR	LAB_27BA		; round FAC1
  2993 BB64 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  2994 BB66 48				PHA				; push on stack
  2995 BB67 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  2996 BB69 48				PHA				; push on stack
  2997 BB6A A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  2998 BB6C 48				PHA				; push on stack
  2999 BB6D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3000 BB6F 48				PHA				; push on stack
  3001 BB70 6C 31 00			JMP	(ut1_pl)		; return, sort of
  3002
  3003 				; do functions
  3004 BB73			LAB_1B78
  3005 BB73 A0 FF			LDY	#$FF			; flag function
  3006 BB75 68				PLA				; pull precedence byte
  3007 BB76			LAB_1B7B
  3008 BB76 F0 20			BEQ	LAB_1B9D		; exit if done
  3009
  3010 BB78			LAB_1B7D
  3011 BB78 C9 64			CMP	#$64			; compare previous precedence with $64
  3012 BB7A F0 03			BEQ	LAB_1B84		; branch if was $64 (< function)
  3013
  3014 BB7C 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3015 BB7F			LAB_1B84
  3016 BB7F 84 59			STY	prstk			; save precedence stacked flag
  3017
  3018 									; pop FAC2 and return
  3019 BB81			LAB_1B86
  3020 BB81 68				PLA				; pop byte
  3021 BB82 4A				LSR				; shift out comparison evaluation lowest bit
  3022 BB83 85 23			STA	Cflag			; save comparison evaluation flag
  3023 BB85 68				PLA				; pop exponent
  3024 BB86 85 73			STA	FAC2_e			; save FAC2 exponent
  3025 BB88 68				PLA				; pop mantissa1
  3026 BB89 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3027 BB8B 68				PLA				; pop mantissa2
  3028 BB8C 85 75			STA	FAC2_2			; save FAC2 mantissa2
  3029 BB8E 68				PLA				; pop mantissa3
  3030 BB8F 85 76			STA	FAC2_3			; save FAC2 mantissa3
  3031 BB91 68				PLA				; pop sign
  3032 BB92 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  3033 BB94 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  3034 BB96 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  3035 BB98			LAB_1B9D
  3036 BB98 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3037 BB9A 60				RTS
  3038
  3039 				; print '...' string to string util area
  3040 BB9B			LAB_1BC1
  3041 BB9B A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  3042 BB9D A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  3043 BB9F 69 00			ADC	#$00			; add carry to low byte
  3044 BBA1 90 01			BCC	LAB_1BCA		; branch if no overflow
  3045
  3046 BBA3 C8				INY				; increment high byte
  3047 BBA4			LAB_1BCA
  3048 BBA4 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  3049 BBA7 4C BC C4			JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  3050
  3051 				; get value from line
  3052 BBAA			LAB_GVAL
  3053 BBAA 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3054 BBAD B0 03			BCS	LAB_1BAC		; branch if not numeric character
  3055
  3056 									; else numeric string found (e.g. 123)
  3057 BBAF			LAB_1BA9
  3058 BBAF 4C 93 C9			JMP	LAB_2887		; get FAC1 from string and return
  3059
  3060 				; get value from line .. continued
  3061 									; wasn't a number so ..
  3062 BBB2			LAB_1BAC
  3063 BBB2 AA				TAX				; set the flags
  3064 BBB3 30 2F			BMI	LAB_1BD0		; if -ve go test token values
  3065
  3066 									; else it is either a string, number, variable or (<expr>)
  3067 BBB5 C9 24			CMP	#'$'			; compare with '$'
  3068 BBB7 F0 F6			BEQ	LAB_1BA9		; branch if '$', hex number
  3069
  3070 BBB9 C9 25			CMP	#'%'			; else compare with '%'
  3071 BBBB F0 F2			BEQ	LAB_1BA9		; branch if '%', binary number
  3072
  3073 BBBD C9 2E			CMP	#'.'			; compare with '.'
  3074 BBBF F0 EE			BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  3075
  3076 									; it wasn't any sort of number so ..
  3077 BBC1 C9 22			CMP	#$22			; compare with '
  3078 BBC3 F0 D6			BEQ	LAB_1BC1		; branch if open quote
  3079
  3080 									; wasn't any sort of number so ..
  3081
  3082 				; evaluate expression within parentheses
  3083 BBC5 C9 28			CMP	#'('			; compare with '('
  3084 BBC7 D0 4F			BNE	LAB_1C18		; if not '(' get (var), return value in FAC1 and $ flag
  3085
  3086 BBC9			LAB_1BF7
  3087 BBC9 20 C6 BA			JSR	LAB_EVEZ		; evaluate expression, no decrement
  3088
  3089 				; all the 'scan for' routines return the character after the sought character
  3090
  3091 				; scan for ')' , else do syntax error then warm start
  3092 BBCC			LAB_1BFB
  3093 BBCC A9 29			LDA	#$29			; load A with ')'
  3094
  3095 				; scan for CHR$(A) , else do syntax error then warm start
  3096 BBCE			LAB_SCCA
  3097 BBCE A0 00			LDY	#$00			; clear index
  3098 BBD0 D1 83			CMP	(Bpntrl),Y		; check next byte is = A
  3099 BBD2 D0 0B			BNE	LAB_SNER		; if not do syntax error then warm start
  3100
  3101 BBD4 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then return
  3102
  3103 				; scan for '(' , else do syntax error then warm start
  3104 BBD7			LAB_1BFE
  3105 BBD7 A9 28			LDA	#$28			; load A with '('
  3106 BBD9 D0 F3			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3107 									; (branch always)
  3108
  3109 				; scan for ',' , else do syntax error then warm start
  3110 BBDB			LAB_1C01
  3111 BBDB A9 2C			LDA	#$2C			; load A with ','
  3112 BBDD D0 EF			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3113 									; (branch always)
  3114
  3115 				; syntax error then warm start
  3116 BBDF			LAB_SNER
  3117 BBDF A2 02			LDX	#$02			; error code $02 ('Syntax' error)
  3118 BBE1 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3119
  3120 				; get value from line .. continued
  3121 				; do tokens
  3122 BBE4			LAB_1BD0
  3123 BBE4 C9 CC			CMP	#TK_MINUS		; compare with token for -
  3124 BBE6 F0 29			BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  3125
  3126 									; wasn't -n so ..
  3127 BBE8 C9 CB			CMP	#TK_PLUS		; compare with token for +
  3128 BBEA F0 BE			BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  3129
  3130 BBEC C9 C6			CMP	#TK_NOT		; compare with token for NOT
  3131 BBEE D0 13			BNE	LAB_1BE7		; branch if not token for NOT
  3132
  3133 									; was NOT token
  3134 = 000C			TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
  3135 BBF0 A0 24			LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  3136 BBF2 D0 1F			BNE	LAB_1C13		; do set-up for function then execute (branch always)
  3137
  3138 				; do = compare
  3139 BBF4			LAB_EQUAL
  3140 BBF4 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3141 BBF7 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3142 BBF9 49 FF			EOR	#$FF			; invert it
  3143 BBFB A8				TAY				; copy it
  3144 BBFC A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3145 BBFE 49 FF			EOR	#$FF			; invert it
  3146 BC00 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3147
  3148 				; get value from line .. continued
  3149 									; wasn't +, -, or NOT so ..
  3150 BC03			LAB_1BE7
  3151 BC03 C9 C3			CMP	#TK_FN			; compare with token for FN
  3152 BC05 D0 03			BNE	LAB_1BEE		; branch if not token for FN
  3153
  3154 BC07 4C 9F C0			JMP	LAB_201E		; go evaluate FNx
  3155
  3156 				; get value from line .. continued
  3157 									; wasn't +, -, NOT or FN so ..
  3158 BC0A			LAB_1BEE
  3159 BC0A E9 D9			SBC	#TK_SGN			; subtract with token for SGN
  3160 BC0C B0 1B			BCS	LAB_1C27		; if a function token go do it
  3161
  3162 BC0E 4C DF BB			JMP	LAB_SNER		; else do syntax error
  3163
  3164 				; set-up for functions
  3165 BC11			LAB_1C11
  3166 = 000B			TK_GT_PLUS	= TK_GT-TK_PLUS
  3167 BC11 A0 21			LDY	#TK_GT_PLUS*3		; set offset from base to > operator
  3168 BC13			LAB_1C13
  3169 BC13 68				PLA				; dump return address low byte
  3170 BC14 68				PLA				; dump return address high byte
  3171 BC15 4C 17 BB			JMP	LAB_1B1D		; execute function then continue evaluation
  3172
  3173 				; variable name set-up
  3174 				; get (var), return value in FAC_1 and $ flag
  3175 BC18			LAB_1C18
  3176 BC18 20 89 BD			JSR	LAB_GVAR		; get (var) address
  3177 BC1B 85 6E			STA	FAC1_2			; save address low byte in FAC1 mantissa2
  3178 BC1D 84 6F			STY	FAC1_3			; save address high byte in FAC1 mantissa3
  3179 BC1F A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  3180 BC21 30 03			BMI	LAB_1C25		; if string then return (does RTS)
  3181
  3182 BC23			LAB_1C24
  3183 BC23 4C 6A C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  3184
  3185 BC26			LAB_1C25	; patch string pointer high byte trashed when moved to stack
  3186 BC26 46 79			LSR   	FAC1_r            	; clear bit 7 (<$80) = do not round up
  3187 BC28 60				RTS
  3188
  3189 				; get value from line .. continued
  3190 				; only functions left so ..
  3191
  3192 				; set up function references
  3193
  3194 				; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3195 				; to process function calls. now the function vector is computed and pushed on the stack
  3196 				; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3197 				; is calculated and the routine called, if not this routine just does RTS. whichever
  3198 				; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3199 				; the function code
  3200
  3201 				; this also removes some less than elegant code that was used to bypass type checking
  3202 				; for functions that returned strings
  3203 BC29			LAB_1C27
  3204 BC29 0A				ASL				; *2 (2 bytes per function address)
  3205 BC2A A8				TAY				; copy to index
  3206
  3207 BC2B B9 EB D4			LDA	LAB_FTBM,Y		; get function jump vector high byte
  3208 BC2E 48				PHA				; push functions jump vector high byte
  3209 BC2F B9 EA D4			LDA	LAB_FTBL,Y		; get function jump vector low byte
  3210 BC32 48				PHA				; push functions jump vector low byte
  3211
  3212 BC33 B9 9D D4			LDA	LAB_FTPM,Y		; get function pre process vector high byte
  3213 BC36 F0 05			BEQ	LAB_1C56		; skip pre process if null vector
  3214
  3215 BC38 48				PHA				; push functions pre process vector high byte
  3216 BC39 B9 9C D4			LDA	LAB_FTPL,Y		; get function pre process vector low byte
  3217 BC3C 48				PHA				; push functions pre process vector low byte
  3218
  3219 BC3D			LAB_1C56
  3220 BC3D 60				RTS				; do function, or pre process, call
  3221
  3222 				; process string expression in parenthesis
  3223 BC3E			LAB_PPFS
  3224 BC3E 20 C9 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3225 BC41 4C AF BA			JMP	LAB_CTST		; check if source is string then do function,
  3226 									; else do type mismatch
  3227
  3228 				; process numeric expression in parenthesis
  3229 BC44			LAB_PPFN
  3230 BC44 20 C9 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3231 BC47 4C AD BA			JMP	LAB_CTNM		; check if source is numeric then do function,
  3232 									; else do type mismatch
  3233
  3234 				; set numeric data type and increment BASIC execute pointer
  3235 BC4A			LAB_PPBI
  3236 BC4A 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3237 BC4C 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then do function
  3238
  3239 				; process string for LEFT$, RIGHT$ or MID$
  3240 BC4F			LAB_LRMS
  3241 BC4F 20 C6 BA			JSR	LAB_EVEZ		; evaluate (should be string) expression
  3242 BC52 20 DB BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3243 BC55 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  3244
  3245 BC58 68				PLA				; get function jump vector low byte
  3246 BC59 AA				TAX				; save functions jump vector low byte
  3247 BC5A 68				PLA				; get function jump vector high byte
  3248 BC5B A8				TAY				; save functions jump vector high byte
  3249 BC5C A5 6F			LDA	des_ph			; get descriptor pointer high byte
  3250 BC5E 48				PHA				; push string pointer high byte
  3251 BC5F A5 6E			LDA	des_pl			; get descriptor pointer low byte
  3252 BC61 48				PHA				; push string pointer low byte
  3253 BC62 98				TYA				; get function jump vector high byte back
  3254 BC63 48				PHA				; save functions jump vector high byte
  3255 BC64 8A				TXA				; get function jump vector low byte back
  3256 BC65 48				PHA				; save functions jump vector low byte
  3257 BC66 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  3258 BC69 8A				TXA				; copy byte parameter to A
  3259 BC6A 60				RTS				; go do function
  3260
  3261 				; process numeric expression(s) for BIN$ or HEX$
  3262 BC6B			LAB_BHSS
  3263 BC6B 20 C6 BA			JSR	LAB_EVEZ		; process expression
  3264 BC6E 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3265 BC71 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3266 BC73 C9 98			CMP	#$98			; compare with exponent = 2^24
  3267 BC75 B0 20			BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  3268
  3269 BC77 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  3270 BC7A A2 02			LDX	#$02			; 3 bytes to do
  3271 BC7C			LAB_CFAC
  3272 BC7C B5 6D			LDA	FAC1_1,X		; get byte from FAC1
  3273 BC7E 95 11			STA	nums_1,X		; save byte to temp
  3274 BC80 CA				DEX				; decrement index
  3275 BC81 10 F9			BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  3276
  3277 BC83 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  3278 BC86 A2 00			LDX	#$00			; set default to no leading '0's
  3279 BC88 C9 29			CMP	#')'			; compare with close bracket
  3280 BC8A F0 0A			BEQ	LAB_1C54		; if ')' go do rest of function
  3281
  3282 BC8C 20 CB C4			JSR	LAB_SCGB		; scan for ',' and get byte
  3283 BC8F 20 82 00			JSR	LAB_GBYT		; get last byte back
  3284 BC92 C9 29			CMP	#')'			; is next character )
  3285 BC94 D0 01			BNE	LAB_BHER		; if not ')' go do error
  3286
  3287 BC96			LAB_1C54
  3288 BC96 60				RTS				; else do function
  3289
  3290 BC97			LAB_BHER
  3291 BC97 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  3292
  3293 				; perform EOR
  3294
  3295 				; added operator format is the same as AND or OR, precedence is the same as OR
  3296
  3297 				; this bit worked first time but it took a while to sort out the operator table
  3298 				; pointers and offsets afterwards!
  3299 BC9A			LAB_EOR
  3300 BC9A 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3301 BC9D 45 1B			EOR	XOAw_l			; EOR with expression 1 low byte
  3302 BC9F A8				TAY				; save in Y
  3303 BCA0 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3304 BCA2 45 1C			EOR	XOAw_h			; EOR with expression 1 high byte
  3305 BCA4 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3306
  3307 				; perform OR
  3308 BCA7			LAB_OR
  3309 BCA7 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3310 BCAA 05 1B			ORA	XOAw_l			; OR with expression 1 low byte
  3311 BCAC A8				TAY				; save in Y
  3312 BCAD A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3313 BCAF 05 1C			ORA	XOAw_h			; OR with expression 1 high byte
  3314 BCB1 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3315
  3316 				; perform AND
  3317 BCB4			LAB_AND
  3318 BCB4 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3319 BCB7 25 1B			AND	XOAw_l			; AND with expression 1 low byte
  3320 BCB9 A8				TAY				; save in Y
  3321 BCBA A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3322 BCBC 25 1C			AND	XOAw_h			; AND with expression 1 high byte
  3323 BCBE 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3324
  3325 				; get first value for OR, AND or EOR
  3326 BCC1			GetFirst
  3327 BCC1 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3328 BCC4 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3329 BCC6 85 1C			STA	XOAw_h			; save it
  3330 BCC8 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3331 BCCA 85 1B			STA	XOAw_l			; save it
  3332 BCCC 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3333 BCCF 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3334 BCD2 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3335 BCD4			LAB_1C95
  3336 BCD4 60				RTS
  3337
  3338 				; perform comparisons
  3339
  3340 				; do < compare
  3341 BCD5			LAB_LTHAN
  3342 BCD5 20 B0 BA			JSR	LAB_CKTM		; type match check, set C for string
  3343 BCD8 B0 13			BCS	LAB_1CAE		; branch if string
  3344 									; do numeric < compare
  3345 BCDA A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  3346 BCDC 09 7F			ORA	#$7F			; set all non sign bits
  3347 BCDE 25 74			AND	FAC2_1			; and FAC2 mantissa1 (AND in sign bit)
  3348 BCE0 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3349 BCE2 A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  3350 BCE4 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  3351 BCE6 20 04 C9			JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3352 BCE9 AA				TAX				; copy result
  3353 BCEA 4C 1E BD			JMP	LAB_1CE1		; go evaluate result
  3354 									; do string < compare
  3355 BCED			LAB_1CAE
  3356 BCED 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3357 BCEF C6 5B			DEC	comp_f			; clear < bit in compare function flag
  3358 BCF1 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3359 									; space returns with A = length, X=pointer low byte,
  3360 									; Y=pointer high byte
  3361 BCF4 85 6C			STA	str_ln			; save length
  3362 BCF6 86 6D			STX	str_pl			; save string pointer low byte
  3363 BCF8 84 6E			STY	str_ph			; save string pointer high byte
  3364 BCFA A5 75			LDA	FAC2_2			; get descriptor pointer low byte
  3365 BCFC A4 76			LDY	FAC2_3			; get descriptor pointer high byte
  3366 BCFE 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3367 									; returns with A = length, X=pointer low byte,
  3368 									; Y=pointer high byte
  3369 BD01 86 75			STX	FAC2_2			; save string pointer low byte
  3370 BD03 84 76			STY	FAC2_3			; save string pointer high byte
  3371 BD05 AA				TAX				; copy length
  3372 BD06 38				SEC				; set carry for subtract
  3373 BD07 E5 6C			SBC	str_ln			; subtract string 1 length
  3374 BD09 F0 08			BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3375
  3376 BD0B A9 01			LDA	#$01			; set str 1 length > string 2 length
  3377 BD0D 90 04			BCC	LAB_1CD6		; branch if so
  3378
  3379 BD0F A6 6C			LDX	str_ln			; get string 1 length
  3380 BD11 A9 FF			LDA	#$FF			; set str 1 length < string 2 length
  3381 BD13			LAB_1CD6
  3382 BD13 85 70			STA	FAC1_s			; save length compare
  3383 BD15 A0 FF			LDY	#$FF			; set index
  3384 BD17 E8				INX				; adjust for loop
  3385 BD18			LAB_1CDB
  3386 BD18 C8				INY				; increment index
  3387 BD19 CA				DEX				; decrement count
  3388 BD1A D0 07			BNE	LAB_1CE6		; branch if still bytes to do
  3389
  3390 BD1C A6 70			LDX	FAC1_s			; get length compare back
  3391 BD1E			LAB_1CE1
  3392 BD1E 30 0F			BMI	LAB_1CF2		; branch if str 1 < str 2
  3393
  3394 BD20 18				CLC				; flag str 1 <= str 2
  3395 BD21 90 0C			BCC	LAB_1CF2		; go evaluate result
  3396
  3397 BD23			LAB_1CE6
  3398 BD23 B1 75			LDA	(FAC2_2),Y		; get string 2 byte
  3399 BD25 D1 6D			CMP	(FAC1_1),Y		; compare with string 1 byte
  3400 BD27 F0 EF			BEQ	LAB_1CDB		; loop if bytes =
  3401
  3402 BD29 A2 FF			LDX	#$FF			; set str 1 < string 2
  3403 BD2B B0 02			BCS	LAB_1CF2		; branch if so
  3404
  3405 BD2D A2 01			LDX	#$01			;  set str 1 > string 2
  3406 BD2F			LAB_1CF2
  3407 BD2F E8				INX				; x = 0, 1 or 2
  3408 BD30 8A				TXA				; copy to A
  3409 BD31 2A				ROL				; *2 (1, 2 or 4)
  3410 BD32 25 23			AND	Cflag			; AND with comparison evaluation flag
  3411 BD34 F0 02			BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3412
  3413 BD36 A9 FF			LDA	#$FF			; else set result true
  3414 BD38			LAB_1CFB
  3415 BD38 4C E7 C8			JMP	LAB_27DB		; save A as integer byte and return
  3416
  3417 BD3B			LAB_1CFE
  3418 BD3B 20 DB BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3419
  3420 				; perform DIM
  3421 BD3E			LAB_DIM
  3422 BD3E AA				TAX				; copy 'DIM' flag to X
  3423 BD3F 20 8E BD			JSR	LAB_1D10		; search for variable
  3424 BD42 20 82 00			JSR	LAB_GBYT		; scan memory
  3425 BD45 D0 F4			BNE	LAB_1CFE		; scan for ',' and loop if not null
  3426
  3427 BD47 60				RTS
  3428
  3429 				; perform << (left shift)
  3430 BD48			LAB_LSHIFT
  3431 BD48 20 7E BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3432 BD4B A5 6E			LDA	FAC1_2			; get expression high byte
  3433 BD4D A6 38			LDX	TempB			; get shift count
  3434 BD4F F0 22			BEQ	NoShift			; branch if zero
  3435
  3436 BD51 E0 10			CPX	#$10			; compare bit count with 16d
  3437 BD53 B0 23			BCS	TooBig			; branch if >=
  3438
  3439 BD55			Ls_loop
  3440 BD55 06 6F			ASL	FAC1_3			; shift low byte
  3441 BD57 2A				ROL				; shift high byte
  3442 BD58 CA				DEX				; decrement bit count
  3443 BD59 D0 FA			BNE	Ls_loop			; loop if shift not complete
  3444
  3445 BD5B A4 6F			LDY	FAC1_3			; get expression low byte
  3446 BD5D 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3447
  3448 				; perform >> (right shift)
  3449 BD60			LAB_RSHIFT
  3450 BD60 20 7E BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3451 BD63 A5 6E			LDA	FAC1_2			; get expression high byte
  3452 BD65 A6 38			LDX	TempB			; get shift count
  3453 BD67 F0 0A			BEQ	NoShift			; branch if zero
  3454
  3455 BD69 E0 10			CPX	#$10			; compare bit count with 16d
  3456 BD6B B0 0B			BCS	TooBig			; branch if >=
  3457
  3458 BD6D			Rs_loop
  3459 BD6D 4A				LSR				; shift high byte
  3460 BD6E 66 6F			ROR	FAC1_3			; shift low byte
  3461 BD70 CA				DEX				; decrement bit count
  3462 BD71 D0 FA			BNE	Rs_loop			; loop if shift not complete
  3463
  3464 BD73			NoShift
  3465 BD73 A4 6F			LDY	FAC1_3			; get expression low byte
  3466 BD75 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3467
  3468 BD78			TooBig
  3469 BD78 A9 00			LDA	#$00			; clear high byte
  3470 BD7A A8				TAY				; copy to low byte
  3471 BD7B 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3472
  3473 BD7E			GetPair
  3474 BD7E 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  3475 BD81 86 38			STX	TempB			; save it
  3476 BD83 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3477 BD86 4C 85 BE			JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3478
  3479 				; search for variable
  3480
  3481 				; return pointer to variable in Cvaral/Cvarah
  3482 BD89			LAB_GVAR
  3483 BD89 A2 00			LDX	#$00			; set DIM flag = $00
  3484 BD8B 20 82 00			JSR	LAB_GBYT		; scan memory (1st character)
  3485 BD8E			LAB_1D10
  3486 BD8E 86 1E			STX	Defdim			; save DIM flag
  3487 BD90			LAB_1D12
  3488 BD90 85 53			STA	Varnm1			; save 1st character
  3489 BD92 29 7F			AND	#$7F			; clear FN flag bit
  3490 BD94 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3491 BD97 B0 03			BCS	LAB_1D1F		; branch if ok
  3492
  3493 BD99 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  3494
  3495 									; was variable name so ..
  3496 BD9C			LAB_1D1F
  3497 BD9C A2 00			LDX	#$00			; clear 2nd character temp
  3498 BD9E 86 1F			STX	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3499 BDA0 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (2nd character)
  3500 BDA3 90 05			BCC	LAB_1D2D		; branch if character = '0'-'9' (ok)
  3501
  3502 									; 2nd character wasn't '0' to '9' so ..
  3503 BDA5 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3504 BDA8 90 0B			BCC	LAB_1D38		; branch if <'A' or >'Z' (go check if string)
  3505
  3506 BDAA			LAB_1D2D
  3507 BDAA AA				TAX				; copy 2nd character
  3508
  3509 									; ignore further (valid) characters in the variable name
  3510 BDAB			LAB_1D2E
  3511 BDAB 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (3rd character)
  3512 BDAE 90 FB			BCC	LAB_1D2E		; loop if character = '0'-'9' (ignore)
  3513
  3514 BDB0 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3515 BDB3 B0 F6			BCS	LAB_1D2E		; loop if character = 'A'-'Z' (ignore)
  3516
  3517 									; check if string variable
  3518 BDB5			LAB_1D38
  3519 BDB5 C9 24			CMP	#'$'			; compare with '$'
  3520 BDB7 D0 0B			BNE	LAB_1D47		; branch if not string
  3521
  3522 				; to introduce a new variable type (% suffix for integers say) then this branch
  3523 				; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3524 									; type is string
  3525 BDB9 A9 FF			LDA	#$FF			; set data type = string
  3526 BDBB 85 1F			STA	Dtypef			; set data type flag, $FF=string, $00=numeric
  3527 BDBD 8A				TXA				; get 2nd character back
  3528 BDBE 09 80			ORA	#$80			; set top bit (indicate string var)
  3529 BDC0 AA				TAX				; copy back to 2nd character temp
  3530 BDC1 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3531
  3532 				; after we have determined the variable type we need to come back here to determine
  3533 				; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3534 BDC4			LAB_1D47				; gets here with character after var name in A
  3535 BDC4 86 54			STX	Varnm2			; save 2nd character
  3536 BDC6 05 21			ORA	Sufnxf			; or with subscript/FNX flag (or FN name)
  3537 BDC8 C9 28			CMP	#'('			; compare with '('
  3538 BDCA D0 03			BNE	LAB_1D53		; branch if not '('
  3539
  3540 BDCC 4C 97 BE			JMP	LAB_1E17		; go find, or make, array
  3541
  3542 				; either find or create var
  3543 				; var name (1st two characters only!) is in Varnm1,Varnm2
  3544 									; variable name wasn't var(... so look for plain var
  3545 BDCF			LAB_1D53
  3546 BDCF A9 00			LDA	#$00			; clear A
  3547 BDD1 85 21			STA	Sufnxf			; clear subscript/FNX flag
  3548 BDD3 A5 3B			LDA	Svarl			; get start of vars low byte
  3549 BDD5 A6 3C			LDX	Svarh			; get start of vars high byte
  3550 BDD7 A0 00			LDY	#$00			; clear index
  3551 BDD9			LAB_1D5D
  3552 BDD9 86 6B			STX	Vrschh			; save search address high byte
  3553 BDDB			LAB_1D5F
  3554 BDDB 85 6A			STA	Vrschl			; save search address low byte
  3555 BDDD E4 3E			CPX	Sarryh			; compare high address with var space end
  3556 BDDF D0 04			BNE	LAB_1D69		; skip next compare if <>
  3557
  3558 									; high addresses were = so compare low addresses
  3559 BDE1 C5 3D			CMP	Sarryl			; compare low address with var space end
  3560 BDE3 F0 2C			BEQ	LAB_1D8B		; if not found go make new var
  3561
  3562 BDE5			LAB_1D69
  3563 BDE5 A5 53			LDA	Varnm1			; get 1st character of var to find
  3564 BDE7 D1 6A			CMP	(Vrschl),Y		; compare with variable name 1st character
  3565 BDE9 D0 08			BNE	LAB_1D77		; branch if no match
  3566
  3567 									; 1st characters match so compare 2nd characters
  3568 BDEB A5 54			LDA	Varnm2			; get 2nd character of var to find
  3569 BDED C8				INY				; index to point to variable name 2nd character
  3570 BDEE D1 6A			CMP	(Vrschl),Y		; compare with variable name 2nd character
  3571 BDF0 F0 69			BEQ	LAB_1DD7		; branch if match (found var)
  3572
  3573 BDF2 88				DEY				; else decrement index (now = $00)
  3574 BDF3			LAB_1D77
  3575 BDF3 18				CLC				; clear carry for add
  3576 BDF4 A5 6A			LDA	Vrschl			; get search address low byte
  3577 BDF6 69 06			ADC	#$06			; +6 (offset to next var name)
  3578 BDF8 90 E1			BCC	LAB_1D5F		; loop if no overflow to high byte
  3579
  3580 BDFA E8				INX				; else increment high byte
  3581 BDFB D0 DC			BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3582
  3583 				; check byte, return C=0 if<'A' or >'Z' or 'a' to 'z'
  3584 BDFD			LAB_CASC
  3585 BDFD C9 61			CMP	#'a'			; compare with 'a'
  3586 BDFF B0 0A			BCS	LAB_1D83		; go check <'z'+1
  3587
  3588 				; check byte, return C=0 if<'A' or >'Z'
  3589 BE01			LAB_1D82
  3590 BE01 C9 41			CMP	#'A'			; compare with 'A'
  3591 BE03 90 05			BCC	LAB_1D8A		; exit if less
  3592
  3593 									; carry is set
  3594 BE05 E9 5B			SBC	#$5B			; subtract 'Z'+1
  3595 BE07 38				SEC				; set carry
  3596 BE08 E9 A5			SBC	#$A5			; subtract $A5 (restore byte)
  3597 									; carry clear if byte>$5A
  3598 BE0A			LAB_1D8A
  3599 BE0A 60				RTS
  3600
  3601 BE0B			LAB_1D83
  3602 BE0B E9 7B			SBC	#$7B			; subtract 'z'+1
  3603 BE0D 38				SEC				; set carry
  3604 BE0E E9 85			SBC	#$85			; subtract $85 (restore byte)
  3605 									; carry clear if byte>$7A
  3606 BE10 60				RTS
  3607
  3608 									; reached end of variable mem without match
  3609 									; .. so create new variable
  3610 BE11			LAB_1D8B
  3611 BE11 68				PLA				; pop return address low byte
  3612 BE12 48				PHA				; push return address low byte
  3613 = BC1A			LAB_1C18p2	= LAB_1C18+2
  3614 BE13 C9 1A			CMP	#<LAB_1C18p2		; compare with expected calling routine return low byte
  3615 BE15 D0 05			BNE	LAB_1D98		; if not get (var) go create new var
  3616
  3617 				; This will only drop through if the call was from LAB_1C18 and is only called
  3618 				; from there if it is searching for a variable from the RHS of a LET a=b statement
  3619 				; it prevents the creation of variables not assigned a value.
  3620
  3621 				; value returned by this is either numeric zero (exponent byte is $00) or null string
  3622 				; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3623
  3624 				; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3625
  3626 				; this is where you would put the undefined variable error call e.g.
  3627
  3628 				;					; variable doesn't exist so flag error
  3629 				;	LDX	#$24			; error code $24 ('undefined variable' error)
  3630 				;	JMP	LAB_XERR		; do error #X then warm start
  3631
  3632 				; the above code has been tested and works a treat! (it replaces the three code lines
  3633 				; below)
  3634 									; else return dummy null value
  3635 BE17 A9 F6			LDA	#<LAB_1D96		; low byte point to $00,$00
  3636 									; (uses part of misc constants table)
  3637 BE19 A0 D3			LDY	#>LAB_1D96		; high byte point to $00,$00
  3638 BE1B 60				RTS
  3639
  3640 				; create new numeric variable
  3641 BE1C			LAB_1D98
  3642 BE1C A5 3D			LDA	Sarryl			; get var mem end low byte
  3643 BE1E A4 3E			LDY	Sarryh			; get var mem end high byte
  3644 BE20 85 6A			STA	Ostrtl			; save old block start low byte
  3645 BE22 84 6B			STY	Ostrth			; save old block start high byte
  3646 BE24 A5 3F			LDA	Earryl			; get array mem end low byte
  3647 BE26 A4 40			LDY	Earryh			; get array mem end high byte
  3648 BE28 85 66			STA	Obendl			; save old block end low byte
  3649 BE2A 84 67			STY	Obendh			; save old block end high byte
  3650 BE2C 18				CLC				; clear carry for add
  3651 BE2D 69 06			ADC	#$06			; +6 (space for one var)
  3652 BE2F 90 01			BCC	LAB_1DAE		; branch if no overflow to high byte
  3653
  3654 BE31 C8				INY				; else increment high byte
  3655 BE32			LAB_1DAE
  3656 BE32 85 64			STA	Nbendl			; set new block end low byte
  3657 BE34 84 65			STY	Nbendh			; set new block end high byte
  3658 BE36 20 8D B0			JSR	LAB_11CF		; open up space in memory
  3659 BE39 A5 64			LDA	Nbendl			; get new start low byte
  3660 BE3B A4 65			LDY	Nbendh			; get new start high byte (-$100)
  3661 BE3D C8				INY				; correct high byte
  3662 BE3E 85 3D			STA	Sarryl			; save new var mem end low byte
  3663 BE40 84 3E			STY	Sarryh			; save new var mem end high byte
  3664 BE42 A0 00			LDY	#$00			; clear index
  3665 BE44 A5 53			LDA	Varnm1			; get var name 1st character
  3666 BE46 91 6A			STA	(Vrschl),Y		; save var name 1st character
  3667 BE48 C8				INY				; increment index
  3668 BE49 A5 54			LDA	Varnm2			; get var name 2nd character
  3669 BE4B 91 6A			STA	(Vrschl),Y		; save var name 2nd character
  3670 BE4D A9 00			LDA	#$00			; clear A
  3671 BE4F C8				INY				; increment index
  3672 BE50 91 6A			STA	(Vrschl),Y		; initialise var byte
  3673 BE52 C8				INY				; increment index
  3674 BE53 91 6A			STA	(Vrschl),Y		; initialise var byte
  3675 BE55 C8				INY				; increment index
  3676 BE56 91 6A			STA	(Vrschl),Y		; initialise var byte
  3677 BE58 C8				INY				; increment index
  3678 BE59 91 6A			STA	(Vrschl),Y		; initialise var byte
  3679
  3680 									; found a match for var ((Vrschl) = ptr)
  3681 BE5B			LAB_1DD7
  3682 BE5B A5 6A			LDA	Vrschl			; get var address low byte
  3683 BE5D 18				CLC				; clear carry for add
  3684 BE5E 69 02			ADC	#$02			; +2 (offset past var name bytes)
  3685 BE60 A4 6B			LDY	Vrschh			; get var address high byte
  3686 BE62 90 01			BCC	LAB_1DE1		; branch if no overflow from add
  3687
  3688 BE64 C8				INY				; else increment high byte
  3689 BE65			LAB_1DE1
  3690 BE65 85 55			STA	Cvaral			; save current var address low byte
  3691 BE67 84 56			STY	Cvarah			; save current var address high byte
  3692 BE69 60				RTS
  3693
  3694 				; set-up array pointer (Adatal/h) to first element in array
  3695 				; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3696 BE6A			LAB_1DE6
  3697 BE6A A5 1D			LDA	Dimcnt			; get # of dimensions (1, 2 or 3)
  3698 BE6C 0A				ASL				; *2 (also clears the carry !)
  3699 BE6D 69 05			ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3700 BE6F 65 6A			ADC	Astrtl			; add array start pointer low byte
  3701 BE71 A4 6B			LDY	Astrth			; get array pointer high byte
  3702 BE73 90 01			BCC	LAB_1DF2		; branch if no overflow
  3703
  3704 BE75 C8				INY				; else increment high byte
  3705 BE76			LAB_1DF2
  3706 BE76 85 64			STA	Adatal			; save array data pointer low byte
  3707 BE78 84 65			STY	Adatah			; save array data pointer high byte
  3708 BE7A 60				RTS
  3709
  3710 				; evaluate integer expression
  3711 BE7B			LAB_EVIN
  3712 BE7B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3713 BE7E 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3714 									; else do type mismatch
  3715
  3716 				; evaluate integer expression (no check)
  3717 BE81			LAB_EVPI
  3718 BE81 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  3719 BE83 30 0D			BMI	LAB_1E12		; do function call error if -ve
  3720
  3721 				; evaluate integer expression (no sign check)
  3722 BE85			LAB_EVIR
  3723 BE85 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3724 BE87 C9 90			CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3725 BE89 90 09			BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3726
  3727 BE8B A9 FD			LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3728 BE8D A0 D3			LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3729 BE8F 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  3730 BE92			LAB_1E12
  3731 BE92 D0 74			BNE	LAB_FCER		; if <> do function call error then warm start
  3732
  3733 BE94			LAB_1E14
  3734 BE94 4C 3D C9			JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  3735
  3736 				; find or make array
  3737 BE97			LAB_1E17
  3738 BE97 A5 1E			LDA	Defdim			; get DIM flag
  3739 BE99 48				PHA				; push it
  3740 BE9A A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  3741 BE9C 48				PHA				; push it
  3742 BE9D A0 00			LDY	#$00			; clear dimensions count
  3743
  3744 				; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3745 BE9F			LAB_1E1F
  3746 BE9F 98				TYA				; copy dimensions count
  3747 BEA0 48				PHA				; save it
  3748 BEA1 A5 54			LDA	Varnm2			; get array name 2nd byte
  3749 BEA3 48				PHA				; save it
  3750 BEA4 A5 53			LDA	Varnm1			; get array name 1st byte
  3751 BEA6 48				PHA				; save it
  3752 BEA7 20 7B BE			JSR	LAB_EVIN		; evaluate integer expression
  3753 BEAA 68				PLA				; pull array name 1st byte
  3754 BEAB 85 53			STA	Varnm1			; restore array name 1st byte
  3755 BEAD 68				PLA				; pull array name 2nd byte
  3756 BEAE 85 54			STA	Varnm2			; restore array name 2nd byte
  3757 BEB0 68				PLA				; pull dimensions count
  3758 BEB1 A8				TAY				; restore it
  3759 BEB2 BA				TSX				; copy stack pointer
  3760 BEB3 BD 02 01			LDA	LAB_STAK+2,X		; get DIM flag
  3761 BEB6 48				PHA				; push it
  3762 BEB7 BD 01 01			LDA	LAB_STAK+1,X		; get data type flag
  3763 BEBA 48				PHA				; push it
  3764 BEBB A5 6E			LDA	FAC1_2			; get this dimension size high byte
  3765 BEBD 9D 02 01			STA	LAB_STAK+2,X		; stack before flag bytes
  3766 BEC0 A5 6F			LDA	FAC1_3			; get this dimension size low byte
  3767 BEC2 9D 01 01			STA	LAB_STAK+1,X		; stack before flag bytes
  3768 BEC5 C8				INY				; increment dimensions count
  3769 BEC6 20 82 00			JSR	LAB_GBYT		; scan memory
  3770 BEC9 C9 2C			CMP	#','			; compare with ','
  3771 BECB F0 D2			BEQ	LAB_1E1F		; if found go do next dimension
  3772
  3773 BECD 84 1D			STY	Dimcnt			; store dimensions count
  3774 BECF 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  3775 BED2 68				PLA				; pull data type flag
  3776 BED3 85 1F			STA	Dtypef			; restore data type flag, $FF=string, $00=numeric
  3777 BED5 68				PLA				; pull DIM flag
  3778 BED6 85 1E			STA	Defdim			; restore DIM flag
  3779 BED8 A6 3D			LDX	Sarryl			; get array mem start low byte
  3780 BEDA A5 3E			LDA	Sarryh			; get array mem start high byte
  3781
  3782 				; now check to see if we are at the end of array memory (we would be if there were
  3783 				; no arrays).
  3784 BEDC			LAB_1E5C
  3785 BEDC 86 6A			STX	Astrtl			; save as array start pointer low byte
  3786 BEDE 85 6B			STA	Astrth			; save as array start pointer high byte
  3787 BEE0 C5 40			CMP	Earryh			; compare with array mem end high byte
  3788 BEE2 D0 04			BNE	LAB_1E68		; branch if not reached array mem end
  3789
  3790 BEE4 E4 3F			CPX	Earryl			; else compare with array mem end low byte
  3791 BEE6 F0 39			BEQ	LAB_1EA1		; go build array if not found
  3792
  3793 									; search for array
  3794 BEE8			LAB_1E68
  3795 BEE8 A0 00			LDY	#$00			; clear index
  3796 BEEA B1 6A			LDA	(Astrtl),Y		; get array name first byte
  3797 BEEC C8				INY				; increment index to second name byte
  3798 BEED C5 53			CMP	Varnm1			; compare with this array name first byte
  3799 BEEF D0 06			BNE	LAB_1E77		; branch if no match
  3800
  3801 BEF1 A5 54			LDA	Varnm2			; else get this array name second byte
  3802 BEF3 D1 6A			CMP	(Astrtl),Y		; compare with array name second byte
  3803 BEF5 F0 16			BEQ	LAB_1E8D		; array found so branch
  3804
  3805 									; no match
  3806 BEF7			LAB_1E77
  3807 BEF7 C8				INY				; increment index
  3808 BEF8 B1 6A			LDA	(Astrtl),Y		; get array size low byte
  3809 BEFA 18				CLC				; clear carry for add
  3810 BEFB 65 6A			ADC	Astrtl			; add array start pointer low byte
  3811 BEFD AA				TAX				; copy low byte to X
  3812 BEFE C8				INY				; increment index
  3813 BEFF B1 6A			LDA	(Astrtl),Y		; get array size high byte
  3814 BF01 65 6B			ADC	Astrth			; add array mem pointer high byte
  3815 BF03 90 D7			BCC	LAB_1E5C		; if no overflow go check next array
  3816
  3817 				; do array bounds error
  3818 BF05			LAB_1E85
  3819 BF05 A2 10			LDX	#$10			; error code $10 ('Array bounds' error)
  3820 BF07 2C				.byte	$2C			; makes next bit BIT LAB_08A2
  3821
  3822 				; do function call error
  3823 BF08			LAB_FCER
  3824 BF08 A2 08			LDX	#$08			; error code $08 ('Function call' error)
  3825 BF0A			LAB_1E8A
  3826 BF0A 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3827
  3828 									; found array, are we trying to dimension it?
  3829 BF0D			LAB_1E8D
  3830 BF0D A2 12			LDX	#$12			; set error $12 ('Double dimension' error)
  3831 BF0F A5 1E			LDA	Defdim			; get DIM flag
  3832 BF11 D0 F7			BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3833 									; start
  3834
  3835 				; found the array and we're not dimensioning it so we must find an element in it
  3836 BF13 20 6A BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3837 									; (Astrtl,Astrth points to start of array)
  3838 BF16 A5 1D			LDA	Dimcnt			; get dimensions count
  3839 BF18 A0 04			LDY	#$04			; set index to array's # of dimensions
  3840 BF1A D1 6A			CMP	(Astrtl),Y		; compare with no of dimensions
  3841 BF1C D0 E7			BNE	LAB_1E85		; if wrong do array bounds error, could do 'Wrong
  3842 									; dimensions' error here .. if we want a different
  3843 									; error message
  3844
  3845 BF1E 4C A4 BF			JMP	LAB_1F28		; found array so go get element
  3846 									; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3847 									; Dimcnt and save it at (Astrtl),Y which is already the
  3848 									; same or we would have taken the BNE)
  3849
  3850 									; array not found, so build it
  3851 BF21			LAB_1EA1
  3852 BF21 20 6A BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3853 									; (Astrtl,Astrth points to start of array)
  3854 BF24 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3855 									; addr to check is in AY (low/high)
  3856 BF27 A0 00			LDY	#$00			; clear Y (don't need to clear A)
  3857 BF29 84 7B			STY	Aspth			; clear array data size high byte
  3858 BF2B A5 53			LDA	Varnm1			; get variable name 1st byte
  3859 BF2D 91 6A			STA	(Astrtl),Y		; save array name 1st byte
  3860 BF2F C8				INY				; increment index
  3861 BF30 A5 54			LDA	Varnm2			; get variable name 2nd byte
  3862 BF32 91 6A			STA	(Astrtl),Y		; save array name 2nd byte
  3863 BF34 A5 1D			LDA	Dimcnt			; get dimensions count
  3864 BF36 A0 04			LDY	#$04			; index to dimension count
  3865 BF38 84 7A			STY	Asptl			; set array data size low byte (four bytes per element)
  3866 BF3A 91 6A			STA	(Astrtl),Y		; set array's dimensions count
  3867
  3868 									; now calculate the size of the data space for the array
  3869 BF3C 18				CLC				; clear carry for add (clear on subsequent loops)
  3870 BF3D			LAB_1EC0
  3871 BF3D A2 0B			LDX	#$0B			; set default dimension value low byte
  3872 BF3F A9 00			LDA	#$00			; set default dimension value high byte
  3873 BF41 24 1E			BIT	Defdim			; test default DIM flag
  3874 BF43 50 07			BVC	LAB_1ED0		; branch if b6 of Defdim is clear
  3875
  3876 BF45 68				PLA				; else pull dimension value low byte
  3877 BF46 69 01			ADC	#$01			; +1 (allow for zeroeth element)
  3878 BF48 AA				TAX				; copy low byte to X
  3879 BF49 68				PLA				; pull dimension value high byte
  3880 BF4A 69 00			ADC	#$00			; add carry from low byte
  3881
  3882 BF4C			LAB_1ED0
  3883 BF4C C8				INY				; index to dimension value high byte
  3884 BF4D 91 6A			STA	(Astrtl),Y		; save dimension value high byte
  3885 BF4F C8				INY				; index to dimension value high byte
  3886 BF50 8A				TXA				; get dimension value low byte
  3887 BF51 91 6A			STA	(Astrtl),Y		; save dimension value low byte
  3888 BF53 20 F3 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3889 BF56 86 7A			STX	Asptl			; save array data size low byte
  3890 BF58 85 7B			STA	Aspth			; save array data size high byte
  3891 BF5A A4 31			LDY	ut1_pl			; restore index (saved by subroutine)
  3892 BF5C C6 1D			DEC	Dimcnt			; decrement dimensions count
  3893 BF5E D0 DD			BNE	LAB_1EC0		; loop while not = 0
  3894
  3895 BF60 65 65			ADC	Adatah			; add size high byte to first element high byte
  3896 									; (carry is always clear here)
  3897 BF62 B0 5D			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3898
  3899 BF64 85 65			STA	Adatah			; save end of array high byte
  3900 BF66 A8				TAY				; copy end high byte to Y
  3901 BF67 8A				TXA				; get array size low byte
  3902 BF68 65 64			ADC	Adatal			; add array start low byte
  3903 BF6A 90 03			BCC	LAB_1EF3		; branch if no carry
  3904
  3905 BF6C C8				INY				; else increment end of array high byte
  3906 BF6D F0 52			BEQ	LAB_1F45		; if overflow go do 'Out of memory' error
  3907
  3908 									; set-up mostly complete, now zero the array
  3909 BF6F			LAB_1EF3
  3910 BF6F 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3911 									; addr to check is in AY (low/high)
  3912 BF72 85 3F			STA	Earryl			; save array mem end low byte
  3913 BF74 84 40			STY	Earryh			; save array mem end high byte
  3914 BF76 A9 00			LDA	#$00			; clear byte for array clear
  3915 BF78 E6 7B			INC	Aspth			; increment array size high byte (now block count)
  3916 BF7A A4 7A			LDY	Asptl			; get array size low byte (now index to block)
  3917 BF7C F0 05			BEQ	LAB_1F07		; branch if low byte = $00
  3918
  3919 BF7E			LAB_1F02
  3920 BF7E 88				DEY				; decrement index (do 0 to n-1)
  3921 BF7F 91 64			STA	(Adatal),Y		; zero byte
  3922 BF81 D0 FB			BNE	LAB_1F02		; loop until this block done
  3923
  3924 BF83			LAB_1F07
  3925 BF83 C6 65			DEC	Adatah			; decrement array pointer high byte
  3926 BF85 C6 7B			DEC	Aspth			; decrement block count high byte
  3927 BF87 D0 F5			BNE	LAB_1F02		; loop until all blocks done
  3928
  3929 BF89 E6 65			INC	Adatah			; correct for last loop
  3930 BF8B 38				SEC				; set carry for subtract
  3931 BF8C A0 02			LDY	#$02			; index to array size low byte
  3932 BF8E A5 3F			LDA	Earryl			; get array mem end low byte
  3933 BF90 E5 6A			SBC	Astrtl			; subtract array start low byte
  3934 BF92 91 6A			STA	(Astrtl),Y		; save array size low byte
  3935 BF94 C8				INY				; index to array size high byte
  3936 BF95 A5 40			LDA	Earryh			; get array mem end high byte
  3937 BF97 E5 6B			SBC	Astrth			; subtract array start high byte
  3938 BF99 91 6A			STA	(Astrtl),Y		; save array size high byte
  3939 BF9B A5 1E			LDA	Defdim			; get default DIM flag
  3940 BF9D D0 53			BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  3941
  3942 									; else, find element
  3943 BF9F C8				INY				; index to # of dimensions
  3944
  3945 BFA0			LAB_1F24
  3946 BFA0 B1 6A			LDA	(Astrtl),Y		; get array's dimension count
  3947 BFA2 85 1D			STA	Dimcnt			; save it
  3948
  3949 				; we have found, or built, the array. now we need to find the element
  3950 BFA4			LAB_1F28
  3951 BFA4 A9 00			LDA	#$00			; clear byte
  3952 BFA6 85 7A			STA	Asptl			; clear array data pointer low byte
  3953 BFA8			LAB_1F2C
  3954 BFA8 85 7B			STA	Aspth			; save array data pointer high byte
  3955 BFAA C8				INY				; increment index (point to array bound high byte)
  3956 BFAB 68				PLA				; pull array index low byte
  3957 BFAC AA				TAX				; copy to X
  3958 BFAD 85 6E			STA	FAC1_2			; save index low byte to FAC1 mantissa2
  3959 BFAF 68				PLA				; pull array index high byte
  3960 BFB0 85 6F			STA	FAC1_3			; save index high byte to FAC1 mantissa3
  3961 BFB2 D1 6A			CMP	(Astrtl),Y		; compare with array bound high byte
  3962 BFB4 90 0E			BCC	LAB_1F48		; branch if within bounds
  3963
  3964 BFB6 D0 06			BNE	LAB_1F42		; if outside bounds do array bounds error
  3965
  3966 									; else high byte was = so test low bytes
  3967 BFB8 C8				INY				; index to array bound low byte
  3968 BFB9 8A				TXA				; get array index low byte
  3969 BFBA D1 6A			CMP	(Astrtl),Y		; compare with array bound low byte
  3970 BFBC 90 07			BCC	LAB_1F49		; branch if within bounds
  3971
  3972 BFBE			LAB_1F42
  3973 BFBE 4C 05 BF			JMP	LAB_1E85		; else do array bounds error
  3974
  3975 BFC1			LAB_1F45
  3976 BFC1 4C 09 B1			JMP	LAB_OMER		; do 'Out of memory' error then warm start
  3977
  3978 BFC4			LAB_1F48
  3979 BFC4 C8				INY				; index to array bound low byte
  3980 BFC5			LAB_1F49
  3981 BFC5 A5 7B			LDA	Aspth			; get array data pointer high byte
  3982 BFC7 05 7A			ORA	Asptl			; OR with array data pointer low byte
  3983 BFC9 F0 0A			BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  3984
  3985 BFCB 20 F3 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3986 BFCE 8A				TXA				; get result low byte
  3987 BFCF 65 6E			ADC	FAC1_2			; add index low byte from FAC1 mantissa2
  3988 BFD1 AA				TAX				; save result low byte
  3989 BFD2 98				TYA				; get result high byte
  3990 BFD3 A4 31			LDY	ut1_pl			; restore index
  3991 BFD5			LAB_1F5A
  3992 BFD5 65 6F			ADC	FAC1_3			; add index high byte from FAC1 mantissa3
  3993 BFD7 86 7A			STX	Asptl			; save array data pointer low byte
  3994 BFD9 C6 1D			DEC	Dimcnt			; decrement dimensions count
  3995 BFDB D0 CB			BNE	LAB_1F2C		; loop if dimensions still to do
  3996
  3997 BFDD 06 7A			ASL	Asptl			; array data pointer low byte * 2
  3998 BFDF 2A				ROL				; array data pointer high byte * 2
  3999 BFE0 06 7A			ASL	Asptl			; array data pointer low byte * 4
  4000 BFE2 2A				ROL				; array data pointer high byte * 4
  4001 BFE3 A8				TAY				; copy high byte
  4002 BFE4 A5 7A			LDA	Asptl			; get low byte
  4003 BFE6 65 64			ADC	Adatal			; add array data start pointer low byte
  4004 BFE8 85 55			STA	Cvaral			; save as current var address low byte
  4005 BFEA 98				TYA				; get high byte back
  4006 BFEB 65 65			ADC	Adatah			; add array data start pointer high byte
  4007 BFED 85 56			STA	Cvarah			; save as current var address high byte
  4008 BFEF A8				TAY				; copy high byte to Y
  4009 BFF0 A5 55			LDA	Cvaral			; get current var address low byte
  4010 BFF2			LAB_1F7B
  4011 BFF2 60				RTS
  4012
  4013 				; does XY = (Astrtl),Y * (Asptl)
  4014 BFF3			LAB_1F7C
  4015 BFF3 84 31			STY	ut1_pl			; save index
  4016 BFF5 B1 6A			LDA	(Astrtl),Y		; get dimension size low byte
  4017 BFF7 85 36			STA	dims_l			; save dimension size low byte
  4018 BFF9 88				DEY				; decrement index
  4019 BFFA B1 6A			LDA	(Astrtl),Y		; get dimension size high byte
  4020 BFFC 85 37			STA	dims_h			; save dimension size high byte
  4021
  4022 BFFE A9 10			LDA	#$10			; count = $10 (16 bit multiply)
  4023 C000 85 68			STA	numbit			; save bit count
  4024 C002 A2 00			LDX	#$00			; clear result low byte
  4025 C004 A0 00			LDY	#$00			; clear result high byte
  4026 C006			LAB_1F8F
  4027 C006 8A				TXA				; get result low byte
  4028 C007 0A				ASL				; *2
  4029 C008 AA				TAX				; save result low byte
  4030 C009 98				TYA				; get result high byte
  4031 C00A 2A				ROL				; *2
  4032 C00B A8				TAY				; save result high byte
  4033 C00C B0 B3			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4034
  4035 C00E 06 7A			ASL	Asptl			; shift multiplier low byte
  4036 C010 26 7B			ROL	Aspth			; shift multiplier high byte
  4037 C012 90 0B			BCC	LAB_1FA8		; skip add if no carry
  4038
  4039 C014 18				CLC				; else clear carry for add
  4040 C015 8A				TXA				; get result low byte
  4041 C016 65 36			ADC	dims_l			; add dimension size low byte
  4042 C018 AA				TAX				; save result low byte
  4043 C019 98				TYA				; get result high byte
  4044 C01A 65 37			ADC	dims_h			; add dimension size high byte
  4045 C01C A8				TAY				; save result high byte
  4046 C01D B0 A2			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4047
  4048 C01F			LAB_1FA8
  4049 C01F C6 68			DEC	numbit			; decrement bit count
  4050 C021 D0 E3			BNE	LAB_1F8F		; loop until all done
  4051
  4052 C023 60				RTS
  4053
  4054 				; perform FRE()
  4055 C024			LAB_FRE
  4056 C024 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  4057 C026 10 03			BPL	LAB_1FB4		; branch if numeric
  4058
  4059 C028 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  4060 									; space returns with A = length, X=$71=pointer low byte,
  4061 									; Y=$72=pointer high byte
  4062
  4063 									; FRE(n) was numeric so do this
  4064 C02B			LAB_1FB4
  4065 C02B 20 CC C1			JSR	LAB_GARB		; go do garbage collection
  4066 C02E 38				SEC				; set carry for subtract
  4067 C02F A5 41			LDA	Sstorl			; get bottom of string space low byte
  4068 C031 E5 3F			SBC	Earryl			; subtract array mem end low byte
  4069 C033 A8				TAY				; copy result to Y
  4070 C034 A5 42			LDA	Sstorh			; get bottom of string space high byte
  4071 C036 E5 40			SBC	Earryh			; subtract array mem end high byte
  4072
  4073 				; save and convert unsigned integer AY to FAC1
  4074 C038			LAB_UAYFC
  4075 C038 46 1F			LSR	Dtypef            	; clear data type flag, $FF=string, $00=numeric
  4076 C03A 85 6D			STA	FAC1_1            	; save FAC1 mantissa1
  4077 C03C 84 6E			STY	FAC1_2            	; save FAC1 mantissa2
  4078 C03E A2 90			LDX	#$90              	; set exponent=2^16 (integer)
  4079 C040 38				SEC                     	; always positive
  4080 C041 4C F4 C8			JMP	LAB_STFA          	; set exp=X, clear FAC1_3, normalise and return 
  4081 				      
  4082 				; save and convert integer AY to FAC1
  4083 C044			LAB_AYFC
  4084 C044 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  4085 C046 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  4086 C048 84 6E			STY	FAC1_2			; save FAC1 mantissa2
  4087 C04A A2 90			LDX	#$90			; set exponent=2^16 (integer)
  4088 C04C 4C EF C8			JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
  4089
  4090 				; perform POS()
  4091 C04F			LAB_POS
  4092 C04F A4 0E			LDY	TPos			; get terminal position
  4093
  4094 				; convert Y to byte in FAC1
  4095 C051			LAB_1FD0
  4096 C051 A9 00			LDA	#$00			; clear high byte
  4097 C053 F0 EF			BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  4098
  4099 				; check not Direct (used by DEF and INPUT)
  4100 C055			LAB_CKRN
  4101 C055 A6 48			LDX	Clineh			; get current line high byte
  4102 C057 E8				INX				; increment it
  4103 C058 D0 98			BNE	LAB_1F7B		; return if can continue not direct mode
  4104
  4105 									; else do illegal direct error
  4106 C05A			LAB_1FD9
  4107 C05A A2 16			LDX	#$16			; error code $16 ('Illegal direct' error)
  4108 C05C			LAB_1FDB
  4109 C05C 4C 0B B1			JMP	LAB_XERR		; go do error #X, then warm start
  4110
  4111 				; perform DEF
  4112 C05F			LAB_DEF
  4113 C05F 20 90 C0			JSR	LAB_200B		; check FNx syntax
  4114 C062 85 5C			STA	func_l			; save function pointer low byte
  4115 C064 84 5D			STY	func_h			; save function pointer high byte
  4116 C066 20 55 C0			JSR	LAB_CKRN		; check not Direct (back here if ok)
  4117 C069 20 D7 BB			JSR	LAB_1BFE		; scan for '(' , else do syntax error then warm start
  4118 C06C A9 80			LDA	#$80			; set flag for FNx
  4119 C06E 85 21			STA	Sufnxf			; save subscript/FNx flag
  4120 C070 20 89 BD			JSR	LAB_GVAR		; get (var) address
  4121 C073 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4122 C076 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4123 C079 A9 D7			LDA	#TK_EQUAL		; get = token
  4124 C07B 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  4125 C07E A5 56			LDA	Cvarah			; get current var address high byte
  4126 C080 48				PHA				; push it
  4127 C081 A5 55			LDA	Cvaral			; get current var address low byte
  4128 C083 48				PHA				; push it
  4129 C084 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4130 C086 48				PHA				; push it
  4131 C087 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4132 C089 48				PHA				; push it
  4133 C08A 20 67 B6			JSR	LAB_DATA		; go perform DATA
  4134 C08D 4C FF C0			JMP	LAB_207A		; put execute pointer and variable pointer into function
  4135 									; and return
  4136
  4137 				; check FNx syntax
  4138 C090			LAB_200B
  4139 C090 A9 C3			LDA	#TK_FN			; get FN' token
  4140 C092 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  4141 									; return character after A
  4142 C095 09 80			ORA	#$80			; set FN flag bit
  4143 C097 85 21			STA	Sufnxf			; save FN flag so array variable test fails
  4144 C099 20 90 BD			JSR	LAB_1D12		; search for FN variable
  4145 C09C 4C AD BA			JMP	LAB_CTNM		; check if source is numeric and return, else do type
  4146 									; mismatch
  4147 									; Evaluate FNx
  4148 C09F			LAB_201E
  4149 C09F 20 90 C0			JSR	LAB_200B		; check FNx syntax
  4150 C0A2 48				PHA				; push function pointer low byte
  4151 C0A3 98				TYA				; copy function pointer high byte
  4152 C0A4 48				PHA				; push function pointer high byte
  4153 C0A5 20 D7 BB			JSR	LAB_1BFE		; scan for '(', else do syntax error then warm start
  4154 C0A8 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  4155 C0AB 20 CC BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4156 C0AE 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4157 C0B1 68				PLA				; pop function pointer high byte
  4158 C0B2 85 5D			STA	func_h			; restore it
  4159 C0B4 68				PLA				; pop function pointer low byte
  4160 C0B5 85 5C			STA	func_l			; restore it
  4161 C0B7 A2 20			LDX	#$20			; error code $20 ('Undefined function' error)
  4162 C0B9 A0 03			LDY	#$03			; index to variable pointer high byte
  4163 C0BB B1 5C			LDA	(func_l),Y		; get variable pointer high byte
  4164 C0BD F0 9D			BEQ	LAB_1FDB		; if zero go do undefined function error
  4165
  4166 C0BF 85 56			STA	Cvarah			; save variable address high byte
  4167 C0C1 88				DEY				; index to variable address low byte
  4168 C0C2 B1 5C			LDA	(func_l),Y		; get variable address low byte
  4169 C0C4 85 55			STA	Cvaral			; save variable address low byte
  4170 C0C6 AA				TAX				; copy address low byte
  4171 									; now stack the function variable value before use
  4172 C0C7 C8				INY				; index to mantissa_3
  4173 C0C8			LAB_2043
  4174 C0C8 B1 55			LDA	(Cvaral),Y		; get byte from variable
  4175 C0CA 48				PHA				; stack it
  4176 C0CB 88				DEY				; decrement index
  4177 C0CC 10 FA			BPL	LAB_2043		; loop until variable stacked
  4178
  4179 C0CE A4 56			LDY	Cvarah			; get variable address high byte
  4180 C0D0 20 94 C8			JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  4181 									; (function variable), return Y=0, always
  4182 C0D3 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4183 C0D5 48				PHA				; push it
  4184 C0D6 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4185 C0D8 48				PHA				; push it
  4186 C0D9 B1 5C			LDA	(func_l),Y		; get function execute pointer low byte
  4187 C0DB 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  4188 C0DD C8				INY				; index to high byte
  4189 C0DE B1 5C			LDA	(func_l),Y		; get function execute pointer high byte
  4190 C0E0 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4191 C0E2 A5 56			LDA	Cvarah			; get variable address high byte
  4192 C0E4 48				PHA				; push it
  4193 C0E5 A5 55			LDA	Cvaral			; get variable address low byte
  4194 C0E7 48				PHA				; push it
  4195 C0E8 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4196 									; else do type mismatch
  4197 C0EB 68				PLA				; pull variable address low byte
  4198 C0EC 85 5C			STA	func_l			; save variable address low byte
  4199 C0EE 68				PLA				; pull variable address high byte
  4200 C0EF 85 5D			STA	func_h			; save variable address high byte
  4201 C0F1 20 82 00			JSR	LAB_GBYT		; scan memory
  4202 C0F4 F0 03			BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  4203
  4204 C0F6 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  4205
  4206 				; restore Bpntrl,Bpntrh and function variable from stack
  4207 C0F9			LAB_2074
  4208 C0F9 68				PLA				; pull BASIC execute pointer low byte
  4209 C0FA 85 83			STA	Bpntrl			; restore BASIC execute pointer low byte
  4210 C0FC 68				PLA				; pull BASIC execute pointer high byte
  4211 C0FD 85 84			STA	Bpntrh			; restore BASIC execute pointer high byte
  4212
  4213 				; put execute pointer and variable pointer into function
  4214 C0FF			LAB_207A
  4215 C0FF A0 00			LDY	#$00			; clear index
  4216 C101 68				PLA				; pull BASIC execute pointer low byte
  4217 C102 91 5C			STA	(func_l),Y		; save to function
  4218 C104 C8				INY				; increment index
  4219 C105 68				PLA				; pull BASIC execute pointer high byte
  4220 C106 91 5C			STA	(func_l),Y		; save to function
  4221 C108 C8				INY				; increment index
  4222 C109 68				PLA				; pull current var address low byte
  4223 C10A 91 5C			STA	(func_l),Y		; save to function
  4224 C10C C8				INY				; increment index
  4225 C10D 68				PLA				; pull current var address high byte
  4226 C10E 91 5C			STA	(func_l),Y		; save to function
  4227 C110 60				RTS
  4228
  4229 				; perform STR$()
  4230 C111			LAB_STRS
  4231 C111 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4232 C114 20 82 CA			JSR	LAB_296E		; convert FAC1 to string
  4233 C117 A9 9E			LDA	#<Decssp1		; set result string low pointer
  4234 C119 A0 00			LDY	#>Decssp1		; set result string high pointer
  4235 C11B F0 12			BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
  4236
  4237 				; Do string vector
  4238 				; copy des_pl/h to des_2l/h and make string space A bytes long
  4239 C11D			LAB_209C
  4240 C11D A6 6E			LDX	des_pl			; get descriptor pointer low byte
  4241 C11F A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4242 C121 86 5E			STX	des_2l			; save descriptor pointer low byte
  4243 C123 84 5F			STY	des_2h			; save descriptor pointer high byte
  4244
  4245 				; make string space A bytes long
  4246 				; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4247 C125			LAB_MSSP
  4248 C125 20 9A C1			JSR	LAB_2115		; make space in string memory for string A long
  4249 									; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4250 C128 86 6D			STX	str_pl			; save string pointer low byte
  4251 C12A 84 6E			STY	str_ph			; save string pointer high byte
  4252 C12C 85 6C			STA	str_ln			; save length
  4253 C12E 60				RTS
  4254
  4255 				; Scan, set up string
  4256 				; print ' terminated string to Sutill/Sutilh
  4257 C12F			LAB_20AE
  4258 C12F A2 22			LDX	#$22			; set terminator to '
  4259 C131 86 1B			STX	Srchc			; set search character (terminator 1)
  4260 C133 86 1C			STX	Asrch			; set terminator 2
  4261
  4262 				; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4263 				; source is AY
  4264 C135			LAB_20B4
  4265 C135 85 78			STA	ssptr_l			; store string start low byte
  4266 C137 84 79			STY	ssptr_h			; store string start high byte
  4267 C139 85 6D			STA	str_pl			; save string pointer low byte
  4268 C13B 84 6E			STY	str_ph			; save string pointer high byte
  4269 C13D A0 FF			LDY	#$FF			; set length to -1
  4270 C13F			LAB_20BE
  4271 C13F C8				INY				; increment length
  4272 C140 B1 78			LDA	(ssptr_l),Y		; get byte from string
  4273 C142 F0 0C			BEQ	LAB_20CF		; exit loop if null byte [EOS]
  4274
  4275 C144 C5 1B			CMP	Srchc			; compare with search character (terminator 1)
  4276 C146 F0 04			BEQ	LAB_20CB		; branch if terminator
  4277
  4278 C148 C5 1C			CMP	Asrch			; compare with terminator 2
  4279 C14A D0 F3			BNE	LAB_20BE		; loop if not terminator 2
  4280
  4281 C14C			LAB_20CB
  4282 C14C C9 22			CMP	#$22			; compare with '
  4283 C14E F0 01			BEQ	LAB_20D0		; branch if ' (carry set if = !)
  4284
  4285 C150			LAB_20CF
  4286 C150 18				CLC				; clear carry for add (only if [EOL] terminated string)
  4287 C151			LAB_20D0
  4288 C151 84 6C			STY	str_ln			; save length in FAC1 exponent
  4289 C153 98				TYA				; copy length to A
  4290 C154 65 78			ADC	ssptr_l			; add string start low byte
  4291 C156 85 7A			STA	Sendl			; save string end low byte
  4292 C158 A6 79			LDX	ssptr_h			; get string start high byte
  4293 C15A 90 01			BCC	LAB_20DC		; branch if no low byte overflow
  4294
  4295 C15C E8				INX				; else increment high byte
  4296 C15D			LAB_20DC				; RAM above code / Ibuff above EhBASIC patch V2
  4297 C15D 86 7B			STX	Sendh			; save string end high byte
  4298 C15F A5 79			LDA	ssptr_h			; get string start high byte
  4299 C161 F0 04			BEQ   	LAB_MVST          	; fix STR$() using page zero via LAB_296E
  4300 					
  4301 C163 C9 18			CMP   	#>Ibuffs          	; compare with location of input buffer page
  4302 C165 D0 0B			BNE   	LAB_RTST          	; branch if not in utility area
  4303 C167			LAB_MVST 
  4304 									; string in utility area, move to string memory
  4305 C167 98				TYA				; copy length to A
  4306 C168 20 1D C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4307 									; long
  4308 C16B A6 78			LDX	ssptr_l			; get string start low byte
  4309 C16D A4 79			LDY	ssptr_h			; get string start high byte
  4310 C16F 20 0C C3			JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
  4311
  4312 				; check for space on descriptor stack then ..
  4313 				; put string address and length on descriptor stack and update stack pointers
  4314 C172			LAB_RTST
  4315 C172 A6 25			LDX	next_s			; get string stack pointer
  4316 C174 E0 31			CPX	#des_sk+$09		; compare with max+1
  4317 C176 D0 05			BNE	LAB_20F8		; branch if space on string stack
  4318
  4319 									; else do string too complex error
  4320 C178 A2 1C			LDX	#$1C			; error code $1C ('String too complex' error)
  4321 C17A			LAB_20F5
  4322 C17A 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4323
  4324 				; put string address and length on descriptor stack and update stack pointers
  4325 C17D			LAB_20F8
  4326 C17D A5 6C			LDA	str_ln			; get string length
  4327 C17F 95 00			STA	PLUS_0,X		; put on string stack
  4328 C181 A5 6D			LDA	str_pl			; get string pointer low byte
  4329 C183 95 01			STA	PLUS_1,X		; put on string stack
  4330 C185 A5 6E			LDA	str_ph			; get string pointer high byte
  4331 C187 95 02			STA	PLUS_2,X		; put on string stack
  4332 C189 A0 00			LDY	#$00			; clear Y
  4333 C18B 86 6E			STX	des_pl			; save string descriptor pointer low byte
  4334 C18D 84 6F			STY	des_ph			; save string descriptor pointer high byte (always $00)
  4335 C18F 88				DEY				; Y = $FF
  4336 C190 84 1F			STY	Dtypef			; save data type flag, $FF=string
  4337 C192 86 26			STX	last_sl			; save old stack pointer (current top item)
  4338 C194 E8				INX				; update stack pointer
  4339 C195 E8				INX				; update stack pointer
  4340 C196 E8				INX				; update stack pointer
  4341 C197 86 25			STX	next_s			; save new top item value
  4342 C199 60				RTS
  4343
  4344 				; Build descriptor
  4345 				; make space in string memory for string A long
  4346 				; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4347 C19A			LAB_2115
  4348 C19A 46 20			LSR	Gclctd			; clear garbage collected flag (b7)
  4349 									; make space for string A long
  4350 C19C			LAB_2117
  4351 C19C 48				PHA				; save string length
  4352 C19D 49 FF			EOR	#$FF			; complement it
  4353 C19F 38				SEC				; set carry for subtract (twos comp add)
  4354 C1A0 65 41			ADC	Sstorl			; add bottom of string space low byte (subtract length)
  4355 C1A2 A4 42			LDY	Sstorh			; get bottom of string space high byte
  4356 C1A4 B0 01			BCS	LAB_2122		; skip decrement if no underflow
  4357
  4358 C1A6 88				DEY				; decrement bottom of string space high byte
  4359 C1A7			LAB_2122
  4360 C1A7 C4 40			CPY	Earryh			; compare with array mem end high byte
  4361 C1A9 90 11			BCC	LAB_2137		; do out of memory error if less
  4362
  4363 C1AB D0 04			BNE	LAB_212C		; if not = skip next test
  4364
  4365 C1AD C5 3F			CMP	Earryl			; compare with array mem end low byte
  4366 C1AF 90 0B			BCC	LAB_2137		; do out of memory error if less
  4367
  4368 C1B1			LAB_212C
  4369 C1B1 85 41			STA	Sstorl			; save bottom of string space low byte
  4370 C1B3 84 42			STY	Sstorh			; save bottom of string space high byte
  4371 C1B5 85 43			STA	Sutill			; save string utility ptr low byte
  4372 C1B7 84 44			STY	Sutilh			; save string utility ptr high byte
  4373 C1B9 AA				TAX				; copy low byte to X
  4374 C1BA 68				PLA				; get string length back
  4375 C1BB 60				RTS
  4376
  4377 C1BC			LAB_2137
  4378 C1BC A2 0C			LDX	#$0C			; error code $0C ('Out of memory' error)
  4379 C1BE A5 20			LDA	Gclctd			; get garbage collected flag
  4380 C1C0 30 B8			BMI	LAB_20F5		; if set then do error code X
  4381
  4382 C1C2 20 CC C1			JSR	LAB_GARB		; else go do garbage collection
  4383 C1C5 A9 80			LDA	#$80			; flag for garbage collected
  4384 C1C7 85 20			STA	Gclctd			; set garbage collected flag
  4385 C1C9 68				PLA				; pull length
  4386 C1CA D0 D0			BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4387
  4388 				; garbage collection routine
  4389 C1CC			LAB_GARB
  4390 C1CC A6 45			LDX	Ememl			; get end of mem low byte
  4391 C1CE A5 46			LDA	Ememh			; get end of mem high byte
  4392
  4393 				; re-run routine from last ending
  4394 C1D0			LAB_214B
  4395 C1D0 86 41			STX	Sstorl			; set string storage low byte
  4396 C1D2 85 42			STA	Sstorh			; set string storage high byte
  4397 C1D4 A0 00			LDY	#$00			; clear index
  4398 C1D6 84 5D			STY	garb_h			; clear working pointer high byte (flag no strings to move)
  4399 C1D8 A5 3F			LDA	Earryl			; get array mem end low byte
  4400 C1DA A6 40			LDX	Earryh			; get array mem end high byte
  4401 C1DC 85 6A			STA	Histrl			; save as highest string low byte
  4402 C1DE 86 6B			STX	Histrh			; save as highest string high byte
  4403 C1E0 A9 28			LDA	#des_sk			; set descriptor stack pointer
  4404 C1E2 85 31			STA	ut1_pl			; save descriptor stack pointer low byte
  4405 C1E4 84 32			STY	ut1_ph			; save descriptor stack pointer high byte ($00)
  4406 C1E6			LAB_2161
  4407 C1E6 C5 25			CMP	next_s			; compare with descriptor stack pointer
  4408 C1E8 F0 05			BEQ	LAB_216A		; branch if =
  4409
  4410 C1EA 20 50 C2			JSR	LAB_21D7		; go garbage collect descriptor stack
  4411 C1ED F0 F7			BEQ	LAB_2161		; loop always
  4412
  4413 									; done stacked strings, now do string vars
  4414 C1EF			LAB_216A
  4415 C1EF 06 60			ASL	g_step			; set step size = $06
  4416 C1F1 A5 3B			LDA	Svarl			; get start of vars low byte
  4417 C1F3 A6 3C			LDX	Svarh			; get start of vars high byte
  4418 C1F5 85 31			STA	ut1_pl			; save as pointer low byte
  4419 C1F7 86 32			STX	ut1_ph			; save as pointer high byte
  4420 C1F9			LAB_2176
  4421 C1F9 E4 3E			CPX	Sarryh			; compare start of arrays high byte
  4422 C1FB D0 04			BNE	LAB_217E		; branch if no high byte match
  4423
  4424 C1FD C5 3D			CMP	Sarryl			; else compare start of arrays low byte
  4425 C1FF F0 05			BEQ	LAB_2183		; branch if = var mem end
  4426
  4427 C201			LAB_217E
  4428 C201 20 4A C2			JSR	LAB_21D1		; go garbage collect strings
  4429 C204 F0 F3			BEQ	LAB_2176		; loop always
  4430
  4431 									; done string vars, now do string arrays
  4432 C206			LAB_2183
  4433 C206 85 64			STA	Nbendl			; save start of arrays low byte as working pointer
  4434 C208 86 65			STX	Nbendh			; save start of arrays high byte as working pointer
  4435 C20A A9 04			LDA	#$04			; set step size
  4436 C20C 85 60			STA	g_step			; save step size
  4437 C20E			LAB_218B
  4438 C20E A5 64			LDA	Nbendl			; get pointer low byte
  4439 C210 A6 65			LDX	Nbendh			; get pointer high byte
  4440 C212			LAB_218F
  4441 C212 E4 40			CPX	Earryh			; compare with array mem end high byte
  4442 C214 D0 04			BNE	LAB_219A		; branch if not at end
  4443
  4444 C216 C5 3F			CMP	Earryl			; else compare with array mem end low byte
  4445 C218 F0 75			BEQ	LAB_2216		; tidy up and exit if at end
  4446
  4447 C21A			LAB_219A
  4448 C21A 85 31			STA	ut1_pl			; save pointer low byte
  4449 C21C 86 32			STX	ut1_ph			; save pointer high byte
  4450 C21E A0 02			LDY	#$02			; set index
  4451 C220 B1 31			LDA	(ut1_pl),Y		; get array size low byte
  4452 C222 65 64			ADC	Nbendl			; add start of this array low byte
  4453 C224 85 64			STA	Nbendl			; save start of next array low byte
  4454 C226 C8				INY				; increment index
  4455 C227 B1 31			LDA	(ut1_pl),Y		; get array size high byte
  4456 C229 65 65			ADC	Nbendh			; add start of this array high byte
  4457 C22B 85 65			STA	Nbendh			; save start of next array high byte
  4458 C22D A0 01			LDY	#$01			; set index
  4459 C22F B1 31			LDA	(ut1_pl),Y		; get name second byte
  4460 C231 10 DB			BPL	LAB_218B		; skip if not string array
  4461
  4462 				; was string array so ..
  4463 C233 A0 04			LDY	#$04			; set index
  4464 C235 B1 31			LDA	(ut1_pl),Y		; get # of dimensions
  4465 C237 0A				ASL				; *2
  4466 C238 69 05			ADC	#$05			; +5 (array header size)
  4467 C23A 20 82 C2			JSR	LAB_2208		; go set up for first element
  4468 C23D			LAB_21C4
  4469 C23D E4 65			CPX	Nbendh			; compare with start of next array high byte
  4470 C23F D0 04			BNE	LAB_21CC		; branch if <> (go do this array)
  4471
  4472 C241 C5 64			CMP	Nbendl			; else compare element pointer low byte with next array
  4473 									; low byte
  4474 C243 F0 CD			BEQ	LAB_218F		; if equal then go do next array
  4475
  4476 C245			LAB_21CC
  4477 C245 20 50 C2			JSR	LAB_21D7		; go defrag array strings
  4478 C248 F0 F3			BEQ	LAB_21C4		; go do next array string (loop always)
  4479
  4480 				; defrag string variables
  4481 				; enter with XA = variable pointer
  4482 				; return with XA = next variable pointer
  4483 C24A			LAB_21D1
  4484 C24A C8				INY				; increment index (Y was $00)
  4485 C24B B1 31			LDA	(ut1_pl),Y		; get var name byte 2
  4486 C24D 10 30			BPL	LAB_2206		; if not string, step pointer to next var and return
  4487
  4488 C24F C8				INY				; else increment index
  4489 C250			LAB_21D7
  4490 C250 B1 31			LDA	(ut1_pl),Y		; get string length
  4491 C252 F0 2B			BEQ	LAB_2206		; if null, step pointer to next string and return
  4492
  4493 C254 C8				INY				; else increment index
  4494 C255 B1 31			LDA	(ut1_pl),Y		; get string pointer low byte
  4495 C257 AA				TAX				; copy to X
  4496 C258 C8				INY				; increment index
  4497 C259 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte
  4498 C25B C5 42			CMP	Sstorh			; compare bottom of string space high byte
  4499 C25D 90 06			BCC	LAB_21EC		; branch if less
  4500
  4501 C25F D0 1E			BNE	LAB_2206		; if greater, step pointer to next string and return
  4502
  4503 									; high bytes were = so compare low bytes
  4504 C261 E4 41			CPX	Sstorl			; compare bottom of string space low byte
  4505 C263 B0 1A			BCS	LAB_2206		; if >=, step pointer to next string and return
  4506
  4507 									; string pointer is < string storage pointer (pos in mem)
  4508 C265			LAB_21EC
  4509 C265 C5 6B			CMP	Histrh			; compare to highest string high byte
  4510 C267 90 17			BCC	LAB_2207		; if <, step pointer to next string and return
  4511
  4512 C269 D0 04			BNE	LAB_21F6		; if > update pointers, step to next and return
  4513
  4514 									; high bytes were = so compare low bytes
  4515 C26B E4 6A			CPX	Histrl			; compare to highest string low byte
  4516 C26D 90 11			BCC	LAB_2207		; if <, step pointer to next string and return
  4517
  4518 									; string is in string memory space
  4519 C26F			LAB_21F6
  4520 C26F 86 6A			STX	Histrl			; save as new highest string low byte
  4521 C271 85 6B			STA	Histrh			; save as new highest string high byte
  4522 C273 A5 31			LDA	ut1_pl			; get start of vars(descriptors) low byte
  4523 C275 A6 32			LDX	ut1_ph			; get start of vars(descriptors) high byte
  4524 C277 85 5C			STA	garb_l			; save as working pointer low byte
  4525 C279 86 5D			STX	garb_h			; save as working pointer high byte
  4526 C27B 88				DEY				; decrement index DIFFERS
  4527 C27C 88				DEY				; decrement index (should point to descriptor start)
  4528 C27D 84 62			STY	g_indx			; save index pointer
  4529
  4530 									; step pointer to next string
  4531 C27F			LAB_2206
  4532 C27F 18				CLC				; clear carry for add
  4533 C280			LAB_2207
  4534 C280 A5 60			LDA	g_step			; get step size
  4535 C282			LAB_2208
  4536 C282 65 31			ADC	ut1_pl			; add pointer low byte
  4537 C284 85 31			STA	ut1_pl			; save pointer low byte
  4538 C286 90 02			BCC	LAB_2211		; branch if no overflow
  4539
  4540 C288 E6 32			INC	ut1_ph			; else increment high byte
  4541 C28A			LAB_2211
  4542 C28A A6 32			LDX	ut1_ph			; get pointer high byte
  4543 C28C A0 00			LDY	#$00			; clear Y
  4544 C28E 60				RTS
  4545
  4546 				; search complete, now either exit or set-up and move string
  4547 C28F			LAB_2216
  4548 C28F C6 60			DEC	g_step			; decrement step size (now $03 for descriptor stack)
  4549 C291 A6 5D			LDX	garb_h			; get string to move high byte
  4550 C293 F0 F5			BEQ	LAB_2211		; exit if nothing to move
  4551
  4552 C295 A4 62			LDY	g_indx			; get index byte back (points to descriptor)
  4553 C297 18				CLC				; clear carry for add
  4554 C298 B1 5C			LDA	(garb_l),Y		; get string length
  4555 C29A 65 6A			ADC	Histrl			; add highest string low byte
  4556 C29C 85 66			STA	Obendl			; save old block end low pointer
  4557 C29E A5 6B			LDA	Histrh			; get highest string high byte
  4558 C2A0 69 00			ADC	#$00			; add any carry
  4559 C2A2 85 67			STA	Obendh			; save old block end high byte
  4560 C2A4 A5 41			LDA	Sstorl			; get bottom of string space low byte
  4561 C2A6 A6 42			LDX	Sstorh			; get bottom of string space high byte
  4562 C2A8 85 64			STA	Nbendl			; save new block end low byte
  4563 C2AA 86 65			STX	Nbendh			; save new block end high byte
  4564 C2AC 20 94 B0			JSR	LAB_11D6		; open up space in memory, don't set array end
  4565 C2AF A4 62			LDY	g_indx			; get index byte
  4566 C2B1 C8				INY				; point to descriptor low byte
  4567 C2B2 A5 64			LDA	Nbendl			; get string pointer low byte
  4568 C2B4 91 5C			STA	(garb_l),Y		; save new string pointer low byte
  4569 C2B6 AA				TAX				; copy string pointer low byte
  4570 C2B7 E6 65			INC	Nbendh			; correct high byte (move sets high byte -1)
  4571 C2B9 A5 65			LDA	Nbendh			; get new string pointer high byte
  4572 C2BB C8				INY				; point to descriptor high byte
  4573 C2BC 91 5C			STA	(garb_l),Y		; save new string pointer high byte
  4574 C2BE 4C D0 C1			JMP	LAB_214B		; re-run routine from last ending
  4575 									; (but don't collect this string)
  4576
  4577 				; concatenate
  4578 				; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4579 C2C1			LAB_224D
  4580 C2C1 A5 6F			LDA	des_ph			; get descriptor pointer high byte
  4581 C2C3 48				PHA				; put on stack
  4582 C2C4 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4583 C2C6 48				PHA				; put on stack
  4584 C2C7 20 AA BB			JSR	LAB_GVAL		; get value from line
  4585 C2CA 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4586 C2CD 68				PLA				; get descriptor pointer low byte back
  4587 C2CE 85 78			STA	ssptr_l			; set pointer low byte
  4588 C2D0 68				PLA				; get descriptor pointer high byte back
  4589 C2D1 85 79			STA	ssptr_h			; set pointer high byte
  4590 C2D3 A0 00			LDY	#$00			; clear index
  4591 C2D5 B1 78			LDA	(ssptr_l),Y		; get length_1 from descriptor
  4592 C2D7 18				CLC				; clear carry for add
  4593 C2D8 71 6E			ADC	(des_pl),Y		; add length_2
  4594 C2DA 90 05			BCC	LAB_226D		; branch if no overflow
  4595
  4596 C2DC A2 1A			LDX	#$1A			; else set error code $1A ('String too long' error)
  4597 C2DE 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4598
  4599 C2E1			LAB_226D
  4600 C2E1 20 1D C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4601 									; long
  4602 C2E4 20 FE C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  4603 C2E7 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4604 C2E9 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4605 C2EB 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4606 									; returns with A = length, ut1_pl = pointer low byte,
  4607 									; ut1_ph = pointer high byte
  4608 C2EE 20 10 C3			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4609 C2F1 A5 78			LDA	ssptr_l			;.set descriptor pointer low byte
  4610 C2F3 A4 79			LDY	ssptr_h			;.set descriptor pointer high byte
  4611 C2F5 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4612 									; returns with A = length, X=ut1_pl=pointer low byte,
  4613 									; Y=ut1_ph=pointer high byte
  4614 C2F8 20 72 C1			JSR	LAB_RTST		; check for space on descriptor stack then put string
  4615 									; address and length on descriptor stack and update stack
  4616 									; pointers
  4617 C2FB 4C D5 BA			JMP	LAB_1ADB		;.continue evaluation
  4618
  4619 				; copy string from descriptor (sdescr) to (Sutill)
  4620 C2FE			LAB_228A
  4621 C2FE A0 00			LDY	#$00			; clear index
  4622 C300 B1 78			LDA	(sdescr),Y		; get string length
  4623 C302 48				PHA				; save on stack
  4624 C303 C8				INY				; increment index
  4625 C304 B1 78			LDA	(sdescr),Y		; get source string pointer low byte
  4626 C306 AA				TAX				; copy to X
  4627 C307 C8				INY				; increment index
  4628 C308 B1 78			LDA	(sdescr),Y		; get source string pointer high byte
  4629 C30A A8				TAY				; copy to Y
  4630 C30B 68				PLA				; get length back
  4631
  4632 				; store string A bytes long from YX to (Sutill)
  4633 C30C			LAB_2298
  4634 C30C 86 31			STX	ut1_pl			; save source string pointer low byte
  4635 C30E 84 32			STY	ut1_ph			; save source string pointer high byte
  4636
  4637 				; store string A bytes long from (ut1_pl) to (Sutill)
  4638 C310			LAB_229C
  4639 C310 AA				TAX				; copy length to index (don't count with Y)
  4640 C311 F0 14			BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4641
  4642 C313 A0 00			LDY	#$00			; zero pointer (copy forward)
  4643 C315			LAB_22A0
  4644 C315 B1 31			LDA	(ut1_pl),Y		; get source byte
  4645 C317 91 43			STA	(Sutill),Y		; save destination byte
  4646
  4647 C319 C8				INY				; increment index
  4648 C31A CA				DEX				; decrement counter
  4649 C31B D0 F8			BNE	LAB_22A0		; loop while <> 0
  4650
  4651 C31D 98				TYA				; restore length from Y
  4652 C31E			LAB_22A9
  4653 C31E 18				CLC				; clear carry for add
  4654 C31F 65 43			ADC	Sutill			; add string utility ptr low byte
  4655 C321 85 43			STA	Sutill			; save string utility ptr low byte
  4656 C323 90 02			BCC	LAB_22B2		; branch if no carry
  4657
  4658 C325 E6 44			INC	Sutilh			; else increment string utility ptr high byte
  4659 C327			LAB_22B2
  4660 C327 60				RTS
  4661
  4662 				; evaluate string
  4663 C328			LAB_EVST
  4664 C328 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4665
  4666 				; pop string off descriptor stack, or from top of string space
  4667 				; returns with A = length, X=pointer low byte, Y=pointer high byte
  4668 C32B			LAB_22B6
  4669 C32B A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4670 C32D A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4671
  4672 				; pop (YA) descriptor off stack or from top of string space
  4673 				; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4674 C32F			LAB_22BA
  4675 C32F 85 31			STA	ut1_pl			; save descriptor pointer low byte
  4676 C331 84 32			STY	ut1_ph			; save descriptor pointer high byte
  4677 C333 20 60 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  4678 C336 08				PHP				; save status flags
  4679 C337 A0 00			LDY	#$00			; clear index
  4680 C339 B1 31			LDA	(ut1_pl),Y		; get length from string descriptor
  4681 C33B 48				PHA				; put on stack
  4682 C33C C8				INY				; increment index
  4683 C33D B1 31			LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
  4684 C33F AA				TAX				; copy to X
  4685 C340 C8				INY				; increment index
  4686 C341 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
  4687 C343 A8				TAY				; copy to Y
  4688 C344 68				PLA				; get string length back
  4689 C345 28				PLP				; restore status
  4690 C346 D0 13			BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
  4691
  4692 C348 C4 42			CPY	Sstorh			; compare bottom of string space high byte
  4693 C34A D0 0F			BNE	LAB_22E6		; branch if <>
  4694
  4695 C34C E4 41			CPX	Sstorl			; else compare bottom of string space low byte
  4696 C34E D0 0B			BNE	LAB_22E6		; branch if <>
  4697
  4698 C350 48				PHA				; save string length
  4699 C351 18				CLC				; clear carry for add
  4700 C352 65 41			ADC	Sstorl			; add bottom of string space low byte
  4701 C354 85 41			STA	Sstorl			; save bottom of string space low byte
  4702 C356 90 02			BCC	LAB_22E5		; skip increment if no overflow
  4703
  4704 C358 E6 42			INC	Sstorh			; increment bottom of string space high byte
  4705 C35A			LAB_22E5
  4706 C35A 68				PLA				; restore string length
  4707 C35B			LAB_22E6
  4708 C35B 86 31			STX	ut1_pl			; save string pointer low byte
  4709 C35D 84 32			STY	ut1_ph			; save string pointer high byte
  4710 C35F 60				RTS
  4711
  4712 				; clean descriptor stack, YA = pointer
  4713 				; checks if AY is on the descriptor stack, if so does a stack discard
  4714 C360			LAB_22EB
  4715 C360 C4 27			CPY	last_sh			; compare pointer high byte
  4716 C362 D0 0C			BNE	LAB_22FB		; exit if <>
  4717
  4718 C364 C5 26			CMP	last_sl			; compare pointer low byte
  4719 C366 D0 08			BNE	LAB_22FB		; exit if <>
  4720
  4721 C368 85 25			STA	next_s			; save descriptor stack pointer
  4722 C36A E9 03			SBC	#$03			; -3
  4723 C36C 85 26			STA	last_sl			; save low byte -3
  4724 C36E A0 00			LDY	#$00			; clear high byte
  4725 C370			LAB_22FB
  4726 C370 60				RTS
  4727
  4728 				; perform CHR$()
  4729 C371			LAB_CHRS
  4730 C371 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  4731 C374 8A				TXA				; copy to A
  4732 C375 48				PHA				; save character
  4733 C376 A9 01			LDA	#$01			; string is single byte
  4734 C378 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4735 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4736 C37B 68				PLA				; get character back
  4737 C37C A0 00			LDY	#$00			; clear index
  4738 C37E 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  4739 C380 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4740 									; address and length on descriptor stack and update stack
  4741 									; pointers
  4742
  4743 				; perform LEFT$()
  4744 C383			LAB_LEFT
  4745 C383 48				PHA				; push byte parameter
  4746 C384 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4747 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4748 C387 D1 5E			CMP	(des_2l),Y		; compare byte parameter with string length
  4749 C389 98				TYA				; clear A
  4750 C38A F0 09			BEQ	LAB_2316		; go do string copy (branch always)
  4751
  4752 				; perform RIGHT$()
  4753 C38C			LAB_RIGHT
  4754 C38C 48				PHA				; push byte parameter
  4755 C38D 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4756 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4757 C390 18				CLC				; clear carry for add-1
  4758 C391 F1 5E			SBC	(des_2l),Y		; subtract string length
  4759 C393 49 FF			EOR	#$FF			; invert it (A=LEN(expression$)-l)
  4760
  4761 C395			LAB_2316
  4762 C395 90 04			BCC	LAB_231C		; branch if string length > byte parameter
  4763
  4764 C397 B1 5E			LDA	(des_2l),Y		; else make parameter = length
  4765 C399 AA				TAX				; copy to byte parameter copy
  4766 C39A 98				TYA				; clear string start offset
  4767 C39B			LAB_231C
  4768 C39B 48				PHA				; save string start offset
  4769 C39C			LAB_231D
  4770 C39C 8A				TXA				; copy byte parameter (or string length if <)
  4771 C39D			LAB_231E
  4772 C39D 48				PHA				; save string length
  4773 C39E 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4774 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4775 C3A1 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4776 C3A3 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4777 C3A5 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4778 									; returns with A = length, X=ut1_pl=pointer low byte,
  4779 									; Y=ut1_ph=pointer high byte
  4780 C3A8 68				PLA				; get string length back
  4781 C3A9 A8				TAY				; copy length to Y
  4782 C3AA 68				PLA				; get string start offset back
  4783 C3AB 18				CLC				; clear carry for add
  4784 C3AC 65 31			ADC	ut1_pl			; add start offset to string start pointer low byte
  4785 C3AE 85 31			STA	ut1_pl			; save string start pointer low byte
  4786 C3B0 90 02			BCC	LAB_2335		; branch if no overflow
  4787
  4788 C3B2 E6 32			INC	ut1_ph			; else increment string start pointer high byte
  4789 C3B4			LAB_2335
  4790 C3B4 98				TYA				; copy length to A
  4791 C3B5 20 10 C3			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4792 C3B8 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4793 									; address and length on descriptor stack and update stack
  4794 									; pointers
  4795
  4796 				; perform MID$()
  4797 C3BB			LAB_MIDS
  4798 C3BB 48				PHA				; push byte parameter
  4799 C3BC A9 FF			LDA	#$FF			; set default length = 255
  4800 C3BE 85 6F			STA	mids_l			; save default length
  4801 C3C0 20 82 00			JSR	LAB_GBYT		; scan memory
  4802 C3C3 C9 29			CMP	#')'			; compare with ')'
  4803 C3C5 F0 06			BEQ	LAB_2358		; branch if = ')' (skip second byte get)
  4804
  4805 C3C7 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4806 C3CA 20 79 C4			JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
  4807 C3CD			LAB_2358
  4808 C3CD 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4809 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4810 C3D0 CA				DEX				; decrement start index
  4811 C3D1 8A				TXA				; copy to A
  4812 C3D2 48				PHA				; save string start offset
  4813 C3D3 18				CLC				; clear carry for sub-1
  4814 C3D4 A2 00			LDX	#$00			; clear output string length
  4815 C3D6 F1 5E			SBC	(des_2l),Y		; subtract string length
  4816 C3D8 B0 C2			BCS	LAB_231D		; if start>string length go do null string
  4817
  4818 C3DA 49 FF			EOR	#$FF			; complement -length
  4819 C3DC C5 6F			CMP	mids_l			; compare byte parameter
  4820 C3DE 90 BD			BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4821
  4822 C3E0 A5 6F			LDA	mids_l			; get length byte
  4823 C3E2 B0 B9			BCS	LAB_231E		; go do string copy (branch always)
  4824
  4825 				; pull string data and byte parameter from stack
  4826 				; return pointer in des_2l/h, byte in A (and X), Y=0
  4827 C3E4			LAB_236F
  4828 C3E4 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4829 C3E7 68				PLA				; pull return address low byte (return address)
  4830 C3E8 85 62			STA	Fnxjpl			; save functions jump vector low byte
  4831 C3EA 68				PLA				; pull return address high byte (return address)
  4832 C3EB 85 63			STA	Fnxjph			; save functions jump vector high byte
  4833 C3ED 68				PLA				; pull byte parameter
  4834 C3EE AA				TAX				; copy byte parameter to X
  4835 C3EF 68				PLA				; pull string pointer low byte
  4836 C3F0 85 5E			STA	des_2l			; save it
  4837 C3F2 68				PLA				; pull string pointer high byte
  4838 C3F3 85 5F			STA	des_2h			; save it
  4839 C3F5 A0 00			LDY	#$00			; clear index
  4840 C3F7 8A				TXA				; copy byte parameter
  4841 C3F8 F0 79			BEQ	LAB_23A8		; if null do function call error then warm start
  4842
  4843 C3FA E6 62			INC	Fnxjpl			; increment function jump vector low byte
  4844 									; (JSR pushes return addr-1. this is all very nice
  4845 									; but will go tits up if either call is on a page
  4846 									; boundary!)
  4847 C3FC 6C 62 00			JMP	(Fnxjpl)		; in effect, RTS
  4848
  4849 				; perform LCASE$()
  4850 C3FF			LAB_LCASE
  4851 C3FF 20 28 C3			JSR	LAB_EVST		; evaluate string
  4852 C402 85 6C			STA	str_ln			; set string length
  4853 C404 A8				TAY				; copy length to Y
  4854 C405 F0 38			BEQ	NoString		; branch if null string
  4855
  4856 C407 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4857 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4858 C40A 86 6D			STX	str_pl			; save string pointer low byte
  4859 C40C 84 6E			STY	str_ph			; save string pointer high byte
  4860 C40E A8				TAY				; get string length back
  4861
  4862 C40F			LC_loop
  4863 C40F 88				DEY				; decrement index
  4864 C410 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4865 C412 20 01 BE			JSR	LAB_1D82		; is character 'A' to 'Z'
  4866 C415 90 02			BCC	NoUcase			; branch if not upper case alpha
  4867
  4868 C417 09 20			ORA	#$20			; convert upper to lower case
  4869 C419			NoUcase
  4870 C419 91 43			STA	(Sutill),Y		; save byte back to string
  4871 C41B 98				TYA				; test index
  4872 C41C D0 F1			BNE	LC_loop			; loop if not all done
  4873
  4874 C41E F0 1F			BEQ	NoString		; tidy up and exit, branch always
  4875
  4876 				; perform UCASE$()
  4877 C420			LAB_UCASE
  4878 C420 20 28 C3			JSR	LAB_EVST		; evaluate string
  4879 C423 85 6C			STA	str_ln			; set string length
  4880 C425 A8				TAY				; copy length to Y
  4881 C426 F0 17			BEQ	NoString		; branch if null string
  4882
  4883 C428 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4884 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4885 C42B 86 6D			STX	str_pl			; save string pointer low byte
  4886 C42D 84 6E			STY	str_ph			; save string pointer high byte
  4887 C42F A8				TAY				; get string length back
  4888
  4889 C430			UC_loop
  4890 C430 88				DEY				; decrement index
  4891 C431 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4892 C433 20 FD BD			JSR	LAB_CASC		; is character 'a' to 'z' (or 'A' to 'Z')
  4893 C436 90 02			BCC	NoLcase			; branch if not alpha
  4894
  4895 C438 29 DF			AND	#$DF			; convert lower to upper case
  4896 C43A			NoLcase
  4897 C43A 91 43			STA	(Sutill),Y		; save byte back to string
  4898 C43C 98				TYA				; test index
  4899 C43D D0 F1			BNE	UC_loop			; loop if not all done
  4900
  4901 C43F			NoString
  4902 C43F 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4903 									; address and length on descriptor stack and update stack
  4904 									; pointers
  4905
  4906 				; perform SADD()
  4907 C442			LAB_SADD
  4908 C442 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4909 C445 20 89 BD			JSR	LAB_GVAR		; get var address
  4910
  4911 C448 20 CC BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4912 C44B 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4913
  4914 C44E A0 02			LDY	#$02			; index to string pointer high byte
  4915 C450 B1 55			LDA	(Cvaral),Y		; get string pointer high byte
  4916 C452 AA				TAX				; copy string pointer high byte to X
  4917 C453 88				DEY				; index to string pointer low byte
  4918 C454 B1 55			LDA	(Cvaral),Y		; get string pointer low byte
  4919 C456 A8				TAY				; copy string pointer low byte to Y
  4920 C457 8A				TXA				; copy string pointer high byte to A
  4921 C458 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  4922
  4923 				; perform LEN()
  4924 C45B			LAB_LENS
  4925 C45B 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4926 C45E 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4927
  4928 				; evaluate string, get length in Y
  4929 C461			LAB_ESGL
  4930 C461 20 28 C3			JSR	LAB_EVST		; evaluate string
  4931 C464 A8				TAY				; copy length to Y
  4932 C465 60				RTS
  4933
  4934 				; perform ASC()
  4935 C466			LAB_ASC
  4936 C466 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4937 C469 F0 08			BEQ	LAB_23A8		; if null do function call error then warm start
  4938
  4939 C46B A0 00			LDY	#$00			; set index to first character
  4940 C46D B1 31			LDA	(ut1_pl),Y		; get byte
  4941 C46F A8				TAY				; copy to Y
  4942 C470 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4943
  4944 				; do function call error then warm start
  4945 C473			LAB_23A8
  4946 C473 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  4947
  4948 				; scan and get byte parameter
  4949 C476			LAB_SGBY
  4950 C476 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4951
  4952 				; get byte parameter
  4953 C479			LAB_GTBY
  4954 C479 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4955 									; else do type mismatch
  4956
  4957 				; evaluate byte expression, result in X
  4958 C47C			LAB_EVBY
  4959 C47C 20 81 BE			JSR	LAB_EVPI		; evaluate integer expression (no check)
  4960
  4961 C47F A4 6E			LDY	FAC1_2			; get FAC1 mantissa2
  4962 C481 D0 F0			BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  4963
  4964 C483 A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  4965 C485 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4966
  4967 				; perform VAL()
  4968 C488			LAB_VAL
  4969 C488 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4970 C48B D0 03			BNE	LAB_23C5		; branch if not null string
  4971
  4972 									; string was null so set result = $00
  4973 C48D 4C 3D C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  4974
  4975 C490			LAB_23C5
  4976 C490 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  4977 C492 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  4978 C494 86 7A			STX	Btmpl			; save BASIC execute pointer low byte
  4979 C496 84 7B			STY	Btmph			; save BASIC execute pointer high byte
  4980 C498 A6 31			LDX	ut1_pl			; get string pointer low byte
  4981 C49A 86 83			STX	Bpntrl			; save as BASIC execute pointer low byte
  4982 C49C 18				CLC				; clear carry
  4983 C49D 65 31			ADC	ut1_pl			; add string length
  4984 C49F 85 33			STA	ut2_pl			; save string end low byte
  4985 C4A1 A5 32			LDA	ut1_ph			; get string pointer high byte
  4986 C4A3 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4987 C4A5 69 00			ADC	#$00			; add carry to high byte
  4988 C4A7 85 34			STA	ut2_ph			; save string end high byte
  4989 C4A9 A0 00			LDY	#$00			; set index to $00
  4990 C4AB B1 33			LDA	(ut2_pl),Y		; get string end +1 byte
  4991 C4AD 48				PHA				; push it
  4992 C4AE 98				TYA				; clear A
  4993 C4AF 91 33			STA	(ut2_pl),Y		; terminate string with $00
  4994 C4B1 20 82 00			JSR	LAB_GBYT		; scan memory
  4995 C4B4 20 93 C9			JSR	LAB_2887		; get FAC1 from string
  4996 C4B7 68				PLA				; restore string end +1 byte
  4997 C4B8 A0 00			LDY	#$00			; set index to zero
  4998 C4BA 91 33			STA	(ut2_pl),Y		; put string end byte back
  4999
  5000 				; restore BASIC execute pointer from temp (Btmpl/Btmph)
  5001 C4BC			LAB_23F3
  5002 C4BC A6 7A			LDX	Btmpl			; get BASIC execute pointer low byte back
  5003 C4BE A4 7B			LDY	Btmph			; get BASIC execute pointer high byte back
  5004 C4C0 86 83			STX	Bpntrl			; save BASIC execute pointer low byte
  5005 C4C2 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  5006 C4C4 60				RTS
  5007
  5008 				; get two parameters for POKE or WAIT
  5009 C4C5			LAB_GADB
  5010 C4C5 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5011 									; else do type mismatch
  5012 C4C8 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5013
  5014 				; scan for ',' and get byte, else do Syntax error then warm start
  5015 C4CB			LAB_SCGB
  5016 C4CB 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5017 C4CE A5 12			LDA	Itemph			; save temporary integer high byte
  5018 C4D0 48				PHA				; on stack
  5019 C4D1 A5 11			LDA	Itempl			; save temporary integer low byte
  5020 C4D3 48				PHA				; on stack
  5021 C4D4 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  5022 C4D7 68				PLA				; pull low byte
  5023 C4D8 85 11			STA	Itempl			; restore temporary integer low byte
  5024 C4DA 68				PLA				; pull high byte
  5025 C4DB 85 12			STA	Itemph			; restore temporary integer high byte
  5026 C4DD 60				RTS
  5027
  5028 				; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5029 				; -ve and converts it into a right truncated integer in Itempl and Itemph
  5030
  5031 				; save unsigned 16 bit integer part of FAC1 in temporary integer
  5032 C4DE			LAB_F2FX
  5033 C4DE A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5034 C4E0 C9 98			CMP	#$98			; compare with exponent = 2^24
  5035 C4E2 B0 8F			BCS	LAB_23A8		; if >= do function call error then warm start
  5036
  5037 C4E4			LAB_F2FU
  5038 C4E4 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5039 C4E7 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5040 C4E9 A4 6F			LDY	FAC1_3			; get FAC1 mantissa3
  5041 C4EB 84 11			STY	Itempl			; save temporary integer low byte
  5042 C4ED 85 12			STA	Itemph			; save temporary integer high byte
  5043 C4EF 60				RTS
  5044
  5045 				; perform PEEK()
  5046 C4F0			LAB_PEEK
  5047 C4F0 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5048 C4F3 A2 00			LDX	#$00			; clear index
  5049 C4F5 A1 11			LDA	(Itempl,X)		; get byte via temporary integer (addr)
  5050 C4F7 A8				TAY				; copy byte to Y
  5051 C4F8 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5052
  5053 				; perform POKE
  5054 C4FB			LAB_POKE
  5055 C4FB 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5056 C4FE 8A				TXA				; copy byte argument to A
  5057 C4FF A2 00			LDX	#$00			; clear index
  5058 C501 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  5059 C503 60				RTS
  5060
  5061 				; perform DEEK()
  5062 C504			LAB_DEEK
  5063 C504 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5064 C507 A2 00			LDX	#$00			; clear index
  5065 C509 A1 11			LDA	(Itempl,X)		; PEEK low byte
  5066 C50B A8				TAY				; copy to Y
  5067 C50C E6 11			INC	Itempl			; increment pointer low byte
  5068 C50E D0 02			BNE	Deekh			; skip high increment if no rollover
  5069
  5070 C510 E6 12			INC	Itemph			; increment pointer high byte
  5071 C512			Deekh
  5072 C512 A1 11			LDA	(Itempl,X)		; PEEK high byte
  5073 C514 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  5074
  5075 				; perform DOKE
  5076 C517			LAB_DOKE
  5077 C517 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5078 									; else do type mismatch
  5079 C51A 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5080
  5081 C51D 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  5082 C51F 85 58			STA	Frnxth			; save pointer high byte
  5083
  5084 C521 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5085 C524 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5086 									; else do type mismatch
  5087 C527 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5088
  5089 C52A 98				TYA				; copy value low byte (float to fixed returns word in AY)
  5090 C52B A2 00			LDX	#$00			; clear index
  5091 C52D 81 57			STA	(Frnxtl,X)		; POKE low byte
  5092 C52F E6 57			INC	Frnxtl			; increment pointer low byte
  5093 C531 D0 02			BNE	Dokeh			; skip high increment if no rollover
  5094
  5095 C533 E6 58			INC	Frnxth			; increment pointer high byte
  5096 C535			Dokeh
  5097 C535 A5 12			LDA	Itemph			; get value high byte
  5098 C537 81 57			STA	(Frnxtl,X)		; POKE high byte
  5099 C539 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5100
  5101 				; perform SWAP
  5102 C53C			LAB_SWAP
  5103 C53C 20 89 BD			JSR	LAB_GVAR		; get var1 address
  5104 C53F 85 57			STA	Lvarpl			; save var1 address low byte
  5105 C541 84 58			STY	Lvarph			; save var1 address high byte
  5106 C543 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  5107 C545 48				PHA				; save data type flag
  5108
  5109 C546 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5110 C549 20 89 BD			JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
  5111 C54C 68				PLA				; pull var1 data type flag
  5112 C54D 45 1F			EOR	Dtypef			; compare with var2 data type
  5113 C54F D0 10			BNE	SwapErr			; exit if not both the same type  (changed 2022/05/16 by Joerg Walke)
  5114
  5115 C551 A0 03			LDY	#$03			; four bytes to swap (either value or descriptor+1)
  5116 C553			SwapLp
  5117 C553 B1 57			LDA	(Lvarpl),Y		; get byte from var1
  5118 C555 AA				TAX				; save var1 byte
  5119 C556 B1 55			LDA	(Cvaral),Y		; get byte from var2
  5120 C558 91 57			STA	(Lvarpl),Y		; save byte to var1
  5121 C55A 8A				TXA				; restore var1 byte
  5122 C55B 91 55			STA	(Cvaral),Y		; save byte to var2
  5123 C55D 88				DEY				; decrement index
  5124 C55E 10 F3			BPL	SwapLp			; loop until done
  5125
  5126 C560 60				RTS
  5127
  5128 C561			SwapErr
  5129 C561 4C B9 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  5130
  5131 				; perform CALL
  5132 C564			LAB_CALL
  5133 C564 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5134 									; else do type mismatch
  5135 C567 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5136 C56A A9 C5			LDA	#>CallExit		; set return address high byte
  5137 C56C 48				PHA				; put on stack
  5138 C56D A9 72			LDA	#<CallExit-1		; set return address low byte
  5139 C56F 48				PHA				; put on stack
  5140 C570 6C 11 00			JMP	(Itempl)		; do indirect jump to user routine
  5141
  5142 				; if the called routine exits correctly then it will return to here. this will then get
  5143 				; the next byte for the interpreter and return
  5144
  5145 C573			CallExit
  5146 C573 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5147
  5148 				; perform WAIT
  5149 C576			LAB_WAIT
  5150 C576 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5151 C579 86 57			STX	Frnxtl			; save byte
  5152 C57B A2 00			LDX	#$00			; clear mask
  5153 C57D 20 82 00			JSR	LAB_GBYT		; scan memory
  5154 C580 F0 03			BEQ	LAB_2441		; skip if no third argument
  5155
  5156 C582 20 CB C4			JSR	LAB_SCGB		; scan for ',' and get byte, else SN error then warm start
  5157 C585			LAB_2441
  5158 C585 86 58			STX	Frnxth			; save EOR argument
  5159 C587			LAB_2445
  5160 C587 B1 11			LDA	(Itempl),Y		; get byte via temporary integer (addr)
  5161 C589 45 58			EOR	Frnxth			; EOR with second argument (mask)
  5162 C58B 25 57			AND	Frnxtl			; AND with first argument (byte)
  5163 C58D F0 F8			BEQ	LAB_2445		; loop if result is zero
  5164
  5165 C58F			LAB_244D
  5166 C58F 60				RTS
  5167
  5168 				; perform subtraction, FAC1 from (AY)
  5169 C590			LAB_2455
  5170 C590 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5171
  5172 				; perform subtraction, FAC1 from FAC2
  5173
  5174 C593			LAB_SUBTRACT
  5175 C593 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5176 C595 49 FF			EOR	#$FF			; complement it
  5177 C597 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5178 C599 45 77			EOR	FAC2_s			; EOR with FAC2 sign (b7)
  5179 C59B 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5180 C59D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5181 C59F 4C AE C5			JMP	LAB_ADD			; go add FAC2 to FAC1
  5182
  5183 				; perform addition
  5184 C5A2			LAB_2467
  5185 C5A2 20 C7 C6			JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  5186 C5A5 90 4D			BCC	LAB_24A8		;.go subtract mantissas
  5187
  5188 				; add 0.5 to FAC1
  5189 C5A7			LAB_244E
  5190 C5A7 A9 FE			LDA	#<LAB_2A96		; set 0.5 pointer low byte
  5191 C5A9 A0 D3			LDY	#>LAB_2A96		; set 0.5 pointer high byte
  5192
  5193 				; add (AY) to FAC1
  5194 C5AB			LAB_246C
  5195 C5AB 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5196
  5197 				; add FAC2 to FAC1
  5198 C5AE			LAB_ADD
  5199 C5AE D0 10			BNE	LAB_2474		; branch if FAC1 was not zero
  5200
  5201 				; copy FAC2 to FAC1
  5202 C5B0			LAB_279B
  5203 C5B0 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  5204
  5205 				; save FAC1 sign and copy ABS(FAC2) to FAC1
  5206 C5B2			LAB_279D
  5207 C5B2 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5208 C5B4 A2 04			LDX	#$04			; 4 bytes to copy
  5209 C5B6			LAB_27A1
  5210 C5B6 B5 72			LDA	FAC1_o,X		; get byte from FAC2,X
  5211 C5B8 95 6B			STA	FAC1_e-1,X		; save byte at FAC1,X
  5212 C5BA CA				DEX				; decrement count
  5213 C5BB D0 F9			BNE	LAB_27A1		; loop if not all done
  5214
  5215 C5BD 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5216 C5BF 60				RTS
  5217 									; FAC1 is non zero
  5218 C5C0			LAB_2474
  5219 C5C0 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5220 C5C2 86 63			STX	FAC2_r			; save as FAC2 rounding byte
  5221 C5C4 A2 73			LDX	#FAC2_e			; set index to FAC2 exponent addr
  5222 C5C6 A5 73			LDA	FAC2_e			; get FAC2 exponent
  5223 C5C8			LAB_247C
  5224 C5C8 A8				TAY				; copy exponent
  5225 C5C9 F0 C4			BEQ	LAB_244D		; exit if zero
  5226
  5227 C5CB 38				SEC				; set carry for subtract
  5228 C5CC E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5229 C5CE F0 24			BEQ	LAB_24A8		; branch if = (go add mantissa)
  5230
  5231 C5D0 90 12			BCC	LAB_2498		; branch if <
  5232
  5233 									; FAC2>FAC1
  5234 C5D2 84 6C			STY	FAC1_e			; save FAC1 exponent
  5235 C5D4 A4 77			LDY	FAC2_s			; get FAC2 sign (b7)
  5236 C5D6 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5237 C5D8 49 FF			EOR	#$FF			; complement A
  5238 C5DA 69 00			ADC	#$00			; +1 (twos complement, carry is set)
  5239 C5DC A0 00			LDY	#$00			; clear Y
  5240 C5DE 84 63			STY	FAC2_r			; clear FAC2 rounding byte
  5241 C5E0 A2 6C			LDX	#FAC1_e			; set index to FAC1 exponent addr
  5242 C5E2 D0 04			BNE	LAB_249C		; branch always
  5243
  5244 C5E4			LAB_2498
  5245 C5E4 A0 00			LDY	#$00			; clear Y
  5246 C5E6 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5247 C5E8			LAB_249C
  5248 C5E8 C9 F9			CMP	#$F9			; compare exponent diff with $F9
  5249 C5EA 30 B6			BMI	LAB_2467		; branch if range $79-$F8
  5250
  5251 C5EC A8				TAY				; copy exponent difference to Y
  5252 C5ED A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5253 C5EF 56 01			LSR	PLUS_1,X		; shift FAC? mantissa1
  5254 C5F1 20 DE C6			JSR	LAB_2592		; shift FACX Y times right
  5255
  5256 									; exponents are equal now do mantissa subtract
  5257 C5F4			LAB_24A8
  5258 C5F4 24 78			BIT	FAC_sc			; test sign compare (FAC1 EOR FAC2)
  5259 C5F6 10 4C			BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  5260
  5261 C5F8 A0 6C			LDY	#FAC1_e			; set index to FAC1 exponent addr
  5262 C5FA E0 73			CPX	#FAC2_e			; compare X to FAC2 exponent addr
  5263 C5FC F0 02			BEQ	LAB_24B4		; branch if =
  5264
  5265 C5FE A0 73			LDY	#FAC2_e			; else set index to FAC2 exponent addr
  5266
  5267 									; subtract smaller from bigger (take sign of bigger)
  5268 C600			LAB_24B4
  5269 C600 38				SEC				; set carry for subtract
  5270 C601 49 FF			EOR	#$FF			; ones complement A
  5271 C603 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5272 C605 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5273 C607 B9 03 00			LDA	PLUS_3,Y		; get FACY mantissa3
  5274 C60A F5 03			SBC	PLUS_3,X		; subtract FACX mantissa3
  5275 C60C 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5276 C60E B9 02 00			LDA	PLUS_2,Y		; get FACY mantissa2
  5277 C611 F5 02			SBC	PLUS_2,X		; subtract FACX mantissa2
  5278 C613 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5279 C615 B9 01 00			LDA	PLUS_1,Y		; get FACY mantissa1
  5280 C618 F5 01			SBC	PLUS_1,X		; subtract FACX mantissa1
  5281 C61A 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5282
  5283 				; do ABS and normalise FAC1
  5284 C61C			LAB_24D0
  5285 C61C B0 03			BCS	LAB_24D5		; branch if number is +ve
  5286
  5287 C61E 20 83 C6			JSR	LAB_2537		; negate FAC1
  5288
  5289 				; normalise FAC1
  5290 C621			LAB_24D5
  5291 C621 A0 00			LDY	#$00			; clear Y
  5292 C623 98				TYA				; clear A
  5293 C624 18				CLC				; clear carry for add
  5294 C625			LAB_24D9
  5295 C625 A6 6D			LDX	FAC1_1			; get FAC1 mantissa1
  5296 C627 D0 3E			BNE	LAB_251B		; if not zero normalise FAC1
  5297
  5298 C629 A6 6E			LDX	FAC1_2			; get FAC1 mantissa2
  5299 C62B 86 6D			STX	FAC1_1			; save FAC1 mantissa1
  5300 C62D A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  5301 C62F 86 6E			STX	FAC1_2			; save FAC1 mantissa2
  5302 C631 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5303 C633 86 6F			STX	FAC1_3			; save FAC1 mantissa3
  5304 C635 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5305 C637 69 08			ADC	#$08			; add x to exponent offset
  5306 C639 C9 18			CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5307 C63B D0 E8			BNE	LAB_24D9		; loop if not max
  5308
  5309 				; clear FAC1 exponent and sign
  5310 C63D			LAB_24F1
  5311 C63D A9 00			LDA	#$00			; clear A
  5312 C63F			LAB_24F3
  5313 C63F 85 6C			STA	FAC1_e			; set FAC1 exponent
  5314
  5315 				; save FAC1 sign
  5316 C641			LAB_24F5
  5317 C641 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5318 C643 60				RTS
  5319
  5320 				; add FAC2 mantissa to FAC1 mantissa
  5321 C644			LAB_24F8
  5322 C644 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5323 C646 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5324 C648 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5325 C64A 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5326 C64C 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5327 C64E A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5328 C650 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5329 C652 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5330 C654 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5331 C656 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5332 C658 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5333 C65A B0 1A			BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  5334
  5335 C65C 60				RTS				; else just exit
  5336
  5337 C65D			LAB_2511
  5338 C65D 69 01			ADC	#$01			; add 1 to exponent offset
  5339 C65F 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5340 C661 26 6F			ROL	FAC1_3			; shift FAC1 mantissa3
  5341 C663 26 6E			ROL	FAC1_2			; shift FAC1 mantissa2
  5342 C665 26 6D			ROL	FAC1_1			; shift FAC1 mantissa1
  5343
  5344 				; normalise FAC1
  5345 C667			LAB_251B
  5346 C667 10 F4			BPL	LAB_2511		; loop if not normalised
  5347
  5348 C669 38				SEC				; set carry for subtract
  5349 C66A E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5350 C66C B0 CF			BCS	LAB_24F1		; branch if underflow (set result = $0)
  5351
  5352 C66E 49 FF			EOR	#$FF			; complement exponent
  5353 C670 69 01			ADC	#$01			; +1 (twos complement)
  5354 C672 85 6C			STA	FAC1_e			; save FAC1 exponent
  5355 					
  5356 				; test and normalise FAC1 for C=0/1
  5357 C674			LAB_2528
  5358 C674 90 0C			BCC	LAB_2536		; exit if no overflow
  5359
  5360 				; normalise FAC1 for C=1
  5361 C676			LAB_252A
  5362 C676 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5363 C678 F0 36			BEQ	LAB_2564		; if zero do overflow error and warm start
  5364
  5365 C67A 66 6D			ROR	FAC1_1			; shift FAC1 mantissa1
  5366 C67C 66 6E			ROR	FAC1_2			; shift FAC1 mantissa2
  5367 C67E 66 6F			ROR	FAC1_3			; shift FAC1 mantissa3
  5368 C680 66 79			ROR	FAC1_r			; shift FAC1 rounding byte
  5369 C682			LAB_2536
  5370 C682 60				RTS
  5371
  5372 				; negate FAC1
  5373 C683			LAB_2537
  5374 C683 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5375 C685 49 FF			EOR	#$FF			; complement it
  5376 C687 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5377
  5378 				; twos complement FAC1 mantissa
  5379 C689			LAB_253D
  5380 C689 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5381 C68B 49 FF			EOR	#$FF			; complement it
  5382 C68D 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5383 C68F A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5384 C691 49 FF			EOR	#$FF			; complement it
  5385 C693 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5386 C695 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5387 C697 49 FF			EOR	#$FF			; complement it
  5388 C699 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5389 C69B A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5390 C69D 49 FF			EOR	#$FF			; complement it
  5391 C69F 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5392 C6A1 E6 79			INC	FAC1_r			; increment FAC1 rounding byte
  5393 C6A3 D0 0A			BNE	LAB_2563		; exit if no overflow
  5394
  5395 				; increment FAC1 mantissa
  5396 C6A5			LAB_2559
  5397 C6A5 E6 6F			INC	FAC1_3			; increment FAC1 mantissa3
  5398 C6A7 D0 06			BNE	LAB_2563		; finished if no rollover
  5399
  5400 C6A9 E6 6E			INC	FAC1_2			; increment FAC1 mantissa2
  5401 C6AB D0 02			BNE	LAB_2563		; finished if no rollover
  5402
  5403 C6AD E6 6D			INC	FAC1_1			; increment FAC1 mantissa1
  5404 C6AF			LAB_2563
  5405 C6AF 60				RTS
  5406
  5407 				; do overflow error (overflow exit)
  5408 C6B0			LAB_2564
  5409 C6B0 A2 0A			LDX	#$0A			; error code $0A ('Overflow' error)
  5410 C6B2 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5411
  5412 				; shift FCAtemp << A+8 times
  5413 C6B5			LAB_2569
  5414 C6B5 A2 34			LDX	#FACt_1-1		; set offset to FACtemp
  5415 C6B7			LAB_256B
  5416 C6B7 B4 03			LDY	PLUS_3,X		; get FACX mantissa3
  5417 C6B9 84 79			STY	FAC1_r			; save as FAC1 rounding byte
  5418 C6BB B4 02			LDY	PLUS_2,X		; get FACX mantissa2
  5419 C6BD 94 03			STY	PLUS_3,X		; save FACX mantissa3
  5420 C6BF B4 01			LDY	PLUS_1,X		; get FACX mantissa1
  5421 C6C1 94 02			STY	PLUS_2,X		; save FACX mantissa2
  5422 C6C3 A4 72			LDY	FAC1_o			; get FAC1 overflow byte
  5423 C6C5 94 01			STY	PLUS_1,X		; save FACX mantissa1
  5424
  5425 				; shift FACX -A times right (> 8 shifts)
  5426 C6C7			LAB_257B
  5427 C6C7 69 08			ADC	#$08			; add 8 to shift count
  5428 C6C9 30 EC			BMI	LAB_256B		; go do 8 shift if still -ve
  5429
  5430 C6CB F0 EA			BEQ	LAB_256B		; go do 8 shift if zero
  5431
  5432 C6CD E9 08			SBC	#$08			; else subtract 8 again
  5433 C6CF A8				TAY				; save count to Y
  5434 C6D0 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5435 C6D2 B0 12			BCS	LAB_259A		;.
  5436
  5437 C6D4			LAB_2588
  5438 C6D4 16 01			ASL	PLUS_1,X		; shift FACX mantissa1
  5439 C6D6 90 02			BCC	LAB_258E		; branch if +ve
  5440
  5441 C6D8 F6 01			INC	PLUS_1,X		; this sets b7 eventually
  5442 C6DA			LAB_258E
  5443 C6DA 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5444 C6DC 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5445
  5446 				; shift FACX Y times right
  5447 C6DE			LAB_2592
  5448 C6DE 76 02			ROR	PLUS_2,X		; shift FACX mantissa2
  5449 C6E0 76 03			ROR	PLUS_3,X		; shift FACX mantissa3
  5450 C6E2 6A				ROR				; shift FACX rounding byte
  5451 C6E3 C8				INY				; increment exponent diff
  5452 C6E4 D0 EE			BNE	LAB_2588		; branch if range adjust not complete
  5453
  5454 C6E6			LAB_259A
  5455 C6E6 18				CLC				; just clear it
  5456 C6E7 60				RTS
  5457
  5458 				; perform LOG()
  5459 C6E8			LAB_LOG
  5460 C6E8 20 D6 C8			JSR	LAB_27CA		; test sign and zero
  5461 C6EB F0 02			BEQ	LAB_25C4		; if zero do function call error then warm start
  5462
  5463 C6ED 10 03			BPL	LAB_25C7		; skip error if +ve
  5464
  5465 C6EF			LAB_25C4
  5466 C6EF 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start (-ve)
  5467
  5468 C6F2			LAB_25C7
  5469 C6F2 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5470 C6F4 E9 7F			SBC	#$7F			; normalise it
  5471 C6F6 48				PHA				; save it
  5472 C6F7 A9 80			LDA	#$80			; set exponent to zero
  5473 C6F9 85 6C			STA	FAC1_e			; save FAC1 exponent
  5474 C6FB A9 7E			LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5475 C6FD A0 D3			LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5476 C6FF 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5477 C702 A9 82			LDA	#<LAB_25B1		; set root2 pointer low byte
  5478 C704 A0 D3			LDY	#>LAB_25B1		; set root2 pointer high byte
  5479 C706 20 EE C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5480 C709 A9 F5			LDA	#<LAB_259C		; set 1 pointer low byte
  5481 C70B A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  5482 C70D 20 90 C5			JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5483 C710 A9 71			LDA	#<LAB_25A0		; set pointer low byte to counter
  5484 C712 A0 D3			LDY	#>LAB_25A0		; set pointer high byte to counter
  5485 C714 20 3E CC			JSR	LAB_2B6E		; ^2 then series evaluation
  5486 C717 A9 86			LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5487 C719 A0 D3			LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5488 C71B 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  5489 C71E 68				PLA				; restore FAC1 exponent
  5490 C71F 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  5491 C722 A9 8A			LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5492 C724 A0 D3			LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5493
  5494 				; do convert AY, FCA1*(AY)
  5495 C726			LAB_25FB
  5496 C726 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5497 C729			LAB_MULTIPLY
  5498 C729 F0 4C			BEQ	LAB_264C		; exit if zero
  5499
  5500 C72B 20 9E C7			JSR	LAB_2673		; test and adjust accumulators
  5501 C72E A9 00			LDA	#$00			; clear A
  5502 C730 85 35			STA	FACt_1			; clear temp mantissa1
  5503 C732 85 36			STA	FACt_2			; clear temp mantissa2
  5504 C734 85 37			STA	FACt_3			; clear temp mantissa3
  5505 C736 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5506 C738 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5507 C73B A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5508 C73D 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5509 C740 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5510 C742 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5511 C745 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5512 C747 20 52 C7			JSR	LAB_2627		; go do shift/add FAC2
  5513 C74A 4C 5B C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5514
  5515 C74D			LAB_2622
  5516 C74D D0 03			BNE	LAB_2627		; branch if byte <> zero
  5517
  5518 C74F 4C B5 C6			JMP	LAB_2569		; shift FCAtemp << A+8 times
  5519
  5520 									; else do shift and add
  5521 C752			LAB_2627
  5522 C752 4A				LSR				; shift byte
  5523 C753 09 80			ORA	#$80			; set top bit (mark for 8 times)
  5524 C755			LAB_262A
  5525 C755 A8				TAY				; copy result
  5526 C756 90 13			BCC	LAB_2640		; skip next if bit was zero
  5527
  5528 C758 18				CLC				; clear carry for add
  5529 C759 A5 37			LDA	FACt_3			; get temp mantissa3
  5530 C75B 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5531 C75D 85 37			STA	FACt_3			; save temp mantissa3
  5532 C75F A5 36			LDA	FACt_2			; get temp mantissa2
  5533 C761 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5534 C763 85 36			STA	FACt_2			; save temp mantissa2
  5535 C765 A5 35			LDA	FACt_1			; get temp mantissa1
  5536 C767 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5537 C769 85 35			STA	FACt_1			; save temp mantissa1
  5538 C76B			LAB_2640
  5539 C76B 66 35			ROR	FACt_1			; shift temp mantissa1
  5540 C76D 66 36			ROR	FACt_2			; shift temp mantissa2
  5541 C76F 66 37			ROR	FACt_3			; shift temp mantissa3
  5542 C771 66 79			ROR	FAC1_r			; shift temp rounding byte
  5543 C773 98				TYA				; get byte back
  5544 C774 4A				LSR				; shift byte
  5545 C775 D0 DE			BNE	LAB_262A		; loop if all bits not done
  5546
  5547 C777			LAB_264C
  5548 C777 60				RTS
  5549
  5550 				; unpack memory (AY) into FAC2
  5551 C778			LAB_264D
  5552 C778 85 31			STA	ut1_pl			; save pointer low byte
  5553 C77A 84 32			STY	ut1_ph			; save pointer high byte
  5554 C77C A0 03			LDY	#$03			; 4 bytes to get (0-3)
  5555 C77E B1 31			LDA	(ut1_pl),Y		; get mantissa3
  5556 C780 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5557 C782 88				DEY				; decrement index
  5558 C783 B1 31			LDA	(ut1_pl),Y		; get mantissa2
  5559 C785 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5560 C787 88				DEY				; decrement index
  5561 C788 B1 31			LDA	(ut1_pl),Y		; get mantissa1+sign
  5562 C78A 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  5563 C78C 45 70			EOR	FAC1_s			; EOR with FAC1 sign (b7)
  5564 C78E 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5565 C790 A5 77			LDA	FAC2_s			; recover FAC2 sign (b7)
  5566 C792 09 80			ORA	#$80			; set 1xxx xxx (set normal bit)
  5567 C794 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5568 C796 88				DEY				; decrement index
  5569 C797 B1 31			LDA	(ut1_pl),Y		; get exponent byte
  5570 C799 85 73			STA	FAC2_e			; save FAC2 exponent
  5571 C79B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5572 C79D 60				RTS
  5573
  5574 				; test and adjust accumulators
  5575 C79E			LAB_2673
  5576 C79E A5 73			LDA	FAC2_e			; get FAC2 exponent
  5577 C7A0			LAB_2675
  5578 C7A0 F0 1D			BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5579
  5580 C7A2 18				CLC				; clear carry for add
  5581 C7A3 65 6C			ADC	FAC1_e			; add FAC1 exponent
  5582 C7A5 90 04			BCC	LAB_2680		; branch if sum of exponents <$0100
  5583
  5584 C7A7 30 31			BMI	LAB_269B		; do overflow error
  5585
  5586 C7A9 18				CLC				; clear carry for the add
  5587 C7AA 2C				.byte	$2C			; makes next line BIT $1410
  5588 C7AB			LAB_2680
  5589 C7AB 10 12			BPL	LAB_2696		; if +ve go handle underflow
  5590
  5591 C7AD 69 80			ADC	#$80			; adjust exponent
  5592 C7AF 85 6C			STA	FAC1_e			; save FAC1 exponent
  5593 C7B1 D0 03			BNE	LAB_268B		; branch if not zero
  5594
  5595 C7B3 4C 41 C6			JMP	LAB_24F5		; save FAC1 sign and return
  5596
  5597 C7B6			LAB_268B
  5598 C7B6 A5 78			LDA	FAC_sc			; get sign compare (FAC1 EOR FAC2)
  5599 C7B8 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5600 C7BA			LAB_268F
  5601 C7BA 60				RTS
  5602
  5603 				; handle overflow and underflow
  5604 C7BB			LAB_2690
  5605 C7BB A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5606 C7BD 10 1B			BPL	LAB_269B		; do overflow error
  5607
  5608 									; handle underflow
  5609 C7BF			LAB_2696
  5610 C7BF 68				PLA				; pop return address low byte
  5611 C7C0 68				PLA				; pop return address high byte
  5612 C7C1 4C 3D C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5613
  5614 				; multiply by 10
  5615 C7C4			LAB_269E
  5616 C7C4 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5617 C7C7 AA				TAX				; copy exponent (set the flags)
  5618 C7C8 F0 F0			BEQ	LAB_268F		; exit if zero
  5619
  5620 C7CA 18				CLC				; clear carry for add
  5621 C7CB 69 02			ADC	#$02			; add two to exponent (*4)
  5622 C7CD B0 0B			BCS	LAB_269B		; do overflow error if > $FF
  5623
  5624 C7CF A2 00			LDX	#$00			; clear byte
  5625 C7D1 86 78			STX	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  5626 C7D3 20 C8 C5			JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5627 C7D6 E6 6C			INC	FAC1_e			; increment FAC1 exponent (*10)
  5628 C7D8 D0 E0			BNE	LAB_268F		; if non zero just do RTS
  5629
  5630 C7DA			LAB_269B
  5631 C7DA 4C B0 C6			JMP	LAB_2564		; do overflow error and warm start
  5632
  5633 				; divide by 10
  5634 C7DD			LAB_26B9
  5635 C7DD 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5636 C7E0 A9 06			LDA	#<LAB_26B5		; set pointer to 10d low addr
  5637 C7E2 A0 D4			LDY	#>LAB_26B5		; set pointer to 10d high addr
  5638 C7E4 A2 00			LDX	#$00			; clear sign
  5639
  5640 				; divide by (AY) (X=sign)
  5641 C7E6			LAB_26C2
  5642 C7E6 86 78			STX	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5643 C7E8 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5644 C7EB 4C F1 C7			JMP	LAB_DIVIDE		; do FAC2/FAC1
  5645
  5646 									; Perform divide-by
  5647 				; convert AY and do (AY)/FAC1
  5648 C7EE			LAB_26CA
  5649 C7EE 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5650
  5651 				; Perform divide-into
  5652 C7F1			LAB_DIVIDE
  5653 C7F1 F0 63			BEQ	LAB_2737		; if zero go do /0 error
  5654
  5655 C7F3 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5656 C7F6 A9 00			LDA	#$00			; clear A
  5657 C7F8 38				SEC				; set carry for subtract
  5658 C7F9 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent (2s complement)
  5659 C7FB 85 6C			STA	FAC1_e			; save FAC1 exponent
  5660 C7FD 20 9E C7			JSR	LAB_2673		; test and adjust accumulators
  5661 C800 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5662 C802 F0 D6			BEQ	LAB_269B		; if zero do overflow error
  5663
  5664 C804 A2 FF			LDX	#$FF			; set index for pre increment
  5665 C806 A9 01			LDA	#$01			; set bit to flag byte save
  5666 C808			LAB_26E4
  5667 C808 A4 74			LDY	FAC2_1			; get FAC2 mantissa1
  5668 C80A C4 6D			CPY	FAC1_1			; compare FAC1 mantissa1
  5669 C80C D0 0A			BNE	LAB_26F4		; branch if <>
  5670
  5671 C80E A4 75			LDY	FAC2_2			; get FAC2 mantissa2
  5672 C810 C4 6E			CPY	FAC1_2			; compare FAC1 mantissa2
  5673 C812 D0 04			BNE	LAB_26F4		; branch if <>
  5674
  5675 C814 A4 76			LDY	FAC2_3			; get FAC2 mantissa3
  5676 C816 C4 6F			CPY	FAC1_3			; compare FAC1 mantissa3
  5677 C818			LAB_26F4
  5678 C818 08				PHP				; save FAC2-FAC1 compare status
  5679 C819 2A				ROL				; shift the result byte
  5680 C81A 90 0E			BCC	LAB_2702		; if no carry skip the byte save
  5681
  5682 C81C A0 01			LDY	#$01			; set bit to flag byte save
  5683 C81E E8				INX				; else increment the index to FACt
  5684 C81F E0 02			CPX	#$02			; compare with the index to FACt_3
  5685 C821 30 04			BMI	LAB_2701		; if not last byte just go save it
  5686
  5687 C823 D0 28			BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5688 									; return
  5689
  5690 C825 A0 40			LDY	#$40			; set bit to flag byte save for the rounding byte
  5691 C827			LAB_2701
  5692 C827 95 35			STA	FACt_1,X		; write result byte to FACt_1 + index
  5693 C829 98				TYA				; copy the next save byte flag
  5694 C82A			LAB_2702
  5695 C82A 28				PLP				; restore FAC2-FAC1 compare status
  5696 C82B 90 14			BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5697
  5698 C82D A8				TAY				; save FAC2-FAC1 compare status
  5699 C82E A5 76			LDA	FAC2_3			; get FAC2 mantissa3
  5700 C830 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5701 C832 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5702 C834 A5 75			LDA	FAC2_2			; get FAC2 mantissa2
  5703 C836 E5 6E			SBC	FAC1_2			; subtract FAC1 mantissa2
  5704 C838 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5705 C83A A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  5706 C83C E5 6D			SBC	FAC1_1			; subtract FAC1 mantissa1
  5707 C83E 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5708 C840 98				TYA				; restore FAC2-FAC1 compare status
  5709
  5710 									; FAC2 = FAC2*2
  5711 C841			LAB_2704
  5712 C841 06 76			ASL	FAC2_3			; shift FAC2 mantissa3
  5713 C843 26 75			ROL	FAC2_2			; shift FAC2 mantissa2
  5714 C845 26 74			ROL	FAC2_1			; shift FAC2 mantissa1
  5715 C847 B0 CF			BCS	LAB_26F4		; loop with no compare
  5716
  5717 C849 30 BD			BMI	LAB_26E4		; loop with compare
  5718
  5719 C84B 10 CB			BPL	LAB_26F4		; loop always with no compare
  5720
  5721 				; do A<<6, save as FAC1 rounding byte, normalise and return
  5722 C84D			LAB_272B
  5723 C84D 4A				LSR				; shift b1 - b0 ..
  5724 C84E 6A				ROR				; ..
  5725 C84F 6A				ROR				; .. to b7 - b6
  5726 C850 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5727 C852 28				PLP				; dump FAC2-FAC1 compare status
  5728 C853 4C 5B C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5729
  5730 				; do 'Divide by zero' error
  5731 C856			LAB_2737
  5732 C856 A2 14			LDX	#$14			; error code $14 ('Divide by zero' error)
  5733 C858 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5734
  5735 				; copy temp to FAC1 and normalise
  5736 C85B			LAB_273C
  5737 C85B A5 35			LDA	FACt_1			; get temp mantissa1
  5738 C85D 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5739 C85F A5 36			LDA	FACt_2			; get temp mantissa2
  5740 C861 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5741 C863 A5 37			LDA	FACt_3			; get temp mantissa3
  5742 C865 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5743 C867 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  5744
  5745 				; unpack memory (AY) into FAC1
  5746 C86A			LAB_UFAC
  5747 C86A 85 31			STA	ut1_pl			; save pointer low byte
  5748 C86C 84 32			STY	ut1_ph			; save pointer high byte
  5749 C86E A0 03			LDY	#$03			; 4 bytes to do
  5750 C870 B1 31			LDA	(ut1_pl),Y		; get last byte
  5751 C872 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5752 C874 88				DEY				; decrement index
  5753 C875 B1 31			LDA	(ut1_pl),Y		; get last-1 byte
  5754 C877 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5755 C879 88				DEY				; decrement index
  5756 C87A B1 31			LDA	(ut1_pl),Y		; get second byte
  5757 C87C 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5758 C87E 09 80			ORA	#$80			; set 1xxx xxxx (add normal bit)
  5759 C880 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5760 C882 88				DEY				; decrement index
  5761 C883 B1 31			LDA	(ut1_pl),Y		; get first byte (exponent)
  5762 C885 85 6C			STA	FAC1_e			; save FAC1 exponent
  5763 C887 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5764 C889 60				RTS
  5765
  5766 				; pack FAC1 into Adatal
  5767 C88A			LAB_276E
  5768 C88A A2 64			LDX	#<Adatal		; set pointer low byte
  5769 C88C			LAB_2770
  5770 C88C A0 00			LDY	#>Adatal		; set pointer high byte
  5771 C88E F0 04			BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5772
  5773 				; pack FAC1 into (Lvarpl)
  5774 C890			LAB_PFAC
  5775 C890 A6 57			LDX	Lvarpl			; get destination pointer low byte
  5776 C892 A4 58			LDY	Lvarph			; get destination pointer high byte
  5777
  5778 				; pack FAC1 into (XY)
  5779 C894			LAB_2778
  5780 C894 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5781 C897 86 31			STX	ut1_pl			; save pointer low byte
  5782 C899 84 32			STY	ut1_ph			; save pointer high byte
  5783 C89B A0 03			LDY	#$03			; set index
  5784 C89D A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5785 C89F 91 31			STA	(ut1_pl),Y		; store in destination
  5786 C8A1 88				DEY				; decrement index
  5787 C8A2 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5788 C8A4 91 31			STA	(ut1_pl),Y		; store in destination
  5789 C8A6 88				DEY				; decrement index
  5790 C8A7 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5791 C8A9 09 7F			ORA	#$7F			; set bits x111 1111
  5792 C8AB 25 6D			AND	FAC1_1			; AND in FAC1 mantissa1
  5793 C8AD 91 31			STA	(ut1_pl),Y		; store in destination
  5794 C8AF 88				DEY				; decrement index
  5795 C8B0 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5796 C8B2 91 31			STA	(ut1_pl),Y		; store in destination
  5797 C8B4 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5798 C8B6 60				RTS
  5799
  5800 				; round and copy FAC1 to FAC2
  5801 C8B7			LAB_27AB
  5802 C8B7 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5803
  5804 				; copy FAC1 to FAC2
  5805 C8BA			LAB_27AE
  5806 C8BA A2 05			LDX	#$05			; 5 bytes to copy
  5807 C8BC			LAB_27B0
  5808 C8BC B5 6B			LDA	FAC1_e-1,X		; get byte from FAC1,X
  5809 C8BE 95 72			STA	FAC1_o,X		; save byte at FAC2,X
  5810 C8C0 CA				DEX				; decrement count
  5811 C8C1 D0 F9			BNE	LAB_27B0		; loop if not all done
  5812
  5813 C8C3 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5814 C8C5			LAB_27B9
  5815 C8C5 60				RTS
  5816
  5817 				; round FAC1
  5818 C8C6			LAB_27BA
  5819 C8C6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5820 C8C8 F0 FB			BEQ	LAB_27B9		; exit if zero
  5821
  5822 C8CA 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5823 C8CC 90 F7			BCC	LAB_27B9		; exit if no overflow
  5824
  5825 				; round FAC1 (no check)
  5826 C8CE			LAB_27C2
  5827 C8CE 20 A5 C6			JSR	LAB_2559		; increment FAC1 mantissa
  5828 C8D1 D0 F2			BNE	LAB_27B9		; branch if no overflow
  5829
  5830 C8D3 4C 76 C6			JMP	LAB_252A		; normalise FAC1 for C=1 and return
  5831
  5832 				; get FAC1 sign
  5833 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5834 C8D6			LAB_27CA
  5835 C8D6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5836 C8D8 F0 09			BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  5837
  5838 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5839 				; no = 0 check
  5840 C8DA			LAB_27CE
  5841 C8DA A5 70			LDA	FAC1_s			; else get FAC1 sign (b7)
  5842
  5843 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5844 				; no = 0 check, sign in A
  5845 C8DC			LAB_27D0
  5846 C8DC 2A				ROL				; move sign bit to carry
  5847 C8DD A9 FF			LDA	#$FF			; set byte for -ve result
  5848 C8DF B0 02			BCS	LAB_27D7		; return if sign was set (-ve)
  5849
  5850 C8E1 A9 01			LDA	#$01			; else set byte for +ve result
  5851 C8E3			LAB_27D7
  5852 C8E3 60				RTS
  5853
  5854 				; perform SGN()
  5855 C8E4			LAB_SGN
  5856 C8E4 20 D6 C8			JSR	LAB_27CA		; get FAC1 sign
  5857 									; return A=$FF/-ve A=$01/+ve
  5858 				; save A as integer byte
  5859 C8E7			LAB_27DB
  5860 C8E7 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5861 C8E9 A9 00			LDA	#$00			; clear A
  5862 C8EB 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5863 C8ED A2 88			LDX	#$88			; set exponent
  5864
  5865 				; set exp=X, clearFAC1 mantissa3 and normalise
  5866 C8EF			LAB_27E3
  5867 C8EF A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5868 C8F1 49 FF			EOR	#$FF			; complement it
  5869 C8F3 2A				ROL				; sign bit into carry
  5870
  5871 				; set exp=X, clearFAC1 mantissa3 and normalise
  5872 C8F4			LAB_STFA
  5873 C8F4 A9 00			LDA	#$00			; clear A
  5874 C8F6 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5875 C8F8 86 6C			STX	FAC1_e			; set FAC1 exponent
  5876 C8FA 85 79			STA	FAC1_r			; clear FAC1 rounding byte
  5877 C8FC 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  5878 C8FE 4C 1C C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5879
  5880 				; perform ABS()
  5881 C901			LAB_ABS
  5882 C901 46 70			LSR	FAC1_s			; clear FAC1 sign (put zero in b7)
  5883 C903 60				RTS
  5884
  5885 				; compare FAC1 with (AY)
  5886 				; returns A=$00 if FAC1 = (AY)
  5887 				; returns A=$01 if FAC1 > (AY)
  5888 				; returns A=$FF if FAC1 < (AY)
  5889 C904			LAB_27F8
  5890 C904 85 33			STA	ut2_pl			; save pointer low byte
  5891 C906			LAB_27FA
  5892 C906 84 34			STY	ut2_ph			; save pointer high byte
  5893 C908 A0 00			LDY	#$00			; clear index
  5894 C90A B1 33			LDA	(ut2_pl),Y		; get exponent
  5895 C90C C8				INY				; increment index
  5896 C90D AA				TAX				; copy (AY) exponent to X
  5897 C90E F0 C6			BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  5898 									; A=FF,C=1/-ve A=01,C=0/+ve
  5899
  5900 C910 B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5901 C912 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  5902 C914 30 C4			BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  5903 									; A=01,C=0/+ve and return
  5904
  5905 C916 E4 6C			CPX	FAC1_e			; compare (AY) exponent with FAC1 exponent
  5906 C918 D0 1A			BNE	LAB_2828		; branch if different
  5907
  5908 C91A B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5909 C91C 09 80			ORA	#$80			; normalise top bit
  5910 C91E C5 6D			CMP	FAC1_1			; compare with FAC1 mantissa1
  5911 C920 D0 12			BNE	LAB_2828		; branch if different
  5912
  5913 C922 C8				INY				; increment index
  5914 C923 B1 33			LDA	(ut2_pl),Y		; get mantissa2
  5915 C925 C5 6E			CMP	FAC1_2			; compare with FAC1 mantissa2
  5916 C927 D0 0B			BNE	LAB_2828		; branch if different
  5917
  5918 C929 C8				INY				; increment index
  5919 C92A A9 7F			LDA	#$7F			; set for 1/2 value rounding byte
  5920 C92C C5 79			CMP	FAC1_r			; compare with FAC1 rounding byte (set carry)
  5921 C92E B1 33			LDA	(ut2_pl),Y		; get mantissa3
  5922 C930 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5923 C932 F0 28			BEQ	LAB_2850		; exit if mantissa3 equal
  5924
  5925 				; gets here if number <> FAC1
  5926 C934			LAB_2828
  5927 C934 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5928 C936 90 02			BCC	LAB_282E		; branch if FAC1 > (AY)
  5929
  5930 C938 49 FF			EOR	#$FF			; else toggle FAC1 sign
  5931 C93A			LAB_282E
  5932 C93A 4C DC C8			JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  5933
  5934 				; convert FAC1 floating-to-fixed
  5935 C93D			LAB_2831
  5936 C93D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5937 C93F F0 4A			BEQ	LAB_287F		; if zero go clear FAC1 and return
  5938
  5939 C941 38				SEC				; set carry for subtract
  5940 C942 E9 98			SBC	#$98			; subtract maximum integer range exponent
  5941 C944 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  5942 C946 10 09			BPL	LAB_2845		; branch if FAC1 +ve
  5943
  5944 									; FAC1 was -ve
  5945 C948 AA				TAX				; copy subtracted exponent
  5946 C949 A9 FF			LDA	#$FF			; overflow for -ve number
  5947 C94B 85 72			STA	FAC1_o			; set FAC1 overflow byte
  5948 C94D 20 89 C6			JSR	LAB_253D		; twos complement FAC1 mantissa
  5949 C950 8A				TXA				; restore subtracted exponent
  5950 C951			LAB_2845
  5951 C951 A2 6C			LDX	#FAC1_e			; set index to FAC1
  5952 C953 C9 F9			CMP	#$F9			; compare exponent result
  5953 C955 10 06			BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  5954
  5955 C957 20 C7 C6			JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  5956 C95A 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5957 C95C			LAB_2850
  5958 C95C 60				RTS
  5959
  5960 				; shift FAC1 A times right
  5961 C95D			LAB_2851
  5962 C95D A8				TAY				; copy shift count
  5963 C95E A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5964 C960 29 80			AND	#$80			; mask sign bit only (x000 0000)
  5965 C962 46 6D			LSR	FAC1_1			; shift FAC1 mantissa1
  5966 C964 05 6D			ORA	FAC1_1			; OR sign in b7 FAC1 mantissa1
  5967 C966 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5968 C968 20 DE C6			JSR	LAB_2592		; shift FAC1 Y times right
  5969 C96B 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5970 C96D 60				RTS
  5971
  5972 				; perform INT()
  5973 C96E			LAB_INT
  5974 C96E A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5975 C970 C9 98			CMP	#$98			; compare with max int
  5976 C972 B0 1E			BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  5977
  5978 C974 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5979 C977 84 79			STY	FAC1_r			; save FAC1 rounding byte
  5980 C979 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5981 C97B 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5982 C97D 49 80			EOR	#$80			; toggle FAC1 sign
  5983 C97F 2A				ROL				; shift into carry
  5984 C980 A9 98			LDA	#$98			; set new exponent
  5985 C982 85 6C			STA	FAC1_e			; save FAC1 exponent
  5986 C984 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5987 C986 85 1B			STA	Temp3			; save for EXP() function
  5988 C988 4C 1C C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5989
  5990 				; clear FAC1 and return
  5991 C98B			LAB_287F
  5992 C98B 85 6D			STA	FAC1_1			; clear FAC1 mantissa1
  5993 C98D 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5994 C98F 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5995 C991 A8				TAY				; clear Y
  5996 C992			LAB_2886
  5997 C992 60				RTS
  5998
  5999 				; get FAC1 from string
  6000 				; this routine now handles hex and binary values from strings
  6001 				; starting with '$' and '%' respectively
  6002 C993			LAB_2887
  6003 C993 A0 00			LDY	#$00			; clear Y
  6004 C995 84 1F			STY	Dtypef			; clear data type flag, $FF=string, $00=numeric
  6005 C997 A2 09			LDX	#$09			; set index
  6006 C999			LAB_288B
  6007 C999 94 68			STY	numexp,X		; clear byte
  6008 C99B CA				DEX				; decrement index
  6009 C99C 10 FB			BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
  6010
  6011 C99E 90 7F			BCC	LAB_28FE		; branch if 1st character numeric
  6012
  6013 				; get FAC1 from string .. first character wasn't numeric
  6014 C9A0 C9 2D			CMP	#'-'			; else compare with '-'
  6015 C9A2 D0 04			BNE	LAB_289A		; branch if not '-'
  6016
  6017 C9A4 86 71			STX	negnum			; set flag for -ve number (X = $FF)
  6018 C9A6 F0 04			BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  6019
  6020 				; get FAC1 from string .. first character wasn't numeric or -
  6021 C9A8			LAB_289A
  6022 C9A8 C9 2B			CMP	#'+'			; else compare with '+'
  6023 C9AA D0 05			BNE	LAB_289D		; branch if not '+' (go check for hex/bin)
  6024
  6025 				; was '+' or '-' to start, so get next character
  6026 C9AC			LAB_289C
  6027 C9AC 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6028 C9AF 90 6E			BCC	LAB_28FE		; branch if numeric character
  6029
  6030 				; code here for hex and binary numbers
  6031 C9B1			LAB_289D
  6032 C9B1 C9 24			CMP	#'$'			; else compare with '$'
  6033 C9B3 D0 03			BNE	LAB_NHEX		; branch if not '$'
  6034
  6035 C9B5 4C 5D CE			JMP	LAB_CHEX		; branch if '$'
  6036
  6037 C9B8			LAB_NHEX
  6038 C9B8 C9 25			CMP	#'%'			; else compare with '%'
  6039 C9BA D0 08			BNE	LAB_28A3		; branch if not '%' (continue original code)
  6040
  6041 C9BC 4C 8B CE			JMP	LAB_CBIN		; branch if '%'
  6042
  6043 C9BF			LAB_289E
  6044 C9BF 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  6045 C9C2			LAB_28A1
  6046 C9C2 90 5B			BCC	LAB_28FE		; branch if numeric character
  6047
  6048 				; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6049 C9C4			LAB_28A3
  6050 C9C4 C9 2E			CMP	#'.'			; else compare with '.'
  6051 C9C6 F0 2E			BEQ	LAB_28D5		; branch if '.'
  6052
  6053 				; get FAC1 from string .. character wasn't numeric, -, + or .
  6054 C9C8 C9 45			CMP	#'E'			; else compare with 'E'
  6055 C9CA D0 30			BNE	LAB_28DB		; branch if not 'E'
  6056
  6057 									; was 'E' so evaluate exponential part
  6058 C9CC 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6059 C9CF 90 17			BCC	LAB_28C7		; branch if numeric character
  6060
  6061 C9D1 C9 CC			CMP	#TK_MINUS		; else compare with token for -
  6062 C9D3 F0 0E			BEQ	LAB_28C2		; branch if token for -
  6063
  6064 C9D5 C9 2D			CMP	#'-'			; else compare with '-'
  6065 C9D7 F0 0A			BEQ	LAB_28C2		; branch if '-'
  6066
  6067 C9D9 C9 CB			CMP	#TK_PLUS		; else compare with token for +
  6068 C9DB F0 08			BEQ	LAB_28C4		; branch if token for +
  6069
  6070 C9DD C9 2B			CMP	#'+'			; else compare with '+'
  6071 C9DF F0 04			BEQ	LAB_28C4		; branch if '+'
  6072
  6073 C9E1 D0 07			BNE	LAB_28C9		; branch always
  6074
  6075 C9E3			LAB_28C2
  6076 C9E3 66 6B			ROR	expneg			; set exponent -ve flag (C, which=1, into b7)
  6077 C9E5			LAB_28C4
  6078 C9E5 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6079 C9E8			LAB_28C7
  6080 C9E8 90 5B			BCC	LAB_2925		; branch if numeric character
  6081
  6082 C9EA			LAB_28C9
  6083 C9EA 24 6B			BIT	expneg			; test exponent -ve flag
  6084 C9EC 10 0E			BPL	LAB_28DB		; if +ve go evaluate exponent
  6085
  6086 									; else do exponent = -exponent 
  6087 C9EE A9 00			LDA	#$00			; clear result
  6088 C9F0 38				SEC				; set carry for subtract
  6089 C9F1 E5 69			SBC	expcnt			; subtract exponent byte
  6090 C9F3 4C FE C9			JMP	LAB_28DD		; go evaluate exponent
  6091
  6092 C9F6			LAB_28D5
  6093 C9F6 66 6A			ROR	numdpf			; set decimal point flag
  6094 C9F8 24 6A			BIT	numdpf			; test decimal point flag
  6095 C9FA 50 C3			BVC	LAB_289E		; branch if only one decimal point so far
  6096
  6097 									; evaluate exponent
  6098 C9FC			LAB_28DB
  6099 C9FC A5 69			LDA	expcnt			; get exponent count byte
  6100 C9FE			LAB_28DD
  6101 C9FE 38				SEC				; set carry for subtract
  6102 C9FF E5 68			SBC	numexp			; subtract numerator exponent
  6103 CA01 85 69			STA	expcnt			; save exponent count byte
  6104 CA03 F0 12			BEQ	LAB_28F6		; branch if no adjustment
  6105
  6106 CA05 10 09			BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
  6107
  6108 									; else go do FAC1/10^(0-expcnt)
  6109 CA07			LAB_28E6
  6110 CA07 20 DD C7			JSR	LAB_26B9		; divide by 10
  6111 CA0A E6 69			INC	expcnt			; increment exponent count byte
  6112 CA0C D0 F9			BNE	LAB_28E6		; loop until all done
  6113
  6114 CA0E F0 07			BEQ	LAB_28F6		; branch always
  6115
  6116 CA10			LAB_28EF
  6117 CA10 20 C4 C7			JSR	LAB_269E		; multiply by 10
  6118 CA13 C6 69			DEC	expcnt			; decrement exponent count byte
  6119 CA15 D0 F9			BNE	LAB_28EF		; loop until all done
  6120
  6121 CA17			LAB_28F6
  6122 CA17 A5 71			LDA	negnum			; get -ve flag
  6123 CA19 30 01			BMI	LAB_28FB		; if -ve do - FAC1 and return
  6124
  6125 CA1B 60				RTS
  6126
  6127 				; do - FAC1 and return
  6128 CA1C			LAB_28FB
  6129 CA1C 4C E1 CB			JMP	LAB_GTHAN		; do - FAC1 and return
  6130
  6131 				; do unsigned FAC1*10+number
  6132 CA1F			LAB_28FE
  6133 CA1F 48				PHA				; save character
  6134 CA20 24 6A			BIT	numdpf			; test decimal point flag
  6135 CA22 10 02			BPL	LAB_2905		; skip exponent increment if not set
  6136
  6137 CA24 E6 68			INC	numexp			; else increment number exponent
  6138 CA26			LAB_2905
  6139 CA26 20 C4 C7			JSR	LAB_269E		; multiply FAC1 by 10
  6140 CA29 68				PLA				; restore character
  6141 CA2A 29 0F			AND	#$0F			; convert to binary
  6142 CA2C 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6143 CA2F 4C BF C9			JMP	LAB_289E		; go do next character
  6144
  6145 				; evaluate new ASCII digit
  6146 CA32			LAB_2912
  6147 CA32 48				PHA				; save digit
  6148 CA33 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6149 CA36 68				PLA				; restore digit
  6150 CA37 20 E7 C8			JSR	LAB_27DB		; save A as integer byte
  6151 CA3A A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6152 CA3C 45 70			EOR	FAC1_s			; toggle with FAC1 sign (b7)
  6153 CA3E 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6154 CA40 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6155 CA42 4C AE C5			JMP	LAB_ADD			; add FAC2 to FAC1 and return
  6156
  6157 				; evaluate next character of exponential part of number
  6158 CA45			LAB_2925
  6159 CA45 A5 69			LDA	expcnt			; get exponent count byte
  6160 CA47 C9 0A			CMP	#$0A			; compare with 10 decimal
  6161 CA49 90 09			BCC	LAB_2934		; branch if less
  6162
  6163 CA4B A9 64			LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  6164 CA4D 24 6B			BIT	expneg			; test exponent -ve flag
  6165 CA4F 30 0E			BMI	LAB_2942		; branch if -ve
  6166
  6167 CA51 4C B0 C6			JMP	LAB_2564		; else do overflow error
  6168
  6169 CA54			LAB_2934
  6170 CA54 0A				ASL				; * 2
  6171 CA55 0A				ASL				; * 4
  6172 CA56 65 69			ADC	expcnt			; * 5
  6173 CA58 0A				ASL				; * 10
  6174 CA59 A0 00			LDY	#$00			; set index
  6175 CA5B 71 83			ADC	(Bpntrl),Y		; add character (will be $30 too much!)
  6176 CA5D E9 2F			SBC	#'0'-1			; convert character to binary
  6177 CA5F			LAB_2942
  6178 CA5F 85 69			STA	expcnt			; save exponent count byte
  6179 CA61 4C E5 C9			JMP	LAB_28C4		; go get next character
  6180
  6181 				; print ' in line [LINE #]'
  6182 CA64			LAB_2953
  6183 CA64 A9 23			LDA	#<LAB_LMSG		; point to ' in line ' message low byte
  6184 CA66 A0 DB			LDY	#>LAB_LMSG		; point to ' in line ' message high byte
  6185 CA68 20 B1 B8			JSR	LAB_18C3		; print null terminated string from memory
  6186
  6187 									; print Basic line #
  6188 CA6B A5 48			LDA	Clineh			; get current line high byte
  6189 CA6D A6 47			LDX	Clinel			; get current line low byte
  6190
  6191 				; print XA as unsigned integer
  6192 CA6F			LAB_295E
  6193 CA6F 85 6D			STA	FAC1_1			; save low byte as FAC1 mantissa1
  6194 CA71 86 6E			STX	FAC1_2			; save high byte as FAC1 mantissa2
  6195 CA73 A2 90			LDX	#$90			; set exponent to 16d bits
  6196 CA75 38				SEC				; set integer is +ve flag
  6197 CA76 20 F4 C8			JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  6198 CA79 A0 00			LDY	#$00			; clear index
  6199 CA7B 98				TYA				; clear A
  6200 CA7C 20 8F CA			JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  6201 CA7F 4C B1 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  6202
  6203 				; convert FAC1 to ASCII string result in (AY)
  6204 				; not any more, moved scratchpad to page 0
  6205 CA82			LAB_296E
  6206 CA82 A0 01			LDY	#$01			; set index = 1
  6207 CA84 A9 20			LDA	#$20			; character = ' ' (assume +ve)
  6208 CA86 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  6209 CA88 10 02			BPL	LAB_2978		; branch if +ve
  6210
  6211 CA8A A9 2D			LDA	#$2D			; else character = '-'
  6212 CA8C			LAB_2978
  6213 CA8C 99 9D 00			STA	Decss,Y			; save leading character (' ' or '-')
  6214 CA8F			LAB_297B
  6215 CA8F 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6216 CA91 84 7A			STY	Sendl			; save index
  6217 CA93 C8				INY				; increment index
  6218 CA94 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6219 CA96 D0 05			BNE	LAB_2989		; branch if FAC1<>0
  6220
  6221 									; exponent was $00 so FAC1 is 0
  6222 CA98 A9 30			LDA	#'0'			; set character = '0'
  6223 CA9A 4C 9B CB			JMP	LAB_2A89		; save last character, [EOT] and exit
  6224
  6225 									; FAC1 is some non zero value
  6226 CA9D			LAB_2989
  6227 CA9D A9 00			LDA	#$00			; clear (number exponent count)
  6228 CA9F E0 81			CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  6229
  6230 CAA1 B0 09			BCS	LAB_299A		; branch if FAC1=>1
  6231
  6232 									; FAC1<1
  6233 CAA3 A9 96			LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  6234 CAA5 A0 D3			LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  6235 CAA7 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6236 CAAA A9 FA			LDA	#$FA			; set number exponent count (-6)
  6237 CAAC			LAB_299A
  6238 CAAC 85 68			STA	numexp			; save number exponent count
  6239 CAAE			LAB_299C
  6240 CAAE A9 92			LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  6241 CAB0 A0 D3			LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  6242 CAB2 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6243 CAB5 F0 1E			BEQ	LAB_29C3		; exit if FAC1 = (AY)
  6244
  6245 CAB7 10 12			BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  6246
  6247 									; FAC1 < (AY)
  6248 CAB9			LAB_29A7
  6249 CAB9 A9 8E			LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  6250 CABB A0 D3			LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  6251 CABD 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6252 CAC0 F0 02			BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  6253
  6254 CAC2 10 0E			BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  6255
  6256 									; FAC1 <= (AY)
  6257 CAC4			LAB_29B2
  6258 CAC4 20 C4 C7			JSR	LAB_269E		; multiply by 10
  6259 CAC7 C6 68			DEC	numexp			; decrement number exponent count
  6260 CAC9 D0 EE			BNE	LAB_29A7		; go test again (branch always)
  6261
  6262 CACB			LAB_29B9
  6263 CACB 20 DD C7			JSR	LAB_26B9		; divide by 10
  6264 CACE E6 68			INC	numexp			; increment number exponent count
  6265 CAD0 D0 DC			BNE	LAB_299C		; go test again (branch always)
  6266
  6267 				; now we have just the digits to do
  6268 CAD2			LAB_29C0
  6269 CAD2 20 A7 C5			JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  6270 CAD5			LAB_29C3
  6271 CAD5 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6272 CAD8 A2 01			LDX	#$01			; set default digits before dp = 1
  6273 CADA A5 68			LDA	numexp			; get number exponent count
  6274 CADC 18				CLC				; clear carry for add
  6275 CADD 69 07			ADC	#$07			; up to 6 digits before point
  6276 CADF 30 09			BMI	LAB_29D8		; if -ve then 1 digit before dp
  6277
  6278 CAE1 C9 08			CMP	#$08			; A>=8 if n>=1E6
  6279 CAE3 B0 06			BCS	LAB_29D9		; branch if >= $08
  6280
  6281 									; carry is clear
  6282 CAE5 69 FF			ADC	#$FF			; take 1 from digit count
  6283 CAE7 AA				TAX				; copy to A
  6284 CAE8 A9 02			LDA	#$02			;.set exponent adjust
  6285 CAEA			LAB_29D8
  6286 CAEA 38				SEC				; set carry for subtract
  6287 CAEB			LAB_29D9
  6288 CAEB E9 02			SBC	#$02			; -2
  6289 CAED 85 69			STA	expcnt			;.save exponent adjust
  6290 CAEF 86 68			STX	numexp			; save digits before dp count
  6291 CAF1 8A				TXA				; copy to A
  6292 CAF2 F0 02			BEQ	LAB_29E4		; branch if no digits before dp
  6293
  6294 CAF4 10 13			BPL	LAB_29F7		; branch if digits before dp
  6295
  6296 CAF6			LAB_29E4
  6297 CAF6 A4 7A			LDY	Sendl			; get output string index
  6298 CAF8 A9 2E			LDA	#$2E			; character '.'
  6299 CAFA C8				INY				; increment index
  6300 CAFB 99 9D 00			STA	Decss,Y			; save to output string
  6301 CAFE 8A				TXA				;.
  6302 CAFF F0 06			BEQ	LAB_29F5		;.
  6303
  6304 CB01 A9 30			LDA	#'0'			; character '0'
  6305 CB03 C8				INY				; increment index
  6306 CB04 99 9D 00			STA	Decss,Y			; save to output string
  6307 CB07			LAB_29F5
  6308 CB07 84 7A			STY	Sendl			; save output string index
  6309 CB09			LAB_29F7
  6310 CB09 A0 00			LDY	#$00			; clear index (point to 100,000)
  6311 CB0B A2 80			LDX	#$80			; 
  6312 CB0D			LAB_29FB
  6313 CB0D A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  6314 CB0F 18				CLC				; clear carry for add
  6315 CB10 79 0C D4			ADC	LAB_2A9C,Y		; add -ve LSB
  6316 CB13 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  6317 CB15 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  6318 CB17 79 0B D4			ADC	LAB_2A9B,Y		; add -ve NMSB
  6319 CB1A 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  6320 CB1C A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  6321 CB1E 79 0A D4			ADC	LAB_2A9A,Y		; add -ve MSB
  6322 CB21 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  6323 CB23 E8				INX				; 
  6324 CB24 B0 04			BCS	LAB_2A18		; 
  6325
  6326 CB26 10 E5			BPL	LAB_29FB		; not -ve so try again
  6327
  6328 CB28 30 02			BMI	LAB_2A1A		; 
  6329
  6330 CB2A			LAB_2A18
  6331 CB2A 30 E1			BMI	LAB_29FB		; 
  6332
  6333 CB2C			LAB_2A1A
  6334 CB2C 8A				TXA				; 
  6335 CB2D 90 04			BCC	LAB_2A21		; 
  6336
  6337 CB2F 49 FF			EOR	#$FF			; 
  6338 CB31 69 0A			ADC	#$0A			; 
  6339 CB33			LAB_2A21
  6340 CB33 69 2F			ADC	#'0'-1			; add '0'-1 to result
  6341 CB35 C8				INY				; increment index ..
  6342 CB36 C8				INY				; .. to next less ..
  6343 CB37 C8				INY				; .. power of ten
  6344 CB38 84 55			STY	Cvaral			; save as current var address low byte
  6345 CB3A A4 7A			LDY	Sendl			; get output string index
  6346 CB3C C8				INY				; increment output string index
  6347 CB3D AA				TAX				; copy character to X
  6348 CB3E 29 7F			AND	#$7F			; mask out top bit
  6349 CB40 99 9D 00			STA	Decss,Y			; save to output string
  6350 CB43 C6 68			DEC	numexp			; decrement # of characters before the dp
  6351 CB45 D0 06			BNE	LAB_2A3B		; branch if still characters to do
  6352
  6353 									; else output the point
  6354 CB47 A9 2E			LDA	#$2E			; character '.'
  6355 CB49 C8				INY				; increment output string index
  6356 CB4A 99 9D 00			STA	Decss,Y			; save to output string
  6357 CB4D			LAB_2A3B
  6358 CB4D 84 7A			STY	Sendl			; save output string index
  6359 CB4F A4 55			LDY	Cvaral			; get current var address low byte
  6360 CB51 8A				TXA				; get character back
  6361 CB52 49 FF			EOR	#$FF			; 
  6362 CB54 29 80			AND	#$80			; 
  6363 CB56 AA				TAX				; 
  6364 CB57 C0 12			CPY	#$12			; compare index with max
  6365 CB59 D0 B2			BNE	LAB_29FB		; loop if not max
  6366
  6367 									; now remove trailing zeroes
  6368 CB5B A4 7A			LDY	Sendl			; get output string index
  6369 CB5D			LAB_2A4B
  6370 CB5D B9 9D 00			LDA	Decss,Y			; get character from output string
  6371 CB60 88				DEY				; decrement output string index
  6372 CB61 C9 30			CMP	#'0'			; compare with '0'
  6373 CB63 F0 F8			BEQ	LAB_2A4B		; loop until non '0' character found
  6374
  6375 CB65 C9 2E			CMP	#'.'			; compare with '.'
  6376 CB67 F0 01			BEQ	LAB_2A58		; branch if was dp
  6377
  6378 									; restore last character
  6379 CB69 C8				INY				; increment output string index
  6380 CB6A			LAB_2A58
  6381 CB6A A9 2B			LDA	#$2B			; character '+'
  6382 CB6C A6 69			LDX	expcnt			; get exponent count
  6383 CB6E F0 2E			BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6384
  6385 									; exponent isn't zero so write exponent
  6386 CB70 10 08			BPL	LAB_2A68		; branch if exponent count +ve
  6387
  6388 CB72 A9 00			LDA	#$00			; clear A
  6389 CB74 38				SEC				; set carry for subtract
  6390 CB75 E5 69			SBC	expcnt			; subtract exponent count adjust (convert -ve to +ve)
  6391 CB77 AA				TAX				; copy exponent count to X
  6392 CB78 A9 2D			LDA	#'-'			; character '-'
  6393 CB7A			LAB_2A68
  6394 CB7A 99 9F 00			STA	Decss+2,Y		; save to output string
  6395 CB7D A9 45			LDA	#$45			; character 'E'
  6396 CB7F 99 9E 00			STA	Decss+1,Y		; save exponent sign to output string
  6397 CB82 8A				TXA				; get exponent count back
  6398 CB83 A2 2F			LDX	#'0'-1			; one less than '0' character
  6399 CB85 38				SEC				; set carry for subtract
  6400 CB86			LAB_2A74
  6401 CB86 E8				INX				; increment 10's character
  6402 CB87 E9 0A			SBC	#$0A			;.subtract 10 from exponent count
  6403 CB89 B0 FB			BCS	LAB_2A74		; loop while still >= 0
  6404
  6405 CB8B 69 3A			ADC	#':'			; add character ':' ($30+$0A, result is 10 less that value)
  6406 CB8D 99 A1 00			STA	Decss+4,Y		; save to output string
  6407 CB90 8A				TXA				; copy 10's character
  6408 CB91 99 A0 00			STA	Decss+3,Y		; save to output string
  6409 CB94 A9 00			LDA	#$00			; set null terminator
  6410 CB96 99 A2 00			STA	Decss+5,Y		; save to output string
  6411 CB99 F0 08			BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6412
  6413 									; save last character, [EOT] and exit
  6414 CB9B			LAB_2A89
  6415 CB9B 99 9D 00			STA	Decss,Y			; save last character to output string
  6416
  6417 									; set null terminator and exit
  6418 CB9E			LAB_2A8C
  6419 CB9E A9 00			LDA	#$00			; set null terminator
  6420 CBA0 99 9E 00			STA	Decss+1,Y		; save after last character
  6421
  6422 									; set string pointer (AY) and exit
  6423 CBA3			LAB_2A91
  6424 CBA3 A9 9E			LDA	#<Decssp1		; set result string low pointer
  6425 CBA5 A0 00			LDY	#>Decssp1		; set result string high pointer
  6426 CBA7 60				RTS
  6427
  6428 				; perform power function
  6429 CBA8			LAB_POWER
  6430 CBA8 F0 42			BEQ	LAB_EXP			; go do  EXP()
  6431
  6432 CBAA A5 73			LDA	FAC2_e			; get FAC2 exponent
  6433 CBAC D0 03			BNE	LAB_2ABF		; branch if FAC2<>0
  6434
  6435 CBAE 4C 3F C6			JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6436
  6437 CBB1			LAB_2ABF
  6438 CBB1 A2 5C			LDX	#<func_l		; set destination pointer low byte
  6439 CBB3 A0 00			LDY	#>func_l		; set destination pointer high byte
  6440 CBB5 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6441 CBB8 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6442 CBBA 10 0F			BPL	LAB_2AD9		; branch if FAC2>0
  6443
  6444 									; else FAC2 is -ve and can only be raised to an
  6445 									; integer power which gives an x +j0 result
  6446 CBBC 20 6E C9			JSR	LAB_INT			; perform INT
  6447 CBBF A9 5C			LDA	#<func_l		; set source pointer low byte
  6448 CBC1 A0 00			LDY	#>func_l		; set source pointer high byte
  6449 CBC3 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6450 CBC6 D0 03			BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6451 									; this will leave FAC1 -ve and cause a Function Call
  6452 									; error when LOG() is called
  6453
  6454 CBC8 98				TYA				; clear sign b7
  6455 CBC9 A4 1B			LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
  6456 									; for possible later negation, b0
  6457 CBCB			LAB_2AD9
  6458 CBCB 20 B2 C5			JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6459 CBCE 98				TYA				; copy sign back ..
  6460 CBCF 48				PHA				; .. and save it
  6461 CBD0 20 E8 C6			JSR	LAB_LOG			; do LOG(n)
  6462 CBD3 A9 5C			LDA	#<garb_l		; set pointer low byte
  6463 CBD5 A0 00			LDY	#>garb_l		; set pointer high byte
  6464 CBD7 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6465 CBDA 20 EC CB			JSR	LAB_EXP			; go do EXP(n)
  6466 CBDD 68				PLA				; pull sign from stack
  6467 CBDE 4A				LSR				; b0 is to be tested, shift to Cb
  6468 CBDF 90 0A			BCC	LAB_2AF9		; if no bit then exit
  6469
  6470 									; Perform negation
  6471 				; do - FAC1
  6472 CBE1			LAB_GTHAN
  6473 CBE1 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6474 CBE3 F0 06			BEQ	LAB_2AF9		; exit if FAC1_e = $00
  6475
  6476 CBE5 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6477 CBE7 49 FF			EOR	#$FF			; complement it
  6478 CBE9 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  6479 CBEB			LAB_2AF9
  6480 CBEB 60				RTS
  6481
  6482 				; perform EXP()	(x^e)
  6483 CBEC			LAB_EXP
  6484 CBEC A9 9A			LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6485 CBEE A0 D3			LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6486 CBF0 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6487 CBF3 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  6488 CBF5 69 50			ADC	#$50			; +$50/$100
  6489 CBF7 90 03			BCC	LAB_2B2B		; skip rounding if no carry
  6490
  6491 CBF9 20 CE C8			JSR	LAB_27C2		; round FAC1 (no check)
  6492 CBFC			LAB_2B2B
  6493 CBFC 85 63			STA	FAC2_r			; save FAC2 rounding byte
  6494 CBFE 20 BA C8			JSR	LAB_27AE		; copy FAC1 to FAC2
  6495 CC01 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6496 CC03 C9 88			CMP	#$88			; compare with EXP limit (256d)
  6497 CC05 90 03			BCC	LAB_2B39		; branch if less
  6498
  6499 CC07			LAB_2B36
  6500 CC07 20 BB C7			JSR	LAB_2690		; handle overflow and underflow
  6501 CC0A			LAB_2B39
  6502 CC0A 20 6E C9			JSR	LAB_INT			; perform INT
  6503 CC0D A5 1B			LDA	Temp3			; get mantissa 3 from INT() function
  6504 CC0F 18				CLC				; clear carry for add
  6505 CC10 69 81			ADC	#$81			; normalise +1
  6506 CC12 F0 F3			BEQ	LAB_2B36		; if $00 go handle overflow
  6507
  6508 CC14 38				SEC				; set carry for subtract
  6509 CC15 E9 01			SBC	#$01			; now correct for exponent
  6510 CC17 48				PHA				; save FAC2 exponent
  6511
  6512 									; swap FAC1 and FAC2
  6513 CC18 A2 04			LDX	#$04			; 4 bytes to do
  6514 CC1A			LAB_2B49
  6515 CC1A B5 73			LDA	FAC2_e,X		; get FAC2,X
  6516 CC1C B4 6C			LDY	FAC1_e,X		; get FAC1,X
  6517 CC1E 95 6C			STA	FAC1_e,X		; save FAC1,X
  6518 CC20 94 73			STY	FAC2_e,X		; save FAC2,X
  6519 CC22 CA				DEX				; decrement count/index
  6520 CC23 10 F5			BPL	LAB_2B49		; loop if not all done
  6521
  6522 CC25 A5 63			LDA	FAC2_r			; get FAC2 rounding byte
  6523 CC27 85 79			STA	FAC1_r			; save as FAC1 rounding byte
  6524 CC29 20 93 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6525 CC2C 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6526 CC2F A9 9E			LDA	#<LAB_2AFE		; set counter pointer low byte
  6527 CC31 A0 D3			LDY	#>LAB_2AFE		; set counter pointer high byte
  6528 CC33 20 54 CC			JSR	LAB_2B84		; go do series evaluation
  6529 CC36 A9 00			LDA	#$00			; clear A
  6530 CC38 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6531 CC3A 68				PLA				;.get saved FAC2 exponent
  6532 CC3B 4C A0 C7			JMP	LAB_2675		; test and adjust accumulators and return
  6533
  6534 				; ^2 then series evaluation
  6535 CC3E			LAB_2B6E
  6536 CC3E 85 7A			STA	Cptrl			; save count pointer low byte
  6537 CC40 84 7B			STY	Cptrh			; save count pointer high byte
  6538 CC42 20 8A C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6539 CC45 A9 64			LDA	#<Adatal		; set pointer low byte (Y already $00)
  6540 CC47 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6541 CC4A 20 58 CC			JSR	LAB_2B88		; go do series evaluation
  6542 CC4D A9 64			LDA	#<Adatal		; pointer to original # low byte
  6543 CC4F A0 00			LDY	#>Adatal		; pointer to original # high byte
  6544 CC51 4C 26 C7			JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6545
  6546 				; series evaluation
  6547 CC54			LAB_2B84
  6548 CC54 85 7A			STA	Cptrl			; save count pointer low byte
  6549 CC56 84 7B			STY	Cptrh			; save count pointer high byte
  6550 CC58			LAB_2B88
  6551 CC58 A2 68			LDX	#<numexp		; set pointer low byte
  6552 CC5A 20 8C C8			JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
  6553 CC5D B1 7A			LDA	(Cptrl),Y		; get constants count
  6554 CC5F 85 71			STA	numcon			; save constants count
  6555 CC61 A4 7A			LDY	Cptrl			; get count pointer low byte
  6556 CC63 C8				INY				; increment it (now constants pointer)
  6557 CC64 98				TYA				; copy it
  6558 CC65 D0 02			BNE	LAB_2B97		; skip next if no overflow
  6559
  6560 CC67 E6 7B			INC	Cptrh			; else increment high byte
  6561 CC69			LAB_2B97
  6562 CC69 85 7A			STA	Cptrl			; save low byte
  6563 CC6B A4 7B			LDY	Cptrh			; get high byte
  6564 CC6D			LAB_2B9B
  6565 CC6D 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6566 CC70 A5 7A			LDA	Cptrl			; get constants pointer low byte
  6567 CC72 A4 7B			LDY	Cptrh			; get constants pointer high byte
  6568 CC74 18				CLC				; clear carry for add
  6569 CC75 69 04			ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6570 CC77 90 01			BCC	LAB_2BA8		; skip next if no overflow
  6571
  6572 CC79 C8				INY				; increment high byte
  6573 CC7A			LAB_2BA8
  6574 CC7A 85 7A			STA	Cptrl			; save pointer low byte
  6575 CC7C 84 7B			STY	Cptrh			; save pointer high byte
  6576 CC7E 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6577 CC81 A9 68			LDA	#<numexp		; set pointer low byte to partial @ numexp
  6578 CC83 A0 00			LDY	#>numexp		; set pointer high byte to partial @ numexp
  6579 CC85 C6 71			DEC	numcon			; decrement constants count
  6580 CC87 D0 E4			BNE	LAB_2B9B		; loop until all done
  6581
  6582 CC89 60				RTS
  6583
  6584 				; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6585 				; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6586 				; the Galois method and a sample of 65536 bytes produced gives the following values.
  6587
  6588 				; Entropy = 7.997442 bits per byte
  6589 				; Optimum compression would reduce these 65536 bytes by 0 percent
  6590
  6591 				; Chi square distribution for 65536 samples is 232.01, and
  6592 				; randomly would exceed this value 75.00 percent of the time
  6593
  6594 				; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6595 				; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6596 				; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6597 CC8A			LAB_RND
  6598 CC8A A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6599 CC8C F0 07			BEQ	NextPRN			; do next random # if zero
  6600
  6601 									; else get seed into random number store
  6602 CC8E A2 98			LDX	#Rbyte4			; set PRNG pointer low byte
  6603 CC90 A0 00			LDY	#$00			; set PRNG pointer high byte
  6604 CC92 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6605 CC95			NextPRN
  6606 CC95 A2 AF			LDX	#$AF			; set EOR byte
  6607 CC97 A0 13			LDY	#$13			; do this nineteen times
  6608 CC99			LoopPRN
  6609 CC99 06 99			ASL	Rbyte1			; shift PRNG most significant byte
  6610 CC9B 26 9A			ROL	Rbyte2			; shift PRNG middle byte
  6611 CC9D 26 9B			ROL	Rbyte3			; shift PRNG least significant byte
  6612 CC9F 26 98			ROL	Rbyte4			; shift PRNG extra byte
  6613 CCA1 90 05			BCC	Ninc1			; branch if bit 32 clear
  6614
  6615 CCA3 8A				TXA				; set EOR byte
  6616 CCA4 45 99			EOR	Rbyte1			; EOR PRNG extra byte
  6617 CCA6 85 99			STA	Rbyte1			; save new PRNG extra byte
  6618 CCA8			Ninc1
  6619 CCA8 88				DEY				; decrement loop count
  6620 CCA9 D0 EE			BNE	LoopPRN			; loop if not all done
  6621
  6622 CCAB A2 02			LDX	#$02			; three bytes to copy
  6623 CCAD			CopyPRNG
  6624 CCAD B5 99			LDA	Rbyte1,X		; get PRNG byte
  6625 CCAF 95 6D			STA	FAC1_1,X		; save FAC1 byte
  6626 CCB1 CA				DEX
  6627 CCB2 10 F9			BPL	CopyPRNG		; loop if not complete
  6628
  6629 CCB4 A9 80			LDA	#$80			; set the exponent
  6630 CCB6 85 6C			STA	FAC1_e			; save FAC1 exponent
  6631
  6632 CCB8 0A				ASL				; clear A
  6633 CCB9 85 70			STA	FAC1_s			; save FAC1 sign
  6634
  6635 CCBB 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  6636
  6637 				; perform COS()
  6638 CCBE			LAB_COS
  6639 CCBE A9 BB			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6640 CCC0 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6641 CCC2 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6642
  6643 				; perform SIN()
  6644 CCC5			LAB_SIN
  6645 CCC5 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6646 CCC8 A9 D0			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6647 CCCA A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6648 CCCC A6 77			LDX	FAC2_s			; get FAC2 sign (b7)
  6649 CCCE 20 E6 C7			JSR	LAB_26C2		; divide by (AY) (X=sign)
  6650 CCD1 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6651 CCD4 20 6E C9			JSR	LAB_INT			; perform INT
  6652 CCD7 A9 00			LDA	#$00			; clear byte
  6653 CCD9 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6654 CCDB 20 93 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6655 CCDE A9 02			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6656 CCE0 A0 D4			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6657 CCE2 20 90 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6658 CCE5 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6659 CCE7 48				PHA				; save FAC1 sign
  6660 CCE8 10 0D			BPL	LAB_2C35		; branch if +ve
  6661
  6662 									; FAC1 sign was -ve
  6663 CCEA 20 A7 C5			JSR	LAB_244E		; add 0.5 to FAC1
  6664 CCED A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6665 CCEF 30 09			BMI	LAB_2C38		; branch if -ve
  6666
  6667 CCF1 A5 23			LDA	Cflag			; get comparison evaluation flag
  6668 CCF3 49 FF			EOR	#$FF			; toggle flag
  6669 CCF5 85 23			STA	Cflag			; save comparison evaluation flag
  6670 CCF7			LAB_2C35
  6671 CCF7 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6672 CCFA			LAB_2C38
  6673 CCFA A9 02			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6674 CCFC A0 D4			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6675 CCFE 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6676 CD01 68				PLA				; restore FAC1 sign
  6677 CD02 10 03			BPL	LAB_2C45		; branch if was +ve
  6678
  6679 									; else correct FAC1
  6680 CD04 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6681 CD07			LAB_2C45
  6682 CD07 A9 BF			LDA	#<LAB_2C84		; set pointer low byte to counter
  6683 CD09 A0 D3			LDY	#>LAB_2C84		; set pointer high byte to counter
  6684 CD0B 4C 3E CC			JMP	LAB_2B6E		; ^2 then series evaluation and return
  6685
  6686 				; perform TAN()
  6687 CD0E			LAB_TAN
  6688 CD0E 20 8A C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6689 CD11 A9 00			LDA	#$00			; clear byte
  6690 CD13 85 23			STA	Cflag			; clear comparison evaluation flag
  6691 CD15 20 C5 CC			JSR	LAB_SIN			; go do SIN(n)
  6692 CD18 A2 5C			LDX	#<func_l		; set sin(n) pointer low byte
  6693 CD1A A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6694 CD1C 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6695 CD1F A9 64			LDA	#<Adatal		; set n pointer low addr
  6696 CD21 A0 00			LDY	#>Adatal		; set n pointer high addr
  6697 CD23 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6698 CD26 A9 00			LDA	#$00			; clear byte
  6699 CD28 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6700 CD2A A5 23			LDA	Cflag			; get comparison evaluation flag
  6701 CD2C 20 36 CD			JSR	LAB_2C74		; save flag and go do series evaluation
  6702
  6703 CD2F A9 5C			LDA	#<func_l		; set sin(n) pointer low byte
  6704 CD31 A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6705 CD33 4C EE C7			JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6706
  6707 CD36			LAB_2C74
  6708 CD36 48				PHA				; save comparison evaluation flag
  6709 CD37 4C F7 CC			JMP	LAB_2C35		; go do series evaluation
  6710
  6711 				; perform USR()
  6712 CD3A			LAB_USR
  6713 CD3A 20 0A 00			JSR	Usrjmp			; call user code
  6714 CD3D 4C CC BB			JMP	LAB_1BFB		; scan for ')', else do syntax error then warm start
  6715
  6716 				; perform ATN()
  6717 CD40			LAB_ATN
  6718 CD40 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6719 CD42 48				PHA				; save sign
  6720 CD43 10 03			BPL	LAB_2CA1		; branch if +ve
  6721
  6722 CD45 20 E1 CB			JSR	LAB_GTHAN		; else do - FAC1
  6723 CD48			LAB_2CA1
  6724 CD48 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6725 CD4A 48				PHA				; push exponent
  6726 CD4B C9 81			CMP	#$81			; compare with 1
  6727 CD4D 90 07			BCC	LAB_2CAF		; branch if FAC1<1
  6728
  6729 CD4F A9 F5			LDA	#<LAB_259C		; set 1 pointer low byte
  6730 CD51 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  6731 CD53 20 EE C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6732 CD56			LAB_2CAF
  6733 CD56 A9 D4			LDA	#<LAB_2CC9		; set pointer low byte to counter
  6734 CD58 A0 D3			LDY	#>LAB_2CC9		; set pointer high byte to counter
  6735 CD5A 20 3E CC			JSR	LAB_2B6E		; ^2 then series evaluation
  6736 CD5D 68				PLA				; restore old FAC1 exponent
  6737 CD5E C9 81			CMP	#$81			; compare with 1
  6738 CD60 90 07			BCC	LAB_2CC2		; branch if FAC1<1
  6739
  6740 CD62 A9 BB			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6741 CD64 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6742 CD66 20 90 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6743 CD69			LAB_2CC2
  6744 CD69 68				PLA				; restore FAC1 sign
  6745 CD6A 10 16			BPL	LAB_2D04		; exit if was +ve
  6746
  6747 CD6C 4C E1 CB			JMP	LAB_GTHAN		; else do - FAC1 and return
  6748
  6749 				; perform BITSET
  6750 CD6F			LAB_BITSET
  6751 CD6F 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6752 CD72 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6753 CD74 B0 20			BCS	FCError			; branch if > 7
  6754
  6755 CD76 A9 00			LDA	#$00			; clear A
  6756 CD78 38				SEC				; set the carry
  6757 CD79			S_Bits
  6758 CD79 2A				ROL				; shift bit
  6759 CD7A CA				DEX				; decrement bit number
  6760 CD7B 10 FC			BPL	S_Bits			; loop if still +ve
  6761
  6762 CD7D E8				INX				; make X = $00
  6763 CD7E 01 11			ORA	(Itempl,X)		; or with byte via temporary integer (addr)
  6764 CD80 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6765 CD82			LAB_2D04
  6766 CD82 60				RTS
  6767
  6768 				; perform BITCLR
  6769 CD83			LAB_BITCLR
  6770 CD83 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6771 CD86 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6772 CD88 B0 0C			BCS	FCError			; branch if > 7
  6773
  6774 CD8A A9 FF			LDA	#$FF			; set A
  6775 CD8C			S_Bitc
  6776 CD8C 2A				ROL				; shift bit
  6777 CD8D CA				DEX				; decrement bit number
  6778 CD8E 10 FC			BPL	S_Bitc			; loop if still +ve
  6779
  6780 CD90 E8				INX				; make X = $00
  6781 CD91 21 11			AND	(Itempl,X)		; and with byte via temporary integer (addr)
  6782 CD93 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6783 CD95 60				RTS
  6784
  6785 CD96			FCError
  6786 CD96 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  6787
  6788 				; perform BITTST()
  6789 CD99			LAB_BTST
  6790 CD99 20 7C 00			JSR	LAB_IGBY		; increment BASIC pointer
  6791 CD9C 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6792 CD9F E0 08			CPX	#$08			; only 0 to 7 are allowed
  6793 CDA1 B0 F3			BCS	FCError			; branch if > 7
  6794
  6795 CDA3 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  6796 CDA6 C9 29			CMP	#')'			; is next character ')'
  6797 CDA8 F0 03			BEQ	TST_OK			; if ')' go do rest of function
  6798
  6799 CDAA 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  6800
  6801 CDAD			TST_OK
  6802 CDAD 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6803 CDB0 A9 00			LDA	#$00			; clear A
  6804 CDB2 38				SEC				; set the carry
  6805 CDB3			T_Bits
  6806 CDB3 2A				ROL				; shift bit
  6807 CDB4 CA				DEX				; decrement bit number
  6808 CDB5 10 FC			BPL	T_Bits			; loop if still +ve
  6809
  6810 CDB7 E8				INX				; make X = $00
  6811 CDB8 21 11			AND	(Itempl,X)		; AND with byte via temporary integer (addr)
  6812 CDBA F0 02			BEQ	LAB_NOTT		; branch if zero (already correct)
  6813
  6814 CDBC A9 FF			LDA	#$FF			; set for -1 result
  6815 CDBE			LAB_NOTT
  6816 CDBE 4C E7 C8			JMP	LAB_27DB		; go do SGN tail
  6817
  6818 				; perform BIN$()
  6819 CDC1			LAB_BINS
  6820 CDC1 E0 19			CPX	#$19			; max + 1
  6821 CDC3 B0 48			BCS	BinFErr			; exit if too big ( > or = )
  6822
  6823 CDC5 86 38			STX	TempB			; save # of characters ($00 = leading zero remove)
  6824 CDC7 A9 18			LDA	#$18			; need A byte long space
  6825 CDC9 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long
  6826 CDCC A0 17			LDY	#$17			; set index
  6827 CDCE A2 18			LDX	#$18			; character count
  6828 CDD0			NextB1
  6829 CDD0 46 11			LSR	nums_1			; shift highest byte
  6830 CDD2 66 12			ROR	nums_2			; shift middle byte
  6831 CDD4 66 13			ROR	nums_3			; shift lowest byte bit 0 to carry
  6832 CDD6 8A				TXA				; load with '0'/2
  6833 CDD7 2A				ROL				; shift in carry
  6834 CDD8 91 6D			STA	(str_pl),Y		; save to temp string + index
  6835 CDDA 88				DEY				; decrement index
  6836 CDDB 10 F3			BPL	NextB1			; loop if not done
  6837
  6838 CDDD A5 38			LDA	TempB			; get # of characters
  6839 CDDF F0 0A			BEQ	EndBHS			; branch if truncate
  6840
  6841 CDE1 AA				TAX				; copy length to X
  6842 CDE2 38				SEC				; set carry for add !
  6843 CDE3 49 FF			EOR	#$FF			; 1's complement
  6844 CDE5 69 18			ADC	#$18			; add 24d
  6845 CDE7 F0 1C			BEQ	GoPr2			; if zero print whole string
  6846
  6847 CDE9 D0 0F			BNE	GoPr1			; else go make output string
  6848 					
  6849 				; this is the exit code and is also used by HEX$()
  6850 				; truncate string to remove leading '0's
  6851 CDEB			EndBHS
  6852 CDEB A8				TAY				; clear index (A=0, X=length here)
  6853 CDEC			NextB2
  6854 CDEC B1 6D			LDA	(str_pl),Y		; get character from string
  6855 CDEE C9 30			CMP	#'0'			; compare with '0'
  6856 CDF0 D0 07			BNE	GoPr			; if not '0' then go print string from here
  6857
  6858 CDF2 CA				DEX				; decrement character count
  6859 CDF3 F0 03			BEQ	GoPr3			; if zero then end of string so go print it
  6860
  6861 CDF5 C8				INY				; else increment index
  6862 CDF6 10 F4			BPL	NextB2			; loop always
  6863
  6864 				; make fixed length output string - ignore overflows!
  6865 CDF8			GoPr3
  6866 CDF8 E8				INX				; need at least 1 character
  6867 CDF9			GoPr
  6868 CDF9 98				TYA				; copy result
  6869 CDFA			GoPr1
  6870 CDFA 18				CLC				; clear carry for add
  6871 CDFB 65 6D			ADC	str_pl			; add low address
  6872 CDFD 85 6D			STA	str_pl			; save low address
  6873 CDFF A9 00			LDA	#$00			; do high byte
  6874 CE01 65 6E			ADC	str_ph			; add high address
  6875 CE03 85 6E			STA	str_ph			; save high address
  6876 CE05			GoPr2
  6877 CE05 86 6C			STX	str_ln			; X holds string length
  6878 CE07 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6879 CE0A 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put address
  6880 									; and length on descriptor stack and update stack pointers
  6881
  6882 CE0D			BinFErr
  6883 CE0D 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  6884
  6885 				; perform HEX$()
  6886 CE10			LAB_HEXS
  6887 CE10 E0 07			CPX	#$07			; max + 1
  6888 CE12 B0 F9			BCS	BinFErr			; exit if too big ( > or = )
  6889
  6890 CE14 86 38			STX	TempB			; save # of characters
  6891
  6892 CE16 A9 06			LDA	#$06			; need 6 bytes for string
  6893 CE18 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long
  6894 CE1B A0 05			LDY	#$05			; set string index
  6895
  6896 					; Disable decimal mode patch
  6897 					;SED				; need decimal mode for nibble convert
  6898 CE1D A5 13			LDA	nums_3			; get lowest byte
  6899 CE1F 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6900 CE22 A5 12			LDA	nums_2			; get middle byte
  6901 CE24 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6902 CE27 A5 11			LDA	nums_1			; get highest byte
  6903 CE29 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6904 					;CLD				; back to binary
  6905
  6906 CE2C A2 06			LDX	#$06			; character count
  6907 CE2E A5 38			LDA	TempB			; get # of characters
  6908 CE30 F0 B9			BEQ	EndBHS			; branch if truncate
  6909
  6910 CE32 AA				TAX				; copy length to X
  6911 CE33 38				SEC				; set carry for add !
  6912 CE34 49 FF			EOR	#$FF			; 1's complement
  6913 CE36 69 06			ADC	#$06			; add 6d
  6914 CE38 F0 CB			BEQ	GoPr2			; if zero print whole string
  6915
  6916 CE3A D0 BE			BNE	GoPr1			; else go make output string (branch always)
  6917
  6918 				; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6919 CE3C			LAB_A2HX
  6920 CE3C AA				TAX				; save byte
  6921 CE3D 29 0F			AND	#$0F			; mask off top bits
  6922 CE3F 20 47 CE			JSR	LAB_AL2X		; convert low nibble to ASCII and output
  6923 CE42 8A				TXA				; get byte back
  6924 CE43 4A				LSR				; /2	shift high nibble to low nibble
  6925 CE44 4A				LSR				; /4
  6926 CE45 4A				LSR				; /8
  6927 CE46 4A				LSR				; /16
  6928 CE47			LAB_AL2X				; Disable decimal mode patch added
  6929 CE47 C9 0A			CMP	#$0A			; set carry for +1 if >9
  6930 CE49 90 02			BCC   	LAB_AL20          	; skip adjust if <= 9
  6931 CE4B 69 06			ADC   	#$06              	; adjust for A to F 
  6932 CE4D			LAB_AL20
  6933 CE4D 69 30			ADC	#'0'			; add ASCII '0'
  6934 CE4F 91 6D			STA	(str_pl),Y		; save to temp string
  6935 CE51 88				DEY				; decrement counter
  6936 CE52 60				RTS
  6937
  6938 CE53			LAB_NLTO
  6939 CE53 85 6C			STA	FAC1_e			; save FAC1 exponent
  6940 CE55 A9 00			LDA	#$00			; clear sign compare
  6941 CE57			LAB_MLTE
  6942 CE57 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6943 CE59 8A				TXA				; restore character
  6944 CE5A 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6945
  6946 				; gets here if the first character was '$' for hex
  6947 				; get hex number
  6948 CE5D			LAB_CHEX
  6949 CE5D 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6950 CE60 90 0A			BCC	LAB_ISHN		; branch if numeric character
  6951
  6952 CE62 09 20			ORA	#$20			; case convert, allow 'A' to 'F' and 'a' to 'f'
  6953 CE64 E9 61			SBC	#'a'			; subtract 'a' (carry set here)
  6954 CE66 C9 06			CMP	#$06			; compare normalised with $06 (max+1)
  6955 CE68 B0 2A			BCS	LAB_EXCH		; exit if >'f' or <'0'
  6956
  6957 CE6A 69 0A			ADC	#$0A			; convert to nibble
  6958 CE6C			LAB_ISHN
  6959 CE6C 29 0F			AND	#$0F			; convert to binary
  6960 CE6E AA				TAX				; save nibble
  6961 CE6F A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6962 CE71 F0 E4			BEQ	LAB_MLTE		; skip multiply if zero
  6963
  6964 CE73 69 04			ADC	#$04			; add four to exponent (*16 - carry clear here)
  6965 CE75 90 DC			BCC	LAB_NLTO		; if no overflow do evaluate digit
  6966
  6967 CE77			LAB_MLTO
  6968 CE77 4C B0 C6			JMP	LAB_2564		; do overflow error and warm start
  6969
  6970 CE7A			LAB_NXCH
  6971 CE7A AA				TAX				; save bit
  6972 CE7B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6973 CE7D F0 06			BEQ	LAB_MLBT		; skip multiply if zero
  6974
  6975 CE7F E6 6C			INC	FAC1_e			; increment FAC1 exponent (*2)
  6976 CE81 F0 F4			BEQ	LAB_MLTO		; do overflow error if = $00
  6977
  6978 CE83 A9 00			LDA	#$00			; clear sign compare
  6979 CE85			LAB_MLBT
  6980 CE85 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6981 CE87 8A				TXA				; restore bit
  6982 CE88 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6983
  6984 				; gets here if the first character was  '%' for binary
  6985 				; get binary number
  6986 CE8B			LAB_CBIN
  6987 CE8B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6988 CE8E 49 30			EOR	#'0'			; convert '0' to 0 etc.
  6989 CE90 C9 02			CMP	#$02			; compare with max+1
  6990 CE92 90 E6			BCC	LAB_NXCH		; branch exit if < 2
  6991
  6992 CE94			LAB_EXCH
  6993 CE94 4C 17 CA			JMP	LAB_28F6		; evaluate -ve flag and return
  6994
  6995 				; ctrl-c check routine. includes limited 'life' byte save for INGET routine
  6996 				; now also the code that checks to see if an interrupt has occurred
  6997 CE97			CTRLC
  6998 CE97 AD 68 18			LDA	ccflag			; get [CTRL-C] check flag
  6999 CE9A D0 18			BNE	LAB_FBA2		; exit if inhibited
  7000
  7001 CE9C 20 0D D3			JSR	V_INPT			; scan input device
  7002 CE9F 90 0B			BCC	LAB_FBA0		; exit if buffer empty
  7003
  7004 CEA1 8D 69 18			STA	ccbyte			; save received byte
  7005 CEA4 A2 20			LDX	#$20			; 'life' timer for bytes
  7006 CEA6 8E 6A 18			STX	ccnull			; set countdown
  7007 CEA9 4C F6 B4			JMP	LAB_1636		; return to BASIC
  7008
  7009 CEAC			LAB_FBA0
  7010 CEAC AE 6A 18			LDX	ccnull			; get countdown byte
  7011 CEAF F0 03			BEQ	LAB_FBA2		; exit if finished
  7012
  7013 CEB1 CE 6A 18			DEC	ccnull			; else decrement countdown
  7014 CEB4			LAB_FBA2
  7015 CEB4 A2 03			LDX	#NmiBase		; set pointer to NMI values
  7016 CEB6 20 BF CE			JSR	LAB_CKIN		; go check interrupt
  7017 CEB9 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7018 CEBB 20 BF CE			JSR	LAB_CKIN		; go check interrupt
  7019 CEBE			LAB_CRTS
  7020 CEBE 60				RTS
  7021
  7022 				; check whichever interrupt is indexed by X
  7023 CEBF			LAB_CKIN
  7024 CEBF B5 00			LDA	PLUS_0,X		; get interrupt flag byte
  7025 CEC1 10 FB			BPL	LAB_CRTS		; branch if interrupt not enabled
  7026
  7027 				; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  7028 				; automatically enable the interrupt when we exit
  7029 CEC3 0A				ASL				; move happened bit to setup bit
  7030 CEC4 29 40			AND	#$40			; mask happened bits
  7031 CEC6 F0 F6			BEQ	LAB_CRTS		; if no interrupt then exit
  7032
  7033 CEC8 95 00			STA	PLUS_0,X		; save interrupt flag byte
  7034
  7035 CECA 8A				TXA				; copy index ..
  7036 CECB A8				TAY				; .. to Y
  7037
  7038 CECC 68				PLA				; dump return address low byte, call from CTRL-C
  7039 CECD 68				PLA				; dump return address high byte
  7040
  7041 CECE A9 05			LDA	#$05			; need 5 bytes for GOSUB
  7042 CED0 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  7043 CED3 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  7044 CED5 48				PHA				; push on stack
  7045 CED6 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  7046 CED8 48				PHA				; push on stack
  7047 CED9 A5 48			LDA	Clineh			; get current line high byte
  7048 CEDB 48				PHA				; push on stack
  7049 CEDC A5 47			LDA	Clinel			; get current line low byte
  7050 CEDE 48				PHA				; push on stack
  7051 CEDF A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  7052 CEE1 48				PHA				; push on stack
  7053
  7054 CEE2 B9 01 00			LDA	PLUS_1,Y		; get interrupt code pointer low byte
  7055 CEE5 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  7056 CEE7 B9 02 00			LDA	PLUS_2,Y		; get interrupt code pointer high byte
  7057 CEEA 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  7058
  7059 CEEC 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  7060 									; can't RTS, we used the stack! the RTS from the ctrl-c
  7061 									; check will be taken when the RETIRQ/RETNMI/RETURN is
  7062 									; executed at the end of the subroutine
  7063
  7064 				; get byte from input device, no waiting
  7065 				; returns with carry set if byte in A
  7066 CEEF			INGET
  7067 CEEF 20 0D D3			JSR	V_INPT			; call scan input device
  7068 CEF2 B0 09			BCS	LAB_FB95		; if byte go reset timer
  7069
  7070 CEF4 AD 6A 18			LDA	ccnull			; get countdown
  7071 CEF7 F0 09			BEQ	LAB_FB96		; exit if empty
  7072
  7073 CEF9 AD 69 18			LDA	ccbyte			; get last received byte
  7074 CEFC 38				SEC				; flag we got a byte
  7075 CEFD			LAB_FB95
  7076 CEFD A2 00			LDX	#$00			; clear X
  7077 CEFF 8E 6A 18			STX	ccnull			; clear timer because we got a byte
  7078 CF02			LAB_FB96
  7079 CF02 60				RTS
  7080
  7081 				; these routines only enable the interrupts if the set-up flag is set
  7082 				; if not they have no effect
  7083
  7084 				; perform IRQ {ON|OFF|CLEAR}
  7085 CF03			LAB_IRQ
  7086 CF03 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7087 CF05 2C				.byte	$2C			; make next line BIT abs.
  7088
  7089 				; perform NMI {ON|OFF|CLEAR}
  7090 CF06			LAB_NMI
  7091 CF06 A2 03			LDX	#NmiBase		; set pointer to NMI values
  7092 CF08 C9 93			CMP	#TK_ON			; compare with token for ON
  7093 CF0A F0 11			BEQ	LAB_INON		; go turn on interrupt
  7094
  7095 CF0C C9 CA			CMP	#TK_OFF			; compare with token for OFF
  7096 CF0E F0 07			BEQ	LAB_IOFF		; go turn off interrupt
  7097
  7098 CF10 49 A2			EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
  7099 CF12 F0 0E			BEQ	LAB_INEX		; go clear interrupt flags and return
  7100
  7101 CF14 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  7102
  7103 CF17			LAB_IOFF
  7104 CF17 A9 7F			LDA	#$7F			; clear A
  7105 CF19 35 00			AND	PLUS_0,X		; AND with interrupt setup flag
  7106 CF1B 10 05			BPL	LAB_INEX		; go clear interrupt enabled flag and return
  7107
  7108 CF1D			LAB_INON
  7109 CF1D B5 00			LDA	PLUS_0,X		; get interrupt setup flag
  7110 CF1F 0A				ASL				; Shift bit to enabled flag
  7111 CF20 15 00			ORA	PLUS_0,X		; OR with flag byte
  7112 CF22			LAB_INEX
  7113 CF22 95 00			STA	PLUS_0,X		; save interrupt flag byte
  7114 CF24 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer and return
  7115
  7116 				; these routines set up the pointers and flags for the interrupt routines
  7117 				; note that the interrupts are also enabled by these commands
  7118
  7119 				; perform ON IRQ
  7120 CF27			LAB_SIRQ
  7121 CF27 58				CLI				; enable interrupts
  7122 CF28 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7123 CF2A 2C				.byte	$2C			; make next line BIT abs.
  7124
  7125 				; perform ON NMI
  7126 CF2B			LAB_SNMI
  7127 CF2B A2 03			LDX	#NmiBase		; set pointer to NMI values
  7128
  7129 CF2D 86 38			STX	TempB			; save interrupt pointer
  7130 CF2F 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (past token)
  7131 CF32 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  7132 CF35 A5 39			LDA	Smeml			; get start of mem low byte
  7133 CF37 A6 3A			LDX	Smemh			; get start of mem high byte
  7134 CF39 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  7135 CF3C B0 03			BCS	LAB_LFND		; if carry set go set-up interrupt
  7136
  7137 CF3E 4C 4D B6			JMP	LAB_16F7		; else go do 'Undefined statement' error and warm start
  7138
  7139 CF41			LAB_LFND
  7140 CF41 A6 38			LDX	TempB			; get interrupt pointer
  7141 CF43 A5 6A			LDA	Baslnl			; get pointer low byte
  7142 CF45 E9 01			SBC	#$01			; -1 (carry already set for subtract)
  7143 CF47 95 01			STA	PLUS_1,X		; save as interrupt pointer low byte
  7144 CF49 A5 6B			LDA	Baslnh			; get pointer high byte
  7145 CF4B E9 00			SBC	#$00			; subtract carry
  7146 CF4D 95 02			STA	PLUS_2,X		; save as interrupt pointer high byte
  7147
  7148 CF4F A9 C0			LDA	#$C0			; set interrupt enabled/setup bits
  7149 CF51 95 00			STA	PLUS_0,X		; set interrupt flags
  7150 CF53			LAB_IRTS
  7151 CF53 60				RTS
  7152
  7153 				; return from IRQ service, restores the enabled flag.
  7154
  7155 				; perform RETIRQ
  7156 CF54			LAB_RETIRQ
  7157 CF54 D0 FD			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7158
  7159 CF56 A5 06			LDA	IrqBase			; get interrupt flags
  7160 CF58 0A				ASL				; copy setup to enabled (b7)
  7161 CF59 05 06			ORA	IrqBase			; OR in setup flag
  7162 CF5B 85 06			STA	IrqBase			; save enabled flag
  7163 CF5D 4C 54 B6			JMP	LAB_16E8		; go do rest of RETURN
  7164
  7165 				; return from NMI service, restores the enabled flag.
  7166
  7167 				; perform RETNMI
  7168 CF60			LAB_RETNMI
  7169 CF60 D0 F1			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7170
  7171 CF62 A5 03			LDA	NmiBase			; get set-up flag
  7172 CF64 0A				ASL				; copy setup to enabled (b7)
  7173 CF65 05 03			ORA	NmiBase			; OR in setup flag
  7174 CF67 85 03			STA	NmiBase			; save enabled flag
  7175 CF69 4C 54 B6			JMP	LAB_16E8		; go do rest of RETURN
  7176
  7177 				; MAX() MIN() pre process
  7178 CF6C			LAB_MMPP
  7179 CF6C 20 C6 BA			JSR	LAB_EVEZ		; process expression
  7180 CF6F 4C AD BA			JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  7181
  7182 				; perform MAX()
  7183 CF72			LAB_MAX
  7184 CF72 20 A0 CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7185 									; pull FAC2 and compare with FAC1
  7186 CF75 10 FB			BPL	LAB_MAX			; branch if no swap to do
  7187
  7188 CF77 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7189 CF79 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7190 CF7B 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7191 CF7D 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7192 CF80 F0 F0			BEQ	LAB_MAX			; go do next (branch always)
  7193
  7194 				; perform MIN()
  7195 CF82			LAB_MIN
  7196 CF82 20 A0 CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7197 									; pull FAC2 and compare with FAC1
  7198 CF85 30 FB			BMI	LAB_MIN			; branch if no swap to do
  7199
  7200 CF87 F0 F9			BEQ	LAB_MIN			; branch if no swap to do
  7201
  7202 CF89 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7203 CF8B 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7204 CF8D 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7205 CF8F 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7206 CF92 F0 EE			BEQ	LAB_MIN			; go do next (branch always)
  7207
  7208 				; exit routine. don't bother returning to the loop code
  7209 				; check for correct exit, else so syntax error
  7210 CF94			LAB_MMEC
  7211 CF94 C9 29			CMP	#')'			; is it end of function?
  7212 CF96 D0 05			BNE	LAB_MMSE		; if not do MAX MIN syntax error
  7213
  7214 CF98 68				PLA				; dump return address low byte
  7215 CF99 68				PLA				; dump return address high byte
  7216 CF9A 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ')')
  7217
  7218 CF9D			LAB_MMSE
  7219 CF9D 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  7220
  7221 				; check for next, evaluate and return or exit
  7222 				; this is the routine that does most of the work
  7223 CFA0			LAB_PHFA
  7224 CFA0 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  7225 CFA3 C9 2C			CMP	#','			; is there more ?
  7226 CFA5 D0 ED			BNE	LAB_MMEC		; if not go do end check
  7227
  7228 									; push FAC1
  7229 CFA7 20 C6 C8			JSR	LAB_27BA		; round FAC1
  7230 CFAA A5 70			LDA	FAC1_s			; get FAC1 sign
  7231 CFAC 09 7F			ORA	#$7F			; set all non sign bits
  7232 CFAE 25 6D			AND	FAC1_1			; AND FAC1 mantissa1 (AND in sign bit)
  7233 CFB0 48				PHA				; push on stack
  7234 CFB1 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  7235 CFB3 48				PHA				; push on stack
  7236 CFB4 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  7237 CFB6 48				PHA				; push on stack
  7238 CFB7 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  7239 CFB9 48				PHA				; push on stack
  7240
  7241 CFBA 20 7C 00			JSR	LAB_IGBY		; scan and get next BASIC byte (after ',')
  7242 CFBD 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7243 									; else do type mismatch
  7244
  7245 									; pop FAC2 (MAX/MIN expression so far)
  7246 CFC0 68				PLA				; pop exponent
  7247 CFC1 85 73			STA	FAC2_e			; save FAC2 exponent
  7248 CFC3 68				PLA				; pop mantissa3
  7249 CFC4 85 76			STA	FAC2_3			; save FAC2 mantissa3
  7250 CFC6 68				PLA				; pop mantissa1
  7251 CFC7 85 75			STA	FAC2_2			; save FAC2 mantissa2
  7252 CFC9 68				PLA				; pop sign/mantissa1
  7253 CFCA 85 74			STA	FAC2_1			; save FAC2 sign/mantissa1
  7254 CFCC 85 77			STA	FAC2_s			; save FAC2 sign
  7255
  7256 									; compare FAC1 with (packed) FAC2
  7257 CFCE A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  7258 CFD0 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  7259 CFD2 4C 04 C9			JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  7260 									; returns A=$00 if FAC1 = (AY)
  7261 									; returns A=$01 if FAC1 > (AY)
  7262 									; returns A=$FF if FAC1 < (AY)
  7263
  7264 				; perform WIDTH
  7265 CFD5			LAB_WDTH
  7266 CFD5 C9 2C			CMP	#','			; is next byte ','
  7267 CFD7 F0 1B			BEQ	LAB_TBSZ		; if so do tab size
  7268
  7269 CFD9 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  7270 CFDC 8A				TXA				; copy width to A
  7271 CFDD F0 0A			BEQ	LAB_NSTT		; branch if set for infinite line
  7272
  7273 CFDF E0 10			CPX	#$10			; else make min width = 16d
  7274 CFE1 90 45			BCC	TabErr			; if less do function call error and exit
  7275
  7276 				; this next compare ensures that we can't exit WIDTH via an error leaving the
  7277 				; tab size greater than the line length.
  7278 CFE3 E4 24			CPX	TabSiz			; compare with tab size
  7279 CFE5 B0 02			BCS	LAB_NSTT		; branch if >= tab size
  7280
  7281 CFE7 86 24			STX	TabSiz			; else make tab size = terminal width
  7282 CFE9			LAB_NSTT
  7283 CFE9 86 0F			STX	TWidth			; set the terminal width
  7284 CFEB 20 82 00			JSR	LAB_GBYT		; get BASIC byte back
  7285 CFEE F0 1A			BEQ	WExit			; exit if no following
  7286
  7287 CFF0 C9 2C			CMP	#','			; else is it ','
  7288 CFF2 D0 A9			BNE	LAB_MMSE		; if not do syntax error
  7289
  7290 CFF4			LAB_TBSZ
  7291 CFF4 20 76 C4			JSR	LAB_SGBY		; scan and get byte parameter
  7292 CFF7 8A				TXA				; copy TAB size
  7293 CFF8 30 2E			BMI	TabErr			; if >127 do function call error and exit
  7294
  7295 CFFA E0 01			CPX	#$01			; compare with min-1
  7296 CFFC 90 2A			BCC	TabErr			; if <=1 do function call error and exit
  7297
  7298 CFFE A5 0F			LDA	TWidth			; set flags for width
  7299 D000 F0 06			BEQ	LAB_SVTB		; skip check if infinite line
  7300
  7301 D002 E4 0F			CPX	TWidth			; compare TAB with width
  7302 D004 F0 02			BEQ	LAB_SVTB		; ok if =
  7303
  7304 D006 B0 20			BCS	TabErr			; branch if too big
  7305
  7306 D008			LAB_SVTB
  7307 D008 86 24			STX	TabSiz			; save TAB size
  7308
  7309 				; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7310 				; position on a line that still has at least one whole tab width between it
  7311 				; and the end of the line.
  7312 D00A			WExit
  7313 D00A A5 0F			LDA	TWidth			; get width
  7314 D00C F0 06			BEQ	LAB_SULP		; branch if infinite line
  7315
  7316 D00E C5 24			CMP	TabSiz			; compare with tab size
  7317 D010 B0 03			BCS	LAB_WDLP		; branch if >= tab size
  7318
  7319 D012 85 24			STA	TabSiz			; else make tab size = terminal width
  7320 D014			LAB_SULP
  7321 D014 38				SEC				; set carry for subtract
  7322 D015			LAB_WDLP
  7323 D015 E5 24			SBC	TabSiz			; subtract tab size
  7324 D017 B0 FC			BCS	LAB_WDLP		; loop while no borrow
  7325
  7326 D019 65 24			ADC	TabSiz			; add tab size back
  7327 D01B 18				CLC				; clear carry for add
  7328 D01C 65 24			ADC	TabSiz			; add tab size back again
  7329 D01E 85 10			STA	Iclim			; save for now
  7330 D020 A5 0F			LDA	TWidth			; get width back
  7331 D022 38				SEC				; set carry for subtract
  7332 D023 E5 10			SBC	Iclim			; subtract remainder
  7333 D025 85 10			STA	Iclim			; save tab column limit
  7334 D027			LAB_NOSQ
  7335 D027 60				RTS
  7336
  7337 D028			TabErr
  7338 D028 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  7339
  7340 				; perform SQR()
  7341 D02B			LAB_SQR
  7342 D02B A5 70			LDA	FAC1_s			; get FAC1 sign
  7343 D02D 30 F9			BMI	TabErr			; if -ve do function call error
  7344
  7345 D02F A5 6C			LDA	FAC1_e			; get exponent
  7346 D031 F0 F4			BEQ	LAB_NOSQ		; if zero just return
  7347
  7348 									; else do root
  7349 D033 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  7350 D036 A9 00			LDA	#$00			; clear A
  7351
  7352 D038 85 37			STA	FACt_3			; clear remainder
  7353 D03A 85 36			STA	FACt_2			; ..
  7354 D03C 85 35			STA	FACt_1			; ..
  7355 D03E 85 38			STA	TempB			; ..
  7356
  7357 D040 85 6F			STA	FAC1_3			; clear root
  7358 D042 85 6E			STA	FAC1_2			; ..
  7359 D044 85 6D			STA	FAC1_1			; ..
  7360
  7361 D046 A2 18			LDX	#$18			; 24 pairs of bits to do
  7362 D048 A5 73			LDA	FAC2_e			; get exponent
  7363 D04A 4A				LSR				; check odd/even
  7364 D04B B0 0E			BCS	LAB_SQE2		; if odd only 1 shift first time
  7365
  7366 D04D			LAB_SQE1
  7367 D04D 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7368 D04F 26 75			ROL	FAC2_2			; ..
  7369 D051 26 74			ROL	FAC2_1			; ..
  7370 D053 26 37			ROL	FACt_3			; .. into remainder
  7371 D055 26 36			ROL	FACt_2			; ..
  7372 D057 26 35			ROL	FACt_1			; ..
  7373 D059 26 38			ROL	TempB			; .. never overflows
  7374 D05B			LAB_SQE2
  7375 D05B 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7376 D05D 26 75			ROL	FAC2_2			; ..
  7377 D05F 26 74			ROL	FAC2_1			; ..
  7378 D061 26 37			ROL	FACt_3			; .. into remainder
  7379 D063 26 36			ROL	FACt_2			; ..
  7380 D065 26 35			ROL	FACt_1			; ..
  7381 D067 26 38			ROL	TempB			; .. never overflows
  7382
  7383 D069 06 6F			ASL	FAC1_3			; root = root * 2
  7384 D06B 26 6E			ROL	FAC1_2			; ..
  7385 D06D 26 6D			ROL	FAC1_1			; .. never overflows
  7386
  7387 D06F A5 6F			LDA	FAC1_3			; get root low byte
  7388 D071 2A				ROL				; *2
  7389 D072 85 1B			STA	Temp3			; save partial low byte
  7390 D074 A5 6E			LDA	FAC1_2			; get root low mid byte
  7391 D076 2A				ROL				; *2
  7392 D077 85 1C			STA	Temp3+1			; save partial low mid byte
  7393 D079 A5 6D			LDA	FAC1_1			; get root high mid byte
  7394 D07B 2A				ROL				; *2
  7395 D07C 85 1D			STA	Temp3+2			; save partial high mid byte
  7396 D07E A9 00			LDA	#$00			; get root high byte (always $00)
  7397 D080 2A				ROL				; *2
  7398 D081 85 1E			STA	Temp3+3			; save partial high byte
  7399
  7400 									; carry clear for subtract +1
  7401 D083 A5 37			LDA	FACt_3			; get remainder low byte
  7402 D085 E5 1B			SBC	Temp3			; subtract partial low byte
  7403 D087 85 1B			STA	Temp3			; save partial low byte
  7404
  7405 D089 A5 36			LDA	FACt_2			; get remainder low mid byte
  7406 D08B E5 1C			SBC	Temp3+1			; subtract partial low mid byte
  7407 D08D 85 1C			STA	Temp3+1			; save partial low mid byte
  7408
  7409 D08F A5 35			LDA	FACt_1			; get remainder high mid byte
  7410 D091 E5 1D			SBC	Temp3+2			; subtract partial high mid byte
  7411 D093 A8				TAY				; copy partial high mid byte
  7412
  7413 D094 A5 38			LDA	TempB			; get remainder high byte
  7414 D096 E5 1E			SBC	Temp3+3			; subtract partial high byte
  7415 D098 90 0E			BCC	LAB_SQNS		; skip sub if remainder smaller
  7416
  7417 D09A 85 38			STA	TempB			; save remainder high byte
  7418
  7419 D09C 84 35			STY	FACt_1			; save remainder high mid byte
  7420
  7421 D09E A5 1C			LDA	Temp3+1			; get remainder low mid byte
  7422 D0A0 85 36			STA	FACt_2			; save remainder low mid byte
  7423
  7424 D0A2 A5 1B			LDA	Temp3			; get partial low byte
  7425 D0A4 85 37			STA	FACt_3			; save remainder low byte
  7426
  7427 D0A6 E6 6F			INC	FAC1_3			; increment root low byte (never any rollover)
  7428 D0A8			LAB_SQNS
  7429 D0A8 CA				DEX				; decrement bit pair count
  7430 D0A9 D0 A2			BNE	LAB_SQE1		; loop if not all done
  7431
  7432 D0AB 38				SEC				; set carry for subtract
  7433 D0AC A5 73			LDA	FAC2_e			; get exponent
  7434 D0AE E9 80			SBC	#$80			; normalise
  7435 D0B0 6A				ROR				; /2 and re-bias to $80
  7436 D0B1 69 00			ADC	#$00			; add bit zero back in (allow for half shift)
  7437 D0B3 85 6C			STA	FAC1_e			; save it
  7438 D0B5 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  7439
  7440 				; perform VARPTR()
  7441 D0B8			LAB_VARPTR
  7442 D0B8 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  7443 D0BB 20 89 BD			JSR	LAB_GVAR		; get var address
  7444 D0BE 20 CC BB			JSR	LAB_1BFB		; scan for ')" , else do syntax error then warm start
  7445 D0C1 A4 55			LDY	Cvaral			; get var address low byte
  7446 D0C3 A5 56			LDA	Cvarah			; get var address high byte
  7447 D0C5 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  7448
  7449 				; perform PI
  7450 D0C8			LAB_PI
  7451 D0C8 A9 D0			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7452 D0CA A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7453 D0CC 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  7454 D0CF C6 6C			DEC	FAC1_e			; make result = PI
  7455 D0D1 60				RTS
  7456
  7457 				; perform TWOPI
  7458 D0D2			LAB_TWOPI
  7459 D0D2 A9 D0			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7460 D0D4 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7461 D0D6 4C 6A C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
  7462 					
  7463 				; *****************************************
  7464 				; ** New Commands For Junior Computer 2 ***
  7465 				; *****************************************
  7466 D0D9			LAB_MOD
  7467 D0D9 60				RTS
  7468 				;	LDX	#$04
  7469 				;LAB_STO_FAC2
  7470 				;	LDA	FAC2_e,X
  7471 				;	PHA
  7472 				;	DEX
  7473 				;	BPL	LAB_STO_FAC2
  7474 D0DA A2 04			LDX	#$04
  7475 D0DC			LAB_STO_FAC1
  7476 D0DC B5 6C			LDA	FAC1_e,X
  7477 D0DE 48				PHA
  7478 D0DF CA				DEX
  7479 D0E0 10 FA			BPL	LAB_STO_FAC1
  7480
  7481 D0E2 20 F1 C7			JSR 	LAB_DIVIDE
  7482 D0E5 20 6E C9			JSR	LAB_INT
  7483
  7484 D0E8 20 BA C8			JSR	LAB_27AE
  7485 				;	LDX	#$00
  7486 				;	STX	FAC1_r
  7487 				;LAB_LOD_FAC2_1
  7488 				;	PLA
  7489 				;	STA	FAC1_e,X
  7490 				;	INX
  7491 				;	CPX	#$05
  7492 				;	BNE	LAB_LOD_FAC2_1
  7493
  7494 					;JSR	LAB_MULTIPLY
  7495 					
  7496 D0EB A2 00			LDX	#$00
  7497 D0ED			LAB_LOD_FAC2_2
  7498 D0ED 68				PLA
  7499 D0EE 95 6C			STA	FAC1_e,X
  7500 D0F0 E8				INX
  7501 D0F1 E0 05			CPX	#$05
  7502 D0F3 D0 F8			BNE	LAB_LOD_FAC2_2
  7503
  7504 					;JSR	LAB_SUBTRACT
  7505 D0F5 4C 29 C7			JMP	LAB_MULTIPLY		; call routine and return
  7506
  7507 				; Call Device Command Routine *************
  7508 D0F8			CALL_CMD
  7509 D0F8 6C 6C 1A			JMP	(DEVCMD)		; current opened device command vector (Junior Computer 2)
  7510
  7511 				; Get Null Terminated String Parameter ****
  7512 D0FB			LAB_GETSTRPARM
  7513 D0FB 85 1A			STA	Temp1
  7514 D0FD 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  7515 D100 A5 1F			LDA	Dtypef			; is it a string expression
  7516 D102 D0 03			BNE	LAB_GETSTR0		; yes, get string				
  7517 D104 20 B9 BA			JSR	LAB_1ABC		; no, throw type mismatch error
  7518 D107			LAB_GETSTR0
  7519 D107 A0 00			LDY	#$00			; set string index to 0
  7520 D109			LAB_GETSTR1
  7521 D109 B1 78			LDA	(ssptr_l),Y		; load a string char
  7522 D10B F0 0B			BEQ	LAB_GETSTR2		; is it a NULL? yes, exit
  7523 D10D C9 22			CMP	#'"'			; is it a '"'?
  7524 D10F F0 03			BEQ	LAB_TERM		; yes, set string termination
  7525 D111 C8				INY				; increment string index
  7526 D112 D0 F5			BNE	LAB_GETSTR1		; and repeat loop
  7527 D114			LAB_TERM
  7528 D114 A9 00			LDA 	#$00			; store termination char
  7529 D116 91 78			STA 	(ssptr_l),Y		; at the end of the string
  7530 D118			LAB_GETSTR2
  7531 D118 A6 78			LDX	ssptr_l			; load string pointer low byte into X
  7532 D11A A4 79			LDY	ssptr_h			; load string pointer high byte into X
  7533 D11C A5 1A			LDA	Temp1
  7534 D11E 60				RTS
  7535
  7536 				; Get Device Parameters *******************
  7537 D11F			LAB_GETDEVPARM
  7538 D11F 20 79 C4			JSR	LAB_GTBY		; scan for byte value
  7539 D122 8A				TXA				; and set A to result
  7540 D123 F0 08			BEQ	LAB_DEV0		; device is 0, no more parameters needed
  7541 D125 85 1A			STA	Temp1			; save device number
  7542 D127 20 DB BB			JSR	LAB_1C01		; check for ','
  7543 D12A A5 1A			LDA	Temp1
  7544 D12C 60				RTS
  7545 D12D			LAB_DEV0
  7546 D12D 4C CE BB			JMP	LAB_SCCA		; check if more token, if so throw syntax error
  7547
  7548 				; Get Two Byte Parameters *****************
  7549 D130			LAB_GET2BYTEPARMS
  7550 					;JSR	LAB_EVBY		; evaluate byte expression, result in X
  7551 D130 20 79 C4			JSR	LAB_GTBY		; get first byte parameter into X
  7552 D133 86 1A			STX	Temp1			; and store it in temp var
  7553 D135 20 DB BB			JSR	LAB_1C01		; check for ',' else syntax error
  7554 D138 20 79 C4			JSR	LAB_GTBY		; get second byte parameter into X
  7555 D13B 8A				TXA
  7556 D13C A8				TAY				; and transfer it into Y
  7557 D13D A6 1A			LDX	Temp1			; restore first parameter into X
  7558 D13F 60				RTS
  7559
  7560 				; get device number parameter *************
  7561 D140			LAB_GETDEVID
  7562 D140 20 79 C4			JSR	LAB_GTBY		; get byte parameter into X
  7563 D143 8A				TXA				; and transfer it into A
  7564 D144 09 10			ORA	#$10			; search for stdio devices
  7565 D146 60				RTS
  7566
  7567 				; Select GPIO Device **********************
  7568 D147			LAB_SEL_PORT
  7569 D147 E0 01			CPX	#$01
  7570 D149 D0 04			BNE	LAB_PORTA
  7571 D14B A0 00			LDY	#VIA_PORTB
  7572 D14D 18				CLC
  7573 D14E 60				RTS
  7574 D14F			LAB_PORTA
  7575 D14F E0 02			CPX	#$02
  7576 D151 B0 02			BCS	LAB_I2C_ADR	
  7577 D153 A0 01			LDY	#VIA_PORTA
  7578 D155			LAB_I2C_ADR
  7579 D155 60				RTS
  7580
  7581 				; perform LOAD ****************************
  7582 D156			LAB_LOAD 
  7583 D156 D0 04			BNE	LOAD_DEV		; if no following token use device 0
  7584 D158 A9 00			LDA	#$00			; set device id = 0
  7585 D15A F0 03			BEQ	SET_LOADADR		; branch always
  7586 D15C			LOAD_DEV
  7587 D15C 20 1F D1			JSR	LAB_GETDEVPARM		; get device id
  7588 D15F			SET_LOADADR
  7589 D15F 48				PHA
  7590 D160 A2 00			LDX	#$00
  7591 D162 86 FA			STX	ADRL			; set load destination address low, needed by XModem routines
  7592 D164 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7593 D166 A2 B0			LDX	#>RAM_TOP		; Highest RAM load-address for BASIC
  7594 D168 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7595 D16A A2 20			LDX	#$20
  7596 D16C 86 FB			STX	ADRH			; set load destination address high, needed by XModem routines
  7597 D16E 86 FF			STX	MODE			; Set to a non-zero value so that XModemRcv uses ADRL/ADRH as dest. address
  7598 D170 09 20			ORA	#$20			; it's a storage device
  7599 D172 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7600 D175 68				PLA
  7601 D176 F0 03			BEQ	CALL_LOAD		; device id = 0?
  7602 D178 20 FB D0			JSR	LAB_GETSTRPARM		; no, get string parameter
  7603 D17B			CALL_LOAD
  7604 D17B A9 20			LDA	#CMD_LOAD
  7605 D17D 20 F8 D0			JSR	CALL_CMD		; call load command
  7606 D180 90 40			BCC	CLEAR_BASE		; load interrupted, exit
  7607 D182 AE 00 20			LDX	Ram_base-1
  7608 D185 86 3B			STX	Svarl
  7609 D187 AE 01 20			LDX	Ram_base
  7610 D18A 86 3C			STX	Svarh
  7611 D18C 20 C2 D1			JSR	CLEAR_BASE
  7612 D18F 4C 55 B3			JMP	LAB_147A
  7613
  7614 				; perform SAVE ****************************
  7615 D192			LAB_SAVE
  7616 D192 D0 04			BNE	SAVE_DEV		; if no following token use device 0
  7617 D194 A9 00			LDA	#$00			; set device id = 0
  7618 D196 F0 03			BEQ	SET_SAVEADR
  7619 D198			SAVE_DEV
  7620 D198 20 1F D1			JSR	LAB_GETDEVPARM		; get device id
  7621 D19B			SET_SAVEADR
  7622 D19B 48				PHA
  7623 D19C A2 00			LDX	#$00			; Basic-files start at $2000
  7624 D19E 86 FA			STX	ADRL			; Start of File pointer LSB, needed by XModem routines
  7625 D1A0 A2 20			LDX	#$20			
  7626 D1A2 86 FB			STX	ADRH			; Start of File pointer MSB, needed by XModem routines
  7627 D1A4 A6 3B			LDX	Svarl
  7628 D1A6 8E 00 20			STX	Ram_base-1
  7629 D1A9 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7630 D1AB A6 3C			LDX	Svarh
  7631 D1AD 8E 01 20			STX	Ram_base
  7632 D1B0 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7633 D1B2 09 20			ORA	#$20			; Disk-devices
  7634 D1B4 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7635 D1B7 68				PLA
  7636 D1B8 F0 03			BEQ	CALL_SAVE
  7637 D1BA 20 FB D0			JSR	LAB_GETSTRPARM		; X,Y = Ptr to Filename
  7638 D1BD			CALL_SAVE
  7639 D1BD A9 21			LDA	#CMD_SAVE
  7640 D1BF 20 F8 D0			JSR	CALL_CMD		; Device-driver Write
  7641 D1C2			CLEAR_BASE
  7642 D1C2 A2 00			LDX	#$00
  7643 D1C4 8E 00 20			STX	Ram_base-1
  7644 D1C7 8E 01 20			STX	Ram_base
  7645 D1CA 60				RTS
  7646 					
  7647 				; 'BEEP' command **************************
  7648 D1CB			LAB_JC001
  7649 D1CB 6C 66 1A			JMP 	(STDBEEP)		; Jump to Junior Computer standard BEEP routine
  7650
  7651 				; perform BEEP ****************************
  7652 D1CE			LAB_BEEP
  7653 D1CE F0 FB			BEQ 	LAB_JC001		; if no following token go do 'BEEP'
  7654 D1D0 60				RTS
  7655
  7656 D1D1			LAB_SYSBEEP
  7657 D1D1 48				PHA
  7658 D1D2 98				TYA
  7659 D1D3 48				PHA
  7660 D1D4 8A				TXA
  7661 D1D5 48				PHA
  7662 D1D6 20 CB D1			JSR	LAB_JC001
  7663 D1D9 68				PLA
  7664 D1DA AA				TAX
  7665 D1DB 68				PLA
  7666 D1DC A8				TAY
  7667 D1DD 68				PLA
  7668 D1DE 60				RTS	
  7669 					
  7670 				; perform PLIST ***************************
  7671 				; #### TODO: save current output device and restore pointer after list command !!!!!!!
  7672 D1DF			LAB_PLIST
  7673 D1DF 48			    	PHA				; save token
  7674 D1E0 AD 76 1A		    	LDA	STDPRINTDEV		; get standard printer id
  7675 D1E3 20 18 E0			JSR	SET_STDOUTID		; and set it as standard output device
  7676 D1E6 68				PLA				; restore token
  7677 D1E7 20 84 B3			JSR 	LAB_LIST		; call list command
  7678 D1EA AD 75 1A			LDA	STDOUTDEV		; get standard output device id
  7679 D1ED 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device and return
  7680
  7681 				; perform DOS ****************************
  7682 D1F0			LAB_DOS					; If no DOS is loaded, this could hang the system!
  7683 D1F0 6C 0A 18			JMP 	(RETURN_VECT)		; Return to DOS through return vector
  7684
  7685 				; perform HOME ****************************
  7686 D1F3			LAB_HOME
  7687 D1F3 A9 05			LDA	#CMD_HOME		; Call Junior Computer standard HOME routine
  7688 D1F5 D0 0E			BNE	STDCMD_JMP		; branch always
  7689
  7690 				; perform CLS *****************************
  7691 D1F7			LAB_CLS
  7692 D1F7 A9 07			LDA	#CMD_CLRSCRN		; Call Junior Computer standard CLS routine
  7693 D1F9 D0 0A			BNE	STDCMD_JMP		; branch always
  7694
  7695 				; perform NORMAL **************************
  7696 D1FB			LAB_NORMAL
  7697 D1FB A9 02			LDA	#CMD_NORMAL		; Call Junior Computer standard NORMAL routine
  7698 D1FD D0 06			BNE	STDCMD_JMP		; branch always
  7699
  7700 				; perform INVERSE *************************
  7701 D1FF			LAB_INVERSE
  7702 D1FF A9 03			LDA	#CMD_INVERSE		; Call Junior Computer standard INVERSE routine
  7703 D201 D0 02			BNE	STDCMD_JMP		; branch always
  7704
  7705 				; perform FLASH ***************************
  7706 D203			LAB_FLASH
  7707 D203 A9 04			LDA	#CMD_FLASH		; Call Junior Computer standard FLASH routine
  7708 D205			STDCMD_JMP
  7709 D205 6C 72 1A			JMP 	(STDCMD)		; call STDOUT routine
  7710 					
  7711 				; perform LOCATE **************************
  7712 D208			LAB_LOCATE
  7713 D208 F0 36			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7714 D20A 20 30 D1			JSR	LAB_GET2BYTEPARMS	; get two byte parameters into X and Y
  7715 D20D A9 08			LDA	#CMD_SETCURSOR
  7716 D20F 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard SETCURSOR routine
  7717
  7718 				; perform IN# *****************************
  7719 D212			LAB_INNUM
  7720 D212 F0 2C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7721 D214 20 40 D1			JSR	LAB_GETDEVID
  7722 D217 4C 2F E0			JMP	SET_STDINID		; Set Standard In Routine ID
  7723
  7724 				; perform PR# *****************************
  7725 D21A			LAB_PRNUM
  7726 D21A F0 24			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7727 D21C 20 40 D1			JSR	LAB_GETDEVID
  7728 D21F 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device
  7729
  7730 				; perform PORTIO **************************
  7731 D222			LAB_PORTIO
  7732 D222 F0 1C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7733 D224 20 30 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters
  7734 D227 98				TYA
  7735 D228 20 47 D1			JSR	LAB_SEL_PORT		; get port
  7736 D22B B0 04			BCS	LAB_I2C_DEV
  7737 D22D C8				INY				; add 2 because we want to write DDR
  7738 D22E C8				INY
  7739 D22F 91 14			STA	(IOBASE),Y
  7740 D231			LAB_I2C_DEV
  7741 D231 60				RTS
  7742
  7743 				; perform PORTOUT *************************
  7744 D232			LAB_PORTOUT
  7745 D232 F0 0C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7746 D234 20 30 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters
  7747 D237 98				TYA
  7748 D238 20 47 D1			JSR	LAB_SEL_PORT		; get port
  7749 D23B B0 06			BCS	LAB_WRITEI2C		; port id > 1 -> write to i2c port
  7750 D23D 91 14			STA	(IOBASE),Y
  7751 D23F 60				RTS
  7752
  7753 D240			LAB_SYNTAX_ERR
  7754 D240 4C DF BB			JMP	LAB_SNER		; throw syntax error and return
  7755
  7756 				; perform WRITEI2C ************************
  7757 D243			LAB_WRITEI2C
  7758 D243 85 1A			STA	Temp1			; save data byte to Temp1
  7759 D245 20 26 E3			JSR	I2C_START		; Send I2C Start Condition
  7760 D248 8A				TXA				; transfer device address into A
  7761 D249 20 66 E3			JSR	I2C_WRITE_DEV		; Write I2C Device, set write mode. C = 1 acknowledged
  7762 D24C A5 1A			LDA	Temp1			; restore data byte to A
  7763 D24E 20 67 E3			JSR	I2C_SEND		; Send a Byte to I2C Device, C = 1 acknowledged
  7764 D251 4C 35 E3			JMP	I2C_STOP		; Send I2C Stop Condition and return
  7765
  7766 				; perform I2C write operations ************
  7767 D254			LAB_I2COUT
  7768 D254 F0 EA			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7769 D256 20 30 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters: X=addr, Y=ctrl
  7770 D259 86 1A			STX	Temp1			; Temp1=X=addr/data byte
  7771 D25B 98				TYA				; A=ctrl byte
  7772 D25C C9 01			CMP	#I2C_STA		; I2C-start?
  7773 D25E D0 08			BNE	I2C_WR			; branch if not I2C-start
  7774 					
  7775 D260 20 26 E3			JSR	I2C_START		; send start condition (affects A and Y)
  7776 D263 E0 00			CPX	#$00			; Is address byte 0?
  7777 D265 D0 01			BNE	I2C_WR			; branch if address byte > 0
  7778 D267 60				RTS				; otherwise, just return
  7779
  7780 D268 A5 1A		I2C_WR	LDA	Temp1			; restore data byte to A
  7781 D26A 20 67 E3			JSR	I2C_SEND		; I2C-write: write byte
  7782 D26D 90 04			BCC	SET_NAK			; C=0: NACK, C=1: ACK, branch if NACK
  7783
  7784 D26F A9 00			LDA	#0			; return I2C ACK (0)
  7785 D271 F0 02			BEQ	SV_NAK			; branch always
  7786 D273 A9 01		SET_NAK	LDA	#1			; return I2C NACK (1)
  7787 D275 85 9C		SV_NAK	STA	I2Cstat			; save in I2C status
  7788 D277 60				RTS
  7789
  7790 				; perform I2C read operations ************
  7791 D278			LAB_I2CIN
  7792 D278 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer (Itempl)
  7793 D27B A5 11			LDA	Itempl			; get byte via temporary integer
  7794 D27D C9 03			CMP	#I2C_STO		; I2C-stop command only?
  7795 D27F F0 17			BEQ	I2C_STOP_CMD		; branch if stop-command only
  7796
  7797 D281 C9 00			CMP	#I2C_STAT		; Return I2Cstat result?
  7798 D283 F0 16			BEQ	I2C_RD_X		; branch if I2Cstat return only
  7799
  7800 D285 20 9F E3			JSR	I2C_RCV			; I2C-read: receive byte 
  7801 D288 85 9C			STA	I2Cstat			; save received byte
  7802 D28A A5 11			LDA	Itempl			; get ctrl byte back
  7803 D28C C9 01			CMP	#I2C_RD_ACK		; Read followed by ACK?
  7804 D28E D0 05			BNE	RD_NAK			; branch if not an ACK
  7805 					
  7806 D290 20 44 E3			JSR	I2C_ACK			; send ACK (more bytes to read) and return
  7807 D293 D0 06			BNE	I2C_RD_X		; branch always
  7808 					
  7809 D295 20 53 E3		RD_NAK	JSR	I2C_NACK		; send NACK (done reading)
  7810 D298			I2C_STOP_CMD
  7811 D298 20 35 E3			JSR	I2C_STOP		; send I2C-stop Command
  7812 D29B			I2C_RD_X
  7813 D29B A4 9C			LDY	I2Cstat			; load I2C-status byte in Y
  7814 D29D 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7815 					
  7816 				; perform PORTIN **************************
  7817 D2A0			LAB_PORTIN
  7818 D2A0 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  7819 D2A3 20 47 D1			JSR	LAB_SEL_PORT		; get port
  7820 D2A6 B0 06			BCS	LAB_READI2C		; port id > 1 -> read from i2c port
  7821 D2A8 B1 14			LDA	(IOBASE),Y
  7822 D2AA A8				TAY				; copy received byte into Y
  7823 D2AB 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7824
  7825 				; perform READI2C *************************
  7826 D2AE			LAB_READI2C
  7827 D2AE 20 26 E3			JSR	I2C_START		; Send I2C Start Condition
  7828 D2B1 8A				TXA				; transfer device address into A
  7829 D2B2 20 62 E3			JSR	I2C_READ_DEV		; Read I2C Device, set read mode. Return C = 1 acknowledged
  7830 D2B5 20 9F E3			JSR	 I2C_RCV		; Receive a Byte from I2C Device 
  7831 D2B8 85 1A			STA	Temp1
  7832 D2BA 20 35 E3			JSR	I2C_STOP		; Send I2C Stop Condition
  7833 D2BD A4 1A			LDY	Temp1			; load byte to Y
  7834 D2BF 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7835
  7836 				; perform DELAY *************************
  7837 D2C2			LAB_DELAY
  7838 D2C2 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7839 									; else do type mismatch
  7840 D2C5 20 81 BE			JSR	LAB_EVPI		; evaluate positive integer expression
  7841 D2C8 A5 15			LDA	IOBASE+1
  7842 D2CA F0 2F			BEQ	LAB_DELAY_OLD		; check if IO is available (needed for RAM based EhBasic only)
  7843 D2CC A0 0E			LDY	#VIA_IER		; select interrupt enable register
  7844 D2CE A9 7F			LDA	#$7F
  7845 D2D0 91 14			STA	(IOBASE),Y		; disable all VIA2 interrupts
  7846 D2D2			LAB_DELAY_LOOP
  7847 D2D2 A0 08			LDY	#VIA_T2CL		; select Timer2 lower byte register
  7848 D2D4 A9 E8			LDA	#$E8			; set Timer2
  7849 D2D6 91 14			STA	(IOBASE),Y		; store timer low value
  7850 D2D8 A9 03			LDA	#$03
  7851 D2DA C8				INY				; select Timer2 higher byte register
  7852 D2DB 91 14			STA	(IOBASE),Y		; store timer high value and start timer
  7853 D2DD A0 0D			LDY	#VIA_IFR		; select interrupt flag register
  7854 D2DF A5 6E			LDA	FAC1_2
  7855 D2E1 D0 04			BNE	LAB_WAIT_TIMER
  7856 D2E3 A5 6F			LDA	FAC1_3
  7857 D2E5 F0 13			BEQ	LAB_DELAY_END
  7858 D2E7			LAB_WAIT_TIMER
  7859 D2E7 B1 14			LDA	(IOBASE),Y
  7860 D2E9 29 20			AND	#$20
  7861 D2EB F0 FA			BEQ	LAB_WAIT_TIMER
  7862 D2ED C6 6F			DEC	FAC1_3
  7863 D2EF A5 6F			LDA	FAC1_3
  7864 D2F1 C9 FF			CMP	#$FF
  7865 D2F3 D0 DD			BNE	LAB_DELAY_LOOP
  7866 D2F5 C6 6E			DEC	FAC1_2
  7867 D2F7 4C D2 D2			JMP	LAB_DELAY_LOOP
  7868 D2FA			LAB_DELAY_END
  7869 D2FA 60				RTS
  7870
  7871 D2FB			LAB_DELAY_OLD
  7872 D2FB A6 6E			LDX	FAC1_2
  7873 D2FD F0 FB			BEQ	LAB_DELAY_END
  7874 D2FF			LAB_SET_TIMER
  7875 D2FF A5 6F			LDA	FAC1_3
  7876 D301 20 4D E1			JSR	DELAY			; Delay routine
  7877 D304 A9 FF			LDA	#$FF
  7878 D306 85 6F			STA	FAC1_3
  7879 D308 CA				DEX
  7880 D309 D0 F4			BNE	LAB_SET_TIMER
  7881 D30B 60				RTS
  7882
  7883 				; *****************************************
  7884
  7885 D30C			LAB_SCREEN	
  7886 D30C			LAB_PIXEL
  7887 D30C			LAB_LINE	
  7888 D30C			LAB_OVAL
  7889 D30C			LAB_COLOR
  7890 D30C			LAB_RECT
  7891 							
  7892 D30C			LAB_RES5
  7893 D30C			LAB_RES6
  7894 D30C 60				RTS
  7895
  7896 				; **** end of new commands ****
  7897
  7898
  7899 				; system dependent i/o vectors
  7900 				; these are in RAM and are set by the monitor at start-up
  7901
  7902 D30D 6C 6E 1A		V_INPT	JMP	(STDIN)			; non halting scan input device vector (Junior Computer 2)
  7903 D310 6C 70 1A		V_OUTP	JMP	(STDOUT)		; send byte to output device vector (Junior Computer 2)
  7904
  7905 				; The rest are tables messages and code for RAM
  7906
  7907 				; the rest of the code is tables and BASIC start-up code
  7908
  7909 D313			PG2_TABS
  7910 D313 00				.byte	$00			; ctrl-c flag		-	$00 = enabled
  7911 D314 00				.byte	$00			; ctrl-c byte		-	GET needs this
  7912 D315 00				.byte	$00			; ctrl-c byte timeout	-	GET needs this
  7913 D316 97 CE			.word	CTRLC			; ctrl c check vector
  7914 				;	.word	xxxx			; non halting key input	-	monitor to set this
  7915 				;	.word	xxxx			; output vector		-	monitor to set this
  7916 				;	.word	xxxx			; load vector		-	monitor to set this
  7917 				;	.word	xxxx			; save vector		-	monitor to set this
  7918 D318			PG2_TABE
  7919
  7920 				; character get subroutine for zero page
  7921
  7922 				; For a 1.8432MHz 6502 including the JSR and RTS
  7923 				; fastest (>=':')	=  29 cycles =  15.7uS
  7924 				; slowest (<':')	=  40 cycles =  21.7uS
  7925 				; space skip	= +21 cycles = +11.4uS
  7926 				; inc across page	=  +4 cycles =  +2.2uS
  7927
  7928 				; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7929 				; block is copied to it's destination, any non zero page address will do at assembly
  7930 				; time, to assemble a three byte instruction.
  7931
  7932 				; page 0 initialisation table from $BC
  7933 				; increment and scan memory
  7934 D318			LAB_2CEE
  7935 D318 E6 83			INC	Bpntrl			; increment BASIC execute pointer low byte
  7936 D31A D0 02			BNE	LAB_2CF4		; branch if no carry
  7937 									; else
  7938 D31C E6 84			INC	Bpntrh			; increment BASIC execute pointer high byte
  7939
  7940 				; page 0 initialisation table from $C2
  7941 				; scan memory
  7942 D31E			LAB_2CF4
  7943 D31E AD FF FF			LDA	$FFFF			; get byte to scan (addr set by call routine)
  7944 D321 C9 C1			CMP	#TK_ELSE		; compare with the token for ELSE
  7945 D323 F0 0E			BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
  7946
  7947 D325 C9 3A			CMP	#':'			; compare with ':'
  7948 D327 B0 0A			BCS	LAB_2D05		; exit if >= ':', not numeric, carry set
  7949
  7950 D329 C9 20			CMP	#' '			; compare with ' '
  7951 D32B F0 EB			BEQ	LAB_2CEE		; if ' ' go do next
  7952
  7953 D32D 38				SEC				; set carry for SBC
  7954 D32E E9 30			SBC	#'0'			; subtract '0'
  7955 D330 38				SEC				; set carry for SBC
  7956 D331 E9 D0			SBC	#$D0			; subtract -'0'
  7957 									; clear carry if byte = '0'-'9'
  7958 D333			LAB_2D05
  7959 D333 60				RTS
  7960
  7961 				; page zero initialisation table $00-$12 inclusive
  7962 D334			StrTab
  7963 D334 4C				.byte	$4C			; JMP opcode
  7964 D335 00 B0			.word 	LAB_COLD		; initial warm start vector (cold start)
  7965
  7966 D337 00				.byte	$00			; these bytes are not used by BASIC
  7967 D338 00 00			.word	$0000			; 
  7968 D33A 00 00			.word	$0000			; 
  7969 D33C 00 00			.word	$0000			; 
  7970
  7971 D33E 4C				.byte	$4C			; JMP opcode
  7972 D33F 08 BF			.word	LAB_FCER		; initial user function vector ('Function call' error)
  7973 D341 00				.byte	$00			; default NULL count
  7974 D342 00				.byte	$00			; clear terminal position
  7975 D343 00				.byte	$00			; default terminal width byte
  7976 D344 F2				.byte	$F2			; default limit for TAB = 14
  7977 D345 01 20			.word	Ram_base		; start of user RAM
  7978 D347			EndTab
  7979
  7980 D347			LAB_MSZM
  7981 D347 45 6E 68 61 6E 63 + 	.by	'Enhanced BASIC 2.28',$0A,$00
  7982 				;	.byte	$0D,$0A,'Memory size ',$00
  7983
  7984 D35C			LAB_SMSG
  7985 D35C 20 42 61 73 69 63 + 	.by	' Basic Bytes free',$0D,$0A,$0A,$00
  7986 				;	.byte	'Enhanced BASIC 2.25',$0A,$00
  7987
  7988 				; numeric constants and series
  7989
  7990 									; constants and series for LOG(n)
  7991 D371			LAB_25A0
  7992 D371 02				.byte	$02			; counter
  7993 D372 80 19 56 62			.byte	$80,$19,$56,$62		; 0.59898
  7994 D376 80 76 22 F3			.byte	$80,$76,$22,$F3		; 0.96147
  7995 				;##	.byte	$80,$76,$22,$F1		; 0.96147
  7996 D37A 82 38 AA 40			.byte	$82,$38,$AA,$40		; 2.88539
  7997 				;##	.byte	$82,$38,$AA,$45		; 2.88539
  7998
  7999 D37E			LAB_25AD
  8000 D37E 80 35 04 F3			.byte	$80,$35,$04,$F3		; 0.70711	1/root 2
  8001 D382			LAB_25B1
  8002 D382 81 35 04 F3			.byte	$81,$35,$04,$F3		; 1.41421	root 2
  8003 D386			LAB_25B5
  8004 D386 80 80 00 00			.byte	$80,$80,$00,$00		; -0.5
  8005 D38A			LAB_25B9
  8006 D38A 80 31 72 18			.byte	$80,$31,$72,$18		; 0.69315	LOG(2)
  8007
  8008 									; numeric PRINT constants
  8009 D38E			LAB_2947
  8010 D38E 91 43 4F F8			.byte	$91,$43,$4F,$F8		; 99999.9375 (max value with at least one decimal)
  8011 D392			LAB_294B
  8012 D392 94 74 23 F7			.byte	$94,$74,$23,$F7		; 999999.4375 (max value before scientific notation)
  8013 D396			LAB_294F
  8014 D396 94 74 24 00			.byte	$94,$74,$24,$00		; 1000000
  8015
  8016 									; EXP(n) constants and series
  8017 D39A			LAB_2AFA
  8018 D39A 81 38 AA 3B			.byte	$81,$38,$AA,$3B		; 1.4427	(1/LOG base 2 e)
  8019 D39E			LAB_2AFE
  8020 D39E 06				.byte	$06			; counter
  8021 D39F 74 63 90 8C			.byte	$74,$63,$90,$8C		; 2.17023e-4
  8022 D3A3 77 23 0C AB			.byte	$77,$23,$0C,$AB		; 0.00124
  8023 D3A7 7A 1E 94 00			.byte	$7A,$1E,$94,$00		; 0.00968
  8024 D3AB 7C 63 42 80			.byte	$7C,$63,$42,$80		; 0.05548
  8025 D3AF 7E 75 FE D0			.byte	$7E,$75,$FE,$D0		; 0.24023
  8026 D3B3 80 31 72 15			.byte	$80,$31,$72,$15		; 0.69315
  8027 D3B7 81 00 00 00			.byte	$81,$00,$00,$00		; 1.00000
  8028
  8029 				;##	.byte	$07			; counter
  8030 				;##	.byte	$74,$94,$2E,$40		; -1/7! (-1/5040)
  8031 				;##	.byte	$77,$2E,$4F,$70		;  1/6! ( 1/720)
  8032 				;##	.byte	$7A,$88,$02,$6E		; -1/5! (-1/120)
  8033 				;##	.byte	$7C,$2A,$A0,$E6		;  1/4! ( 1/24)
  8034 				;##	.byte	$7E,$AA,$AA,$50		; -1/3! (-1/6)
  8035 				;##	.byte	$7F,$7F,$FF,$FF		;  1/2! ( 1/2)
  8036 				;##	.byte	$81,$80,$00,$00		; -1/1! (-1/1)
  8037 				;##	.byte	$81,$00,$00,$00		;  1/0! ( 1/1)
  8038
  8039 									; trigonometric constants and series
  8040 D3BB			LAB_2C78
  8041 D3BB 81 49 0F DB			.byte	$81,$49,$0F,$DB		; 1.570796371 (pi/2) as floating #
  8042 D3BF			LAB_2C84
  8043 D3BF 04				.byte	$04			; counter
  8044 D3C0 86 1E D7 FB			.byte	$86,$1E,$D7,$FB		; 39.7109
  8045 				;##	.byte	$86,$1E,$D7,$BA		; 39.7109
  8046 D3C4 87 99 26 65			.byte	$87,$99,$26,$65		;-76.575
  8047 				;##	.byte	$87,$99,$26,$64		;-76.575
  8048 D3C8 87 23 34 58			.byte	$87,$23,$34,$58		; 81.6022
  8049 D3CC 86 A5 5D E1			.byte	$86,$A5,$5D,$E1		;-41.3417
  8050 				;##	.byte	$86,$A5,$5D,$E0		;-41.3417
  8051 D3D0			LAB_2C7C
  8052 D3D0 83 49 0F DB			.byte	$83,$49,$0F,$DB		; 6.28319 (2*pi) as floating #
  8053 				;##	.byte	$83,$49,$0F,$DA		; 6.28319 (2*pi) as floating #
  8054
  8055 D3D4			LAB_2CC9
  8056 D3D4 08				.byte	$08			; counter
  8057 D3D5 78 3A C5 37			.byte	$78,$3A,$C5,$37		; 0.00285
  8058 D3D9 7B 83 A2 5C			.byte	$7B,$83,$A2,$5C		;-0.0160686
  8059 D3DD 7C 2E DD 4D			.byte	$7C,$2E,$DD,$4D		; 0.0426915
  8060 D3E1 7D 99 B0 1E			.byte	$7D,$99,$B0,$1E		;-0.0750429
  8061 D3E5 7D 59 ED 24			.byte	$7D,$59,$ED,$24		; 0.106409
  8062 D3E9 7E 91 72 00			.byte	$7E,$91,$72,$00		;-0.142036
  8063 D3ED 7E 4C B9 73			.byte	$7E,$4C,$B9,$73		; 0.199926
  8064 D3F1 7F AA AA 53			.byte	$7F,$AA,$AA,$53		;-0.333331
  8065
  8066 				;##	.byte	$08			; counter
  8067 				;##	.byte	$78,$3B,$D7,$4A		; 1/17
  8068 				;##	.byte	$7B,$84,$6E,$02		;-1/15
  8069 				;##	.byte	$7C,$2F,$C1,$FE		; 1/13
  8070 				;##	.byte	$7D,$9A,$31,$74		;-1/11
  8071 				;##	.byte	$7D,$5A,$3D,$84		; 1/9
  8072 				;##	.byte	$7E,$91,$7F,$C8		;-1/7
  8073 				;##	.byte	$7E,$4C,$BB,$E4		; 1/5
  8074 				;##	.byte	$7F,$AA,$AA,$6C		;-1/3
  8075
  8076 = D3F6			LAB_1D96	= *+1			; $00,$00 used for undefined variables
  8077 D3F5			LAB_259C
  8078 D3F5 81 00 00 00			.byte	$81,$00,$00,$00		; 1.000000, used for INC
  8079 D3F9			LAB_2AFD
  8080 D3F9 81 80 00 00			.byte	$81,$80,$00,$00		; -1.00000, used for DEC. must be on the same page as +1.00
  8081
  8082 									; misc constants
  8083 D3FD			LAB_1DF7
  8084 D3FD 90				.byte	$90			;-32768 (uses first three bytes from 0.5)
  8085 D3FE			LAB_2A96
  8086 D3FE 80 00 00 00			.byte	$80,$00,$00,$00		; 0.5
  8087 D402			LAB_2C80
  8088 D402 7F 00 00 00			.byte	$7F,$00,$00,$00		; 0.25
  8089 D406			LAB_26B5
  8090 D406 84 20 00 00			.byte	$84,$20,$00,$00		; 10.0000 divide by 10 constant
  8091
  8092 				; This table is used in converting numbers to ASCII.
  8093 D40A			LAB_2A9A
  8094 = D40B			LAB_2A9B = LAB_2A9A+1
  8095 = D40C			LAB_2A9C = LAB_2A9B+1
  8096 D40A FE 79 60			.byte	$FE,$79,$60		; -100000
  8097 D40D 00 27 10			.byte	$00,$27,$10		; 10000
  8098 D410 FF FC 18			.byte	$FF,$FC,$18		; -1000
  8099 D413 00 00 64			.byte	$00,$00,$64		; 100
  8100 D416 FF FF F6			.byte	$FF,$FF,$F6		; -10
  8101 D419 00 00 01			.byte	$00,$00,$01		; 1
  8102
  8103 D41C			LAB_CTBL
  8104 D41C F9 B4			.word	LAB_END-1		; END
  8105 D41E 38 B4			.word	LAB_FOR-1		; FOR
  8106 D420 41 BA			.word	LAB_NEXT-1		; NEXT
  8107 D422 66 B6			.word	LAB_DATA-1		; DATA
  8108 D424 24 B9			.word	LAB_INPUT-1		; INPUT
  8109 D426 3D BD			.word	LAB_DIM-1		; DIM
  8110 D428 43 B9			.word	LAB_READ-1		; READ
  8111 D42A 91 B7			.word	LAB_LET-1		; LET
  8112 D42C 63 B7			.word	LAB_DEC-1		; DEC		new command
  8113 D42E C5 B5			.word	LAB_GOTO-1		; GOTO
  8114 D430 84 B5			.word	LAB_RUN-1		; RUN
  8115 D432 94 B6			.word	LAB_IF-1		; IF
  8116 D434 1A B5			.word	LAB_RESTORE-1		; RESTORE	modified command
  8117 D436 A8 B5			.word	LAB_GOSUB-1		; GOSUB
  8118 D438 53 CF			.word	LAB_RETIRQ-1		; RETIRQ	new command
  8119 D43A 5F CF			.word	LAB_RETNMI-1		; RETNMI	new command
  8120 D43C 51 B6			.word	LAB_RETURN-1		; RETURN
  8121 D43E FB B6			.word	LAB_REM-1		; REM
  8122 D440 F7 B4			.word	LAB_STOP-1		; STOP
  8123 D442 04 B7			.word	LAB_ON-1		; ON		modified command
  8124 D444 58 B5			.word	LAB_NULL-1		; NULL		modified command
  8125 D446 66 B7			.word	LAB_INC-1		; INC		new command
  8126 D448 75 C5			.word	LAB_WAIT-1		; WAIT
  8127 D44A 55 D1			.word	LAB_LOAD-1		; LOAD
  8128 D44C 91 D1			.word	LAB_SAVE-1		; SAVE
  8129 D44E 5E C0			.word	LAB_DEF-1		; DEF
  8130 D450 FA C4			.word	LAB_POKE-1		; POKE
  8131 D452 16 C5			.word	LAB_DOKE-1		; DOKE		new command
  8132 D454 63 C5			.word	LAB_CALL-1		; CALL		new command
  8133 D456 8E B5			.word	LAB_DO-1		; DO		new command
  8134 D458 F7 B5			.word	LAB_LOOP-1		; LOOP		new command
  8135 D45A 32 B8			.word	LAB_PRINT-1		; PRINT
  8136 D45C 5E B5			.word	LAB_CONT-1		; CONT
  8137 D45E 83 B3			.word	LAB_LIST-1		; LIST
  8138 D460 80 B3			.word	LAB_CLEAR-1		; CLEAR
  8139 D462 30 B3			.word	LAB_NEW-1		; NEW
  8140 D464 D4 CF			.word	LAB_WDTH-1		; WIDTH		new command
  8141 D466 01 B8			.word	LAB_GET-1		; GET		new command
  8142 D468 3B C5			.word	LAB_SWAP-1		; SWAP		new command
  8143 D46A 6E CD			.word	LAB_BITSET-1		; BITSET	new command
  8144 D46C 82 CD			.word	LAB_BITCLR-1		; BITCLR	new command
  8145 D46E 02 CF			.word	LAB_IRQ-1		; IRQ		new command
  8146 D470 05 CF			.word	LAB_NMI-1		; NMI		new command
  8147 D472 CD D1			.word	LAB_BEEP-1		; BEEP		new command (Junior Computer 2)
  8148 D474 DE D1			.word	LAB_PLIST-1		; PLIST		new command (Junior Computer 2)
  8149 D476 F2 D1			.word	LAB_HOME-1		; HOME		new command (Junior Computer 2)
  8150 D478 F6 D1			.word	LAB_CLS-1		; CLS		new command (Junior Computer 2)
  8151 D47A FA D1			.word	LAB_NORMAL-1		; NORMAL	new command (Junior Computer 2)
  8152 D47C FE D1			.word	LAB_INVERSE-1		; INVERSE	new command (Junior Computer 2)
  8153 D47E 02 D2			.word	LAB_FLASH-1		; FLASH		new command (Junior Computer 2)
  8154 D480 07 D2			.word	LAB_LOCATE-1		; LOCATE	new command (Junior Computer 2)
  8155 D482 11 D2			.word	LAB_INNUM-1		; IN#		new command (Junior Computer 2)
  8156 D484 19 D2			.word	LAB_PRNUM-1		; PR#		new command (Junior Computer 2)
  8157 D486 21 D2			.word	LAB_PORTIO-1		; PORTIO	new command (Junior Computer 2)
  8158 D488 31 D2			.word	LAB_PORTOUT-1		; PORTOUT	new command (Junior Computer 2)
  8159 D48A 0B D3			.word	LAB_SCREEN-1		; SCREEN	new command (Junior Computer 2)	
  8160 D48C 0B D3			.word	LAB_PIXEL-1		; PIXEL		new command (Junior Computer 2)
  8161 D48E 0B D3			.word	LAB_LINE-1		; LINE		new command (Junior Computer 2)	
  8162 D490 0B D3			.word	LAB_OVAL-1		; OVAL		new command (Junior Computer 2)	
  8163 D492 0B D3			.word	LAB_RECT-1		; RECT		new command (Junior Computer 2)	
  8164 D494 0B D3			.word	LAB_COLOR-1		; COLOR		new command (Junior Computer 2)	
  8165 D496 C1 D2			.word	LAB_DELAY-1		; DELAY		new command (Junior Computer 2)	
  8166 D498 53 D2			.word	LAB_I2COUT-1		; I2COUT	new command (Junior Computer 2)
  8167 D49A EF D1			.word	LAB_DOS-1		; DOS		new command (Junior Computer 2)
  8168
  8169 				; function pre process routine table
  8170
  8171 D49C			LAB_FTPL
  8172 = D49D			LAB_FTPM	= LAB_FTPL+$01
  8173 D49C 43 BC			.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
  8174 D49E 43 BC			.word	LAB_PPFN-1		; INT(n)		"
  8175 D4A0 43 BC			.word	LAB_PPFN-1		; ABS(n)		"
  8176 D4A2 C5 BA			.word	LAB_EVEZ-1		; USR(x)	process any expression
  8177 D4A4 C8 BB			.word	LAB_1BF7-1		; FRE(x)		"
  8178 D4A6 C8 BB			.word	LAB_1BF7-1		; POS(x)		"
  8179 D4A8 43 BC			.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
  8180 D4AA 43 BC			.word	LAB_PPFN-1		; RND(n)		"
  8181 D4AC 43 BC			.word	LAB_PPFN-1		; LOG(n)		"
  8182 D4AE 43 BC			.word	LAB_PPFN-1		; EXP(n)		"
  8183 D4B0 43 BC			.word	LAB_PPFN-1		; COS(n)		"
  8184 D4B2 43 BC			.word	LAB_PPFN-1		; SIN(n)		"
  8185 D4B4 43 BC			.word	LAB_PPFN-1		; TAN(n)		"
  8186 D4B6 43 BC			.word	LAB_PPFN-1		; ATN(n)		"
  8187 D4B8 43 BC			.word	LAB_PPFN-1		; PEEK(n)		"
  8188 D4BA 43 BC			.word	LAB_PPFN-1		; DEEK(n)		"
  8189 D4BC 00 00			.word	$0000			; SADD()	none
  8190 D4BE 3D BC			.word	LAB_PPFS-1		; LEN($)	process string expression in ()
  8191 D4C0 43 BC			.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
  8192 D4C2 3D BC			.word	LAB_PPFS-1		; VAL($)	process string expression in ()
  8193 D4C4 3D BC			.word	LAB_PPFS-1		; ASC($)		"
  8194 D4C6 3D BC			.word	LAB_PPFS-1		; UCASE$($)		"
  8195 D4C8 3D BC			.word	LAB_PPFS-1		; LCASE$($)		"
  8196 D4CA 43 BC			.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
  8197 D4CC 6A BC			.word	LAB_BHSS-1		; HEX$(n)		"
  8198 D4CE 6A BC			.word	LAB_BHSS-1		; BIN$(n)		"
  8199 D4D0 00 00			.word	$0000			; BITTST()	none
  8200 D4D2 6B CF			.word	LAB_MMPP-1		; MAX()		process numeric expression
  8201 D4D4 6B CF			.word	LAB_MMPP-1		; MIN()		"
  8202 D4D6 49 BC			.word	LAB_PPBI-1		; PI		advance pointer
  8203 D4D8 49 BC			.word	LAB_PPBI-1		; TWOPI		"
  8204 D4DA 00 00			.word	$0000			; VARPTR()	none
  8205 D4DC 4E BC			.word	LAB_LRMS-1		; LEFT$()	process string expression
  8206 D4DE 4E BC			.word	LAB_LRMS-1		; RIGHT$()		"
  8207 D4E0 4E BC			.word	LAB_LRMS-1		; MID$()		"
  8208 D4E2 43 BC			.word	LAB_PPFN-1		; PORTIN(n)	process string expression in ()
  8209 D4E4 43 BC			.word	LAB_PPFN-1		; I2CIN(n)	process string expression in ()
  8210 D4E6 00 00			.word	$0000			; RESERVED	none TEMP
  8211 D4E8 00 00			.word	$0000			; RESERVED	none TEMP
  8212
  8213 				; action addresses for functions
  8214 D4EA			LAB_FTBL
  8215 = D4EB			LAB_FTBM	= LAB_FTBL+$01
  8216 D4EA E3 C8			.word	LAB_SGN-1		; SGN()
  8217 D4EC 6D C9			.word	LAB_INT-1		; INT()
  8218 D4EE 00 C9			.word	LAB_ABS-1		; ABS()
  8219 D4F0 39 CD			.word	LAB_USR-1		; USR()
  8220 D4F2 23 C0			.word	LAB_FRE-1		; FRE()
  8221 D4F4 4E C0			.word	LAB_POS-1		; POS()
  8222 D4F6 2A D0			.word	LAB_SQR-1		; SQR()
  8223 D4F8 89 CC			.word	LAB_RND-1		; RND()		modified function
  8224 D4FA E7 C6			.word	LAB_LOG-1		; LOG()
  8225 D4FC EB CB			.word	LAB_EXP-1		; EXP()
  8226 D4FE BD CC			.word	LAB_COS-1		; COS()
  8227 D500 C4 CC			.word	LAB_SIN-1		; SIN()
  8228 D502 0D CD			.word	LAB_TAN-1		; TAN()
  8229 D504 3F CD			.word	LAB_ATN-1		; ATN()
  8230 D506 EF C4			.word	LAB_PEEK-1		; PEEK()
  8231 D508 03 C5			.word	LAB_DEEK-1		; DEEK()	new function
  8232 D50A 41 C4			.word	LAB_SADD-1		; SADD()	new function
  8233 D50C 5A C4			.word	LAB_LENS-1		; LEN()
  8234 D50E 10 C1			.word	LAB_STRS-1		; STR$()
  8235 D510 87 C4			.word	LAB_VAL-1		; VAL()
  8236 D512 65 C4			.word	LAB_ASC-1		; ASC()
  8237 D514 1F C4			.word	LAB_UCASE-1		; UCASE$()	new function
  8238 D516 FE C3			.word	LAB_LCASE-1		; LCASE$()	new function
  8239 D518 70 C3			.word	LAB_CHRS-1		; CHR$()
  8240 D51A 0F CE			.word	LAB_HEXS-1		; HEX$()	new function
  8241 D51C C0 CD			.word	LAB_BINS-1		; BIN$()	new function
  8242 D51E 98 CD			.word	LAB_BTST-1		; BITTST()	new function
  8243 D520 71 CF			.word	LAB_MAX-1		; MAX()		new function
  8244 D522 81 CF			.word	LAB_MIN-1		; MIN()		new function
  8245 D524 C7 D0			.word	LAB_PI-1		; PI		new function
  8246 D526 D1 D0			.word	LAB_TWOPI-1		; TWOPI		new function
  8247 D528 B7 D0			.word	LAB_VARPTR-1		; VARPTR()	new function
  8248 D52A 82 C3			.word	LAB_LEFT-1		; LEFT$()
  8249 D52C 8B C3			.word	LAB_RIGHT-1		; RIGHT$()
  8250 D52E BA C3			.word	LAB_MIDS-1		; MID$()
  8251 D530 9F D2			.word	LAB_PORTIN-1		; PORTIN	new function (Junior Computer 2)
  8252 D532 77 D2			.word	LAB_I2CIN-1		; I2CIN()	new function (Junior Computer 2)		
  8253 D534 0B D3			.word	LAB_RES5-1		; RESERVED	new function (Junior Computer 2)
  8254 D536 0B D3			.word	LAB_RES6-1		; RESERVED	new function (Junior Computer 2)
  8255
  8256 				; hierarchy and action addresses for operator
  8257 D538			LAB_OPPT
  8258 D538 79				.byte	$79			; +
  8259 D539 AD C5			.word	LAB_ADD-1
  8260 D53B 79				.byte	$79			; -
  8261 D53C 92 C5			.word	LAB_SUBTRACT-1
  8262 D53E 7B				.byte	$7B			; *
  8263 D53F 28 C7			.word	LAB_MULTIPLY-1
  8264 D541 7B				.byte	$7B			; /
  8265 D542 F0 C7			.word	LAB_DIVIDE-1
  8266 D544 7B				.byte	$7B			; MOD		new operator (Junior Computer 2)
  8267 D545 D8 D0			.word	LAB_MOD-1
  8268 D547 7F				.byte	$7F			; ^
  8269 D548 A7 CB			.word	LAB_POWER-1
  8270 D54A 50				.byte	$50			; AND
  8271 D54B B3 BC			.word	LAB_AND-1
  8272 D54D 46				.byte	$46			; EOR		new operator
  8273 D54E 99 BC			.word	LAB_EOR-1
  8274 D550 46				.byte	$46			; OR
  8275 D551 A6 BC			.word	LAB_OR-1
  8276 D553 56				.byte	$56			; >>		new operator
  8277 D554 5F BD			.word	LAB_RSHIFT-1
  8278 D556 56				.byte	$56			; <<		new operator
  8279 D557 47 BD			.word	LAB_LSHIFT-1
  8280 D559 7D				.byte	$7D			; >
  8281 D55A E0 CB			.word	LAB_GTHAN-1
  8282 D55C 5A				.byte	$5A			; =
  8283 D55D F3 BB			.word	LAB_EQUAL-1
  8284 D55F 64				.byte	$64			; <
  8285 D560 D4 BC			.word	LAB_LTHAN-1
  8286
  8287 				; keywords start with ..
  8288 				; this is the first character table and must be in alphabetic order
  8289 D562			TAB_1STC
  8290 D562 2A				.byte	'*'
  8291 D563 2B				.byte	'+'
  8292 D564 2D				.byte	'-'
  8293 D565 2F				.byte	'/'
  8294 D566 3C				.byte	'<'
  8295 D567 3D				.byte	'='
  8296 D568 3E				.byte	'>'
  8297 D569 3F				.byte	'?'
  8298 D56A 41				.byte	'A'
  8299 D56B 42				.byte	'B'
  8300 D56C 43				.byte	'C'
  8301 D56D 44				.byte	'D'
  8302 D56E 45				.byte	'E'
  8303 D56F 46				.byte	'F'
  8304 D570 47				.byte	'G'
  8305 D571 48				.byte	'H'
  8306 D572 49				.byte	'I'
  8307 D573 4C				.byte	'L'
  8308 D574 4D				.byte	'M'
  8309 D575 4E				.byte	'N'
  8310 D576 4F				.byte	'O'
  8311 D577 50				.byte	'P'
  8312 D578 52				.byte	'R'
  8313 D579 53				.byte	'S'
  8314 D57A 54				.byte	'T'
  8315 D57B 55				.byte	'U'
  8316 D57C 56				.byte	'V'
  8317 D57D 57				.byte	'W'
  8318 D57E 5E				.byte	'^'
  8319 D57F 00				.byte	$00			; table terminator
  8320
  8321 				; pointers to keyword tables
  8322
  8323 D580			TAB_CHRT
  8324 D580 BA D5			.word	TAB_STAR		; table for '*'
  8325 D582 BC D5			.word	TAB_PLUS		; table for '+'
  8326 D584 BE D5			.word	TAB_MNUS		; table for '-'
  8327 D586 C0 D5			.word	TAB_SLAS		; table for '/'
  8328 D588 C2 D5			.word	TAB_LESS		; table for '<'
  8329 D58A C6 D5			.word	TAB_EQUL		; table for '='
  8330 D58C C8 D5			.word	TAB_MORE		; table for '>'
  8331 D58E CC D5			.word	TAB_QEST		; table for '?'
  8332 D590 CE D5			.word	TAB_ASCA		; table for 'A'
  8333 D592 DE D5			.word	TAB_ASCB		; table for 'B'
  8334 D594 FB D5			.word	TAB_ASCC		; table for 'C'
  8335 D596 1A D6			.word	TAB_ASCD		; table for 'D'
  8336 D598 3B D6			.word	TAB_ASCE		; table for 'E'
  8337 D59A 4A D6			.word	TAB_ASCF		; table for 'F'
  8338 D59C 59 D6			.word	TAB_ASCG		; table for 'G'
  8339 D59E 66 D6			.word	TAB_ASCH		; table for 'H'
  8340 D5A0 70 D6			.word	TAB_ASCI		; table for 'I'
  8341 D5A2 98 D6			.word	TAB_ASCL		; table for 'L'
  8342 D5A4 C7 D6			.word	TAB_ASCM		; table for 'M'
  8343 D5A6 DA D6			.word	TAB_ASCN		; table for 'N'
  8344 D5A8 F2 D6			.word	TAB_ASCO		; table for 'O'
  8345 D5AA FE D6			.word	TAB_ASCP		; table for 'P'
  8346 D5AC 2F D7			.word	TAB_ASCR		; table for 'R'
  8347 D5AE 6C D7			.word	TAB_ASCS		; table for 'S'
  8348 D5B0 9D D7			.word	TAB_ASCT		; table for 'T'
  8349 D5B2 B1 D7			.word	TAB_ASCU		; table for 'U'
  8350 D5B4 C2 D7			.word	TAB_ASCV		; table for 'V'
  8351 D5B6 CE D7			.word	TAB_ASCW		; table for 'W'
  8352 D5B8 DD D7			.word	TAB_POWR		; table for '^'
  8353
  8354 				; tables for each start character, note if a longer keyword with the same start
  8355 				; letters as a shorter one exists then it must come first, else the list is in
  8356 				; alphabetical order as follows ..
  8357
  8358 				; [keyword,token
  8359 				; [keyword,token]]
  8360 				; end marker (#$00)
  8361
  8362 D5BA			TAB_STAR
  8363 D5BA CD 00			.byte TK_MUL,$00		; *
  8364 D5BC			TAB_PLUS
  8365 D5BC CB 00			.byte TK_PLUS,$00		; +
  8366 D5BE			TAB_MNUS
  8367 D5BE CC 00			.byte TK_MINUS,$00		; -
  8368 D5C0			TAB_SLAS
  8369 D5C0 CE 00			.byte TK_DIV,$00		; /
  8370 D5C2			TAB_LESS
  8371 D5C2			LBB_LSHIFT
  8372 D5C2 3C D5			.byte	'<',TK_LSHIFT		; <<	note - '<<' must come before '<'
  8373 D5C4 D8				.byte 	TK_LT			; <
  8374 D5C5 00				.byte	$00
  8375 D5C6			TAB_EQUL
  8376 D5C6 D7 00			.byte 	TK_EQUAL,$00		; =
  8377 D5C8			TAB_MORE
  8378 D5C8			LBB_RSHIFT
  8379 D5C8 3E D4			.byte	'>',TK_RSHIFT		; >>	note - '>>' must come before '>'
  8380 D5CA D6				.byte 	TK_GT			; >
  8381 D5CB 00				.byte	$00
  8382 D5CC			TAB_QEST
  8383 D5CC 9F 00			.byte 	TK_PRINT,$00		; ?
  8384 D5CE			TAB_ASCA
  8385 D5CE			LBB_ABS
  8386 D5CE 42 53 28 DB			.byte	'BS(',TK_ABS		; ABS(
  8387 D5D2			LBB_AND
  8388 D5D2 4E 44 D1			.byte	'ND',TK_AND		; AND
  8389 D5D5			LBB_ASC
  8390 D5D5 53 43 28 ED			.byte	'SC(',TK_ASC		; ASC(
  8391 D5D9			LBB_ATN
  8392 D5D9 54 4E 28 E6			.byte	'TN(',TK_ATN		; ATN(
  8393 D5DD 00				.byte	$00
  8394 D5DE			TAB_ASCB
  8395 D5DE			LBB_BEEP
  8396 D5DE 45 45 50 AB			.byte	'EEP',TK_BEEP		; BEEP
  8397 D5E2			LBB_BINS
  8398 D5E2 49 4E 24 28 F2		.byte	'IN$(',TK_BINS		; BIN$(
  8399 D5E7			LBB_BITCLR
  8400 D5E7 49 54 43 4C 52 A8		.byte	'ITCLR',TK_BITCLR	; BITCLR
  8401 D5ED			LBB_BITSET
  8402 D5ED 49 54 53 45 54 A7		.byte	'ITSET',TK_BITSET	; BITSET
  8403 D5F3			LBB_BITTST
  8404 D5F3 49 54 54 53 54 28 + 	.byte	'ITTST(',TK_BITTST  	; BITTST(
  8405 D5FA 00				.byte	$00
  8406 D5FB			TAB_ASCC
  8407 D5FB			LBB_CALL
  8408 D5FB 41 4C 4C 9C			.byte	'ALL',TK_CALL		; CALL
  8409 D5FF			LBB_CHRS
  8410 D5FF 48 52 24 28 F0		.byte	'HR$(',TK_CHRS		; CHR$(
  8411 D604			LBB_CLEAR
  8412 D604 4C 45 41 52 A2		.byte	'LEAR',TK_CLEAR		; CLEAR
  8413 D609			LBB_CLS
  8414 D609 4C 53 AE		    	.byte   'LS',TK_CLS 		; CLS
  8415 D60C			LBB_COLOR
  8416 D60C 4F 4C 4F 52 BC		.byte	'OLOR',TK_COLOR		; COLOR
  8417 D611			LBB_CONT
  8418 D611 4F 4E 54 A0			.byte	'ONT',TK_CONT		; CONT
  8419 D615			LBB_COS
  8420 D615 4F 53 28 E3			.byte	'OS(',TK_COS		; COS(
  8421 D619 00				.byte	$00
  8422 D61A			TAB_ASCD
  8423 D61A			LBB_DATA
  8424 D61A 41 54 41 83			.byte	'ATA',TK_DATA		; DATA
  8425 D61E			LBB_DEC
  8426 D61E 45 43 88			.byte	'EC',TK_DEC		; DEC
  8427 D621			LBB_DEEK
  8428 D621 45 45 4B 28 E8		.byte	'EEK(',TK_DEEK		; DEEK(
  8429 D626			LBB_DEF
  8430 D626 45 46 99			.byte	'EF',TK_DEF		; DEF
  8431 D629			LBB_DELAY
  8432 D629 45 4C 41 59 BD		.byte	'ELAY',TK_DELAY		; DELAY
  8433 D62E			LBB_DIM
  8434 D62E 49 4D 85			.byte	'IM',TK_DIM		; DIM
  8435 D631			LBB_DOKE
  8436 D631 4F 4B 45 9B			.byte	'OKE',TK_DOKE		; DOKE
  8437 D635			LBB_DOS
  8438 D635 4F 53 BF			.byte	'OS',TK_DOS		; DOS note - 'DOS' must come before 'DO'
  8439 D638			LBB_DO
  8440 D638 4F 9D			.byte	'O',TK_DO		; DO
  8441 D63A 00				.byte	$00
  8442 D63B			TAB_ASCE
  8443 D63B			LBB_ELSE
  8444 D63B 4C 53 45 C1			.byte	'LSE',TK_ELSE		; ELSE
  8445 D63F			LBB_END
  8446 D63F 4E 44 80			.byte	'ND',TK_END		; END
  8447 D642			LBB_EOR
  8448 D642 4F 52 D2			.byte	'OR',TK_EOR		; EOR
  8449 D645			LBB_EXP
  8450 D645 58 50 28 E2			.byte	'XP(',TK_EXP		; EXP(
  8451 D649 00				.byte	$00
  8452 D64A			TAB_ASCF
  8453 D64A			LBB_FLASH
  8454 D64A 4C 41 53 48 B1	    	.byte   'LASH',TK_FLASH 	; FLASH
  8455 D64F			LBB_FN
  8456 D64F 4E C3			.byte	'N',TK_FN		; FN
  8457 D651			LBB_FOR
  8458 D651 4F 52 81			.byte	'OR',TK_FOR		; FOR
  8459 D654			LBB_FRE
  8460 D654 52 45 28 DD			.byte	'RE(',TK_FRE		; FRE(
  8461 D658 00				.byte	$00
  8462 D659			TAB_ASCG
  8463 D659			LBB_GET
  8464 D659 45 54 A5			.byte	'ET',TK_GET		; GET
  8465 D65C			LBB_GOSUB
  8466 D65C 4F 53 55 42 8D		.byte	'OSUB',TK_GOSUB		; GOSUB
  8467 D661			LBB_GOTO
  8468 D661 4F 54 4F 89			.byte	'OTO',TK_GOTO		; GOTO
  8469 D665 00				.byte	$00
  8470 D666			TAB_ASCH
  8471 D666			LBB_HEXS
  8472 D666 45 58 24 28 F1		.byte	'EX$(',TK_HEXS		; HEX$(
  8473 D66B			LBB_HOME
  8474 D66B 4F 4D 45 AD		    	.byte   'OME',TK_HOME 		; HOME
  8475 D66F 00				.byte	$00
  8476 D670			TAB_ASCI
  8477 D670			LBB_I2CIN
  8478 D670 32 43 69 6E 28 FD		.byte	'2Cin(',TK_I2CIN	; I2Cin
  8479 D676			LBB_I2COUT
  8480 D676 32 43 6F 75 74 BE		.byte	'2Cout',TK_I2COUT	; I2Cout
  8481 D67C			LBB_IF
  8482 D67C 46 8B			.byte	'F',TK_IF		; IF
  8483 D67E			LBB_INNUM
  8484 D67E 4E 23 B3			.byte	'N#',TK_INNUM		; IN#
  8485 D681			LBB_INC
  8486 D681 4E 43 95			.byte	'NC',TK_INC		; INC
  8487 D684			LBB_INPUT
  8488 D684 4E 50 55 54 84		.byte	'NPUT',TK_INPUT		; INPUT
  8489 D689			LBB_INT
  8490 D689 4E 54 28 DA			.byte	'NT(',TK_INT		; INT(
  8491 D68D			LBB_INVERSE
  8492 D68D 4E 56 45 52 53 45 +     	.byte   'NVERSE',TK_INVERSE 	; INVERSE
  8493 D694			LBB_IRQ
  8494 D694 52 51 A9			.byte	'RQ',TK_IRQ		; IRQ
  8495 D697 00				.byte	$00
  8496 D698			TAB_ASCL
  8497 D698			LBB_LCASES
  8498 D698 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_LCASES
  8499 									; LCASE$(
  8500 D69F			LBB_LEFTS
  8501 D69F 45 46 54 24 28 F9		.byte	'EFT$(',TK_LEFTS	; LEFT$(
  8502 D6A5			LBB_LEN
  8503 D6A5 45 4E 28 EA			.byte	'EN(',TK_LEN		; LEN(
  8504 D6A9			LBB_LET
  8505 D6A9 45 54 87			.byte	'ET',TK_LET		; LET
  8506 D6AC			LBB_LINE
  8507 D6AC 49 4E 45 B9			.byte	'INE',TK_LINE		; LINE
  8508 D6B0			LBB_LIST
  8509 D6B0 49 53 54 A1			.byte	'IST',TK_LIST		; LIST
  8510 D6B4			LBB_LOAD
  8511 D6B4 4F 41 44 97			.byte	'OAD',TK_LOAD		; LOAD
  8512 D6B8			LBB_LOCATE
  8513 D6B8 4F 43 41 54 45 B2	    	.byte   'OCATE',TK_LOCATE 	; LOCATE
  8514 D6BE			LBB_LOG
  8515 D6BE 4F 47 28 E1			.byte	'OG(',TK_LOG		; LOG(
  8516 D6C2			LBB_LOOP
  8517 D6C2 4F 4F 50 9E			.byte	'OOP',TK_LOOP		; LOOP
  8518 D6C6 00				.byte	$00
  8519 D6C7			TAB_ASCM
  8520 D6C7			LBB_MAX
  8521 D6C7 41 58 28 F4			.byte	'AX(',TK_MAX		; MAX(
  8522 D6CB			LBB_MIDS
  8523 D6CB 49 44 24 28 FB		.byte	'ID$(',TK_MIDS		; MID$(
  8524 D6D0			LBB_MIN
  8525 D6D0 49 4E 28 F5			.byte	'IN(',TK_MIN		; MIN(
  8526 D6D4			LBB_MOD
  8527 D6D4 4F 44 5F 23 CF		.byte	'OD_#',TK_MOD		; MOD
  8528 D6D9 00				.byte	$00
  8529 D6DA			TAB_ASCN
  8530 D6DA			LBB_NEW
  8531 D6DA 45 57 A3			.byte	'EW',TK_NEW		; NEW
  8532 D6DD			LBB_NEXT
  8533 D6DD 45 58 54 82			.byte	'EXT',TK_NEXT		; NEXT
  8534 D6E1			LBB_NMI
  8535 D6E1 4D 49 AA			.byte	'MI',TK_NMI		; NMI
  8536 D6E4			LBB_NOT
  8537 D6E4 4F 54 C6			.byte	'OT',TK_NOT		; NOT
  8538 D6E7			LBB_NORMAL
  8539 D6E7 4F 52 4D 41 4C AF	    	.byte   'ORMAL',TK_NORMAL 	; NORMAL
  8540 D6ED			LBB_NULL
  8541 D6ED 55 4C 4C 94			.byte	'ULL',TK_NULL		; NULL
  8542 D6F1 00				.byte	$00
  8543 D6F2			TAB_ASCO
  8544 D6F2			LBB_OFF
  8545 D6F2 46 46 CA			.byte	'FF',TK_OFF		; OFF
  8546 D6F5			LBB_ON
  8547 D6F5 4E 93			.byte	'N',TK_ON		; ON
  8548 D6F7			LBB_OR
  8549 D6F7 52 D3			.byte	'R',TK_OR		; OR
  8550 D6F9			LBB_OVAL
  8551 D6F9 56 41 4C BA			.byte	'VAL',TK_OVAL		; OVAL
  8552 D6FD 00				.byte	$00
  8553 D6FE			TAB_ASCP
  8554 D6FE			LBB_PEEK
  8555 D6FE 45 45 4B 28 E7		.byte	'EEK(',TK_PEEK		; PEEK(
  8556 D703			LBB_PIXEL
  8557 D703 49 58 45 4C B8		.byte	'IXEL',TK_PIXEL		; PIXEL
  8558 D708			LBB_PI
  8559 D708 49 F6			.byte	'I',TK_PI		; PI
  8560 D70A			LBB_PLIST
  8561 D70A 4C 49 53 54 AC	    .byte   	'LIST',TK_PLIST 	; PLIST
  8562 D70F			LBB_POKE
  8563 D70F 4F 4B 45 9A			.byte	'OKE',TK_POKE		; POKE
  8564 D713			LBB_PORTIO
  8565 D713 4F 52 54 49 4F B5		.byte	'ORTIO',TK_PORTIO	; PORTIO
  8566 D719			LBB_PORTIN
  8567 D719 4F 52 54 28 FC		.byte	'ORT(',TK_PORTIN	; PORT IN
  8568 D71E			LBB_PORTOUT
  8569 D71E 4F 52 54 B6			.byte	'ORT',TK_PORTOUT	; PORT OUT
  8570 D722			LBB_POS
  8571 D722 4F 53 28 DE			.byte	'OS(',TK_POS		; POS(
  8572 D726			LBB_PRNUM
  8573 D726 52 23 B4			.byte	'R#',TK_PRNUM		; PR#
  8574 D729			LBB_PRINT
  8575 D729 52 49 4E 54 9F		.byte	'RINT',TK_PRINT		; PRINT
  8576 D72E 00				.byte	$00
  8577 D72F			TAB_ASCR
  8578 D72F			LBB_READ
  8579 D72F 45 41 44 86			.byte	'EAD',TK_READ		; READ
  8580 D733			LBB_RECT
  8581 D733 45 43 54 BB			.byte	'ECT',TK_RECT		; RECT
  8582 D737			LBB_REM
  8583 D737 45 4D 91			.byte	'EM',TK_REM		; REM
  8584 D73A			LBB_RESTORE
  8585 D73A 45 53 54 4F 52 45 + 	.byte	'ESTORE',TK_RESTORE
  8586 									; RESTORE
  8587 D741			LBB_RETIRQ
  8588 D741 45 54 49 52 51 8E		.byte	'ETIRQ',TK_RETIRQ	; RETIRQ
  8589 D747			LBB_RETNMI
  8590 D747 45 54 4E 4D 49 8F		.byte	'ETNMI',TK_RETNMI	; RETNMI
  8591 D74D			LBB_RES5
  8592 D74D 45 53 35 28 FE		.byte	'ES5(',TK_RES5		; RES5
  8593 D752			LBB_RES6
  8594 D752 45 53 36 28 FF		.byte	'ES6(',TK_RES6		; RES6
  8595 D757			LBB_RETURN
  8596 D757 45 54 55 52 4E 90		.byte	'ETURN',TK_RETURN	; RETURN
  8597 D75D			LBB_RIGHTS
  8598 D75D 49 47 48 54 24 28 + 	.byte	'IGHT$(',TK_RIGHTS
  8599 									; RIGHT$(
  8600 D764			LBB_RND
  8601 D764 4E 44 28 E0			.byte	'ND(',TK_RND		; RND(
  8602 D768			LBB_RUN
  8603 D768 55 4E 8A			.byte	'UN',TK_RUN		; RUN
  8604 D76B 00				.byte	$00
  8605 D76C			TAB_ASCS
  8606 D76C			LBB_SADD
  8607 D76C 41 44 44 28 E9		.byte	'ADD(',TK_SADD		; SADD(
  8608 D771			LBB_SAVE
  8609 D771 41 56 45 98			.byte	'AVE',TK_SAVE		; SAVE
  8610 D775			LBB_SCREEN
  8611 D775 43 52 45 45 4E B7		.byte	'CREEN',TK_SCREEN	; SCREEN
  8612 D77B			LBB_SGN
  8613 D77B 47 4E 28 D9			.byte	'GN(',TK_SGN		; SGN(
  8614 D77F			LBB_SIN
  8615 D77F 49 4E 28 E4			.byte	'IN(',TK_SIN		; SIN(
  8616 D783			LBB_SPC
  8617 D783 50 43 28 C4			.byte	'PC(',TK_SPC		; SPC(
  8618 D787			LBB_SQR
  8619 D787 51 52 28 DF			.byte	'QR(',TK_SQR		; SQR(
  8620 D78B			LBB_STEP
  8621 D78B 54 45 50 C7			.byte	'TEP',TK_STEP		; STEP
  8622 D78F			LBB_STOP
  8623 D78F 54 4F 50 92			.byte	'TOP',TK_STOP		; STOP
  8624 D793			LBB_STRS
  8625 D793 54 52 24 28 EB		.byte	'TR$(',TK_STRS		; STR$(
  8626 D798			LBB_SWAP
  8627 D798 57 41 50 A6			.byte	'WAP',TK_SWAP		; SWAP
  8628 D79C 00				.byte	$00
  8629 D79D			TAB_ASCT
  8630 D79D			LBB_TAB
  8631 D79D 41 42 28 C0			.byte	'AB(',TK_TAB		; TAB(
  8632 D7A1			LBB_TAN
  8633 D7A1 41 4E 28 E5			.byte	'AN(',TK_TAN		; TAN(
  8634 D7A5			LBB_THEN
  8635 D7A5 48 45 4E C5			.byte	'HEN',TK_THEN		; THEN
  8636 D7A9			LBB_TO
  8637 D7A9 4F C2			.byte	'O',TK_TO		; TO
  8638 D7AB			LBB_TWOPI
  8639 D7AB 57 4F 50 49 F7		.byte	'WOPI',TK_TWOPI		; TWOPI
  8640 D7B0 00				.byte	$00
  8641 D7B1			TAB_ASCU
  8642 D7B1			LBB_UCASES
  8643 D7B1 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_UCASES
  8644 									; UCASE$(
  8645 D7B8			LBB_UNTIL
  8646 D7B8 4E 54 49 4C C8		.byte	'NTIL',TK_UNTIL		; UNTIL
  8647 D7BD			LBB_USR
  8648 D7BD 53 52 28 DC			.byte	'SR(',TK_USR		; USR(
  8649 D7C1 00				.byte	$00
  8650 D7C2			TAB_ASCV
  8651 D7C2			LBB_VAL
  8652 D7C2 41 4C 28 EC			.byte	'AL(',TK_VAL		; VAL(
  8653 D7C6			LBB_VPTR
  8654 D7C6 41 52 50 54 52 28 + 	.byte	'ARPTR(',TK_VPTR	; VARPTR(
  8655 D7CD 00				.byte	$00
  8656 D7CE			TAB_ASCW
  8657 D7CE			LBB_WAIT
  8658 D7CE 41 49 54 96			.byte	'AIT',TK_WAIT		; WAIT
  8659 D7D2			LBB_WHILE
  8660 D7D2 48 49 4C 45 C9		.byte	'HILE',TK_WHILE		; WHILE
  8661 D7D7			LBB_WIDTH
  8662 D7D7 49 44 54 48 A4		.byte	'IDTH',TK_WIDTH		; WIDTH
  8663 D7DC 00				.byte	$00
  8664 D7DD			TAB_POWR
  8665 D7DD D0 00			.byte	TK_POWER,$00		; ^
  8666
  8667 				; new decode table for LIST
  8668 				; Table is ..
  8669 				; byte - keyword length, keyword first character
  8670 				; word - pointer to rest of keyword from dictionary
  8671
  8672 				; note if length is 1 then the pointer is ignored
  8673 D7DF			LAB_KEYT
  8674 D7DF 03 45			.byte	3,'E'
  8675 D7E1 3F D6			.word	LBB_END			; END
  8676 D7E3 03 46			.byte	3,'F'
  8677 D7E5 51 D6			.word	LBB_FOR			; FOR
  8678 D7E7 04 4E			.byte	4,'N'
  8679 D7E9 DD D6			.word	LBB_NEXT		; NEXT
  8680 D7EB 04 44			.byte	4,'D'
  8681 D7ED 1A D6			.word	LBB_DATA		; DATA
  8682 D7EF 05 49			.byte	5,'I'
  8683 D7F1 84 D6			.word	LBB_INPUT		; INPUT
  8684 D7F3 03 44			.byte	3,'D'
  8685 D7F5 2E D6			.word	LBB_DIM			; DIM
  8686 D7F7 04 52			.byte	4,'R'
  8687 D7F9 2F D7			.word	LBB_READ		; READ
  8688 D7FB 03 4C			.byte	3,'L'
  8689 D7FD A9 D6			.word	LBB_LET			; LET
  8690 D7FF 03 44			.byte	3,'D'
  8691 D801 1E D6			.word	LBB_DEC			; DEC
  8692 D803 04 47			.byte	4,'G'
  8693 D805 61 D6			.word	LBB_GOTO		; GOTO
  8694 D807 03 52			.byte	3,'R'
  8695 D809 68 D7			.word	LBB_RUN			; RUN
  8696 D80B 02 49			.byte	2,'I'
  8697 D80D 7C D6			.word	LBB_IF			; IF
  8698 D80F 07 52			.byte	7,'R'
  8699 D811 3A D7			.word	LBB_RESTORE		; RESTORE
  8700 D813 05 47			.byte	5,'G'
  8701 D815 5C D6			.word	LBB_GOSUB		; GOSUB
  8702 D817 06 52			.byte	6,'R'
  8703 D819 41 D7			.word	LBB_RETIRQ		; RETIRQ
  8704 D81B 06 52			.byte	6,'R'
  8705 D81D 47 D7			.word	LBB_RETNMI		; RETNMI
  8706 D81F 06 52			.byte	6,'R'
  8707 D821 57 D7			.word	LBB_RETURN		; RETURN
  8708 D823 03 52			.byte	3,'R'
  8709 D825 37 D7			.word	LBB_REM			; REM
  8710 D827 04 53			.byte	4,'S'
  8711 D829 8F D7			.word	LBB_STOP		; STOP
  8712 D82B 02 4F			.byte	2,'O'
  8713 D82D F5 D6			.word	LBB_ON			; ON
  8714 D82F 04 4E			.byte	4,'N'
  8715 D831 ED D6			.word	LBB_NULL		; NULL
  8716 D833 03 49			.byte	3,'I'
  8717 D835 81 D6			.word	LBB_INC			; INC
  8718 D837 04 57			.byte	4,'W'
  8719 D839 CE D7			.word	LBB_WAIT		; WAIT
  8720 D83B 04 4C			.byte	4,'L'
  8721 D83D B4 D6			.word	LBB_LOAD		; LOAD
  8722 D83F 04 53			.byte	4,'S'
  8723 D841 71 D7			.word	LBB_SAVE		; SAVE
  8724 D843 03 44			.byte	3,'D'
  8725 D845 26 D6			.word	LBB_DEF			; DEF
  8726 D847 04 50			.byte	4,'P'
  8727 D849 0F D7			.word	LBB_POKE		; POKE
  8728 D84B 04 44			.byte	4,'D'
  8729 D84D 31 D6			.word	LBB_DOKE		; DOKE
  8730 D84F 04 43			.byte	4,'C'
  8731 D851 FB D5			.word	LBB_CALL		; CALL
  8732 D853 02 44			.byte	2,'D'
  8733 D855 38 D6			.word	LBB_DO			; DO
  8734 D857 04 4C			.byte	4,'L'
  8735 D859 C2 D6			.word	LBB_LOOP		; LOOP
  8736 D85B 05 50			.byte	5,'P'
  8737 D85D 29 D7			.word	LBB_PRINT		; PRINT
  8738 D85F 04 43			.byte	4,'C'
  8739 D861 11 D6			.word	LBB_CONT		; CONT
  8740 D863 04 4C			.byte	4,'L'
  8741 D865 B0 D6			.word	LBB_LIST		; LIST
  8742 D867 05 43			.byte	5,'C'
  8743 D869 04 D6			.word	LBB_CLEAR		; CLEAR
  8744 D86B 03 4E			.byte	3,'N'
  8745 D86D DA D6			.word	LBB_NEW			; NEW
  8746 D86F 05 57			.byte	5,'W'
  8747 D871 D7 D7			.word	LBB_WIDTH		; WIDTH
  8748 D873 03 47			.byte	3,'G'
  8749 D875 59 D6			.word	LBB_GET			; GET
  8750 D877 04 53			.byte	4,'S'
  8751 D879 98 D7			.word	LBB_SWAP		; SWAP
  8752 D87B 06 42			.byte	6,'B'
  8753 D87D ED D5			.word	LBB_BITSET		; BITSET
  8754 D87F 06 42			.byte	6,'B'
  8755 D881 E7 D5			.word	LBB_BITCLR		; BITCLR
  8756 D883 03 49			.byte	3,'I'
  8757 D885 94 D6			.word	LBB_IRQ			; IRQ
  8758 D887 03 4E			.byte	3,'N'
  8759 D889 E1 D6			.word	LBB_NMI			; NMI
  8760 D88B 04 42			.byte	4,'B'
  8761 D88D DE D5			.word	LBB_BEEP		; BEEP
  8762 D88F 05 50			.byte	5,'P'
  8763 D891 0A D7			.word	LBB_PLIST		; PLIST
  8764 D893 04 48			.byte	4,'H'
  8765 D895 6B D6			.word	LBB_HOME		; HOME
  8766 D897 03 43			.byte	3,'C'
  8767 D899 09 D6			.word	LBB_CLS			; CLS
  8768 D89B 06 4E			.byte	6,'N'
  8769 D89D E7 D6			.word	LBB_NORMAL		; NORMAL
  8770 D89F 07 49			.byte	7,'I'
  8771 D8A1 8D D6			.word	LBB_INVERSE		; INVERSE
  8772 D8A3 05 46			.byte	5,'F'
  8773 D8A5 4A D6			.word	LBB_FLASH		; FLASH
  8774 D8A7 06 4C			.byte	6,'L'
  8775 D8A9 B8 D6			.word	LBB_LOCATE		; LOCATE
  8776 D8AB 03 49			.byte	3,'I'
  8777 D8AD 7E D6			.word	LBB_INNUM		; IN#
  8778 D8AF 03 50			.byte	3,'P'
  8779 D8B1 26 D7			.word	LBB_PRNUM		; PR#
  8780
  8781 D8B3 06 50			.byte	6,'P'
  8782 D8B5 13 D7			.word	LBB_PORTIO		; PORTIO
  8783 D8B7 04 50			.byte	4,'P'
  8784 D8B9 1E D7			.word	LBB_PORTOUT		; PORTOUT
  8785 D8BB 06 53			.byte	6,'S'
  8786 D8BD 75 D7			.word	LBB_SCREEN		; SCREEN
  8787 D8BF 05 50			.byte	5,'P'
  8788 D8C1 03 D7			.word	LBB_PIXEL		; PIXEL
  8789 D8C3 04 4C			.byte	4,'L'
  8790 D8C5 AC D6			.word	LBB_LINE		; LINE
  8791 D8C7 04 4F			.byte	4,'O'
  8792 D8C9 F9 D6			.word	LBB_OVAL		; OVAL
  8793 D8CB 04 52			.byte	4,'R'
  8794 D8CD 33 D7			.word	LBB_RECT		; RECT
  8795 D8CF 05 43			.byte	5,'C'
  8796 D8D1 0C D6			.word	LBB_COLOR		; COLOR
  8797 D8D3 05 44			.byte	5,'D'
  8798 D8D5 29 D6			.word	LBB_DELAY		; DELAY	
  8799 D8D7 06 49			.byte	6,'I'
  8800 D8D9 76 D6			.word	LBB_I2COUT		; I2COUT
  8801 D8DB 03 44			.byte	3,'D'
  8802 D8DD 35 D6			.word	LBB_DOS			; DOS
  8803
  8804 				; secondary commands (can't start a statement)
  8805 D8DF 04 54			.byte	4,'T'
  8806 D8E1 9D D7			.word	LBB_TAB			; TAB
  8807 D8E3 04 45			.byte	4,'E'
  8808 D8E5 3B D6			.word	LBB_ELSE		; ELSE
  8809 D8E7 02 54			.byte	2,'T'
  8810 D8E9 A9 D7			.word	LBB_TO			; TO
  8811 D8EB 02 46			.byte	2,'F'
  8812 D8ED 4F D6			.word	LBB_FN			; FN
  8813 D8EF 04 53			.byte	4,'S'
  8814 D8F1 83 D7			.word	LBB_SPC			; SPC
  8815 D8F3 04 54			.byte	4,'T'
  8816 D8F5 A5 D7			.word	LBB_THEN		; THEN
  8817 D8F7 03 4E			.byte	3,'N'
  8818 D8F9 E4 D6			.word	LBB_NOT			; NOT
  8819 D8FB 04 53			.byte	4,'S'
  8820 D8FD 8B D7			.word	LBB_STEP		; STEP
  8821 D8FF 05 55			.byte	5,'U'
  8822 D901 B8 D7			.word	LBB_UNTIL		; UNTIL
  8823 D903 05 57			.byte	5,'W'
  8824 D905 D2 D7			.word	LBB_WHILE		; WHILE
  8825 D907 03 4F			.byte	3,'O'
  8826 D909 F2 D6			.word	LBB_OFF			; OFF
  8827
  8828 				; opperators
  8829 D90B 01 2B			.byte	1,'+'
  8830 D90D 00 00			.word	$0000			; +
  8831 D90F 01 2D			.byte	1,'-'
  8832 D911 00 00			.word	$0000			; -
  8833 D913 01 2A			.byte	1,'*'
  8834 D915 00 00			.word	$0000			; *
  8835 D917 01 2F			.byte	1,'/'
  8836 D919 00 00			.word	$0000			; /
  8837 D91B 05 4D			.byte	5,'M'
  8838 D91D D4 D6			.word	LBB_MOD			; MOD
  8839 D91F 01 5E			.byte	1,'^'
  8840 D921 00 00			.word	$0000			; ^
  8841 D923 03 41			.byte	3,'A'
  8842 D925 D2 D5			.word	LBB_AND			; AND
  8843 D927 03 45			.byte	3,'E'
  8844 D929 42 D6			.word	LBB_EOR			; EOR
  8845 D92B 02 4F			.byte	2,'O'
  8846 D92D F7 D6			.word	LBB_OR			; OR
  8847 D92F 02 3E			.byte	2,'>'
  8848 D931 C8 D5			.word	LBB_RSHIFT		; >>
  8849 D933 02 3C			.byte	2,'<'
  8850 D935 C2 D5			.word	LBB_LSHIFT		; <<
  8851 D937 01 3E			.byte	1,'>'
  8852 D939 00 00			.word	$0000			; >
  8853 D93B 01 3D			.byte	1,'='
  8854 D93D 00 00			.word	$0000			; =
  8855 D93F 01 3C			.byte	1,'<'
  8856 D941 00 00			.word	$0000			; <
  8857
  8858 				; functions
  8859 D943 04 53			.byte	4,'S'			;
  8860 D945 7B D7			.word	LBB_SGN			; SGN
  8861 D947 04 49			.byte	4,'I'			;
  8862 D949 89 D6			.word	LBB_INT			; INT
  8863 D94B 04 41			.byte	4,'A'			;
  8864 D94D CE D5			.word	LBB_ABS			; ABS
  8865 D94F 04 55			.byte	4,'U'			;
  8866 D951 BD D7			.word	LBB_USR			; USR
  8867 D953 04 46			.byte	4,'F'			;
  8868 D955 54 D6			.word	LBB_FRE			; FRE
  8869 D957 04 50			.byte	4,'P'			;
  8870 D959 22 D7			.word	LBB_POS			; POS
  8871 D95B 04 53			.byte	4,'S'			;
  8872 D95D 87 D7			.word	LBB_SQR			; SQR
  8873 D95F 04 52			.byte	4,'R'			;
  8874 D961 64 D7			.word	LBB_RND			; RND
  8875 D963 04 4C			.byte	4,'L'			;
  8876 D965 BE D6			.word	LBB_LOG			; LOG
  8877 D967 04 45			.byte	4,'E'			;
  8878 D969 45 D6			.word	LBB_EXP			; EXP
  8879 D96B 04 43			.byte	4,'C'			;
  8880 D96D 15 D6			.word	LBB_COS			; COS
  8881 D96F 04 53			.byte	4,'S'			;
  8882 D971 7F D7			.word	LBB_SIN			; SIN
  8883 D973 04 54			.byte	4,'T'			;
  8884 D975 A1 D7			.word	LBB_TAN			; TAN
  8885 D977 04 41			.byte	4,'A'			;
  8886 D979 D9 D5			.word	LBB_ATN			; ATN
  8887 D97B 05 50			.byte	5,'P'			;
  8888 D97D FE D6			.word	LBB_PEEK		; PEEK
  8889 D97F 05 44			.byte	5,'D'			;
  8890 D981 21 D6			.word	LBB_DEEK		; DEEK
  8891 D983 05 53			.byte	5,'S'			;
  8892 D985 6C D7			.word	LBB_SADD		; SADD
  8893 D987 04 4C			.byte	4,'L'			;
  8894 D989 A5 D6			.word	LBB_LEN			; LEN
  8895 D98B 05 53			.byte	5,'S'			;
  8896 D98D 93 D7			.word	LBB_STRS		; STR$
  8897 D98F 04 56			.byte	4,'V'			;
  8898 D991 C2 D7			.word	LBB_VAL			; VAL
  8899 D993 04 41			.byte	4,'A'			;
  8900 D995 D5 D5			.word	LBB_ASC			; ASC
  8901 D997 07 55			.byte	7,'U'			;
  8902 D999 B1 D7			.word	LBB_UCASES		; UCASE$
  8903 D99B 07 4C			.byte	7,'L'			;
  8904 D99D 98 D6			.word	LBB_LCASES		; LCASE$
  8905 D99F 05 43			.byte	5,'C'			;
  8906 D9A1 FF D5			.word	LBB_CHRS		; CHR$
  8907 D9A3 05 48			.byte	5,'H'			;
  8908 D9A5 66 D6			.word	LBB_HEXS		; HEX$
  8909 D9A7 05 42			.byte	5,'B'			;
  8910 D9A9 E2 D5			.word	LBB_BINS		; BIN$
  8911 D9AB 07 42			.byte	7,'B'			;
  8912 D9AD F3 D5			.word	LBB_BITTST		; BITTST
  8913 D9AF 04 4D			.byte	4,'M'			;
  8914 D9B1 C7 D6			.word	LBB_MAX			; MAX
  8915 D9B3 04 4D			.byte	4,'M'			;
  8916 D9B5 D0 D6			.word	LBB_MIN			; MIN
  8917 D9B7 02 50			.byte	2,'P'			;
  8918 D9B9 08 D7			.word	LBB_PI			; PI
  8919 D9BB 05 54			.byte	5,'T'			;
  8920 D9BD AB D7			.word	LBB_TWOPI		; TWOPI
  8921 D9BF 07 56			.byte	7,'V'			;
  8922 D9C1 C6 D7			.word	LBB_VPTR		; VARPTR
  8923 D9C3 06 4C			.byte	6,'L'			;
  8924 D9C5 9F D6			.word	LBB_LEFTS		; LEFT$
  8925 D9C7 07 52			.byte	7,'R'			;
  8926 D9C9 5D D7			.word	LBB_RIGHTS		; RIGHT$
  8927 D9CB 05 4D			.byte	5,'M'			;
  8928 D9CD CB D6			.word	LBB_MIDS		; MID$
  8929 D9CF 05 50			.byte	5,'P'			;
  8930 D9D1 19 D7			.word	LBB_PORTIN		; PORTIN
  8931 D9D3 06 49			.byte	6,'I'			;
  8932 D9D5 70 D6			.word	LBB_I2CIN		; I2CIN
  8933 D9D7 05 52			.byte	5,'R'			;
  8934 D9D9 4D D7			.word	LBB_RES5		; RESERVED
  8935 D9DB 05 52			.byte	5,'R'			;
  8936 D9DD 52 D7			.word	LBB_RES6		; RESERVED
  8937
  8938 				; BASIC messages, mostly error messages
  8939 D9DF			LAB_BAER
  8940 D9DF 03 DA			.word	ERR_NF			;$00 NEXT without FOR
  8941 D9E1 14 DA			.word	ERR_SN			;$02 syntax
  8942 D9E3 1B DA			.word	ERR_RG			;$04 RETURN without GOSUB
  8943 D9E5 30 DA			.word	ERR_OD			;$06 out of data
  8944 D9E7 3C DA			.word	ERR_FC			;$08 function call
  8945 D9E9 4A DA			.word	ERR_OV			;$0A overflow
  8946 D9EB 53 DA			.word	ERR_OM			;$0C out of memory
  8947 D9ED 61 DA			.word	ERR_US			;$0E undefined statement
  8948 D9EF 75 DA			.word	ERR_BS			;$10 array bounds
  8949 D9F1 82 DA			.word	ERR_DD			;$12 double dimension array
  8950 D9F3 93 DA			.word	ERR_D0			;$14 divide by 0
  8951 D9F5 A2 DA			.word	ERR_ID			;$16 illegal direct
  8952 D9F7 B1 DA			.word	ERR_TM			;$18 type mismatch
  8953 D9F9 BF DA			.word	ERR_LS			;$1A long string
  8954 D9FB CF DA			.word	ERR_ST			;$1C string too complex
  8955 D9FD E2 DA			.word	ERR_CN			;$1E continue error
  8956 D9FF F1 DA			.word	ERR_UF			;$20 undefined function
  8957 DA01 04 DB			.word 	ERR_LD			;$22 LOOP without DO
  8958
  8959 				; I may implement these two errors to force definition of variables and
  8960 				; dimensioning of arrays before use.
  8961
  8962 				;	.word ERR_UV		;$24 undefined variable
  8963
  8964 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8965
  8966 				;	.word ERR_UA		;$26 undimensioned array
  8967 DA03 4E 45 58 54 20 77 + ERR_NF	.by	'NEXT without FOR',$00
  8968 DA14 53 79 6E 74 61 78 + ERR_SN	.by	'Syntax',$00
  8969 DA1B 52 45 54 55 52 4E + ERR_RG	.by	'RETURN without GOSUB',$00
  8970 DA30 4F 75 74 20 6F 66 + ERR_OD	.by	'Out of DATA',$00
  8971 DA3C 46 75 6E 63 74 69 + ERR_FC	.by	'Function call',$00
  8972 DA4A 4F 76 65 72 66 6C + ERR_OV	.by	'Overflow',$00
  8973 DA53 4F 75 74 20 6F 66 + ERR_OM	.by	'Out of memory',$00
  8974 DA61 55 6E 64 65 66 69 + ERR_US	.by	'Undefined statement',$00
  8975 DA75 41 72 72 61 79 20 + ERR_BS	.by	'Array bounds',$00
  8976 DA82 44 6F 75 62 6C 65 + ERR_DD	.by	'Double dimension',$00
  8977 DA93 44 69 76 69 64 65 + ERR_D0	.by	'Divide by zero',$00
  8978 DAA2 49 6C 6C 65 67 61 + ERR_ID	.by	'Illegal direct',$00
  8979 DAB1 54 79 70 65 20 6D + ERR_TM	.by	'Type mismatch',$00
  8980 DABF 53 74 72 69 6E 67 + ERR_LS	.by	'String too long',$00
  8981 DACF 53 74 72 69 6E 67 + ERR_ST	.by	'String too complex',$00
  8982 DAE2 43 61 6E 27 74 20 + ERR_CN	.by	'Can' $27 't continue',$00
  8983 DAF1 55 6E 64 65 66 69 + ERR_UF	.by	'Undefined function',$00
  8984 DB04 4C 4F 4F 50 20 77 + ERR_LD	.by	'LOOP without DO',$00
  8985
  8986 				;ERR_UV	.byte	'Undefined variable',$00
  8987
  8988 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8989
  8990 				;ERR_UA	.byte	'Undimensioned array',$00
  8991 DB14 0D 0A 42 72 65 61 + LAB_BMSG	.byte	$0D,$0A,'Break',$00
  8992 DB1C 20 45 72 72 6F 72 + LAB_EMSG	.byte	' Error',$00
  8993 DB23 20 69 6E 20 6C 69 + LAB_LMSG	.byte	' in line ',$00
  8994 DB2D 0D 0A 52 65 61 64 + LAB_RMSG	.byte	$0D,$0A,'Ready',$0D,$0A,$00
  8995
  8996 DB37 20 45 78 74 72 61 + LAB_IMSG	.byte	' Extra ignored',$0D,$0A,$00
  8997 DB48 20 52 65 64 6F 20 + LAB_REDO	.byte	' Redo from start',$0D,$0A,$00
  8998
  8999 DB5B			AA_end_basic
    36 						
    37 DB5B					ORG	$DFD8
    38 				;----------------------------------------------------------------------------
    39 				; This function enables BIOS-ROM at $E000-$FFFF and disables the RAM behind it.
    40 				;----------------------------------------------------------------------------
    41 DFD8 AD 00 17		BIOS2ROM	LDA	MMU		; MMU-register
    42 DFDB 09 01				ORA	#BIOS_EN	; 1 = enable BIOS ROM
    43 DFDD 8D 00 17				STA	MMU		; Activate BIOS ROM
    44 DFE0 60					RTS			; return
    45 						
    46 				;----------------------------------------------------------------------------
    47 				; This function Enables BIOS-RAM at $E000-$FFFF and disables BIOS-ROM.
    48 				;----------------------------------------------------------------------------
    49 DFE1 AD 00 17		BIOS2RAM	LDA	MMU		; MMU-register
    50 DFE4 29 FE				AND	#~BIOS_EN	; 0 = enable BIOS RAM, disable ROM
    51 DFE6 8D 00 17				STA	MMU		; Activate BIOS RAM
    52 DFE9 60					RTS			; return
    53
    54 DFEA					ORG 	$DFF0
    55 DFF0 42			LANGKEY		.byte	'B'
    56 DFF1 28 42 29 61 73 69 + LANGNAME 	.by	'(B)asic' $00
    57
    58 DFF9					ORG 	$E000       		; start address of BIOS (8K)
    59 E000					icl 	"jc2_bios.asm"
Source: jc2_bios.asm
     1 				; ******************************************************************************
     2 				; Junior Computer ][ BIOS Version 1.2.0 by Joerg Walke
     3 				;
     4 				; first implementation 28.12.2021
     5 				; updated 16.11.2024 by Joerg Walke
     6 				;
     7 				; Assembled With A65
     8 				;
     9 				; 20.03.2023 A bug in the disassembler code was fixed by the German Classic 
    10 				; Computing forum user jet2bue. See version history
    11 				;
    12 				; 01.08.2023 A bug in SD_WR_BLK was fixed. The bug was found by German Classic 
    13 				; Computing forum user Dietrich Lausberg. See version history
    14 				;
    15 				; 29.04.2024 SPI & IRQ optimization by Dietrich Lausberg
    16 				;
    17 				; 26.05.24 Changes in Fast SPI by Dietrich Lausberg
    18 				;
    19 				; 21.04.24 Integration with CF-IDE drivers into 1 32K eprom
    20 				; ******************************************************************************
    21
    22 E000 4C 3F E4		MON_COLD_START	JMP  	MAINSTART	; jump to monitor cold start
    23 E003 4C 3E E6		MON_WARM_START	JMP	MONINP		; jump to monitor warm start
    24
    25 				; **** Switch BASIC To RAM Page (B000..DFFF) ***********************************
    26 				; ******************************************************************************
    27 E006 20 8F FD		SWITCH_TO_RAM	JSR	BAS2RAM		; Set MMU bit 7 to 0, enable BASIC RAM
    28 E009 60					RTS			; return
    29
    30 				; **** Switch BASIC To ROM Page (B000..DFFF) ***********************************
    31 				; ******************************************************************************
    32 E00A 20 98 FD		SWITCH_TO_ROM	JSR	BAS2ROM		; Set MMU bit 7 to 1, enable BASIC ROM
    33 E00D EA			SWITCH		NOP			; maintain compatibility with v1.1.4
    34 E00E 60					RTS
    35
    36 				; **** Set Standard In/Out Routine ID ******************************************
    37 				; Input: A - ID Of Standard IO Device
    38 				; ******************************************************************************
    39 E00F 20 BE F7		SET_STDIOID	JSR	DEV_OPEN
    40
    41 				; **** Set Standard In/Out Routine *********************************************
    42 				; Input: X - Low Byte Of Standard Device Descriptor
    43 				;	 Y - High Byte Of Standard Device Descriptor
    44 				; ******************************************************************************
    45 E012 20 32 E0		SET_STDIO	JSR	SET_STDIN
    46 E015 4C 1F E0				JMP	SET_STDOUT0
    47
    48 				; **** Set Standard Out Routine ID *********************************************
    49 				; Input: A - ID Of Standard Output Device
    50 				; ******************************************************************************
    51 E018 20 BE F7		SET_STDOUTID	JSR	DEV_OPEN
    52
    53 				; **** Set Standard Out Routine ************************************************
    54 				; Input: X - Low Byte Of Standard Out Device Descriptor
    55 				;	 Y - High Byte Of Standard Out Device Descriptor
    56 				; ******************************************************************************
    57 E01B 86 DE		SET_STDOUT	STX	PDEVL
    58 E01D 84 DF				STY	PDEVH
    59 E01F A0 04		SET_STDOUT0	LDY	#$04
    60 E021 A2 00				LDX	#$00
    61 E023 B1 DE		SET_STDOUT1	LDA	(PDEV),Y
    62 E025 9D 70 1A				STA	STDOUT,X
    63 E028 C8					INY
    64 E029 E8					INX
    65 E02A E0 04				CPX	#$04
    66 E02C D0 F5				BNE	SET_STDOUT1
    67 E02E 60					RTS
    68
    69 				; **** Set Standard In Routine ID **********************************************
    70 				; Input: A - ID Of Standard Input Device
    71 				; ******************************************************************************
    72 E02F 20 BE F7		SET_STDINID	JSR	DEV_OPEN
    73
    74 				; **** Set Standard In Routine *************************************************
    75 				; Input: X - Low Byte Of Standard In Device Descriptor
    76 				;	 Y - High Byte Of Standard In Device Descriptor
    77 				; ******************************************************************************
    78 E032 86 DE		SET_STDIN	STX	PDEVL
    79 E034 84 DF				STY	PDEVH
    80 E036 A0 02				LDY	#$02
    81 E038 B1 DE				LDA	(PDEV),Y
    82 E03A 8D 6E 1A				STA	STDIN
    83 E03D C8					INY
    84 E03E B1 DE				LDA	(PDEV),Y
    85 E040 8D 6F 1A				STA	STDIN+1
    86 E043 60			         	RTS
    87
    88 				; **** Write Binary Routine ****************************************************
    89 				; Input: A - Output Byte to Standard Out
    90 				; ******************************************************************************
    91 E044 6C 70 1A		BOUT		JMP	(STDOUT)
    92
    93 				; **** Read Character Routine **************************************************
    94 				; Output: A - character read from standard in
    95 				; ******************************************************************************
    96 E047 20 4D E0		CIN		JSR	CGET		; call standard in. Character available?
    97 E04A 90 FB				BCC	CIN		; no, repeat
    98 E04C 60					RTS
    99
   100 				; **** Get Character (no wait) Routine *****************************************
   101 				; Output: A - character read from standard in
   102 				;         C - 1 char get, 0 no char get
   103 				; ******************************************************************************
   104 E04D 4C D4 E1		CGET            JMP     CHAR_GET
   105
   106 				; **** Write LF Character Routine **********************************************
   107 				; ******************************************************************************
   108 E050 A9 0A		LFOUT		LDA  	#LF        	; write a LF
   109 									; fall through to COUT
   110
   111 				; **** Write Character Routine *************************************************
   112 				; Input: A - character to write
   113 				; ******************************************************************************
   114 E052 20 44 E0		COUT 		JSR     BOUT
   115 E055 C9 0D		                CMP  	#CR        	; character was a CR?
   116 E057 F0 F7				BEQ  	LFOUT      	; yes, also write LF
   117 E059 60					RTS
   118
   119 				; **** Write CR/LF To Terminal *************************************************
   120 				; ******************************************************************************
   121 E05A A9 0D		CROUT		LDA	#CR		; write a CR
   122 E05C D0 F4				BNE	COUT
   123
   124 				; **** Write Single Space Char To Terminal *************************************
   125 				; ******************************************************************************
   126 E05E A9 20		SPCOUT		LDA	#$20		; write a Space char
   127 E060 D0 E2				BNE	BOUT
   128
   129 				; **** Read String Routine *****************************************************
   130 				; Output:  (PSTRL, PSTRH) - pointer to CR terminated string data
   131 				; ******************************************************************************
   132 E062 A2 02		STRIN           LDX  	#$02		; initialize character index
   133 E064 CA			BACKSPACE       DEX
   134 E065 F0 FB				BEQ  	STRIN		; if line empty, restart
   135 E067 20 47 E0		NEXTCHR         JSR  	CIN        	; get next character from input buffer
   136 E06A 9D 00 14				STA  	STRBUF,X   	; store character in string buffer
   137 E06D C9 0D				CMP  	#CR		; is it a CR?
   138 E06F F0 0F		                BEQ  	ENDSTRIN	; yes, exit
   139 E071 20 52 E0		                JSR  	COUT		; echo character
   140 E074 C9 08				CMP  	#BS        	; backspace key?
   141 E076 F0 EC				BEQ  	BACKSPACE  	; yes
   142 E078 E8			                INX             	; advance string index
   143 E079 D0 EC		                BNE  	NEXTCHR    	; more then 255 characters? No, read next char
   144 E07B A9 0D		                LDA  	#CR        	; yes, auto new line and stop reading
   145 E07D 9D 00 14				STA  	STRBUF,X   	; store CR in string buffer
   146 E080 4C 52 E0		ENDSTRIN        JMP  	COUT       	; send CR
   147
   148 				; **** Write String Routine ****************************************************
   149 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   150 				; ******************************************************************************
   151 E083 A0 00		STROUT		LDY  	#$00       	; index y is 0
   152
   153 				; **** Write String From Index Routine *****************************************
   154 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   155 				;	  Y              - start index into string data
   156 				; ******************************************************************************
   157 E085 B1 EA		WRSTR		LDA  	(PSTR),Y   	; load char at string pos y
   158 E087 F0 07				BEQ  	ENDSTROUT  	; exit, if NULL char
   159 E089 20 52 E0				JSR  	COUT       	; write character
   160 E08C C8					INY             	; next index
   161 E08D 4C 85 E0				JMP  	WRSTR
   162 E090 60			ENDSTROUT	RTS
   163
   164 				; **** Print A Byte In Hexadecimal *********************************************
   165 				; Input: A - data byte to print in hex
   166 				; ******************************************************************************
   167 E091 48			HEXOUT          PHA             	; save A for lower hex digit
   168 E092 4A			                LSR  	
   169 E093 4A			                LSR  	
   170 E094 4A			                LSR  	
   171 E095 4A			                LSR  	
   172 E096 20 9A E0		                JSR  	HEXDIG		; write upper hex digit
   173 E099 68			                PLA             	; write lower hex digit
   174 									; fall through to HEXDIG
   175
   176 				; **** Print A Single Hexadecimal Digit ****************************************
   177 				; Input: A - data nibble in Bit 0-3 to print in hex
   178 				; ******************************************************************************
   179 E09A 29 0F		HEXDIG          AND     #$0F    	; mask lower digit
   180 E09C 09 30		                ORA     #'0'    	; add 48
   181 E09E C9 3A		                CMP     #'9'+1  	; decimal digit?
   182 E0A0 90 02		                BCC     PRHEX   	; yes, print it
   183 E0A2 69 06		                ADC     #6      	; add offset for letter digit
   184 E0A4 4C 44 E0		PRHEX		JMP     BOUT
   185
   186 				; **** Print A Byte As Decimal Number ******************************************
   187 				; Input: A - number 00..FF (0..255)
   188 				; ******************************************************************************
   189 E0A7 20 BD E0		NUMOUT		JSR	DEC2STR
   190 E0AA A2 02				LDX	#2
   191 E0AC B5 F8		NEXTNUMOUT	LDA	DIG0,X
   192 E0AE 20 44 E0				JSR	BOUT
   193 E0B1 CA					DEX
   194 E0B2 10 F8				BPL	NEXTNUMOUT
   195 E0B4 60					RTS
   196
   197 				; **** Clear Screen Routine ****************************************************
   198 				; ******************************************************************************
   199 E0B5 A9 07		CLRSCRN		LDA	#CMD_CLRSCRN
   200
   201 				; **** Call Standard Print Command Routine *************************************
   202 				; Input : A - command byte
   203 				;         X - command data byte low
   204 				;         Y - command data byte high
   205 				; ******************************************************************************
   206 E0B7 6C 72 1A		CMDPRINT	JMP	(STDCMD)
   207
   208 				; **** Call Opened Device Command Routine **************************************
   209 				; Input : A - command byte
   210 				;         X - command data byte low
   211 				;         Y - command data byte high
   212 				; ******************************************************************************
   213 E0BA 6C 6C 1A		CMDDEV		JMP	(DEVCMD)
   214
   215 				; **** Convert a Byte To Decimal String ****************************************
   216 				; Input:  A - number 00..FF (0..255)
   217 				; Output; DIG0 (10^0), DIG1 (10^1), DIG2 (10^2)
   218 				; ******************************************************************************
   219 E0BD A2 30		DEC2STR		LDX	#48
   220 E0BF 86 F8				STX	DIG0		; initialize digit counter 0 to '0'
   221 E0C1 86 F9				STX	DIG1		; initialize digit counter 1 to '0'
   222 E0C3 86 FA				STX	DIG2		; initialize digit counter 2 to '0'
   223 E0C5 C9 64		GETDIG2		CMP	#100		; is A >= 100?
   224 E0C7 90 06				BCC	GETDIG1		; no, convert next digit
   225 E0C9 E9 64				SBC	#100		; yes, subract 100 from A
   226 E0CB E6 FA				INC	DIG2		; and increment digit counter 2
   227 E0CD D0 F6				BNE	GETDIG2		; branch always
   228 E0CF C9 0A		GETDIG1		CMP	#10		; is A >= 10?
   229 E0D1 90 06				BCC	GETDIG0		; no, convert next digit
   230 E0D3 E9 0A				SBC	#10		; yes, subract 10 from A
   231 E0D5 E6 F9				INC	DIG1		; and increment digit counter 1
   232 E0D7 D0 F6				BNE	GETDIG1		; branch always
   233 E0D9 65 F8		GETDIG0		ADC	DIG0		; add digit counter 0 to remainder in A
   234 E0DB 85 F8				STA	DIG0		; and store it back to digit counter 0
   235 E0DD 60					RTS
   236
   237 				; **** Print Tab Routine *******************************************************
   238 				; Input: A - number of space characters to print
   239 				; ******************************************************************************
   240 E0DE 85 FC		TAB		STA  	TEMP
   241 E0E0 A9 20				LDA  	#SPC		; load SPC char
   242 E0E2 20 52 E0		PRINTTAB	JSR  	COUT		; write SPC
   243 E0E5 C6 FC				DEC   	TEMP
   244 E0E7 D0 F9		                BNE   	PRINTTAB   	; all spaces written? No, repeat
   245 E0E9 60					RTS
   246
   247 				; **** Read Hex Number From Input String ***************************************
   248 				; Input:  Y - current input string position to read from
   249 				; Output: (NUML, NUMH) - last 8 digits of read hex number
   250 				; ******************************************************************************
   251 E0EA A2 00		HEXINPUT	LDX   	#$00
   252 E0EC 86 F8				STX   	NUML       	; clear input value
   253 E0EE 86 F9				STX   	NUMH
   254 E0F0 B9 00 14		NEXTDIGIT       LDA   	STRBUF,Y   	; get next input char
   255 E0F3 C9 30				CMP   	#'0'
   256 E0F5 90 21				BCC   	NOTHEX     	; char < '0'? Yes, no hex digit
   257 E0F7 C9 3A				CMP   	#':'
   258 E0F9 90 0C				BCC   	NUMDIGIT   	; char is in '0'..'9'
   259 E0FB 29 DF				AND   	#$DF	 	; uppercase chars only
   260 E0FD C9 41		HEXDIGIT	CMP   	#'A'
   261 E0FF 90 17				BCC   	NOTHEX     	; char < 'A'? Yes, no hex digit
   262 E101 C9 47				CMP   	#'G'
   263 E103 B0 13				BCS   	NOTHEX     	; char > 'F'? Yes, no hex digit
   264 E105 E9 36				SBC   	#'A'-11	 	; char 'A'..'F' to value 10..16
   265 E107 0A			NUMDIGIT        ASL   	
   266 E108 0A					ASL   	
   267 E109 0A					ASL   	
   268 E10A 0A					ASL   			; digit shifted to upper nibble
   269 E10B A2 04				LDX   	#$04      	; load shift loop counter
   270 E10D 0A			SHIFT		ASL   			; shift msb in C
   271 E10E 26 F8				ROL   	NUML
   272 E110 26 F9				ROL   	NUMH
   273 E112 CA					DEX
   274 E113 D0 F8				BNE   	SHIFT	 	; 4 times shifted? No, repeat
   275 E115 C8					INY		 	; increment string index
   276 E116 D0 D8				BNE   	NEXTDIGIT	; branch always
   277 E118 60			NOTHEX		RTS
   278
   279 				; **** Read String From Input Buffer *******************************************
   280 				; Input:  Y - current input string position to read from
   281 				; Output: C = 1, string found C = 0, string not found
   282 				;         PSTRL = low byte of string pointer
   283 				;	  PSTRH = high byte of string pointer
   284 				; ******************************************************************************
   285 E119 18			STRINPUT	CLC
   286 E11A B9 00 14		NEXTSTRCHAR	LDA  	STRBUF,Y   	; get next input char
   287 E11D C8					INY
   288 E11E C9 20				CMP  	#' '
   289 E120 F0 F8				BEQ  	NEXTSTRCHAR 	; ignore spaces
   290 E122 C9 0D				CMP  	#CR
   291 E124 F0 19				BEQ  	ENDSTRING 	; end of input line, no filename found
   292 E126 C9 22				CMP	#'"'
   293 E128 D0 15				BNE	ENDSTRING
   294 E12A A2 00				LDX	#$00
   295 E12C 38					SEC
   296 E12D B9 00 14		READSTRING	LDA  	STRBUF,Y   	; get next input char
   297 E130 C9 0D				CMP	#CR
   298 E132 F0 0B				BEQ	ENDSTRING
   299 E134 C9 22				CMP	#'"'
   300 E136 F0 07				BEQ	ENDSTRING
   301 E138 9D 00 15				STA	RBUFF,X		; char to buffer
   302 E13B C8					INY
   303 E13C E8					INX
   304 E13D D0 EE				BNE	READSTRING	; read next char of filename
   305 E13F A9 00		ENDSTRING	LDA	#$00
   306 E141 9D 00 15				STA	RBUFF,X		; terminate filename string with NULL
   307
   308 				; **** Set String Pointer To Read Buffer ***************************************
   309 				; Output: X - low byte of string pointer
   310 				;	  Y - high byte of string pointer
   311 				; ******************************************************************************
   312
   313 E144 A2 00		SETSTRBUFF	LDX	#< RBUFF	; set string pointer to filename buffer
   314 E146 A0 15				LDY	#> RBUFF
   315 E148 86 EA		SETSTRBUFF0	STX	PSTRL
   316 E14A 84 EB				STY	PSTRH
   317 E14C 60					RTS
   318
   319 				; **** Delay Routine ***********************************************************
   320 				; Input: A - milliseconds to wait
   321 				; ******************************************************************************
   322 E14D 8D 97 1A		DELAY           STA  	CNTD
   323 E150 D0 04				BNE	LOOPDELAY
   324
   325 				; **** Short Delay Routine *****************************************************
   326 				; Input: A - microseconds to wait
   327 				; ******************************************************************************
   328 E152 A8			SHORTDELAY	TAY
   329 E153 8C 94 1A		SHORTDELAY1	STY  	CNTA		; set counter
   330 E156 2C 9F 1A		LOOPDELAY	BIT  	CNTIRQ		; check if counter reached 0
   331 E159 10 FB				BPL  	LOOPDELAY	; no, check again
   332 E15B 60					RTS
   333
   334 				; **** Check ESC Routine *******************************************************
   335 				; Output: C = 1 ESC pressed, 0 ESC not pressed
   336 				; Beep if ESC pressed
   337 				; ******************************************************************************
   338 E15C 20 4D E0		CHKESC		JSR     CGET            ; key pressed?
   339 E15F 90 05				BCC	NOTESC		; no
   340 E161 C9 1B				CMP     #ESC		; ESC pressed?
   341 E163 F0 02				BEQ	BEEP		; yes, exit and beep.
   342 E165 18					CLC			; no, clear carry flag
   343 E166 60			NOTESC		RTS
   344
   345 				; **** System Beep Routine *****************************************************
   346 				; ******************************************************************************
   347 E167 6C 66 1A		BEEP		JMP	(STDBEEP)	; call standard BEEP routine
   348
   349 				; **** Simple Beep Routine *****************************************************
   350 				; ******************************************************************************
   351 E16A AD 83 1A		DOBEEP		LDA	PBDD		; save port b data direction register
   352 E16D 48					PHA
   353 E16E A2 60				LDX     #$60		; repeat 60 times
   354 E170 A9 21				LDA     #$21
   355 E172 A8					TAY
   356 E173 8D 83 1A				STA     PBDD		; turn speaker on
   357 E176 8C 82 1A		BEEPLOOP	STY     PBD		; set PB0 high
   358 E179 A9 01				LDA     #$01
   359 E17B 20 4D E1				JSR     DELAY		; delay of ~1ms
   360 E17E 88					DEY
   361 E17F 8C 82 1A				STY	PBD		; set PB0 low
   362 E182 A9 01				LDA	#$01
   363 E184 20 4D E1				JSR	DELAY		; delay of ~1ms
   364 E187 A0 21				LDY	#$21
   365 E189 CA					DEX
   366 E18A D0 EA				BNE	BEEPLOOP	; not finished, repeat
   367 E18C 68					PLA
   368 E18D 8D 83 1A				STA	PBDD		; restore port b data direction register
   369 E190 38					SEC
   370 E191 60					RTS
   371
   372 				; ******************************************************************************
   373 				; REAL TIME CLOCK ROUTINES ALIASES
   374 				; ******************************************************************************
   375
   376 				; **** Print Date And Time *****************************************************
   377
   378 				; ******************************************************************************
   379
   380 E192 4C F9 EB		PRINT_DATETIME	JMP	PRINTDATETIME
   381
   382 				; **** Print Time *************************************************************
   383
   384 				; ******************************************************************************
   385
   386 E195 4C 05 EC		PRINT_TIME	JMP	PRINTTIME
   387
   388 				; **** Print Date **************************************************************
   389
   390 				; ******************************************************************************
   391
   392 E198 4C 2B EC		PRINT_DATE	JMP	PRINTDATE
   393
   394 				; **** Print Date Including Day Of Week ****************************************
   395
   396 				; ******************************************************************************
   397
   398 E19B 4C 17 EC		PRINT_FULLDATE	JMP	PRINTFULLDATE
   399
   400 				; **** Set Date And Time *******************************************************
   401
   402 				; ******************************************************************************
   403
   404 E19E 4C 59 EB		SET_DATETIME	JMP	SETDATETIME
   405
   406 				; **** Set Time ****************************************************************
   407
   408 				; ******************************************************************************
   409
   410 E1A1 4C 86 EB		SET_TIME	JMP	SETTIME
   411
   412 				; **** Set Date ****************************************************************
   413
   414 				; ******************************************************************************
   415
   416 E1A4 4C 5C EB		SET_DATE	JMP	SETDATE
   417
   418 				; **** Add Storage Device ******************************************************
   419
   420 				; Input:   X - device descriptor pointer low
   421 				;          Y - device descriptor pointer high
   422 				; Output - C = 1 Success, C = 0 Error
   423 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
   424
   425 				; ******************************************************************************
   426
   427 E1A7 4C 6F F7		ADD_DEVICE	JMP	DEV_ADD
   428
   429 				; **** Open Device For Read/Write **********************************************
   430
   431 				; Input:  A - device id
   432 				; Output: C = 1 Success, C = 0 Error
   433 				;         X - device descriptor pointer low
   434 				;         Y - device descriptor pointer high
   435
   436 				; ******************************************************************************
   437
   438 E1AA 4C BE F7		OPEN_DEVICE	JMP	DEV_OPEN
   439
   440 				; **** Reset Standard I/O To First Screen Device *******************************
   441
   442 				; ******************************************************************************
   443
   444 E1AD AD 74 1A		RESET_STDIO	LDA	STDINDEV	; open base In device
   445 E1B0 20 2F E0				JSR	SET_STDINID	; and set it as standard input
   446 E1B3 AD 75 1A				LDA	STDOUTDEV	; open base Out device
   447 E1B6 4C 18 E0				JMP	SET_STDOUTID	; and set it as standard output
   448
   449 				; **** Read Joystick Port ******************************************************
   450
   451 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   452 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   453 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   454 				;         C = 0 - No joystick port available; C = 1 - Joystickport available
   455
   456 				; ******************************************************************************
   457
   458 E1B9 4C 15 F7		READ_JOYSTICK   JMP     READ_JOY_PORT
   459
   460 				; **** Decode Joystick Data ****************************************************
   461
   462 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   463 				;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   464 				;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   465
   466 				; ******************************************************************************
   467
   468 E1BC 4C 1D F7		DECODE_JOYSTICK JMP     DECODE_JOY_PORT
   469
   470 				; **** Mute All Sound Chip Channels ********************************************
   471
   472 				; ******************************************************************************
   473
   474 E1BF 4C D0 E3		SOUND_MUTE_ALL  JMP     SOUND_MUTEALL
   475
   476 				; **** Mute A Sound Chip Channel ***********************************************
   477
   478 				; Input: A - Channel # (0..3)
   479
   480 				; ******************************************************************************
   481
   482 E1C2 4C DA E3		SOUND_MUTE_CHAN JMP     SOUND_MUTE
   483
   484 				; **** Set Attenuation For A Sound Chip Channel ********************************
   485
   486 				; Input: A - Channel # (0..3)
   487 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
   488
   489 				; ******************************************************************************
   490
   491 E1C5 4C DC E3		SOUND_SET_ATN   JMP     SOUND_SETATN
   492
   493 				; **** Set Periodic Noise ******************************************************
   494
   495 				; Input: X - Noise Shift Rate
   496
   497 				; ******************************************************************************
   498
   499 E1C8 4C EA E3		SOUND_P_NOISE   JMP     SOUND_PNOISE
   500
   501 				; **** Set White Noise *********************************************************
   502
   503 				; Input: X - Noise Shift Rate
   504
   505 				; ******************************************************************************
   506
   507 E1CB 4C EE E3		SOUND_W_NOISE   JMP     SOUND_WNOISE
   508
   509 				; **** Set Noise ***************************************************************
   510
   511 				; Input: A - 0 = Periodic Noise  1 = White Noise
   512 				;	 X - Noise Shift Rate
   513
   514 				; ******************************************************************************
   515
   516 E1CE 4C F0 E3		SOUND_SET_NOISE JMP     SOUND_SETNOISE
   517
   518 				; **** Set Sound Frequency in HZ ***********************************************
   519
   520 				; Input: A - Channel (0..2)
   521 				;	 X - Frequency Low Bits 7..0
   522 				;	 Y - Frequency High Bits 9..8
   523
   524 				; ******************************************************************************
   525
   526 E1D1 4C FB E3		SOUND_SET_FREQ  JMP     SOUND_SETFREQ
   527
   528 				; ******************************************************************************
   529 				; INTERNAL
   530 				; ******************************************************************************
   531
   532 				; **** Extended Read-Character Handler *****************************************
   533
   534 E1D4 20 DF E1		CHAR_GET        JSR     READ_STD_IN
   535 E1D7 90 03		                BCC     NO_CHAR_GET
   536 E1D9 6C 24 1A		                JMP     (KEY_HANDLER)
   537 E1DC 6C 26 1A		NO_CHAR_GET     JMP     (NKEY_HANDLER)
   538 E1DF 6C 6E 1A		READ_STD_IN     JMP	(STDIN)
   539
   540 				; ******************************************************************************
   541 				; TTY DEVICE DRIVER
   542 				; ******************************************************************************
   543
   544 				; **** Terminal Command Routine ************************************************
   545
   546 				; Input : A - command byte
   547 				;         X - command data byte low
   548 				;         Y - command data byte high
   549
   550 				; ******************************************************************************
   551
   552 E1E2 C9 09		TTY_CMD		CMP	#9
   553 E1E4 B0 13				BCS	END_TTY_CMD
   554 E1E6 84 FD				STY	YSAV
   555 E1E8 0A					ASL	
   556 E1E9 A8					TAY
   557 E1EA B9 FA E1				LDA	TTY_CMD_TABLE,Y
   558 E1ED 85 EA				STA	PSTRL
   559 E1EF B9 FB E1				LDA	TTY_CMD_TABLE+1,Y
   560 E1F2 85 EB				STA	PSTRH
   561 E1F4 A4 FD				LDY	YSAV
   562 E1F6 6C EA 00				JMP     (PSTR)
   563 E1F9 60			END_TTY_CMD	RTS
   564
   565 E1FA 0C E2 3A E2 3E E2 + TTY_CMD_TABLE	.word	TTY_INIT,TTY_IDENTIFY,TTY_NORMAL,TTY_INVERSE,TTY_FLASH
   566 E204 4A E2 4E E2 57 E2 + 		.word	TTY_HOME,TTY_CLRLINE,TTY_CLRSCRN,TTY_SETCURSOR
   567
   568 				; **** Initialize TTY Device ***************************************************
   569
   570 				; ******************************************************************************
   571
   572 E20C A9 00		TTY_INIT	LDA  	#$00
   573 E20E 85 E0				STA  	BAUDRATE   	; initialize baud rate variable
   574 E210 A9 0B				LDA  	#$0B       	; set ACIA to
   575 E212 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   576 E215 A2 19				LDX  	#$19		; start with 1 stop bit, 8 data bits, 2400 bps as the current baud rate
   577 E217 8E 03 16		NEXTBAUD	STX  	CTRL_REG	; set the baud rate
   578 E21A 20 3A E2				JSR  	TTY_IDENTIFY	; send identify string to terminal
   579 E21D A9 28				LDA  	#40
   580 E21F 20 4D E1				JSR  	DELAY		; wait for ~64ms
   581 E222 AD 01 16				LDA  	STAT_REG
   582 E225 29 08				AND  	#$08		; ACIA input register full?
   583 E227 F0 0B				BEQ  	NOESC	 	; no, go on
   584 E229 AD 00 16				LDA  	DATA_REG    	; read data register from ACIA
   585 E22C C9 1B				CMP  	#ESC	 	; is it a ESC char
   586 E22E D0 04				BNE  	NOESC	 	; no, go on
   587 E230 86 E0				STX  	BAUDRATE    	; and store it
   588 E232 A2 1F				LDX  	#$1F	 	; detection finished
   589 E234 E8			NOESC           INX  			; try next baud rate
   590 E235 E0 20				CPX  	#$20
   591 E237 90 DE				BCC  	NEXTBAUD   	; tried all baud rates?
   592 E239 60					RTS
   593
   594 				; **** Identify TTY Device *****************************************************
   595
   596 				; ******************************************************************************
   597
   598 E23A A0 09		TTY_IDENTIFY    LDY  	#ESCGID-STRINGP	; load sequence index
   599 E23C D0 1B				BNE  	PRINTESC   	; jump always
   600
   601 				; **** Set Normal Text *********************************************************
   602
   603 				; ******************************************************************************
   604
   605 E23E A0 0C		TTY_NORMAL      LDY  	#ESCNORM-STRINGP; load sequence index
   606 E240 D0 17				BNE  	PRINTESC   	; jump always
   607
   608 				; **** Set Inverse Text ********************************************************
   609
   610 				; ******************************************************************************
   611
   612 E242 A0 0E		TTY_INVERSE     LDY  	#ESCINV-STRINGP ; load sequence index
   613 E244 D0 13				BNE  	PRINTESC   	; jump always
   614
   615 				; **** Set Blinking Text *******************************************************
   616
   617 				; ******************************************************************************
   618
   619 E246 A0 11		TTY_FLASH       LDY  	#ESCBLNK-STRINGP; load sequence index
   620 E248 D0 0F				BNE  	PRINTESC   	; jump always
   621
   622 				; **** Set Cursor To Home Position *********************************************
   623
   624 				; ******************************************************************************
   625
   626 E24A A0 04		TTY_HOME        LDY  	#ESCHOME-STRINGP; load sequence index
   627 E24C D0 0B				BNE  	PRINTESC   	; jump always
   628
   629 				; **** Clear Line **************************************************************
   630
   631 				; ******************************************************************************
   632
   633 E24E A9 0D		TTY_CLRLINE     LDA	#$0D
   634 E250 20 44 E0				JSR	BOUT
   635 E253 A0 06				LDY  	#ESCCLL-STRINGP	; load sequence index
   636 E255 D0 02				BNE  	PRINTESC   	; jump always
   637
   638 				; **** Clear Screen And Set Cursor To Home Position ****************************
   639
   640 				; ******************************************************************************
   641
   642 E257 A0 00		TTY_CLRSCRN     LDY  	#ESCCLS-STRINGP	; load sequence index
   643 									; fall through to PRINTESC
   644
   645 				; **** VT100 ESC Sequence Loader ***********************************************
   646
   647 				; ******************************************************************************
   648
   649 E259 20 62 E2		PRINTESC        JSR	TTY_ESCCODE
   650 E25C 20 43 E5				JSR	LOADSTRING
   651 E25F 4C 85 E0				JMP  	WRSTR
   652
   653 				; **** VT100 ESC Start Code ****************************************************
   654
   655 				; ******************************************************************************
   656
   657 E262 A9 1B		TTY_ESCCODE	LDA	#$1B
   658 E264 20 44 E0				JSR	BOUT
   659 E267 A9 5B				LDA	#'['
   660 E269 4C 44 E0				JMP	BOUT
   661
   662 				; **** Set Cursor Location *****************************************************
   663
   664 				; Input: X - x position of cursor.  Y - y position of cursor
   665
   666 				; ******************************************************************************
   667
   668 E26C 8A			TTY_SETCURSOR	TXA
   669 E26D 48					PHA
   670 E26E 20 62 E2				JSR	TTY_ESCCODE
   671 E271 98					TYA
   672 E272 20 A7 E0				JSR	NUMOUT
   673 E275 A9 3B				LDA	#';'
   674 E277 20 44 E0				JSR	BOUT
   675 E27A 68					PLA
   676 E27B 20 A7 E0				JSR	NUMOUT
   677 E27E A9 48				LDA	#'H'
   678 E280 4C 44 E0				JMP	BOUT
   679
   680 				; ******************************************************************************
   681 				; LOW LEVEL REAL TIME CLOCK CODE
   682 				; ******************************************************************************
   683
   684 				; **** Set Day Of Week *********************************************************
   685
   686 				; Input: A - Day Of Week 1 (MON) - 7 (SUN)
   687
   688 				; ******************************************************************************
   689
   690 E283 85 F3		WRITEDOW	STA	ACC
   691 E285 A9 03				LDA	#$03
   692 E287 20 13 E3				JSR	SETRTCADR
   693 E28A A5 F3				LDA	ACC
   694 E28C 20 67 E3				JSR	I2C_SEND	; set day of week
   695 E28F 4C 35 E3				JMP	I2C_STOP
   696
   697 				; **** Get Day Of Week *********************************************************
   698
   699 				; Output: A - Day Of Week 1 (MON) - 7 (SUN)
   700
   701 				; ******************************************************************************
   702
   703 E292 A9 03		READDOW		LDA	#$03
   704 E294 20 E6 E2				JSR	READCLOCK
   705 E297 98					TYA
   706 E298 60					RTS
   707
   708 				; **** Write Time **************************************************************
   709
   710 				; Input: A - HOUR 	in BCD ($00-$23)
   711 				;	 X - MINUTE 	in BCD ($00-$59)
   712 				;	 Y - SECOND	in BCD ($00-$59)
   713
   714 				; ******************************************************************************
   715
   716 E299 85 F3		WRITETIME	STA	ACC
   717 E29B 86 F5				STX	XREG
   718 E29D 84 F4				STY	YREG
   719 E29F A9 00		WRITETIME2	LDA	#$00		; start at register 0
   720 E2A1 20 C9 E2				JSR	WRITECLOCK	; write time bytes to clock registers
   721 E2A4 A9 08				LDA	#$08		; set address pointer to ram
   722 E2A6 20 13 E3				JSR	SETRTCADR
   723 E2A9 A9 65				LDA	#$65		; time set mark
   724 E2AB 20 67 E3				JSR	I2C_SEND
   725 E2AE 4C 35 E3				JMP	I2C_STOP
   726
   727 				; **** Write Date **************************************************************
   728
   729 				; Input: A - YEAR 	in BCD ($00-$99)
   730 				;	 X - MONTH 	in BCD ($01-$12)
   731 				;	 Y - DAY	in BCD ($01-$31)
   732
   733 				; ******************************************************************************
   734
   735 E2B1 85 F3		WRITEDATE	STA	ACC
   736 E2B3 86 F5				STX	XREG
   737 E2B5 84 F4				STY	YREG
   738 E2B7 A9 04		WRITEDATE2	LDA	#$04		; start at register 4
   739 E2B9 20 C9 E2				JSR	WRITECLOCK	; write date bytes to clock register
   740 E2BC A9 09				LDA	#$09		; set address pointer to ram
   741 E2BE 20 13 E3				JSR	SETRTCADR
   742 E2C1 A9 02				LDA	#$02		; date set mark
   743 E2C3 20 67 E3				JSR	I2C_SEND
   744 E2C6 4C 35 E3				JMP	I2C_STOP
   745
   746 				; **** Write Data To Clock *****************************************************
   747
   748 				; ******************************************************************************
   749
   750 E2C9 20 13 E3		WRITECLOCK	JSR	SETRTCADR
   751 E2CC A5 F4				LDA	YREG
   752 E2CE 20 67 E3				JSR	I2C_SEND	; set second or day
   753 E2D1 A5 F5				LDA	XREG
   754 E2D3 20 67 E3				JSR	I2C_SEND	; set minute or month
   755 E2D6 A5 F3				LDA	ACC
   756 E2D8 20 67 E3				JSR	I2C_SEND	; set hour or year
   757 E2DB 4C 35 E3				JMP	I2C_STOP
   758
   759 				; **** Read Time ***************************************************************
   760
   761 				; Output: A - HOUR 	in BCD ($00-$23)
   762 				;	  X - MINUTE 	in BCD ($00-$59)
   763 				;	  Y - SECOND	in BCD ($00-$59)
   764
   765 				; ******************************************************************************
   766
   767 E2DE A9 00		READTIME	LDA	#$00
   768 E2E0 F0 04				BEQ	READCLOCK
   769
   770 				; **** Read Date ***************************************************************
   771
   772 				; Output: A - YEAR 	in BCD ($00-$99)
   773 				; 	  X - MONTH 	in BCD ($01-$12)
   774 				; 	  Y - DAY	in BCD ($01-$31)
   775
   776
   777 				; ******************************************************************************
   778
   779 E2E2 A9 04		READDATE	LDA	#$04
   780 E2E4 D0 00				BNE	READCLOCK
   781
   782 				; **** Read Data From Clock ****************************************************
   783
   784 				; ******************************************************************************
   785
   786 E2E6 20 13 E3		READCLOCK	JSR	SETRTCADR	; set read pointer
   787 E2E9 20 26 E3				JSR	I2C_START	; send start condition
   788 E2EC A9 68				LDA	#I2C_RTC_ADR	; the I2C address
   789 E2EE 20 62 E3				JSR	I2C_READ_DEV	; send device id and set read mode
   790 E2F1 20 9F E3				JSR	I2C_RCV		; receive first data byte
   791 E2F4 85 F4				STA	YREG		; and store it
   792 E2F6 20 44 E3				JSR	I2C_ACK		; send acknowlege
   793 E2F9 20 9F E3				JSR	I2C_RCV		; receive second data byte
   794 E2FC 85 F5				STA	XREG		; and store it
   795 E2FE 20 44 E3				JSR	I2C_ACK		; send acknowlege
   796 E301 20 9F E3				JSR	I2C_RCV		; receive third data byte
   797 E304 85 F3				STA	ACC		; and store it
   798 E306 20 53 E3				JSR	I2C_NACK	; no more data
   799 E309 20 35 E3				JSR	I2C_STOP	; stop communication
   800 E30C A5 F3				LDA	ACC		; load third data byte into A
   801 E30E A6 F5				LDX	XREG		; load second data byte into X
   802 E310 A4 F4				LDY	YREG		; load first data byte into Y
   803 E312 60					RTS
   804
   805 				; **** Set RTC Address Read/Write Pointer **************************************
   806
   807 				; Input: A - Register Address
   808
   809 				; ******************************************************************************
   810
   811 E313 48			SETRTCADR	PHA			; save register address onto stack
   812 E314 20 26 E3				JSR	I2C_START	; send start condition
   813 E317 A9 68				LDA	#I2C_RTC_ADR	; the I2C device address
   814 E319 20 66 E3				JSR	I2C_WRITE_DEV	; send device address and write bit
   815 E31C 68					PLA			; restore register address
   816 E31D 4C 67 E3				JMP	I2C_SEND	; send register address
   817
   818 				; ******************************************************************************
   819 				; START OF DATA INPUT/OUTPUT CODE
   820 				; ******************************************************************************
   821
   822 				; ******************************************************************************
   823 				; START OF VIA1 INPUT/OUTPUT CODE
   824 				; ******************************************************************************
   825
   826 				; **** Write To VIA1 Register **************************************************
   827
   828 				; Input:  Y - Destination Register index (VIA_PORTA,VIA_DDRA...)
   829 				;	  A - Data to be written into the Register
   830
   831 				; ******************************************************************************
   832
   833 E320 91 14		WRITE_VIA	STA	(IOBASE),Y
   834 E322 60					RTS
   835
   836 				; **** Read From VIA1 Register *************************************************
   837
   838 				; Input:  Y - Source Register index (VIA_PORTA,VIA_DDRA...)
   839 				; Output: A - Read Data from the Register
   840
   841 				; ******************************************************************************
   842
   843 E323 B1 14		READ_VIA	LDA	(IOBASE),Y
   844 E325 60					RTS
   845
   846
   847 				; ******************************************************************************
   848 				; START OF I2C CODE
   849 				; ******************************************************************************
   850
   851 				; **** Send I2C Start Condition ************************************************
   852
   853 				; ******************************************************************************
   854
   855 E326 A0 12		I2C_START	LDY	#DDRB
   856 E328 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   857 E32A 91 14				STA	(IOBASE),Y
   858 E32C A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   859 E32E 91 14				STA	(IOBASE),Y
   860 E330 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   861 E332 91 14				STA	(IOBASE),Y
   862 E334 60					RTS
   863
   864 				; **** Send I2C Stop Condition *************************************************
   865
   866 				; ******************************************************************************
   867
   868 E335 A0 12		I2C_STOP	LDY	#DDRB
   869 E337 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   870 E339 91 14				STA	(IOBASE),Y
   871 E33B A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   872 E33D 91 14				STA	(IOBASE),Y
   873 E33F A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   874 E341 91 14				STA	(IOBASE),Y
   875 E343 60					RTS
   876
   877 				; **** Send I2C Acknowledged ***************************************************
   878
   879 				; ******************************************************************************
   880
   881 E344 A0 12		I2C_ACK		LDY	#DDRB
   882 E346 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   883 E348 91 14				STA	(IOBASE),Y
   884 E34A A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   885 E34C 91 14				STA	(IOBASE),Y
   886 E34E A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   887 E350 91 14				STA	(IOBASE),Y
   888 E352 60					RTS
   889
   890 				; **** Send I2C Not Acknowledged ***********************************************
   891
   892 				; ******************************************************************************
   893
   894 E353 A0 12		I2C_NACK	LDY	#DDRB
   895 E355 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   896 E357 91 14				STA	(IOBASE),Y
   897 E359 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   898 E35B 91 14				STA	(IOBASE),Y
   899 E35D A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   900 E35F 91 14				STA	(IOBASE),Y
   901 E361 60					RTS
   902
   903 				; **** Read I2C Device *********************************************************
   904
   905 				; Input:  A - Device Address
   906 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   907
   908 				; ******************************************************************************
   909
   910 E362 38			I2C_READ_DEV	SEC			; set carry flag
   911 E363 2A					ROL			; shift device address one bit left and rotate C in LSB. LSB = 1 = read
   912 E364 D0 01				BNE	I2C_SEND	; and send it
   913
   914 				; **** Write I2C Device ********************************************************
   915
   916 				; Input:  A - Device Address
   917 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   918
   919 				; ******************************************************************************
   920
   921 E366 0A			I2C_WRITE_DEV	ASL			; shift device address one bit left. LSB is now 0 = write
   922 									; directly fallthrough to I2C_SEND
   923
   924 				; **** Send a Byte to I2C Device ***********************************************
   925
   926 				; Input:  A - Data Byte
   927 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   928
   929 				; ******************************************************************************
   930
   931 E367 85 E0		I2C_SEND	STA	I2C_DATA
   932 E369 A2 08				LDX	#$08		; send 8 bits
   933 E36B A0 12				LDY	#DDRB
   934 E36D 06 E0		SENDLOOP	ASL	I2C_DATA	; get next bit into C flag
   935 E36F B0 04				BCS	MSENDH		; is it a 1 bit?
   936 E371 A9 DF				LDA	#%11011111	; no, SDA = 0; SCL = 0
   937 E373 D0 02				BNE	SETBIT		; branch always
   938 E375 A9 5F		MSENDH		LDA	#%01011111	; yes, SDA = 1; SCL = 0
   939 E377 91 14		SETBIT		STA	(IOBASE),Y
   940 E379 29 FE				AND	#%11111110	; SDA = X; SCL = 1
   941 E37B 91 14				STA	(IOBASE),Y
   942 E37D 09 01				ORA	#%00000001	; SDA = X, SCL = 0
   943 E37F 91 14				STA	(IOBASE),Y
   944 E381 CA					DEX
   945 E382 D0 E9				BNE	SENDLOOP
   946
   947 E384 A0 12		I2C_ACK?	LDY	#DDRB
   948
   949 E386 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   950 E388 91 14				STA	(IOBASE),Y
   951
   952 E38A A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   953 E38C 91 14				STA	(IOBASE),Y
   954 E38E A0 10				LDY	#PORTB
   955 E390 B1 14				LDA	(IOBASE),Y	; get SDA
   956 E392 10 03				BPL	ISACK		; SDA = 1 ?
   957 E394 18					CLC			; no, not acknowledeged
   958 E395 90 01				BCC	CLKDOWN
   959 E397 38			ISACK		SEC			; yes, acknowledeged
   960 E398 A0 12		CLKDOWN		LDY	#DDRB
   961 E39A A9 5F				LDA	#%01011111	; SCL = 0
   962 E39C 91 14				STA	(IOBASE),Y
   963 E39E 60					RTS
   964
   965 				; **** Receive a Byte from I2C Device ******************************************
   966
   967 				; Output: A - Data Byte
   968
   969 				; ******************************************************************************
   970
   971 E39F A2 09		I2C_RCV		LDX	#$09
   972 E3A1 A0 12		RCVLOOP		LDY	#DDRB
   973 E3A3 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   974 E3A5 91 14				STA	(IOBASE),Y
   975 E3A7 CA					DEX
   976 E3A8 F0 0E				BEQ	RCVEND		; all eight bits received?
   977 E3AA A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   978 E3AC 91 14				STA	(IOBASE),Y
   979 E3AE A0 10				LDY	#PORTB
   980 E3B0 B1 14				LDA	(IOBASE),Y	; get SDA
   981 E3B2 0A					ASL			; and shift it into C
   982 E3B3 26 E0				ROL	I2C_DATA	; shift byte buffer one bit left. C goes into LSB
   983 E3B5 4C A1 E3				JMP	RCVLOOP
   984 E3B8 A5 E0		RCVEND		LDA	I2C_DATA	; load data into A
   985 E3BA 60					RTS
   986
   987 				; ******************************************************************************
   988 				; START OF SOUND GENERATOR CODE
   989 				; ******************************************************************************
   990
   991 				; **** Send A Command Byte To The Sound Chip ***********************************
   992
   993 				; Input: A - Data Byte
   994
   995 				; ******************************************************************************
   996
   997 E3BB 84 FD		SOUND_SENDBYTE	STY	YSAV		; save current Y register
   998 E3BD A0 11				LDY	#PORTA
   999 E3BF 91 14				STA	(IOBASE),Y	; set data
  1000 E3C1 A0 10				LDY	#PORTB
  1001 E3C3 A9 FD				LDA	#%11111101	; Set sound WE low
  1002 E3C5 25 E4				AND	VIA_STATUS
  1003 E3C7 91 14				STA	(IOBASE),Y	; enable sound data write
  1004 E3C9 A5 E4				LDA	VIA_STATUS	; set sound WE high
  1005 E3CB 91 14				STA	(IOBASE),Y	; disable sound data write
  1006 E3CD A4 FD				LDY	YSAV		; restore Y register
  1007 E3CF 60					RTS
  1008
  1009 				; **** Mute All Sound Chip Channels ********************************************
  1010
  1011 				; ******************************************************************************
  1012
  1013 E3D0 A0 03		SOUND_MUTEALL	LDY	#$03		; channels 0..3 to mute
  1014 E3D2 98			NEXTCHANNEL	TYA
  1015 E3D3 20 DA E3				JSR	SOUND_MUTE	; mute current channel
  1016 E3D6 88					DEY			; next channel
  1017 E3D7 10 F9				BPL	NEXTCHANNEL	; loop if not all four channels done
  1018 E3D9 60					RTS
  1019
  1020 				; **** Mute A Sound Chip Channel ***********************************************
  1021
  1022 				; Input: A - Channel # (0..3)
  1023
  1024 				; ******************************************************************************
  1025
  1026 E3DA A2 0F		SOUND_MUTE	LDX	#$0F		; set attenuation level to maximum
  1027 									; fall through to set attenuation level
  1028
  1029 				; **** Set Attenuation For A Sound Chip Channel ********************************
  1030
  1031 				; Input: A - Channel # (0..3)
  1032 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
  1033
  1034 				; ******************************************************************************
  1035
  1036 E3DC 86 FC		SOUND_SETATN	STX	TEMP		; store attenuation level in TEMP variable
  1037 E3DE 18					CLC			; clear carry flag
  1038 E3DF 6A					ROR			; and rotate channel number to bit 5 and 6
  1039 E3E0 6A					ROR	
  1040 E3E1 6A					ROR	
  1041 E3E2 6A					ROR	
  1042 E3E3 05 FC				ORA	TEMP		; combine channel number with attenuation value
  1043 E3E5 09 90				ORA	#$90		; and also set bit 7 and 4
  1044 E3E7 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1045
  1046 				; **** Set Periodic Noise ******************************************************
  1047
  1048 				; Input: X - Noise Shift Rate
  1049
  1050 				; ******************************************************************************
  1051
  1052 E3EA A9 00		SOUND_PNOISE	LDA	#$00
  1053 E3EC F0 04				BEQ	SET_NOISE
  1054
  1055 				; **** Set White Noise *********************************************************
  1056
  1057 				; Input: X - Noise Shift Rate
  1058
  1059 				; ******************************************************************************
  1060
  1061 E3EE A9 01		SOUND_WNOISE	LDA	#$01
  1062
  1063 				; **** Set Noise ***************************************************************
  1064
  1065 				; Input: A - 0 = Periodic Noise  1 = White Noise
  1066 				;	 X - Noise Shift Rate
  1067
  1068 				; ******************************************************************************
  1069
  1070 E3F0 0A			SOUND_SETNOISE	ASL	
  1071 E3F1 0A					ASL	
  1072 E3F2 86 FC		SET_NOISE	STX	TEMP
  1073 E3F4 05 FC				ORA	TEMP
  1074 E3F6 09 F0				ORA	#$F0
  1075 E3F8 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1076
  1077 				; **** Set Sound Frequency in HZ ***********************************************
  1078
  1079 				; Input: A - Channel (0..2)
  1080 				;	 X - Frequency Low Bits 7..0
  1081 				;	 Y - Frequency High Bits 9..8
  1082
  1083 				; *****************************************************************************
  1084
  1085 E3FB 18			SOUND_SETFREQ	CLC			; clear carry flag
  1086 E3FC 6A					ROR			; and rotate channel number to bit 5 and 6
  1087 E3FD 6A					ROR	
  1088 E3FE 6A					ROR	
  1089 E3FF 6A					ROR	
  1090 E400 09 80				ORA	#$80		; set high bit
  1091 E402 85 FC				STA	TEMP		; and store it in TEMP variable
  1092 E404 8A					TXA			; load frequency low bits into A
  1093 E405 29 0F				AND	#$0F		; we first want to send the lower 4 bits
  1094 E407 05 FC				ORA	TEMP		; combined it with the channel number
  1095 E409 20 BB E3				JSR	SOUND_SENDBYTE	; send complete first command byte to the sound chip
  1096 E40C 98					TYA			; load frequency high bits into A
  1097 E40D 86 FC				STX	TEMP		; store frequency low bits to TEMP variable
  1098 E40F A2 04				LDX	#$04		; we need four bits shifted
  1099 E411 06 FC		LOOP_NXT	ASL	TEMP		; shift highest bit of low frequency to Carry flag
  1100 E413 2A					ROL			; and shift it into the high frequency bits
  1101 E414 CA					DEX			; decrement counter
  1102 E415 D0 FA				BNE	LOOP_NXT	; do we need more shifts?
  1103 E417 4C BB E3				JMP	SOUND_SENDBYTE	; send complete second command byte to the sound chip
  1104
  1105 				; ******************************************************************************
  1106 				; ***************************** MAIN MONITOR ***********************************
  1107 				; ******************************************************************************
  1108
  1109 				; **** Auto Terminal And Baud Rate Detection Routine ***************************
  1110
  1111 				; ******************************************************************************
  1112
  1113 E41A A2 2D		INITVECT        LDX	#< NMI		; set NMI service routine
  1114 E41C A0 F3		                LDY	#> NMI
  1115 E41E 8E 7A 1A				STX	NMIVECT
  1116 E421 8C 7B 1A				STY	NMIVECT+1
  1117 E424 20 49 ED				JSR     SETIRQVECT      ; set IRQ service routine
  1118 E427 A2 18				LDX	#<  IRQ
  1119 E429 A0 F3				LDY	#> IRQ
  1120 E42B 20 49 ED				JSR	SETIRQVECT
  1121 E42E 8E 7C 1A				STX	IRQUSR
  1122 E431 8C 7D 1A				STY	IRQUSR+1
  1123 E434 A2 2F				LDX	#<  BREAK	; set BRK service routine
  1124 E436 A0 F3				LDY	#> BREAK
  1125 E438 8E 78 1A				STX	BRKUSR
  1126 E43B 8C 79 1A		                STY	BRKUSR+1
  1127 E43E 60			                RTS
  1128
  1129 E43F 78			MAINSTART       SEI			; disable Interrupts
  1130 E440 A2 FF		                LDX     #$FF
  1131 E442 9A					TXS			; initialize stack pointer
  1132 E443 D8					CLD			; set binary mode
  1133
  1134 E444 A9 4F		                LDA     #< _HANDLER_  ; low address to empty event handler (RTS)
  1135 E446 8D 24 1A		                STA     KEY_HANDLER     ; init character input handler low address
  1136 E449 8D 26 1A		                STA     NKEY_HANDLER    ; init no character input handler low address
  1137 E44C A9 F8		                LDA     #> _HANDLER_ ; high address to empty event handler (RTS)
  1138 E44E 8D 25 1A		                STA     KEY_HANDLER+1   ; init character input handler high address
  1139 E451 8D 27 1A		                STA     NKEY_HANDLER+1  ; init no character input handler high address
  1140
  1141 E454 20 1A E4		                JSR     INITVECT
  1142
  1143 E457 A2 03		INITRESET       LDX     #< MON_WARM_START
  1144 E459 A0 E0				LDY     #> MON_WARM_START
  1145 E45B 20 F1 EC				JSR	SET_RETURN_VECT		; set entry point for monitor warm start
  1146 E45E EA					NOP				; maintain compatibility with v1.1.4
  1147
  1148 E45F A9 80				LDA     #$80
  1149 E461 20 4D E1				JSR  	DELAY		; wait for ~128ms after reset
  1150 E464 20 6A EC				JSR	INITIO		; find and initialize IO cards
  1151 E467 20 4D E1		VTDETECT	JSR  	DELAY		; wait for ~128ms after reset
  1152 E46A 8D 01 16				STA  	STAT_REG   	; reset ACIA
  1153
  1154 				; ******************************************************************************
  1155 				; Set Fixed Baud Rate Patch
  1156 				; ******************************************************************************
  1157
  1158 E46D A9 3E				LDA	#$3E
  1159 E46F 8D 83 1A				STA	PBDD
  1160 E472 A9 06				LDA	#$06		; set keyboard decoder Q4 to low
  1161 E474 8D 82 1A				STA	PBD		; write value to RIOT port B
  1162 E477 AD F9 FF				LDA	$FFF9		; load standard baud rate value
  1163 E47A 85 E0				STA	BAUDRATE	; and store it in detected baud rate variable
  1164 E47C A9 0B				LDA  	#$0B       	; set ACIA to
  1165 E47E 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
  1166 E481 AD 82 1A				LDA	PBD		; read RIOT port B
  1167 E484 A2 0F				LDX	#$0F		; set all keyboard decoder outputs to high
  1168 E486 8E 82 1A				STX	PBD		; write value to RIOT port B
  1169 E489 6A					ROR			; rotate bit 0 into Carry
  1170 E48A 90 05				BCC	INIT		; if Carry = 0 then skip autodetection
  1171
  1172 				; ******************************************************************************
  1173
  1174 E48C A9 00				LDA	#CMD_INIT
  1175 E48E 20 B7 E0				JSR	CMDPRINT	; try to detect connected terminal
  1176
  1177 				; **** Main Initialization Routine *********************************************
  1178
  1179 				; ******************************************************************************
  1180
  1181 E491 20 67 E1		INIT            JSR     BEEP		; give some feedback
  1182 E494 A5 E0				LDA  	BAUDRATE   	; load selected baud rate
  1183 E496 D0 1A				BNE     SETBAUDRATE	; terminal detected or fixed baud rate?
  1184 E498 AD F9 FF				LDA	$FFF9		; no, load standard baud rate value
  1185 E49B 8D 03 16				STA  	CTRL_REG	; set baud rate
  1186 E49E A5 C9				LDA     DEVID
  1187 E4A0 C9 10				CMP     #TTY1_ID        ; is TTY still the standard output device?
  1188 E4A2 D0 03				BNE     SET_CRTDEV      ; no, CRT controller is installed. Continue initialization
  1189 E4A4 4C 55 E7				JMP  	JCRESET		; TTY ist still sdtoutdev, but not connected. Jump to junior monitor
  1190
  1191 E4A7 8D 75 1A		SET_CRTDEV      STA     STDOUTDEV       ; make CRT controller the standard output device
  1192 E4AA 20 18 E0		                JSR     SET_STDOUTID
  1193 E4AD A9 00		                LDA	#CMD_INIT
  1194 E4AF 20 B7 E0				JSR	CMDPRINT	; initialize standard output device
  1195
  1196 E4B2 8D 03 16		SETBAUDRATE     STA  	CTRL_REG	; set detected baud rate
  1197
  1198 E4B5 58					CLI			; enable interrupts
  1199
  1200 				; **** Main Program Loop *******************************************************
  1201
  1202 				; ******************************************************************************
  1203
  1204 E4B6 20 4D E0		MAIN		JSR	CGET		; clear input buffer
  1205 E4B9 20 40 E5				JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1206 E4BC A9 1F				LDA  	#$1F
  1207 E4BE 20 DE E0				JSR  	TAB		; send some space chars to center title
  1208 E4C1 A0 14		        	LDY  	#TITLE-STRINGP 	; load title string
  1209 E4C3 20 85 E0				JSR  	WRSTR		; and write it
  1210 E4C6 20 16 F9				JSR     INIT_CFC	; init. CFC-driver
  1211
  1212 E4C9 A5 15		CHK_IO_CARD     LDA	IOBASEH		; language card available?
  1213 E4CB F0 21				BEQ	TRY_BOOT	; no, try to boot from CF-device
  1214 						
  1215 E4CD A0 57				LDY	#IOCARD-STRINGP ; load detect message
  1216 E4CF 20 85 E0				JSR	WRSTR		; and write it
  1217 E4D2 A5 15				LDA	IOBASEH
  1218 E4D4 20 91 E0				JSR	HEXOUT
  1219 E4D7 A9 00				LDA	#$00
  1220 E4D9 20 91 E0				JSR	HEXOUT
  1221 E4DC AD 74 1A				LDA	STDINDEV
  1222 E4DF C9 13				CMP	#KEYBD1_ID	; is ASCII keyboard the standard input device?
  1223 E4E1 D0 08				BNE	SHOW_CLOCK 	; no, show clock
  1224 						
  1225 E4E3 A0 6E				LDY	#KBDSTR-STRINGP	; yes, load detect message
  1226 E4E5 20 85 E0				JSR	WRSTR		; and write it
  1227 E4E8 20 10 F4				JSR	SETPPORTIN
  1228 E4EB 20 34 EB		SHOW_CLOCK	JSR	CLOCKSTART	; call clock
  1229
  1230 E4EE 20 B8 F6		TRY_BOOT        JSR     SYS_BOOT        ; try to boot from CF or SD device
  1231 E4F1 90 03		                BCC     NO_BOOT_DEV     ; no boot device found, show menu
  1232 						
  1233 E4F3 4C 00 06		                JMP     BLOCK_BUF       ; jump to boot code in Volume-ID with C=1
  1234
  1235 E4F6 A5 15		NO_BOOT_DEV     LDA	IOBASEH		; language card available?
  1236 E4F8 F0 43				BEQ	SHOWMON		; no, just start monitor
  1237
  1238 E4FA A9 00				LDA	#$00
  1239 E4FC A0 1B		                LDY	#ACR		; select auxilary control register
  1240 E4FE 91 14				STA	(IOBASE),Y	; disable shift operation
  1241 E500 20 43 E5		                JSR     LOADSTRING
  1242 E503 A0 89				LDY	#SPACE-STRINGP
  1243 E505 20 85 E0				JSR	WRSTR		; write spacer lines
  1244 E508 A9 1E				LDA	#$1E		; send some space chars to center menu
  1245 E50A 20 DE E0				JSR  	TAB
  1246 E50D A0 8E				LDY	#MENU-STRINGP   ; load menu string
  1247 E50F 20 85 E0				JSR	WRSTR		; and write it
  1248 E512 A2 F1				LDX	#< LANGNAME	; load language name
  1249 E514 A0 DF				LDY	#> LANGNAME
  1250 E516 20 82 F6				JSR	SPRINT		; and write it
  1251 E519 A9 20				LDA	#SPC
  1252 E51B 20 52 E0				JSR	COUT
  1253 E51E A9 3F				LDA	#'?'
  1254 E520 20 52 E0				JSR	COUT
  1255 E523 20 47 E0		MLOOP		JSR  	CIN		; main menu loop
  1256 E526 29 DF		        	AND  	#$DF		; convert the input to uppercase char
  1257 E528 C9 4D		        	CMP  	#'M'		; (M)onitor choosen?
  1258 E52A D0 03				BNE	MNEXT1
  1259
  1260 E52C 4C 33 E6		STARTMON	JMP  	MONITOR		; yes, start monitor
  1261 E52F CD F0 DF		MNEXT1		CMP	LANGKEY		; compare with language key char
  1262 E532 D0 06				BNE	MNEXT
  1263
  1264 E534 20 B5 E0				JSR  	CLRSCRN    	; clear screen
  1265 E537 4C 00 B0				JMP	$B000		; jump to language start
  1266 E53A 4C 23 E5		MNEXT		JMP  	MLOOP		; no valid input choosen, try again
  1267 E53D 4C 3B E6		SHOWMON		JMP	MONRESET
  1268
  1269 				; Load String Pointer **********************************************************
  1270
  1271 E540 20 B5 E0		CLRLOADSTR      JSR     CLRSCRN
  1272 E543 A9 72		LOADSTRING	LDA  	#< STRINGP 	; load string pointer 1
  1273 E545 85 EA				STA  	PSTRL
  1274 E547 A9 E7				LDA  	#> STRINGP
  1275 E549 85 EB				STA  	PSTRH
  1276 E54B 60					RTS
  1277 						
  1278 E54C A9 62		LOADSTRING2	LDA  	#< STRINGP2 	; load string pointer 2
  1279 E54E 85 EA				STA  	PSTRL
  1280 E550 A9 E8				LDA  	#> STRINGP2
  1281 E552 85 EB				STA  	PSTRH
  1282 E554 60					RTS
  1283
  1284 E555 A9 10		WRITE_IO_INFO   LDA     #$10
  1285 E557 8D 00 1A				STA     IO_INFO
  1286 E55A A5 17		CHK_IO_0	LDA     FGCBASEH        ; controller card 0 available?
  1287 E55C F0 06				BEQ     CHK_IO_1        ; no, check next card
  1288 E55E 8D 01 1A				STA     IO_INFO+1
  1289 E561 20 6F E5				JSR     CALL_INFO
  1290 E564 A5 19		CHK_IO_1        LDA     CARD3BASEH      ; controller card 1 available?
  1291 E566 F0 06		                BEQ     IO_INFO_END     ; no, exit
  1292 						
  1293 E568 8D 01 1A		                STA     IO_INFO+1
  1294 E56B 20 6F E5				JSR     CALL_INFO
  1295 E56E 60			IO_INFO_END	RTS
  1296
  1297 E56F 6C 00 1A		CALL_INFO       JMP     (IO_INFO)
  1298
  1299 				; ******************************************************************************
  1300 				; MONITOR COMMAND EXECUTOR ROUTINES
  1301 				; ******************************************************************************
  1302
  1303 				; print command ****************************************************************
  1304
  1305 E572 84 FD		PRINTOUT	STY	YSAV		; save y register
  1306 E574 AD 76 1A				LDA	STDPRINTDEV	; get standard printer
  1307 E577 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1308 E57A A4 FD				LDY	YSAV		; restore y register
  1309 E57C C8					INY
  1310 E57D B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1311 E580 29 DF				AND  	#$DF		; uppercase chars only
  1312 E582 C9 44				CMP  	#'D'		; print mem dump?
  1313 E584 F0 06				BEQ	PRINTDUMP
  1314 E586 20 AC E8				JSR	DISASSEM
  1315 E589 4C 94 E5				JMP	ENDINP
  1316 E58C 20 C7 E6		PRINTDUMP	JSR	MEMDUMP		; print memory dump
  1317 E58F 90 03				BCC	ENDINP 		; normal termination?
  1318 E591 20 67 E1				JSR	BEEP		; no, ESC pressed. Beep
  1319 E594 20 5A E0		ENDINP		JSR	CROUT		; send CR/LF to print last line
  1320 E597 AD 75 1A				LDA	STDOUTDEV	; get standard output device
  1321 E59A 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1322 E59D 4C 3E E6				JMP	MONINP		; get next command line
  1323
  1324 				; XMODEM load/save command *****************************************************
  1325
  1326 E5A0 CA			XMODEM		DEX			; check read/write mode
  1327 E5A1 F0 09				BEQ	XMODEML		; read mode?
  1328 E5A3 A5 FF				LDA	MODE		; no, test if valid address mode
  1329 E5A5 F0 6A				BEQ	NOTVALID	; not valid, get next input
  1330 E5A7 20 06 F1				JSR	XModemSnd	; call xmodem send
  1331 E5AA F0 03				BEQ	XMODEME
  1332 E5AC 20 15 F0		XMODEML		JSR	XModemRcv	; yes, call xmodem receive
  1333 E5AF 4C 3E E6		XMODEME		JMP	MONINP		; get next command line
  1334
  1335 				; parallel load/save command ***************************************************
  1336
  1337 E5B2 CA			PARALLEL	DEX			; check read/write mode
  1338 E5B3 F0 0A				BEQ	PARALLELL	; read mode?
  1339 E5B5 A5 FF				LDA	MODE		; no, test if valid address mode
  1340 E5B7 F0 58				BEQ	NOTVALID	; not valid, get next input
  1341 E5B9 20 03 18				JSR	PPORTSAVE	; call save pport ### not implemented yet
  1342 E5BC 4C 3E E6				JMP	MONINP
  1343 E5BF 20 00 18		PARALLELL	JSR	PPORTLOAD	; call load pport ### not implemented yet
  1344 E5C2 4C 3E E6				JMP	MONINP		; get next command line
  1345
  1346 				; tape load/save command *******************************************************
  1347
  1348 E5C5 C8			TAPE		INY
  1349 E5C6 CA					DEX			; check read/write mode
  1350 E5C7 F0 08				BEQ	TAPEL		; read mode?
  1351 E5C9 A5 FF				LDA	MODE		; no, test if valid address mode
  1352 E5CB F0 44				BEQ	NOTVALID	; not valid, get next input
  1353 E5CD A9 21				LDA	#CMD_SAVE	; set save to tape command
  1354 E5CF D0 02				BNE	OPENTAPE
  1355 E5D1 A9 20		TAPEL		LDA	#CMD_LOAD	; set load from tape command
  1356 E5D3 48			OPENTAPE	PHA			; save command to stack
  1357 E5D4 A9 21				LDA	#TAPE1_ID	; open tape1 device
  1358 E5D6 84 FD				STY	YSAV		; save y register
  1359 E5D8 20 BE F7				JSR	DEV_OPEN	; open tape device
  1360 E5DB A4 FD				LDY	YSAV		; restore y register
  1361 E5DD 20 19 E1				JSR	STRINPUT	; check for filename
  1362 E5E0 68					PLA			; restore command
  1363 E5E1 20 BA E0				JSR	CMDDEV		; and send it to opened device
  1364 E5E4 4C 3E E6				JMP	MONINP		; get next command line
  1365
  1366 				; load/save command ************************************************************
  1367
  1368 E5E7 A5 FF		LOADSAVE	LDA	MODE		; check address mode
  1369 E5E9 0A					ASL	
  1370 E5EA 30 06				BMI	CHKNEXTCMD	; mode = $C0 (block mode)?
  1371 E5EC A9 FF				LDA	#$FF		; no, set end address to $ffff
  1372 E5EE 85 F8				STA	NUML
  1373 E5F0 85 F9				STA	NUMH
  1374 E5F2 C8			CHKNEXTCMD	INY
  1375 E5F3 B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1376 E5F6 29 DF				AND  	#$DF		; uppercase chars only
  1377 E5F8 C9 4D				CMP  	#'M'		; load/save via xmodem
  1378 E5FA F0 A4				BEQ  	XMODEM
  1379 E5FC C9 50				CMP  	#'P'		; load/save via parallel port
  1380 E5FE F0 B2				BEQ  	PARALLEL
  1381 E600 C9 54				CMP  	#'T'		; load/save via tape
  1382 E602 F0 C1				BEQ  	TAPE
  1383 E604 C9 30				CMP	#'0'
  1384 E606 B0 09				BCS	NOTVALID
  1385 E608 CA					DEX			; check load/save mode
  1386 E609 D0 06				BNE	NOTVALID	; if save mode, just get next input char
  1387 E60B 20 AC E8				JSR	DISASSEM	; last command was L, so call disassembler
  1388 E60E 4C 3E E6				JMP	MONINP		; we are finnished, get next input line
  1389 E611 A9 00		NOTVALID	LDA	#$00		; no valid command, so restore registers
  1390 E613 AA					TAX
  1391 E614 4C A1 E6				JMP  	SETMODE2   	; and get next input char
  1392
  1393 				; save command *****************************************************************
  1394
  1395 E617 E8			SAVE		INX
  1396
  1397 				; load command *****************************************************************
  1398
  1399 E618 E8			LOAD		INX
  1400 E619 4C E7 E5				JMP	LOADSAVE
  1401
  1402 				; print command ****************************************************************
  1403
  1404 E61C 4C 72 E5		PRINT		JMP	PRINTOUT
  1405
  1406 				; call a program ***************************************************************
  1407
  1408 E61F 20 36 E7		RUN		JSR	PRADDRESS
  1409 E622 A9 52				LDA	#'R'		; print R to signal run mode
  1410 E624 20 52 E0				JSR	COUT
  1411 E627 20 5A E0				JSR	CROUT
  1412 E62A 20 30 E6				JSR     EXECPROG
  1413 E62D 4C 3E E6				JMP  	MONINP		; jump back from program call
  1414 E630 6C FA 00		EXECPROG	JMP  	(ADRL)     	; jump to program address; execute program
  1415
  1416 				; **** Start Of Hex Monitor ****************************************************
  1417
  1418 				; ******************************************************************************
  1419 E633 20 40 E5		MONITOR 	JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1420 E636 A0 9A				LDY  	#MONSTR-STRINGP
  1421 E638 20 85 E0		        	JSR  	WRSTR		; show monitor title
  1422 E63B 20 10 F4		MONRESET	JSR	SETPPORTIN	; initialize RIOT
  1423 E63E 20 5A E0		MONINP		JSR  	CROUT
  1424 E641 A9 2A				LDA  	#PROMPT
  1425 E643 20 52 E0				JSR  	COUT		; show monitor prompt
  1426 E646 20 62 E0				JSR  	STRIN      	; read input string
  1427 E649 A0 00				LDY  	#$00       	; reset string index
  1428 E64B 98					TYA			; mode = 0 (none)
  1429
  1430 E64C AA			MONINIT		TAX
  1431 E64D 85 FF		SETADRMODE	STA  	MODE
  1432 E64F C8			SKIPCMDCHR      INY			; increment string index
  1433 E650 B9 00 14		NEXTCMDCHR	LDA  	STRBUF,Y   	; get next input char
  1434 E653 C9 0D				CMP  	#CR
  1435 E655 F0 52				BEQ  	ENDCMD 		; end of input line, return to reader routine
  1436 E657 C9 20				CMP  	#' '
  1437 E659 F0 F4				BEQ  	SKIPCMDCHR 	; ignore spaces
  1438 E65B C9 2E				CMP  	#'.'
  1439 E65D F0 46				BEQ  	SETBLKMODE 	; block mode
  1440 E65F C9 3A				CMP	#':'
  1441 E661 F0 EA				BEQ	SETADRMODE
  1442 E663 29 DF				AND  	#$DF		; uppercase chars only
  1443 E665 C9 4C				CMP  	#'L'		; LOAD/LIST command
  1444 E667 F0 AF				BEQ	LOAD 		; load or list data
  1445 E669 C9 53				CMP  	#'S'		; SAVE command
  1446 E66B F0 AA				BEQ	SAVE		; save data
  1447 E66D C9 50				CMP	#'P'		; PRINT command
  1448 E66F F0 AB				BEQ	PRINT		; print data
  1449 E671 C9 47				CMP  	#'G'		; GO command
  1450 E673 F0 AA				BEQ  	RUN		; call program
  1451 E675 C9 4D				CMP  	#'M'		; JUNIOR MONITOR command
  1452 E677 D0 03				BNE  	NEXTCMD
  1453 E679 4C 55 E7				JMP	JCRESET		; execute original junior computer monitor
  1454 E67C C9 51		NEXTCMD		CMP  	#'Q'		; QUIT command
  1455 E67E F0 30				BEQ  	MONEND		; exit monitor program
  1456 E680 A5 FF				LDA	MODE		; test if list command pending
  1457 E682 30 3C				BMI	DUMP		; if mode = $80, dump last line
  1458 E684 84 FD				STY  	YSAV		; save Y
  1459 E686 20 EA E0				JSR  	HEXINPUT   	; read hex number
  1460 E689 C4 FD			 	CPY  	YSAV		; min 1 hex digit entered?
  1461 E68B F0 C2				BEQ  	SKIPCMDCHR     	; no, read next command
  1462 E68D A5 FF				LDA  	MODE
  1463 E68F D0 0A				BNE	SETMODE
  1464 E691 A5 F8		STOREADR	LDA  	NUML       	; yes, copy input value to last address
  1465 E693 85 FA		                STA  	ADRL
  1466 E695 A5 F9		                LDA  	NUMH
  1467 E697 85 FB		                STA  	ADRH
  1468 E699 A9 00				LDA	#$00		; line list mode
  1469 E69B C9 3A		SETMODE		CMP	#':'		; is it store mode?
  1470 E69D F0 14				BEQ	STOREDATA	; yes, store data
  1471 E69F 09 80				ORA	#$80
  1472 E6A1 85 FF		SETMODE2	STA	MODE
  1473 E6A3 D0 AB				BNE	NEXTCMDCHR	; branch always
  1474 E6A5 A9 40		SETBLKMODE	LDA	#$40		; set block list mode
  1475 E6A7 D0 A4				BNE	SETADRMODE
  1476 E6A9 A5 FF		ENDCMD		LDA	MODE		; test if list command pending
  1477 E6AB 30 13				BMI	DUMP		; yes, dump last line
  1478 E6AD 4C 3E E6		CMDEND		JMP	MONINP		; read next command line
  1479 E6B0 6C 0A 18		MONEND		JMP     (RETURN_VECT)   ; return to monitor caller
  1480
  1481 				; store data *******************************************************************
  1482
  1483 E6B3 A5 F8		STOREDATA	LDA  	NUML       	; load lower byte of number
  1484 E6B5 81 FA		                STA  	(ADRL,X)   	; store current store address (X=0)
  1485 E6B7 E6 FA		                INC  	ADRL       	; increment lower store index.
  1486 E6B9 D0 02		                BNE  	NEXTITEM    	; no overflow
  1487 E6BB E6 FB		                INC  	ADRH       	; add carry to upper store index
  1488 E6BD 4C 50 E6		NEXTITEM        JMP  	NEXTCMDCHR    	; get next command string
  1489
  1490 				; call memory dump *************************************************************
  1491
  1492 E6C0 20 C7 E6		DUMP		JSR	MEMDUMP
  1493 E6C3 90 8B				BCC	NEXTCMDCHR   	; get next input
  1494 E6C5 B0 E6				BCS	CMDEND		; yes, stop printing memory dump
  1495
  1496 				; print memory dump ************************************************************
  1497
  1498 E6C7 A2 00		MEMDUMP		LDX	#$00
  1499 E6C9 86 FE				STX  	PDBCNT		; printed data byte count = 0
  1500 E6CB 20 5C E1				JSR	CHKESC		; ESC pressed?
  1501 E6CE 90 01				BCC	PRADR		; no, go on dumping
  1502 E6D0 60					RTS			; yes, exit leaving carry flag set
  1503 E6D1 20 36 E7		PRADR		JSR	PRADDRESS	; print current address
  1504
  1505 				; print current data byte ******************************************************
  1506
  1507 E6D4 20 5E E0		PRDATA		JSR  	SPCOUT		; print space
  1508 E6D7 A1 FA		                LDA  	(ADRL,X)   	; get data from address (X=0)
  1509 E6D9 20 91 E0		                JSR  	HEXOUT     	; print data in hex format
  1510 E6DC E6 FE				INC  	PDBCNT     	; increment data counter
  1511
  1512 				; examine next address *********************************************************
  1513
  1514 E6DE 20 4C E7		ADRNEXT		JSR	CMPADDR		; see if there's more to print
  1515 E6E1 B0 18		                BCS  	FINISHED?  	; no more data to output
  1516
  1517 E6E3 20 7F E9				JSR	INCADR          ; increment list index
  1518 E6E6 A5 FE		DIVCHK          LDA  	PDBCNT
  1519 E6E8 C9 08				CMP  	#$08
  1520 E6EA D0 03				BNE  	MOD16CHK	; do we need a divider?
  1521 E6EC 20 5E E0				JSR  	SPCOUT		; yes, print single SPC as block divider
  1522 E6EF A5 FA		MOD16CHK	LDA  	ADRL       	; if address MOD 16 = 0 start new line
  1523 E6F1 29 0F		                AND  	#$0F
  1524 E6F3 D0 DF				BNE  	PRDATA
  1525 E6F5 20 07 E7				JSR  	PRASCII
  1526 E6F8 4C C7 E6				JMP  	MEMDUMP		; print next line
  1527
  1528 				; check if line print completed ************************************************
  1529
  1530 E6FB A5 FF		FINISHED?	LDA  	MODE		; examine last mode
  1531 E6FD 86 FF				STX  	MODE       	; set mode 0
  1532 E6FF 0A					ASL			; mode = $D0?
  1533 E700 10 03				BPL  	ENDDUMP		; no, get next input
  1534 E702 20 07 E7				JSR  	PRASCII		; yes, we are not finished, print ASCII output for last address
  1535 E705 18			ENDDUMP		CLC			; normal exit, so clear carry flag
  1536 E706 60					RTS
  1537
  1538 				; print a column with ASCII representation of data *****************************
  1539
  1540 E707 84 FD		PRASCII         STY  	YSAV       	; store Y
  1541 E709 38					SEC			; no carry to subtract
  1542 E70A A9 34				LDA  	#52		; max tabs
  1543 E70C E5 FE				SBC  	PDBCNT		; calc tab count to print ASCII column
  1544 E70E E5 FE				SBC  	PDBCNT		; tab = 52-3*printed_data_bytes_count
  1545 E710 E5 FE				SBC  	PDBCNT
  1546 E712 A4 FE				LDY  	PDBCNT
  1547 E714 C0 09				CPY  	#9		; more than 8 bytes viewed?
  1548 E716 B0 02				BCS  	NOADJUST	; no
  1549 E718 69 01				ADC  	#1		; yes, adjust by one char for block divider
  1550 E71A 20 DE E0		NOADJUST	JSR  	TAB		; print tab spaces
  1551
  1552 E71D A0 00				LDY  	#$00
  1553 E71F B1 E6		NEXTASC		LDA  	(ASCL),Y   	; get data from address
  1554 E721 C9 7F				CMP	#$7F
  1555 E723 B0 04				BCS  	NOASC      	; char >= ASCII 127? yes, print '.'
  1556 E725 C9 20				CMP  	#' '
  1557 E727 B0 02				BCS  	ASCOUT		; printable character?
  1558 E729 A9 2E		NOASC		LDA  	#'.'       	; no, print '.'
  1559 E72B 20 52 E0		ASCOUT		JSR  	COUT
  1560 E72E C8					INY
  1561 E72F C4 FE				CPY  	PDBCNT
  1562 E731 D0 EC				BNE  	NEXTASC
  1563 E733 A4 FD				LDY  	YSAV       	; restore Y
  1564 E735 60					RTS
  1565
  1566 				; Prompt new line with current address *****************************************
  1567
  1568 				;*******************************************************************************
  1569
  1570 E736 20 5A E0		PRADDRESS	JSR  	CROUT
  1571 E739 A5 FB				LDA  	ADRH
  1572 E73B 85 E7		                STA  	ASCH		; store current print address high-order byte
  1573 E73D 20 91 E0				JSR  	HEXOUT		; print high-order byte of address
  1574 E740 A5 FA		                LDA  	ADRL
  1575 E742 85 E6				STA  	ASCL		; store current print address low-order byte
  1576 E744 20 91 E0		                JSR  	HEXOUT		; print low-order byte of address
  1577 E747 A9 2D				LDA  	#ADIV      	; print '-'
  1578 E749 4C 52 E0		                JMP  	COUT
  1579
  1580 				; Compare if start address ADR is greater end address NUM **********************
  1581
  1582 				;*******************************************************************************
  1583
  1584 E74C A5 FA		CMPADDR		LDA  	ADRL       	; see if there's more to print
  1585 E74E C5 F8		                CMP  	NUML
  1586 E750 A5 FB		                LDA  	ADRH
  1587 E752 E5 F9		                SBC  	NUMH
  1588 E754 60					RTS
  1589
  1590 				; Jump to original Junior Computer reset vector ********************************
  1591
  1592 				;*******************************************************************************
  1593 E755 A9 06		JCRESET		LDA	#$06			; set PB5 = L (WRITE)
  1594 E757 8D 82 1A				STA	PBD
  1595 E75A 78					SEI
  1596 E75B 20 1A E4				JSR     INITVECT
  1597 E75E 20 CC EF		                JSR     TAPEIRQ_OFF
  1598 E761 58					CLI
  1599 E762 4C 1D 1C				JMP	MONITOR_BLOCK.RESET	; jump to Junior Computer reset routine
  1600
  1601 				; ******************************************************************************
  1602 				; String Data Section
  1603 				; ******************************************************************************
  1604
  1605 E765 00 00 00 00		MAGIC0		.byte	$00,$00,$00,$00                 ; Removed by Emile
  1606 E769 18 90 00 90		MAGIC1          .byte   $18,$90,$00,$90                 ; clc bcc 00 bcc
  1607
  1608 E76D 50 53 41 59 58	PSSTR		.by	'PSAYX'				; processor status string
  1609
  1610 E772			STRINGP							; *** string base pointer ***
  1611 E772 32 4A 1B 5B		ESCCLS  	.byte   $32,$4A,$1B,$5B                 ; VT100 clear screen sequence
  1612 E776 48 00		ESCHOME        	.byte   $48,$00                 	; VT100 cursor home sequence
  1613 E778 32 4B 00		ESCCLL        	.byte   $32,$4B,$00         		; VT100 clear line sequence
  1614 E77B 30 63 00		ESCGID		.byte   $30,$63,$00	        	; VT100 get ID sequence
  1615 E77E 6D 00		ESCNORM		.byte   $6D,$00	        		; VT100 set normal text mode
  1616 E780 37 6D 00		ESCINV		.byte   $37,$6D,$00	        	; VT100 set inverse text mode
  1617 E783 35 6D 00		ESCBLNK		.byte   $35,$6D,$00	        	; VT100 set blinking text mode
  1618
  1619 E786 4A 75 6E 69 6F 72 + TITLE		.by   	'Junior Computer ][' CR,CR,CR
  1620 E79B 20 42 49 4F 53 20 + 		.by   	' BIOS Version '
  1621 E7A9 31 2E 32 2E 33 0D	        	.byte   VERMAIN,$2E,VERPSUB,$2E,VERSSUB,CR
  1622 E7AF 20 32 30 32 30 2F +         	.by   	' 2020/25 by Joerg Walke' CR CR $00
  1623 E7C9 20 49 4F 2F 4C 61 + IOCARD		.by	' IO/Language-Card at $' $00
  1624 E7E0 0D 20 41 53 43 49 + KBDSTR		.by	CR ' ASCII Keyboard connected' $00
  1625 E7FB 0D 0D 0D 0D 00	SPACE    	.byte  	CR, CR, CR, CR, $00
  1626 E800 28 4D 29 6F 6E 69 + MENU		.by   	'(M)onitor  ' $00
  1627 E80C 0D 48 65 78 20 4D + MONSTR		.by	CR 'Hex Monitor' CR $00
  1628
  1629 E81A 0D 0D 20 44 61 74 + DT_NOT_SET	.by	CR CR ' Date/Time not set' CR $00
  1630 E830 0D 20 44 61 74 65 + DATEINPUT	.by	CR ' Date: DD' DATEDIV 'MM' DATEDIV 'YY'
  1631 E840 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1632 E849 0D 20 54 69 6D 65 + TIMEINPUT	.by	CR ' Time: HH' TIMEDIV 'MM' TIMEDIV 'SS'
  1633 E859 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1634
  1635 E862			STRINGP2
  1636 E862 4D 6F 6E 00		DAYS		.by	'Mon' $00
  1637 E866 54 75 65 00				.by	'Tue' $00
  1638 E86A 57 65 64 00				.by	'Wed' $00
  1639 E86E 54 68 75 00				.by	'Thu' $00
  1640 E872 46 72 69 00				.by	'Fri' $00
  1641 E876 53 61 74 00				.by	'Sat' $00
  1642 E87A 53 75 6E 00				.by	'Sun' $00
  1643 E87E 4A 43 4F 53		OSID            .by    'JCOS'
  1644 E882 0D 20 42 6F 6F 74 + BOOTDEV         .by    CR ' Booting from ' $00
  1645 E892 0D 20 4E 6F 20 42 + NOBOOTDEV       .by    CR ' No Boot Disk ' $00
  1646 E8A2 43 46 43 31 00	CFCDEV          .by    'CFC1' $00
  1647 E8A7 53 44 43 31 00	SDCDEV          .by    'SDC1' $00
  1648
  1649 				; ******************************************************************************
  1650 				; START OF DISASSEMBLER
  1651 				; ******************************************************************************
  1652
  1653 E8AC A5 FF		DISASSEM	LDA	MODE
  1654 E8AE 0A					ASL	
  1655 E8AF 10 0E				BPL	SHOW1PAGE	; mode <> $C0 (block mode)?
  1656 E8B1 20 5C E1		NEXTLINE1	JSR     CHKESC          ; ESC pressed?
  1657 E8B4 B0 14				BCS	ENDDISASSEM	; yes, quit disassembling
  1658 E8B6 20 CB E8		NEXTOP		JSR	LOADOPCODE	; load current opcode
  1659 E8B9 20 4C E7		MORE?		JSR	CMPADDR		; see if there's more to print
  1660 E8BC 90 F3		                BCC  	NEXTLINE1  	; no more data to output
  1661 E8BE 60					RTS
  1662 E8BF A9 17		SHOW1PAGE	LDA	#23		; show 23 disassembled lines
  1663 E8C1 85 E1				STA	LINECNT
  1664 E8C3 20 CB E8		NEXTLINE2	JSR	LOADOPCODE	; load current opcode
  1665 E8C6 C6 E1				DEC	LINECNT
  1666 E8C8 D0 F9				BNE	NEXTLINE2	; more lines to show?
  1667 E8CA 60			ENDDISASSEM	RTS			; no, jump back to monitor
  1668
  1669 				; load next opcode
  1670
  1671 E8CB 20 36 E7		LOADOPCODE	JSR	PRADDRESS	; print current address
  1672 E8CE A0 00				LDY	#$00
  1673 E8D0 B1 FA				LDA	(ADRL),Y	; load opcode
  1674 E8D2 A8					TAY			; store opcode in Y
  1675 E8D3 29 03				AND	#$03
  1676 E8D5 C9 03				CMP	#$03		; is it a unused opcode?
  1677 E8D7 D0 05				BNE	DECODE  	; no, decode it
  1678 E8D9 A0 02				LDY	#$02		; Y points to unused opcode $02 to print '???'
  1679 E8DB 98					TYA			; and we also need it in A
  1680 E8DC D0 09				BNE	DECODEMNEM	; branch always
  1681
  1682 				; decode opcode index into compressed opcode instruction table
  1683
  1684 E8DE 98			DECODE		TYA			; reload opcode into A
  1685 E8DF 4A					LSR			; every fourth column in the opcode table is a (opcode) gap
  1686 E8E0 4A					LSR			; so we have to adjust the index because these columns are
  1687 									; stripped off in our indirect index table
  1688 E8E1 85 FC				STA	TEMP		; store number of bytes to subtract
  1689 E8E3 98					TYA			; reload opcode again
  1690 E8E4 38					SEC
  1691 E8E5 E5 FC				SBC	TEMP		; and subtract value in TEMP from the original opcode.
  1692 E8E7 84 E0		DECODEMNEM	STY	OPCODE		; store opcode
  1693 E8E9 A8					TAY			; Y holds now the actual index to the stripped opcode table
  1694 E8EA B9 74 EA				LDA	OPCODES,Y	; load packed mnemonic_index/instr._bytes from opcode table
  1695 E8ED A8					TAY			; and save to Y
  1696 E8EE 29 03				AND	#$03		; the lower two bits are the number of instruction bytes
  1697 E8F0 85 E3				STA	IBYTES		; store it in IBYTES var
  1698 E8F2 98					TYA			; reload packed index
  1699 E8F3 4A					LSR			; and strip the lower two bits off
  1700 E8F4 4A					LSR	
  1701 E8F5 A8					TAY			; Y holds now the index to the mnemonics table
  1702 E8F6 B9 3B EA				LDA   	MNEMONICSH,Y    ; load first packed byte of mnemonic string
  1703 E8F9 85 E7				STA   	ASCH            ; and store it as left byte of mnemonic
  1704 E8FB B9 02 EA				LDA   	MNEMONICSL,Y    ; load second packed byte of mnemonic string
  1705 E8FE 85 E6				STA   	ASCL            ; and store it as right byte of mnemonic
  1706 E900 20 AB E9				JSR	SHOWHEX		; first print out all instruction bytes as hex numbers
  1707 E903 A2 03				LDX   	#$03		; we have to unpack three chars
  1708 E905 A9 00		NEXTMCHR        LDA   	#$00		; clear A
  1709 E907 A0 05				LDY   	#$05            ; shift 5 bits into A
  1710 E909 06 E6		NEXTSHIFT       ASL   	ASCL           	; MSBit of ASCL in C
  1711 E90B 26 E7				ROL   	ASCH		; C in LSBit of ASCH and MSBit of ASCH in C
  1712 E90D 2A					ROL   			; C in A
  1713 E90E 88					DEY
  1714 E90F D0 F8				BNE   	NEXTSHIFT
  1715 E911 69 3F				ADC   	#'?'		; add offset to result, to make it an ASCII char
  1716 E913 20 52 E0				JSR     COUT		; print one character of mnemonic
  1717 E916 CA					DEX
  1718 E917 D0 EC				BNE     NEXTMCHR	; more chars to decode?
  1719 E919 A9 02				LDA	#$02		; print two space chars
  1720 E91B 20 DE E0				JSR	TAB
  1721
  1722 				; decode address mode and print left part of mode string ('#', '(' or 'A')
  1723
  1724 E91E A2 A0				LDX     #$A0            ; default address mode is implied
  1725 E920 A0 FF				LDY	#$FF
  1726 E922 C8			NEXTMASK	INY
  1727 E923 C0 0F				CPY	#$0F		; all masks tested?
  1728 E925 F0 0D				BEQ	ENDMASK		; yes, finish. Address mode is implied
  1729 E927 B9 C5 E9				LDA	ADRMODEM,Y	; load mask
  1730 E92A 25 E0				AND	OPCODE		; mask opcode
  1731 E92C D9 D4 E9				CMP	ADRMODEC,Y	; is it the mask result?
  1732 E92F D0 F1				BNE	NEXTMASK	; no, try next mask
  1733 E931 BE E3 E9				LDX	ADRMODER,Y	; yes, load the resulting address mode
  1734 E934 86 E2		ENDMASK		STX	ADRMODE		; save address mode
  1735 E936 8A					TXA			; address mode is in A
  1736 E937 29 0F				AND	#$0F		; A holds left mode string index
  1737 E939 A8					TAY
  1738 E93A B9 F2 E9				LDA	ADRMSTRL,Y      ; load left mode string
  1739 E93D F0 03				BEQ	PRINTVAL	; is it a NULL char? Then there is nothing to print
  1740 E93F 20 52 E0				JSR	COUT		; else print character
  1741
  1742 				; print either one or two operand value bytes
  1743
  1744 E942 20 7F E9		PRINTVAL	JSR	INCADR		; increment current address
  1745 E945 A6 E3				LDX	IBYTES		; load number of instruction bytes
  1746 E947 CA					DEX			; more than one IBs?
  1747 E948 F0 3B				BEQ	ENDINC		; no, just finish
  1748 E94A A9 24				LDA	#'$'		; yes, print operant value
  1749 E94C 20 52 E0				JSR	COUT		; first print out '$' as hex number indicator
  1750 E94F A0 01				LDY	#$01
  1751 E951 CA					DEX			; more than two IBs?
  1752 E952 F0 05				BEQ	HEX1		; no, just print one byte
  1753 E954 B1 FA				LDA	(ADRL),Y	; load high byte
  1754 E956 20 91 E0				JSR	HEXOUT		; and print it as hex number
  1755 E959 88			HEX1		DEY
  1756 E95A B1 FA				LDA	(ADRL),Y	; load low byte
  1757 E95C A6 E2				LDX	ADRMODE
  1758 E95E E0 A4				CPX	#$A4		; is it a branch opcode?
  1759 E960 F0 24				BEQ	CALCADR		; yes, calculate branch destination address
  1760 E962 20 91 E0				JSR	HEXOUT		; no, print byte as hex number
  1761
  1762 				; print right part of mode string. (',X', ',Y', ',X)', '),Y' or ')' )
  1763
  1764 E965 8A					TXA			; load address mode in A
  1765 E966 4A					LSR			; upper nibble is index to right address mode string
  1766 E967 4A					LSR			; so we have to shift it right by four bits
  1767 E968 4A					LSR	
  1768 E969 4A					LSR	
  1769 E96A A8					TAY
  1770 E96B B9 F7 E9		NEXTAMCHR	LDA	ADRMSTRR,Y	; load one char of right mode string
  1771 E96E F0 06				BEQ     ENDMODE		; if a NULL char then we are finished
  1772 E970 20 52 E0				JSR	COUT		; else print char
  1773 E973 C8					INY
  1774 E974 D0 F5				BNE	NEXTAMCHR	; branch always
  1775
  1776 				; finish current instruction
  1777
  1778 E976 A5 E3		ENDMODE		LDA	IBYTES		; how many address increments left?
  1779 E978 C9 03				CMP	#$03
  1780 E97A D0 03				BNE	INCADR		; just one?
  1781 E97C 20 7F E9				JSR	INCADR		; no, two increments needed
  1782
  1783 				; increment current address
  1784
  1785 E97F E6 FA		INCADR  	INC  	ADRL    	; increment current address
  1786 E981 D0 02		        	BNE  	ENDINC  	; no carry!
  1787 E983 E6 FB		        	INC  	ADRH
  1788 E985 60			ENDINC		RTS			; end of disassembly
  1789
  1790 				; calculate destination address for branch instructions
  1791
  1792 E986 38			CALCADR		SEC
  1793 E987 A8					TAY			; transfer A to Y for sign test
  1794 E988 10 10				BPL	ADDOFS		; is the branch offset positiv?
  1795 E98A 49 FF				EOR	#$FF		; no, subtract offset from current address
  1796 E98C 85 E8				STA	STOL
  1797 E98E A5 FA				LDA	ADRL
  1798 E990 E5 E8				SBC	STOL		; subtract branch offset from LSB current address
  1799 E992 A8					TAY			; store low byte of address to Y
  1800 E993 A5 FB				LDA	ADRH
  1801 E995 E9 00				SBC	#$00		; substract carry from MSB of address
  1802 E997 4C A1 E9				JMP	PRINTOFFS
  1803 E99A 65 FA		ADDOFS		ADC	ADRL		; add branch offset to LSB of current address
  1804 E99C A8					TAY			; store low byte of address to Y
  1805 E99D A5 FB				LDA	ADRH
  1806 E99F 69 00				ADC	#$00		; add carry to MSB of address
  1807 E9A1 20 91 E0		PRINTOFFS	JSR	HEXOUT		; print high byte of branch address
  1808 E9A4 98					TYA
  1809 E9A5 20 91 E0				JSR	HEXOUT		; print low byte of branch address
  1810 E9A8 4C 7F E9				JMP	INCADR		; and increment current address by one
  1811
  1812 				; show instruction bytes as hex values and trailing variable number of space chars
  1813
  1814 E9AB A0 00		SHOWHEX		LDY	#$00
  1815 E9AD 20 5E E0		NEXTBYTE	JSR	SPCOUT		; print leading space char
  1816 E9B0 B1 FA				LDA	(ADRL),Y	; load data byte
  1817 E9B2 20 91 E0				JSR	HEXOUT		; and print it
  1818 E9B5 C8					INY
  1819 E9B6 C4 E3				CPY	IBYTES		; all data bytes printed?
  1820 E9B8 D0 F3				BNE	NEXTBYTE	; no, print next byte
  1821 E9BA A9 0C				LDA	#$0C		; tab size is 12
  1822 E9BC 38					SEC
  1823 E9BD E9 03		CALCTAB		SBC	#$03		; reduce tab space by 3 for every data byte
  1824 E9BF 88					DEY
  1825 E9C0 D0 FB				BNE	CALCTAB		; all data bytes considered?
  1826 E9C2 4C DE E0				JMP	TAB
  1827
  1828 				; Address Mode Decode Tables ***************************************************
  1829
  1830 				; Mask, Mask Result and Mode tables. If Opcode and Mask = Mask Result then Mode
  1831 				; each Mode holds two indices (4 bits R | 4 bits L) to the mode string parts
  1832
  1833 				; ******************************************************************************
  1834
  1835 E9C5 FF FF FF 1F 1F 1F + ADRMODEM	.byte	$FF,$FF,$FF,$1F,$1F,$1F,$1F,$1F,$9F,$9F,$1C,$1C,$DF,$1C,$1C ; mask bits
  1836
  1837 E9D4 6C A2 BE 01 09 10 + ADRMODEC	.byte	$6C,$A2,$BE,$01,$09,$10,$11,$19,$0A,$80,$04,$0C,$96,$14,$1C ; mask result bits
  1838
  1839 E9E3 52 A1 80 32 A1 A4 + ADRMODER	.byte	$52,$A1,$80,$32,$A1,$A4,$72,$80,$A3,$A1,$A0,$A0,$80,$00,$00 ; packed mode bits
  1840
  1841 				; Address Mode Strings *********************************************************
  1842
  1843 E9F2 00 23 28 41 00	ADRMSTRL	.byte	$00,$23,$28,$41,$00
  1844 						;	 0   #   (   A   0
  1845
  1846 E9F7 2C 58 00 2C 58 29 + ADRMSTRR	.byte	$2C,$58,$00,$2C,$58,$29,$00,$29,$2C,$59,$00
  1847 						;	 ,   X   0   ,   X   )   0   )   ,   Y   0
  1848
  1849 				; Mnemonics Table **************************************************************
  1850
  1851 				; three characters packed in two bytes. Each character uses 5 bits, last bit is
  1852 				; unused
  1853
  1854 				; ******************************************************************************
  1855
  1856 				; low bytes of table
  1857
  1858 EA02 48 CA 1A 08 28 A4 + MNEMONICSL	.byte	$48, $CA, $1A, $08, $28, $A4, $AA, $94
  1859 EA0A CC 5A D8 C8 E8 48 +      		.byte	$CC, $5A, $D8, $C8, $E8, $48, $4A, $54
  1860 EA12 6E A2 72 74 88 B2 +      		.byte	$6E, $A2, $72, $74, $88, $B2, $B4, $26
  1861 EA1A C8 F2 F4 A2 26 44 +      		.byte	$C8, $F2, $F4, $A2, $26, $44, $72, $74
  1862 EA22 26 22 C4 44 62 44 +      		.byte	$26, $22, $C4, $44, $62, $44, $62, $1A
  1863 EA2A 26 54 68 C8 88 8A +      		.byte	$26, $54, $68, $C8, $88, $8A, $94, $44
  1864 EA32 72 74 B2 B4 32 44 +      		.byte	$72, $74, $B2, $B4, $32, $44, $68, $84, $00
  1865
  1866 				; high bytes of table
  1867
  1868 EA3B 11 13 15 19 19 19 + MNEMONICSH	.byte	$11, $13, $15, $19, $19, $19, $1A, $1B
  1869 EA43 1B 1C 1C 1D 1D 23 +      		.byte	$1B, $1C, $1C, $1D, $1D, $23, $23, $23
  1870 EA4B 23 23 24 24 29 29 +      		.byte	$23, $23, $24, $24, $29, $29, $29, $34
  1871 EA53 53 53 53 5B 5D 69 +      		.byte	$53, $53, $53, $5B, $5D, $69, $69, $69
  1872 EA5B 6D 7C 84 8A 8A 8B +      		.byte	$6D, $7C, $84, $8A, $8A, $8B, $8B, $9C
  1873 EA63 9C 9D 9D A0 A1 A1 +      		.byte	$9C, $9D, $9D, $A0, $A1, $A1, $A1, $A5
  1874 EA6B A5 A5 A8 A8 AD AE +      		.byte	$A5, $A5, $A8, $A8, $AD, $AE, $AE, $AE, $00
  1875
  1876 				; Compressed Opcode Table ******************************************************
  1877
  1878 				; each byte holds a 6 bit index to the mnemonic table and 2 bits instruction
  1879 				; byte count
  1880 				; empty opcode table columns (3,7,B,F) are stripped out
  1881
  1882 				; ******************************************************************************
  1883
  1884 EA74 29 8A E1 E1 8A 0A + OPCODES         .byte	$29, $8A, $E1, $E1, $8A, $0A, $91, $8A, $09, $E1, $8B, $0B
  1885 EA80 26 8A E1 E1 8A 0A +      		.byte	$26, $8A, $E1, $E1, $8A, $0A, $35, $8B, $E1, $E1, $8B, $0B
  1886 EA8C 73 06 E1 1A 06 9E +      		.byte	$73, $06, $E1, $1A, $06, $9E, $99, $06, $9D, $1B, $07, $9F
  1887 EA98 1E 06 E1 E1 06 9E +      		.byte	$1E, $06, $E1, $E1, $06, $9E, $B1, $07, $E1, $E1, $07, $9F
  1888 EAA4 A5 5E E1 E1 5E 82 +      		.byte	$A5, $5E, $E1, $E1, $5E, $82, $8D, $5E, $81, $6F, $5F, $83
  1889 EAB0 2E 5E E1 E1 5E 82 +      		.byte	$2E, $5E, $E1, $E1, $5E, $82, $3D, $5F, $E1, $E1, $5F, $83
  1890 EABC A9 02 E1 E1 02 A2 +      		.byte	$A9, $02, $E1, $E1, $02, $A2, $95, $02, $A1, $6F, $03, $A3
  1891 EAC8 32 02 E1 E1 02 A2 +      		.byte	$32, $02, $E1, $E1, $02, $A2, $B9, $03, $E1, $E1, $03, $A3
  1892 EAD4 E1 BE E1 C6 BE C2 +      		.byte	$E1, $BE, $E1, $C6, $BE, $C2, $59, $E1, $D5, $C7, $BF, $C3
  1893 EAE0 0E BE E1 C6 BE C2 +      		.byte	$0E, $BE, $E1, $C6, $BE, $C2, $DD, $BF, $D9, $E1, $BF, $E1
  1894 EAEC 7E 76 7A 7E 76 7A +      		.byte	$7E, $76, $7A, $7E, $76, $7A, $CD, $76, $C9, $7F, $77, $7B
  1895 EAF8 12 76 E1 7E 76 7A +      		.byte	$12, $76, $E1, $7E, $76, $7A, $41, $77, $D1, $7F, $77, $7B
  1896 EB04 4E 46 E1 4E 46 52 +      		.byte	$4E, $46, $E1, $4E, $46, $52, $69, $46, $55, $4F, $47, $53
  1897 EB10 22 46 E1 E1 46 52 +      		.byte	$22, $46, $E1, $E1, $46, $52, $39, $47, $E1, $E1, $47, $53
  1898 EB1C 4A AE E1 4A AE 62 +      		.byte	$4A, $AE, $E1, $4A, $AE, $62, $65, $AE, $85, $4B, $AF, $63
  1899 EB28 16 AE E1 E1 AE 62 +      		.byte	$16, $AE, $E1, $E1, $AE, $62, $B5, $AF, $E1, $E1, $AF, $63
  1900
  1901 				; ******************************************************************************
  1902 				; START OF HIGH LEVEL REAL TIME CLOCK CODE
  1903 				; ******************************************************************************
  1904
  1905 				; **** Check If Date/Time Is Set And Show Date/Time ****************************
  1906
  1907 EB34 20 43 EB		CLOCKSTART	JSR	CHECKDATETIME
  1908 EB37 20 5A E0				JSR	CROUT
  1909 EB3A 20 5A E0				JSR	CROUT
  1910 EB3D 20 5E E0				JSR	SPCOUT
  1911 EB40 4C F9 EB				JMP	PRINTDATETIME
  1912
  1913 				; **** Check If Date/Time Is Set ***********************************************
  1914
  1915 				; ******************************************************************************
  1916
  1917 EB43 A9 08		CHECKDATETIME	LDA	#$08
  1918 EB45 20 E6 E2				JSR	READCLOCK
  1919 EB48 C0 65				CPY	#$65
  1920 EB4A D0 05				BNE	DATETIMELOST
  1921 EB4C E0 02				CPX	#$02
  1922 EB4E D0 01				BNE	DATETIMELOST
  1923 EB50 60					RTS
  1924
  1925 EB51 20 43 E5		DATETIMELOST	JSR	LOADSTRING
  1926 EB54 A0 A8				LDY	#DT_NOT_SET-STRINGP
  1927 EB56 20 85 E0				JSR	WRSTR
  1928
  1929 EB59 20 86 EB		SETDATETIME	JSR	SETTIME
  1930
  1931 EB5C 20 43 E5		SETDATE		JSR	LOADSTRING
  1932 EB5F A9 2E				LDA	#'.'
  1933 EB61 85 F2				STA	DIVCHAR
  1934 EB63 A0 BE				LDY	#DATEINPUT-STRINGP
  1935 EB65 20 85 E0				JSR	WRSTR
  1936 EB68 A0 31				LDY	#$31
  1937 EB6A 20 B0 EB				JSR	GETDIGIT
  1938 EB6D 85 F4				STA	YREG
  1939 EB6F 20 49 EC				JSR	PRINTDIVCHAR
  1940 EB72 A0 12				LDY	#$12
  1941 EB74 20 B0 EB				JSR	GETDIGIT
  1942 EB77 85 F5				STA	XREG
  1943 EB79 20 49 EC				JSR	PRINTDIVCHAR
  1944 EB7C A0 99				LDY	#$99
  1945 EB7E 20 B0 EB				JSR	GETDIGIT
  1946 EB81 85 F3				STA	ACC
  1947 EB83 4C B7 E2				JMP	WRITEDATE2
  1948
  1949 EB86 20 43 E5		SETTIME		JSR	LOADSTRING
  1950 EB89 A9 3A				LDA	#':'
  1951 EB8B 85 F2				STA	DIVCHAR
  1952 EB8D A0 D7				LDY	#TIMEINPUT-STRINGP
  1953 EB8F 20 85 E0				JSR	WRSTR
  1954 EB92 A0 23				LDY	#$23
  1955 EB94 20 B0 EB				JSR	GETDIGIT
  1956 EB97 85 F3				STA	ACC
  1957 EB99 20 49 EC				JSR	PRINTDIVCHAR
  1958 EB9C A0 59				LDY	#$59
  1959 EB9E 20 B0 EB				JSR	GETDIGIT
  1960 EBA1 85 F5				STA	XREG
  1961 EBA3 20 49 EC				JSR	PRINTDIVCHAR
  1962 EBA6 A0 59				LDY	#$59
  1963 EBA8 20 B0 EB				JSR	GETDIGIT
  1964 EBAB 85 F4				STA	YREG
  1965 EBAD 4C 9F E2				JMP	WRITETIME2
  1966
  1967 EBB0 C8			GETDIGIT	INY
  1968 EBB1 84 FD				STY	YSAV
  1969 EBB3 20 EA EB		GETDIGIT1	JSR	NUMINPUT
  1970 EBB6 90 FB				BCC	GETDIGIT1
  1971 EBB8 AA					TAX
  1972 EBB9 E9 30				SBC	#48
  1973 EBBB 0A					ASL	
  1974 EBBC 0A					ASL	
  1975 EBBD 0A					ASL	
  1976 EBBE 0A					ASL	
  1977 EBBF C5 FD				CMP	YSAV
  1978 EBC1 B0 F0				BCS	GETDIGIT1
  1979 EBC3 85 FC				STA	TEMP
  1980 EBC5 8A					TXA
  1981 EBC6 20 52 E0				JSR	COUT
  1982 EBC9 20 EA EB		GETDIGIT2	JSR	NUMINPUT
  1983 EBCC 90 FB				BCC	GETDIGIT2
  1984 EBCE AA					TAX
  1985 EBCF E9 30				SBC	#48
  1986 EBD1 05 FC				ORA	TEMP
  1987 EBD3 C5 FD				CMP	YSAV
  1988 EBD5 B0 F2				BCS	GETDIGIT2
  1989 EBD7 85 FC				STA	TEMP
  1990 EBD9 A9 2E				LDA	#'.'
  1991 EBDB C5 F2				CMP	DIVCHAR
  1992 EBDD D0 04				BNE	GETDIGITEND
  1993 EBDF A5 FC				LDA	TEMP
  1994 EBE1 F0 E6				BEQ	GETDIGIT2
  1995 EBE3 8A			GETDIGITEND	TXA
  1996 EBE4 20 52 E0				JSR	COUT
  1997 EBE7 A5 FC				LDA	TEMP
  1998 EBE9 60					RTS
  1999
  2000
  2001 EBEA 20 47 E0		NUMINPUT	JSR	CIN
  2002 EBED C9 30				CMP	#'0'
  2003 EBEF 90 04				BCC	NOTNUM
  2004 EBF1 C9 3A				CMP	#':'
  2005 EBF3 90 02				BCC	ISNUM
  2006 EBF5 18			NOTNUM		CLC
  2007 EBF6 60					RTS
  2008 EBF7 38			ISNUM		SEC
  2009 EBF8 60					RTS
  2010
  2011 				; **** Print Date And Time *****************************************************
  2012
  2013 				; ******************************************************************************
  2014
  2015 EBF9 20 2B EC		PRINTDATETIME	JSR	PRINTDATE	; print current date	; PRINTFULLDATE
  2016 EBFC 20 5E E0				JSR	SPCOUT
  2017 EBFF 20 05 EC				JSR	PRINTTIME	; print current time
  2018 EC02 4C 5A E0				JMP	CROUT
  2019
  2020 				; **** Print Time **************************************************************
  2021
  2022 				; ******************************************************************************
  2023
  2024 EC05 A9 3A		PRINTTIME	LDA	#':'
  2025 EC07 85 F2				STA	DIVCHAR
  2026 EC09 20 DE E2				JSR	READTIME
  2027 EC0C 20 46 EC				JSR	PRINTDIGIT
  2028 EC0F 8A					TXA
  2029 EC10 20 46 EC				JSR	PRINTDIGIT
  2030 EC13 98					TYA
  2031 EC14 4C 91 E0				JMP	HEXOUT
  2032
  2033 				; **** Print Date And Day Of Week **********************************************
  2034
  2035 				; ******************************************************************************
  2036
  2037 EC17 20 92 E2		PRINTFULLDATE	JSR	READDOW
  2038 EC1A 0A					ASL	
  2039 EC1B 0A					ASL	
  2040 EC1C A8					TAY
  2041 EC1D A9 5E				LDA  	#< (DAYS-4)
  2042 EC1F 85 EA				STA  	PSTRL
  2043 EC21 A9 E8				LDA  	#> (DAYS-4)
  2044 EC23 85 EB				STA  	PSTRH
  2045 EC25 20 85 E0				JSR	WRSTR
  2046 EC28 20 5E E0				JSR	SPCOUT
  2047
  2048 				; **** Print Date **************************************************************
  2049
  2050 				; ******************************************************************************
  2051
  2052 EC2B A9 2E		PRINTDATE	LDA	#DATEDIV	; load divider char
  2053 EC2D 85 F2				STA	DIVCHAR
  2054 EC2F 20 E2 E2				JSR	READDATE	; read current date
  2055 EC32 85 FC				STA	TEMP		; store year value in TEMP
  2056 EC34 98					TYA
  2057 EC35 20 46 EC				JSR	PRINTDIGIT	; print day
  2058 EC38 8A					TXA
  2059 EC39 20 46 EC				JSR	PRINTDIGIT	; print month
  2060 EC3C A9 20				LDA	#CENTURY
  2061 EC3E 20 91 E0				JSR	HEXOUT		; print century
  2062 EC41 A5 FC				LDA	TEMP
  2063 EC43 4C 91 E0				JMP	HEXOUT		; print year
  2064
  2065 EC46 20 91 E0		PRINTDIGIT	JSR	HEXOUT		; print digit
  2066 EC49 A5 F2		PRINTDIVCHAR	LDA	DIVCHAR		; print divider char
  2067 EC4B 4C 52 E0				JMP	COUT
  2068
  2069 				; ******************************************************************************
  2070 				; START OF LOW LEVEL ROUTINES
  2071 				; ******************************************************************************
  2072
  2073 				; **** Print Processor Status **************************************************
  2074
  2075 				; ******************************************************************************
  2076
  2077 EC4E 20 36 E7		PRSTATUS	JSR	PRADDRESS	; print current program counter
  2078 EC51 A2 04				LDX	#$04
  2079 EC53 20 5E E0		NXTREG		JSR	SPCOUT		; print space char
  2080 EC56 BD 6D E7				LDA	PSSTR,X		; load register label
  2081 EC59 20 52 E0				JSR	COUT		; and print it
  2082 EC5C A9 3D				LDA	#'='
  2083 EC5E 20 52 E0				JSR	COUT		; print =
  2084 EC61 B5 F1				LDA	PREG,X
  2085 EC63 20 91 E0				JSR	HEXOUT
  2086 EC66 CA					DEX
  2087 EC67 10 EA				BPL	NXTREG
  2088 EC69 60					RTS
  2089
  2090 				; **** Initialize IO Devices ***************************************************
  2091
  2092 				; ******************************************************************************
  2093
  2094 EC6A A9 00		INITIO          LDA     #$00
  2095 EC6C A2 06		                LDX     #$06
  2096 EC6E 95 14		INITIO1         STA     IOBASE,X        ; clear K2,K3 and K4 base address pointers
  2097 EC70 CA			                DEX
  2098 EC71 D0 FB		                BNE     INITIO1
  2099
  2100 EC73 20 64 F7		                JSR     DEV_INIT        ; initialize driver list
  2101 EC76 A2 88		SET_TTY_DEV     LDX     #<  TTY_DEV
  2102 EC78 A0 F9		                LDY     #> TTY_DEV
  2103 EC7A 20 6F F7		                JSR     DEV_ADD         ; add terminal driver
  2104 EC7D 8D 74 1A				STA	STDINDEV        ; and initially set TTY as standard IO
  2105 EC80 8D 75 1A				STA	STDOUTDEV
  2106 EC83 85 C9				STA     DEVID
  2107
  2108 EC85 A2 A8		SET_XMODEM_DEV  LDX     #<  XMODEM_DEV
  2109 EC87 A0 F9		                LDY     #> XMODEM_DEV
  2110 EC89 20 6F F7		                JSR     DEV_ADD         ; add xmodem driver
  2111
  2112 EC8C A2 90		SET_PRINTER_DEV LDX     #<  PPRINT_DEV
  2113 EC8E A0 F9		                LDY     #> PPRINT_DEV
  2114 EC90 20 6F F7		                JSR     DEV_ADD         ; add parallel printer driver
  2115 EC93 8D 76 1A		                STA	STDPRINTDEV     ; and initially set parallel port printer as standard printer
  2116
  2117 EC96 20 A9 EC				JSR     DETECT_IO       ; detect IO cards
  2118
  2119 				; TEMP #### future: Set std beep only if no language card found
  2120
  2121 EC99 A9 6A		INIT_BEEP	LDA	#< DOBEEP	; load low byte of address of system beep
  2122 EC9B 8D 66 1A				STA	STDBEEP
  2123 EC9E A9 E1				LDA	#> DOBEEP	; load high byte of address of system beep
  2124 ECA0 8D 67 1A				STA	STDBEEP+1
  2125
  2126 ECA3 4C AD E1		                JMP     RESET_STDIO     ; reset to standard IO devices
  2127
  2128 ECA6 6C FA 00		IO_INITIALIZE   JMP     (ADRL)
  2129
  2130 				; **** Scan Bus And Detect IO Cards ********************************************
  2131 				;
  2132 				; ******************************************************************************
  2133
  2134 ECA9 A9 FB		DETECT_IO       LDA     #$FB
  2135 ECAB 85 FA		                STA     ADRL            ; set pointer to init routine
  2136 ECAD A9 07		                LDA     #$07
  2137 ECAF 85 FB		                STA     ADRH
  2138 ECB1 A9 03		                LDA     #$03            ; search on three slot base addresses
  2139 ECB3 85 FE		                STA     PDBCNT
  2140 ECB5 18			DETECT_LOOP     CLC
  2141 ECB6 A5 FB		                LDA     ADRH
  2142 ECB8 AA			                TAX
  2143 ECB9 E8			                INX                     ; X holds slot base address high byte
  2144 ECBA 69 04		                ADC     #$04
  2145 ECBC 85 FB		                STA     ADRH            ; set high byte to init routine
  2146 ECBE A0 03		                LDY	#$03            ; test byte string in card ROM against magic number
  2147 ECC0 B9 69 E7		COMP_LOOP	LDA	MAGIC1,Y        ; get one byte of magic number
  2148 ECC3 D1 FA				CMP	(ADRL),Y        ; and compare it with ROM content.
  2149 ECC5 D0 06				BNE	NO_MATCH        ; byte does not match, exit inner detection loop
  2150 ECC7 88					DEY                     ; byte matched magic number, try next one
  2151 ECC8 10 F6				BPL	COMP_LOOP       ; more bytes to compare?
  2152 ECCA 20 A6 EC				JSR     IO_INITIALIZE   ; IO card detected. Call init routine
  2153 ECCD C6 FE		NO_MATCH        DEC     PDBCNT
  2154 ECCF D0 E4		                BNE     DETECT_LOOP     ; try next card base address
  2155 				                                        ; fall through to IO/Language Card detection
  2156
  2157 				; **** Try To Detect IO/Language Card ******************************************
  2158 				;
  2159 				; ******************************************************************************
  2160
  2161 ECD1 A9 00		DETECT_IOL_CARD	LDA	#$00
  2162 ECD3 85 14				STA	IOBASEL		; set low byte of IO base pointer to $00
  2163 ECD5 A9 08				LDA	#$08		; try 1st IO-card at $0800
  2164 ECD7 85 15				STA	IOBASEH		; set high byte of IO base pointer to $00
  2165 						
  2166 ECD9 A0 12		DETECT_LP	LDY	#DDRB		; input & output regs are the same
  2167 ECDB 91 14				STA	(IOBASE),Y
  2168 ECDD 84 FA				STY	ADRL		; reset databus
  2169 ECDF D1 14				CMP	(IOBASE),Y	; Match only if 6522 VIA is present
  2170 ECE1 F0 1C				BEQ	STOREBASE	; branch if a card is found
  2171 						
  2172 ECE3 18					CLC
  2173 ECE4 69 04				ADC	#4		; next IO base-address
  2174 ECE6 85 15				STA	IOBASEH		; next card-address
  2175 ECE8 C9 14				CMP	#$14
  2176 ECEA 90 ED				BCC	DETECT_LP	; branch if MSB base-address < $14
  2177 						
  2178 ECEC A9 00				LDA	#0
  2179 ECEE 85 15				STA	IOBASEH		; 0 = no card found
  2180 ECF0 60			NOCARD          RTS                     ; no card found
  2181
  2182 				;----------------------------------------------------------------------------------		
  2183 				; This routine sets the return vector that is used by both Monitor and boot.sys.
  2184 				;----------------------------------------------------------------------------------		
  2185 ECF1 8E 0A 18		SET_RETURN_VECT	STX     RETURN_VECT     	; set entry point for monitor warm start
  2186 ECF4 8C 0B 18		                STY     RETURN_VECT+1
  2187 ECF7 60					RTS
  2188
  2189 ECF8					ORG	$ECFF		; maintain compatibility with v1.1.4
  2190 						
  2191 ECFF 85 15		STOREBASE	STA	IOBASEH		; card found, set high byte of base pointer.
  2192
  2193 				; **** Initialize The IO/Language Card *****************************************
  2194
  2195 				; ******************************************************************************
  2196
  2197 ED01 AD 74 1A		INIT_IOCARD     LDA     STDINDEV
  2198 ED04 C9 10		                CMP     #TTY1_ID
  2199 ED06 D0 03		                BNE     INIT_VIA        ; is standard input device still TTY?
  2200 ED08 20 BD F3		                JSR	DETECT_ASCIIKBD	; yes, check if ASCII keyboard available, else skip it
  2201 ED0B A0 10		INIT_VIA	LDY	#PORTB
  2202 ED0D A9 4E				LDA	#%01001110	; SDA=0,/CAS_MOT=1,CAS_SENSE=0,CAS_WR=0,/SPI_LOAD=1,SPI_CS=1,/SND_WE=1,SCL=0
  2203 ED0F 85 E4				STA	VIA_STATUS	; store current PortB output status
  2204 ED11 91 14				STA	(IOBASE),Y	; set SDA as input to pull it high, set SCL as input to pull it high
  2205 ED13 A0 12				LDY	#DDRB		; initialize data direction of port B
  2206 ED15 A9 5E				LDA	#%01011110	; SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
  2207 ED17 91 14				STA	(IOBASE),Y
  2208 ED19 A0 13				LDY	#DDRA		; initialize data direction of port A
  2209 ED1B A9 FF				LDA	#$FF		; all pins of port A are outputs
  2210 ED1D 91 14				STA	(IOBASE),Y
  2211 ED1F 20 D0 E3				JSR	SOUND_MUTEALL	; mute sound output
  2212 ED22 20 26 F4		INIT_SDCARD     JSR     SPI_INIT        ; initialize SPI
  2213 ED25 A2 B8		                LDX     #<  SDC_DEV
  2214 ED27 A0 F9		                LDY     #> SDC_DEV
  2215 ED29 20 6F F7		                JSR     DEV_ADD         ; add sd-card driver
  2216 ED2C A9 00		INIT_TAPE       LDA	#$00
  2217 ED2E A0 1B		                LDY	#ACR		; select auxilary control register
  2218 ED30 91 14				STA	(IOBASE),Y	; set one shot timer mode
  2219 ED32 85 E5		                STA	KEY_SENSE	; reset tape sense line status
  2220 ED34 A0 1C				LDY	#PCR		; select peripheral control register
  2221 ED36 91 14				STA	(IOBASE),Y	; set interrupt on falling edge of CA1
  2222 						;LDY	#IER		; select interrupt enable register
  2223 ED38 20 DF EF				JSR	TAPERW_OFF	; turn tape read/write mode off
  2224 ED3B 20 99 EF				JSR	RESET_TIMER2	; set Timer2 to 1/60 second
  2225 ED3E A2 B0		                LDX     #<  TAPE_DEV
  2226 ED40 A0 F9		                LDY     #> TAPE_DEV
  2227 ED42 20 6F F7		                JSR     DEV_ADD         ; add tape driver
  2228 ED45 A2 63				LDX	#<  TAPEIRQ 	; set low address of clock interrupt routine
  2229 ED47 A0 EF				LDY	#> TAPEIRQ   ; set low address of clock interrupt routine
  2230 ED49 8E 7E 1A		SETIRQVECT	STX	IRQVECT
  2231 ED4C 8C 7F 1A				STY	IRQVECT+1
  2232 ED4F 60					RTS
  2233
  2234 				; ******************************************************************************
  2235 				; START OF TAPE READ/WRITE ROUTINES
  2236 				; ******************************************************************************
  2237
  2238 ED50 4C ED ED		TAPEESC		JMP	BREAKSYNC
  2239
  2240 				; *** Tape Load Routine ********************************************************
  2241
  2242 				; ******************************************************************************
  2243
  2244 ED53 20 E7 EF		TAPELOAD	JSR	PREPFILENAME
  2245 ED56 20 81 F2				JSR	TAPE_PLAY_MSG	; print PLAY message
  2246 ED59 20 85 F2				JSR	TAPE_ESC_MSG
  2247 ED5C 20 5C E1		WAITPLAY	JSR	CHKESC		; <ESC> key pressed?
  2248 ED5F B0 EF				BCS	TAPEESC		; yes -> exit
  2249 ED61 A5 E5				LDA	KEY_SENSE	; check sense line status
  2250 ED63 D0 F7				BNE	WAITPLAY	; if <> 0, wait until datasette key pressed down
  2251 ED65 20 D7 EF				JSR	TAPERW_ON	; turn off key clock interrupt and turn on bit read interrupt
  2252 ED68 20 72 F2		STARTLOAD	JSR	TAPE_LOAD_MSG	; print LOAD message
  2253 ED6B 20 B6 EF				JSR	MOTOR_ON	; and turn motor on
  2254 ED6E A9 01		STARTSYNC	LDA	#$01		; we are in sync mode
  2255 ED70 85 ED				STA	BITCNT		; so initialize bit counter to just one bit
  2256 ED72 A0 10		WAITBIT		LDY	#PORTB		; set index to Port B
  2257 ED74 B1 14				LDA	(IOBASE),Y	; load port B
  2258 ED76 29 20				AND	#$20		; test tape sense line at PB5
  2259 ED78 D0 73				BNE	BREAKSYNC	; if sense line is high, PLAY key is no longer down -> exit.
  2260 ED7A A5 ED		READSYNC	LDA	BITCNT		; bit counter reached 0 ?
  2261 ED7C D0 F4				BNE	WAITBIT		; no, wait for more bits
  2262 ED7E A5 DD				LDA	OUTBYTE		; yes, load current byte into A
  2263 ED80 C9 2E				CMP	#SYNCMARK	; is it a valid sync mark?
  2264 ED82 D0 EA				BNE	STARTSYNC	; no, resync
  2265 ED84 A2 00				LDX	#$00
  2266 ED86 86 E3				STX	IBYTES		; yes, reset sync block counter
  2267 ED88 20 60 EE		GETBYTE?	JSR	BYTE_IN		; read next full byte
  2268 ED8B A5 DD				LDA	OUTBYTE		; and load it into A
  2269 ED8D C9 2E				CMP	#SYNCMARK	; still a sync mark?
  2270 ED8F D0 0B				BNE	SYNCEND?	; no, check if end of sync
  2271 ED91 E8					INX			; yes, increment sync mark counter
  2272 ED92 D0 F4				BNE	GETBYTE?	; 256 sync marks read? no read more
  2273 ED94 20 52 E0				JSR	COUT		; yes, print '.'
  2274 ED97 E6 E3				INC	IBYTES		; increment sync block counter
  2275 ED99 4C 88 ED				JMP	GETBYTE?	; and read next byte
  2276 ED9C A5 E3		SYNCEND?	LDA	IBYTES
  2277 ED9E F0 CE				BEQ	STARTSYNC	; at least one sync block read? no resync
  2278 EDA0 20 F9 ED				JSR	READHEADER	; yes, read header. C = 0 if no header mark is found. X returns 0
  2279 EDA3 90 C9				BCC	STARTSYNC	; no header mark found or names not equal. resync
  2280 EDA5 86 E2				STX	BLKNO		; BLKNO = 0
  2281 EDA7 86 DC				STX	CHECKSUM	; CHECKSUM = 0
  2282 EDA9 A5 DD		NEXTBLK		LDA	OUTBYTE		; load current block number into A
  2283 EDAB C5 E2				CMP	BLKNO		; is it the expected number?
  2284 EDAD D0 44				BNE	ERRLOAD		; no, error.
  2285 EDAF 20 60 EE		NEXTDATA	JSR	BYTE_IN		; yes, read next data byte
  2286 EDB2 A5 DD				LDA	OUTBYTE		; and load it into A
  2287 EDB4 A0 00				LDY	#$00
  2288 EDB6 91 FA				STA	(ADRL),Y	; store read data byte to destination address
  2289 EDB8 45 DC				EOR	CHECKSUM	; XOR it with checksum
  2290 EDBA 85 DC				STA	CHECKSUM	; and write result back to checksum
  2291 EDBC 20 4C E7				JSR	CMPADDR		; see if there's more to load
  2292 EDBF B0 17		                BCS  	ENDLDDATA  	; no, finish loading
  2293 EDC1 20 7F E9				JSR	INCADR		; yes, increment current destination address
  2294 EDC4 E8					INX
  2295 EDC5 D0 E8				BNE	NEXTDATA	; and read next byte
  2296 EDC7 20 60 EE				JSR	BYTE_IN		; read checksum
  2297 EDCA A5 DD				LDA	OUTBYTE		; and load it int A
  2298 EDCC C5 DC				CMP	CHECKSUM	; compare expected check sum with calculated checksum
  2299 EDCE D0 23				BNE	ERRLOAD		; if checksum incorrect, exit with error
  2300 EDD0 20 60 EE				JSR	BYTE_IN		; read next block number
  2301 EDD3 E6 E2				INC	BLKNO		; increment internal block counter
  2302 EDD5 4C A9 ED				JMP	NEXTBLK		; read next block
  2303 EDD8 20 60 EE		ENDLDDATA	JSR	BYTE_IN		; read last checksum
  2304 EDDB A5 DD				LDA	OUTBYTE		; and load it int A
  2305 EDDD C5 DC				CMP	CHECKSUM	; compare expected check sum with calculated checksum
  2306 EDDF D0 12				BNE	ERRLOAD		; if checksum incorrect, exit with error
  2307 EDE1 20 5F F2				JSR	TAPE_OK_MSG	; print OK message
  2308 EDE4 20 DF EF		ENDLOAD		JSR	TAPERW_OFF	; return to clock interrupt
  2309 EDE7 4C C1 EF				JMP	MOTOR_OFF	; and turn motor off
  2310
  2311 EDEA 68			BREAKREAD	PLA			; clean up stack
  2312 EDEB 68					PLA
  2313 EDEC 68					PLA
  2314 EDED 20 69 F2		BREAKSYNC	JSR	TAPE_BREAK_MSG	; print BREAK message
  2315 EDF0 4C E4 ED				JMP	ENDLOAD		; and exit
  2316
  2317 EDF3 20 64 F2		ERRLOAD		JSR	TAPE_ERR_MSG	; print error message
  2318 EDF6 4C E4 ED				JMP	ENDLOAD		; end exit
  2319
  2320 				; *** Read Tape Header Routine *************************************************
  2321
  2322 				; ******************************************************************************
  2323
  2324 EDF9 A5 DD		READHEADER	LDA	OUTBYTE		; load current byte
  2325 EDFB C9 A1				CMP	#ADDRMARK	; is it a address mark?
  2326 EDFD D0 5A				BNE	NOHDRMARK	; no, exit
  2327 EDFF A0 00				LDY	#$00		; set string counter to 0
  2328 EE01 84 E1				STY	EQUFLAG		; clear character compare flag
  2329 EE03 A2 06				LDX	#$06		; 6 bytes (start address, end address, reserved) to read
  2330 EE05 20 60 EE		READADDR	JSR	BYTE_IN		; read new address byte
  2331 EE08 A5 DD				LDA	OUTBYTE		; and load it into A
  2332 EE0A 95 F5				STA	NUML-3,X	; store it to pinter location
  2333 EE0C B9 FB F2				LDA	TAPEFND,Y	; load one char of "found" message
  2334 EE0F 20 52 E0				JSR	COUT		; and print it
  2335 EE12 C8					INY			; increment message pointer
  2336 EE13 CA					DEX			; decrement byte read counter
  2337 EE14 D0 EF				BNE	READADDR	; more address bytes to read?
  2338 EE16 20 60 EE				JSR	BYTE_IN		; read next byte
  2339 EE19 A5 DD				LDA	OUTBYTE		; and load it into A
  2340 EE1B C9 A0				CMP	#NAMEMARK	; is it a name mark?
  2341 EE1D D0 22				BNE	READFIRSTBYTE	; no, read first data byte
  2342 EE1F A0 00				LDY	#$00		; reset name string pointer
  2343 EE21 20 60 EE		READNAME	JSR	BYTE_IN		; read name char
  2344 EE24 A5 DD				LDA	OUTBYTE		; load it into A
  2345 EE26 85 E3				STA	IBYTES 		; and save value
  2346 EE28 C9 1F				CMP	#FILEMARK	; is it the file mark?
  2347 EE2A F0 15				BEQ	READFIRSTBYTE	; yes, read first data byte
  2348 EE2C 90 2D				BCC	MARKERROR 	; is character < spac char? yes show error
  2349 EE2E 20 52 E0				JSR	COUT		; no, print current name char
  2350 EE31 B9 00 15				LDA	RBUFF,Y		; load compare char
  2351 EE34 C9 2A				CMP	#'*'		; is it a '*'?
  2352 EE36 F0 E9				BEQ	READNAME	; yes, skip compare
  2353 EE38 C8					INY
  2354 EE39 45 E3				EOR	IBYTES		; is char of search name equal current name?
  2355 EE3B F0 E4				BEQ	READNAME	; yes, read next char
  2356 EE3D 85 E1				STA	EQUFLAG		; no, mark name as not equal
  2357 EE3F D0 E0				BNE	READNAME	; and read next char
  2358
  2359 EE41 A5 E1		READFIRSTBYTE	LDA	EQUFLAG		; is search name equal current name?
  2360 EE43 D0 11				BNE	NAMENEQ		; no, we need to skip the file
  2361 EE45 B9 00 15				LDA	RBUFF,Y
  2362 EE48 C9 2A				CMP	#'*'		; was last char in search name a '*'?
  2363 EE4A F0 05				BEQ	NAMEEQU		; yes, name is equal
  2364 EE4C B9 00 15				LDA	RBUFF,Y		; no, is search name length equal current name length?
  2365 EE4F D0 05				BNE	NAMENEQ		; no, we need to skip the file
  2366 EE51 20 60 EE		NAMEEQU		JSR	BYTE_IN		; yes, read first data Byte
  2367 EE54 38					SEC			; header OK, so set carry flag
  2368 EE55 60					RTS
  2369
  2370 EE56 20 76 F2		NAMENEQ		JSR	TAPE_SKIP_MSG	; print skip message
  2371 EE59 18			NOHDRMARK	CLC			; header not OK, so clear carry flag
  2372 EE5A 60					RTS
  2373
  2374 EE5B 68			MARKERROR	PLA			; clear return address
  2375 EE5C 68					PLA
  2376 EE5D 4C F3 ED				JMP	ERRLOAD		; and jump to error routine
  2377
  2378 				; *** Tape Byte Read Routine ***************************************************
  2379
  2380 				; ******************************************************************************
  2381
  2382 EE60 98			BYTE_IN		TYA			; save Y register
  2383 EE61 48					PHA
  2384 EE62 A0 10				LDY	#PORTB		; select port B register
  2385 EE64 B1 14		READBIT		LDA	(IOBASE),Y	; read port B Bits
  2386 EE66 29 20				AND	#$20		; test tape sense line at PB5
  2387 EE68 D0 80				BNE	BREAKREAD	; play key is no longer down, stop reading
  2388 EE6A A5 ED				LDA	BITCNT		; load bit counter
  2389 EE6C D0 F6				BNE	READBIT		; check again until bit counter = 0
  2390 EE6E A9 08				LDA	#$08
  2391 EE70 85 ED				STA	BITCNT		; reset bit counter
  2392 EE72 68			ENDBYTE_IN	PLA			; yes, restore Y register
  2393 EE73 A8					TAY
  2394 EE74 60					RTS
  2395
  2396 				; *** Tape Save Routine ********************************************************
  2397
  2398 				; ******************************************************************************
  2399
  2400 EE75 20 E7 EF		TAPESAVE	JSR	PREPFILENAME
  2401 EE78 20 7A F2				JSR	TAPE_REC_MSG	; Print press record message
  2402 EE7B 20 85 F2				JSR	TAPE_ESC_MSG
  2403 EE7E 20 5C E1		WAITRECORD	JSR	CHKESC		; <ESC> key pressed?
  2404 EE81 B0 64				BCS	BREAKSAVE	; yes -> exit
  2405 EE83 A5 E5				LDA	KEY_SENSE	; Check if any Datasette key is pressed
  2406 EE85 D0 F7				BNE	WAITRECORD	; No, repeat check
  2407 EE87 20 6E F2				JSR	TAPE_SAVE_MSG	; Print save message
  2408 EE8A 78					SEI			; Yes, disable interrupts
  2409 EE8B 20 83 E0				JSR	STROUT		; Print file name
  2410 EE8E A9 FF				LDA	#$FF
  2411 EE90 8D 94 1A				STA  	CNTA		; Initialize timer value
  2412 EE93 A9 06				LDA	#$06		; Write 6x256 Byte blocks of sync marks
  2413 EE95 20 ED EE				JSR	WRITESYNC	; Write sync marks
  2414 EE98 20 03 EF				JSR	WRITEHEADER	; Write tape header
  2415 EE9B A9 1F				LDA	#FILEMARK
  2416 EE9D 20 22 EF				JSR	BYTE_OUT	; Write file mark
  2417 EEA0 A9 00				LDA	#$00
  2418 EEA2 85 DC				STA	CHECKSUM	; Initialize XOR data checksum
  2419 EEA4 85 E2				STA	BLKNO		; Initialize block numbers
  2420 EEA6 AA					TAX			; Initialize Byte counter
  2421 EEA7 20 22 EF		NEXTBLOCK	JSR	BYTE_OUT	; Write block number to tape
  2422 EEAA A0 10		WRNXTBYTE	LDY	#PORTB
  2423 EEAC B1 14				LDA	(IOBASE),Y	; Read Port B
  2424 EEAE 29 20				AND	#$20		; Test tape sense line at PB5
  2425 EEB0 D0 35				BNE	BREAKSAVE	; No Datasette key pressed. Stop saving
  2426 EEB2 A0 00				LDY	#$00
  2427 EEB4 B1 FA				LDA	(ADRL),Y	; Load current data Byte
  2428 EEB6 A8					TAY			; Save data to Y register
  2429 EEB7 45 DC				EOR	CHECKSUM	; XOR data with checksum
  2430 EEB9 85 DC				STA	CHECKSUM
  2431 EEBB 98					TYA			; Reload data into Accumulator
  2432 EEBC 20 22 EF				JSR	BYTE_OUT	; Write data Byte to tape
  2433 EEBF 20 4C E7				JSR	CMPADDR		; See if there's more to copy
  2434 EEC2 B0 12		                BCS  	ENDDATA  	; No more data to copy
  2435 EEC4 20 7F E9				JSR	INCADR		; Increment current save address
  2436 EEC7 E8					INX			; Increment Byte counter
  2437 EEC8 D0 E0				BNE	WRNXTBYTE	; If less than 256 Bytes written, then write next data Byte
  2438 EECA A5 DC		ENDBLOCK	LDA	CHECKSUM	; Else...
  2439 EECC 20 22 EF				JSR	BYTE_OUT	; Write checksum at the end of block
  2440 EECF E6 E2				INC	BLKNO		; Increment block number
  2441 EED1 A5 E2				LDA	BLKNO
  2442 EED3 4C A7 EE				JMP	NEXTBLOCK	; Write next block
  2443 EED6 A5 DC		ENDDATA		LDA	CHECKSUM
  2444 EED8 20 22 EF				JSR	BYTE_OUT	; Write checksum at end of block
  2445 EEDB A9 03				LDA	#$03
  2446 EEDD 20 22 EF				JSR	BYTE_OUT	; Write End-Of-Text mark
  2447 EEE0 20 5F F2				JSR	TAPE_OK_MSG	; Print OK message
  2448 EEE3 58			ENDSAVE		CLI			; Reenable interrupts
  2449 EEE4 4C C1 EF				JMP	MOTOR_OFF	; Stop motor
  2450
  2451 				; ******************************************************************************
  2452
  2453 EEE7 20 69 F2		BREAKSAVE	JSR	TAPE_BREAK_MSG	; Print Break message
  2454 EEEA 4C E3 EE				JMP	ENDSAVE
  2455
  2456 				; **** Write Synchronization Bytes To Tape *************************************
  2457
  2458 				; ******************************************************************************
  2459
  2460 EEED 85 E9		WRITESYNC	STA	STOH
  2461 EEEF A9 00				LDA	#$00
  2462 EEF1 85 E8				STA	STOL
  2463 EEF3 A9 2E				LDA	#SYNCMARK	; Load sync mark
  2464 EEF5 85 DD				STA	OUTBYTE		; and store it to output variable
  2465 EEF7 20 24 EF		PLOOP		JSR	WRITEBYTE	; Write sync mark
  2466 EEFA C6 E8				DEC	STOL		; Decrement loop counter
  2467 EEFC D0 F9				BNE	PLOOP		; Repeat loop if counter low byte > 0
  2468 EEFE C6 E9				DEC	STOH		; Overflow, decrement counter high byte
  2469 EF00 D0 F5				BNE	PLOOP		; Repeat loop if counter high byte > 0
  2470 EF02 60			ENDPREAMBLE	RTS
  2471
  2472 				; **** Write File Header To Tape ***********************************************
  2473
  2474 				; ******************************************************************************
  2475
  2476 EF03 A2 06		WRITEHEADER	LDX	#$06
  2477 EF05 A9 A1				LDA	#ADDRMARK	; load address mark
  2478 EF07 20 22 EF		WRITEADDR	JSR	BYTE_OUT	; write to tape
  2479 EF0A B5 F5				LDA	NUML-3,X	; load address byte
  2480 EF0C CA					DEX
  2481 EF0D 10 F8				BPL	WRITEADDR	; all address fields written? no repeat
  2482 EF0F A9 A0				LDA	#NAMEMARK	; yes, load name mark
  2483 EF11 20 22 EF				JSR	BYTE_OUT	; and write it to tape
  2484 EF14 A0 00				LDY	#$00		; index to first filename char
  2485 EF16 B9 00 15		WRNXTCHAR	LDA	RBUFF,Y		; load filename char
  2486 EF19 F0 06				BEQ	ENDHEADER	; is it a NULL? yes -> exit
  2487 EF1B 20 22 EF				JSR	BYTE_OUT	; no write filename char to tape
  2488 EF1E C8					INY			; increment index to next filename char
  2489 EF1F D0 F5				BNE	WRNXTCHAR	; and write it
  2490 EF21 60			ENDHEADER	RTS
  2491
  2492 				; **** Write Tape Byte Routine *************************************************
  2493
  2494 				; ******************************************************************************
  2495
  2496 EF22 85 DD		BYTE_OUT	STA	OUTBYTE		; save output byte
  2497 EF24 8A			WRITEBYTE	TXA			; save X register
  2498 EF25 48					PHA
  2499 EF26 98					TYA			; save Y register
  2500 EF27 48					PHA
  2501 EF28 2C 9F 1A		WAIT_BIT1	BIT  	CNTIRQ		; timer counted to zero
  2502 EF2B 10 FB				BPL  	WAIT_BIT1	; no, repeat test
  2503 EF2D A2 08				LDX	#8		; initialize bit counter
  2504 EF2F A0 10		NEXT_BIT	LDY	#PORTB
  2505 EF31 A9 10				LDA	#%00010000	; set CAS_WR output HIGH
  2506 EF33 05 E4				ORA	VIA_STATUS	; get old output status and set CAS_WR Pin
  2507 EF35 91 14				STA	(IOBASE),Y
  2508 EF37 26 DD				ROL	OUTBYTE		; rotate next output bit to carry flag
  2509 EF39 90 04				BCC	SET_SHORT	; if carry = 0 then write short pulse
  2510 EF3B A0 BE		SET_LONG	LDY	#LPTIME		; else write long pulse
  2511 EF3D D0 02				BNE	WRITE_BIT
  2512 EF3F A0 3C		SET_SHORT	LDY	#SPTIME		; set short pulse value
  2513 EF41 84 FD		WRITE_BIT	STY	YSAV		; save pulse width value for low phase
  2514 EF43 20 53 E1				JSR	SHORTDELAY1	; high phase delay
  2515 EF46 A0 10				LDY	#PORTB		; index to port B
  2516 EF48 A9 EF				LDA	#%11101111	; set CAS_WR output LOW
  2517 EF4A 25 E4				AND	VIA_STATUS	; get old output status and clear CAS_WR pin
  2518 EF4C 91 14				STA	(IOBASE),Y
  2519 EF4E A4 FD				LDY	YSAV		; restore delay value for low phase of pulse
  2520 EF50 CA					DEX
  2521 EF51 F0 06				BEQ	ENDWRITE	; all bits done? yes, exit routine
  2522 EF53 20 53 E1				JSR	SHORTDELAY1	; low phase delay
  2523 EF56 4C 2F EF				JMP	NEXT_BIT	; continue bit send loop
  2524 EF59 8C 94 1A		ENDWRITE	STY  	CNTA		; set timer for final low phase
  2525 EF5C 26 DD				ROL	OUTBYTE		; rotate one bit to restore old Byte value
  2526 EF5E 68					PLA
  2527 EF5F A8					TAY			; restore Y register
  2528 EF60 68					PLA
  2529 EF61 AA					TAX			; restore X register
  2530 EF62 60					RTS
  2531
  2532 				; **** VIA2 IRQ Routine ********************************************************
  2533
  2534 				; ******************************************************************************
  2535
  2536 EF63 48			TAPEIRQ		PHA			; save accumulator
  2537 EF64 98					TYA
  2538 EF65 48					PHA			; save Y register
  2539 EF66 A0 1D				LDY	#IFR		; select interrupt flag register
  2540 EF68 B1 14				LDA	(IOBASE),Y
  2541 EF6A 10 27				BPL	NOTAPEIRQ	; check if it was a VIA2 interrupt
  2542 EF6C 29 02				AND	#$02		; yes, CA1 interrupt occured?
  2543 EF6E F0 13				BEQ	CHECKKEY	; no, check key status
  2544 EF70 C6 ED		CHECKBIT	DEC	BITCNT		; decrement bit counter
  2545 EF72 A0 11				LDY	#PORTA
  2546 EF74 B1 14				LDA	(IOBASE),Y	; clear CA1 interrupt flag
  2547 EF76 AD 9F 1A				LDA	CNTIRQ		; load timer IRQ status
  2548 EF79 0A					ASL			; and shift it into the carry flag
  2549 EF7A 26 DD				ROL	OUTBYTE		; save carry as current bit value
  2550 EF7C A9 31				LDA	#RPTIME
  2551 EF7E 8D 95 1A				STA	CNTB		; set timer to Read-Point-Time
  2552 EF81 D0 0C				BNE	ENDTAPEIRQ	; and exit IRQ routine
  2553 EF83 20 A5 EF		CHECKKEY	JSR	CHECK_KEYSIG	; check tape sense line
  2554 EF86 20 99 EF				JSR	RESET_TIMER2	; reset Timer2 and interrupt flags
  2555 EF89 A5 DA				LDA     TICKCNT         ; load the tick counter
  2556 EF8B F0 02				BEQ     ENDTAPEIRQ      ; is it 0?
  2557 EF8D C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  2558 EF8F 68			ENDTAPEIRQ	PLA
  2559 EF90 A8					TAY			; restore Y register
  2560 EF91 68					PLA			; restore accumulator
  2561 EF92 40					RTI
  2562
  2563 EF93 68			NOTAPEIRQ	PLA
  2564 EF94 A8					TAY			; restore Y register
  2565 EF95 68				        PLA			; restore accumulator
  2566 EF96 4C 18 F3		USRIRQ		JMP	IRQ		; call user interrupt routine
  2567
  2568 				; **** Reset Timer2 Routine ****************************************************
  2569
  2570 				; ******************************************************************************
  2571
  2572 EF99 A0 18		RESET_TIMER2	LDY	#T2CL		; select Timer2 lower byte register
  2573 EF9B A9 4B				LDA	#$4B		; reset Timer2
  2574 EF9D 91 14				STA	(IOBASE),Y	; store timer low value
  2575 EF9F A9 41				LDA	#$41
  2576 EFA1 C8					INY			; select Timer2 higher byte register
  2577 EFA2 91 14				STA	(IOBASE),Y	; store timer high value
  2578 EFA4 60					RTS
  2579
  2580 				; **** Check Tape Sense Line Routine *******************************************
  2581
  2582 				; ******************************************************************************
  2583
  2584 EFA5 A0 10		CHECK_KEYSIG	LDY	#PORTB
  2585 EFA7 B1 14				LDA	(IOBASE),Y
  2586 EFA9 29 20				AND	#$20		; test tape sense line at PB5
  2587 EFAB C5 E5				CMP	KEY_SENSE	; is it different to old tape sense line status?
  2588 EFAD F0 06				BEQ	ENDCHECK	; no, just return
  2589 EFAF 85 E5		 		STA	KEY_SENSE	; yes, save new state value
  2590 EFB1 B0 0E				BCS	MOTOR_OFF
  2591 EFB3 90 01				BCC	MOTOR_ON
  2592 EFB5 60			ENDCHECK	RTS
  2593
  2594 				; **** Turn Tape Drive Motor On ************************************************
  2595
  2596 				; ******************************************************************************
  2597
  2598 EFB6 A0 10		MOTOR_ON	LDY	#PORTB
  2599 EFB8 A9 BF				LDA	#%10111111	; set CAS_MOT line low
  2600 EFBA 25 E4				AND	VIA_STATUS
  2601 EFBC 85 E4				STA	VIA_STATUS
  2602 EFBE 91 14				STA	(IOBASE),Y
  2603 EFC0 60					RTS
  2604
  2605 				; **** Turn Tape Drive Motor Off ***********************************************
  2606
  2607 				; ******************************************************************************
  2608
  2609 EFC1 A0 10		MOTOR_OFF	LDY	#PORTB
  2610 EFC3 A9 40				LDA	#%01000000	; set CAS_MOT line high
  2611 EFC5 05 E4				ORA	VIA_STATUS
  2612 EFC7 85 E4				STA	VIA_STATUS
  2613 EFC9 91 14				STA	(IOBASE),Y
  2614 EFCB 60					RTS
  2615
  2616 				; **** Tape IRQ Off ************************************************************
  2617
  2618 				; ******************************************************************************
  2619
  2620 EFCC A0 1E		TAPEIRQ_OFF     LDY	#IER		; select interrupt enable register
  2621 EFCE A5 15		                LDA     IOBASEH
  2622 EFD0 F0 04		                BEQ     TAPEIRQ_OFF1    ; IO card available? No, just exit
  2623 EFD2 A9 7F				LDA	#$7F
  2624 EFD4 91 14				STA	(IOBASE),Y	; disable all VIA2 interrupts
  2625 EFD6 60			TAPEIRQ_OFF1	RTS
  2626
  2627 				; **** Turn Tape Read/Write Mode On ********************************************
  2628
  2629 				; ******************************************************************************
  2630
  2631 EFD7 20 CC EF		TAPERW_ON	JSR	TAPEIRQ_OFF
  2632 EFDA A9 82				LDA	#$82
  2633 EFDC 91 14				STA	(IOBASE),Y	; set interrupt for CA1
  2634 EFDE 60					RTS
  2635
  2636 				; **** Turn Tape Read/Write Mode Off *******************************************
  2637
  2638 				; ******************************************************************************
  2639
  2640 EFDF 20 CC EF		TAPERW_OFF	JSR	TAPEIRQ_OFF
  2641 EFE2 A9 A0				LDA	#$A0
  2642 EFE4 91 14				STA	(IOBASE),Y	; set interrupt for Timer2
  2643 EFE6 60					RTS
  2644
  2645 				; **** Prepare Filename ********************************************************
  2646
  2647 				; Input: X - low byte of string pointer
  2648 				;	 Y - high byte of string pointer
  2649
  2650 				; ******************************************************************************
  2651
  2652 EFE7 20 48 E1		PREPFILENAME	JSR	SETSTRBUFF0
  2653 EFEA A0 00				LDY	#$00
  2654 EFEC A2 00				LDX	#$00
  2655 EFEE B1 EA		NEXTFNCHAR	LDA  	(PSTR),Y   	; get next input char
  2656 EFF0 F0 11				BEQ	ENDFILENAME
  2657 EFF2 C9 61				CMP	#'a'		; char < 'a'?
  2658 EFF4 90 06				BCC	COPYNAME	; no, just copy char to buffer
  2659 EFF6 C9 7B				CMP	#'{'		; char > 'z'?
  2660 EFF8 B0 02				BCS	COPYNAME	; no, just copy char to buffer
  2661 EFFA 29 DF				AND	#$DF		; convert to upper case char
  2662 EFFC 9D 00 15		COPYNAME	STA	RBUFF,X		; char to buffer
  2663 EFFF C8					INY
  2664 F000 E8					INX
  2665 F001 D0 EB				BNE	NEXTFNCHAR	; read next char of filename
  2666 F003 E0 00		ENDFILENAME	CPX	#$00
  2667 F005 D0 07				BNE	ENDPREP		; is X = 0? no -> exit
  2668 F007 A9 2A				LDA	#'*'		; yes, empty string.
  2669 F009 9D 00 15				STA	RBUFF,X		; make it "*"
  2670 F00C E8					INX
  2671 F00D 98					TYA
  2672 F00E 9D 00 15		ENDPREP		STA	RBUFF,X		; terminate string with NULL
  2673 F011 20 44 E1				JSR	SETSTRBUFF	;
  2674 F014 60					RTS
  2675
  2676 				; ******************************************************************************
  2677 				; START OF XMODEM CODE
  2678 				; ******************************************************************************
  2679 				;
  2680 				; XMODEM/CRC Sender/Receiver for the 6502
  2681 				;
  2682 				; By Daryl Rictor Aug 2002
  2683 				;
  2684 				; A simple file transfer program to allow transfers between the SBC and a
  2685 				; console device utilizing the x-modem/CRC transfer protocol.
  2686 				;
  2687 				;*******************************************************************************
  2688 				; This implementation of XMODEM/CRC does NOT conform strictly to the
  2689 				; XMODEM protocol standard in that it (1) does not accurately time character
  2690 				; reception or (2) fall back to the Checksum mode.
  2691
  2692 				; (1) For timing, it uses a crude timing loop to provide approximate
  2693 				; delays.  These have been calibrated against a 1MHz CPU clock.  I have
  2694 				; found that CPU clock speed of up to 5MHz also work but may not in
  2695 				; every case.  Windows HyperTerminal worked quite well at both speeds!
  2696 				;
  2697 				; (2) Most modern terminal programs support XMODEM/CRC which can detect a
  2698 				; wider range of transmission errors so the fallback to the simple checksum
  2699 				; calculation was not implemented to save space.
  2700 				;*******************************************************************************
  2701 				;
  2702 				; Files transferred via XMODEM-CRC will have the load address contained in
  2703 				; the first two bytes in little-endian format:
  2704 				;  FIRST BLOCK
  2705 				;     offset(0) = lo(load start address),
  2706 				;     offset(1) = hi(load start address)
  2707 				;     offset(2) = data byte (0)
  2708 				;     offset(n) = data byte (n-2)
  2709 				;
  2710 				; Subsequent blocks
  2711 				;     offset(n) = data byte (n)
  2712 				;
  2713 				; One note, XMODEM send 128 byte blocks.  If the block of memory that
  2714 				; you wish to save is smaller than the 128 byte block boundary, then
  2715 				; the last block will be padded with zeros.  Upon reloading, the
  2716 				; data will be written back to the original location.  In addition, the
  2717 				; padded zeros WILL also be written into RAM, which could overwrite other
  2718 				; data.
  2719 				;
  2720 				;*******************************************************************************
  2721 				;
  2722 				; Code extensions 2022 by Joerg Walke
  2723 				;
  2724 				; Included: CAN command in addition to ESC to cancel sending and receiving data.
  2725 				; Included: EOT command to signal end of transmition.
  2726 				; Included: address range for received data, to override the start address in
  2727 				;           the first data block and to prevent overwriting of data by
  2728 				;	    trailing zeros.
  2729
  2730 				; XMODEM Receive Routine *******************************************************
  2731
  2732 F015 20 39 F2		XModemRcv       JSR     PrintXStart
  2733 F018 85 E0				STA	BLKEND		; set flag to false
  2734 F01A A9 01		                LDA     #$01
  2735 F01C 85 E2		                STA     BLKNO           ; set block # to 1
  2736 F01E 85 E1		                STA	BFLAG           ; set flag to get address from block 1
  2737 F020 A9 43		StartRcv        LDA     #'C'            ; "C" start with CRC mode
  2738 F022 20 65 F3		                JSR     SOUT	     	; send it
  2739 F025 A9 FF		                LDA     #$FF
  2740 F027 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2741 F029 A9 00		                LDA     #$00
  2742 F02B 85 DC		                STA     CRCL
  2743 F02D 85 DD		                STA     CRCH            ; init CRC value
  2744 F02F 20 E2 F1		                JSR     GetByte         ; wait for input
  2745 F032 B0 0C				BCS     GotByte         ; byte received, process it
  2746 F034 4C 20 F0				JMP     StartRcv
  2747 F037 A9 FF		StartBlk        LDA     #$FF
  2748 F039 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2749 F03B 20 E2 F1		                JSR     GetByte         ; get first byte of block
  2750 F03E 90 F7		                BCC     StartBlk        ; timed out, keep waiting...
  2751 F040 C9 1B		GotByte         CMP     #ESC            ; quitting?
  2752 F042 F0 04		                BEQ     GotESC          ; yes
  2753 F044 C9 18				CMP	#CAN		; cancel?
  2754 F046 D0 03				BNE     GotByte1	; no
  2755 F048 4C 41 F2		GotESC          JMP     PrintXErr       ; print error and return
  2756 F04B C9 01		GotByte1        CMP     #SOH            ; start of block?
  2757 F04D F0 07		                BEQ     BegBlk          ; yes
  2758 F04F C9 04		                CMP     #EOT            ;
  2759 F051 D0 45		                BNE     BadCRC          ; Not SOH or EOT, so flush buffer & send NAK
  2760 F053 4C FB F0		                JMP     RDone           ; EOT - all done!
  2761 F056 A2 00		BegBlk          LDX     #$00
  2762 F058 A9 FF		GetBlk          LDA     #$FF            ; 3 sec window to receive characters
  2763 F05A 85 DF		                STA     RETRYH
  2764 F05C 20 CF F1		GetBlk1         JSR     GetData         ; get next character
  2765 F05F 90 37		                BCC     BadCRC          ; chr rcv error, flush and send NAK
  2766 F061 9D 00 15		GetBlk2         STA     RBUFF,x         ; good char, save it in the rcv buffer
  2767 F064 E8			                INX                     ; inc buffer pointer
  2768 F065 E0 84		                CPX     #$84            ; <01> <FE> <128 bytes> <CRCH> <CRCL>
  2769 F067 D0 EF		                BNE     GetBlk          ; get 132 characters
  2770 F069 A2 00		                LDX     #$00
  2771 F06B BD 00 15		                LDA     RBUFF,x         ; get block # from buffer
  2772 F06E C5 E2		                CMP     BLKNO           ; compare to expected block #
  2773 F070 F0 06		                BEQ     GoodBlk1        ; matched!
  2774 F072 20 41 F2		                jsr     PrintXErr       ; Unexpected block number - abort
  2775 F075 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2776 F078 49 FF		GoodBlk1        EOR     #$FF            ; 1's comp of block #
  2777 F07A E8			                INX                     ;
  2778 F07B DD 00 15		                CMP     RBUFF,x         ; compare with expected 1's comp of block #
  2779 F07E F0 06		                BEQ     GoodBlk2        ; matched!
  2780 F080 20 41 F2		                JSR     PrintXErr       ; Unexpected block number - abort
  2781 F083 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2782 F086 20 19 F2		GoodBlk2        JSR     CalcCRC         ; calc CRC
  2783 F089 B9 00 15		                LDA     RBUFF,y         ; get hi CRC from buffer
  2784 F08C C5 DD		                CMP     CRCH            ; compare to calculated hi CRC
  2785 F08E D0 08		                BNE     BadCRC          ; bad crc, send NAK
  2786 F090 C8			                INY                     ;
  2787 F091 B9 00 15		                LDA     RBUFF,y         ; get lo CRC from buffer
  2788 F094 C5 DC		                CMP     CRCL            ; compare to calculated lo CRC
  2789 F096 F0 0B		                BEQ     GoodCRC         ; good CRC
  2790 F098 20 0F F2		BadCRC          JSR     Flush           ; flush the input port
  2791 F09B A9 15		                LDA     #NAK            ;
  2792 F09D 20 65 F3		                JSR     SOUT            ; send NAK to resend block
  2793 F0A0 4C 37 F0		                JMP     StartBlk        ; start over, get the block again
  2794 F0A3 A2 02		GoodCRC         LDX     #$02            ;
  2795 F0A5 A5 E2		                LDA     BLKNO           ; get the block number
  2796 F0A7 C9 01		                CMP     #$01            ; 1st block?
  2797 F0A9 D0 21		                BNE     CopyBlk         ; no, copy all 128 bytes
  2798 F0AB A5 E1		                LDA     BFLAG           ; is it really block 1, not block 257, 513 etc.
  2799 F0AD F0 1D		                BEQ     CopyBlk         ; no, copy all 128 bytes
  2800 F0AF A5 FF				LDA     MODE		; address mode = 0?
  2801 F0B1 F0 03				BEQ	READADR         ; yes, read start address from data stream
  2802 F0B3 E8			                INX
  2803 F0B4 D0 0B				BNE     READDATA	; branch always
  2804 F0B6 BD 00 15		READADR         LDA     RBUFF,x         ; get target address from 1st 2 bytes of blk 1
  2805 F0B9 85 FA				STA     ADRL            ; save lo address
  2806 F0BB E8			                INX
  2807 F0BC BD 00 15		                LDA     RBUFF,x         ; get hi address
  2808 F0BF 85 FB		                STA     ADRH            ; save it
  2809 F0C1 A5 FA		READDATA        LDA	ADRL
  2810 F0C3 85 E8				STA	STOL		; save start address low byte
  2811 F0C5 A5 FB				LDA	ADRH
  2812 F0C7 85 E9				STA	STOH		; save start address high byte
  2813 F0C9 E8					INX                     ; point to first byte of data
  2814 F0CA C6 E1		                DEC     BFLAG           ; set the flag so we won't get another address
  2815 F0CC A0 00		CopyBlk         LDY     #$00            ; set offset to zero
  2816 F0CE A5 E0		CopyBlk3        LDA     BLKEND		; block end flag set?
  2817 F0D0 D0 14				BNE     CopyBlk5	; yes, skip reading data
  2818 F0D2 BD 00 15				LDA     RBUFF,x         ; get data byte from buffer
  2819 F0D5 91 E8				STA     (STOL),y        ; save to target
  2820 F0D7 38					SEC
  2821 F0D8 A5 F8		                LDA     NUML
  2822 F0DA E5 E8		                SBC     STOL            ; are we at the last address?
  2823 F0DC D0 08		                BNE     CopyBlk5  	; no, inc pointer and continue
  2824 F0DE A5 F9		                LDA     NUMH
  2825 F0E0 E5 E9		                SBC     STOH
  2826 F0E2 D0 02		                BNE     CopyBlk5
  2827 F0E4 E6 E0		                INC     BLKEND		; yes, set last byte flag
  2828 F0E6 E6 E8		CopyBlk5	INC     STOL            ; point to next address
  2829 F0E8 D0 02		                BNE     CopyBlk4        ; did it step over page boundary?
  2830 F0EA E6 E9		                INC     STOH            ; adjust high address for page crossing
  2831 F0EC E8			CopyBlk4        INX                     ; point to next data byte
  2832 F0ED E0 82		                CPX     #$82            ; is it the last byte
  2833 F0EF D0 DD		                BNE     CopyBlk3        ; no, get the next one
  2834 F0F1 E6 E2		IncBlk          INC     BLKNO           ; done.  Inc the block #
  2835 F0F3 A9 06		                LDA     #ACK            ; send ACK
  2836 F0F5 20 65 F3		                JSR     SOUT
  2837 F0F8 4C 37 F0		                JMP     StartBlk        ; get next block
  2838 F0FB A9 06		RDone           LDA     #ACK            ; last block, send ACK and exit.
  2839 F0FD 20 65 F3		                JSR     SOUT
  2840 F100 20 0F F2		                JSR     Flush           ; get leftover characters, if any
  2841 F103 4C 49 F2		                JMP     PrintXSucc
  2842
  2843 				; XMODEM Send Routine **********************************************************
  2844
  2845 F106 20 39 F2		XModemSnd       JSR     PrintXStart
  2846 F109 85 E3				STA     ERRCNT          ; error counter set to 0
  2847 F10B 85 E0				STA     BLKEND          ; set flag to false
  2848 F10D A9 01				LDA     #$01
  2849 F10F 85 E2		                STA     BLKNO           ; set block # to 1
  2850 F111 A9 FF		Wait4CRC        LDA     #$FF            ; 3 seconds
  2851 F113 85 DF		                STA     RETRYH
  2852 F115 20 E2 F1		                JSR     GetByte
  2853 F118 90 F7		                BCC     Wait4CRC        ; wait for something to come in...
  2854 F11A C9 43		                CMP     #'C'            ; is it the "C" to start a CRC xfer?
  2855 F11C F0 0B		                BEQ     SetStoAddr      ; yes
  2856 F11E C9 1B		                CMP     #ESC            ; is it a cancel? <Esc> Key
  2857 F120 F0 04		                BEQ     DoCancel        ; No, wait for another character
  2858 F122 C9 18				CMP     #CAN            ; is it a cancel?
  2859 F124 D0 EB		                BNE     Wait4CRC        ; No, wait for another character
  2860 F126 4C C6 F1		DoCancel        JMP     PrtAbort        ; Print abort msg and exit
  2861 F129 A9 01		SetStoAddr	LDA     #$01            ; manually load blk number
  2862 F12B 8D 00 15		                STA     RBUFF           ; into 1st byte
  2863 F12E A9 FE		                LDA     #$FE            ; load 1's comp of block #
  2864 F130 8D 01 15		                STA     RBUFF+1         ; into 2nd byte
  2865 F133 A5 FA		                LDA     ADRL            ; load low byte of start address
  2866 F135 8D 02 15		                STA     RBUFF+2         ; into 3rd byte
  2867 F138 A5 FB		                LDA     ADRH            ; load hi byte of start address
  2868 F13A 8D 03 15		                STA     RBUFF+3         ; into 4th byte
  2869 F13D A2 04				LDX     #$04            ; preload X to receive buffer
  2870 F13F A0 00				LDY     #$00            ; init data block offset to 0
  2871 F141 F0 17		                BEQ     LdBuff1         ; jump into buffer load routine
  2872 F143 A5 E0		LdBuffer        LDA     BLKEND          ; was the last block sent?
  2873 F145 F0 03		                BEQ     LdBuff0         ; no, send the next one
  2874 F147 4C CC F1		                JMP     SDone           ; yes, we're done
  2875 F14A A2 02		LdBuff0         LDX     #$02            ; init pointers
  2876 F14C A0 00		                LDY     #$00
  2877 F14E E6 E2		                INC     BLKNO           ; inc block counter
  2878 F150 A5 E2		                LDA     BLKNO
  2879 F152 8D 00 15		                STA     RBUFF           ; save in 1st byte of buffer
  2880 F155 49 FF		                EOR     #$FF
  2881 F157 8D 01 15		                STA     RBUFF+1         ; save 1's comp of blkno next
  2882 F15A B1 FA		LdBuff1         LDA     (ADRL),y        ; save 128 bytes of data
  2883 F15C 9D 00 15		                STA     RBUFF,x
  2884 F15F 38			LdBuff2         SEC
  2885 F160 A5 F8		                LDA     NUML
  2886 F162 E5 FA		                SBC     ADRL            ; are we at the last address?
  2887 F164 D0 14		                BNE     LdBuff4         ; no, inc pointer and continue
  2888 F166 A5 F9		                LDA     NUMH
  2889 F168 E5 FB		                SBC     ADRH
  2890 F16A D0 0E		                BNE     LdBuff4
  2891 F16C E6 E0		                INC     BLKEND          ; yes, set last byte flag
  2892 F16E E8			LdBuff3         INX
  2893 F16F E0 82		                CPX     #$82            ; are we at the end of the 128 byte block?
  2894 F171 F0 12		                BEQ     SCalcCRC        ; yes, calc CRC
  2895 F173 A9 00		                LDA     #$00            ; fill rest of 128 bytes with $00
  2896 F175 9D 00 15		                STA     RBUFF,x
  2897 F178 F0 F4		                BEQ     LdBuff3         ; branch always
  2898 F17A E6 FA		LdBuff4         INC     ADRL            ; inc address pointer
  2899 F17C D0 02		                BNE     LdBuff5
  2900 F17E E6 FB		                INC     ADRH
  2901 F180 E8			LdBuff5         INX
  2902 F181 E0 82		                CPX     #$82            ; last byte in block?
  2903 F183 D0 D5		                BNE     LdBuff1         ; no, get the next
  2904 F185 20 19 F2		SCalcCRC        JSR     CalcCRC
  2905 F188 A5 DD		                LDA     CRCH            ; save hi byte of CRC to buffer
  2906 F18A 99 00 15		                STA     RBUFF,y
  2907 F18D C8			                INY
  2908 F18E A5 DC		                LDA     CRCL            ; save lo byte of CRC to buffer
  2909 F190 99 00 15		                STA     RBUFF,y
  2910 F193 A2 00		Resend          LDX     #$00
  2911 F195 A9 01		                LDA     #SOH
  2912 F197 20 65 F3		                JSR     SOUT            ; send SOH
  2913 F19A BD 00 15		SendBlk         LDA     RBUFF,x         ; send 132 bytes in buffer to the console
  2914 F19D 20 65 F3		                JSR     SOUT
  2915 F1A0 E8			                INX
  2916 F1A1 E0 84		                CPX     #$84            ; last byte?
  2917 F1A3 D0 F5		                BNE     SendBlk         ; no, get next
  2918 F1A5 A9 FF		                LDA     #$FF            ; yes, set 3 second delay
  2919 F1A7 85 DF		                STA     RETRYH          ; and
  2920 F1A9 20 E2 F1		                JSR     GetByte         ; wait for ACK/NACK
  2921 F1AC 90 10		                BCC     SetError        ; no char received after 3 seconds, resend
  2922 F1AE C9 06		                CMP     #ACK            ; char received... is it:
  2923 F1B0 F0 91		                BEQ     LdBuffer        ; ACK, send next block
  2924 F1B2 C9 15		                CMP     #NAK
  2925 F1B4 F0 08		                BEQ     SetError        ; NAK, inc errors and resend
  2926 F1B6 C9 1B		                CMP     #ESC
  2927 F1B8 F0 0C		                BEQ     PrtAbort        ; ESC pressed to abort
  2928 F1BA C9 18				CMP	#CAN
  2929 F1BC F0 08				BEQ     PrtAbort	; CANCEL send
  2930 									; fall through to error counter
  2931 F1BE E6 E3		SetError        INC     ERRCNT          ; inc error counter
  2932 F1C0 A5 E3		                LDA     ERRCNT
  2933 F1C2 C9 0A		                CMP     #$0A            ; are there 10 errors? (Xmodem spec for failure)
  2934 F1C4 D0 CD		                BNE     Resend          ; no, resend block
  2935
  2936 F1C6 20 0F F2		PrtAbort        JSR     Flush           ; yes, too many errors, flush buffer,
  2937 F1C9 4C 41 F2		                JMP     PrintXErr       ; print error msg and exit
  2938 F1CC 4C 49 F2		SDone           JMP     PrintXSucc   	; All Done..Print msg and exit
  2939
  2940 				; Get Data From Serial Port ****************************************************
  2941
  2942 F1CF A9 00		GetData		LDA     #$00            ; wait for chr input and cycle timing loop
  2943 F1D1 85 DE		                STA     RETRYL          ; set low value of timing loop
  2944 F1D3 20 75 F3		LoopGetData     JSR     SIN        	; get chr from serial port, don't wait
  2945 F1D6 B0 09		                BCS     EndGetData      ; got one, so exit
  2946 F1D8 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2947 F1DA D0 F7		                BNE     LoopGetData
  2948 F1DC C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2949 F1DE D0 F3		                BNE     LoopGetData     ; look for character again
  2950 F1E0 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2951 F1E1 60			EndGetData      RTS                     ; with character in A
  2952
  2953 				; Get Byte From Serial Port. Check if ESC pressed ******************************
  2954
  2955 F1E2 A9 00		GetByte		LDA     #$00            ; wait for chr input and cycle timing loop
  2956 F1E4 85 DE		                STA     RETRYL          ; set low value of timing loop
  2957 F1E6 A9 75		LoopGetByte     LDA     #< SIN        ; check low byte of serial in address
  2958 F1E8 CD 6E 1A				CMP	STDIN	        ; is Low(stdin) = Low(SIN)?
  2959 F1EB D0 07		                BNE     GetChar         ; no, use standard Get Char Routine
  2960 F1ED A9 F3		                LDA     #> SIN       ; yes, check high byte of serial in address
  2961 F1EF CD 6F 1A		                CMP     STDIN+1         ; is High(stdin) = High(SIN)?
  2962 F1F2 F0 0C		                BEQ	ReadByte	; yes, just read input stream
  2963 F1F4 20 4D E0		GetChar		JSR	CGET
  2964 F1F7 90 07				BCC	ReadByte
  2965 F1F9 C9 1B				CMP	#ESC
  2966 F1FB D0 03				BNE	ReadByte
  2967 F1FD 38					SEC
  2968 F1FE B0 0E				BCS	EndGetByte
  2969 				;		JSR	CHKESC		; no, check stdin if ESC key pressed
  2970 				;		BCC	ReadByte	; no ESC pressed, read data byte from serial port
  2971 				;		LDA	#ESC
  2972 				;		BNE     EndGetByte      ; ESC pressed, so exit
  2973 F200 20 75 F3		ReadByte	JSR     SIN        	; get chr from serial port, don't wait
  2974 F203 B0 09		                BCS     EndGetByte      ; got one, so exit
  2975 F205 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2976 F207 D0 DD		                BNE     LoopGetByte
  2977 F209 C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2978 F20B D0 D9		                BNE     LoopGetByte     ; look for character again
  2979 F20D 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2980 F20E 60			EndGetByte      RTS                     ; with character in A
  2981
  2982 				; Empty Buffer *****************************************************************
  2983
  2984 F20F A9 1C		Flush           LDA     #$1C            ; flush receive buffer
  2985 F211 85 DF		                STA     RETRYH          ; flush until empty for ~1/4 sec.
  2986 F213 20 CF F1		Flush1          JSR     GetData         ; read the port
  2987 F216 B0 F7		                BCS     Flush           ; if char received, wait for another
  2988 F218 60			                RTS
  2989
  2990 				; Calculate CRC ****************************************************************
  2991
  2992 F219 A9 00		CalcCRC		LDA	#$00		; calculate the CRC for the 128 bytes
  2993 F21B 85 DC				STA	CRCL
  2994 F21D 85 DD				STA	CRCH
  2995 F21F A0 02				LDY	#$02
  2996 F221 B9 00 15		CalcCRC1	LDA	RBUFF,y
  2997 F224 45 DD				EOR 	CRCH 		; Quick CRC computation with lookup tables
  2998 F226 AA			       		TAX		 	; updates the two bytes at crc & crc+1
  2999 F227 A5 DC		       		LDA 	CRCL		; with the byte send in the "A" register
  3000 F229 5D 00 FB		       		EOR 	CRCHI,x
  3001 F22C 85 DD		       		STA 	CRCH
  3002 F22E BD 00 FA		      	 	LDA 	CRCLO,x
  3003 F231 85 DC		       		STA 	CRCL
  3004 F233 C8					INY
  3005 F234 C0 82				CPY	#$82		; done yet?
  3006 F236 D0 E9				BNE	CalcCRC1	; no, get next
  3007 F238 60					RTS			; y=82 on exit
  3008
  3009 				; Print XModem Messages ********************************************************
  3010
  3011 F239 78			PrintXStart     SEI			; disable interrupts during XModem transfer
  3012 F23A 20 0F F2				JSR	Flush		; clear buffer
  3013 F23D A0 00				LDY     #$00		; load start message
  3014 F23F F0 0C				BEQ	PrintXMsg
  3015
  3016 F241 20 67 E1		PrintXErr       JSR	BEEP
  3017 F244 A0 28		PrintXError	LDY     #(ERRX-MSGX)	; load error message
  3018 F246 18					CLC
  3019 F247 D0 03				BNE     PrintXEnd
  3020
  3021 F249 A0 39		PrintXSucc      LDY     #(SUCCX-MSGX)	; load success message
  3022 F24B 38					SEC
  3023 F24C 58			PrintXEnd	CLI			; enable interrupts
  3024
  3025 F24D A9 00		PrintXMsg	LDA     #$00
  3026 F24F 2A					ROL			; save carry
  3027 F250 48					PHA
  3028 F251 B9 89 F2		PrintXMsg1	LDA  	MSGX,Y   	; load char at string pos y
  3029 F254 F0 06				BEQ  	EndXMsg  	; exit, if NULL char
  3030 F256 20 52 E0				JSR  	COUT       	; write character
  3031 F259 C8					INY             	; next index
  3032 F25A D0 F5				BNE  	PrintXMsg1
  3033 F25C 68			EndXMsg		PLA
  3034 F25D 4A					LSR			; restore carry and leave A = 0
  3035 F25E 60					RTS
  3036
  3037 				; Tape Messages ****************************************************************
  3038
  3039 F25F 38			TAPE_OK_MSG	SEC
  3040 F260 A0 3C				LDY	#(TAPEOK-MSGX)
  3041 F262 D0 E9				BNE	PrintXMsg
  3042
  3043 F264 18			TAPE_ERR_MSG	CLC
  3044 F265 A0 80				LDY	#(TAPELDERR-MSGX)
  3045 F267 D0 E4				BNE	PrintXMsg
  3046
  3047 F269 18			TAPE_BREAK_MSG	CLC
  3048 F26A A0 78				LDY	#(TAPEBRK-MSGX)
  3049 F26C D0 DF				BNE	PrintXMsg
  3050
  3051 F26E A0 57		TAPE_SAVE_MSG	LDY	#(TAPESAV-MSGX)
  3052 F270 D0 DB				BNE	PrintXMsg
  3053
  3054 F272 A0 69		TAPE_LOAD_MSG	LDY	#(TAPELOD-MSGX)
  3055 F274 D0 D7				BNE	PrintXMsg
  3056
  3057 F276 A0 60		TAPE_SKIP_MSG	LDY	#(TAPESKIP-MSGX)
  3058 F278 D0 D3				BNE	PrintXMsg
  3059
  3060 F27A 20 81 F2		TAPE_REC_MSG	JSR	TAPE_PLAY_MSG
  3061 F27D A0 4D				LDY	#(TAPEREC-MSGX)
  3062 F27F D0 CC				BNE	PrintXMsg
  3063
  3064 F281 A0 41		TAPE_PLAY_MSG	LDY	#(TAPEPLAY-MSGX)
  3065 F283 D0 C8				BNE	PrintXMsg
  3066
  3067 F285 A0 14		TAPE_ESC_MSG	LDY	#(ESCX-MSGX)
  3068 F287 D0 C4				BNE	PrintXMsg
  3069
  3070 				; ******************************************************************************
  3071 				; String Data Section
  3072 				; ******************************************************************************
  3073
  3074 F289 0D			MSGX            .byte      CR
  3075 F28A 42 65 67 69 6E 20 + 		.by	'Begin data transfer'
  3076 F29D 2C 20 3C 45 53 43 + ESCX		.by	', <ESC> to cancel. '
  3077 F2B0 00					.byte     	$00
  3078 F2B1 0D			ERRX		.byte	CR
  3079 F2B2 54 72 61 6E 73 66 + 		.by	'Transfer Error'
  3080 F2C0 0D 00				.byte      CR,$00
  3081 F2C2 04 04 04		SUCCX           .byte	EOT,EOT,EOT
  3082
  3083 F2C5 0D			TAPEOK		.byte	CR
  3084 F2C6 4F 4B				.by 	'OK'
  3085 F2C8 0D 00				.byte  	CR,$00
  3086 F2CA 0D			TAPEPLAY	.byte	CR
  3087 F2CB 50 72 65 73 73 20 + 		.by	'Press PLAY'
  3088 F2D5 00					.byte	$00
  3089 F2D6 20 26 20 52 45 43 + TAPEREC		.by	' & RECORD'
  3090 F2DF 00					.byte	$00
  3091 F2E0 0D			TAPESAV		.byte	CR
  3092 F2E1 73 61 76 69 6E 67 + 		.by	'saving '
  3093 F2E8 00					.byte	$00
  3094 F2E9 2C 20 73 6B 69 70 + TAPESKIP	.by	', skipped'
  3095 F2F2 0D			TAPELOD		.byte	CR
  3096 F2F3 6C 6F 61 64 69 6E + 		.by	'loading'
  3097 F2FA 00					.byte	$00
  3098 F2FB 66 6F 75 6E 64 20	TAPEFND		.by	'found '
  3099 F301 0D			TAPEBRK		.byte	CR
  3100 F302 42 72 65 61 6B			.by	'Break'
  3101 F307 0D 00				.byte	CR,$00
  3102 F309 0D			TAPELDERR	.byte	CR
  3103 F30A 4C 6F 61 64 20 45 + 		.by	'Load Error'
  3104 F314 0D 00				.byte	CR,$00
  3105 F316 2A			TAPEANYNAME	.by	"*"
  3106 F317 00					.byte	$00
  3107
  3108 				; **** IRQ, NMI and BREAK Service Routines *************************************
  3109
  3110 				; ******************************************************************************
  3111
  3112 F318 8D 77 1A		IRQ		STA	STOACC		; save current accumulator
  3113 F31B 68					PLA			; get current processor status in A
  3114 F31C 48					PHA			; and push it back to stack
  3115 F31D 29 10				AND	#$10		; mask break flag
  3116 F31F D0 06				BNE	USRBREAK	; if break flag set, jump to user break handler
  3117 F321 AD 77 1A				LDA	STOACC
  3118 F324 6C 7C 1A				JMP	(IRQUSR)	; else jump to clock IRQ routine
  3119
  3120 F327 AD 77 1A		USRBREAK	LDA	STOACC
  3121 F32A 6C 78 1A				JMP	(BRKUSR)
  3122
  3123 F32D 85 F3		NMI		STA	ACC		; save current accumulator
  3124
  3125 F32F			BREAK					; default IRQUSR & BRKUSR entry
  3126 F32F 68					PLA			; get current processor status in A
  3127 F330 85 F1				STA	PREG		; save it
  3128 F332 48					PHA			; and push it back to stack
  3129 F333 86 F5				STX	XREG		; save x-register
  3130 F335 84 F4				STY	YREG		; save y-register
  3131 F337 20 AD E1				JSR	RESET_STDIO	; always reset to standard I/O
  3132 F33A 28					PLP			; get last processor status
  3133 F33B 68					PLA			; get last program counter low byte
  3134 F33C 85 EF				STA	PCL		; and store it
  3135 F33E 85 FA				STA	ADRL
  3136 F340 68					PLA			; get last program counter high byte
  3137 F341 85 F0				STA	PCH		; and store it
  3138 F343 85 FB				STA	ADRH
  3139 F345 BA					TSX			; get current stack pointer
  3140 F346 86 F2				STX	SPUSER		; and store it
  3141 F348 D8					CLD			; set binary mode
  3142 F349 20 67 E1				JSR	BEEP		; error beep
  3143 F34C 20 4E EC				JSR	PRSTATUS	; print user program status
  3144 F34F A2 FF				LDX     #$FF
  3145 F351 9A					TXS			; initialize stack pointer
  3146 F352 58					CLI			; enable interrupts
  3147 F353 4C 3B E6				JMP	MONRESET	; and return to monitor
  3148
  3149 				; **** Try To Read Magic Number ************************************************
  3150
  3151 				; ******************************************************************************
  3152
  3153 F356 A2 04		GETMAGIC	LDX	#$04
  3154 F358 BD 64 E7		MAGICLOOP	LDA	MAGIC0-1,X
  3155 F35B DD FB DF				CMP	$DFFB,X
  3156 F35E D0 03				BNE	NOMAGIC
  3157 F360 CA					DEX
  3158 F361 D0 F5				BNE	MAGICLOOP
  3159 F363 8A			NOMAGIC		TXA
  3160 F364 60			NOSTDPROC	RTS
  3161
  3162 				; **** Write To Serial Routine *************************************************
  3163
  3164 				; Input: A - Output Byte to RS232
  3165
  3166 				; ******************************************************************************
  3167
  3168 F365			SOUT
  3169 F365 08			SERIALOUT	PHP			; save processor status
  3170 F366 78					SEI			; disable interrupts
  3171 F367 48					PHA			; save character
  3172 F368 A9 10				LDA  	#$10
  3173 F36A 2C 01 16		EMPTY?		BIT  	STAT_REG	; ACIA output register empty?
  3174 F36D F0 FB				BEQ  	EMPTY?		; no, check again.
  3175 F36F 68					PLA			; restore character
  3176 F370 8D 00 16				STA  	DATA_REG   	; write character to ACIA
  3177 F373 28					PLP			; restore processor status
  3178 F374 60					RTS
  3179
  3180 				; **** Read From Serial Routine ************************************************
  3181
  3182 				; Output: A - Input Byte from RS232
  3183 				;         C - 1 char get, 0 no char get
  3184
  3185 				; ******************************************************************************
  3186
  3187 F375			SIN
  3188 F375 18			SERIALIN	CLC              	; set to no chr present
  3189 F376 AD 01 16				LDA	STAT_REG
  3190 F379 29 08				AND	#$08		; ACIA input register full?
  3191 F37B F0 04				BEQ	SERIALEND	; no, just exit
  3192 F37D AD 00 16				LDA	DATA_REG	; yes, read character
  3193 F380 38					SEC		 	; and set C = 1, char present
  3194 F381 60			SERIALEND	RTS
  3195
  3196 				; **** Read From ASCII Keyboard Routine ****************************************
  3197
  3198 				; Output: A - Input Byte from Keyboard
  3199 				;         C - 1 char get, 0 no char get
  3200
  3201 				; ******************************************************************************
  3202
  3203 F382 AD 81 1A		ASCIIKBD	LDA	PADD		; are we in read mode?
  3204 F385 F0 03				BEQ	READMODE	; yes, check if data available
  3205 F387 20 10 F4				JSR	SETPPORTIN	; no, first set parallel port as an input
  3206 F38A 18			READMODE	CLC			; set to no char present
  3207 F38B 2C 85 1A				BIT	WRDC		; test PA7 (DATA_AVAIL)
  3208 F38E 50 09				BVC	NODATA		; no new data, just exit with C = 0
  3209 F390 AD 85 1A				LDA	WRDC		; clear PA7 flag
  3210 F393 AD 80 1A				LDA	PAD		; load keyboard ASCII code from port A
  3211 F396 29 7F				AND	#%01111111	; clear MSB
  3212 F398 38			DATA_AVAIL	SEC			; and set C = 1, char present
  3213 F399 60			NODATA		RTS
  3214
  3215 				; **** PS2 Keyboard Driver Routine *********************************************
  3216
  3217 				; Output: A - Input Byte from Keyboard
  3218 				;         C - 1 char get, 0 no char get
  3219
  3220 				; ******************************************************************************
  3221
  3222 F39A 18			PS2KBD          CLC                     ; set to no char present
  3223 F39B 84 F1		                STY     PREG            ; save current Y register
  3224 F39D A0 0E		                LDY     #PIA_PORTC
  3225 F39F B1 16		                LDA     (FGCBASE),Y     ; load data from Port C
  3226 F3A1 29 20		                AND     #$20            ; and check Strobe line
  3227 F3A3 F0 15		                BEQ     PS2_NODATA      ; no data received, just exit with C = 0
  3228 F3A5 A0 0C		                LDY     #PIA_PORTA
  3229 F3A7 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  3230 F3A9 D0 0E		                BNE     PS2_DATA_AVAIL
  3231 F3AB A0 0E		                LDY     #PIA_PORTC      ; NULL Byte received, check for second byte
  3232 F3AD B1 16		PS2_CHECK       LDA     (FGCBASE),Y     ; load data from Port C
  3233 F3AF 29 20		                AND     #$20            ; and check Strobe line
  3234 F3B1 F0 FA		                BEQ     PS2_CHECK       ; no data received, repeat
  3235 F3B3 A0 0C		                LDY     #PIA_PORTA
  3236 F3B5 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  3237 F3B7 09 80		                ORA     #$80            ; set bit 7
  3238 F3B9 38			PS2_DATA_AVAIL  SEC			; and set C = 1, char present
  3239 F3BA A4 F1		PS2_NODATA      LDY     PREG            ; restore Y register
  3240 F3BC 60			                RTS
  3241
  3242 				; **** Detect ASCII Keyboard Routine *******************************************
  3243
  3244 				; ******************************************************************************
  3245
  3246 F3BD 20 10 F4		DETECT_ASCIIKBD JSR	SETPPORTIN	; set parallel port as an input
  3247 F3C0 AD 80 1A				LDA	PAD		; read parallel port
  3248 F3C3 C9 FF				CMP	#$FF		; is there anything connected?
  3249 F3C5 F0 0A				BEQ	NOKBD		; no, just exit
  3250 F3C7 A2 98		                LDX     #<  KEYBD_DEV
  3251 F3C9 A0 F9		                LDY     #> KEYBD_DEV
  3252 F3CB 20 6F F7		                JSR     DEV_ADD         ; add ASCII keyboard driver
  3253 F3CE 8D 74 1A				STA	STDINDEV	; make it the standard input device
  3254 F3D1 60			NOKBD		RTS
  3255
  3256 				; **** Write To Parallel Port Routine ******************************************
  3257
  3258 				; Input: A - Output Byte to parallel port
  3259
  3260 				; ******************************************************************************
  3261
  3262 F3D2 48			PPORTOUT	PHA			; save character
  3263 F3D3 A9 BE				LDA	#$BE		; initialize handshake line I/O on port b
  3264 F3D5 CD 83 1A				CMP	PBDD		; already initialized?
  3265 F3D8 F0 03				BEQ	SETHSK		; yes, just set output values
  3266 F3DA 8D 83 1A				STA	PBDD		; no, PB7 = /strobe, PB6 = busy, PB5 = r/w, PB0 = speaker off
  3267 F3DD A9 86		SETHSK		LDA	#$86		; set handshake lines to their initial values
  3268 F3DF 8D 82 1A				STA	PBD		; r/w = L, strobe = H, PB1,PB2 = H -> hex-kbd disabled; speaker = H
  3269 F3E2 A9 FF				LDA	#$FF		; all port A lines are outputs
  3270 F3E4 8D 81 1A				STA	PADD
  3271 F3E7 68					PLA			; reload character in A
  3272 F3E8 48					PHA
  3273 F3E9 8D 80 1A				STA	PAD		; set output data
  3274 F3EC 2C 82 1A		PPORTBSY?	BIT	PBD		; bussy line is high?
  3275 F3EF 70 FB				BVS	PPORTBSY?	; yes, check bussy line again
  3276 F3F1 A9 06				LDA	#$06		; generate strobe pulse
  3277 F3F3 8D 82 1A				STA	PBD		; set strobe line low
  3278 F3F6 A9 86				LDA	#$86
  3279 F3F8 8D 82 1A				STA	PBD		; set strobe line high
  3280 F3FB 68					PLA			; restore character
  3281 F3FC 60					RTS
  3282
  3283 				; **** Read From Parallel Port Routine *****************************************
  3284
  3285 				; Output: A - Input Byte from parallel port
  3286 				;         C - 1 char get, 0 no char get
  3287
  3288 				; ******************************************************************************
  3289
  3290 F3FD 20 10 F4		PPORTIN		JSR	SETPPORTIN	; set parallel port as input
  3291 F400 18					CLC
  3292 F401 2C 82 1A				BIT	PBD		; check if /STROBE = 0
  3293 F404 30 09				BMI	NOSTROBE	; no, just exit with C = 0
  3294 F406 2C 82 1A		STROBE?		BIT	PBD		; yes, wait for strobe to come high again
  3295 F409 30 FB				BMI	STROBE?
  3296 F40B AD 80 1A				LDA	PAD		; load data from port A
  3297 F40E 38					SEC			; and set C = 1, data present
  3298 F40F 60			NOSTROBE	RTS
  3299
  3300 				; **** Switch Parallel Port To Data Input **************************************
  3301
  3302 				; ******************************************************************************
  3303
  3304 F410 A9 00		SETPPORTIN	LDA	#$00		; initialize port A as input
  3305 F412 8D 81 1A				STA	PADD
  3306 F415 A9 3E				LDA	#$3E		; initialize port B bits for read operation
  3307 F417 8D 83 1A				STA	PBDD
  3308 F41A A9 26				LDA	#$26		; set PB5 = H (READ)
  3309 F41C 8D 82 1A				STA	PBD
  3310 F41F 8D 85 1A				STA	WRDC		; set PA7 raising edge detection, no interrupt
  3311 F422 AD 85 1A				LDA	WRDC		; clear interrupt flag
  3312 F425 60					RTS
  3313
  3314 				; ******************************************************************************
  3315 				; SPI Driver
  3316 				; ******************************************************************************
  3317
  3318 				; ******************************************************************************
  3319 				; Initialize SPI Interface
  3320 				; ******************************************************************************
  3321
  3322 F426			SPI_INIT					;fall trough to SPI_SLOW
  3323
  3324 				; ******************************************************************************
  3325 				; Set SPI to Slow Mode (250KHz)
  3326 				; ******************************************************************************
  3327
  3328 F426 A9 04		SPI_SLOW        LDA	#$04
  3329 F428 A0 1B				LDY	#ACR
  3330 F42A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under T2 control"
  3331 F42C A9 00				LDA	#$00			; reset Timer2
  3332 F42E A0 18				LDY	#T2CL
  3333 F430 91 14				STA	(IOBASE),Y		; store timer low value
  3334 F432 20 61 F4				JSR	SPI_RESET		; flush shift register
  3335 F435 60					RTS				; Clock is set to 250 kHz
  3336 						
  3337 				; ******************************************************************************
  3338 				; Set SPI to Fast Mode (500KHz)
  3339 				; ******************************************************************************
  3340
  3341 F436 A9 08		SPI_FAST	LDA	#$08
  3342 F438 A0 1B				LDY	#ACR
  3343 F43A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under phi2 control"
  3344 F43C 60					RTS				; Clock is set to 500 kHz
  3345
  3346 				; ******************************************************************************
  3347 				; Write a Single Byte to the SPI Interface
  3348 				;
  3349 				; Input: A = Byte to Send
  3350 				; ******************************************************************************
  3351
  3352 F43D 84 FD		SPI_WRITE	STY	YSAV
  3353 F43F A0 11				LDY	#PORTA
  3354 F441 91 14				STA	(IOBASE),Y		; output data to shift register
  3355 F443 A0 1D				LDY	#IFR
  3356 F445 A9 04		SPI_WRITE1	LDA	#$04			; set bit mask for data available flag
  3357 F447 31 14				AND	(IOBASE),Y		; shift register full?
  3358 F449 F0 FA				BEQ	SPI_WRITE1		; no, check again
  3359 F44B A0 10				LDY	#PORTB
  3360 F44D A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3361 F44F 91 14				STA	(IOBASE),Y		; load data into shift register
  3362 F451 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3363 F453 91 14				STA	(IOBASE),Y		; data is now in shift register
  3364 F455 D0 0A				BNE	SPI_RESET               ; branch always
  3365
  3366 				; ******************************************************************************
  3367 				; Read a Single Byte from the SPI Interface
  3368 				;
  3369 				; Output: A = Received Byte
  3370 				; ******************************************************************************
  3371
  3372 F457 84 FD		SPI_READ	STY	YSAV
  3373 F459 A0 1D				LDY	#IFR
  3374 F45B A9 04		SPI_READ1	LDA	#$04			; set bit mask for data available flag
  3375 F45D 31 14				AND	(IOBASE),Y		; shift register full?
  3376 F45F F0 FA				BEQ	SPI_READ1		; no, check again
  3377 F461 A0 1A		SPI_RESET	LDY	#SR
  3378 F463 B1 14				LDA	(IOBASE),Y		; start next shifting, clear data available flag
  3379 F465 A4 FD				LDY	YSAV
  3380 F467 60					RTS
  3381
  3382 				; ******************************************************************************
  3383 				; SD-Card Driver Routines
  3384 				; ******************************************************************************
  3385
  3386 				; ******************************************************************************
  3387 				; Initialize SD-Card
  3388 				; Output: C = 1 Init OK, C = 0 Error
  3389 				; ******************************************************************************
  3390
  3391 F468 78			SD_INIT		SEI                             ; disable interrupts
  3392 F469 A9 00		                LDA	#$00
  3393 F46B 85 DB				STA	SD_TYPE
  3394 F46D 20 E1 F5				JSR	SD_RESET		; reset SD-Card
  3395 F470 C9 01				CMP	#$01			; SD-Card present?
  3396 F472 D0 57				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3397 F474 20 D0 F4				JSR	SD_GET_VERS		; get SD-Card version
  3398 F477 C9 05				CMP	#$05			; seems to be a version 1 card
  3399 F479 F0 08				BEQ	INIT_SD0		; so just try to initialize it
  3400 F47B C9 AA				CMP	#$AA			; version 2 cards should response with $(01)AA
  3401 F47D D0 4C				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3402 F47F A9 40				LDA	#$40			; try ACMD41($40000000) init (SD Ver. 2+)
  3403 F481 D0 02				BNE	INIT_SD1
  3404 F483 A9 00		INIT_SD0	LDA	#$00			; try ACMD41($00000000) init (SD Ver. 1)
  3405 F485 20 F3 F4		INIT_SD1	JSR	SD_CLEAR_CMD		; prepare for new command
  3406 F488 85 DF				STA	SD_PB3
  3407 F48A A9 77		INIT_SD2	LDA	#CMD55			; send prefix CMD55 (application cmd)
  3408 F48C 20 02 F5				JSR	SD_SEND_CMD
  3409 F48F C9 01				CMP	#$01
  3410 F491 D0 38				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3411 F493 A9 69				LDA	#ACMD41			; send ACMD41 (initialize)
  3412 F495 20 02 F5				JSR	SD_SEND_CMD
  3413 F498 F0 06				BEQ	INIT_SD3		; response = 0 means card waked up,
  3414 F49A C9 01				CMP	#$01			; card still idle?
  3415 F49C F0 EC				BEQ	INIT_SD2		; yes, try again
  3416 F49E D0 2B				BNE	SDC_NOT_FOUND		; no, invalid response, no usable card found
  3417 F4A0 A5 DF		INIT_SD3	LDA	SD_PB3			; Ver. 2+ Card?
  3418 F4A2 F0 13				BEQ	INIT_SD4		; no, just set block size
  3419 F4A4 20 F3 F4				JSR	SD_CLEAR_CMD		; prepare for new command
  3420 F4A7 A9 7A				LDA	#CMD58			; send CMD58 (get OCR)
  3421 F4A9 20 02 F5				JSR	SD_SEND_CMD
  3422 F4AC D0 1D				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3423 F4AE 20 E5 F4				JSR	SD_WAIT_RESP3		; wait for OCR response
  3424 F4B1 A5 DF				LDA	SD_PB3			; Test Bit 30
  3425 F4B3 29 40				AND	#$40			; 1 if SDHC/SDXC card, 0 else
  3426 F4B5 85 DB				STA	SD_TYPE			; set type $00 Byte mode, $40 LBA mode
  3427 F4B7 20 F3 F4		INIT_SD4	JSR	SD_CLEAR_CMD		; prepare for new command
  3428 F4BA A9 02				LDA	#$02			; set blocksize to 512 byte
  3429 F4BC 85 E1				STA	SD_PB1
  3430 F4BE A9 50				LDA	#CMD16			; send CMD16 (set block size)
  3431 F4C0 20 02 F5				JSR	SD_SEND_CMD
  3432 F4C3 D0 06				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3433 F4C5 20 36 F4				JSR	SPI_FAST		; and switch to SPI fast mode (500kHz)
  3434 F4C8 58					CLI                             ; reenable interrupts
  3435 F4C9 38					SEC				; everything gone well, set carry
  3436 F4CA 60					RTS
  3437 F4CB A9 80		SDC_NOT_FOUND	LDA	#$80
  3438 F4CD 58			                CLI                             ; reenable interrupts
  3439 F4CE 18					CLC				; something went wrong, clear carry
  3440 F4CF 60					RTS				; to signal error
  3441
  3442 				; ******************************************************************************
  3443 				; Get SD-Card Version
  3444 				; ******************************************************************************
  3445
  3446 F4D0 A9 01		SD_GET_VERS	LDA	#$01			; set parameter byte 1
  3447 F4D2 85 E1				STA	SD_PB1
  3448 F4D4 A9 AA				LDA	#$AA			; set parameter byte 0
  3449 F4D6 85 E2				STA	SD_PB0
  3450 F4D8 A9 87				LDA	#$87			; set crc
  3451 F4DA 85 E3				STA	SD_CRC
  3452 F4DC A9 48				LDA	#CMD8			; send CMD8($000001AA) (get version)
  3453 F4DE 20 02 F5				JSR	SD_SEND_CMD		; response should be $01
  3454 F4E1 C9 01				CMP	#$01			; SD-Card present?
  3455 F4E3 D0 0D				BNE	END_GET_VERS		; no, exit with result <> $01
  3456 										; yes, fall through to sd_wait_resp
  3457
  3458 				; ******************************************************************************
  3459 				; Wait for a 32 Bit Command R3 Response from SD-Card
  3460 				; ******************************************************************************
  3461
  3462 F4E5 A0 00		SD_WAIT_RESP3	LDY	#$00
  3463 F4E7 20 13 F5		READ_RESP3	JSR	SD_WAIT_RESP		; yes, receive 4 response bytes
  3464 F4EA 99 DF 00				STA	SD_PB3,Y		; store response bytes in PB0..3
  3465 F4ED C8					INY
  3466 F4EE C0 04				CPY	#$04
  3467 F4F0 D0 F5				BNE	READ_RESP3
  3468 F4F2 60			END_GET_VERS	RTS
  3469
  3470 				; ******************************************************************************
  3471 				; Clear SD-Card Command Parameters
  3472 				; ******************************************************************************
  3473
  3474 F4F3 A9 00		SD_CLEAR_CMD	LDA	#$00
  3475 F4F5 A0 04				LDY	#$04			; 4 parameter bytes to clear
  3476 F4F7 99 DE 00		NEXT_PARAM	STA	SD_CMD,Y		; clear parameter byte
  3477 F4FA 88					DEY
  3478 F4FB D0 FA				BNE	NEXT_PARAM		; more to clear?
  3479 F4FD A9 FF				LDA	#$FF
  3480 F4FF 85 E3				STA	SD_CRC			; no, finally set CRC byte to $FF
  3481 F501 60					RTS
  3482
  3483 				; ******************************************************************************
  3484 				; Send Command to SD-Card
  3485 				; Input: A = Command Index
  3486 				; ******************************************************************************
  3487
  3488 F502 85 DE		SD_SEND_CMD	STA	SD_CMD
  3489 F504 20 57 F4				JSR	SPI_READ		; send one dummy
  3490 F507 A2 00				LDX	#$00
  3491 F509 B5 DE		SEND_BYTE	LDA	SD_CMD,X		; get one command byte
  3492 F50B 20 3D F4				JSR	SPI_WRITE		; and send it
  3493 F50E E8					INX
  3494 F50F E0 06				CPX	#$06			; all 6 cmd bytes send?
  3495 F511 D0 F6				BNE	SEND_BYTE		; no, send more bytes
  3496 										; yes, fall through to sd_wait_resp
  3497
  3498 				; ******************************************************************************
  3499 				; Wait for a 8 Bit Command R1 Response from SD-Card
  3500 				; Output: A = Response Byte
  3501 				; ******************************************************************************
  3502
  3503 F513 A2 08		SD_WAIT_RESP	LDX	#$08			; wait for max 8 cycles
  3504 F515 20 57 F4		READ_RESP1	JSR	SPI_READ		; receive data
  3505 F518 C9 FF				CMP	#$FF			; is it a $FF?
  3506 F51A D0 03				BNE	RESPONSE		; no, card did response
  3507 F51C CA					DEX				; yes, try again
  3508 F51D D0 F6				BNE	READ_RESP1		; check for timeout
  3509 F51F AA			RESPONSE	TAX
  3510 F520 8A					TXA				; set proper status flags for A
  3511 F521 60					RTS
  3512
  3513 				; ******************************************************************************
  3514 				; Wait for a Special Token Response from SD-Card
  3515 				; Input:  A = Token Byte
  3516 				; Output: A = Response Byte
  3517 				; ******************************************************************************
  3518
  3519 F522 85 FC		SD_WAIT_TOKEN	STA	TEMP			; store token into TEMP variable
  3520 F524 A0 FF				LDY	#$FF			; load low byte of time out counter
  3521 F526 A2 0A				LDX	#$0A			; load high byte of time out counter
  3522 F528 20 57 F4		WAIT_RESP	JSR	SPI_READ		; read byte from SPI
  3523 F52B 88					DEY				; decrement wait counter
  3524 F52C D0 03				BNE	WAIT_RESP0
  3525 F52E CA					DEX
  3526 F52F F0 04				BEQ	WAIT_RESP_END		; wait counter is 0 -> time out
  3527 F531 C5 FC		WAIT_RESP0	CMP	TEMP			; did we read the token we are waiting for?
  3528 F533 D0 F3				BNE	WAIT_RESP		; no, read next byte
  3529 F535 60			WAIT_RESP_END	RTS
  3530
  3531 				; ******************************************************************************
  3532 				; Read Single Data Block to Std. Block Buffer
  3533 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3534 				; Output: C = 0 Error, C = 1 Read OK
  3535 				;	  A = Error Code
  3536 				; ******************************************************************************
  3537
  3538 F536 20 8B F6		SD_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3539 F539 F0 06				BEQ	SD_RD_BLK
  3540
  3541 				; ******************************************************************************
  3542 				; Read Single Data Block from Logical Address to Std. Block Buffer
  3543 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3544 				; Output: C = 0 Error, C = 1 Data OK
  3545 				;	  A = Error Code
  3546 				; ******************************************************************************
  3547
  3548 F53B 20 8B F6		SD_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3549 										; fall through to sd_rd_lblk
  3550
  3551 				; ******************************************************************************
  3552 				; Read Single Data Block from Logical Address
  3553 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3554 				;	  BLKBUF,BLKBUFH = 16 Bit Destination Address
  3555 				; Output: C = 0 Error, C = 1 Data OK
  3556 				;	  A = Error Code
  3557 				; ******************************************************************************
  3558
  3559 F53E 20 94 F6		SD_RD_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3560 										; fall through to sd_rd_blk
  3561
  3562 				; ******************************************************************************
  3563 				; Read Single Data Block
  3564 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3565 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
  3566 				; Output: C = 0 Error, C = 1 Read OK
  3567 				;	  A = Error Code
  3568 				; ******************************************************************************
  3569
  3570 F541 A9 51		SD_RD_BLK	LDA	#CMD17			; send CMD17 (blk read)
  3571 F543 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3572 F546 20 22 F5				JSR	SD_WAIT_TOKEN		; wait for data token $FE
  3573 F549 C9 FE				CMP	#$FE			; is card ready for block read?
  3574 F54B 18					CLC
  3575 F54C D0 1F				BNE	SD_RD_END		; did not receive data token, exit with C = 0
  3576 F54E A2 01				LDX	#$01			; initialize page counter
  3577 F550 A0 00				LDY	#$00			; initialize byte counter
  3578 F552 84 FD		SD_RD_BLK0	STY	YSAV			; read a byte
  3579 F554 A0 1A				LDY 	#SR
  3580 F556 B1 14				LDA	(IOBASE),Y
  3581 F558 A4 FD				LDY	YSAV
  3582 F55A 91 DC				STA	(BLKBUF),Y		; and store it into the block buffer
  3583 F55C C8					INY				; increment destination pointer
  3584 F55D D0 F3				BNE	SD_RD_BLK0		; pointer overflow? No, read next byte
  3585 F55F E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3586 F561 CA					DEX
  3587 F562 10 EE				BPL	SD_RD_BLK0		; two pages read? no, read next byte
  3588 F564 20 57 F4		SD_RD_BLK1	JSR	SPI_READ		; yes, read 3 more bytes (CRC H, CRC L, dummy)
  3589 F567 C8					INY
  3590 F568 C0 03				CPY	#$03			; all 3 bytes read?
  3591 F56A D0 F8				BNE	SD_RD_BLK1		; no, read next byte
  3592 F56C 38					SEC				; yes, all data read, set C = 1
  3593 F56D 60			SD_RD_END	RTS
  3594
  3595 				; ******************************************************************************
  3596 				; Write Single Data Block from Std. Block Buffer
  3597 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Destination Address
  3598 				; Output: C = 0 Error, C = 1 Read OK
  3599 				;	  A = Error Code
  3600 				; ******************************************************************************
  3601
  3602 F56E 20 8B F6		SD_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3603 F571 F0 06				BEQ	SD_WR_BLK
  3604
  3605 				; ******************************************************************************
  3606 				; Write Single Data Block from Std. Block Buffer to Logical Address
  3607 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3608 				; Output: C = 0 Error, C = 1 Data OK
  3609 				;	  A = Error Code
  3610 				; ******************************************************************************
  3611
  3612 F573 20 8B F6		SD_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3613 										; fall through to sd_rd_lblk
  3614
  3615 				; ******************************************************************************
  3616 				; Write Single Data Block to Logical Address
  3617 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3618 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3619 				; Output: C = 0 Error, C = 1 Data OK
  3620 				;	  A = Error Code
  3621 				; ******************************************************************************
  3622
  3623 F576 20 94 F6		SD_WR_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3624 										; fall through to sd_rd_blk
  3625
  3626 				; ******************************************************************************
  3627 				; Write Single Data Block
  3628 				; Input:  SD_PB3..SD_PB0 = 32 Bit CommandBlock Destination Address
  3629 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3630 				; Output: C = 0 Error, C = 1 Write OK
  3631 				;	  A = Error Code
  3632 				; ******************************************************************************
  3633
  3634 F579 A9 58		SD_WR_BLK	LDA	#CMD24			; send CMD24 (blk write)
  3635 F57B 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3636 F57E 20 3D F4				JSR	SPI_WRITE		; write data token
  3637 F581 A2 01				LDX	#1			; initialize page counter
  3638 F583 86 FD				STX	YSAV
  3639 F585 CA					DEX				; initialize byte counter
  3640 F586 8A			SD_WR_BLK0	TXA
  3641 F587 A8					TAY
  3642 F588 B1 DC				LDA	(BLKBUF),Y		; read next byte from buffer
  3643 F58A A0 11				LDY	#PORTA			; and write it to the card
  3644 F58C 91 14				STA	(IOBASE),Y		; output data to shift register
  3645 F58E 88					DEY				; set for PORTB
  3646 F58F A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3647 F591 91 14				STA	(IOBASE),Y		; load data into shift register
  3648 F593 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3649 F595 91 14				STA	(IOBASE),Y		; data is now in shift register
  3650 F597 A0 1A				LDY 	#SR
  3651 F599 B1 14				LDA	(IOBASE),Y		; and start clk'ing
  3652 F59B E8					INX				; increment source pointer
  3653 F59C D0 E8				BNE	SD_WR_BLK0		; pointer overflow? No, write next byte
  3654 F59E E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3655 F5A0 C6 FD				DEC	YSAV
  3656 F5A2 10 E2				BPL	SD_WR_BLK0		; two pages written? no, write next byte
  3657 F5A4 20 57 F4				JSR	SPI_READ		; yes, send a (dummy) CRC ($FFFF)
  3658 F5A7 20 57 F4				JSR	SPI_READ
  3659 F5AA 20 57 F4				JSR	SPI_READ		; read one dummy byte
  3660 F5AD 20 57 F4				JSR	SPI_READ		; read response byte
  3661 F5B0 48			                PHA                             ; and save it onto the stack
  3662 F5B1 20 57 F4		SD_WR_BUSY?	JSR	SPI_READ		; read next byte
  3663 F5B4 C9 00				CMP	#0
  3664 F5B6 F0 F9				BEQ	SD_WR_BUSY?		; check if busy ($00)
  3665 F5B8 68					PLA
  3666 F5B9 29 1F				AND	#$1F			; mask result bits
  3667 F5BB C9 05				CMP	#$05			; data accepted?
  3668 F5BD 18					CLC
  3669 F5BE D0 01				BNE	SD_WR_END		; no, exit with C = 0
  3670 F5C0 38					SEC				; yes, exit with C = 1
  3671 F5C1 60			SD_WR_END	RTS
  3672
  3673 				; ******************************************************************************
  3674 				; Send Block Read or Write Command
  3675 				; Input :  A = Command (CMD17,CMD24)
  3676 				; Output : A = Data Token
  3677 				; ******************************************************************************
  3678
  3679 F5C2 20 02 F5		SD_SEND_BLK_CMD	JSR	SD_SEND_CMD
  3680 F5C5 D0 03				BNE	SD_RESP_ERR		; response <> 0 check error type
  3681 F5C7 A9 FE				LDA	#DATA_TOKEN
  3682 F5C9 60					RTS
  3683
  3684 				; ******************************************************************************
  3685 				; Check Error
  3686 				; ******************************************************************************
  3687
  3688 F5CA 29 01		SD_RESP_ERR	AND	#$01			; is card in idle mode?
  3689 F5CC F0 0B				BEQ	SD_DISK_RW		; no, print error
  3690 F5CE 20 26 F4				JSR	SPI_SLOW		; set SPI slow mode
  3691 F5D1 20 68 F4				JSR	SD_INIT			; yes, maybe card changed, reset
  3692 F5D4 B0 07				BCS	SD_DISK_CHNG
  3693 F5D6 A9 80		SD_NO_DISK	LDA	#$80
  3694 F5D8 60					RTS
  3695 F5D9 A9 81		SD_DISK_RW	LDA	#$81
  3696 F5DB 18					CLC
  3697 F5DC 60					RTS
  3698 F5DD A9 82		SD_DISK_CHNG	LDA	#$82
  3699 F5DF 18					CLC
  3700 F5E0 60					RTS
  3701
  3702 				; ******************************************************************************
  3703 				; Reset SD-Card
  3704 				; ******************************************************************************
  3705
  3706 F5E1 20 F3 F4		SD_RESET	JSR	SD_CLEAR_CMD		; clear command parameters
  3707 F5E4 A9 95				LDA	#$95
  3708 F5E6 85 E3				STA	SD_CRC			; and set crc to $95 for CMD0
  3709 F5E8 20 FF F5				JSR	SD_PREPARE		; send dummy sequence to SD-Card
  3710 F5EB D0 0A				BNE	RESET_SDC		; is MISO line high?
  3711 F5ED A9 40				LDA	#CMD0			; no, send CMD0 (reset) to SD-Card
  3712 F5EF 20 02 F5				JSR	SD_SEND_CMD
  3713 F5F2 20 FF F5				JSR	SD_PREPARE		; send init dummy sequence again
  3714 F5F5 F0 05				BEQ	END_SD_RESET		; MISO still low? Exit with A = $FF
  3715 F5F7 A9 40		RESET_SDC	LDA	#CMD0			; send CMD0 (reset) to SD-Card
  3716 F5F9 4C 02 F5				JMP	SD_SEND_CMD		; response should be $01
  3717
  3718 F5FC A9 FF		END_SD_RESET	LDA	#$FF			; reset failed
  3719 F5FE 60					RTS
  3720
  3721 				; **** Prepare SD-Card for Communication ***************************************
  3722 				;
  3723 				; ******************************************************************************
  3724
  3725 F5FF 20 26 F4		SD_PREPARE	JSR	SPI_SLOW		; set SPI slow mode
  3726 F602 A0 10				LDY	#PORTB			; initialize VIA Port B
  3727 F604 A9 4E				LDA	#$4E			; set /SPI_CS = H and /SPI_LOAD = H
  3728 F606 91 14				STA	(IOBASE),Y
  3729 F608 A2 0A				LDX	#10			; first send 80 clocks to SD-Card
  3730 F60A 20 57 F4		SEND_CLOCK	JSR	SPI_READ		; send 8 clock cycles
  3731 F60D CA					DEX
  3732 F60E D0 FA				BNE	SEND_CLOCK		; send more clock cycles
  3733 F610 AA					TAX
  3734 F611 A0 1D				LDY	#IFR
  3735 F613 A9 04		SD_PREPARE1	LDA	#$04
  3736 F615 31 14				AND	(IOBASE),Y
  3737 F617 F0 FA				BEQ	SD_PREPARE1
  3738 F619 A0 10				LDY	#PORTB
  3739 F61B A9 4A				LDA	#$4A			; set /SPI_CS = L and /SPI_LOAD = H
  3740 F61D 91 14				STA	(IOBASE),Y
  3741 F61F 8A					TXA				; set proper status flags
  3742 F620 60			SD_END		RTS
  3743
  3744 				; **** SD-Card Boot Routine ****************************************************
  3745 				;
  3746 				; ******************************************************************************
  3747 F621 20 F3 F4		SD_BOOT         JSR	SD_CLEAR_CMD
  3748 F624 20 36 F5				JSR	SD_RD_BLK_BUF           ; read MBR
  3749 F627 90 F7		                BCC     SD_END                  ; error reading MBR. Exit
  3750
  3751 F629 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3752 F62C 90 F2				BCC	SD_END			; branch if error
  3753 						
  3754 F62E A0 45				LDY     #SDCDEV-STRINGP2        ; load pointer to device name
  3755 F630 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3756 					
  3757 				;----------------------------------------------------------------------------------		
  3758 				; This routine is the same for both the CF and SD cards. It does the following:
  3759 				; - Load the MBR (sector 0) and does check for $55 $AA and $65 $02
  3760 				; - It runs the boot-menu routine in the MBR
  3761 				; - It loads the begin-LBA of the selected partition
  3762 				; - It loads the Volume ID (first sector) of the partition
  3763 				; Exit: C=0: Error, C=1: OK
  3764 				;----------------------------------------------------------------------------------		
  3765 F633 20 EE F6		LOAD_RUN_PART   JSR     SYS_MBR_ID              ; check boot block ID tag
  3766 F636 90 E8		                BCC     SD_END                  ; error, wrong ID. Exit
  3767 F638 AD BC 07		                LDA     PART0-2                 ; check if partition ID1 is $65
  3768 F63B C9 65		                CMP     #$65
  3769 F63D D0 20		                BNE     LOAD_PART0              ; no, just load partition 0
  3770 F63F AD BD 07		                LDA     PART0-1                 ; check if partition ID2 is $02
  3771 F642 C9 02		                CMP     #$02
  3772 F644 D0 19		                BNE     LOAD_PART0              ; no, just load partition 0
  3773 F646 20 00 06		                JSR     MBR                     ; partition ID $65 $02 found. Call MBR code
  3774 F649 D0 02		                BNE     LOAD_PART1              ; is boot menu result 1,2,3, or 4 ?
  3775 F64B 18			                CLC                             ; no, ESC pressed or no valid partition found
  3776 F64C 60			LRP_END         RTS                             ; abort booting from SD-Card
  3777
  3778 F64D CA			LOAD_PART1      DEX                             ; set result to 0,1,2 or 3
  3779 F64E 8A			                TXA                             ; transfer result to Accu
  3780 F64F A8			                TAY                             ; and to Y-Register
  3781 F650 0A			                ASL                            ; multiply result by 16
  3782 F651 0A			                ASL     
  3783 F652 0A			                ASL     
  3784 F653 0A			                ASL     
  3785 F654 09 08		                ORA     #$08                    ; and add 8
  3786 F656 AA			                TAX                             ; move partition table index into X
  3787 F657 98			                TYA
  3788 F658 18			                CLC
  3789 F659 69 31		                ADC     #49                     ; convert partition number to ASCII char (+1)
  3790 F65B 85 EE		                STA     PSAV                    ; and store it to PSAV
  3791 F65D D0 0B		                BNE     LOAD_PART               ; branch always
  3792 F65F A2 08		LOAD_PART0      LDX     #$08                    ; for partition 0 the table index is 8
  3793 F661 A9 31		                LDA     #'1'                    ; partition 0 number as ASCII char (+1)
  3794 F663 85 EE		                STA     PSAV                    ; store it in PSAV
  3795 F665 AD BE 07		                LDA     PART0                   ; read boot indicator
  3796 F668 F0 75		                BEQ     SYS_MSG_ERR             ; if $00 then exit
  3797 F66A A0 08		LOAD_PART       LDY     #$08
  3798 F66C BD C6 07		SD_BOOT1        LDA     PART0_RS,X              ; load partition start and length
  3799 F66F 99 00 04		                STA     BOOT_PART,Y             ; and save it to boot device descriptor
  3800 F672 CA			                DEX
  3801 F673 88			                DEY
  3802 F674 10 F6		                BPL     SD_BOOT1
  3803 F676 A2 00		                LDX	#< BOOT_PART            ; read partition boot blk ptr
  3804 F678 A0 04				LDY	#> BOOT_PART
  3805 F67A 20 E7 F6				JSR     SYS_LD_BOOTBLK          ; load partition boot block
  3806 F67D 90 CD		                BCC     LRP_END                 ; block not found. Exit
  3807 F67F 4C 00 F7		                JMP     SYS_CHECK_OS            ; check OS OEM string C=0: wrong OEM string. And return
  3808 						
  3809 				;----------------------------------------------------------------------------
  3810 				; This routine prints a string to the terminal: A=LSB, Y=MSB
  3811 				;----------------------------------------------------------------------------
  3812 F682 86 CA		SPRINT		STX 	PRSTR	    	; LSB of text-pointer
  3813 F684 84 CB				STY 	PRSTR+1	    	; MSB of text-pointer
  3814 F686 20 4D FE				JSR 	SPROUT	    	; BIOS print string routine
  3815 F689 60					RTS
  3816 F68A EA					NOP			; maintain v1.1.4 compatibility
  3817 						
  3818 				; ******************************************************************************
  3819 				; Initialize Block Buffer Pointer, it must return with A = 0.
  3820 				; ******************************************************************************
  3821
  3822 F68B A9 06		INIT_BLKBUF	LDA	#> BLOCK_BUF         ; set pointer to standard block buffer
  3823 F68D 85 DD				STA	BLKBUFH
  3824 F68F A9 00				LDA	#$00
  3825 F691 85 DC				STA	BLKBUF
  3826 F693 60					RTS
  3827
  3828 				; ******************************************************************************
  3829 				; Load Logical Block Address into SD-card Command Address.
  3830 				; Swap Endian and Shift Bits if Desired
  3831 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
  3832 				; Output: ADR in SD_PB3..SD_PB0
  3833 				; ******************************************************************************
  3834
  3835 F694 86 E6		LOAD_LBA_SD	STX	PLBAL
  3836 F696 84 E7				STY	PLBAH
  3837 F698 A2 04				LDX	#$04
  3838 F69A A0 00				LDY	#$00
  3839 F69C A5 DB				LDA	SD_TYPE
  3840 F69E D0 0F				BNE	BLK_MODE
  3841 F6A0 18					CLC
  3842 F6A1 98					TYA
  3843 F6A2 95 DE		                STA	SD_CMD,X
  3844 F6A4 CA					DEX
  3845 F6A5 B1 E6		BIT_MODE	LDA	(PLBA),Y
  3846 F6A7 2A					ROL	
  3847 F6A8 95 DE		                STA	SD_CMD,X
  3848 F6AA C8					INY
  3849 F6AB CA					DEX
  3850 F6AC D0 F7				BNE	BIT_MODE
  3851 F6AE 60					RTS
  3852 F6AF B1 E6		BLK_MODE	LDA	(PLBA),Y
  3853 F6B1 95 DE				STA	SD_CMD,X
  3854 F6B3 C8					INY
  3855 F6B4 CA					DEX
  3856 F6B5 D0 F8				BNE	BLK_MODE
  3857 F6B7 60					RTS
  3858
  3859 				; ******************************************************************************
  3860 				; Boot Routines
  3861 				; ******************************************************************************
  3862
  3863 				; **** Main Boot Routine *******************************************************
  3864 				;
  3865 				; Find first bootable device
  3866 				; Output : C = 0 No Boot Device Found
  3867 				;          C = 1 Boot Device Found. Boot Code at $0600 Available
  3868 				;
  3869 				; ******************************************************************************
  3870
  3871 F6B8 A0 20		SYS_BOOT        LDY     #STORAGE_DEV            ; boot from storage device only
  3872 F6BA 84 F4		SYS_BOOT1       STY     YREG
  3873 F6BC 98			                TYA
  3874 F6BD 20 BE F7		                JSR     DEV_OPEN                ; open device descriptor
  3875 F6C0 90 0E		                BCC     SYS_BOOT2               ; device not found, try next one
  3876 F6C2 A9 00		                LDA     #CMD_INIT
  3877 F6C4 20 BA E0		                JSR     CMDDEV                  ; initialize device
  3878 F6C7 90 07		                BCC     SYS_BOOT2               ; could not initialize, try next one
  3879 F6C9 A9 24		                LDA     #CMD_BOOT
  3880 F6CB 20 BA E0		                JSR     CMDDEV                  ; can we boot from device?
  3881 F6CE B0 11		                BCS     SYS_BOOT_END            ; yes, exit
  3882 F6D0 A4 F4		SYS_BOOT2       LDY     YREG                    ; no, try next device
  3883 F6D2 C8			                INY
  3884 F6D3 C0 2F		                CPY     #$2F                    ; all devices checked?
  3885 F6D5 D0 E3		                BNE     SYS_BOOT1               ; no, try next one
  3886 F6D7 A0 30		                LDY     #NOBOOTDEV-STRINGP2     ; yes, no boot device found
  3887
  3888 				; ***** Show System Message ****************************************************
  3889 				;
  3890 				; Input:  Y - Index To Message String
  3891 				; Output: C = 0
  3892 				;
  3893 				; ******************************************************************************
  3894
  3895 F6D9 20 4C E5		SYS_MSG         JSR     LOADSTRING2
  3896 F6DC 20 85 E0		                JSR  	WRSTR                   ; show error message
  3897 F6DF 18			SYS_MSG_ERR     CLC
  3898 F6E0 60			SYS_MSG_END     RTS
  3899
  3900 				; ***** Finalize Boot Procedure ************************************************
  3901
  3902 F6E1 A9 B0		SYS_BOOT_END    LDA     #$B0                    ; boot block could be loaded
  3903 F6E3 8D 00 06		                STA     $0600                   ; modify jump opcode in boot block into BCS
  3904 F6E6 60			                RTS
  3905
  3906 				; ***** Load Boot Block From Device ********************************************
  3907 				;
  3908 				; Input:  X - Pointer to Boot Block Low Address
  3909 				;         Y - Pointer to Boot Block High Address
  3910 				; Output: C = 0 No Boot Block Found
  3911 				;         C = 1 Boot Block Loaded at $0600
  3912 				;
  3913 				; ******************************************************************************
  3914
  3915 F6E7 A9 25		SYS_LD_BOOTBLK  LDA     #CMD_READ_BUF
  3916 F6E9 20 BA E0		                JSR     CMDDEV                   ; load master boot block
  3917 F6EC 90 10		                BCC     SYS_TAG_ERR
  3918
  3919 				; ***** Check Boot Block ID Tag ($55 $AA) **************************************
  3920 				;
  3921 				; Output: C = 0 No Boot Block Tag Found
  3922 				;         C = 1 Boot Block Tag Found
  3923 				;
  3924 				; ******************************************************************************
  3925
  3926 F6EE AD FE 07		SYS_MBR_ID      LDA     BOOTBLK_TAG             ; check boot block ID tag
  3927 F6F1 C9 55		                CMP     #$55
  3928 F6F3 D0 09		                BNE     SYS_TAG_ERR
  3929 F6F5 AD FF 07		                LDA     BOOTBLK_TAG+1
  3930 F6F8 C9 AA		                CMP     #$AA
  3931 F6FA D0 02		                BNE     SYS_TAG_ERR
  3932 F6FC 38			                SEC
  3933 F6FD 60			                RTS
  3934 F6FE 18			SYS_TAG_ERR     CLC
  3935 F6FF 60			                RTS
  3936
  3937 				; ***** Check OS OEM String ****************************************************
  3938 				;
  3939 				; Output: C = 0 OS OEM String Not Found
  3940 				;         C = 1 OS OEM String Found
  3941 				;
  3942 				; ******************************************************************************
  3943
  3944 F700 A2 04		SYS_CHECK_OS    LDX     #04                     ; check four characters of OEM string
  3945 F702 BD 7D E8		SYS_ID_LOOP     LDA     OSID-1,X
  3946 F705 DD 02 06		                CMP     BLOCK_BUF+2,X
  3947 F708 18			                CLC
  3948 F709 D0 09		                BNE     SYS_CHECK_END           ; wrong OEM string
  3949 F70B CA			                DEX
  3950 F70C D0 F4		                BNE     SYS_ID_LOOP             ; more charactrs to check
  3951 F70E A0 20		                LDY     #BOOTDEV-STRINGP2
  3952 F710 20 D9 F6		SYS_BOOTMSG     JSR     SYS_MSG                 ; write boot message
  3953 F713 38			                SEC
  3954 F714 60			SYS_CHECK_END   RTS
  3955
  3956 				; ******************************************************************************
  3957 				; Miscellanious Routines
  3958 				; ******************************************************************************
  3959
  3960 				; **** Read Joystick Port ******************************************************
  3961
  3962 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
  3963 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
  3964 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
  3965
  3966 				; ******************************************************************************
  3967
  3968 F715 A5 17		READ_JOY_PORT   LDA     FGCBASEH
  3969 F717 F0 47		                BEQ     NO_JOY_PORT             ; check if Floppy-/Graphisc-Controller installed
  3970 F719 A0 0D		                LDY     #PIA_PORTB
  3971 F71B B1 16		                LDA     (FGCBASE),Y             ; yes, read joystick port
  3972 F71D A2 00		DECODE_JOY_PORT LDX     #$00                    ; preset x position to CENTER
  3973 F71F A0 00		                LDY     #$00                    ; preset y position to CENTER
  3974 F721 86 FC		                STX     TEMP                    ; clear temp value
  3975 F723 4A			JP_UP           LSR                             ; get /UP flag
  3976 F724 B0 06		                BCS     JP_DOWN                 ; not set, check DOWN position
  3977 F726 A0 FF		                LDY     #$FF                    ; set y position to -1 (UP)
  3978 F728 4A			                LSR                             ; skip DOWN bit
  3979 F729 4C 31 F7		                JMP     JP_LEFT                 ; and test x position
  3980 F72C 4A			JP_DOWN         LSR                             ; get /DOWN flag
  3981 F72D B0 02		                BCS     JP_LEFT                 ; not set, test x position
  3982 F72F A0 01		                LDY     #$01                    ; set y position to 1 (DOWN)
  3983 F731 4A			JP_LEFT         LSR                             ; get /LEFT flag
  3984 F732 B0 06		                BCS     JP_RIGHT                ; not set, check RIGHT position
  3985 F734 A2 FF		                LDX     #$FF                    ; set x position to -1 (UP)
  3986 F736 4A			                LSR                             ; skip RIGHT bit
  3987 F737 4C 3F F7		                JMP     JP_BUTTON3              ; and test button 3
  3988 F73A 4A			JP_RIGHT        LSR                             ; get /RIGHT flag
  3989 F73B B0 02		                BCS     JP_BUTTON3              ; not set, test button 3
  3990 F73D A2 01		                LDX     #$01                    ; set x position to 1 (RIGHT)
  3991 F73F 4A			JP_BUTTON3      LSR                             ; get /BUTTON3 flag
  3992 F740 B0 06		                BCS     JP_BUTTON1              ; not set, test button 1
  3993 F742 48			                PHA                             ; save joystick port value
  3994 F743 A9 04		                LDA     #$04
  3995 F745 85 FC		                STA     TEMP                    ; set bit 2 of temp button result
  3996 F747 68			                PLA                             ; restore joystick port value
  3997 F748 4A			JP_BUTTON1      LSR                             ; get /BUTTON1 flag
  3998 F749 B0 08		                BCS     JP_BUTTON2              ; not set, test button 2
  3999 F74B 48			                PHA                             ; save joystick port value
  4000 F74C A9 01		                LDA     #$01
  4001 F74E 05 FC		                ORA     TEMP
  4002 F750 85 FC		                STA     TEMP                    ; set bit 0 of temp button result
  4003 F752 68			                PLA                             ; restore joystick port value
  4004 F753 4A			JP_BUTTON2      LSR                             ; get /BUTTON2 flag
  4005 F754 B0 06		                BCS     END_JOY_PORT            ; not set, exit
  4006 F756 A9 02		                LDA     #$02
  4007 F758 05 FC		                ORA     TEMP
  4008 F75A 85 FC		                STA     TEMP                    ; set bit 1 of temp button result
  4009 F75C A5 FC		END_JOY_PORT    LDA     TEMP                    ; load temp button result into A
  4010 F75E 38			                SEC                             ; data valid
  4011 F75F 60			                RTS
  4012 F760 AA			NO_JOY_PORT     TAX                             ; no joystick port available, clear X
  4013 F761 A8			                TAY                             ; and Y
  4014 F762 18			                CLC                             ; no joystick port available, data invalid
  4015 F763 60			                RTS
  4016
  4017 				; ******************************************************************************
  4018 				; Device Driver Routines
  4019 				; ******************************************************************************
  4020
  4021 				; **** Initialize Device Driver List *******************************************
  4022 				;
  4023 				; ******************************************************************************
  4024
  4025 F764 A0 3E		DEV_INIT	LDY	#$3E                    ; clear entire list
  4026 F766 A9 00		                LDA     #$00                    ; and fill it with zeros
  4027 F768 99 28 1A		DEV_INIT1       STA     DEVLIST,Y
  4028 F76B 88			                DEY
  4029 F76C 10 FA				BPL	DEV_INIT1
  4030 F76E 60			END_DEV_INIT	RTS
  4031
  4032 				; **** Add Device Driver *******************************************************
  4033 				;
  4034 				; Input  - X : Driver Descriptor Address Low Byte
  4035 				;          Y : Driver Descriptor Address High Byte
  4036 				; Output - C = 1 Success, C = 0 Error
  4037 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
  4038 				;
  4039 				; ******************************************************************************
  4040 F76F 86 DE		DEV_ADD		STX	PDEVL			; LSB of device driver descriptor
  4041 F771 84 DF				STY	PDEVH			; MSB of device driver descriptor
  4042 F773 A0 00				LDY	#$00
  4043 F775 B1 DE				LDA	(PDEV),Y                ; load device ID into A
  4044 F777 85 FC				STA     TEMP			; TEMP = Device ID
  4045 F779 20 B2 F7		                JSR     DEV_CHECK		; Check device ID
  4046 F77C 90 2F		                BCC     END_DEV_ADD		; Exit if device ID error
  4047 						
  4048 F77E 4A			                LSR     			; A = Device ID again
  4049 F77F 29 0F		                AND     #$0F			; Get ID-nr from Device ID
  4050 F781 C9 0F		                CMP     #$0F			; Device 15 ?
  4051 F783 D0 14		                BNE     ADD_DEV			; branch if not full yet
  4052 						
  4053 F785 98			FIND_FREE_DEV   TYA				; A now contains 2 * Device ID = $5E			
  4054 F786 29 E0		                AND     #$E0			; A = $50
  4055 F788 A8			                TAY				; Y = $50
  4056 F789 A2 00		                LDX     #$00			; init. X
  4057 F78B B9 08 1A		FIND_NEXT_DEV   LDA     DEVLIST-$20,Y		; Check if Device List entry is empty
  4058 F78E F0 0A		                BEQ     ADD_DEV1		; branch if it is empty
  4059 						
  4060 F790 C8			                INY				; Next entry in Device List
  4061 F791 C8			                INY
  4062 F792 E8			                INX				; Next device
  4063 F793 E0 0F		                CPX     #$0F			; 15 device entries checked?
  4064 F795 90 F4		                BCC     FIND_NEXT_DEV		; branch if not at end of list yet
  4065 						
  4066 F797 18			                CLC				; error
  4067 F798 60			                RTS				; return
  4068 						
  4069 F799 AA			ADD_DEV         TAX				; X = nr. of Device ID
  4070 F79A A5 DE		ADD_DEV1        LDA     PDEVL			; LSB of device driver descriptor
  4071 F79C 99 08 1A		                STA     DEVLIST-$20,Y		; Start of device driver list in RIOT memory
  4072 F79F A5 DF		                LDA     PDEVH			; MSB of device driver descriptor
  4073 F7A1 99 09 1A		                STA     DEVLIST-$1F,Y		;
  4074 F7A4 A5 FC		                LDA     TEMP			; Get Device ID back
  4075 F7A6 29 F0		                AND     #$F0			; A = $20
  4076 F7A8 86 FC		                STX     TEMP			; Temp = nr. of Device ID
  4077 F7AA 05 FC		                ORA     TEMP			; Original Device ID again
  4078 F7AC 38			                SEC				; No error
  4079 F7AD 60			END_DEV_ADD     RTS				; Return
  4080
  4081 F7AE A2 FF		DEV_ERR         LDX     #$FF			; Error, unknown Device Type
  4082 F7B0 18			                CLC
  4083 F7B1 60			               	RTS
  4084
  4085 				;----------------------------------------------------------------------
  4086 				; This functions checks if the Device ID is correct
  4087 				;----------------------------------------------------------------------
  4088 F7B2 C9 30		DEV_CHECK       CMP     #STORAGE_DEV+$10	; Not too many devices?
  4089 F7B4 B0 F8				BCS     DEV_ERR			; branch if so
  4090 						
  4091 F7B6 C9 10				CMP     #COM_DEV		; Device ID too small?
  4092 F7B8 90 F4		                BCC     DEV_ERR			; branch if so
  4093 						
  4094 F7BA 0A			                ASL     			; Why?
  4095 F7BB A8			                TAY				; y = ID * 2
  4096 F7BC 38			                SEC				; No error
  4097 F7BD 60			                RTS				; return
  4098
  4099 				; **** Open Device Driver ******************************************************
  4100 				;
  4101 				; Input  - A : Device ID
  4102 				; Output - C = 1 Success, C = 0 Error
  4103 				;          X : Descriptor Address Low Byte
  4104 				;          Y : Descriptor Address High Byte
  4105 				;
  4106 				; ******************************************************************************
  4107 F7BE 20 B2 F7		DEV_OPEN        JSR     DEV_CHECK		; Check Device ID
  4108 F7C1 90 26		                BCC     END_DEV_OPEN		; exit if ID error
  4109 						
  4110 F7C3 B9 08 1A		                LDA     DEVLIST-$20,Y		; DEVLIST = $1A28, Y=2*Device ID, $1A48 ???
  4111 F7C6 D0 02		                BNE     DEV_OPEN1		
  4112 						
  4113 F7C8 A9 80		                LDA	#< NULL_DEV   		; no device found use NULL device
  4114 F7CA 85 DE		DEV_OPEN1       STA     PDEVL
  4115 F7CC B9 09 1A		                LDA     DEVLIST-$1F,Y		; Get MSB
  4116 F7CF D0 02		                BNE     DEV_OPEN2
  4117 						
  4118 F7D1 A9 F9		                LDA	#> NULL_DEV  		; no device found use NULL device
  4119 F7D3 85 DF		DEV_OPEN2       STA     PDEVH
  4120 F7D5 A0 02				LDY	#$02
  4121 F7D7 A2 00				LDX	#$00
  4122 F7D9 B1 DE		DEV_OPEN3	LDA	(PDEV),Y		; Start Input vector LSB
  4123 F7DB 9D 68 1A				STA	DEVIN,X			
  4124 F7DE C8					INY
  4125 F7DF E8					INX
  4126 F7E0 E0 06				CPX	#$06			; Copy Input, Output & Command vector
  4127 F7E2 D0 F5				BNE	DEV_OPEN3		; branch if not done yet
  4128 						
  4129 F7E4 A6 DE				LDX	PDEVL			; X = LSB of Descriptor Address
  4130 F7E6 A4 DF				LDY	PDEVH			; Y = MSB of Descriptor Address
  4131 F7E8 38					SEC				; No error
  4132 F7E9 60			END_DEV_OPEN    RTS				; Return
  4133
  4134 				; ******************************************************************************
  4135 				; Standard Driver Command Routines
  4136 				; ******************************************************************************
  4137
  4138 				; ******************************************************************************
  4139 				; XModem Command Interpreter
  4140 				; ******************************************************************************
  4141
  4142 F7EA C9 20		XMODEM_CMD	CMP	#CMD_LOAD
  4143 F7EC D0 03				BNE	XM_SAVE
  4144 F7EE 4C 15 F0				JMP	XModemRcv
  4145 F7F1 C9 21		XM_SAVE  	CMP	#CMD_SAVE
  4146 F7F3 D0 45				BNE     COM_CMD
  4147 F7F5 4C 06 F1				JMP	XModemSnd
  4148
  4149 				; ******************************************************************************
  4150 				; Tape Device Command Interpreter
  4151 				; ******************************************************************************
  4152
  4153 F7F8 C9 20		TAPE_CMD	CMP	#CMD_LOAD
  4154 F7FA D0 03				BNE	TP_SAVE
  4155 F7FC 4C 53 ED				JMP	TAPELOAD
  4156 F7FF C9 21		TP_SAVE 	CMP	#CMD_SAVE
  4157 F801 D0 37				BNE     COM_CMD
  4158 F803 4C 75 EE				JMP	TAPESAVE
  4159
  4160 				; ******************************************************************************
  4161 				; XSD_Card Command Interpreter
  4162 				; ******************************************************************************
  4163
  4164 F806 C9 00		SDC_CMD         CMP     #CMD_INIT
  4165 F808 D0 03		                BNE     SDC_READ
  4166 F80A 4C 68 F4		                JMP     SD_INIT
  4167 F80D C9 22		SDC_READ        CMP     #CMD_READ
  4168 F80F D0 03		                BNE     SDC_WRITE
  4169 F811 4C 3E F5		                JMP     SD_RD_LBLK
  4170 F814 C9 23		SDC_WRITE       CMP     #CMD_WRITE
  4171 F816 D0 03		                BNE     SDC_RD_BUF
  4172 F818 4C 76 F5		                JMP     SD_WR_LBLK
  4173 F81B C9 25		SDC_RD_BUF      CMP     #CMD_READ_BUF
  4174 F81D D0 03		                BNE     SDC_WR_BUF
  4175 F81F 4C 3B F5		                JMP     SD_RD_LBLK_BUF
  4176 F822 C9 26		SDC_WR_BUF      CMP     #CMD_WRITE_BUF
  4177 F824 D0 03		                BNE     SDC_SETADR
  4178 F826 4C 73 F5		                JMP     SD_WR_LBLK_BUF
  4179 F829 C9 10		SDC_SETADR      CMP     #CMD_SETSTARTADR
  4180 F82B D0 06		                BNE     SDC_BOOT
  4181 F82D 86 DC		                STX     BLKBUFL
  4182 F82F 84 DD		                STY     BLKBUFH
  4183 F831 38			                SEC
  4184 F832 60			                RTS
  4185 F833 C9 24		SDC_BOOT        CMP     #CMD_BOOT
  4186 F835 D0 17		                BNE     _EMPTY_
  4187 F837 4C 21 F6		                JMP     SD_BOOT
  4188
  4189 				; ******************************************************************************
  4190 				; Common Command Interpreter
  4191 				; ******************************************************************************
  4192
  4193 F83A C9 10		COM_CMD	        CMP	#CMD_SETSTARTADR
  4194 F83C D0 06				BNE     COM_SETENDADR
  4195 F83E 86 FA				STX	ADRL
  4196 F840 84 FB				STY	ADRH
  4197 F842 38					SEC
  4198 F843 60					RTS
  4199 F844 C9 11		COM_SETENDADR	CMP	#CMD_SETENDADR
  4200 F846 D0 06		                BNE     _EMPTY_
  4201 F848 86 F8				STX	NUML
  4202 F84A 84 F9				STY	NUMH
  4203 F84C 38					SEC
  4204 F84D 60					RTS
  4205
  4206 				; EMPTY Command Handler ********************************************************
  4207 F84E 18			_EMPTY_         CLC
  4208 F84F 60			_HANDLER_       RTS
  4209
  4210 				; Command Handler For Floppy Drive 2 *******************************************
  4211 F850 09 80		FGC_FDC_CMD2    ORA     #$80            ; set bit 7 of command byte (drive 2 operation)
  4212 F852 4C 17 10		                JMP     FGC_FDC_CMD     ; call command handler
  4213
  4214 				;----------------------------------------------------------------------------
  4215 				; This routine contains the entry routines for the CF-card routines
  4216 				;----------------------------------------------------------------------------
  4217 F855 C9 00		CFC_CMD         CMP     #CMD_INIT
  4218 F857 D0 03		                BNE     CFC_READ
  4219 F859 4C 8D F8		                JMP     CF_INIT		; Init. CF-card with HW-reset
  4220 F85C C9 22		CFC_READ        CMP     #CMD_READ
  4221 F85E D0 03		                BNE     CFC_WRITE
  4222 F860 4C BF FC		                JMP     CF_RD_LBLK	; used a lot in boot.sys and mkboot.sys
  4223 F863 C9 23		CFC_WRITE       CMP     #CMD_WRITE
  4224 F865 D0 03		                BNE     CFC_RD_BUF
  4225 F867 4C FA FC		                JMP     CF_WR_LBLK
  4226 F86A C9 25		CFC_RD_BUF      CMP     #CMD_READ_BUF
  4227 F86C D0 03		                BNE     CFC_WR_BUF
  4228 F86E 4C BC FC		                JMP     CF_RD_LBLK_BUF
  4229 F871 C9 26		CFC_WR_BUF      CMP     #CMD_WRITE_BUF
  4230 F873 D0 03		                BNE     CFC_LOAD
  4231 F875 4C F7 FC		                JMP     CF_WR_LBLK_BUF
  4232 F878 C9 20		CFC_LOAD	CMP	#CMD_LOAD
  4233 F87A D0 03				BNE	CFC_SAVE
  4234 F87C 6C 06 18				JMP	(CF_LOAD_VEC)	; Filled in by boot.sys
  4235 F87F C9 21		CFC_SAVE	CMP	#CMD_SAVE
  4236 F881 D0 03				BNE	CFC_BOOT
  4237 F883 6C 08 18				JMP	(CF_SAVE_VEC)	; Filled in by boot.sys
  4238 F886 C9 24		CFC_BOOT        CMP     #CMD_BOOT
  4239 F888 D0 C4		                BNE     _EMPTY_
  4240 F88A 4C 04 F9		                JMP     CF_BOOT
  4241
  4242 				; ******************************************************************************
  4243 				; CF-Card Driver Routines
  4244 				; ******************************************************************************
  4245 				;----------------------------------------------------------------------------
  4246 				; Command: CMD_INIT, Initialize CF-Card
  4247 				; Output : C = 1 Init OK, C = 0 Error
  4248 				;----------------------------------------------------------------------------
  4249 F88D A9 00		CF_INIT		LDA #$00		; Reset command
  4250 F88F 8D 88 0C		                STA CFREG8		; HW reset command
  4251 F892 A9 01				LDA #1
  4252 F894 85 D7				STA RSTACT		; 1 = Reset pending
  4253 F896 20 B5 F8				JSR CFWAIT
  4254 F899 B0 03				BCS INITOK		; branch if CF-card init OK
  4255 						
  4256 F89B A9 80		CF_ERR		LDA #$80
  4257 F89D 60					RTS			; return if error (C=0)
  4258 						
  4259 F89E A9 E0		INITOK		LDA #$E0		; LBA3=0, Master, Mode=LBA
  4260 F8A0 8D 86 0C				STA CFREG6
  4261 F8A3 A9 01				LDA #$01		; 8-bit transfers
  4262 F8A5 8D 81 0C				STA CFREG1
  4263 F8A8 A9 EF				LDA #$EF		; Set feature command
  4264 F8AA 8D 87 0C				STA CFREG7		; CF command register
  4265 F8AD 20 B5 F8				JSR CFWAIT		; Wait and return
  4266 F8B0 90 E9				BCC CF_ERR		; branch if Error
  4267 						
  4268 F8B2 4C 00 FC				JMP CF_INFO		; Print CF-Card Info, returns with C=1 (OK)
  4269
  4270 				;----------------------------------------------------------------------------
  4271 				; This routine waits until the CF-card is ready.
  4272 				;----------------------------------------------------------------------------
  4273 F8B5 A9 00		CFWAIT		LDA #0
  4274 F8B7 85 D6				STA MSEC		; msec counter
  4275 F8B9 A5 D7		CFWLP		LDA RSTACT		; 1 = Reset pending
  4276 F8BB F0 05				BEQ NO_DLY10		; branch if no 10 msec. delay needed
  4277 						
  4278 F8BD A9 0A				LDA #10			; delay = 10 msec.
  4279 F8BF 20 4D E1				JSR DELAY		; delay 10 msec.
  4280 F8C2 E6 D6		NO_DLY10	INC MSEC		; msec-counter
  4281 F8C4 A5 D6				LDA MSEC
  4282 F8C6 F0 2D				BEQ CFWLPTO		; branch after 2550 msec. and no reset
  4283 						
  4284 F8C8 AD 87 0C				LDA CFREG7		; read status register
  4285 F8CB 29 80				AND #$80		; check busy flag
  4286 F8CD D0 EA				BNE CFWLP		; branch if BSY flag is still set
  4287 						
  4288 						; Busy flag cleared
  4289 F8CF AD 87 0C				LDA CFREG7		; read status register
  4290 F8D2 29 50				AND #$50		; check for RDY and DSC flags
  4291 F8D4 C9 50				CMP #$50		; BSY and DSC flags both set?
  4292 F8D6 D0 E1				BNE CFWLP		; branch if RDY and DSC not both set
  4293
  4294 F8D8 A5 D7				LDA RSTACT		; 1 = Reset pending
  4295 F8DA F0 17				BEQ PRENDOK		; branch if no Reset pending
  4296 						
  4297 F8DC A9 00				LDA #0
  4298 F8DE 85 D7				STA RSTACT		; Reset no longer pending
  4299 F8E0 A2 32				LDX #<TXT_RSTOK     	; Print Reset OK + msec
  4300 F8E2 A0 F9				LDY #>TXT_RSTOK
  4301 F8E4 20 82 F6				JSR SPRINT	    	; print
  4302 F8E7 A5 D6				LDA MSEC		; #msec. * 10
  4303 F8E9 20 A7 E0				JSR NUMOUT		; Print decimal number
  4304 F8EC A2 3F				LDX #<TXT_MSEC     	; Print msec
  4305 F8EE A0 F9				LDY #>TXT_MSEC
  4306 F8F0 20 82 F6				JSR SPRINT	    	; print
  4307 F8F3 38			PRENDOK		SEC			; C=1, no error
  4308 F8F4 60					RTS			; return if BSY=0 and RDY=DSC=1
  4309 					
  4310 F8F5 A2 48		CFWLPTO		LDX #<TXT_HWERR     	; Print HW error
  4311 F8F7 A0 F9				LDY #>TXT_HWERR
  4312 F8F9 20 82 F6				JSR SPRINT	    	; print		
  4313 F8FC AD 87 0C				LDA CFREG7		; Status register
  4314 F8FF 20 91 E0				JSR HEXOUT		; Print and return
  4315 F902 18					CLC			; C=0, error
  4316 F903 60			CF_END		RTS			; return
  4317
  4318 				;-------------------------------------------------------------------------------
  4319 				; CF-Card Boot Routine
  4320 				;-------------------------------------------------------------------------------
  4321 F904 20 78 FC		CF_BOOT         JSR	INIT_LBA		; CFLBA0..CFLBA3 = 0 (MBR) and load into CF-card
  4322 F907 20 B7 FC				JSR	CF_RD_BLK_BUF		; Read MBR and store in BLOCK_BUF ($0600)
  4323 F90A 90 F7				BCC     CF_END                  ; error reading MBR. Exit
  4324 						
  4325 F90C 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  4326 F90F 90 F2				BCC	CF_END			; branch if error
  4327 						
  4328 F911 A0 40				LDY     #CFCDEV-STRINGP2        ; load pointer to device name
  4329 F913 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  4330
  4331 				;-------------------------------------------------------------------------------
  4332 				; Init CFC-card, this is called from within MAIN loop.
  4333 				; The first instruction comes from the beginning of the MAIN routine and 
  4334 				; ensures that addresses do not change in a new firmware version
  4335 				;-------------------------------------------------------------------------------
  4336 F916 20 55 E5		INIT_CFC	JSR     WRITE_IO_INFO		; instruction from MAIN routine
  4337 F919 20 A1 FD				JSR	CHECK_ROMS		; Check ROM checksum
  4338 F91C A2 D0				LDX     #<CFC_DEV
  4339 F91E A0 F9		                LDY     #>CFC_DEV
  4340 F920 4C 6F F7		                JMP     DEV_ADD         	; add CF-card driver and return
  4341
  4342 				;----------------------------------------------------------------------------------		
  4343 				; This routine is the same for both the CF and SD cards. It displays the device ID
  4344 				;----------------------------------------------------------------------------------		
  4345 F923 20 D9 F6		DISP_DVC        JSR     SYS_MSG                 ; print device name to screen
  4346 F926 A9 5F		                LDA     #'_'
  4347 F928 20 52 E0		                JSR     COUT
  4348 F92B A5 EE		                LDA     PSAV                    ; add partition number to name (_1.._4)
  4349 F92D 20 52 E0		                JSR     COUT
  4350 F930 38			                SEC                             ; normal boot, set carry flag
  4351 F931 60			                RTS
  4352
  4353 F932 0D 20 43 46 20 52 + TXT_RSTOK       .by     CR ' CF Reset: ' $00
  4354 F93F 30 20 6D 73 65 63 + TXT_MSEC	.by	'0 msec.' CR $00
  4355 F948 4E 6F 20 43 46 20 + TXT_HWERR       .by     'No CF Reset, Status=$' $00
  4356
  4357 				; **** VPU IRQ Routine *********************************************************
  4358 				; ******************************************************************************
  4359 F95E			                ORG     $F960
  4360
  4361 F960 48			VPU_IRQ         PHA
  4362 F961 A9 00		                LDA     #VPU_STAT0
  4363 F963 8D 09 10		                STA     VPU_PORT1
  4364 F966 A9 8F		                LDA     #VPU_REG15
  4365 F968 8D 09 10		                STA     VPU_PORT1
  4366 F96B AD 09 10		                LDA     VPU_PORT1       ; is it a line interrupt?
  4367 F96E 10 08		                BPL     NO_VPU_IRQ      ; no, exit
  4368 F970 A5 DA		                LDA     TICKCNT         ; yes, load the tick counter
  4369 F972 F0 02				BEQ     IRQ_END         ; is it 0?
  4370 F974 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  4371 F976 68			IRQ_END         PLA
  4372 F977 40			                RTI
  4373 F978 68			NO_VPU_IRQ	PLA			; restore accumulator
  4374 F979 4C 18 F3				JMP	IRQ		; call user interrupt routine
  4375
  4376 				; ******************************************************************************
  4377 				; Standard Driver Descriptors
  4378 				; ******************************************************************************
  4379
  4380 F97C			                ORG     $FA00-16*8
  4381
  4382 F980 00 00		NULL_DEV	.byte	NULL_ID, $00     ; Null Device Driver Descriptor
  4383 F982 4E F8				.word	_EMPTY_
  4384 F984 4E F8				.word	_EMPTY_
  4385 F986 4E F8				.word	_EMPTY_
  4386
  4387 F988 10 00		TTY_DEV		.byte	TTY1_ID, $00     ; Terminal Driver Descriptor
  4388 F98A 75 F3				.word	SERIALIN
  4389 F98C 65 F3				.word	SERIALOUT
  4390 F98E E2 E1				.word	TTY_CMD
  4391
  4392 F990 11 00		PPRINT_DEV	.byte	PRINTER1_ID, $00 ; Parallel Printer Driver Descriptor
  4393 F992 4E F8				.word	_EMPTY_
  4394 F994 D2 F3				.word	PPORTOUT
  4395 F996 4E F8				.word	_EMPTY_
  4396
  4397 F998 13 00		KEYBD_DEV       .byte	KEYBD1_ID, $00   ; ASCII Keyboard Driver Descriptor
  4398 F99A 82 F3				.word	ASCIIKBD
  4399 F99C 4E F8				.word	_EMPTY_
  4400 F99E 4E F8				.word	_EMPTY_
  4401
  4402 F9A0 15 00		VDP_DEV         .byte	VDP1_ID, $00     ; Video Display Processor Driver Descriptor
  4403 F9A2 9A F3				.word   PS2KBD
  4404 F9A4 27 10		                .word   FGC_VPU_OUT
  4405 F9A6 1F 10				.word   FGC_VPU_CMD
  4406
  4407 F9A8 20 00		XMODEM_DEV	.byte	XMODEM1_ID, $00  ; XModem Device Driver Descriptor
  4408 F9AA 75 F3				.word	SERIALIN
  4409 F9AC 65 F3				.word	SERIALOUT
  4410 F9AE EA F7				.word	XMODEM_CMD
  4411
  4412 F9B0 21 00		TAPE_DEV	.byte	TAPE1_ID, $00    ; Tape Device Driver Descriptor
  4413 F9B2 4E F8				.word	_EMPTY_
  4414 F9B4 4E F8				.word	_EMPTY_
  4415 F9B6 F8 F7				.word	TAPE_CMD
  4416
  4417 F9B8 24 00		SDC_DEV	        .byte	SDC1_ID, $00     ; SD-Card Driver Descriptor
  4418 F9BA 4E F8				.word	_EMPTY_
  4419 F9BC 4E F8				.word	_EMPTY_
  4420 F9BE 06 F8				.word   SDC_CMD
  4421
  4422 F9C0 22 00		FDD1_DEV	.byte	FDD1_ID, $00     ; Floppy Disk Drive 1 Driver Descriptor
  4423 F9C2 4E F8				.word	_EMPTY_
  4424 F9C4 4E F8				.word	_EMPTY_
  4425 F9C6 17 10				.word   FGC_FDC_CMD
  4426
  4427 F9C8 23 00		FDD2_DEV	.byte	FDD2_ID, $00     ; Floppy Disk Drive 2 Driver Descriptor
  4428 F9CA 4E F8				.word	_EMPTY_
  4429 F9CC 4E F8				.word	_EMPTY_
  4430 F9CE 50 F8				.word   FGC_FDC_CMD2
  4431
  4432 F9D0 25 00		CFC_DEV	        .byte	HDD1_ID, $00     ; CF-Card Driver Descriptor
  4433 F9D2 4E F8				.word	_EMPTY_
  4434 F9D4 4E F8				.word	_EMPTY_
  4435 F9D6 55 F8				.word   CFC_CMD		 ; CF-card driver descriptor
  4436
  4437 				; ******************************************************************************
  4438 				; Low Byte CRC Lookup Table (XMODEM)
  4439 				; ******************************************************************************
  4440
  4441 F9D8			                ORG 	$FA00
  4442 FA00			CRCLO
  4443 FA00 00 21 42 63 84 A5 +  		.byte 	$00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
  4444 FA10 31 10 73 52 B5 94 +  		.byte 	$31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
  4445 FA20 62 43 20 01 E6 C7 +  		.byte 	$62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
  4446 FA30 53 72 11 30 D7 F6 +  		.byte 	$53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
  4447 FA40 C4 E5 86 A7 40 61 +  		.byte 	$C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
  4448 FA50 F5 D4 B7 96 71 50 +  		.byte 	$F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
  4449 FA60 A6 87 E4 C5 22 03 +  		.byte 	$A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
  4450 FA70 97 B6 D5 F4 13 32 +  		.byte 	$97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
  4451 FA80 88 A9 CA EB 0C 2D +  		.byte 	$88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
  4452 FA90 B9 98 FB DA 3D 1C +  		.byte 	$B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
  4453 FAA0 EA CB A8 89 6E 4F +  		.byte 	$EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
  4454 FAB0 DB FA 99 B8 5F 7E +  		.byte 	$DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
  4455 FAC0 4C 6D 0E 2F C8 E9 +  		.byte 	$4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
  4456 FAD0 7D 5C 3F 1E F9 D8 +  		.byte 	$7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
  4457 FAE0 2E 0F 6C 4D AA 8B +  		.byte 	$2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
  4458 FAF0 1F 3E 5D 7C 9B BA +  		.byte 	$1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
  4459
  4460 				; ******************************************************************************
  4461 				; Hi Byte CRC Lookup Table (XMODEM)
  4462 				; ******************************************************************************
  4463
  4464 FB00			                ORG 	$FB00
  4465 FB00			CRCHI
  4466 FB00 00 10 20 30 40 50 +  		.byte 	$00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
  4467 FB10 12 02 32 22 52 42 +  		.byte 	$12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
  4468 FB20 24 34 04 14 64 74 +  		.byte 	$24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
  4469 FB30 36 26 16 06 76 66 +  		.byte 	$36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
  4470 FB40 48 58 68 78 08 18 +  		.byte 	$48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
  4471 FB50 5A 4A 7A 6A 1A 0A +  		.byte 	$5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
  4472 FB60 6C 7C 4C 5C 2C 3C +  		.byte 	$6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
  4473 FB70 7E 6E 5E 4E 3E 2E +  		.byte 	$7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
  4474 FB80 91 81 B1 A1 D1 C1 +  		.byte 	$91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
  4475 FB90 83 93 A3 B3 C3 D3 +  		.byte 	$83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
  4476 FBA0 B5 A5 95 85 F5 E5 +  		.byte 	$B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
  4477 FBB0 A7 B7 87 97 E7 F7 +  		.byte 	$A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
  4478 FBC0 D9 C9 F9 E9 99 89 +  		.byte 	$D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
  4479 FBD0 CB DB EB FB 8B 9B +  		.byte 	$CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
  4480 FBE0 FD ED DD CD BD AD +  		.byte 	$FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
  4481 FBF0 EF FF CF DF AF BF +  		.byte 	$EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
    60
    61 FC00					ORG	$FC00			; start address of CF-IDE and MMU routines
    62 FC00					icl	"jc2_cf_ide.asm"	; cf-ide and MMU routines
Source: jc2_cf_ide.asm
     1 				;---------------------------------------------------------------------------
     2 				; JC2 CF-IDE Device Driver & MMU related functions.
     3 				; This program adds the necessary files for the CF-IDE Interface and the
     4 				; MMU related routines. 
     5 				;---------------------------------------------------------------------------
     6
     7 				;----------------------------------------------------------------------------
     8 				; This routine reads CF information and prints it.
     9 				;----------------------------------------------------------------------------
    10 FC00 20 B5 F8		CF_INFO		JSR CFWAIT	    	; Wait until CF-card ready
    11 FC03 A9 EC				LDA #$EC	    	; Drive ID command
    12 FC05 8D 87 0C				STA CFREG7		; CF command register
    13 FC08 20 8B F6				JSR INIT_BLKBUF		; Init. buffer-pointer
    14 FC0B 20 D1 FC				JSR CF_RD_INFO		; Read 512 bytes (= CF_RD_BLK without the Read 1 sector commands)
    15
    16 				; Print serial number
    17 FC0E A2 2D				LDX #<TXT_SER     	; Print Serial text
    18 FC10 A0 FD				LDY #>TXT_SER
    19 FC12 20 82 F6				JSR SPRINT	    	; print
    20 FC15 A9 14				LDA #<(BLOCK_BUF+20)
    21 FC17 85 DC				STA BLKBUF
    22 FC19 A9 06				LDA #>(BLOCK_BUF+20)
    23 FC1B 85 DD				STA BLKBUF+1
    24 FC1D A2 14				LDX #20			; len = 20
    25 FC1F 20 4F FC				JSR PRTRSN		; Print serial-number info
    26
    27 				; Print Firmware revision
    28 FC22 A2 39				LDX #<TXT_FW     	; Print Firmware text
    29 FC24 A0 FD				LDY #>TXT_FW
    30 FC26 20 82 F6				JSR SPRINT	    	; print
    31 FC29 A9 2E				LDA #<(BLOCK_BUF+46)
    32 FC2B 85 DC				STA BLKBUF
    33 FC2D A9 06				LDA #>(BLOCK_BUF+46)
    34 FC2F 85 DD				STA BLKBUF+1
    35 FC31 A2 08				LDX #8			; len = 8
    36 FC33 20 4F FC				JSR PRTRSN		; Print firmware info
    37
    38 				; Print Model number
    39 FC36 A2 46				LDX #<TXT_MOD     	; Print Model number text
    40 FC38 A0 FD				LDY #>TXT_MOD
    41 FC3A 20 82 F6				JSR SPRINT	    	; print
    42 FC3D A9 36				LDA #<(BLOCK_BUF+54)
    43 FC3F 85 DC				STA BLKBUF
    44 FC41 A9 06				LDA #>(BLOCK_BUF+54)
    45 FC43 85 DD				STA BLKBUF+1
    46 FC45 A2 28				LDX #40			; len = 40
    47 FC47 20 4F FC				JSR PRTRSN		; Print firmware info
    48 FC4A 20 5A E0				JSR CROUT		; Print CR
    49 FC4D 38					SEC			; C=1 (no error)
    50 FC4E 60					RTS
    51
    52 				;----------------------------------------------------------------------------
    53 				; This routine print a Big-Endian string of N characters, skipping all spaces.
    54 				; BUFPTR: points to begin of buffer to print
    55 				; X     : #bytes to print
    56 				;----------------------------------------------------------------------------
    57 FC4F A0 01		PRTRSN		LDY #1			; start at MSB
    58 FC51 B1 DC		PRTRSN1		LDA (BLKBUF),Y		; get MSB 		
    59 FC53 C9 20				CMP #' '		; skip if space
    60 FC55 F0 03				BEQ PRSNLP2		; branch if space
    61
    62 FC57 20 6C FC				JSR COUTXY		; output MSB to screen
    63 FC5A 88			PRSNLP2		DEY			; LSB now
    64 FC5B CA					DEX			; #bytes to print
    65 FC5C B1 DC				LDA (BLKBUF),Y		
    66 FC5E C9 20				CMP #' '		; skip if space
    67 FC60 F0 03				BEQ PRSNLP3		; branch if space
    68
    69 FC62 20 6C FC				JSR COUTXY		; output LSB to screen
    70 FC65 C8			PRSNLP3		INY			; 
    71 FC66 C8					INY			; points to next LSB
    72 FC67 C8					INY			; points to next MSB
    73 FC68 CA					DEX			; #bytes to print
    74 FC69 D0 E6				BNE PRTRSN1		; branch if more to print
    75 						
    76 FC6B 60					RTS			; return
    77
    78 				;----------------------------------------------------------------------------
    79 				; This routine calls COUT while preserving the values of X and Y
    80 				;----------------------------------------------------------------------------
    81 FC6C 86 D8		COUTXY		STX SAVEX		; Save X	
    82 FC6E 84 D9				STY SAVEY		; Save Y
    83 FC70 20 52 E0				JSR COUT		; Print char.
    84 FC73 A4 D9				LDY SAVEY		; Get Y back
    85 FC75 A6 D8				LDX SAVEX		; Get X back
    86 FC77 60					RTS			; return
    87
    88 				;----------------------------------------------------------------------------
    89 				; This routine sets the LBA for the CF-card to 0 (the MBR) and loads it
    90 				; into the CF-card.
    91 				;----------------------------------------------------------------------------
    92 FC78 A9 00		INIT_LBA	LDA #0
    93 FC7A 85 D2				STA CFLBA0	    	; LBA 0 (LSB)
    94 FC7C 85 D3				STA CFLBA1
    95 FC7E 85 D4				STA CFLBA2
    96 FC80 85 D5				STA CFLBA3		; LBA 3 (MSB)
    97 FC82 4C 9E FC				JMP LOAD_CFLBA		; Load into CF-card and return
    98
    99 				;----------------------------------------------------------------------------
   100 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   101 				; Input :  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
   102 				; Output: LBA in CFLBA3..CFLBA0
   103 				;----------------------------------------------------------------------------
   104 FC85 86 E6		LOAD_LBA_CF	STX PLBA		; Store pointer
   105 FC87 84 E7				STY PLBA+1
   106 FC89 A0 00				LDY #0
   107 FC8B B1 E6				LDA (PLBA),Y		; LBA 0 (LSB)
   108 FC8D 85 D2				STA CFLBA0
   109 FC8F C8					INY
   110 FC90 B1 E6				LDA (PLBA),Y		; LBA 1
   111 FC92 85 D3				STA CFLBA1
   112 FC94 C8					INY
   113 FC95 B1 E6				LDA (PLBA),Y		; LBA 2
   114 FC97 85 D4				STA CFLBA2
   115 FC99 C8					INY
   116 FC9A B1 E6				LDA (PLBA),Y		; LBA 3 (MSB)
   117 FC9C 85 D5				STA CFLBA3
   118 						;JMP LOAD_CFLBA		; Load into CF-card and return
   119
   120 				;----------------------------------------------------------------------------
   121 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   122 				; Input : CFLBA3..CFLBA0
   123 				; Output: -
   124 				;----------------------------------------------------------------------------
   125 FC9E A5 D2		LOAD_CFLBA	LDA CFLBA0		; CFLBA0 -> CFREG3
   126 FCA0 8D 83 0C				STA CFREG3		; 
   127 FCA3 A5 D3				LDA CFLBA1		; CFLBA1 -> CFREG4
   128 FCA5 8D 84 0C				STA CFREG4
   129 FCA8 A5 D4				LDA CFLBA2		; CFLBA2 -> CFREG5
   130 FCAA 8D 85 0C				STA CFREG5
   131 FCAD A5 D5				LDA CFLBA3		; CFLBA3 -> CFREG6
   132 FCAF 29 0F				AND #$0F		; Filter out LBA bits
   133 FCB1 09 E0				ORA #$E0		; Mode LBA, master dev
   134 FCB3 8D 86 0C				STA CFREG6		; Store in CFREG6
   135 FCB6 60					RTS
   136 						
   137 				;----------------------------------------------------------------------------
   138 				; Command: None, Read Single Data Block to Std. Block Buffer
   139 				; Input  : CFLBA3..CFLBA0 = 32 Bit Command Block Source Address. 
   140 				;          NOTE: These have to loaded prior to calling this function!!!
   141 				; Output : C = 0 Error, C = 1 Read OK
   142 				;	   A = Error Code
   143 				;----------------------------------------------------------------------------
   144 FCB7 20 8B F6		CF_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   145 FCBA F0 06				BEQ	CF_RD_BLK		; branch always
   146
   147 				;----------------------------------------------------------------------------
   148 				; Command: CMD_READ_BUF, Read Single Data Block from Logical Address to Std. Block Buffer
   149 				; Input  :  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   150 				; Output :  C   = 0 Error, C = 1 Data OK
   151 				;	    A   = Error Code
   152 				;----------------------------------------------------------------------------
   153 FCBC 20 8B F6		CF_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   154 										; fall through to CF_RD_LBLK
   155
   156 				;----------------------------------------------------------------------------
   157 				; Command: CMD_READ, Read Single Data Block from Logical Address
   158 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   159 				;	   BLKBUF,BLKBUFH = 16 Bit Destination Address
   160 				; Output : C = 0 Error, C = 1 Data OK
   161 				;	   A = Error Code
   162 				;----------------------------------------------------------------------------
   163 FCBF 20 85 FC		CF_RD_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   164 										; fall through to CF_RD_BLK
   165
   166 				;----------------------------------------------------------------------------
   167 				; Read Single Data Block
   168 				; Input:  CFLBA3..CFLBA0 = 32 Bit LBA Address
   169 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
   170 				; Output: C = 0 Error, C = 1 Read OK
   171 				;	  A = Error Code
   172 				;----------------------------------------------------------------------------
   173 FCC2 A9 01		CF_RD_BLK	LDA 	#$01
   174 FCC4 8D 82 0C				STA 	CFREG2			; Read one Sector
   175 FCC7 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   176 FCCA 90 24				BCC 	CF_RD_END		; branch on error
   177
   178 FCCC A9 20				LDA 	#$20			; Read Sector Command
   179 FCCE 8D 87 0C				STA 	CFREG7			; CF command register
   180 FCD1 A2 01		CF_RD_INFO	LDX	#$01			; initialize page counter
   181 FCD3 A0 00				LDY	#$00			; initialize byte counter
   182 FCD5 20 B5 F8		CF_RD_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   183 FCD8 90 16				BCC	CF_RD_END		; Exit on CF-card error
   184
   185 FCDA AD 87 0C				LDA 	CFREG7			; CF status register
   186 FCDD 29 08				AND 	#$08			; Filter out DRQ
   187 FCDF F0 0F				BEQ 	CF_RD_END		; branch if DRQ is no longer set
   188
   189 FCE1 AD 80 0C				LDA 	CFREG0			; read data-bytes
   190 FCE4 91 DC				STA 	(BLKBUF),Y		; store in buffer
   191 FCE6 C8					INY				; next byte
   192 FCE7 D0 EC				BNE 	CF_RD_BLK0		; branch if more bytes to read
   193
   194 FCE9 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   195 FCEB CA					DEX
   196 FCEC 10 E7				BPL	CF_RD_BLK0		; two pages read? no, read next byte
   197 						
   198 FCEE 38					SEC				; yes, all data read, set C = 1 (no error)
   199 FCEF 60					RTS
   200 FCF0 18			CF_RD_END	CLC				; C=0 (error), DRQ reset should not happen
   201 FCF1 60					RTS
   202
   203 				;----------------------------------------------------------------------------
   204 				; Command: None, Write Single Data Block from Std. Block Buffer
   205 				; Input  : CFLBA3..CFLBA0 = 32 Bit LBA Address to write to
   206 				;          NOTE: These have to loaded prior to calling this function!!!
   207 				; Output : C = 0 Error, C = 1 Read OK
   208 				;	   A = Error Code
   209 				;----------------------------------------------------------------------------
   210 FCF2 20 8B F6		CF_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   211 FCF5 F0 06				BEQ	CF_WR_BLK		; branch always
   212
   213 				;----------------------------------------------------------------------------
   214 				; Command: WRITE_BUF, Write Single Data Block from Std. Block Buffer to Logical Address
   215 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   216 				; Output : C = 0 Error, C = 1 Data OK
   217 				;	   A = Error Code
   218 				;----------------------------------------------------------------------------
   219 FCF7 20 8B F6		CF_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   220 										; fall through to CR_WR_LBLK
   221
   222 				;----------------------------------------------------------------------------
   223 				; Command: CMD_WRITE, Write Single Data Block to Logical Address
   224 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   225 				;	   BLKBUF,BLKBUFH = 16 Bit Source Address
   226 				; Output : C = 0 Error, C = 1 Data OK
   227 				;	   A = Error Code
   228 				;----------------------------------------------------------------------------
   229 FCFA 20 85 FC		CF_WR_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   230 										; fall through to CF_WR_BLK
   231
   232 				;----------------------------------------------------------------------------
   233 				; Write Single Data Block
   234 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   235 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
   236 				; Output: C = 0 Error, C = 1 Write OK
   237 				;	  A = Error Code
   238 				;----------------------------------------------------------------------------
   239 FCFD A9 01		CF_WR_BLK	LDA 	#$01
   240 FCFF 8D 82 0C				STA 	CFREG2			; Read one Sector
   241 FD02 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   242 FD05 90 24				BCC 	CF_WR_END		; branch on error
   243
   244 FD07 A9 30				LDA 	#$30			; Write Sector Command
   245 FD09 8D 87 0C				STA 	CFREG7			; CF command register
   246 FD0C A2 01		CF_WR_INFO	LDX	#$01			; initialize page counter
   247 FD0E A0 00				LDY	#$00			; initialize byte counter
   248 FD10 20 B5 F8		CF_WR_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   249 FD13 90 16				BCC	CF_WR_END		; Exit on CF-card error
   250
   251 FD15 AD 87 0C				LDA 	CFREG7			; CF status register
   252 FD18 29 08				AND 	#$08			; Filter out DRQ
   253 FD1A F0 0F				BEQ 	CF_WR_END		; branch if DRQ is no longer set
   254
   255 FD1C B1 DC				LDA 	(BLKBUF),Y		; read from buffer
   256 FD1E 8D 80 0C				STA 	CFREG0			; Write to CF-card
   257 FD21 C8					INY				; next byte
   258 FD22 D0 EC				BNE 	CF_WR_BLK0		; branch if more bytes to write
   259
   260 FD24 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   261 FD26 CA					DEX
   262 FD27 10 E7				BPL	CF_WR_BLK0		; two pages read? no, read next byte
   263 						
   264 FD29 38					SEC				; yes, all data read, set C = 1 (no error)
   265 FD2A 60					RTS
   266 						
   267 FD2B 18			CF_WR_END	CLC				; C=0 (error), DRQ reset should not happen
   268 FD2C 60					RTS
   269
   270 				;----------------------------------------------------------------------------
   271 				; Text-strings needed for Printing
   272 				;----------------------------------------------------------------------------
   273 FD2D 20 20 20 53 65 72 + TXT_SER		.by        '   Serial: ' $00
   274 FD39 0D 20 46 69 72 6D + TXT_FW		.by     CR ' Firmware: ' $00
   275 FD46 0D 20 20 20 20 4D + TXT_MOD		.by     CR '    Model: ' $00
   276
   277 				;----------------------------------------------------------------------------
   278 				; This function enables a RAM-bank at $4000-$7FFF.
   279 				; Input: X: the RAM-bank number to enable [0..28]. A RAM-bank starts at 4,
   280 				;           so 0..3 disables the RAM-banks and enables main-memory
   281 				;----------------------------------------------------------------------------
   282 FD53 AD 00 17		SET_RAMBANK	LDA	MMU		; Get MMU register
   283 FD56 29 83				AND	#$83		; Set RAM-bank bits 6..2 to 0
   284 FD58 8D 00 17				STA	MMU		; Update MMU register
   285 FD5B 8A					TXA			; A is now RAM-bank number
   286 FD5C C9 1D				CMP	#29		; RAM-bank 28 is the highest nr
   287 FD5E B0 04				BCS	SET_RAMB0	; branch if >= 29
   288 FD60 C9 04				CMP	#4		; <= 28, now check for >= 4
   289 FD62 B0 02				BCS	RAMBVLD		; branch if >= 4
   290 						
   291 FD64 A9 00		SET_RAMB0	LDA	#0		; set to no RAM-bank (main-memory)
   292 FD66 0A			RAMBVLD		ASL
   293 FD67 0A					ASL			; nr now in RAM-bank bits 6..2
   294 FD68 0D 00 17				ORA	MMU		; add to MMU-register
   295 FD6B 8D 00 17				STA	MMU		; Enable RAM-bank
   296 FD6E 60					RTS			; return
   297 						
   298 				;----------------------------------------------------------------------------
   299 				; This function returns the currently active RAM-bank at $4000-$7FFF.
   300 				; Output: A: the active RAM-bank number [4..28] or 0 if no RAM-bank is selected.
   301 				;----------------------------------------------------------------------------
   302 FD6F AD 00 17		GET_RAMBANK	LDA	MMU		; MMU-register
   303 FD72 29 7C				AND	#$7C		; Only RAM-bank bits
   304 FD74 4A					LSR
   305 FD75 4A					LSR			; Now in bits 4..0
   306 FD76 C9 04				CMP	#4		; Is it 4 or more?
   307 FD78 B0 02				BCS	RAMBX		; branch if >= 4, RAM-bank selected
   308 						
   309 FD7A A9 00				LDA	#0		; RAM-bank 0..3 => main memory
   310 FD7C 60			RAMBX		RTS			; return		
   311 						
   312 				;----------------------------------------------------------------------------
   313 				; This function enables Monitor-ROM at $1C00-$1FFF and disables the RAM behind it.
   314 				;----------------------------------------------------------------------------
   315 FD7D AD 00 17		MON2ROM		LDA	MMU		; MMU-register
   316 FD80 09 02				ORA	#MON_EN		; 1 = enable Monitor ROM
   317 FD82 8D 00 17				STA	MMU		; Activate Monitor ROM
   318 FD85 60					RTS			; return
   319 						
   320 				;----------------------------------------------------------------------------
   321 				; This function Enables Monitor-RAM at $1C00-$1FFF and disables Monitor-ROM.
   322 				;----------------------------------------------------------------------------
   323 FD86 AD 00 17		MON2RAM		LDA	MMU		; MMU-register
   324 FD89 29 FD				AND	#~MON_EN	; 0 = enable Monitor RAM, disable ROM
   325 FD8B 8D 00 17				STA	MMU		; Activate Monitor RAM
   326 FD8E 60					RTS			; return
   327
   328 				;----------------------------------------------------------------------------------		
   329 				; This routine disables the BASIC ROM and enables the RAM behind it.
   330 				;----------------------------------------------------------------------------------		
   331 FD8F AD 00 17		BAS2RAM		LDA	MMU			; MMU register		
   332 FD92 29 7F				AND 	#~BAS_EN		; Set bit to 0, disable BASIC		   
   333 FD94 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   334 FD97 60					RTS				; return
   335
   336 				;----------------------------------------------------------------------------------		
   337 				; This routine enables the BASIC ROM and disables the RAM behind it.
   338 				;----------------------------------------------------------------------------------		
   339 FD98 AD 00 17		BAS2ROM		LDA	MMU			; MMU register		
   340 FD9B 09 80				ORA 	#BAS_EN			; Set bit to 0, disable BASIC		   
   341 FD9D 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   342 FDA0 60					RTS				; return
   343
   344 				;----------------------------------------------------------------------------
   345 				; Check both ROMs: 
   346 				; 1) Monitor ROM at $1C00-$1FFF
   347 				; 2) BASIC + BIOS ROM at $B000-$FFF0
   348 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   349 				;        X: LSB of end-Address
   350 				;        Y: MSB of end-Address
   351 				;----------------------------------------------------------------------------
   352 FDA1 A9 1C		CHECK_ROMS	LDA	#$1C		; MSB of $1C00
   353 FDA3 A2 00				LDX	#$00		; LSB of $1FFF+1 (end-address)
   354 FDA5 A0 20				LDY	#$20		; MSB of $1FFF+1 (end-address)
   355 FDA7 20 B9 FD				JSR	CHECK_ROM_STRT	; Check Monitor ROM Checksum
   356 FDAA A9 B0				LDA	#$B0		; MSB of $B000
   357 FDAC A2 00				LDX	#$00		; LSB of $DFFF+1 (end-address)
   358 FDAE A0 E0				LDY	#$E0		; MSB of $DFFF+1 (end-address)
   359 FDB0 20 B9 FD				JSR	CHECK_ROM_STRT	; Check BASIC ROM Checksum
   360 FDB3 A9 E0				LDA	#$E0		; MSB of $B000
   361 FDB5 A2 F0				LDX	#$F0		; LSB of $FFF0 (end-address)
   362 FDB7 A0 FF				LDY	#$FF		; MSB of $FFF0 (end-address)
   363 						;JMP 	CHECK_ROM_STRT	; Check BIOS ROM checksum and return
   364 						
   365 				;----------------------------------------------------------------------------
   366 				; This routine is the entry-point for the ROM checksum routines.
   367 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   368 				;        X: LSB of end-Address
   369 				;        Y: MSB of end-Address
   370 				;----------------------------------------------------------------------------
   371 FDB9 86 CC		CHECK_ROM_STRT	STX	END_PTR		; LSB of end-address
   372 FDBB 84 CD				STY	END_PTR+1	; MSB of end-address
   373 FDBD A2 00				LDX	#0
   374 FDBF 86 D0				STX 	ROM_CS		; Init ROM checksum
   375 FDC1 86 D1				STX 	ROM_CS+1
   376 FDC3 86 CE				STX	ROM_PTR		; LSB of begin-address
   377 FDC5 85 CF				STA	ROM_PTR+1	; MSB of begin-address
   378 FDC7 C9 1C				CMP	#$1C		; Monitor ROM?
   379 FDC9 F0 10				BEQ	MON_CHK_ROM	; branch if Monitor ROM
   380 						
   381 FDCB C9 B0				CMP	#$B0		; BASIC ROM?
   382 FDCD F0 06				BEQ	BAS_CHK_ROM	; branch if BASIC ROM
   383
   384 FDCF A2 6E				LDX	#<TXT_ROM	; BIOS ROM
   385 FDD1 A0 FE				LDY	#>TXT_ROM
   386 FDD3 D0 0A				BNE 	PR_CHKROM_TXT	; branch always
   387 						
   388 FDD5 A2 64		BAS_CHK_ROM	LDX	#<TXT_BAS	; BASIC ROM
   389 FDD7 A0 FE				LDY	#>TXT_BAS
   390 FDD9 D0 04				BNE 	PR_CHKROM_TXT	; branch always
   391
   392 FDDB A2 5A		MON_CHK_ROM	LDX	#<TXT_MON	; Monitor ROM
   393 FDDD A0 FE				LDY	#>TXT_MON
   394 FDDF 20 82 F6		PR_CHKROM_TXT	JSR	SPRINT
   395 FDE2 A2 78				LDX	#<TXT_CS	; Print ' KB ROM '
   396 FDE4 A0 FE				LDY	#>TXT_CS
   397 FDE6 20 82 F6				JSR	SPRINT
   398 FDE9 A0 00				LDY	#0
   399 						;JMP	ROM_LP1		; fall-through to ROM_LP1
   400
   401 				;----------------------------------------------------------------------------
   402 				; This routine calculates the checksum of the entire ROM area from 
   403 				; ROM_PTR to END_PTR.
   404 				;----------------------------------------------------------------------------
   405 FDEB B1 CE		ROM_LP1		LDA 	(ROM_PTR),Y	; get byte from ROM
   406 FDED					ADCAW	ROM_CS		; ROM_CS = ROM_CS + A
Macro: ADCAW [Source: jc2_defines.inc]
     1 FDED 18					CLC
     2 FDEE 65 D0				ADC	ROM_CS
     3 FDF0 85 D0				STA	ROM_CS
     4 FDF2 A5 D1				LDA	ROM_CS+1
     5 FDF4 69 00				ADC	#0
     6 FDF6 85 D1				STA	ROM_CS+1
Source: jc2_cf_ide.asm
   407 FDF8 C8					INY			; next byte
   408 FDF9 D0 02				BNE	ROM_CHK_END	; branch if not on a new page
   409 						
   410 FDFB E6 CF				INC 	ROM_PTR+1	; MSB, next page
   411 FDFD A5 CF		ROM_CHK_END	LDA	ROM_PTR+1	; Current ROM address MSB
   412 FDFF C5 CD				CMP	END_PTR+1	; MSB of end-address
   413 FE01 D0 E8				BNE	ROM_LP1		; branch if not done yet
   414 						
   415 FE03 C4 CC				CPY	END_PTR		; End-address?
   416 FE05 D0 E4				BNE	ROM_LP1		; branch if not at end-address yet
   417 						
   418 FE07 A5 CD				LDA	END_PTR+1
   419 FE09 C9 FF				CMP	#$FF		; BIOS ROM?
   420 FE0B D0 10				BNE	ROM_CHK2	; branch if not BIOS ROM
   421 						
   422 FE0D A5 D1 CD F9 FF D0 + 		CPW	ROM_CS ROM_CS16	; Compare 2 words BIOS checksum
   423 FE19 D0 2B				BNE	ROM_CS_ERR	; branch if not the same
   424 FE1B F0 22				BEQ	ROM_CS_OK	; branch if the same
   425
   426 FE1D C9 E0		ROM_CHK2	CMP	#$E0		; BASIC ROM?
   427 FE1F D0 10				BNE	MON_ROM_CMP	; branch if Monitor ROM
   428 						
   429 FE21 A5 D1 CD F7 FF D0 + 		CPW	ROM_CS BAS_CS16	; Compare 2 words BASIC checksum
   430 FE2D D0 17				BNE	ROM_CS_ERR	; branch if not the same
   431 FE2F F0 0E				BEQ	ROM_CS_OK	; branch if the same
   432 						
   433 FE31 A5 D1 CD F5 FF D0 + MON_ROM_CMP	CPW	ROM_CS MON_CS16	; Compare 2 words Monitor checksum
   434 FE3D D0 07				BNE	ROM_CS_ERR	; branch if not the same
   435
   436 FE3F A2 81		ROM_CS_OK	LDX	#<TXT_CS_OK	; Print 'OKE'
   437 FE41 A0 FE				LDY	#>TXT_CS_OK
   438 FE43 4C 82 F6				JMP	SPRINT		; Print and return
   439 FE46 A2 85		ROM_CS_ERR	LDX	#<TXT_CS_ERR	; Print 'Error'
   440 FE48 A0 FE				LDY	#>TXT_CS_ERR
   441 FE4A 4C 82 F6				JMP	SPRINT		; Print and return
   442
   443 				;----------------------------------------------------------------------------
   444 				; This routine prints a string to the terminal: X=LSB, Y=MSB.
   445 				; In order not to interfere with the BIOS STROUT / WRSTR with PSTR, a copy
   446 				; of these routines is made with SPRINT and SPROUT.
   447 				;----------------------------------------------------------------------------
   448 FE4D A0 00		SPROUT		LDY  	#$00       	; index y is 0
   449 FE4F B1 CA		SPROUTLP	LDA  	(PRSTR),Y   	; load char at string pos y
   450 FE51 F0 06				BEQ  	ENDSPROUT  	; exit, if NULL char
   451 						
   452 FE53 20 52 E0				JSR  	COUT       	; write character
   453 FE56 C8					INY             	; next index
   454 FE57 D0 F6				BNE  	SPROUTLP	; branch always
   455 						
   456 FE59 60			ENDSPROUT	RTS			; return
   457
   458 FE5A 20 4A 43 2D 4D 4F + TXT_MON		.by	' JC-MON 1' $00
   459 FE64 20 42 41 53 49 43 + TXT_BAS		.by	' BASIC 12' $00
   460 FE6E 20 42 49 4F 53 20 + TXT_ROM		.by	' BIOS   8' $00
   461 FE78 20 4B 42 20 52 4F + TXT_CS		.by	' KB ROM ' $00
   462 FE81 4F 4B 0D 00		TXT_CS_OK	.by	'OK' CR $00
   463 FE85 45 72 72 6F 72 0D + TXT_CS_ERR	.by	'Error' CR $00		
   464 						
   465
   466 						
    63 						
    64 				;----------------------------------------------------------------------------
    65 				;       VECTORS AT THE END OF THE ROM AREA
    66 				;----------------------------------------------------------------------------
    67 FE8C					ORG	$FFEE
    68 FFEE 6C 7A 1A		NMI_JMP_VEC    	JMP     (NMIVECT)		; Jump to a user selectable NMI vector (moved from Monitor $1F2F)
    69 FFF1 6C 7E 1A		IRQ_JMP_VEC    	JMP     (IRQVECT)		; Jump to a user selectable IRQ vector (moved from Monitor $1F32)
    70 FFF4 00 00		MON_CS16	.word	$000			;  1 KB Monitor ROM checksum
    71 FFF6 00 00		BAS_CS16	.word	$000			; 12 KB BASIC ROM checksum
    72 FFF8 00 00		ROM_CS16	.word	$000			;  8 KB BIOS ROM checksum
    73 FFFA EE FF		NMI_VECTOR	.word	NMI_JMP_VEC		; This was $1F2F in Junior Computer Monitor program
    74 FFFC 00 E0		RESET_VECTOR	.word  	MON_COLD_START		; $E000 (was $1C1D in Junior Computer Monitor program)
    75 FFFE F1 FF		IRQ_BRK_VECTOR	.word	IRQ_JMP_VEC		; This was $1F32 in Junior Computer Monitor program
    76
    77 						END
