mads 2.1.7 build 33 (1 Aug 24)
Source: jc2_main.asm
     1 				; ------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS Version 1.2.4 by Emile, v1.1.4 and earlier versions by Joerg Walke
     3 				;
     4 				; 21-04-25: v1.2.0 Emile, Integration into 1 eprom
     5 				; 08-05-25: v1.2.1 -Basic update (v2.22 patches + I2COUT, I2CIN and DOS commands)
     6 				;                  -CF_LOAD_VEC/CF_SAVE_VEC added, RETURN_VECT moved to $180A 
     7 				;                  -Address corrections to maintain V1.1.4 compatibility (broken in V1.2.0)
     8 				; 19-05-25: v1.2.2 -ZP addresses reorganised to avoid conflicts between Basic, BIOS & boot.sys.
     9 				;		   -NMI & IRQ JMP vectors moved from Monitor to here to prepare for Monitor ROM switching
    10 				; 24-05-25: v1.2.3 Bug-fix Basic LOAD command.
    11 				; 20-07-25: v1.2.4 - TAPE routines removed and DETECT_IOL updated
    12 				;                  - Basic: SOUND added and PORTIO/PORTOUT/PORTIN updated with new IO2 and main-board
    13 				;                  - MCP23017 routines added
    14 				; ------------------------------------------------------------------------------
    15 = 0031			VERMAIN   	EQU     '1'    			; BIOS main version
    16 = 0032			VERPSUB    	EQU     '2'    			; BIOS primary sub version
    17 = 0034			VERSSUB		EQU	'4'			; BIOS secondary sub version
    18
    19 				        	OPT h-                          ; no DOS file-header
    20 				        	OPT f+                          ; save as single block
    21
    22 				        	icl 	"jc2_defines.inc"  	; all address defines for the JC-II
Source: jc2_defines.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor CONSTANTS
     3 				;------------------------------------------------------------------------------ 
     4
     5 				; PIA Register Indices *********************************************************
     6 = 000C			PIA_PORTA       EQU     $0C             ; Port A input/output register
     7 = 000D			PIA_PORTB       EQU     $0D             ; Port B input/output register
     8 = 000E			PIA_PORTC       EQU     $0E             ; Port C input/output register
     9 = 000F			PIA_CONTROL     EQU     $0F             ; Control/Setup register
    10
    11 				; Memory Management Unit (MMU) Register Indices ********************************
    12 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    13 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    14 = 0080			BAS_EN		EQU	$80		; PORTB bit 7: 1 = enable BASIC at $B000
    15
    16 				; MCP23017 I2C GPIO constants
    17 = 0040			MCP23017_I2C_0	EQU	$40		; I2C address of 1st MCP23017 on IO2 board
    18 = 0042			MCP23017_I2C_1	EQU	$42		; I2C address of 2nd MCP23017 on IO2 board
    19 = 0044			MCP23017_I2C_2	EQU	$44		; I2C address of 3rd MCP23017 on IO2 board
    20 = 0000			IODIRA		EQU	$00		; IO Direction register Port A (1=input, 0=output)
    21 = 0001			IODIRB		EQU	$01		; IO Direction register Port B (1=input, 0=output)
    22 = 0012			GPIOA		EQU	$12		; IO Port A, read and write
    23 = 0013			GPIOB		EQU	$13		; IO Port B, read and write
    24
    25 				; VIA 1 Register Indices ********************************************************
    26 = 0000			VIA_PORTB     	EQU  	$00  		; Port B input/output register
    27 = 0001			VIA_PORTA     	EQU  	$01  		; Port A input/output register
    28 = 0002			VIA_DDRB   	EQU  	$02		; Port B data direction register
    29 = 0003			VIA_DDRA   	EQU  	$03		; Port A data direction register
    30 = 0004			VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
    31 = 0005			VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
    32 = 0006			VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
    33 = 0007			VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
    34 = 0008			VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
    35 = 0009			VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
    36 = 000A			VIA_SR     	EQU  	$0A		; Shift register
    37 = 000B			VIA_ACR    	EQU  	$0B		; Auxilary control register
    38 = 000C			VIA_PCR    	EQU  	$0C		; Periheral control register
    39 = 000D			VIA_IFR    	EQU  	$0D		; Interrupt flag register
    40 = 000E			VIA_IER    	EQU  	$0E		; Interrupt enable register
    41 = 000F			VIA_PANOHS 	EQU  	$0F
    42
    43 				; VIA 2 Register Indices (SD-card, sound, etc.) *********************************
    44 = 0010			PORTB     	EQU  	$10  		; Port B input/output register
    45 = 0011			PORTA     	EQU  	$11  		; Port A input/output register
    46 = 0012			DDRB   		EQU  	$12		; Port B data direction register
    47 = 0013			DDRA   		EQU  	$13		; Port A data direction register
    48 = 0014			T1CL   		EQU  	$14		; Timer 1 counter low byte register
    49 = 0015			T1CH   		EQU  	$15		; Timer 1 counter high byte register
    50 = 0016			T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
    51 = 0017			T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
    52 = 0018			T2CL   		EQU  	$18		; Timer 2 counter low byte register
    53 = 0019			T2CH   		EQU  	$19		; Timer 2 counter high byte register
    54 = 001A			SR     		EQU  	$1A		; Shift register
    55 = 001B			ACR    		EQU  	$1B		; Auxilary control register
    56 = 001C			PCR    		EQU  	$1C		; Peripheral control register
    57 = 001D			IFR    		EQU  	$1D		; Interrupt flag register
    58 = 001E			IER    		EQU  	$1E		; Interrupt enable register
    59 = 001F			PANOHS 		EQU  	$1F
    60
    61 = 0020			CENTURY		EQU	$20		; the 20th century. change to travel in time
    62 = 002E			DATEDIV		EQU	'.'		; divider char for date string
    63 = 003A			TIMEDIV		EQU	':'		; divider char for time string
    64 = 002A			PROMPT    	EQU     '*'    		; prompt character
    65 = 002D			ADIV      	EQU     '-'    		; address divider
    66 = 0001			SOH       	EQU     $01    		; start of header
    67 = 0004			EOT       	EQU     $04    		; end of text
    68 = 0006			ACK       	EQU     $06    		; acknowledged
    69 = 0008			BS        	EQU     $08    		; backspace key
    70 = 000D			CR        	EQU     $0D    		; carriage return
    71 = 000A			LF	  	EQU     $0A    		; line feed
    72 = 0015			NAK       	EQU     $15    		; not acknowledged
    73 = 0018			CAN		EQU     $18		; Cancel
    74 = 001B			ESC       	EQU     $1B    		; ESC
    75 = 0020			SPC		EQU     $20		; space char
    76
    77 				; Tape Reader/Writer Constants *************************************************
    78 = 0031			RPTIME		EQU	49		; read point time   49x8uS     = 392uS
    79
    80 				; Device Driver Constants ******************************************************
    81 = 0081			KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
    82
    83 = 0010			COM_DEV	        EQU	$10             ; COM devices base ID
    84 = 0020			STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
    85
    86 = 0000			NULL_ID		EQU	$00             ; the NULL device
    87
    88 = 0010			TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
    89 = 0011			PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
    90 = 0012			PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
    91 = 0013			KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
    92 = 0014			KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
    93 = 0015			VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
    94
    95 = 0020			XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
    96 = 0021			TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
    97 = 0022			FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
    98 = 0023			FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
    99 = 0024			SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
   100 = 0025			HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID (CF-card)
   101 = 0026			HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
   102
   103 				; Device Command Constants *****************************************************
   104 = 0000			CMD_INIT	EQU	0               ; Init device
   105 = 0001			CMD_IDENTIFY	EQU	1               ; Identify device
   106 = 0002			CMD_NORMAL	EQU	2               ; Set normal text
   107 = 0003			CMD_INVERSE	EQU	3               ; Set inverse text
   108 = 0004			CMD_FLASH	EQU	4               ; Set blinking text
   109 = 0005			CMD_HOME	EQU	5               ; Set cursor to home position
   110 = 0006			CMD_CLRLINE	EQU	6               ; Clear line at cursor
   111 = 0007			CMD_CLRSCRN	EQU	7               ; Clear screen
   112 = 0008			CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   113
   114 = 0010			CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   115 = 0011			CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
   116
   117 = 0020			CMD_LOAD	EQU	32              ; Load data byte from device
   118 = 0021			CMD_SAVE	EQU	33              ; Save data byte to device
   119 = 0022			CMD_READ	EQU	34              ; Read data block from device
   120 = 0023			CMD_WRITE	EQU	35              ; Write data block to device
   121 = 0024			CMD_BOOT        EQU     36              ; Boot from device
   122 = 0025			CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   123 = 0026			CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
   124
   125 				; SD Command Constants *********************************************************
   126 = 0040			CMD0		EQU	$40		; Reset SD-Card
   127 = 0041			CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   128 = 0048			CMD8		EQU	CMD0 + 8	; Check voltage range
   129 = 004D			CMD13		EQU	CMD0 + 13	;
   130 = 0050			CMD16		EQU	CMD0 + 16	; Change block size
   131 = 0051			CMD17		EQU	CMD0 + 17	; Read single block
   132 = 0058			CMD24		EQU	CMD0 + 24	; Write single block
   133 = 0077			CMD55		EQU	CMD0 + 55	; Application command prefix
   134 = 007A			CMD58		EQU	CMD0 + 58	; Get OCR
   135 = 0069			ACMD41		EQU	CMD0 + 41	; Initialize SDC
   136
   137 = 00FE			DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
   138
   139 				;----------------------------------------------------------------------------
   140 				; CF-IDE Hardware Registers
   141 				;----------------------------------------------------------------------------
   142 = 0C80			CFBASE		EQU 	$0C80		; Base card-address for CF-IDE card
   143 = 0C80			CFREG0		EQU	CFBASE+0	; Data port
   144 = 0C81			CFREG1		EQU	CFBASE+1	; Read: error-code, write: feature
   145 = 0C82			CFREG2		EQU	CFBASE+2	; Number of sectors to transfer
   146 = 0C83			CFREG3		EQU	CFBASE+3	; Sector address LBA 0 [0:7] (LSB)
   147 = 0C84			CFREG4		EQU	CFBASE+4	; Sector address LBA 1 [8:15]
   148 = 0C85			CFREG5		EQU	CFBASE+5	; Sector address LBA 2 [16:23]
   149 = 0C86			CFREG6		EQU	CFBASE+6	; Sector address LBA 3 [24:27] (MSB)
   150 = 0C87			CFREG7		EQU	CFBASE+7	; Read: Status, Write: Command
   151 = 0C88			CFREG8		EQU	CFBASE+8	; A write with 0x00 is a HW reset
   152
   153 				; Block Device Constants *******************************************************
   154 = 0400			MOUNT_TABLE     EQU     $0400           ; Table of mounted devices
   155 = 0400			BOOT_PART       EQU     MOUNT_TABLE     ; Boot Medium Descriptor
   156 = 0600			BLOCK_BUF	EQU	$0600           ; Block Device Block Buffer
   157 = 0600			MBR             EQU     BLOCK_BUF       ; Master Boot Block Code
   158 = 07BE			PART0		EQU	$07BE		; Partition 0 start
   159 = 07C6			PART0_RS	EQU	PART0 + 8 	; Partition 0 relative sector field
   160 = 07CE			PART0_SIZE	EQU	PART0 + 16	; Partition 0 sector size field
   161
   162 = 07FE			BOOTBLK_TAG     EQU     $07FE           ; Address of Boot Block Tag ($55 $AA)
   163
   164 				; Miscellaneous Constants ******************************************************
   165 = 0068			I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
   166
   167 = 1000			FGC_BASE        EQU     $1000
   168 = 1010			FGC_INFO        EQU     FGC_BASE+$10
   169 = 1013			FGC_SET_PAGE    EQU     FGC_BASE+$13
   170 = 1017			FGC_FDC_CMD     EQU     FGC_BASE+$17
   171 = 101F			FGC_VPU_CMD     EQU     FGC_BASE+$1F
   172 = 1027			FGC_VPU_OUT     EQU     FGC_BASE+$27
   173
   174 = 1009			VPU_PORT1       EQU     FGC_BASE+$09    ; VPU Port 1
   175 = 0080			VPU_REG0        EQU     $80             ; VPU register 0
   176 = 008F			VPU_REG15       EQU     VPU_REG0+15     ; VPU status register pointer
   177 = 0000			VPU_STAT0       EQU     0               ; VPU status register 0
   178
   179 				;------------------------------------------------------------------------------
   180 				; Junior Computer ][ BIOS & Monitor Address defines
   181 				;------------------------------------------------------------------------------ 
   182
   183 				; Card Base Addresses **********************************************************
   184 = 0014			IOBASE		EQU	$14		; pointer to IO card base
   185 = 0014			IOBASEL		EQU	$14		; always $00
   186 = 0015			IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
   187 = 0016			FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
   188 = 0016			FGCBASEL	EQU	$16		; always $00
   189 = 0017			FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always be K4 = $10
   190 = 0018			CARD3BASE	EQU	$18		; reserved (controller base)
   191 = 0018			CARD3BASEL	EQU	$18		; always $00
   192 = 0019			CARD3BASEH	EQU	$19		;K2 = $08, K3 = $0C, K4 = $10
   193
   194 				;-----------------------------------------------------------------------------
   195 				; Addresses up to $9C are in use by BASIC, see jc2_basic.asm
   196 				; Addresses from $A0 up to $AF are in use by DOS and boot.sys
   197 				;-----------------------------------------------------------------------------
   198
   199 = 00C9			DEVID		EQU	$C9		; 1-byte temp device id (moved from $03 to avoid Basic collision)
   200 = 00CA			PRSTR		EQU	$CA		; 2-bytes replacement for PSTR
   201 = 00CC			END_PTR		EQU	$CC		; ROM end-pointer (2 bytes), also used by boot.sys
   202 = 00CE			ROM_PTR		EQU	$CE		; ROM pointer (2 bytes)
   203 = 00D0			ROM_CS		EQU	$D0		; ROM checksum counter (2 bytes)
   204 = 00D2			CFLBA0          EQU     $D2		; CF-card LBA 0 [0:7]
   205 = 00D3			CFLBA1          EQU     $D3		; CF-card LBA 1 [8:15]
   206 = 00D4			CFLBA2          EQU     $D4		; CF-card LBA 2 [16:23]
   207 = 00D5			CFLBA3          EQU     $D5		; CF-card LBA 3 [24:27]
   208 = 00D6			MSEC		EQU	$D6		; msec time-out counter
   209 = 00D7			RSTACT		EQU	$D7		; 1 = Reset Pending
   210 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register
   211 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register
   212 = 00DA			TICKCNT         EQU     $DA             ; current tick counter
   213 = 00DB			SD_TYPE		EQU	$DB		; SD Card Type: $00 Byte mode, $40 LBA mode
   214 = 00DC			BLKBUF		EQU	$DC             ; pointer to block buffer
   215 = 00DC			BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
   216 = 00DC			CRCL      	EQU   	$DC      	; XModem CRC lo byte
   217 = 00DD			BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
   218 = 00DD			CRCH      	EQU   	$DD     	; XModem CRC hi byte
   219 = 00DE			SD_CMD		EQU	$DE		; SD-Card CMD Byte
   220 = 00DE			RETRYL    	EQU   	$DE      	; XModem retry counter lo byte
   221 = 00DE			PDEV		EQU	$DE		; device descriptor pointer
   222 = 00DE			PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
   223 = 00DF			SD_PB3      	EQU   	$DF   		; SD-Card Parameter Byte 3
   224 = 00DF			RETRYH    	EQU   	$DF      	; XModem retry counter hi byte
   225 = 00DF			PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
   226
   227 = 00E0			SD_PB2		EQU   	$E0   		; SD-Card Parameter Byte 2
   228 = 00E0			BAUDRATE  	EQU   	$E0    		; ACIA current baud rate
   229 = 00E0			OPCODE		EQU	$E0		; DISASSEM current opcode
   230 = 00E0			I2C_DATA	EQU	$E0		; I2C current I2C data byte
   231 = 00E0			BLKEND      	EQU     $E0		; XModem block end flag
   232 = 00E1			KEY     	EQU     $E1   		; MON 1-byte Editor 
   233 = 00E1			SD_PB1      	EQU   	$E1   		; SD-Card Parameter Byte 1
   234 = 00E1			LINECNT		EQU	$E1		; DISASSEM number of disassembled lines
   235 = 00E1			BFLAG     	EQU   	$E1      	; XModem block flag
   236 = 00E2			BEGADR  	EQU     $E2   		; MON 2-byte Editor Begin Address Pointer
   237 = 00E2			SD_PB0		EQU	$E2   		; SD-Card Parameter Byte 0
   238 = 00E2			ADRMODE		EQU	$E2		; DISASSEM addressing mode
   239 = 00E2			BLKNO     	EQU   	$E2      	; XModem block number
   240 = 00E3			SD_CRC		EQU	$E3   		; SD-Card CRC Byte
   241 = 00E3			IBYTES		EQU	$E3		; DISASSEM instruction byte count
   242 = 00E3			ERRCNT    	EQU   	$E3      	; XModem error counter 10 is the limit
   243 = 00E4			ENDADR  	EQU     $E4   		; MON 2-byte Editor End Address Pointer
   244 = 00E4			VIA_STATUS 	EQU	$E4 		; VIA2 current VIA2 PortB output status
   245
   246 = 00E6			CURADR  	EQU     $E6   		; MON 2-byte Editor Current Address Pointer
   247 = 00E6			ASCL	  	EQU   	$E6     	; MON ASCII list start address low
   248 = 00E6			PLBA		EQU	$E6		; LBA pointer
   249 = 00E6			PLBAL		EQU	$E6		; LBA pointer low byte
   250 = 00E7			ASCH      	EQU   	$E7     	; MON ASCII list start address high
   251 = 00E7			PLBAH		EQU	$E7		; LBA pointer high byte
   252 = 00E8			CENDADR 	EQU     $E8   		; MON 2-byte Editor Current End Address Pointer
   253 = 00E8			STOL      	EQU   	$E8     	; MON store address Low
   254 = 00E9			STOH      	EQU   	$E9     	; MON store address High
   255 = 00EA			MOVADR  	EQU     $EA   		; MON 2-byte Editor 
   256 = 00EA			PSTR      	EQU   	$EA      	; ACIA output string Pointer
   257 = 00EA			PSTRL     	EQU   	$EA      	; ACIA lower address byte of output string pointer
   258 = 00EB			PSTRH     	EQU   	$EB      	; ACIA upper address byte of output string pointer
   259 = 00EC			TABLEA  	EQU     $EC   		; MON 2-byte Editor 
   260 = 00EC			WBUF      	EQU   	$EC      	; ACIA character output buffer
   261
   262 = 00EE			LABELS  	EQU     $EE   		; MON 1-byte Editor 
   263 = 00EE			PSAV            EQU     $EE		; MON
   264 = 00EF			PCL		EQU	$EF		; CPU program counter Low
   265
   266 = 00F0			PCH		EQU	$F0		; CPU program counter High
   267 = 00F1			PREG		EQU	$F1		; CPU processor status register
   268 = 00F2			SPUSER		EQU	$F2		; CPU stack pointer
   269 = 00F2			DIVCHAR		EQU	$F2             ; CLOCK current divider char (. or / for date : for time)
   270 = 00F3			ACC		EQU	$F3		; CPU accumulator
   271 = 00F4			YREG		EQU	$F4		; CPU y-register
   272 = 00F5			XREG		EQU	$F5		; CPU x-register
   273 = 00F6			BYTES   	EQU     $F6   		; MON 1-byte Number of bytes to be displayed
   274 = 00F7			COUNT   	EQU     $F7   		; MON 1-byte
   275 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
   276 = 00F8			NUML      	EQU   	$F8     	; MON low number byte
   277 = 00F8			INL     	EQU     $F8   		; MON 1-byte hex display buffer
   278 = 00F9			INH     	EQU     $F9   		; MON 1-byte hex display buffer
   279 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
   280 = 00F9			NUMH	  	EQU   	$F9	 	; MON high number byte
   281 = 00FA			POINT   	EQU     $FA   		; MON 2-byte
   282 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
   283 = 00FA			ADRL      	EQU   	$FA     	; MON last address Low
   284 = 00FB			ADRH      	EQU   	$FB     	; MON last address High
   285 = 00FC			TEMP      	EQU   	$FC     	; MON temp storage
   286 = 00FD			TEMPX   	EQU     $FD   		; MON 1-byte temp. data-buffer
   287 = 00FD			YSAV      	EQU   	$FD     	; MON Y register storage
   288 = 00FE			NIBBLE  	EQU     $FE   		; MON 1-byte temp. data-buffer
   289 = 00FE			PDBCNT    	EQU   	$FE     	; MON number of printed data bytes
   290 = 00FF			MODE      	EQU   	$FF     	; MON current edit mode
   291
   292 				; IO Base Addresses ************************************************************
   293 = 0800			K2		EQU	$0800		; Base address of IO select K2
   294 = 0C00			K3		EQU	$0C00		; Base address of IO select K3
   295 = 1000			K4		EQU	$1000		; Base address of IO select K4
   296
   297 				; Buffers **********************************************************************
   298 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400
   299 = 1500			RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
   300
   301 				; ACIA Registers ***************************************************************
   302 = 1600			DATA_REG  	EQU   	$1600    	; ACIA Data Register
   303 = 1601			STAT_REG  	EQU   	$1601    	; ACIA Status Register
   304 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
   305 = 1603			CTRL_REG  	EQU   	$1603    	; ACIA Control Register
   306
   307 				; ATF1504 Memory Management Unit (MMU) Register ********************************
   308 = 1700			MMU		EQU	$1700		; MMU Register
   309
   310 				;------------------------------------------------------------------------------
   311 				; $1800 - $19FF 512 Bytes, this was previously unused, with the new MMU this
   312 				; has become RAM.
   313 				;------------------------------------------------------------------------------
   314 = 1800			PPORTLOAD	EQU	$1800		; jump location for test code
   315 = 1803			PPORTSAVE	EQU	$1803		; jump location for test code
   316 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
   317 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
   318 = 180A			RETURN_VECT     EQU     $180A           ; 2-byte return vector to monitor caller (moved from $01 to avoid Basic collision)
   319
   320 				; INPBUF is the BASIC Input Buffer. It is defined from $1868 - $18FF
   321 = 1868			INPBUF	  	EQU 	$1868		; change input buffer to last 151 bytes in page
   322 = 1868			ccflag		EQU	INPBUF		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   323 = 1869			ccbyte		EQU 	ccflag+1	; BASIC CTRL-C byte
   324 = 186A			ccnull		EQU 	ccbyte+1	; BASIC CTRL-C byte timeout
   325 = 186B			VEC_CC		EQU 	ccnull+1	; ctrl c check vector
   326
   327 				; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   328 = 187F			Ibuffs		EQU 	VEC_CC+$14	; start of input buffer after IRQ/NMI code
   329 = 18FE			Ibuffe		EQU 	Ibuffs+$7F	; end of input buffer
   330
   331 				; RIOT RAM Area ****************************************************************
   332 = 1A00			IO_INFO         EQU     $1A00           ; Initialization info call for IO card
   333
   334 = 1A24			KEY_HANDLER     EQU     $1A24           ; character input handler
   335 = 1A26			NKEY_HANDLER    EQU     $1A26           ; no character input handler
   336 = 1A28			DEVLIST		EQU	$1A28		; start of device driver list
   337
   338 = 1A66			STDBEEP		EQU	$1A66		; current standard beep routine
   339 = 1A68			DEVIN		EQU	$1A68		; current opened device input routine
   340 = 1A6A			DEVOUT		EQU	$1A6A		; current opened device output routine
   341 = 1A6C			DEVCMD		EQU	$1A6C		; current opened device command routine
   342 = 1A6E			STDIN		EQU	$1A6E		; current standard input routine
   343 = 1A70			STDOUT		EQU	$1A70		; current standard output routine
   344 = 1A72			STDCMD		EQU	$1A72		; current standard command routine
   345 = 1A74			STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   346 = 1A75			STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   347 = 1A76			STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   348 = 1A77			STOACC		EQU	$1A77		; last accumulator before interrupt
   349
   350 				; Interrupt Vectors ************************************************************
   351 = 1A78			BRKUSR		EQU	$1A78		; address of user BREAK vector
   352 = 1A7A			NMIVECT		EQU     $1A7A           ; address of NMI vector
   353 = 1A7C			IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   354 = 1A7E			IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
   355
   356 				; Port Register ****************************************************************
   357 = 1A80			PAD		EQU     $1A80		; Port A Data Register
   358 = 1A81			PADD		EQU	$1A81		; Port A Data Direction Register
   359 = 1A82			PBD		EQU	$1A82		; Port B Data Register
   360 = 1A83			PBDD		EQU	$1A83		; Port B Data Direction Register
   361
   362 = 1A85			WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
   363 									; Read = get Edge Control Interrupt Register
   364
   365 				; Timer Register ***************************************************************
   366 = 1A94			CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   367 = 1A95			CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   368 = 1A96			CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   369 = 1A97			CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
   370 = 1A9F			CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
   371
   372 				;------------------------------------------------------------------------------
   373 				; MACROS for use with the MAD-Assembler
   374 				;------------------------------------------------------------------------------ 
   375 				.macro		ADCAW			; Add A to word and store in word
   376 						CLC
   377 						ADC	:1
   378 						STA	:1
   379 						LDA	:1+1
   380 						ADC	#0
   381 						STA	:1+1
   382 				.endm
   383
   384 				.macro		SBCAW			; Subtract A from word and store in word
   385 						SEC
   386 						SBC	:1
   387 						STA	:1
   388 						LDA	:1+1
   389 						SBC	#0
   390 						STA	:1+1
   391 				.endm
   392
   393 				.macro		SBWB	b16 b8	      	; Subtract a byte from a word
   394 						SEC
   395 						LDA	:b16
   396 						SBC	:b8
   397 						STA	:b16
   398 						LDA	:b16+1
   399 						SBC	#0
   400 						STA	:b16+1
   401 				.endm
   402 						
    23
    24 						ORG	$8000
    25 8000 FF					.byte	$FF			; Fill entire eprom
    26 						
    27 8001					ORG	$9C00			; start address of 1K Monitor in 32K combined EPROM
    28 				;-------------------------------------------------------------------------------------------------------
    29 1C00			MONITOR_BLOCK	.local, $1C00
    30 				;-------------------------------------------------------------------------------------------------------
    31 1C00					icl 	"jc2_mon.asm"		; Monitor source-file
Source: jc2_mon.asm
     1 				;-------------------------------------------------------------------------------------------------------
     2 				; SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER
     3 				;
     4 				; Written by: A. NACHTMANN
     5 				; Date      :  7 FEB. 1980
     6 				;
     7 				; The features of Junior's monitor program are:
     8 				; - Hex address data display (entry via RST)
     9 				; - Hex editor (start address is $1CB5)
    10 				; - Hex assembler (start address is $1F51)
    11 				;----------------------------------------------------------------------------
    12 				; Original code restored and adapted for the 
    13 				; TASM (Telemark Assembler) by : A.J. Prosman, October 26, 2019
    14 				; MADS (MAD-Assembler) by : E. v.d. Logt,      December 2024
    15 				;----------------------------------------------------------------------------
    16
    17 				;       Beginners may load these locations
    18 				;       $1C00 for step by step modus and BRK command
    19
    20 				;----------------------------------------------------------------------------
    21 				;        JUNIOR'S MAIN ROUTINES
    22 				;----------------------------------------------------------------------------
    23 1C00 85 F3		SAVE    STA     ACC         ; Save ACCU
    24 1C02 68			        PLA                 ; Get current P-Register
    25 1C03 85 F1		        STA     PREG        ; Save P-Register
    26
    27 1C05 68			SAVEA   PLA                 ; Get current PCL
    28 1C06 85 EF		        STA	PCL         ; Save current PCL
    29 1C08 85 FA		        STA     POINT       ; PCL to display buffer
    30 1C0A 68			        PLA                 ; Get current PCH
    31 1C0B 85 F0		        STA     PCH         ; Save current PCH
    32 1C0D 85 FB		        STA     POINT+1     ; PCH to display buffer
    33
    34 1C0F 84 F4		SAVEB   STY     YREG        ; Save current Y-Register
    35 1C11 86 F5		        STX     XREG        ; Save current X-Register 
    36 1C13 BA			        TSX                 ; Get current SP
    37 1C14 86 F2		        STX     SPUSER      ; Save current SP
    38 1C16 A2 01		        LDX     #$01        ; Set AD-Mode
    39 1C18 86 FF		        STX     MODE
    40 1C1A 4C 33 1C		        JMP     START
    41
    42 				; RESET vector 6502
    43 1C1D A9 3F		RESET   LDA     #$3F        ; PB5---PB0
    44 1C1F 8D 83 1A		        STA     PBDD        ; IS output
    45 1C22 A9 04		        LDA     #$04        ; Reset P-Register
    46 1C24 85 F1		        STA     PREG
    47 1C26 A9 03		        LDA     #$03
    48 1C28 85 FF		        STA     MODE        ; Set AD-Mode
    49 1C2A 85 F6		        STA     BYTES       ; Display POINT, INH
    50 1C2C A2 FF		        LDX     #$FF
    51 1C2E 9A			        TXS 
    52 1C2F 86 F2		        STX     SPUSER
    53 1C31 D8			        CLD 
    54 1C32 78			        SEI 
    55
    56 1C33 20 88 1D		START   JSR     SCAND       ; Display data specified by POINT
    57 1C36 D0 FB		        BNE     START       ; Wait until key is released
    58
    59 1C38 20 88 1D		STARA   JSR     SCAND       ; Display data specified by point
    60 1C3B F0 FB		        BEQ     STARA       ;  Any key pressed
    61 1C3D 20 88 1D		        JSR     SCAND       ;  Debounce key
    62 1C40 F0 F6		        BEQ     STARA       ; Any key still pressed
    63 1C42 20 F9 1D		        JSR     GETKEY      ; If Yes, decode key, return with key in ACC
    64
    65 1C45 C9 13		GOEXEC  CMP     #$13        ; GO-Key ?
    66 1C47 D0 13		        BNE     ADMODE
    67 1C49 A6 F2		        LDX     SPUSER      ; Get current SP
    68 1C4B 9A			        TXS 
    69 1C4C A5 FB		        LDA     POINT+1     ; Start execution at POINT
    70 1C4E 48			        PHA 
    71 1C4F A5 FA		        LDA     POINT
    72 1C51 48			        PHA 
    73 1C52 A5 F1		        LDA     PREG        ; Restore current P register
    74 1C54 48			        PHA 
    75 1C55 A6 F5		        LDX     XREG
    76 1C57 A4 F4		        LDY     YREG
    77 1C59 A5 F3		        LDA     ACC
    78 1C5B 40			        RTI                 ; Execute program
    79
    80 1C5C C9 10		ADMODE  CMP     #$10        ; AD-Key ?
    81 1C5E D0 06		        BNE     DAMODE
    82 1C60 A9 03		        LDA     #$03        ; Set AD-Mode
    83 1C62 85 FF		        STA     MODE
    84 1C64 D0 14		        BNE     STEPA       ; Always
    85 				        
    86 1C66 C9 11		DAMODE  CMP     #$11        ; DA-Key ?
    87 1C68 D0 06		        BNE     STEP
    88 1C6A A9 00		        LDA     #$00        ; Set DA-Mode
    89 1C6C 85 FF		        STA     MODE
    90 1C6E F0 0A		        BEQ     STEPA
    91
    92 1C70 C9 12		STEP    CMP     #$12        ; PLUS-Key ?
    93 1C72 D0 09		        BNE     PCKEY
    94 1C74 E6 FA		        INC     POINT
    95 1C76 D0 02		        BNE     STEPA
    96 1C78 E6 FB		        INC     POINT+1
    97
    98 1C7A 4C 33 1C		STEPA   JMP     START
    99
   100 1C7D C9 14		PCKEY   CMP     #$14        ; PC-Key
   101 1C7F D0 0B		        BNE     ILLKEY
   102 1C81 A5 EF		        LDA     PCL
   103 1C83 85 FA		        STA     POINT      ; Last PC to display buffer
   104 1C85 A5 F0		        LDA     PCH
   105 1C87 85 FB		        STA     POINT+1
   106 1C89 4C 7A 1C		        JMP     STEPA
   107 				        
   108 1C8C C9 15		ILLKEY  CMP     #$15        ; Illegal key?
   109 1C8E 10 EA		        BPL     STEPA       ; If Yes, ignore it
   110
   111 1C90 85 E1		DATA    STA     KEY         ; Save key
   112 1C92 A4 FF		        LDY     MODE        ; Y=0 Is data mode, else address mode
   113 1C94 D0 0D		        BNE     ADDRESS
   114 1C96 B1 FA		        LDA     (POINT),Y   ; Get Data specified
   115 1C98 0A			        ASL                 ; by point
   116 1C99 0A			        ASL                 ; shift low order
   117 1C9A 0A			        ASL                 ; nibble into high order nibble
   118 1C9B 0A			        ASL      
   119 1C9C 05 E1		        ORA     KEY         ; Data with key
   120 1C9E 91 FA		        STA     (POINT),Y   ; Restore data
   121 1CA0 4C 7A 1C		        JMP     STEPA
   122
   123 1CA3 A2 04		ADDRESS LDX     #$04        ; 4 Shifts
   124 1CA5 06 FA		ADLOOP  ASL     POINT       ; POINT+1, POINT 4 Positions to the left
   125 1CA7 26 FB		        ROL     POINT+1
   126 1CA9 CA			        DEX 
   127 1CAA D0 F9		        BNE     ADLOOP
   128 1CAC A5 FA		        LDA     POINT
   129 1CAE 05 E1		        ORA     KEY         ; Restore address
   130 1CB0 85 FA		        STA     POINT
   131 1CB2 4C 7A 1C		        JMP     STEPA
   132
   133 				;-------------------------------------------------------------------------------
   134 				;       JUNIOR'S HEX EDITOR
   135 				;
   136 				;       FOLLOWING COMMANDS ARE VALID:
   137 				;       "INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
   138 				;       "INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
   139 				;       "SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2BYTE PATTERN
   140 				;       "SKIP": SKIP TO NEXT INSTRUCTION
   141 				;       "DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
   142 				;
   143 				;       AN ERROR IS INDICATED, IF THE INSTRUCTION POINTER CURAD IS OUT OF RANGE
   144 				;-------------------------------------------------------------------------------
   145 1CB5 20 D3 1E		EDITOR  JSR     BEGIN       ; CURAD := BEGAD
   146 1CB8 A4 E3		        LDY     BEGADR+1
   147 1CBA A6 E2		        LDX     BEGADR
   148 1CBC E8			        INX 
   149 1CBD D0 01		        BNE     EDIT
   150 1CBF C8			        INY 
   151
   152 1CC0 86 E8		EDIT    STX     CENDADR     ; CEND := BEGAD + 1
   153 1CC2 84 E9		        STY     CENDADR+1
   154 1CC4 A9 77		        LDA     #$77        ; Display "77"
   155 1CC6 A0 00		        LDY     #$00
   156 1CC8 91 E6		        STA     (CURADR),Y
   157 1CCA 20 4D 1D		CMND    JSR     SCAN        ; Display current instruction,
   158 				                            ; wait for a key
   159 1CCD C9 14		SEARCH  CMP     #$14        ; Search command ?
   160 1CCF D0 2A		        BNE     INSERT
   161 1CD1 20 6F 1D		        JSR     GETBYT      ; Read 1st byte
   162 1CD4 10 F7		        BPL     SEARCH      ; COM. Key ?
   163 1CD6 85 FB		        STA     POINT+1     ; Discard data
   164 1CD8 20 6F 1D		        JSR     GETBYT      ; Read 2nd byte
   165 1CDB 10 F0		        BPL     SEARCH      ; COM. Key ?
   166 1CDD 85 FA		        STA     POINT       ; Discard data
   167 1CDF 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   168
   169 1CE2 A0 00		SELOOP  LDY     #$00
   170 1CE4 B1 E6		        LDA     (CURADR),Y  ; Compare instruction
   171 1CE6 C5 FB		        CMP     POINT+1     ; against data to be searched
   172 1CE8 D0 07		        BNE     SEARA       ; Skip to the next instruction, if not equal
   173 1CEA C8			        INY 
   174 1CEB B1 E6		        LDA     (CURADR),Y
   175 1CED C5 FA		        CMP     POINT
   176 1CEF F0 D9		        BEQ     CMND        ; Return if 2byte pattern is found
   177
   178 1CF1 20 5C 1E		SEARA   JSR     OPLEN       ; Get length of the current instruction
   179 1CF4 20 F8 1E		        JSR     NEXT        ; Skip to the next instruction
   180 1CF7 30 E9		        BMI     SELOOP      ; Search again, if CURAD is less than CEND
   181 1CF9 10 3E		        BPL     ERRA
   182
   183 1CFB C9 10		INSERT  CMP     #$10        ; Insert command ?
   184 1CFD D0 0A		        BNE     INPUT
   185 1CFF 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   186 1D02 10 C9		        BPL     SEARCH      ; COM. key?
   187 1D04 20 47 1E		        JSR     FILLWS      ; Move data in WS downward by the amount in bytes
   188 1D07 F0 C1		        BEQ     CMND        ; Return to display the inserted instruction
   189
   190 1D09 C9 13		INPUT   CMP     #$13        ; Input command ?
   191 1D0B D0 14		        BNE     SKIP
   192 1D0D 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   193 1D10 10 BB		        BPL     SEARCH      ; COM. key ?
   194 1D12 20 5C 1E		        JSR     OPLEN       ; Length of the current instruction
   195 1D15 20 F8 1E		        JSR     NEXT        ; Return with N=1, if CURAD is less than CEND
   196 1D18 A5 FD		        LDA     TEMPX       ; Length of instr. to be inserted
   197 1D1A 85 F6		        STA     BYTES
   198 1D1C 20 47 1E		        JSR     FILLWS      ; Move data in ws downward by the amount in bytes
   199 1D1F F0 A9		        BEQ     CMND        ; Return to display the inserted data
   200
   201 1D21 C9 12		SKIP    CMP     #$12        ; Skip command ?
   202 1D23 D0 07		        BNE     DELETE
   203 1D25 20 F8 1E		        JSR     NEXT        ; Skip to next instruction. CURAD less than CEND?
   204 1D28 30 A0		        BMI     CMND
   205 1D2A 10 0D		        BPL     ERRA
   206
   207 1D2C C9 11		DELETE  CMP     #$11        ; Delete command ?
   208 1D2E D0 09		        BNE     ERRA
   209 1D30 20 83 1E		        JSR     UP          ; Delete current instruction by moving up the WS
   210 1D33 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   211 1D36 4C CA 1C		        JMP     CMND
   212
   213 1D39 A9 EE		ERRA    LDA     #$EE
   214 1D3B 85 FB		        STA     POINT+1
   215 1D3D 85 FA		        STA     POINT
   216 1D3F 85 F9		        STA     INH
   217 1D41 A9 03		        LDA     #$03
   218 1D43 85 F6		        STA     BYTES
   219
   220 1D45 20 8E 1D		ERRB    JSR     SCANDS      ; Display "EEEEEE" until key is released
   221 1D48 D0 FB		        BNE     ERRB
   222 1D4A 4C CA 1C		        JMP     CMND
   223
   224 				;----------------------------------------------------------------------------
   225 				;       EDITOR'S SUBROUTINES
   226 				;
   227 				;       SCAN is a subroutine, filling up the display-buffer determined by
   228 				;       CURADR. Then the display is scanned depending on the length of the  
   229 				;       instruction pointed to by CURADR if a keypress is detected.
   230 				;----------------------------------------------------------------------------
   231
   232 				;       SCAN RETURNS WITH VALUE IN A
   233 1D4D A2 02		SCAN    LDX     #$02        ; Fill up the display buffer
   234 1D4F A0 00		        LDY     #$00
   235
   236 1D51 B1 E6		FILBUF  LDA     (CURADR),Y  ; Start filling at OPCode
   237 1D53 95 F9		        STA     INH,X
   238 1D55 C8			        INY 
   239 1D56 CA			        DEX 
   240 1D57 10 F8		        BPL     FILBUF
   241 1D59 20 5C 1E		        JSR     OPLEN       ; Store instruction length in bytes
   242
   243 1D5C 20 8E 1D		SCANA   JSR     SCANDS      ; Display current instruction
   244 1D5F D0 FB		        BNE     SCANA       ; Key released ?
   245
   246 1D61 20 8E 1D		SCANB   JSR     SCANDS      ; Display current instruction
   247 1D64 F0 FB		        BEQ     SCANB       ; Any key pressed
   248 1D66 20 8E 1D		        JSR     SCANDS      ; Display current instruction
   249 1D69 F0 F6		        BEQ     SCANB       ; Any key still pressed ?
   250 1D6B 20 F9 1D		        JSR     GETKEY      ; If yes, return with key in ACC
   251 1D6E 60			        RTS 
   252
   253 				;----------------------------------------------------------------------------
   254 				;       GETBYT reads 2 hex-keys and composes their values in the A register.
   255 				;       If only hex-keys were pressed, it returns with N=1. If a command-key
   256 				;       was pressed, it returns with N=0;
   257 				;----------------------------------------------------------------------------
   258 1D6F 20 5C 1D		GETBYT  JSR     SCANA       ; Read high order nibble
   259 1D72 C9 10		        CMP     #$10
   260 1D74 10 11		        BPL     BYTEND      ; Command key ?
   261 1D76 0A			        ASL     
   262 1D77 0A			        ASL                 ; If not, save high order nibble
   263 1D78 0A			        ASL     
   264 1D79 0A			        ASL     
   265 1D7A 85 FE		        STA     NIBBLE
   266 1D7C 20 5C 1D		        JSR     SCANA       ; Read low order nibble
   267 1D7F C9 10		        CMP     #$10
   268 1D81 10 04		        BPL     BYTEND      ; Command key ?
   269 1D83 05 FE		        ORA     NIBBLE      ; If not, compose byte
   270 1D85 A2 FF		        LDX     #$FF        ; Set N=1
   271 1D87 60			BYTEND  RTS 
   272
   273 				;----------------------------------------------------------------------------
   274 				;       SCAND is a subroutine showing data specified by POINT.
   275 				;       SCANDS is a subroutine showing the contents of the display-buffer as
   276 				;       a function of BYTES.
   277 				;       The next subroutine AK scans the keyboard, it returns with A=0 if no
   278 				;       key was pressed and with A > 0 if a key was pressed.
   279 				;       When SCAND or SCANDS are exit, PA0..PA7 are set to input.
   280 				;----------------------------------------------------------------------------
   281 1D88 A0 00		SCAND   LDY     #$00
   282 1D8A B1 FA		        LDA     (POINT),Y   ; Get data specified by point
   283 1D8C 85 F9		        STA     INH
   284
   285 1D8E A9 7F		SCANDS  LDA     #$7F
   286 1D90 8D 81 1A		        STA     PADD        ; PA0..PA6 is output
   287 1D93 A2 08		        LDX     #$08        ; Enable display
   288 1D95 A4 F6		        LDY     BYTES       ; Fetch length from bytes
   289
   290 1D97 A5 FB		SCDSA   LDA     POINT+1     ; Output 1st byte
   291 1D99 20 CC 1D		        JSR     SHOW
   292 1D9C 88			        DEY 
   293 1D9D F0 0D		        BEQ     SCDSB       ; More bytes ?
   294 1D9F A5 FA		        LDA     POINT
   295 1DA1 20 CC 1D		        JSR     SHOW        ; If yes, output 2nd byte
   296 1DA4 88			        DEY 
   297 1DA5 F0 05		        BEQ     SCDSB       ; More bytes ?
   298 1DA7 A5 F9		        LDA     INH
   299 1DA9 20 CC 1D		        JSR     SHOW        ; If yes, output 3rd byte
   300
   301 1DAC A9 00		SCDSB   LDA     #$00
   302 1DAE 8D 81 1A		        STA     PADD        ; PA0..PA7 is input
   303 1DB1 A0 03		AK      LDY     #$03        ; Scan 3 rows
   304 1DB3 A2 00		        LDX     #$00        ; Reset row counter
   305
   306 1DB5 A9 FF		ONEKEY  LDA     #$FF
   307 1DB7 8E 82 1A		AKA     STX     PBD         ; Output row number
   308 1DBA E8			        INX                 ; Enable next row
   309 1DBB E8			        INX 
   310 1DBC 2D 80 1A		        AND     PAD         ; Input row pattern
   311 1DBF 88			        DEY                 ; All rows scanned ?
   312 1DC0 D0 F5		        BNE     AKA
   313 1DC2 A0 06		        LDY     #$06        ; Turn display off
   314 1DC4 8C 82 1A		        STY     PBD
   315 1DC7 09 80		        ORA     #$80        ; Set BIT7=1
   316 1DC9 49 FF		        EOR     #$FF        ; Invert key pattern
   317 1DCB 60			        RTS 
   318
   319 				;----------------------------------------------------------------------------
   320 				;       Subroutine SHOW copies the contents of a display-buffer to the display.
   321 				;       The X-register is used as a scan-counter. It determines if POINT+1,
   322 				;       POINT or INH is transported to the displays.
   323 				;----------------------------------------------------------------------------
   324 1DCC 48			SHOW    PHA                 ; Save display 
   325 1DCD 84 FC		        STY     TEMP        ; Save Y register
   326 1DCF 4A			        LSR     
   327 1DD0 4A			        LSR                 ; Get high order nibble
   328 1DD1 4A			        LSR     
   329 1DD2 4A			        LSR     
   330 1DD3 20 DF 1D		        JSR     CONVD       ; Output high order nibble
   331 1DD6 68			        PLA                 ; Get display again
   332 1DD7 29 0F		        AND     #$0F        ; Mask off high order nibble
   333 1DD9 20 DF 1D		        JSR     CONVD       ; Output low order nibble
   334 1DDC A4 FC		        LDY     TEMP
   335 1DDE 60			        RTS 
   336
   337 				;----------------------------------------------------------------------------
   338 				;       Subroutine CONVD controls the display scanning. It converts the
   339 				;       contents of the display-buffer to be displayed into a segment pattern.
   340 				;----------------------------------------------------------------------------
   341 1DDF A8			CONVD   TAY                 ; Use nibble as index
   342 1DE0 B9 0F 1F		        LDA     LOOK,Y      ; Fetch segment pattern
   343 1DE3 8D 80 1A		        STA     PAD         ; Output segment pattern
   344 1DE6 8E 82 1A		        STX     PBD         ; Output digit enable
   345 1DE9 A0 7F		        LDY     #$7F
   346
   347 1DEB 88			DELAY   DEY                 ; Delay 500uS approx
   348 1DEC 10 FD		        BPL     DELAY
   349 1DEE 8C 80 1A		        STY     PAD         ; Turns segments off
   350 1DF1 A0 06		        LDY     #$06
   351 1DF3 8C 82 1A		        STY     PBD         ; Turn display off
   352 1DF6 E8			        INX                 ; Enable next digit
   353 1DF7 E8			        INX 
   354 1DF8 60			        RTS 
   355
   356 				;----------------------------------------------------------------------------
   357 				;       GETKEY converts a key-press into a hex number. It returns with the
   358 				;       key value in A. 
   359 				;       If an invalid key was pressed ?
   360 				;----------------------------------------------------------------------------
   361 1DF9 A2 00		GETKEY  LDX     #$00        ; Start at row 0
   362 1DFB A0 01		GETKEA  LDY     #$01        ; Get one row
   363 1DFD 20 B5 1D		        JSR     ONEKEY      ; A=0, No key pressed
   364 1E00 D0 07		        BNE     KEYIN
   365 1E02 E0 06		        CPX     #$06
   366 1E04 D0 F5		        BNE     GETKEA      ; Each row scanned ?
   367 1E06 A9 15		        LDA     #$15        ; Return if invalid key
   368 1E08 60			        RTS 
   369
   370 1E09 A0 FF		KEYIN   LDY     #$FF
   371 1E0B 0A			KEYINA  ASL                 ; Shift left until Y=Key number
   372 1E0C B0 03		        BCS     KEYINB
   373 1E0E C8			        INY 
   374 1E0F 10 FA		        BPL     KEYINA
   375
   376 1E11 8A			KEYINB  TXA 
   377 1E12 29 0F		        AND     #$0F        ; Mask MSD
   378 1E14 4A			        LSR                 ; Divide by 2
   379 1E15 AA			        TAX 
   380 1E16 98			        TYA 
   381 1E17 10 03		        BPL     KEYIND
   382
   383 1E19 18			KEYINC  CLC 
   384 1E1A 69 07		        ADC     #$07        ; Add row offset
   385 1E1C CA			KEYIND  DEX 
   386 1E1D D0 FA		        BNE     KEYINC
   387 1E1F 60			        RTS 
   388
   389 				;----------------------------------------------------------------------------
   390 				;       RDINST transfers an instruction from the keyboard to the display-buffer. 
   391 				;       It returns with N=0 if a command-key was pressed. Once the entire
   392 				;       instruction is read, RDINST returns with N=1;
   393 				;----------------------------------------------------------------------------
   394 1E20 20 6F 1D		RDINST  JSR     GETBYT      ; Read OPCode
   395 1E23 10 21		        BPL     RDB         ; Return if it is the command key
   396 1E25 85 FB		        STA     POINT+1     ; Store OP cod in the display buffer
   397 1E27 20 60 1E		        JSR     LENACC      ; Calculate instruction length
   398 1E2A 84 F7		        STY     COUNT
   399 1E2C 84 FD		        STY     TEMPX
   400 1E2E C6 F7		        DEC     COUNT
   401 1E30 F0 12		        BEQ     RDA         ; 1 Byte instruction ?
   402 1E32 20 6F 1D		        JSR     GETBYT      ; If not, read first operand
   403 1E35 10 0F		        BPL     RDB         ; Return if it is the command key
   404 				        
   405 1E37 85 FA		        STA     POINT       ; Store 1st operand in the display buffer
   406 1E39 C6 F7		        DEC     COUNT
   407 1E3B F0 07		        BEQ     RDA         ; 2 Byte instruction ?
   408 				        
   409 1E3D 20 6F 1D		        JSR     GETBYT      ; If not, read second operand
   410 1E40 10 04		        BPL     RDB         ; Return if it is the command key
   411 				        
   412 1E42 85 F9		        STA     INH         ; Store 2nd operand in the display buffer
   413 1E44 A2 FF		RDA     LDX     #$FF        ; N=1
   414 1E46 60			RDB     RTS 
   415
   416 				;----------------------------------------------------------------------------
   417 				;       WILLWS transfers data from the display to the workspace. It always
   418 				;       returns with Z=1.
   419 				;----------------------------------------------------------------------------
   420 1E47 20 A6 1E		FILLWS  JSR     DOWN        ; Move data down by the amount in bytes
   421 1E4A 20 DC 1E		        JSR     ADCEND      ; Adjust current end address
   422 1E4D A2 02		        LDX     #$02
   423 1E4F A0 00		        LDY     #$00
   424 1E51 B5 F9		WS      LDA     INH,X       ; Fetch data from display buffer
   425 1E53 91 E6		        STA     (CURADR),Y  ; Insert data into the data field
   426 1E55 CA			        DEX 
   427 1E56 C8			        INY 
   428 1E57 C4 F6		        CPY     BYTES       ; All inserted ?
   429 1E59 D0 F6		        BNE     WS          ; If not, continue
   430 1E5B 60			        RTS 
   431
   432 				;----------------------------------------------------------------------------
   433 				;       OPLEN calculates the length of a 6502 instruction.
   434 				;       Instruction length is saved in BYTES.
   435 				;----------------------------------------------------------------------------
   436 1E5C A0 00		OPLEN   LDY     #$00
   437 1E5E B1 E6		        LDA     (CURADR),Y  ; Fetch OPCode from WS
   438 1E60 A0 01		LENACC  LDY     #$01        ; Length of the OPCode is 1 byte
   439 1E62 C9 00		        CMP     #$00
   440 1E64 F0 1A		        BEQ     LENEND      ; BRK Instruction ?
   441 				        
   442 1E66 C9 40		        CMP     #$40
   443 1E68 F0 16		        BEQ     LENEND      ; TRI Instruction ?
   444 				        
   445 1E6A C9 60		        CMP     #$60
   446 1E6C F0 12		        BEQ     LENEND      ; RTS Instruction ?
   447 				        
   448 1E6E A0 03		        LDY     #$03
   449 1E70 C9 20		        CMP     #$20
   450 1E72 F0 0C		        BEQ     LENEND      ; JSR Instruction ?
   451 				        
   452 1E74 29 1F		        AND     #$1F        ; Strip to 5 bits
   453 1E76 C9 19		        CMP     #$19
   454 1E78 F0 06		        BEQ     LENEND      ; Any ABS,Y instruction ?
   455 				        
   456 1E7A 29 0F		        AND     #$0F        ; Strip to 4 bits
   457 1E7C AA			        TAX                 ; Use nibble as index
   458 1E7D BC 1F 1F		        LDY     LEN,X       ; Fetch length from LEN
   459 1E80 84 F6		LENEND  STY     BYTES       ; Discard length in bytes
   460 1E82 60			        RTS 
   461
   462 				;----------------------------------------------------------------------------
   463 				;       UP moves a data-field between CURADR and CENDADR upwards by the
   464 				;       amount in BYTES.
   465 				;----------------------------------------------------------------------------
   466 1E83 A5 E6		UP      LDA     CURADR
   467 1E85 85 EA		        STA     MOVADR
   468 1E87 A5 E7		        LDA     CURADR+1    ; MOVAD := CURADR
   469 1E89 85 EB		        STA     MOVADR+1
   470 1E8B A4 F6		UPLOOP  LDY     BYTES
   471 1E8D B1 EA		        LDA     (MOVADR),Y  ; Move upward by the number of bytes
   472 1E8F A0 00		        LDY     #$00
   473 1E91 91 EA		        STA     (MOVADR),Y
   474 1E93 E6 EA		        INC     MOVADR
   475 1E95 D0 02		        BNE     UPA
   476 				        
   477 1E97 E6 EB		        INC     MOVADR+1    ; MOVADR+1 := MOVADR+1 + 1
   478 1E99 A5 EA		UPA     LDA     MOVADR
   479 1E9B C5 E8		        CMP     CENDADR
   480 1E9D D0 EC		        BNE     UPLOOP      ; All data moved ?
   481 1E9F A5 EB		        LDA     MOVADR+1    ; If not continue
   482 1EA1 C5 E9		        CMP     CENDADR+1
   483 1EA3 D0 E6		        BNE     UPLOOP
   484 1EA5 60			        RTS 
   485
   486 				;----------------------------------------------------------------------------
   487 				;       DOWN moves a data-field between CURADR and CENDADR downwards by the
   488 				;       amount in BYTES.
   489 				;----------------------------------------------------------------------------
   490 1EA6 A5 E8		DOWN    LDA     CENDADR
   491 1EA8 85 EA		        STA     MOVADR      ; MOVAD := CEND
   492 1EAA A5 E9		        LDA     CENDADR+1
   493 1EAC 85 EB		        STA     MOVADR+1
   494 1EAE A0 00		DNLOOP  LDY     #$00
   495 1EB0 B1 EA		        LDA     (MOVADR),Y  ; Move downward by the number of bytes
   496 1EB2 A4 F6		        LDY     BYTES
   497 1EB4 91 EA		        STA     (MOVADR),Y
   498 1EB6 A5 EA		        LDA     MOVADR
   499 1EB8 C5 E6		        CMP     CURADR
   500 1EBA D0 06		        BNE     DNA         ; All data moved ?
   501 				        
   502 1EBC A5 EB		        LDA     MOVADR+1    ; If not, continue
   503 1EBE C5 E7		        CMP     CURADR+1
   504 1EC0 F0 10		        BEQ     DNEND
   505 1EC2 38			DNA     SEC 
   506 1EC3 A5 EA		        LDA     MOVADR
   507 1EC5 E9 01		        SBC     #$01
   508 1EC7 85 EA		        STA     MOVADR
   509 1EC9 A5 EB		        LDA     MOVADR+1    ; MOVAD := MOVAD - 1
   510 1ECB E9 00		        SBC     #$00
   511 1ECD 85 EB		        STA     MOVADR+1
   512 1ECF 4C AE 1E		        JMP     DNLOOP
   513 1ED2 60			DNEND   RTS 
   514
   515 				;----------------------------------------------------------------------------
   516 				;       BEGIN sets CURADR TO BEGADR
   517 				;----------------------------------------------------------------------------
   518 1ED3 A5 E2		BEGIN   LDA     BEGADR
   519 1ED5 85 E6		        STA     CURADR
   520 1ED7 A5 E3		        LDA     BEGADR+1    ; CURAD := BEGADR
   521 1ED9 85 E7		        STA     CURADR+1
   522 1EDB 60			        RTS 
   523
   524 				;----------------------------------------------------------------------------
   525 				;       ADCEND increases the current end-address by the number in BYTES.
   526 				;----------------------------------------------------------------------------
   527 1EDC 18			ADCEND  CLC 
   528 1EDD A5 E8		        LDA     CENDADR
   529 1EDF 65 F6		        ADC     BYTES       ; CEND := CEND + BYTES
   530 1EE1 85 E8		        STA     CENDADR
   531 1EE3 A5 E9		        LDA     CENDADR+1
   532 1EE5 69 00		        ADC     #$00
   533 1EE7 85 E9		        STA     CENDADR+1
   534 1EE9 60			        RTS 
   535
   536 				;----------------------------------------------------------------------------
   537 				;       RECEND decreases the current end-address by the number in BYTES.
   538 				;----------------------------------------------------------------------------
   539 1EEA 38			RECEND  SEC 
   540 1EEB A5 E8		        LDA     CENDADR
   541 1EED E5 F6		        SBC     BYTES       ; CEND := CEND - BYTES
   542 1EEF 85 E8		        STA     CENDADR
   543 1EF1 A5 E9		        LDA     CENDADR+1
   544 1EF3 E9 00		        SBC     #$00
   545 1EF5 85 E9		        STA     CENDADR+1
   546 1EF7 60			        RTS 
   547
   548 				;----------------------------------------------------------------------------
   549 				;       NEXT increases the current displayed address by the number in BYTES.
   550 				;----------------------------------------------------------------------------
   551 1EF8 18			NEXT    CLC 
   552 1EF9 A5 E6		        LDA     CURADR
   553 1EFB 65 F6		        ADC     BYTES       ; CURAD := CURAD + BYTES
   554 1EFD 85 E6		        STA     CURADR
   555 1EFF A5 E7		        LDA     CURADR+1
   556 1F01 69 00		        ADC     #$00
   557 1F03 85 E7		        STA     CURADR+1
   558 1F05 38			        SEC 
   559 1F06 A5 E6		        LDA     CURADR
   560 1F08 E5 E8		        SBC     CENDADR
   561 1F0A A5 E7		        LDA     CURADR+1
   562 1F0C E5 E9		        SBC     CENDADR+1
   563 1F0E 60			        RTS 
   564
   565 				;----------------------------------------------------------------------------
   566 				;       Lookup table "LOOK"" is used to convert a hex number into a pattern
   567 				;       for the seven-segment displays. 
   568 				;       Lookup table "LEN" is used to convert an instruction into an 
   569 				;       instruction length.
   570 				;----------------------------------------------------------------------------
   571 1F0F 40			LOOK    .byte   $40         ; "0"
   572 1F10 79			        .byte   $79         ; "1"
   573 1F11 24			        .byte   $24         ; "2"
   574 1F12 30			        .byte   $30         ; "3"
   575 1F13 19			        .byte   $19         ; "4"
   576 1F14 12			        .byte   $12         ; "5"
   577 1F15 02			        .byte   $02         ; "6"
   578 1F16 78			        .byte   $78         ; "7"
   579 1F17 00			        .byte   $00         ; "8"
   580 1F18 10			        .byte   $10         ; "9"
   581 1F19 08			        .byte   $08         ; "A"
   582 1F1A 03			        .byte   $03         ; "B"
   583 1F1B 46			        .byte   $46         ; "C"
   584 1F1C 21			        .byte   $21         ; "D"
   585 1F1D 06			        .byte   $06         ; "E"
   586 1F1E 0E			        .byte   $0E         ; "F"
   587
   588 1F1F 02			LEN     .byte   $02
   589 1F20 02			        .byte   $02
   590 1F21 02			        .byte   $02
   591 1F22 01			        .byte   $01
   592 1F23 02			        .byte   $02
   593 1F24 02			        .byte   $02
   594 1F25 02			        .byte   $02
   595 1F26 01			        .byte   $01
   596 1F27 01			        .byte   $01
   597 1F28 02			        .byte   $02
   598 1F29 01			        .byte   $01
   599 1F2A 01			        .byte   $01
   600 1F2B 03			        .byte   $03
   601 1F2C 03			        .byte   $03
   602 1F2D 03			        .byte   $03
   603 1F2E 03			        .byte   $03
   604
   605 				; NMI and IRQ JMP vectors are now moved to jc2_main.asm
   606
   607 1F2F				ORG	$1F35		; maintain compatibility with original Monitor
   608 				;----------------------------------------------------------------------------
   609 				;       GETLBL is an assembler subroutine. It searches for labels on the
   610 				;       symbol pseudo stack. If this stack contains a valid label, it returns
   611 				;       with the high-order label address in X and the low-order label
   612 				;       address in A. If no valid label is found, it returns with Z=1.
   613 				;----------------------------------------------------------------------------
   614 1F35 B1 E6		GETLBL  LDA     (CURADR),Y  ; Fetch current label number from WS
   615 1F37 A0 FF		        LDY     #$FF        ; Reset pseudo stack
   616 1F39 C4 EE		SYMA    CPY     LABELS      ; Upper most symbol table address ?
   617 1F3B F0 0D		        BEQ     SYMB        ; If yes, return, no label on pseudo stack
   618 				        
   619 1F3D D1 EC		        CMP     (TABLEA),Y  ; Label Nr. in WS = Label Nr. on pseudo stack
   620 1F3F D0 0A		        BNE     SYMNXT
   621 				        
   622 1F41 88			        DEY                 ; If yes, get high order address
   623 1F42 B1 EC		        LDA     (TABLEA),Y
   624 1F44 AA			        TAX                 ; Discard high order, add in X
   625 1F45 88			        DEY 
   626 1F46 B1 EC		        LDA     (TABLEA),Y  ; Get low order add
   627 1F48 A0 01		        LDY     #$01        ; Prepare Y register
   628 1F4A 60			SYMB    RTS 
   629
   630 1F4B 88			SYMNXT  DEY                 ; *********   *********
   631 1F4C 88			        DEY                 ; * X=ADH *   * A=ADL *
   632 1F4D 88			        DEY                 ; *********   *********
   633 1F4E D0 E9		        BNE     SYMA
   634 1F50 60			        RTS 
   635
   636 				;----------------------------------------------------------------------------
   637 				;       ASSEMBLER main routine.
   638 				;
   639 				;       The following instructions are assembled:
   640 				;       - JSR instruction
   641 				;       - JMP instruction 
   642 				;       - BRANCH instructions
   643 				;----------------------------------------------------------------------------
   644 1F51 38			ASSEMB  SEC 
   645 1F52 A5 E4		        LDA     ENDADR
   646 1F54 E9 FF		        SBC     #$FF
   647 1F56 85 EC		        STA     TABLEA      ; TABLE := ENDAD - $FF
   648 1F58 A5 E5		        LDA     ENDADR+1
   649 1F5A E9 00		        SBC     #$00
   650 1F5C 85 ED		        STA     TABLEA+1
   651 1F5E A9 FF		        LDA     #$FF
   652 1F60 85 EE		        STA     LABELS
   653 1F62 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   654
   655 1F65 20 5C 1E		PASSA   JSR     OPLEN       ; Start pass one, get current instruction
   656 1F68 A0 00		        LDY     #$00
   657 1F6A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   658 1F6C C9 FF		        CMP     #$FF        ; Is the current instruction a label ? 
   659 1F6E D0 1D		        BNE     NXTINS
   660 				        
   661 1F70 C8			        INY 
   662 1F71 B1 E6		        LDA     (CURADR),Y  ; If yes, fetch label number
   663 1F73 A4 EE		        LDY     LABELS
   664 1F75 91 EC		        STA     (TABLEA),Y  ; Push label number on symbol stack
   665 1F77 88			        DEY 
   666 1F78 A5 E7		        LDA     CURADR+1    ; Get high order address
   667 1F7A 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   668 1F7C 88			        DEY 
   669 1F7D A5 E6		        LDA     CURADR      ; Get high order address
   670 1F7F 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   671 1F81 88			        DEY 
   672 1F82 84 EE		        STY     LABELS      ; Adjust pseudo stack pointer
   673 1F84 20 83 1E		        JSR     UP          ; Delete current label in ws
   674 1F87 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   675 1F8A 4C 65 1F		        JMP     PASSA       ; Look for more labels
   676
   677 1F8D 20 F8 1E		NXTINS  JSR     NEXT        ; If no label skip to the next instruction
   678 1F90 30 D3		        BMI     PASSA       ; All labels in WS collected ?
   679 1F92 20 D3 1E		        JSR     BEGIN       ; Start pass 2
   680 				        
   681 1F95 20 5C 1E		PASSB   JSR     OPLEN       ; Get length of the current instruction
   682 1F98 A0 00		        LDY     #$00
   683 1F9A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   684 1F9C C9 4C		        CMP     #$4C        ; JMP instruction ?
   685 1F9E F0 16		        BEQ     JUMPS
   686 				        
   687 1FA0 C9 20		        CMP     #$20        ; JSR Instruction ?
   688 1FA2 F0 12		        BEQ     JUMPS
   689 				        
   690 1FA4 29 1F		        AND     #$1F        ; Strip to 5 bits
   691 1FA6 C9 10		        CMP     #$10        ; Any branch instruction ?
   692 1FA8 F0 1A		        BEQ     BRINST
   693 				        
   694 1FAA 20 F8 1E		PB      JSR     NEXT        ; If not, return
   695 1FAD 30 E6		        BMI     PASSB       ; All labels between CURAD and ENDAD assembled ?
   696 				        
   697 1FAF A9 03		        LDA     #$03        ; Enable 3 display buffers
   698 1FB1 85 F6		        STA     BYTES
   699 1FB3 4C 33 1C		        JMP     START       ; Exit here
   700
   701 1FB6 C8			JUMPS   INY                 ; Set pointer to label number
   702 1FB7 20 35 1F		        JSR     GETLBL      ; Get label address
   703 1FBA F0 EE		        BEQ     PB          ; Return if not found
   704 				        
   705 1FBC 91 E6		        STA     (CURADR),Y  ; Store low order address
   706 1FBE 8A			        TXA 
   707 1FBF C8			        INY 
   708 1FC0 91 E6		        STA     (CURADR),Y  ; Store high order address
   709 1FC2 D0 E6		        BNE     PB
   710
   711 1FC4 C8			BRINST  INY                 ; Set pointer to label number
   712 1FC5 20 35 1F		        JSR     GETLBL      ; Get label address
   713 1FC8 F0 E0		        BEQ     PB          ; Return if label not found
   714 				        
   715 1FCA 38			        SEC 
   716 1FCB E5 E6		        SBC     CURADR      ; Calculate branch offset
   717 1FCD 38			        SEC 
   718 1FCE E9 02		        SBC     #$02        ; DESTINATION - SOURCE - 2 = OFFSET
   719 1FD0 91 E6		        STA     (CURADR),Y  ; Insert branch offset in WS
   720 1FD2 4C AA 1F		        JMP     PB
   721
   722 				;----------------------------------------------------------------------------
   723 				;       BRANCH calculates the offset of branch instructions. The 2 right-hand
   724 				;       displays show the calculated offset defined by the 4 left-hand
   725 				;       displays. The program must be stopped by the RESET key.
   726 				;----------------------------------------------------------------------------
   727 1FD5 D8			BRANCH  CLD 
   728 1FD6 A9 00		        LDA     #$00        ; Reset display buffer
   729 1FD8 85 FB		        STA     POINT+1
   730 1FDA 85 FA		        STA     POINT
   731 1FDC 85 F9		        STA     INH
   732 1FDE 20 6F 1D		BR      JSR     GETBYT      ; Read source
   733 1FE1 10 F2		        BPL     BRANCH      ; Command key ?
   734 				        
   735 1FE3 85 FB		        STA     POINT+1    ; Save source in buffer
   736 1FE5 20 6F 1D		        JSR     GETBYT      ; Read destination
   737 1FE8 10 EB		        BPL     BRANCH      ; Command key ?
   738
   739 1FEA 85 FA		        STA     POINT       ; Save destination in buffer
   740 1FEC 18			        CLC 
   741 1FED A5 FA		        LDA     POINT       ; Fetch destination
   742 1FEF E5 FB		        SBC     POINT+1     ; Substract source
   743 1FF1 85 F9		        STA     INH
   744 1FF3 C6 F9		        DEC     INH         ; Equalize and save offset in buffer
   745 1FF5 4C DE 1F		        JMP     BR
   746
   747 				;----------------------------------------------------------------------------
   748 				;       END OF JUNIOR'S MONITOR
   749 				;----------------------------------------------------------------------------
    32 				;-------------------------------------------------------------------------------------------------------
    33 1FF8			MONITOR_END	
    34 						.endl
    35 				;-------------------------------------------------------------------------------------------------------
    36
    37 9FF8					ORG 	$B000       		; start address of BASIC (12K)
    38 B000			RAM_TOP		icl 	"jc2_basic.asm"		; end of user RAM+1 (set as needed, should be page aligned)
Source: jc2_basic.asm
     1
     2 				; Enhanced BASIC ver 2.28
     3
     4 				; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     5
     6 				; 2.00	new revision numbers start here
     7 				; 2.01	fixed LCASE$() and UCASE$()
     8 				; 2.02	new get value routine done
     9 				; 2.03	changed RND() to galoise method
    10 				; 2.04	fixed SPC()
    11 				; 2.05	new get value routine fixed
    12 				; 2.06	changed USR() code
    13 				; 2.07	fixed STR$()
    14 				; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    15 				; 2.09	fixed RND()
    16 				; 2.10	integrated missed changes from an earlier version
    17 				; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    18 				; 2.21	fixed IF .. THEN RETURN to not cause error
    19 				; 2.22	fixed RND() breaking the get byte routine
    20 				; 2.25  Emile: I2C addresses corrected for V1.1.4 bios and integrated with BIOS & MON source-files.
    21 				; 2.26  - I2Cout, I2Cin() and DOS commands added
    22 				;	- Destructive RAM memory test disabled
    23 				;       - Patches from EhBASIC 2.22 added: 
    24 				;         - RAM above code/Ibuff above patch (LAB_20DC)
    25 				;	  - Some function outputs (e.g. FRE()) limited to integers are negative (LAB_UAYFC)
    26 				;         - Use of decimal mode and invalid BCD (LAB_AL2X)
    27 				;	  - First statement after direct mode does not set continue pointer (LAB_1491, LAB_15C2, LAB_163B, LAB_CONT, LAB_1934)
    28 				;	  - String compare of equal strings in direct mode returns FALSE (LAB_1C25)
    29 				;	  - FALSE value stored to a variable after string compare is not exactly zero (LAB_LET)
    30 				;	  - Stack floor protection does not cater for background interrupts (LAB_1212)
    31 				;	  - Allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack (LAB_174D)
    32 				; 2.27	  - INPBUF moved from $768 to $1868. Also moved Decss, Decssp1, ADREL, ADREH, ADRSL, ADRSH to lower ZP-addresses
    33 				; 2.28	  Bugfix ADREL/ADREH, ADRSL/ADRSH. They had other names in BIOS, so should not be removed!
    34 				;	  Bugfix MODE and NUML/NUMH no init. in LAB_LOAD.
    35 				; 2.29	- PORTIO, PORT() and PORT commands extended with extra VIA and MCP23017 ports from JC2 V4.1 and IO2 boards
    36 				;       - SOUND command added
    37 				; ********************************************************************************************************
    38
    39 				; changes by Joerg Walke
    40 				; ----------------------
    41 				; 2022/05/14 added command BEEP
    42 				; 2022/05/15 added command PLIST
    43 				; 2022/05/16 changed BPL SwapErr to BNE SwapErr in LAB_SWAP to avoid command always throwing 'Type mismatch Error'
    44 				; 2024/02/03 Source adapted for MAD-Assembler
    45 				; ********************************************************************************************************
    46
    47 				; zero page use ..
    48 = 0000			LAB_WARM		= $00			; BASIC warm start entry point
    49 = 0001			Wrmjpl 			= LAB_WARM+1		; BASIC warm start vector jump low byte
    50 = 0002			Wrmjph 			= LAB_WARM+2		; BASIC warm start vector jump high byte
    51
    52 				; *** moved from $DC-$E1 - J.Walke 2022/07/29 *****************************
    53 = 0003			NmiBase			= $03			; NMI handler enabled/setup/triggered flags
    54 										; bit	function
    55 										; ===	========
    56 										; 7	interrupt enabled
    57 										; 6	interrupt setup
    58 										; 5	interrupt happened
    59
    60 				;			= $04		; NMI handler addr low byte
    61 				;			= $05		; NMI handler addr high byte
    62 = 0006			IrqBase			= $06		; IRQ handler enabled/setup/triggered flags
    63 				;			= $07		; IRQ handler addr low byte
    64 				;			= $08		; IRQ handler addr high byte
    65
    66 				; *************************************************************************
    67
    68 = 000A			Usrjmp			= $0A		; USR function JMP address
    69 = 000B			Usrjpl			= Usrjmp+1	; USR function JMP vector low byte
    70 = 000C			Usrjph			= Usrjmp+2	; USR function JMP vector high byte
    71 = 000D			Nullct			= $0D		; nulls output after each line
    72 = 000E			TPos			= $0E		; BASIC terminal position byte
    73 = 000F			TWidth			= $0F		; BASIC terminal width byte
    74 = 0010			Iclim			= $10		; input column limit
    75 = 0011			Itempl			= $11		; temporary integer low byte
    76 = 0012			Itemph			= Itempl+1	; temporary integer high byte
    77
    78 = 0011			nums_1			= Itempl	; number to bin/hex string convert MSB
    79 = 0012			nums_2			= nums_1+1	; number to bin/hex string convert
    80 = 0013			nums_3			= nums_1+2	; number to bin/hex string convert LSB
    81
    82 				; *** free space **********************************************************
    83 				;			= $14		; *used by JC2 system
    84 				;			= $15		; *used by JC2 system
    85 				;			= $16		; *used by JC2 system
    86 				;			= $17		; *used by JC2 system
    87 				;			= $18		; *used by JC2 system
    88 				;			= $19		; *used by JC2 system 
    89 				; *************************************************************************
    90
    91 = 001A			Temp1			= $1A		; temporary byte for free use
    92
    93 = 001B			Srchc			= $1B		; search character
    94 = 001B			Temp3			= Srchc		; temp byte used in number routines
    95 = 001C			Scnquo			= $1C		; scan-between-quotes flag
    96 = 001C			Asrch			= Scnquo	; alt search character
    97
    98 = 001B			XOAw_l			= Srchc		; eXclusive OR, OR and AND word low byte
    99 = 001C			XOAw_h			= Scnquo	; eXclusive OR, OR and AND word high byte
   100
   101 = 001D			Ibptr			= $1D		; input buffer pointer
   102 = 001D			Dimcnt			= Ibptr		; # of dimensions
   103 = 001D			Tindx			= Ibptr		; token index
   104
   105 = 001E			Defdim			= $1E		; default DIM flag
   106 = 001F			Dtypef			= $1F		; data type flag, $FF=string, $00=numeric
   107 = 0020			Oquote			= $20		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
   108 = 0020			Gclctd			= $20		; garbage collected flag
   109 = 0021			Sufnxf			= $21		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   110 = 0022			Imode			= $22		; input mode flag, $00=INPUT, $80=READ
   111
   112 = 0023			Cflag			= $23		; comparison evaluation flag
   113
   114 = 0024			TabSiz			= $24		; TAB step size (was input flag)
   115
   116 = 0025			next_s			= $25		; next descriptor stack address
   117
   118 									; these two bytes form a word pointer to the item
   119 									; currently on top of the descriptor stack
   120
   121 = 0026			last_sl			= $26		; last descriptor stack address low byte
   122 = 0027			last_sh			= $27		; last descriptor stack address high byte (always $00)
   123
   124 = 0028			des_sk			= $28		; descriptor stack start address (temp strings)
   125
   126 				;			= $30		; End of descriptor stack
   127
   128 = 0031			ut1_pl			= $31		; utility pointer 1 low byte
   129 = 0032			ut1_ph			= ut1_pl+1	; utility pointer 1 high byte
   130 = 0033			ut2_pl			= $33		; utility pointer 2 low byte
   131 = 0034			ut2_ph			= ut2_pl+1	; utility pointer 2 high byte
   132
   133 = 0031			Temp_2			= ut1_pl	; temp byte for block move	
   134
   135 = 0035			FACt_1			= $35		; FAC temp mantissa1
   136 = 0036			FACt_2			= FACt_1+1	; FAC temp mantissa2
   137 = 0037			FACt_3			= FACt_2+1	; FAC temp mantissa3
   138
   139 = 0036			dims_l			= FACt_2	; array dimension size low byte
   140 = 0037			dims_h			= FACt_3	; array dimension size high byte
   141
   142 = 0038			TempB			= $38		; temp page 0 byte
   143
   144 = 0039			Smeml			= $39		; start of mem low byte		(Start-of-Basic)
   145 = 003A			Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
   146 = 003B			Svarl			= $3B		; start of vars low byte	(Start-of-Variables)
   147 = 003C			Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
   148 = 003D			Sarryl			= $3D		; var mem end low byte		(Start-of-Arrays)
   149 = 003E			Sarryh			= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
   150 = 003F			Earryl			= $3F		; array mem end low byte	(End-of-Arrays)
   151 = 0040			Earryh			= Earryl+1	; array mem end high byte	(End-of-Arrays)
   152 = 0041			Sstorl			= $41		; string storage low byte	(String storage (moving down))
   153 = 0042			Sstorh			= Sstorl+1	; string storage high byte	(String storage (moving down))
   154 = 0043			Sutill			= $43		; string utility ptr low byte
   155 = 0044			Sutilh			= Sutill+1	; string utility ptr high byte
   156 = 0045			Ememl			= $45		; end of mem low byte		(Limit-of-memory)
   157 = 0046			Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
   158 = 0047			Clinel			= $47		; current line low byte		(Basic line number)
   159 = 0048			Clineh			= Clinel+1	; current line high byte	(Basic line number)
   160 = 0049			Blinel			= $49		; break line low byte		(Previous Basic line number)
   161 = 004A			Blineh			= Blinel+1	; break line high byte		(Previous Basic line number)
   162
   163 = 004B			Cpntrl			= $4B		; continue pointer low byte
   164 = 004C			Cpntrh			= Cpntrl+1	; continue pointer high byte
   165
   166 = 004D			Dlinel			= $4D		; current DATA line low byte
   167 = 004E			Dlineh			= Dlinel+1	; current DATA line high byte
   168
   169 = 004F			Dptrl			= $4F		; DATA pointer low byte
   170 = 0050			Dptrh			= Dptrl+1	; DATA pointer high byte
   171
   172 = 0051			Rdptrl			= $51		; read pointer low byte
   173 = 0052			Rdptrh			= Rdptrl+1	; read pointer high byte
   174
   175 = 0053			Varnm1			= $53		; current var name 1st byte
   176 = 0054			Varnm2			= Varnm1+1	; current var name 2nd byte
   177
   178 = 0055			Cvaral			= $55		; current var address low byte
   179 = 0056			Cvarah			= Cvaral+1	; current var address high byte
   180
   181 = 0057			Frnxtl			= $57		; var pointer for FOR/NEXT low byte
   182 = 0058			Frnxth			= Frnxtl+1	; var pointer for FOR/NEXT high byte
   183
   184 = 0057			Tidx1			= Frnxtl	; temp line index
   185
   186 = 0057			Lvarpl			= Frnxtl	; let var pointer low byte
   187 = 0058			Lvarph			= Frnxth	; let var pointer high byte
   188
   189 = 0059			prstk			= $59		; precedence stacked flag
   190
   191 = 005B			comp_f			= $5B		; compare function flag, bits 0,1 and 2 used
   192 									; bit 2 set if >
   193 									; bit 1 set if =
   194 									; bit 0 set if <
   195
   196 = 005C			func_l			= $5C		; function pointer low byte
   197 = 005D			func_h			= func_l+1	; function pointer high byte
   198
   199 = 005C			garb_l			= func_l	; garbage collection working pointer low byte
   200 = 005D			garb_h			= func_h	; garbage collection working pointer high byte
   201
   202 = 005E			des_2l			= $5E		; string descriptor_2 pointer low byte
   203 = 005F			des_2h			= des_2l+1	; string descriptor_2 pointer high byte
   204
   205 = 0060			g_step			= $60		; garbage collect step size
   206
   207 = 0061			Fnxjmp			= $61		; jump vector for functions
   208 = 0062			Fnxjpl			= Fnxjmp+1	; functions jump vector low byte
   209 = 0063			Fnxjph			= Fnxjmp+2	; functions jump vector high byte
   210
   211 = 0062			g_indx			= Fnxjpl	; garbage collect temp index
   212 					
   213 = 0063			FAC2_r			= $63		; FAC2 rounding byte
   214
   215 = 0064			Adatal			= $64		; array data pointer low byte
   216 = 0065			Adatah			= Adatal+1	; array data pointer high  byte
   217
   218 = 0064			Nbendl			= Adatal	; new block end pointer low byte
   219 = 0065			Nbendh			= Adatah	; new block end pointer high  byte
   220
   221 = 0066			Obendl			= $66		; old block end pointer low byte
   222 = 0067			Obendh			= Obendl+1	; old block end pointer high  byte
   223
   224 = 0068			numexp			= $68		; string to float number exponent count
   225 = 0069			expcnt			= $69		; string to float exponent count
   226
   227 = 0068			numbit			= numexp	; bit count for array element calculations
   228
   229 = 006A			numdpf			= $6A		; string to float decimal point flag
   230 = 006B			expneg			= $6B		; string to float eval exponent -ve flag
   231
   232 = 006A			Astrtl			= numdpf	; array start pointer low byte
   233 = 006B			Astrth			= expneg	; array start pointer high  byte
   234
   235 = 006A			Histrl			= numdpf	; highest string low byte
   236 = 006B			Histrh			= expneg	; highest string high  byte
   237
   238 = 006A			Baslnl			= numdpf	; BASIC search line pointer low byte
   239 = 006B			Baslnh			= expneg	; BASIC search line pointer high  byte
   240
   241 = 006A			Fvar_l			= numdpf	; find/found variable pointer low byte
   242 = 006B			Fvar_h			= expneg	; find/found variable pointer high  byte
   243
   244 = 006A			Ostrtl			= numdpf	; old block start pointer low byte
   245 = 006B			Ostrth			= expneg	; old block start pointer high  byte
   246
   247 = 006A			Vrschl			= numdpf	; variable search pointer low byte
   248 = 006B			Vrschh			= expneg	; variable search pointer high  byte
   249
   250 = 006C			FAC1_e			= $6C		; FAC1 exponent
   251 = 006D			FAC1_1			= FAC1_e+1	; FAC1 mantissa1
   252 = 006E			FAC1_2			= FAC1_e+2	; FAC1 mantissa2
   253 = 006F			FAC1_3			= FAC1_e+3	; FAC1 mantissa3
   254 = 0070			FAC1_s			= FAC1_e+4	; FAC1 sign (b7)
   255
   256 = 006C			str_ln			= FAC1_e	; string length
   257 = 006D			str_pl			= FAC1_1	; string pointer low byte
   258 = 006E			str_ph			= FAC1_2	; string pointer high byte
   259
   260 = 006E			des_pl			= FAC1_2	; string descriptor pointer low byte
   261 = 006F			des_ph			= FAC1_3	; string descriptor pointer high byte
   262
   263 = 006F			mids_l			= FAC1_3	; MID$ string temp length byte
   264
   265 = 0071			negnum			= $71		; string to float eval -ve flag
   266 = 0071			numcon			= $71		; series evaluation constant count
   267
   268 = 0072			FAC1_o			= $72		; FAC1 overflow byte
   269
   270 = 0073			FAC2_e			= $73		; FAC2 exponent
   271 = 0074			FAC2_1			= FAC2_e+1	; FAC2 mantissa1
   272 = 0075			FAC2_2			= FAC2_e+2	; FAC2 mantissa2
   273 = 0076			FAC2_3			= FAC2_e+3	; FAC2 mantissa3
   274 = 0077			FAC2_s			= FAC2_e+4	; FAC2 sign (b7)
   275
   276 = 0078			FAC_sc			= $78		; FAC sign comparison, Acc#1 vs #2
   277 = 0079			FAC1_r			= $79		; FAC1 rounding byte
   278
   279 = 0078			ssptr_l			= FAC_sc	; string start pointer low byte
   280 = 0079			ssptr_h			= FAC1_r	; string start pointer high byte
   281
   282 = 0078			sdescr			= FAC_sc	; string descriptor pointer
   283
   284 = 007A			csidx			= $7A		; line crunch save index
   285 = 007A			Asptl			= csidx		; array size/pointer low byte
   286 = 007B			Aspth			= $7B		; array size/pointer high byte
   287
   288 = 007A			Btmpl			= Asptl		; BASIC pointer temp low byte
   289 = 007B			Btmph			= Aspth		; BASIC pointer temp low byte
   290
   291 = 007A			Cptrl			= Asptl		; BASIC pointer temp low byte
   292 = 007B			Cptrh			= Aspth		; BASIC pointer temp low byte
   293
   294 = 007A			Sendl			= Asptl		; BASIC pointer temp low byte
   295 = 007B			Sendh			= Aspth		; BASIC pointer temp low byte
   296
   297 = 007C			LAB_IGBY		= $7C		; get next BASIC byte subroutine
   298
   299 = 0082			LAB_GBYT		= $82		; get current BASIC byte subroutine
   300 = 0083			Bpntrl			= $83		; BASIC execute (get byte) pointer low byte
   301 = 0084			Bpntrh			= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   302
   303 				;			= $97		; end of get BASIC char subroutine
   304
   305 = 0098			Rbyte4			= $98		; extra PRNG byte
   306 = 0099			Rbyte1			= Rbyte4+1	; most significant PRNG byte
   307 = 009A			Rbyte2			= Rbyte4+2	; middle PRNG byte
   308 = 009B			Rbyte3			= Rbyte4+3	; least significant PRNG byte
   309
   310 = 009C			I2Cstat			= $9C		; BASIC I2C read byte or ACK/NACK bit
   311 = 009D			Decss			= $9D		; BASIC number to decimal string start LSB (moved from $EF)
   312 = 009E			Decssp1			= $9E		; BASIC number to decimal string start MSB (moved from $F0)
   313
   314 				; token values needed for BASIC
   315
   316 				; primary command tokens (can start a statement)
   317
   318 = 0080			TK_END		= $80			; END token
   319 = 0081			TK_FOR		= TK_END+1		; FOR token
   320 = 0082			TK_NEXT		= TK_FOR+1		; NEXT token
   321 = 0083			TK_DATA		= TK_NEXT+1		; DATA token
   322 = 0084			TK_INPUT	= TK_DATA+1		; INPUT token
   323 = 0085			TK_DIM		= TK_INPUT+1		; DIM token
   324 = 0086			TK_READ		= TK_DIM+1		; READ token
   325 = 0087			TK_LET		= TK_READ+1		; LET token
   326 = 0088			TK_DEC		= TK_LET+1		; DEC token
   327 = 0089			TK_GOTO		= TK_DEC+1		; GOTO token
   328 = 008A			TK_RUN		= TK_GOTO+1		; RUN token
   329 = 008B			TK_IF		= TK_RUN+1		; IF token
   330 = 008C			TK_RESTORE	= TK_IF+1		; RESTORE token
   331 = 008D			TK_GOSUB	= TK_RESTORE+1		; GOSUB token
   332 = 008E			TK_SOUND	= TK_GOSUB+1		; SOUND token
   333 = 008F			TK_RES2		= TK_SOUND+1		; RES2 token
   334 = 0090			TK_RETURN	= TK_RES2+1		; RETURN token
   335 = 0091			TK_REM		= TK_RETURN+1		; REM token
   336 = 0092			TK_STOP		= TK_REM+1		; STOP token
   337 = 0093			TK_ON		= TK_STOP+1		; ON token
   338 = 0094			TK_NULL		= TK_ON+1		; NULL token
   339 = 0095			TK_INC		= TK_NULL+1		; INC token
   340 = 0096			TK_WAIT		= TK_INC+1		; WAIT token
   341 = 0097			TK_LOAD		= TK_WAIT+1		; LOAD token
   342 = 0098			TK_SAVE		= TK_LOAD+1		; SAVE token
   343 = 0099			TK_DEF		= TK_SAVE+1		; DEF token
   344 = 009A			TK_POKE		= TK_DEF+1		; POKE token
   345 = 009B			TK_DOKE		= TK_POKE+1		; DOKE token
   346 = 009C			TK_CALL		= TK_DOKE+1		; CALL token
   347 = 009D			TK_DO		= TK_CALL+1		; DO token
   348 = 009E			TK_LOOP		= TK_DO+1		; LOOP token
   349 = 009F			TK_PRINT	= TK_LOOP+1		; PRINT token
   350 = 00A0			TK_CONT		= TK_PRINT+1		; CONT token
   351 = 00A1			TK_LIST		= TK_CONT+1		; LIST token
   352 = 00A2			TK_CLEAR	= TK_LIST+1		; CLEAR token
   353 = 00A3			TK_NEW		= TK_CLEAR+1		; NEW token
   354 = 00A4			TK_WIDTH	= TK_NEW+1		; WIDTH token
   355 = 00A5			TK_GET		= TK_WIDTH+1		; GET token
   356 = 00A6			TK_SWAP		= TK_GET+1		; SWAP token
   357 = 00A7			TK_BITSET	= TK_SWAP+1		; BITSET token
   358 = 00A8			TK_BITCLR	= TK_BITSET+1		; BITCLR token
   359 = 00A9			TK_RES3		= TK_BITCLR+1		; RES3 token
   360 = 00AA			TK_RES4		= TK_RES3+1		; RES4 token
   361 = 00AB			TK_BEEP		= TK_RES4+1		; BEEP token
   362 = 00AC			TK_PLIST    	= TK_BEEP+1		; PLIST token
   363 = 00AD			TK_HOME		= TK_PLIST+1		; HOME token
   364 = 00AE			TK_CLS		= TK_HOME+1		; CLS token
   365 = 00AF			TK_NORMAL	= TK_CLS+1		; NORMAL token
   366 = 00B0			TK_INVERSE	= TK_NORMAL+1		; INVERSE token
   367 = 00B1			TK_FLASH	= TK_INVERSE+1		; FLASH token
   368 = 00B2			TK_LOCATE	= TK_FLASH+1		; LOCATE token	
   369 = 00B3			TK_INNUM	= TK_LOCATE+1		; IN# token
   370 = 00B4			TK_PRNUM	= TK_INNUM+1		; PR# token
   371 = 00B5			TK_PORTIO	= TK_PRNUM+1		; PORTIO token
   372 = 00B6			TK_PORTOUT	= TK_PORTIO+1		; PORTOUT token
   373 = 00B7			TK_SCREEN	= TK_PORTOUT+1		; SCREEN token ###
   374 = 00B8			TK_PIXEL	= TK_SCREEN+1		; PIXEL token ###
   375 = 00B9			TK_LINE		= TK_PIXEL+1		; LINE token ###
   376 = 00BA			TK_OVAL		= TK_LINE+1		; OVAL token ###
   377 = 00BB			TK_RECT		= TK_OVAL+1		; RECT token ###
   378 = 00BC			TK_COLOR	= TK_RECT+1		; COLOR token ###
   379 = 00BD			TK_DELAY	= TK_COLOR+1		; DELAY token
   380 = 00BE			TK_I2COUT	= TK_DELAY+1		; I2Cout token
   381 = 00BF			TK_DOS		= TK_I2COUT+1		; DOS token
   382
   383 				; secondary command tokens, can't start a statement
   384
   385 = 00C0			TK_TAB		= TK_DOS+1		; TAB token
   386 = 00C1			TK_ELSE		= TK_TAB+1		; ELSE token
   387 = 00C2			TK_TO		= TK_ELSE+1		; TO token
   388 = 00C3			TK_FN		= TK_TO+1		; FN token
   389 = 00C4			TK_SPC		= TK_FN+1		; SPC token
   390 = 00C5			TK_THEN		= TK_SPC+1		; THEN token
   391 = 00C6			TK_NOT		= TK_THEN+1		; NOT token
   392 = 00C7			TK_STEP		= TK_NOT+1		; STEP token
   393 = 00C8			TK_UNTIL	= TK_STEP+1		; UNTIL token
   394 = 00C9			TK_WHILE	= TK_UNTIL+1		; WHILE token
   395 = 00CA			TK_OFF		= TK_WHILE+1		; OFF token, removed!
   396
   397 				; opperator tokens
   398
   399 = 00CB			TK_PLUS		= TK_OFF+1		; + token
   400 = 00CC			TK_MINUS	= TK_PLUS+1		; - token
   401 = 00CD			TK_MUL		= TK_MINUS+1		; * token
   402 = 00CE			TK_DIV		= TK_MUL+1		; / token
   403 = 00CF			TK_MOD		= TK_DIV+1		; MOD token ###
   404 = 00D0			TK_POWER	= TK_MOD+1		; ^ token
   405 = 00D1			TK_AND		= TK_POWER+1		; AND token
   406 = 00D2			TK_EOR		= TK_AND+1		; EOR token
   407 = 00D3			TK_OR		= TK_EOR+1		; OR token
   408 = 00D4			TK_RSHIFT	= TK_OR+1		; RSHIFT token
   409 = 00D5			TK_LSHIFT	= TK_RSHIFT+1		; LSHIFT token
   410 = 00D6			TK_GT		= TK_LSHIFT+1		; > token
   411 = 00D7			TK_EQUAL	= TK_GT+1		; = token
   412 = 00D8			TK_LT		= TK_EQUAL+1		; < token
   413
   414 				; functions tokens
   415
   416 = 00D9			TK_SGN		= TK_LT+1		; SGN token
   417 = 00DA			TK_INT		= TK_SGN+1		; INT token
   418 = 00DB			TK_ABS		= TK_INT+1		; ABS token
   419 = 00DC			TK_USR		= TK_ABS+1		; USR token
   420 = 00DD			TK_FRE		= TK_USR+1		; FRE token
   421 = 00DE			TK_POS		= TK_FRE+1		; POS token
   422 = 00DF			TK_SQR		= TK_POS+1		; SQR token
   423 = 00E0			TK_RND		= TK_SQR+1		; RND token
   424 = 00E1			TK_LOG		= TK_RND+1		; LOG token
   425 = 00E2			TK_EXP		= TK_LOG+1		; EXP token
   426 = 00E3			TK_COS		= TK_EXP+1		; COS token
   427 = 00E4			TK_SIN		= TK_COS+1		; SIN token
   428 = 00E5			TK_TAN		= TK_SIN+1		; TAN token
   429 = 00E6			TK_ATN		= TK_TAN+1		; ATN token
   430 = 00E7			TK_PEEK		= TK_ATN+1		; PEEK token
   431 = 00E8			TK_DEEK		= TK_PEEK+1		; DEEK token
   432 = 00E9			TK_SADD		= TK_DEEK+1		; SADD token
   433 = 00EA			TK_LEN		= TK_SADD+1		; LEN token
   434 = 00EB			TK_STRS		= TK_LEN+1		; STR$ token
   435 = 00EC			TK_VAL		= TK_STRS+1		; VAL token
   436 = 00ED			TK_ASC		= TK_VAL+1		; ASC token
   437 = 00EE			TK_UCASES	= TK_ASC+1		; UCASE$ token
   438 = 00EF			TK_LCASES	= TK_UCASES+1		; LCASE$ token
   439 = 00F0			TK_CHRS		= TK_LCASES+1		; CHR$ token
   440 = 00F1			TK_HEXS		= TK_CHRS+1		; HEX$ token
   441 = 00F2			TK_BINS		= TK_HEXS+1		; BIN$ token
   442 = 00F3			TK_BITTST	= TK_BINS+1		; BITTST token
   443 = 00F4			TK_MAX		= TK_BITTST+1		; MAX token
   444 = 00F5			TK_MIN		= TK_MAX+1		; MIN token
   445 = 00F6			TK_PI		= TK_MIN+1		; PI token
   446 = 00F7			TK_TWOPI	= TK_PI+1		; TWOPI token
   447 = 00F8			TK_VPTR		= TK_TWOPI+1		; VARPTR token
   448 = 00F9			TK_LEFTS	= TK_VPTR+1		; LEFT$ token
   449 = 00FA			TK_RIGHTS	= TK_LEFTS+1		; RIGHT$ token
   450 = 00FB			TK_MIDS		= TK_RIGHTS+1		; MID$ token
   451 = 00FC			TK_PORTIN	= TK_MIDS+1		; PORTIN token
   452 = 00FD			TK_I2CIN	= TK_PORTIN+1		; I2CIN token
   453 = 00FE			TK_RES5		= TK_I2CIN+1		; RESERVED ###
   454 = 00FF			TK_RES6		= TK_RES5+1		; RESERVED ###
   455
   456 				; offsets from a base of X or Y
   457 = 0000			PLUS_0		= $00			; X or Y plus 0
   458 = 0001			PLUS_1		= $01			; X or Y plus 1
   459 = 0002			PLUS_2		= $02			; X or Y plus 2
   460 = 0003			PLUS_3		= $03			; X or Y plus 3
   461
   462 = 0100			LAB_STAK	= $0100			; stack bottom, no offset
   463 = 01FE			LAB_SKFE	= LAB_STAK+$FE		; flushed stack address
   464 = 01FF			LAB_SKFF	= LAB_STAK+$FF		; flushed stack address
   465
   466 = 2001			Ram_base	= $2001			; start of user RAM (set as needed, should be page aligned)
   467 = 0010			Stack_floor	= 16			; bytes left free on stack for background interrupts
   468
   469 				; INPBUF moved to jc2_defines.inc 
   470
   471 				; Constants defined for I2Cin() and I2Cout functions
   472 = 0001			I2C_STA		= 1			; I2Cout Start command
   473 = 0000			I2C_STAT	= 0			; I2Cin return I2Cstat value
   474 = 0001			I2C_RD_ACK	= 1			; I2Cin Read + ACK
   475 = 0002			I2C_RD_NAK	= 2			; I2Cin Read + NACK + Stop
   476 = 0003			I2C_STO		= 3			; I2Cin Stop only
   477
   478 				; BASIC cold start entry point
   479 				; new page 2 initialisation, copy block to ccflag on
   480 B000			LAB_COLD
   481 B000 A0 04			LDY	#PG2_TABE-PG2_TABS-1
   482 										; byte count-1
   483 B002			LAB_2D13
   484 B002 B9 05 D3			LDA	PG2_TABS,Y			; get byte
   485 B005 99 68 18			STA	ccflag,Y			; store in page 2
   486 B008 88				DEY					; decrement count
   487 B009 10 F7			BPL	LAB_2D13			; loop if not done
   488
   489 B00B A2 FF			LDX	#$FF				; set byte
   490 B00D 86 48			STX	Clineh				; set current line high byte (set immediate mode)
   491 B00F 9A				TXS					; reset stack pointer
   492
   493 B010 A9 4C			LDA	#$4C				; code for JMP
   494 B012 85 61			STA	Fnxjmp				; save for jump vector for functions
   495
   496 				; copy block from LAB_2CEE to $00BC - $00D3
   497 B014 A2 1C			LDX	#StrTab-LAB_2CEE		; set byte count
   498 B016			LAB_2D4E
   499 B016 BD 09 D3			LDA	LAB_2CEE-1,X			; get byte from table
   500 B019 95 7B			STA	LAB_IGBY-1,X			; save byte in page zero
   501 B01B CA				DEX					; decrement count
   502 B01C D0 F8			BNE	LAB_2D4E			; loop if not all done
   503
   504 				; copy block from StrTab to $0000 - $0012
   505 B01E			LAB_GMEM
   506 B01E A2 12			LDX	#EndTab-StrTab-1; set byte count-1
   507 B020			TabLoop
   508 B020 BD 26 D3			LDA	StrTab,X			; get byte from table
   509 B023 95 00			STA	PLUS_0,X			; save byte in page zero
   510 B025 CA				DEX					; decrement count
   511 B026 10 F8			BPL	TabLoop				; loop if not all done
   512
   513 				; set-up start values
   514
   515 B028 A9 00			LDA	#$00				; clear A
   516 B02A 85 03			STA	NmiBase				; clear NMI handler enabled flag
   517 B02C 85 06			STA	IrqBase				; clear IRQ handler enabled flag
   518 B02E 85 72			STA	FAC1_o				; clear FAC1 overflow byte
   519 B030 85 27			STA	last_sh				; clear descriptor stack top item pointer high byte
   520
   521 B032 A9 0E			LDA	#$0E				; set default tab size
   522 B034 85 24			STA	TabSiz				; save it
   523 B036 A9 03			LDA	#$03				; set garbage collect step size for descriptor stack
   524 B038 85 60			STA	g_step				; save it
   525 B03A A2 28			LDX	#des_sk				; descriptor stack start
   526 B03C 86 25			STX	next_s				; set descriptor stack pointer
   527 B03E 20 58 B8			JSR	LAB_CRLF			; print CR/LF
   528 				; #########################	
   529 B041 20 32 D1			JSR	CLEAR_BASE			; clear first two bytes of memory to avoid crash
   530 				; #########################	
   531 B044 A9 39			LDA	#<LAB_MSZM			; point to memory size message (low addr)
   532 B046 A0 D3			LDY	#>LAB_MSZM			; point to memory size message (high addr)
   533 B048 20 99 B8			JSR	LAB_18C3			; print null terminated string from memory
   534 				;	JSR	LAB_INLN			; print '? ' and get BASIC input
   535 B04B 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   536 B04D 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   537 				;	JSR	LAB_GBYT			; get last byte back
   538
   539 				;	BNE	LAB_2DAA			; branch if not null (user typed something)
   540
   541 				;	LDY	#$00				; else clear Y
   542 										; character was null so get memory size the hard way
   543 										; we get here with Y=0 and Itempl/h = Ram_base
   544 B04F			LAB_2D93	; Disable destructive RAM-test, which did set all available memory to $AA
   545 B04F A9 00			LDA	#<RAM_TOP			; A = LSB of RAM_TOP
   546 B051 A0 B0			LDY	#>RAM_TOP			; Y = MSB of RAM_TOP
   547 				;	INC	Itempl				; increment temporary integer low byte
   548 				;	BNE	LAB_2D99			; branch if no overflow
   549 				;
   550 				;	INC	Itemph				; increment temporary integer high byte
   551 				;	LDA	Itemph				; get high byte
   552 				;	CMP	#>RAM_TOP			; compare with top of RAM+1
   553 				;	BEQ	LAB_2DB6			; branch if match (end of user RAM)
   554 				;
   555 				;LAB_2D99
   556 				;	LDA	#$55				; set test byte
   557 				;	STA	(Itempl),Y			; save via temporary integer
   558 				;	CMP	(Itempl),Y			; compare via temporary integer
   559 				;	BNE	LAB_2DB6			; branch if fail
   560 				;
   561 				;	ASL					; shift test byte left (now $AA)
   562 				;	STA	(Itempl),Y			; save via temporary integer
   563 				;	CMP	(Itempl),Y			; compare via temporary integer
   564 				;	BEQ	LAB_2D93			; if ok go do next byte
   565 				;
   566 				;	BNE	LAB_2DB6			; branch if fail
   567 				;
   568 				;LAB_2DAA
   569 				;	JSR	LAB_2887			; get FAC1 from string
   570 				;	LDA	FAC1_e				; get FAC1 exponent
   571 				;	CMP	#$98				; compare with exponent = 2^24
   572 				;	BCS	LAB_GMEM			; if too large go try again
   573 				;
   574 				;	JSR	LAB_F2FU			; save integer part of FAC1 in temporary integer
   575 				;						; (no range check)
   576 				;
   577 				;LAB_2DB6
   578 				;	LDA	Itempl				; get temporary integer low byte
   579 				;	LDY	Itemph				; get temporary integer high byte
   580 				;	CPY	#<Ram_base+1			; compare with start of RAM+$100 high byte
   581 				;	BCC	LAB_GMEM			; if too small go try again
   582 				;
   583 				;
   584 				; uncomment these lines if you want to check on the high limit of memory. Note if
   585 				; RAM_TOP is set too low then this will fail. default is ignore it and assume the
   586 				; users know what they're doing!
   587
   588 				;	CPY	#>RAM_TOP			; compare with top of RAM high byte
   589 				;	BCC	MEM_OK				; branch if < RAM top
   590
   591 				;	BNE	LAB_GMEM			; if too large go try again
   592 										; else was = so compare low bytes
   593 				;	CMP	#<RAM_TOP			; compare with top of RAM low byte
   594 				;	BEQ	MEM_OK				; branch if = RAM top
   595
   596 				;	BCS	LAB_GMEM			; if too large go try again
   597 				;MEM_OK
   598 B053 85 45			STA	Ememl				; set end of mem low byte
   599 B055 84 46			STY	Ememh				; set end of mem high byte
   600 B057 85 41			STA	Sstorl				; set bottom of string space low byte
   601 B059 84 42			STY	Sstorh				; set bottom of string space high byte
   602
   603 B05B A0 01			LDY	#<Ram_base			; set start addr low byte
   604 B05D A2 20			LDX	#>Ram_base			; set start addr high byte
   605 B05F 84 39			STY	Smeml				; save start of mem low byte
   606 B061 86 3A			STX	Smemh				; save start of mem high byte
   607
   608 				; this line is only needed if Ram_base is not $xx00
   609
   610 				;	LDY	#$00				; clear Y
   611 B063 98				TYA					; clear A
   612 B064 91 39			STA	(Smeml),Y			; clear first byte
   613 B066 E6 39			INC	Smeml				; increment start of mem low byte
   614
   615 				; these two lines are only needed if Ram_base is $xxFF
   616
   617 				;	BNE	LAB_2E05			; branch if no rollover
   618
   619 				;	INC	Smemh				; increment start of mem high byte
   620 B068			LAB_2E05
   621 B068 20 58 B8			JSR	LAB_CRLF			; print CR/LF
   622 B06B 20 33 B3			JSR	LAB_1463			; do 'NEW' and 'CLEAR'
   623 B06E A5 45			LDA	Ememl				; get end of mem low byte
   624 B070 38				SEC					; set carry for subtract
   625 B071 E5 39			SBC	Smeml				; subtract start of mem low byte
   626 B073 AA				TAX					; copy to X
   627 B074 A5 46			LDA	Ememh				; get end of mem high byte
   628 B076 E5 3A			SBC	Smemh				; subtract start of mem high byte
   629 B078 20 57 CA			JSR	LAB_295E			; print XA as unsigned integer (bytes free)
   630 B07B A9 4E			LDA	#<LAB_SMSG			; point to sign-on message (low addr)
   631 B07D A0 D3			LDY	#>LAB_SMSG			; point to sign-on message (high addr)
   632 B07F 20 99 B8			JSR	LAB_18C3			; print null terminated string from memory
   633 B082 A9 2C			LDA	#<LAB_1274			; warm start vector low byte
   634 B084 A0 B1			LDY	#>LAB_1274			; warm start vector high byte
   635 B086 85 01			STA	Wrmjpl				; save warm start vector low byte
   636 B088 84 02			STY	Wrmjph				; save warm start vector high byte
   637 B08A 6C 01 00			JMP	(Wrmjpl)			; go do warm start
   638
   639 				; open up space in memory
   640 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   641
   642 				; Nbendl,Nbendh - new block end address (A/Y)
   643 				; Obendl,Obendh - old block end address
   644 				; Ostrtl,Ostrth - old block start address
   645
   646 				; returns with ..
   647
   648 				; Nbendl,Nbendh - new block start address (high byte - $100)
   649 				; Obendl,Obendh - old block start address (high byte - $100)
   650 				; Ostrtl,Ostrth - old block start address (unchanged)
   651 B08D			LAB_11CF
   652 B08D 20 DA B0			JSR	LAB_121F			; check available memory, 'Out of memory' error if no room
   653 										; addr to check is in AY (low/high)
   654 B090 85 3F			STA	Earryl				; save new array mem end low byte
   655 B092 84 40			STY	Earryh				; save new array mem end high byte
   656
   657 				; open up space in memory
   658 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   659 				; don't set array end
   660 B094			LAB_11D6
   661 B094 38				SEC					; set carry for subtract
   662 B095 A5 66			LDA	Obendl				; get block end low byte
   663 B097 E5 6A			SBC	Ostrtl				; subtract block start low byte
   664 B099 A8				TAY					; copy MOD(block length/$100) byte to Y
   665 B09A A5 67			LDA	Obendh				; get block end high byte
   666 B09C E5 6B			SBC	Ostrth				; subtract block start high byte
   667 B09E AA				TAX					; copy block length high byte to X
   668 B09F E8				INX					; +1 to allow for count=0 exit
   669 B0A0 98				TYA					; copy block length low byte to A
   670 B0A1 F0 24			BEQ	LAB_120A			; branch if length low byte=0
   671
   672 										; block is (X-1)*256+Y bytes, do the Y bytes first
   673
   674 B0A3 38				SEC					; set carry for add + 1, two's complement
   675 B0A4 49 FF			EOR	#$FF				; invert low byte for subtract
   676 B0A6 65 66			ADC	Obendl				; add block end low byte
   677
   678 B0A8 85 66			STA	Obendl				; save corrected old block end low byte
   679 B0AA B0 03			BCS	LAB_11F3			; branch if no underflow
   680
   681 B0AC C6 67			DEC	Obendh				; else decrement block end high byte
   682 B0AE 38				SEC					; set carry for add + 1, two's complement
   683 B0AF			LAB_11F3
   684 B0AF 98				TYA					; get MOD(block length/$100) byte
   685 B0B0 49 FF			EOR	#$FF				; invert low byte for subtract
   686 B0B2 65 64			ADC	Nbendl				; add destination end low byte
   687 B0B4 85 64			STA	Nbendl				; save modified new block end low byte
   688 B0B6 B0 08			BCS	LAB_1203			; branch if no underflow
   689
   690 B0B8 C6 65			DEC	Nbendh				; else decrement block end high byte
   691 B0BA 90 04			BCC	LAB_1203			; branch always
   692
   693 B0BC			LAB_11FF
   694 B0BC B1 66			LDA	(Obendl),Y			; get byte from source
   695 B0BE 91 64			STA	(Nbendl),Y			; copy byte to destination
   696 B0C0			LAB_1203
   697 B0C0 88				DEY					; decrement index
   698 B0C1 D0 F9			BNE	LAB_11FF			; loop until Y=0
   699
   700 										; now do Y=0 indexed byte
   701 B0C3 B1 66			LDA	(Obendl),Y			; get byte from source
   702 B0C5 91 64			STA	(Nbendl),Y			; save byte to destination
   703 B0C7			LAB_120A
   704 B0C7 C6 67			DEC	Obendh				; decrement source pointer high byte
   705 B0C9 C6 65			DEC	Nbendh				; decrement destination pointer high byte
   706 B0CB CA				DEX					; decrement block count
   707 B0CC D0 F2			BNE	LAB_1203			; loop until count = $0
   708
   709 B0CE 60				RTS
   710
   711 				; check room on stack for A bytes
   712 				; stack too deep? do OM error
   713 B0CF			LAB_1212
   714 					.if	Stack_floor			; Stack floor protection patch
   715 B0CF 18				CLC					; prep ADC
   716 B0D0 69 10			ADC	#Stack_floor			; stack pointer lower limit before interrupts
   717 					.endif
   718 B0D2 85 38			STA	TempB				; save result in temp byte
   719 B0D4 BA				TSX					; copy stack
   720 B0D5 E4 38			CPX	TempB				; compare new 'limit' with stack
   721 B0D7 90 30			BCC	LAB_OMER			; if stack < limit do 'Out of memory' error then warm start
   722
   723 B0D9 60				RTS
   724
   725 				; check available memory, 'Out of memory' error if no room
   726 				; addr to check is in AY (low/high)
   727 B0DA			LAB_121F
   728 B0DA C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   729 B0DC 90 2A			BCC	LAB_124B			; if less then exit (is ok)
   730
   731 B0DE D0 04			BNE	LAB_1229			; skip next test if greater (tested <)
   732
   733 										; high byte was =, now do low byte
   734 B0E0 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   735 B0E2 90 24			BCC	LAB_124B			; if less then exit (is ok)
   736
   737 										; addr is > string storage ptr (oops!)
   738 B0E4			LAB_1229
   739 B0E4 48				PHA					; push addr low byte
   740 B0E5 A2 08			LDX	#$08				; set index to save Adatal to expneg inclusive
   741 B0E7 98				TYA					; copy addr high byte (to push on stack)
   742
   743 										; save misc numeric work area
   744 B0E8			LAB_122D
   745 B0E8 48				PHA					; push byte
   746 B0E9 B5 63			LDA	Adatal-1,X			; get byte from Adatal to expneg ( ,$00 not pushed)
   747 B0EB CA				DEX					; decrement index
   748 B0EC 10 FA			BPL	LAB_122D			; loop until all done
   749
   750 B0EE 20 B4 C1			JSR	LAB_GARB			; garbage collection routine
   751
   752 										; restore misc numeric work area
   753 B0F1 A2 00			LDX	#$00				; clear the index to restore bytes
   754 B0F3			LAB_1238
   755 B0F3 68				PLA					; pop byte
   756 B0F4 95 64			STA	Adatal,X			; save byte to Adatal to expneg
   757 B0F6 E8				INX					; increment index
   758 B0F7 E0 08			CPX	#$08				; compare with end + 1
   759 B0F9 30 F8			BMI	LAB_1238			; loop if more to do
   760
   761 B0FB 68				PLA					; pop addr high byte
   762 B0FC A8				TAY					; copy back to Y
   763 B0FD 68				PLA					; pop addr low byte
   764 B0FE C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   765 B100 90 06			BCC	LAB_124B			; if less then exit (is ok)
   766
   767 B102 D0 05			BNE	LAB_OMER			; if greater do 'Out of memory' error then warm start
   768
   769 										; high byte was =, now do low byte
   770 B104 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   771 B106 B0 01			BCS	LAB_OMER			; if >= do 'Out of memory' error then warm start
   772
   773 										; ok exit, carry clear
   774 B108			LAB_124B
   775 B108 60				RTS
   776
   777 				; do 'Out of memory' error then warm start
   778 B109			LAB_OMER
   779 B109 A2 0C			LDX	#$0C				; error code $0C ('Out of memory' error)
   780
   781 				; do error #X, then warm start
   782 B10B			LAB_XERR
   783 B10B 20 41 D1			JSR	LAB_SYSBEEP
   784 B10E 20 58 B8			JSR	LAB_CRLF			; print CR/LF
   785
   786 B111 BD D0 D9			LDA	LAB_BAER,X			; get error message pointer low byte
   787 B114 BC D1 D9			LDY	LAB_BAER+1,X			; get error message pointer high byte
   788 B117 20 99 B8			JSR	LAB_18C3			; print null terminated string from memory
   789
   790 B11A 20 6C B3			JSR	LAB_1491			; flush stack and clear continue flag
   791 B11D A9 0D			LDA	#<LAB_EMSG			; point to ' Error' low addr
   792 B11F A0 DB			LDY	#>LAB_EMSG			; point to ' Error' high addr
   793 B121			LAB_1269
   794 B121 20 99 B8			JSR	LAB_18C3			; print null terminated string from memory
   795 B124 A4 48			LDY	Clineh				; get current line high byte
   796 B126 C8				INY					; increment it
   797 B127 F0 03			BEQ	LAB_1274			; go do warm start (was immediate mode)
   798
   799 										; else print line number
   800 B129 20 4C CA			JSR	LAB_2953			; print ' in line [LINE #]'
   801
   802 				; BASIC warm start entry point
   803 				; wait for Basic command
   804 B12C			LAB_1274
   805 										; clear ON IRQ/NMI bytes
   806 B12C A9 00			LDA	#$00				; clear A
   807 B12E 85 06			STA	IrqBase				; clear enabled byte
   808 B130 85 03			STA	NmiBase				; clear enabled byte
   809 B132 A9 1E			LDA	#<LAB_RMSG			; point to 'Ready' message low byte
   810 B134 A0 DB			LDY	#>LAB_RMSG			; point to 'Ready' message high byte
   811
   812 B136 20 99 B8			JSR	LAB_18C3			; go do print string
   813
   814 				; wait for Basic command (no 'Ready')
   815 B139			LAB_127D
   816 B139 20 1F B2			JSR	LAB_1357			; call for BASIC input
   817 B13C			LAB_1280
   818 B13C 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   819 B13E 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   820 B140 20 82 00			JSR	LAB_GBYT			; scan memory
   821 B143 F0 F4			BEQ	LAB_127D			; loop while null
   822
   823 				; got to interpret input line now ..
   824 B145 A2 FF			LDX	#$FF				; current line to null value
   825 B147 86 48			STX	Clineh				; set current line high byte
   826 B149 90 06			BCC	LAB_1295			; branch if numeric character (handle new BASIC line)
   827
   828 										; no line number .. immediate mode
   829 B14B 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   830 B14E 4C D2 B4			JMP	LAB_15F6			; go scan and interpret code
   831
   832 				; handle new BASIC line
   833 B151			LAB_1295
   834 B151 20 1B B7			JSR	LAB_GFPN			; get fixed-point number into temp integer
   835 B154 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   836 B157 84 1D			STY	Ibptr				; save index pointer to end of crunched line
   837 B159 20 07 B3			JSR	LAB_SSLN			; search BASIC for temp integer line number
   838 B15C 90 44			BCC	LAB_12E6			; branch if not found
   839
   840 										; aroooogah! line # already exists! delete it
   841 B15E A0 01			LDY	#$01				; set index to next line pointer high byte
   842 B160 B1 6A			LDA	(Baslnl),Y			; get next line pointer high byte
   843 B162 85 32			STA	ut1_ph				; save it
   844 B164 A5 3B			LDA	Svarl				; get start of vars low byte
   845 B166 85 31			STA	ut1_pl				; save it
   846 B168 A5 6B			LDA	Baslnh				; get found line pointer high byte
   847 B16A 85 34			STA	ut2_ph				; save it
   848 B16C A5 6A			LDA	Baslnl				; get found line pointer low byte
   849 B16E 88				DEY					; decrement index
   850 B16F F1 6A			SBC	(Baslnl),Y			; subtract next line pointer low byte
   851 B171 18				CLC					; clear carry for add
   852 B172 65 3B			ADC	Svarl				; add start of vars low byte
   853 B174 85 3B			STA	Svarl				; save new start of vars low byte
   854 B176 85 33			STA	ut2_pl				; save destination pointer low byte
   855 B178 A5 3C			LDA	Svarh				; get start of vars high byte
   856 B17A 69 FF			ADC	#$FF				; -1 + carry
   857 B17C 85 3C			STA	Svarh				; save start of vars high byte
   858 B17E E5 6B			SBC	Baslnh				; subtract found line pointer high byte
   859 B180 AA				TAX					; copy to block count
   860 B181 38				SEC					; set carry for subtract
   861 B182 A5 6A			LDA	Baslnl				; get found line pointer low byte
   862 B184 E5 3B			SBC	Svarl				; subtract start of vars low byte
   863 B186 A8				TAY					; copy to bytes in first block count
   864 B187 B0 03			BCS	LAB_12D0			; branch if overflow
   865
   866 B189 E8				INX					; increment block count (correct for =0 loop exit)
   867 B18A C6 34			DEC	ut2_ph				; decrement destination high byte
   868 B18C			LAB_12D0
   869 B18C 18				CLC					; clear carry for add
   870 B18D 65 31			ADC	ut1_pl				; add source pointer low byte
   871 B18F 90 03			BCC	LAB_12D8			; branch if no overflow
   872
   873 B191 C6 32			DEC	ut1_ph				; else decrement source pointer high byte
   874 B193 18				CLC					; clear carry
   875
   876 										; close up memory to delete old line
   877 B194			LAB_12D8
   878 B194 B1 31			LDA	(ut1_pl),Y			; get byte from source
   879 B196 91 33			STA	(ut2_pl),Y			; copy to destination
   880 B198 C8				INY					; increment index
   881 B199 D0 F9			BNE	LAB_12D8			; while <> 0 do this block
   882
   883 B19B E6 32			INC	ut1_ph				; increment source pointer high byte
   884 B19D E6 34			INC	ut2_ph				; increment destination pointer high byte
   885 B19F CA				DEX					; decrement block count
   886 B1A0 D0 F2			BNE	LAB_12D8			; loop until all done
   887
   888 										; got new line in buffer and no existing same #
   889 B1A2			LAB_12E6
   890 B1A2 AD 7F 18			LDA	Ibuffs				; get byte from start of input buffer
   891 B1A5 F0 3F			BEQ	LAB_1319			; if null line just go flush stack/vars and exit
   892
   893 										; got new line and it isn't empty line
   894 B1A7 A5 45			LDA	Ememl				; get end of mem low byte
   895 B1A9 A4 46			LDY	Ememh				; get end of mem high byte
   896 B1AB 85 41			STA	Sstorl				; set bottom of string space low byte
   897 B1AD 84 42			STY	Sstorh				; set bottom of string space high byte
   898 B1AF A5 3B			LDA	Svarl				; get start of vars low byte	(end of BASIC)
   899 B1B1 85 66			STA	Obendl				; save old block end low byte
   900 B1B3 A4 3C			LDY	Svarh				; get start of vars high byte	(end of BASIC)
   901 B1B5 84 67			STY	Obendh				; save old block end high byte
   902 B1B7 65 1D			ADC	Ibptr				; add input buffer pointer	(also buffer length)
   903 B1B9 90 01			BCC	LAB_1301			; branch if no overflow from add
   904
   905 B1BB C8				INY					; else increment high byte
   906 B1BC			LAB_1301
   907 B1BC 85 64			STA	Nbendl				; save new block end low byte	(move to, low byte)
   908 B1BE 84 65			STY	Nbendh				; save new block end high byte
   909 B1C0 20 8D B0			JSR	LAB_11CF			; open up space in memory
   910 										; old start pointer Ostrtl,Ostrth set by the find line call
   911 B1C3 A5 3F			LDA	Earryl				; get array mem end low byte
   912 B1C5 A4 40			LDY	Earryh				; get array mem end high byte
   913 B1C7 85 3B			STA	Svarl				; save start of vars low byte
   914 B1C9 84 3C			STY	Svarh				; save start of vars high byte
   915 B1CB A4 1D			LDY	Ibptr				; get input buffer pointer	(also buffer length)
   916 B1CD 88				DEY					; adjust for loop type
   917 B1CE			LAB_1311
   918 B1CE B9 7B 18			LDA	Ibuffs-4,Y			; get byte from crunched line
   919 B1D1 91 6A			STA	(Baslnl),Y			; save it to program memory
   920 B1D3 88				DEY					; decrement count
   921 B1D4 C0 03			CPY	#$03				; compare with first byte-1
   922 B1D6 D0 F6			BNE	LAB_1311			; continue while count <> 3
   923
   924 B1D8 A5 12			LDA	Itemph				; get line # high byte
   925 B1DA 91 6A			STA	(Baslnl),Y			; save it to program memory
   926 B1DC 88				DEY					; decrement count
   927 B1DD A5 11			LDA	Itempl				; get line # low byte
   928 B1DF 91 6A			STA	(Baslnl),Y			; save it to program memory
   929 B1E1 88				DEY					; decrement count
   930 B1E2 A9 FF			LDA	#$FF				; set byte to allow chain rebuild. if you didn't set this
   931 										; byte then a zero already here would stop the chain rebuild
   932 										; as it would think it was the [EOT] marker.
   933 B1E4 91 6A			STA	(Baslnl),Y			; save it to program memory
   934
   935 B1E6			LAB_1319
   936 B1E6 20 48 B3			JSR	LAB_1477			; reset execution to start, clear vars and flush stack
   937 B1E9 A6 39			LDX	Smeml				; get start of mem low byte
   938 B1EB A5 3A			LDA	Smemh				; get start of mem high byte
   939 B1ED A0 01			LDY	#$01				; index to high byte of next line pointer
   940 B1EF			LAB_1325
   941 B1EF 86 31			STX	ut1_pl				; set line start pointer low byte
   942 B1F1 85 32			STA	ut1_ph				; set line start pointer high byte
   943 B1F3 B1 31			LDA	(ut1_pl),Y			; get it
   944 B1F5 F0 18			BEQ	LAB_133E			; exit if end of program
   945
   946 				; rebuild chaining of Basic lines
   947 B1F7 A0 04			LDY	#$04				; point to first code byte of line
   948 										; there is always 1 byte + [EOL] as null entries are deleted
   949 B1F9			LAB_1330
   950 B1F9 C8				INY					; next code byte
   951 B1FA B1 31			LDA	(ut1_pl),Y			; get byte
   952 B1FC D0 FB			BNE	LAB_1330			; loop if not [EOL]
   953
   954 B1FE 38				SEC					; set carry for add + 1
   955 B1FF 98				TYA					; copy end index
   956 B200 65 31			ADC	ut1_pl				; add to line start pointer low byte
   957 B202 AA				TAX					; copy to X
   958 B203 A0 00			LDY	#$00				; clear index, point to this line's next line pointer
   959 B205 91 31			STA	(ut1_pl),Y			; set next line pointer low byte
   960 B207 98				TYA					; clear A
   961 B208 65 32			ADC	ut1_ph				; add line start pointer high byte + carry
   962 B20A C8				INY					; increment index to high byte
   963 B20B 91 31			STA	(ut1_pl),Y			; save next line pointer low byte
   964 B20D 90 E0			BCC	LAB_1325			; go do next line, branch always, carry clear
   965
   966
   967 B20F			LAB_133E
   968 B20F 4C 39 B1			JMP	LAB_127D			; else we just wait for Basic command, no 'Ready'
   969
   970 				; print '? ' and get BASIC input
   971 B212			LAB_INLN
   972 B212 20 B1 B8			JSR	LAB_18E3			; print '?' character
   973 B215 20 AE B8			JSR	LAB_18E0			; print ' '
   974 B218 D0 05			BNE	LAB_1357			; call for BASIC input and return
   975
   976 				; receive line from keyboard
   977 										; $08 as delete key (BACKSPACE on standard keyboard)
   978 B21A			LAB_134B
   979 B21A 20 B3 B8			JSR	LAB_PRNA			; go print the character
   980 B21D CA				DEX					; decrement the buffer counter (delete)
   981 B21E 2C				.byte	$2C				; make LDX into BIT abs
   982
   983 				; call for BASIC input (main entry point)
   984 B21F			LAB_1357
   985 B21F A2 00			LDX	#$00			; clear BASIC line buffer pointer
   986 B221			LAB_1359
   987 B221 20 FF D2			JSR	V_INPT			; call scan input device
   988 B224 90 FB			BCC	LAB_1359		; loop if no byte
   989
   990 B226 F0 F9			BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   991
   992 B228 C9 07			CMP	#$07			; compare with [BELL]
   993 B22A F0 10			BEQ	LAB_1378		; branch if [BELL]
   994
   995 B22C C9 0D			CMP	#$0D			; compare with [CR]
   996 B22E F0 19			BEQ	LAB_1384		; do CR/LF exit if [CR]
   997
   998 B230 E0 00			CPX	#$00			; compare pointer with $00
   999 B232 D0 04			BNE	LAB_1374		; branch if not empty
  1000
  1001 				; next two lines ignore any non print character and [SPACE] if input buffer empty
  1002 B234 C9 21			CMP	#$21			; compare with [SP]+1
  1003 B236 90 E9			BCC	LAB_1359		; if < ignore character
  1004
  1005 B238			LAB_1374
  1006 B238 C9 08			CMP	#$08			; compare with [BACKSPACE] (delete last character)
  1007 B23A F0 DE			BEQ	LAB_134B		; go delete last character
  1008
  1009 B23C			LAB_1378
  1010 B23C E0 7F			CPX	#Ibuffe-Ibuffs		; compare character count with max
  1011 B23E B0 0C			BCS	LAB_138E		; skip store and do [BELL] if buffer full
  1012
  1013 B240 9D 7F 18			STA	Ibuffs,X		; else store in buffer
  1014 B243 E8				INX				; increment pointer
  1015 B244			LAB_137F
  1016 B244 20 B3 B8			JSR	LAB_PRNA		; go print the character
  1017 B247 D0 D8			BNE	LAB_1359		; always loop for next character
  1018
  1019 B249			LAB_1384
  1020 B249 4C 4F B8			JMP	LAB_1866		; do CR/LF exit to BASIC
  1021
  1022 				; announce buffer full
  1023 B24C			LAB_138E
  1024 B24C A9 07			LDA	#$07			; [BELL] character into A
  1025 B24E D0 F4			BNE	LAB_137F		; go print the [BELL] but ignore input character
  1026 									; branch always
  1027
  1028 				; crunch keywords into Basic tokens
  1029 				; position independent buffer version ..
  1030 				; faster, dictionary search version ....
  1031 B250			LAB_13A6
  1032 B250 A0 FF			LDY	#$FF			; set save index (makes for easy math later)
  1033
  1034 B252 38				SEC				; set carry for subtract
  1035 B253 A5 83			LDA	Bpntrl			; get basic execute pointer low byte
  1036 B255 E9 7F			SBC	#<Ibuffs		; subtract input buffer start pointer
  1037 B257 AA				TAX				; copy result to X (index past line # if any)
  1038
  1039 B258 86 20			STX	Oquote			; clear open quote/DATA flag
  1040 B25A			LAB_13AC
  1041 B25A BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1042 B25D F0 62			BEQ	LAB_13EC		; if null save byte then exit
  1043
  1044 B25F C9 7B			CMP   	#'{'           		; convert lower to upper case
  1045 B261 B0 5E			BCS   	LAB_13EC       	 	; is above lower case
  1046 B263 C9 61			CMP   	#'a'
  1047 B265 90 02			BCC   	PATCH_LC       		; is below lower case
  1048 B267 29 DF			AND   	#$DF           		; mask lower case bit
  1049 				      
  1050 B269			PATCH_LC
  1051 B269 C9 5F			CMP	#'_'			; compare with '_'
  1052 B26B B0 54			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1053
  1054 B26D C9 3C			CMP	#'<'			; compare with '<'
  1055 B26F B0 0E			BCS	LAB_13CC		; if >= go crunch now
  1056
  1057 B271 C9 30			CMP	#'0'			; compare with '0'
  1058 B273 B0 4C			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1059
  1060 B275 85 1C			STA	Scnquo			; save buffer byte as search character
  1061 B277 C9 22			CMP	#$22			; is it quote character?
  1062 B279 F0 68			BEQ	LAB_1410		; branch if so (copy quoted string)
  1063
  1064 B27B C9 2A			CMP	#'*'			; compare with '*'
  1065 B27D 90 42			BCC	LAB_13EC		; if < go save byte then continue crunching
  1066 									; else crunch now
  1067 B27F			LAB_13CC
  1068 B27F 24 20			BIT	Oquote			; get open quote/DATA token flag
  1069 B281 70 3E			BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
  1070 									; go save byte then continue crunching
  1071
  1072 B283 86 38			STX	TempB			; save buffer read index
  1073 B285 84 7A			STY	csidx			; copy buffer save index
  1074 B287 A0 54			LDY	#<TAB_1STC		; get keyword first character table low address
  1075 B289 84 33			STY	ut2_pl			; save pointer low byte
  1076 B28B A0 D5			LDY	#>TAB_1STC		; get keyword first character table high address
  1077 B28D 84 34			STY	ut2_ph			; save pointer high byte
  1078 B28F A0 00			LDY	#$00			; clear table pointer
  1079
  1080 B291			LAB_13D0
  1081 B291 D1 33			CMP	(ut2_pl),Y		; compare with keyword first character table byte
  1082 B293 F0 05			BEQ	LAB_13D1		; go do word_table_chr if match
  1083
  1084 B295 90 60			BCC   	PATCH_LC2		; if < keyword first character table byte go restore
  1085 									; Y and save to crunched
  1086
  1087 B297 C8				INY				; else increment pointer
  1088 B298 D0 F7			BNE	LAB_13D0		; and loop (branch always)
  1089
  1090 				; have matched first character of some keyword
  1091 B29A			LAB_13D1
  1092 B29A 98				TYA				; copy matching index
  1093 B29B 0A				ASL				; *2 (bytes per pointer)
  1094 B29C AA				TAX				; copy to new index
  1095 B29D BD 72 D5			LDA	TAB_CHRT,X		; get keyword table pointer low byte
  1096 B2A0 85 33			STA	ut2_pl			; save pointer low byte
  1097 B2A2 BD 73 D5			LDA	TAB_CHRT+1,X		; get keyword table pointer high byte
  1098 B2A5 85 34			STA	ut2_ph			; save pointer high byte
  1099
  1100 B2A7 A0 FF			LDY	#$FF			; clear table pointer (make -1 for start)
  1101
  1102 B2A9 A6 38			LDX	TempB			; restore buffer read index
  1103 B2AB			LAB_13D6
  1104 B2AB C8				INY				; next table byte
  1105 B2AC B1 33			LDA	(ut2_pl),Y		; get byte from table
  1106 B2AE			LAB_13D8
  1107 B2AE 30 0F			BMI	LAB_13EA		; all bytes matched so go save token
  1108
  1109 B2B0 E8				INX				; next buffer byte
  1110 B2B1 DD 7F 18			CMP	Ibuffs,X		; compare with byte from input buffer
  1111 B2B4 F0 F5			BEQ	LAB_13D6		; go compare next if match
  1112 				    
  1113 B2B6 09 20			ORA 	#$20                	; repeat with lower case
  1114 B2B8 DD 7F 18			CMP 	Ibuffs,X            	; compare with byte from input buffer
  1115 B2BB F0 EE			BEQ 	LAB_13D6            	; go compare next if match
  1116 					
  1117 B2BD D0 2B			BNE	LAB_1417		; branch if >< (not found keyword)
  1118
  1119 B2BF			LAB_13EA
  1120 B2BF A4 7A			LDY	csidx			; restore save index
  1121 									; save crunched to output
  1122 B2C1			LAB_13EC
  1123 B2C1 E8				INX				; increment buffer index (to next input byte)
  1124 B2C2 C8				INY				; increment save index (to next output byte)
  1125 B2C3 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1126 B2C6 C9 00			CMP	#$00			; set the flags, set carry
  1127 B2C8 F0 32			BEQ	LAB_142A		; do exit if was null [EOL]
  1128
  1129 									; A holds token or byte here
  1130 B2CA E9 3A			SBC	#':'			; subtract ':' (carry set by CMP #00)
  1131 B2CC F0 04			BEQ	LAB_13FF		; branch if it was ':' (is now $00)
  1132
  1133 									; A now holds token-$3A
  1134 B2CE C9 49			CMP	#TK_DATA-$3A		; compare with DATA token - $3A
  1135 B2D0 D0 02			BNE	LAB_1401		; branch if not DATA
  1136 									; token was : or DATA
  1137 B2D2			LAB_13FF
  1138 B2D2 85 20			STA	Oquote			; save token-$3A (clear for ':', TK_DATA-$3A for DATA)
  1139 B2D4			LAB_1401
  1140 B2D4 49 57			EOR	#TK_REM-$3A		; effectively subtract REM token offset
  1141 B2D6 D0 82			BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
  1142
  1143 B2D8 85 1C			STA	Asrch			; else was REM so set search for [EOL]
  1144 									; loop for REM, '...' etc.
  1145 B2DA			LAB_1408
  1146 B2DA BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1147 B2DD F0 E2			BEQ	LAB_13EC		; branch if null [EOL]
  1148
  1149 B2DF C5 1C			CMP	Asrch			; compare with stored character
  1150 B2E1 F0 DE			BEQ	LAB_13EC		; branch if match (end quote)
  1151
  1152 									; entry for copy string in quotes, don't crunch
  1153 B2E3			LAB_1410
  1154 B2E3 C8				INY				; increment buffer save index
  1155 B2E4 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1156 B2E7 E8				INX				; increment buffer read index
  1157 B2E8 D0 F0			BNE	LAB_1408		; loop while <> 0 (should never be 0!)
  1158
  1159 									; not found keyword this go
  1160 B2EA			LAB_1417
  1161 B2EA A6 38			LDX	TempB			; compare has failed, restore buffer index (start byte!)
  1162
  1163 									; now find the end of this word in the table
  1164 B2EC			LAB_141B
  1165 B2EC B1 33			LDA	(ut2_pl),Y		; get table byte
  1166 B2EE 08				PHP				; save status
  1167 B2EF C8				INY				; increment table index
  1168 B2F0 28				PLP				; restore byte status
  1169 B2F1 10 F9			BPL	LAB_141B		; if not end of keyword go do next
  1170
  1171 B2F3 B1 33			LDA	(ut2_pl),Y		; get byte from keyword table
  1172 B2F5 D0 B7			BNE	LAB_13D8		; go test next word if not zero byte (end of table)
  1173
  1174 B2F7			PATCH_LC2
  1175 									; reached end of table with no match
  1176 B2F7 BD 7F 18			LDA	Ibuffs,X		; restore byte from input buffer
  1177 B2FA 10 C3			BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
  1178 									; go save byte in output and continue crunching
  1179
  1180 									; reached [EOL]
  1181 B2FC			LAB_142A
  1182 B2FC C8				INY				; increment pointer
  1183 B2FD C8				INY				; increment pointer (makes it next line pointer high byte)
  1184 B2FE 99 7F 18			STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
  1185 B301 C8				INY				; adjust for line copy
  1186 B302 C8				INY				; adjust for line copy
  1187 B303 C8				INY				; adjust for line copy
  1188 B304 C6 83			DEC	Bpntrl			; allow for increment (change if buffer starts at $xxFF)
  1189 B306 60				RTS
  1190
  1191 				; search Basic for temp integer line number from start of mem
  1192 B307			LAB_SSLN
  1193 B307 A5 39			LDA	Smeml			; get start of mem low byte
  1194 B309 A6 3A			LDX	Smemh			; get start of mem high byte
  1195
  1196 				; search Basic for temp integer line number from AX
  1197 				; returns carry set if found
  1198 				; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1199
  1200 				; old 541 new 507
  1201 B30B			LAB_SHLN
  1202 B30B A0 01			LDY	#$01			; set index
  1203 B30D 85 6A			STA	Baslnl			; save low byte as current
  1204 B30F 86 6B			STX	Baslnh			; save high byte as current
  1205 B311 B1 6A			LDA	(Baslnl),Y		; get pointer high byte from addr
  1206 B313 F0 1A			BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
  1207
  1208 B315 A0 03			LDY	#$03			; set index to line # high byte
  1209 B317 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1210 B319 88				DEY				; decrement index (point to low byte)
  1211 B31A C5 12			CMP	Itemph			; compare with temporary integer high byte
  1212 B31C D0 04			BNE	LAB_1455		; if <> skip low byte check
  1213
  1214 B31E B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1215 B320 C5 11			CMP	Itempl			; compare with temporary integer low byte
  1216 B322			LAB_1455
  1217 B322 B0 09			BCS	LAB_145E		; else if temp < this line, exit (passed line#)
  1218
  1219 B324			LAB_1456
  1220 B324 88				DEY				; decrement index to next line ptr high byte
  1221 B325 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1222 B327 AA				TAX				; copy to X
  1223 B328 88				DEY				; decrement index to next line ptr low byte
  1224 B329 B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1225 B32B 90 DE			BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
  1226 									; (carry always clear)
  1227
  1228 B32D			LAB_145E
  1229 B32D F0 01			BEQ	LAB_1460		; exit if temp = found line #, carry is set
  1230
  1231 B32F			LAB_145F
  1232 B32F 18				CLC				; clear found flag
  1233 B330			LAB_1460
  1234 B330 60				RTS
  1235
  1236 				; perform NEW
  1237 B331			LAB_NEW
  1238 B331 D0 FD			BNE	LAB_1460		; exit if not end of statement (to do syntax error)
  1239
  1240 B333			LAB_1463
  1241 B333 A9 00			LDA	#$00			; clear A
  1242 B335 A8				TAY				; clear Y
  1243 B336 91 39			STA	(Smeml),Y		; clear first line, next line pointer, low byte
  1244 B338 C8				INY				; increment index
  1245 B339 91 39			STA	(Smeml),Y		; clear first line, next line pointer, high byte
  1246 B33B 18				CLC				; clear carry
  1247 B33C A5 39			LDA	Smeml			; get start of mem low byte
  1248 B33E 69 02			ADC	#$02			; calculate end of BASIC low byte
  1249 B340 85 3B			STA	Svarl			; save start of vars low byte
  1250 B342 A5 3A			LDA	Smemh			; get start of mem high byte
  1251 B344 69 00			ADC	#$00			; add any carry
  1252 B346 85 3C			STA	Svarh			; save start of vars high byte
  1253
  1254 				; reset execution to start, clear vars and flush stack
  1255 B348			LAB_1477
  1256 B348 18				CLC				; clear carry
  1257 B349 A5 39			LDA	Smeml			; get start of mem low byte
  1258 B34B 69 FF			ADC	#$FF			; -1
  1259 B34D 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1260 B34F A5 3A			LDA	Smemh			; get start of mem high byte
  1261 B351 69 FF			ADC	#$FF			; -1+carry
  1262 B353 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1263
  1264 				; 'CLEAR' command gets here
  1265 B355			LAB_147A
  1266 B355 A5 45			LDA	Ememl			; get end of mem low byte
  1267 B357 A4 46			LDY	Ememh			; get end of mem high byte
  1268 B359 85 41			STA	Sstorl			; set bottom of string space low byte
  1269 B35B 84 42			STY	Sstorh			; set bottom of string space high byte
  1270 B35D A5 3B			LDA	Svarl			; get start of vars low byte
  1271 B35F A4 3C			LDY	Svarh			; get start of vars high byte
  1272 B361 85 3D			STA	Sarryl			; save var mem end low byte
  1273 B363 84 3E			STY	Sarryh			; save var mem end high byte
  1274 B365 85 3F			STA	Earryl			; save array mem end low byte
  1275 B367 84 40			STY	Earryh			; save array mem end high byte
  1276 B369 20 1D B5			JSR	LAB_161A		; perform RESTORE command
  1277
  1278 				; flush stack and clear continue flag
  1279 B36C			LAB_1491
  1280 B36C A2 28			LDX	#des_sk			; set descriptor stack pointer
  1281 B36E 86 25			STX	next_s			; save descriptor stack pointer
  1282 B370 68				PLA				; pull return address low byte
  1283 B371 AA				TAX				; copy return address low byte
  1284 B372 68				PLA				; pull return address high byte
  1285 B373 8E FE 01			STX	LAB_SKFE		; save to cleared stack
  1286 B376 8D FF 01			STA	LAB_SKFF		; save to cleared stack
  1287 B379 A2 FD			LDX	#$FD			; new stack pointer
  1288 B37B 9A				TXS				; reset stack
  1289 B37C A9 00			LDA	#$00			; clear byte
  1290 					;STA	Cpntrh			; clear continue pointer high byte (patched)
  1291 B37E 85 21			STA	Sufnxf			; clear subscript/FNX flag
  1292 B380			LAB_14A6
  1293 B380 60				RTS
  1294
  1295 				; perform CLEAR
  1296 B381			LAB_CLEAR
  1297 B381 F0 D2			BEQ	LAB_147A		; if no following token go do 'CLEAR'
  1298 									; else there was a following token (go do syntax error)
  1299 B383 60				RTS
  1300
  1301 				; perform LIST [n][-m]
  1302 				; bigger, faster version (a _lot_ faster)
  1303 B384			LAB_LIST
  1304 B384 90 06			BCC	LAB_14BD		; branch if next character numeric (LIST n..)
  1305
  1306 B386 F0 04			BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
  1307
  1308 B388 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1309 B38A D0 F4			BNE	LAB_14A6		; exit if not - (LIST -m)
  1310
  1311 									; LIST [[n][-m]]
  1312 									; this bit sets the n , if present, as the start and end
  1313 B38C			LAB_14BD
  1314 B38C 20 1B B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1315 B38F 20 07 B3			JSR	LAB_SSLN		; search BASIC for temp integer line number
  1316 									; (pointer in Baslnl/Baslnh)
  1317 B392 20 82 00			JSR	LAB_GBYT		; scan memory
  1318 B395 F0 0C			BEQ	LAB_14D4		; branch if no more characters
  1319
  1320 									; this bit checks the - is present
  1321 B397 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1322 B399 D0 95			BNE	LAB_1460		; return if not '-' (will be Syntax error)
  1323
  1324 									; LIST [n]-m
  1325 									; the - was there so set m as the end value
  1326 B39B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1327 B39E 20 1B B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1328 B3A1 D0 8D			BNE	LAB_1460		; exit if not ok
  1329
  1330 B3A3			LAB_14D4
  1331 B3A3 A5 11			LDA	Itempl			; get temporary integer low byte
  1332 B3A5 05 12			ORA	Itemph			; OR temporary integer high byte
  1333 B3A7 D0 06			BNE	LAB_14E2		; branch if start set
  1334
  1335 B3A9 A9 FF			LDA	#$FF			; set for -1
  1336 B3AB 85 11			STA	Itempl			; set temporary integer low byte
  1337 B3AD 85 12			STA	Itemph			; set temporary integer high byte
  1338 B3AF			LAB_14E2
  1339 B3AF A0 01			LDY	#$01			; set index for line
  1340 B3B1 84 20			STY	Oquote			; clear open quote flag
  1341 B3B3 20 58 B8			JSR	LAB_CRLF		; print CR/LF
  1342 B3B6 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1343 									; pointer initially set by search at LAB_14BD
  1344 B3B8 F0 3E			BEQ	LAB_152B		; if null all done so exit
  1345 B3BA 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1346
  1347 B3BD C8				INY				; increment index for line
  1348 B3BE B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1349 B3C0 AA				TAX				; copy to X
  1350 B3C1 C8				INY				; increment index
  1351 B3C2 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1352 B3C4 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1353 B3C6 D0 04			BNE	LAB_14FF		; branch if no high byte match
  1354
  1355 B3C8 E4 11			CPX	Itempl			; compare with temporary integer low byte
  1356 B3CA F0 02			BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
  1357
  1358 B3CC			LAB_14FF				; else ..
  1359 B3CC B0 2A			BCS	LAB_152B		; if greater all done so exit
  1360
  1361 B3CE			LAB_1501
  1362 B3CE 84 57			STY	Tidx1			; save index for line
  1363 B3D0 20 57 CA			JSR	LAB_295E		; print XA as unsigned integer
  1364 B3D3 A9 20			LDA	#$20			; space is the next character
  1365 B3D5			LAB_1508
  1366 B3D5 A4 57			LDY	Tidx1			; get index for line
  1367 B3D7 29 7F			AND	#$7F			; mask top out bit of character
  1368 B3D9			LAB_150C
  1369 B3D9 20 B3 B8			JSR	LAB_PRNA		; go print the character
  1370 B3DC C9 22			CMP	#$22			; was it ' character
  1371 B3DE D0 06			BNE	LAB_1519		; branch if not
  1372
  1373 									; we are either entering or leaving a pair of quotes
  1374 B3E0 A5 20			LDA	Oquote			; get open quote flag
  1375 B3E2 49 FF			EOR	#$FF			; toggle it
  1376 B3E4 85 20			STA	Oquote			; save it back
  1377 B3E6			LAB_1519
  1378 B3E6 C8				INY				; increment index
  1379 B3E7 B1 6A			LDA	(Baslnl),Y		; get next byte
  1380 B3E9 D0 0E			BNE	LAB_152E		; branch if not [EOL] (go print character)
  1381 B3EB A8				TAY				; else clear index
  1382 B3EC B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1383 B3EE AA				TAX				; copy to X
  1384 B3EF C8				INY				; increment index
  1385 B3F0 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1386 B3F2 86 6A			STX	Baslnl			; set pointer to line low byte
  1387 B3F4 85 6B			STA	Baslnh			; set pointer to line high byte
  1388 B3F6 D0 B7			BNE	LAB_14E2		; go do next line if not [EOT]
  1389 									; else ..
  1390 B3F8			LAB_152B
  1391 B3F8 60				RTS
  1392
  1393 B3F9			LAB_152E
  1394 B3F9 10 DE			BPL	LAB_150C		; just go print it if not token byte
  1395
  1396 									; else was token byte so uncrunch it (maybe)
  1397 B3FB 24 20			BIT	Oquote			; test the open quote flag
  1398 B3FD 30 DA			BMI	LAB_150C		; just go print character if open quote set
  1399
  1400 B3FF A2 D7			LDX	#>LAB_KEYT		; get table address high byte
  1401 B401 0A				ASL				; *2
  1402 B402 0A				ASL				; *4
  1403 B403 90 02			BCC	LAB_152F		; branch if no carry
  1404
  1405 B405 E8				INX				; else increment high byte
  1406 B406 18				CLC				; clear carry for add
  1407 B407			LAB_152F
  1408 B407 69 D0			ADC	#<LAB_KEYT		; add low byte
  1409 B409 90 01			BCC	LAB_1530		; branch if no carry
  1410
  1411 B40B E8				INX				; else increment high byte
  1412 B40C			LAB_1530
  1413 B40C 85 33			STA	ut2_pl			; save table pointer low byte
  1414 B40E 86 34			STX	ut2_ph			; save table pointer high byte
  1415 B410 84 57			STY	Tidx1			; save index for line
  1416 B412 A0 00			LDY	#$00			; clear index
  1417 B414 B1 33			LDA	(ut2_pl),Y		; get length
  1418 B416 AA				TAX				; copy length
  1419 B417 C8				INY				; increment index
  1420 B418 B1 33			LDA	(ut2_pl),Y		; get 1st character
  1421 B41A CA				DEX				; decrement length
  1422 B41B F0 B8			BEQ	LAB_1508		; if no more characters exit and print
  1423
  1424 B41D 20 B3 B8			JSR	LAB_PRNA		; go print the character
  1425 B420 C8				INY				; increment index
  1426 B421 B1 33			LDA	(ut2_pl),Y		; get keyword address low byte
  1427 B423 48				PHA				; save it for now
  1428 B424 C8				INY				; increment index
  1429 B425 B1 33			LDA	(ut2_pl),Y		; get keyword address high byte
  1430 B427 A0 00			LDY	#$00
  1431 B429 85 34			STA	ut2_ph			; save keyword pointer high byte
  1432 B42B 68				PLA				; pull low byte
  1433 B42C 85 33			STA	ut2_pl			; save keyword pointer low byte
  1434 B42E			LAB_1540
  1435 B42E B1 33			LDA	(ut2_pl),Y		; get character
  1436 B430 CA				DEX				; decrement character count
  1437 B431 F0 A2			BEQ	LAB_1508		; if last character exit and print
  1438
  1439 B433 20 B3 B8			JSR	LAB_PRNA		; go print the character
  1440 B436 C8				INY				; increment index
  1441 B437 D0 F5			BNE	LAB_1540		; loop for next character
  1442
  1443 				; perform FOR
  1444 B439			LAB_FOR
  1445 B439 A9 80			LDA	#$80			; set FNX
  1446 B43B 85 21			STA	Sufnxf			; set subscript/FNX flag
  1447 B43D 20 7A B7			JSR	LAB_LET			; go do LET
  1448 B440 68				PLA				; pull return address
  1449 B441 68				PLA				; pull return address
  1450 B442 A9 10			LDA	#$10			; we need 16d bytes !
  1451 B444 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1452 B447 20 6E B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1453 B44A 18				CLC				; clear carry for add
  1454 B44B 98				TYA				; copy index to A
  1455 B44C 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1456 B44E 48				PHA				; push onto stack
  1457 B44F A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1458 B451 69 00			ADC	#$00			; add carry
  1459 B453 48				PHA				; push onto stack
  1460 B454 A5 48			LDA	Clineh			; get current line high byte
  1461 B456 48				PHA				; push onto stack
  1462 B457 A5 47			LDA	Clinel			; get current line low byte
  1463 B459 48				PHA				; push onto stack
  1464 B45A A9 C2			LDA	#TK_TO			; get 'TO' token
  1465 B45C 20 B6 BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1466 B45F 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1467 B462 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1468 									; else do type mismatch
  1469 B465 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  1470 B467 09 7F			ORA	#$7F			; set all non sign bits
  1471 B469 25 6D			AND	FAC1_1			; and FAC1 mantissa1
  1472 B46B 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  1473 B46D A9 78			LDA	#<LAB_159F		; set return address low byte
  1474 B46F A0 B4			LDY	#>LAB_159F		; set return address high byte
  1475 B471 85 31			STA	ut1_pl			; save return address low byte
  1476 B473 84 32			STY	ut1_ph			; save return address high byte
  1477 B475 4C 49 BB			JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1478
  1479 B478			LAB_159F
  1480 B478 A9 E7			LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1481 B47A A0 D3			LDY	#>LAB_259C		; set 1 pointer high addr
  1482 B47C 20 52 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1483 B47F 20 82 00			JSR	LAB_GBYT		; scan memory
  1484 B482 C9 C7			CMP	#TK_STEP		; compare with STEP token
  1485 B484 D0 06			BNE	LAB_15B3		; jump if not 'STEP'
  1486
  1487 									;.was step so ..
  1488 B486 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1489 B489 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1490 									; else do type mismatch
  1491 B48C			LAB_15B3
  1492 B48C 20 BE C8			JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1493 B48F 85 70			STA	FAC1_s			; set FAC1 sign (b7)
  1494 									; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1495 									; compare the FOR value and the TO value and return +1 if
  1496 									; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1497 									; here (+/-1) is then compared to that result and if they
  1498 									; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1499 									; the loop is done
  1500 B491 20 3E BB			JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1501 B494 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  1502 B496 48				PHA				; push on stack
  1503 B497 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  1504 B499 48				PHA				; push on stack
  1505 B49A A9 81			LDA	#TK_FOR			; get FOR token
  1506 B49C 48				PHA				; push on stack
  1507
  1508 				; interpreter inner loop
  1509 B49D			LAB_15C2
  1510 B49D 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1511 B4A0 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1512 B4A2 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  1513
  1514 B4A4 A6 48			LDX	Clineh			; continue line is $FFxx for immediate mode
  1515 									; ($00xx for RUN from immediate mode)
  1516 B4A6 E8				INX				; increment it (now $00 if immediate mode)
  1517 					;BEQ	LAB_15D1		; branch if null (immediate mode) (patched)
  1518
  1519 B4A7 85 4B			STA	Cpntrl			; save continue pointer low byte
  1520 B4A9 84 4C			STY	Cpntrh			; save continue pointer high byte
  1521 B4AB			LAB_15D1
  1522 B4AB A0 00			LDY	#$00			; clear index
  1523 B4AD B1 83			LDA	(Bpntrl),Y		; get next byte
  1524 B4AF F0 07			BEQ	LAB_15DC		; branch if null [EOL]
  1525
  1526 B4B1 C9 3A			CMP	#':'			; compare with ':'
  1527 B4B3 F0 1D			BEQ	LAB_15F6		; branch if = (statement separator)
  1528
  1529 B4B5			LAB_15D9
  1530 B4B5 4C C7 BB			JMP	LAB_SNER		; else syntax error then warm start
  1531
  1532 									; have reached [EOL]
  1533 B4B8			LAB_15DC
  1534 B4B8 A0 02			LDY	#$02			; set index
  1535 B4BA B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  1536 B4BC 18				CLC				; clear carry for no 'BREAK' message
  1537 B4BD F0 50			BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1538 									; marker)
  1539
  1540 B4BF C8				INY				; increment index
  1541 B4C0 B1 83			LDA	(Bpntrl),Y		; get line # low byte
  1542 B4C2 85 47			STA	Clinel			; save current line low byte
  1543 B4C4 C8				INY				; increment index
  1544 B4C5 B1 83			LDA	(Bpntrl),Y		; get line # high byte
  1545 B4C7 85 48			STA	Clineh			; save current line high byte
  1546 B4C9 98				TYA				; A now = 4
  1547 B4CA 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1548 B4CC 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1549 B4CE 90 02			BCC	LAB_15F6		; branch if no overflow
  1550
  1551 B4D0 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1552 B4D2			LAB_15F6
  1553 B4D2 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1554
  1555 B4D5			LAB_15F9
  1556 B4D5 20 DB B4			JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
  1557
  1558 B4D8			LAB_15FC
  1559 B4D8 4C 9D B4			JMP	LAB_15C2		; loop
  1560
  1561 				; interpret BASIC code from (Bpntrl)
  1562 B4DB			LAB_15FF
  1563 B4DB F0 4E			BEQ	LAB_1628		; exit if zero [EOL]
  1564
  1565 B4DD			LAB_1602
  1566 B4DD 0A				ASL				; *2 bytes per vector and normalise token
  1567 B4DE B0 03			BCS	LAB_1609		; branch if was token
  1568
  1569 B4E0 4C 7A B7			JMP	LAB_LET			; else go do implied LET
  1570
  1571 B4E3			LAB_1609
  1572 B4E3 C9 80			CMP	#(TK_TAB-$80)*2		; compare normalised token * 2 with TAB
  1573 B4E5 B0 CE			BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  1574 									; only tokens before TAB can start a line
  1575 B4E7 A8				TAY				; copy to index
  1576 B4E8 B9 0F D4			LDA	LAB_CTBL+1,Y		; get vector high byte
  1577 B4EB 48				PHA				; onto stack
  1578 B4EC B9 0E D4			LDA	LAB_CTBL,Y		; get vector low byte
  1579 B4EF 48				PHA				; onto stack
  1580 B4F0 4C 7C 00			JMP	LAB_IGBY		; jump to increment and scan memory
  1581 									; then 'return' to vector
  1582
  1583 				; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1584 				; key press is detected.
  1585 B4F3			LAB_1629
  1586 B4F3 6C 6B 18			JMP	(VEC_CC)		; ctrl c check vector
  1587
  1588 				; if there was a key press it gets back here ..
  1589 B4F6			LAB_1636
  1590 B4F6 C9 03			CMP	#$03			; compare with CTRL-C
  1591
  1592 				; perform STOP
  1593 B4F8			LAB_STOP
  1594 B4F8 B0 01			BCS	LAB_163B		; branch if token follows STOP
  1595 									; else just END
  1596 				; END
  1597 B4FA			LAB_END
  1598 B4FA 18				CLC				; clear the carry, indicate a normal program end
  1599 B4FB			LAB_163B
  1600 B4FB D0 61			BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1601
  1602 B4FD A5 84			LDA	Bpntrh			; get the BASIC execute pointer high byte
  1603 					;EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1604 					;BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1605 									; (can't continue in immediate mode)
  1606
  1607 									; else ..
  1608 					;EOR	#>Ibuffs		; correct the bits (patched 3 lines)
  1609 B4FF A4 83			LDY	Bpntrl			; get BASIC execute pointer low byte
  1610 B501 84 4B			STY	Cpntrl			; save continue pointer low byte
  1611 B503 85 4C			STA	Cpntrh			; save continue pointer high byte
  1612 B505			LAB_1647
  1613 B505 A5 47			LDA	Clinel			; get current line low byte
  1614 B507 A4 48			LDY	Clineh			; get current line high byte
  1615 B509 85 49			STA	Blinel			; save break line low byte
  1616 B50B 84 4A			STY	Blineh			; save break line high byte
  1617 B50D			LAB_164F
  1618 B50D 68				PLA				; pull return address low
  1619 B50E 68				PLA				; pull return address high
  1620 B50F			LAB_1651
  1621 B50F 90 07			BCC	LAB_165E		; if was program end just do warm start
  1622
  1623 									; else ..
  1624 B511 A9 05			LDA	#<LAB_BMSG		; point to 'Break' low byte
  1625 B513 A0 DB			LDY	#>LAB_BMSG		; point to 'Break' high byte
  1626 B515 4C 21 B1			JMP	LAB_1269		; print 'Break' and do warm start
  1627
  1628 B518			LAB_165E
  1629 B518 4C 2C B1			JMP	LAB_1274		; go do warm start
  1630
  1631 				; perform RESTORE
  1632 B51B			LAB_RESTORE
  1633 B51B D0 0F			BNE	LAB_RESTOREn		; branch if next character not null (RESTORE n)
  1634
  1635 B51D			LAB_161A
  1636 B51D 38				SEC				; set carry for subtract
  1637 B51E A5 39			LDA	Smeml			; get start of mem low byte
  1638 B520 E9 01			SBC	#$01			; -1
  1639 B522 A4 3A			LDY	Smemh			; get start of mem high byte
  1640 B524 B0 01			BCS	LAB_1624		; branch if no underflow
  1641
  1642 B526			LAB_uflow
  1643 B526 88				DEY				; else decrement high byte
  1644 B527			LAB_1624
  1645 B527 85 4F			STA	Dptrl			; save DATA pointer low byte
  1646 B529 84 50			STY	Dptrh			; save DATA pointer high byte
  1647 B52B			LAB_1628
  1648 B52B 60				RTS
  1649
  1650 									; is RESTORE n
  1651 B52C			LAB_RESTOREn
  1652 B52C 20 1B B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1653 B52F 20 71 B6			JSR	LAB_SNBL		; scan for next BASIC line
  1654 B532 A5 48			LDA	Clineh			; get current line high byte
  1655 B534 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1656 B536 B0 0B			BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1657
  1658 B538 98				TYA				; else copy line index to A
  1659 B539 38				SEC				; set carry (+1)
  1660 B53A 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1661 B53C A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1662 B53E 90 07			BCC	LAB_go_search		; branch if no overflow to high byte
  1663
  1664 B540 E8				INX				; increment high byte
  1665 B541 B0 04			BCS	LAB_go_search		; branch always (can never be carry clear)
  1666
  1667 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1668 B543			LAB_reset_search
  1669 B543 A5 39			LDA	Smeml			; get start of mem low byte
  1670 B545 A6 3A			LDX	Smemh			; get start of mem high byte
  1671
  1672 				; search for line # in temp (Itempl/Itemph) from (AX)
  1673 B547			LAB_go_search
  1674
  1675 B547 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1676 B54A B0 03			BCS	LAB_line_found		; if carry set go set pointer
  1677
  1678 B54C 4C 43 B6			JMP	LAB_16F7		; else go do 'Undefined statement' error
  1679
  1680 B54F			LAB_line_found
  1681 									; carry already set for subtract
  1682 B54F A5 6A			LDA	Baslnl			; get pointer low byte
  1683 B551 E9 01			SBC	#$01			; -1
  1684 B553 A4 6B			LDY	Baslnh			; get pointer high byte
  1685 B555 B0 D0			BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1686
  1687 B557 90 CD			BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1688 									; return (branch always)
  1689
  1690 				; perform NULL
  1691 B559			LAB_NULL
  1692 B559 20 61 C4			JSR	LAB_GTBY		; get byte parameter
  1693 B55C 86 0D			STX	Nullct			; save new NULL count
  1694 B55E			LAB_167A
  1695 B55E 60				RTS
  1696
  1697 				; perform CONT
  1698 B55F			LAB_CONT
  1699 B55F D0 FD			BNE	LAB_167A		; if following byte exit to do syntax error
  1700
  1701 B561 A4 4C			LDY	Cpntrh			; get continue pointer high byte
  1702 B563 C0 18			CPY   	#>Ibuffs          	; *** fix p2: test direct mode 
  1703 B565 D0 05			BNE	LAB_166C		; go do continue if we can
  1704
  1705 B567 A2 1E			LDX	#$1E			; error code $1E ('Can't continue' error)
  1706 B569 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1707 									; we can continue so ..
  1708 B56C			LAB_166C	; 21-07-25 Emile removed
  1709 					;LDA	#TK_ON			; set token for ON
  1710 					;JSR	LAB_IRQ			; set IRQ flags
  1711 					;LDA	#TK_ON			; set token for ON
  1712 					;JSR	LAB_NMI			; set NMI flags
  1713
  1714 B56C 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  1715 B56E A5 4B			LDA	Cpntrl			; get continue pointer low byte
  1716 B570 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1717 B572 A5 49			LDA	Blinel			; get break line low byte
  1718 B574 A4 4A			LDY	Blineh			; get break line high byte
  1719 B576 85 47			STA	Clinel			; set current line low byte
  1720 B578 84 48			STY	Clineh			; set current line high byte
  1721 B57A 60				RTS
  1722
  1723 				; perform RUN
  1724 B57B			LAB_RUN
  1725 B57B D0 03			BNE	LAB_1696		; branch if RUN n
  1726 B57D 4C 48 B3			JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1727 									; return
  1728
  1729 				; does RUN n
  1730 B580			LAB_1696
  1731 B580 20 55 B3			JSR	LAB_147A		; go do 'CLEAR'
  1732 B583 F0 2E			BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1733
  1734 				; perform DO
  1735 B585			LAB_DO
  1736 B585 A9 05			LDA	#$05			; need 5 bytes for DO
  1737 B587 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1738 B58A A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1739 B58C 48				PHA				; push on stack
  1740 B58D A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1741 B58F 48				PHA				; push on stack
  1742 B590 A5 48			LDA	Clineh			; get current line high byte
  1743 B592 48				PHA				; push on stack
  1744 B593 A5 47			LDA	Clinel			; get current line low byte
  1745 B595 48				PHA				; push on stack
  1746 B596 A9 9D			LDA	#TK_DO			; token for DO
  1747 B598 48				PHA				; push on stack
  1748 B599 20 82 00			JSR	LAB_GBYT		; scan memory
  1749 B59C 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1750
  1751 				; perform GOSUB
  1752 B59F			LAB_GOSUB
  1753 B59F A9 05			LDA	#$05			; need 5 bytes for GOSUB
  1754 B5A1 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1755 B5A4 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1756 B5A6 48				PHA				; push on stack
  1757 B5A7 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1758 B5A9 48				PHA				; push on stack
  1759 B5AA A5 48			LDA	Clineh			; get current line high byte
  1760 B5AC 48				PHA				; push on stack
  1761 B5AD A5 47			LDA	Clinel			; get current line low byte
  1762 B5AF 48				PHA				; push on stack
  1763 B5B0 A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  1764 B5B2 48				PHA				; push on stack
  1765 B5B3			LAB_16B0
  1766 B5B3 20 82 00			JSR	LAB_GBYT		; scan memory
  1767 B5B6 20 BC B5			JSR	LAB_GOTO		; perform GOTO n
  1768 B5B9 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1769 									; (can't RTS, we used the stack!)
  1770
  1771 				; perform GOTO
  1772 B5BC			LAB_GOTO
  1773 B5BC 20 1B B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1774 B5BF 20 71 B6			JSR	LAB_SNBL		; scan for next BASIC line
  1775 B5C2 A5 48			LDA	Clineh			; get current line high byte
  1776 B5C4 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1777 B5C6 B0 0B			BCS	LAB_16D0		; branch if >= (start search from beginning)
  1778
  1779 B5C8 98				TYA				; else copy line index to A
  1780 B5C9 38				SEC				; set carry (+1)
  1781 B5CA 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1782 B5CC A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1783 B5CE 90 07			BCC	LAB_16D4		; branch if no overflow to high byte
  1784
  1785 B5D0 E8				INX				; increment high byte
  1786 B5D1 B0 04			BCS	LAB_16D4		; branch always (can never be carry)
  1787
  1788 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1789 B5D3			LAB_16D0
  1790 B5D3 A5 39			LDA	Smeml			; get start of mem low byte
  1791 B5D5 A6 3A			LDX	Smemh			; get start of mem high byte
  1792
  1793 				; search for line # in temp (Itempl/Itemph) from (AX)
  1794 B5D7			LAB_16D4
  1795 B5D7 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1796 B5DA 90 67			BCC	LAB_16F7		; if carry clear go do 'Undefined statement' error
  1797 									; (unspecified statement)
  1798
  1799 									; carry already set for subtract
  1800 B5DC A5 6A			LDA	Baslnl			; get pointer low byte
  1801 B5DE E9 01			SBC	#$01			; -1
  1802 B5E0 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1803 B5E2 A5 6B			LDA	Baslnh			; get pointer high byte
  1804 B5E4 E9 00			SBC	#$00			; subtract carry
  1805 B5E6 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1806 B5E8			LAB_16E5
  1807 B5E8 60				RTS
  1808
  1809 B5E9			LAB_DONOK
  1810 B5E9 A2 22			LDX	#$22			; error code $22 ('LOOP without DO' error)
  1811 B5EB 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1812
  1813 				; perform LOOP
  1814 B5EE			LAB_LOOP
  1815 B5EE A8				TAY				; save following token
  1816 B5EF BA				TSX				; copy stack pointer
  1817 B5F0 BD 03 01			LDA	LAB_STAK+3,X		; get token byte from stack
  1818 B5F3 C9 9D			CMP	#TK_DO			; compare with DO token
  1819 B5F5 D0 F2			BNE	LAB_DONOK		; branch if no matching DO
  1820
  1821 B5F7 E8				INX				; dump calling routine return address
  1822 B5F8 E8				INX				; dump calling routine return address
  1823 B5F9 9A				TXS				; correct stack
  1824 B5FA 98				TYA				; get saved following token back
  1825 B5FB F0 20			BEQ	LoopAlways		; if no following token loop forever
  1826 									; (stack pointer in X)
  1827
  1828 B5FD C9 3A			CMP	#':'			; could be ':'
  1829 B5FF F0 1C			BEQ	LoopAlways		; if :... loop forever
  1830
  1831 B601 E9 C8			SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1832 B603 AA				TAX				; copy to X (if it was UNTIL then Y will be correct)
  1833 B604 F0 04			BEQ	DoRest			; branch if was UNTIL
  1834
  1835 B606 CA				DEX				; decrement result
  1836 B607 D0 62			BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1837 									; only if the token was WHILE will this fail
  1838
  1839 B609 CA				DEX				; set invert result byte
  1840 B60A			DoRest
  1841 B60A 86 58			STX	Frnxth			; save invert result byte
  1842 B60C 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1843 B60F 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  1844 B612 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1845 B614 F0 02			BEQ	DoCmp			; if =0 go do straight compare
  1846
  1847 B616 A9 FF			LDA	#$FF			; else set all bits
  1848 B618			DoCmp
  1849 B618 BA				TSX				; copy stack pointer
  1850 B619 45 58			EOR	Frnxth			; EOR with invert byte
  1851 B61B D0 1A			BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1852
  1853 									; loop condition wasn't met so do it again
  1854 B61D			LoopAlways
  1855 B61D BD 02 01			LDA	LAB_STAK+2,X		; get current line low byte
  1856 B620 85 47			STA	Clinel			; save current line low byte
  1857 B622 BD 03 01			LDA	LAB_STAK+3,X		; get current line high byte
  1858 B625 85 48			STA	Clineh			; save current line high byte
  1859 B627 BD 04 01			LDA	LAB_STAK+4,X		; get BASIC execute pointer low byte
  1860 B62A 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1861 B62C BD 05 01			LDA	LAB_STAK+5,X		; get BASIC execute pointer high byte
  1862 B62F 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1863 B631 20 82 00			JSR	LAB_GBYT		; scan memory
  1864 B634 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1865
  1866 									; clear stack and back to interpreter loop
  1867 B637			LoopDone
  1868 B637 E8				INX				; dump DO token
  1869 B638 E8				INX				; dump current line low byte
  1870 B639 E8				INX				; dump current line high byte
  1871 B63A E8				INX				; dump BASIC execute pointer low byte
  1872 B63B E8				INX				; dump BASIC execute pointer high byte
  1873 B63C 9A				TXS				; correct stack
  1874 B63D 4C 5D B6			JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1875
  1876 				; do the return without gosub error
  1877 B640			LAB_16F4
  1878 B640 A2 04			LDX	#$04			; error code $04 ('RETURN without GOSUB' error)
  1879 B642 2C				.byte	$2C			; makes next line BIT LAB_0EA2
  1880
  1881 B643			LAB_16F7				; do undefined statement error
  1882 B643 A2 0E			LDX	#$0E			; error code $0E ('Undefined statement' error)
  1883 B645 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1884
  1885 				; perform RETURN
  1886 B648			LAB_RETURN
  1887 B648 D0 9E			BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1888
  1889 B64A			LAB_16E8
  1890 B64A 68				PLA				; dump calling routine return address
  1891 B64B 68				PLA				; dump calling routine return address
  1892 B64C 68				PLA				; pull token
  1893 B64D C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  1894 B64F D0 EF			BNE	LAB_16F4		; branch if no matching GOSUB
  1895
  1896 B651			LAB_16FF
  1897 B651 68				PLA				; pull current line low byte
  1898 B652 85 47			STA	Clinel			; save current line low byte
  1899 B654 68				PLA				; pull current line high byte
  1900 B655 85 48			STA	Clineh			; save current line high byte
  1901 B657 68				PLA				; pull BASIC execute pointer low byte
  1902 B658 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1903 B65A 68				PLA				; pull BASIC execute pointer high byte
  1904 B65B 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1905
  1906 									; now do the DATA statement as we could be returning into
  1907 									; the middle of an ON <var> GOSUB n,m,p,q line
  1908 									; (the return address used by the DATA statement is the one
  1909 									; pushed before the GOSUB was executed!)
  1910
  1911 				; perform DATA
  1912 B65D			LAB_DATA
  1913 B65D 20 6E B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1914 									; set BASIC execute pointer
  1915 B660			LAB_170F
  1916 B660 98				TYA				; copy index to A
  1917 B661 18				CLC				; clear carry for add
  1918 B662 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1919 B664 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1920 B666 90 02			BCC	LAB_1719		; skip next if no carry
  1921
  1922 B668 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1923 B66A			LAB_1719
  1924 B66A 60				RTS
  1925
  1926 B66B			LAB_16FC
  1927 B66B 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  1928
  1929 				; scan for next BASIC statement ([:] or [EOL])
  1930 				; returns Y as index to [:] or [EOL]
  1931 B66E			LAB_SNBS
  1932 B66E A2 3A			LDX	#':'			; set look for character = ':'
  1933 B670 2C				.byte	$2C			; makes next line BIT $00A2
  1934
  1935 				; scan for next BASIC line
  1936 				; returns Y as index to [EOL]
  1937 B671			LAB_SNBL
  1938 B671 A2 00			LDX	#$00			; set alt search character = [EOL]
  1939 B673 A0 00			LDY	#$00			; set search character = [EOL]
  1940 B675 84 1C			STY	Asrch			; store search character
  1941 B677			LAB_1725
  1942 B677 8A				TXA				; get alt search character
  1943 B678 45 1C			EOR	Asrch			; toggle search character, effectively swap with $00
  1944 B67A 85 1C			STA	Asrch			; save swapped search character
  1945 B67C			LAB_172D
  1946 B67C B1 83			LDA	(Bpntrl),Y		; get next byte
  1947 B67E F0 EA			BEQ	LAB_1719		; exit if null [EOL]
  1948
  1949 B680 C5 1C			CMP	Asrch			; compare with search character
  1950 B682 F0 E6			BEQ	LAB_1719		; exit if found
  1951
  1952 B684 C8				INY				; increment index
  1953 B685 C9 22			CMP	#$22			; compare current character with open quote
  1954 B687 D0 F3			BNE	LAB_172D		; if not open quote go get next character
  1955
  1956 B689 F0 EC			BEQ	LAB_1725		; if found go swap search character for alt search character
  1957
  1958 				; perform IF
  1959 B68B			LAB_IF
  1960 B68B 20 A6 BA			JSR	LAB_EVEX		; evaluate the expression
  1961 B68E 20 82 00			JSR	LAB_GBYT		; scan memory
  1962 B691 C9 C5			CMP	#TK_THEN		; compare with THEN token
  1963 B693 F0 11			BEQ	LAB_174B		; if it was THEN go do IF
  1964
  1965 									; wasn't IF .. THEN so must be IF .. GOTO
  1966 B695 C9 89			CMP	#TK_GOTO		; compare with GOTO token
  1967 B697 D0 D2			BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  1968
  1969 B699 A6 83			LDX	Bpntrl			; save the basic pointer low byte
  1970 B69B A4 84			LDY	Bpntrh			; save the basic pointer high byte
  1971 B69D 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1972 B6A0 B0 C9			BCS	LAB_16FC		; if not numeric go do syntax error
  1973
  1974 B6A2 86 83			STX	Bpntrl			; restore the basic pointer low byte
  1975 B6A4 84 84			STY	Bpntrh			; restore the basic pointer high byte
  1976 B6A6			LAB_174B
  1977 B6A6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1978 B6A8 F0 1E			BEQ	LAB_174E		; if the result was zero go look for an ELSE
  1979
  1980 B6AA 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  1981 B6AD B0 03			BCS	LAB_174D		; if not numeric go do var or keyword
  1982
  1983 B6AF			LAB_174C
  1984 B6AF 4C BC B5			JMP	LAB_GOTO		; else was numeric so do GOTO n
  1985
  1986 									; is var or keyword
  1987 B6B2			LAB_174D	; Patch: allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack
  1988 B6B2 68				PLA                     	; discard interpreter loop return address
  1989 B6B3 68				PLA                     	; so data structures are at the correct stack offset
  1990 B6B4 20 82 00			JSR   	LAB_GBYT          	; restore token or variable
  1991 B6B7 20 DB B4			JSR   	LAB_15FF          	; interpret BASIC code from (Bpntrl)
  1992
  1993 				; the IF was executed and there may be a following ELSE so the code needs to return
  1994 				; here to check and ignore the ELSE if present
  1995
  1996 B6BA A0 00			LDY   	#$00              	; clear the index
  1997 B6BC B1 83			LDA   	(Bpntrl),Y        	; get the next BASIC byte
  1998 B6BE C9 C1			CMP   	#TK_ELSE          	; compare it with the token for ELSE
  1999 B6C0 D0 03			BNE   	LAB_no_ELSE       	; no - continue on this line
  2000 B6C2 20 5D B6			JSR   	LAB_DATA          	; yes - skip the rest of the line
  2001
  2002 				; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2003 				; following ELSE will, correctly, cause a syntax error
  2004
  2005 B6C5			LAB_no_ELSE
  2006 B6C5 4C 9D B4			JMP 	LAB_15C2            	; return to the interpreter inner loop 
  2007 				;	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  2008 				;	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  2009 				;					; and return to this code to process any following code
  2010 				;
  2011 				;	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
  2012 				;					; but don't return here
  2013 				;
  2014 				;LAB_174G
  2015 				;	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2016 				;
  2017 				;; the IF was executed and there may be a following ELSE so the code needs to return
  2018 				;; here to check and ignore the ELSE if present
  2019 				;
  2020 				;	LDY	#$00			; clear the index
  2021 				;	LDA	(Bpntrl),Y		; get the next BASIC byte
  2022 				;	CMP	#TK_ELSE		; compare it with the token for ELSE
  2023 				;	BEQ	LAB_DATA		; if ELSE ignore the following statement
  2024 				;
  2025 				;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2026 				;; following ELSE will, correctly, cause a syntax error
  2027 				;
  2028 				;	RTS				; else return to the interpreter inner loop
  2029 				;
  2030 				; perform ELSE after IF
  2031 B6C8			LAB_174E
  2032 B6C8 A0 00			LDY	#$00			; clear the BASIC byte index
  2033 B6CA A2 01			LDX	#$01			; clear the nesting depth
  2034 B6CC			LAB_1750
  2035 B6CC C8				INY				; increment the BASIC byte index
  2036 B6CD B1 83			LDA	(Bpntrl),Y		; get the next BASIC byte
  2037 B6CF F0 0F			BEQ	LAB_1753		; if EOL go add the pointer and return
  2038
  2039 B6D1 C9 8B			CMP	#TK_IF			; compare the byte with the token for IF
  2040 B6D3 D0 03			BNE	LAB_1752		; if not IF token skip the depth increment
  2041
  2042 B6D5 E8				INX				; else increment the nesting depth ..
  2043 B6D6 D0 F4			BNE	LAB_1750		; .. and continue looking
  2044
  2045 B6D8			LAB_1752
  2046 B6D8 C9 C1			CMP	#TK_ELSE		; compare the byte with the token for ELSE
  2047 B6DA D0 F0			BNE	LAB_1750		; if not ELSE token continue looking
  2048
  2049 B6DC CA				DEX				; was ELSE so decrement the nesting depth
  2050 B6DD D0 ED			BNE	LAB_1750		; loop if still nested
  2051
  2052 B6DF C8				INY				; increment the BASIC byte index past the ELSE
  2053
  2054 				; found the matching ELSE, now do <{n|statement}>
  2055 B6E0			LAB_1753
  2056 B6E0 98				TYA				; else copy line index to A
  2057 B6E1 18				CLC				; clear carry for add
  2058 B6E2 65 83			ADC	Bpntrl			; add the BASIC execute pointer low byte
  2059 B6E4 85 83			STA	Bpntrl			; save the BASIC execute pointer low byte
  2060 B6E6 90 02			BCC	LAB_1754		; branch if no overflow to high byte
  2061
  2062 B6E8 E6 84			INC	Bpntrh			; else increment the BASIC execute pointer high byte
  2063 B6EA			LAB_1754
  2064 B6EA 20 82 00			JSR	LAB_GBYT		; scan memory
  2065 B6ED 90 C0			BCC	LAB_174C		; if numeric do GOTO n
  2066 									; the code will return to the interpreter loop at the
  2067 									; tail end of the GOTO <n>
  2068
  2069 B6EF 4C DB B4			JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2070 									; the code will return to the interpreter loop at the
  2071 									; tail end of the <statement>
  2072
  2073 				; perform REM, skip (rest of) line
  2074 B6F2			LAB_REM
  2075 B6F2 20 71 B6			JSR	LAB_SNBL		; scan for next BASIC line
  2076 B6F5 4C 60 B6			JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  2077
  2078 B6F8			LAB_16FD
  2079 B6F8 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  2080
  2081 				; perform ON
  2082 				; 21-7-25 Emile: ON {IRQ|NMI} removed
  2083 B6FB 20 61 C4		LAB_ON	JSR	LAB_GTBY		; get byte parameter
  2084 B6FE 48				PHA				; push GOTO/GOSUB token
  2085 B6FF C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  2086 B701 F0 04			BEQ	LAB_176B		; branch if GOSUB
  2087
  2088 B703 C9 89			CMP	#TK_GOTO		; compare with GOTO token
  2089 B705			LAB_1767
  2090 B705 D0 F1			BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  2091
  2092 				; next character was GOTO or GOSUB
  2093 B707			LAB_176B
  2094 B707 C6 6F			DEC	FAC1_3			; decrement index (byte value)
  2095 B709 D0 04			BNE	LAB_1773		; branch if not zero
  2096
  2097 B70B 68				PLA				; pull GOTO/GOSUB token
  2098 B70C 4C DD B4			JMP	LAB_1602		; go execute it
  2099
  2100 B70F			LAB_1773
  2101 B70F 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2102 B712 20 1B B7			JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  2103 									; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2104 									; just BNE LAB_176B for the loop. should be quicker ..
  2105 									; no we can't, what if we meet a colon or [EOL]?)
  2106 B715 C9 2C			CMP	#$2C			; compare next character with ','
  2107 B717 F0 EE			BEQ	LAB_176B		; loop if ','
  2108
  2109 B719			LAB_177E
  2110 B719 68				PLA				; else pull keyword token (run out of options)
  2111 									; also dump +/-1 pointer low byte and exit
  2112 B71A			LAB_177F
  2113 B71A 60				RTS
  2114
  2115 				; takes n * 106 + 11 cycles where n is the number of digits
  2116 				; get fixed-point number into temp integer
  2117 B71B			LAB_GFPN
  2118 B71B A2 00			LDX	#$00			; clear reg
  2119 B71D 86 11			STX	Itempl			; clear temporary integer low byte
  2120 B71F			LAB_1785
  2121 B71F 86 12			STX	Itemph			; save temporary integer high byte
  2122 B721 B0 F7			BCS	LAB_177F		; return if carry set, end of scan, character was
  2123 									; not 0-9
  2124
  2125 B723 E0 19			CPX	#$19			; compare high byte with $19
  2126 B725 A8				TAY				; ensure Zb = 0 if the branch is taken
  2127 B726 B0 DD			BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  2128 									; bit does *$0A, = 64000, compare at target will fail
  2129 									; and do syntax error
  2130
  2131 B728 E9 2F			SBC	#'0'-1			; subtract '0', $2F + carry, from byte
  2132 B72A A8				TAY				; copy binary digit
  2133 B72B A5 11			LDA	Itempl			; get temporary integer low byte
  2134 B72D 0A				ASL				; *2 low byte
  2135 B72E 26 12			ROL	Itemph			; *2 high byte
  2136 B730 0A				ASL				; *2 low byte
  2137 B731 26 12			ROL	Itemph			; *2 high byte, *4
  2138 B733 65 11			ADC	Itempl			; + low byte, *5
  2139 B735 85 11			STA	Itempl			; save it
  2140 B737 8A				TXA				; get high byte copy to A
  2141 B738 65 12			ADC	Itemph			; + high byte, *5
  2142 B73A 06 11			ASL	Itempl			; *2 low byte, *10d
  2143 B73C 2A				ROL				; *2 high byte, *10d
  2144 B73D AA				TAX				; copy high byte back to X
  2145 B73E 98				TYA				; get binary digit back
  2146 B73F 65 11			ADC	Itempl			; add number low byte
  2147 B741 85 11			STA	Itempl			; save number low byte
  2148 B743 90 01			BCC	LAB_17B3		; if no overflow to high byte get next character
  2149
  2150 B745 E8				INX				; else increment high byte
  2151 B746			LAB_17B3
  2152 B746 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2153 B749 4C 1F B7			JMP	LAB_1785		; loop for next character
  2154
  2155 				; perform DEC
  2156 B74C			LAB_DEC
  2157 B74C A9 EB			LDA	#<LAB_2AFD		; set -1 pointer low byte
  2158 B74E 2C				.byte	$2C			; BIT abs to skip the LDA below
  2159
  2160 				; perform INC
  2161 B74F			LAB_INC
  2162 B74F A9 E7			LDA	#<LAB_259C		; set 1 pointer low byte
  2163 B751			LAB_17B5
  2164 B751 48				PHA				; save +/-1 pointer low byte
  2165 B752			LAB_17B7
  2166 B752 20 71 BD			JSR	LAB_GVAR		; get var address
  2167 B755 A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2168 B757 30 1E			BMI	IncrErr			; exit if string
  2169
  2170 B759 85 57			STA	Lvarpl			; save var address low byte
  2171 B75B 84 58			STY	Lvarph			; save var address high byte
  2172 B75D 20 52 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  2173 B760 68				PLA				; get +/-1 pointer low byte
  2174 B761 48				PHA				; save +/-1 pointer low byte
  2175 B762 A0 D3			LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  2176 B764 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1
  2177 B767 20 78 C8			JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
  2178
  2179 B76A 20 82 00			JSR	LAB_GBYT		; scan memory
  2180 B76D C9 2C			CMP	#','			; compare with ','
  2181 B76F D0 A8			BNE	LAB_177E		; exit if not ',' (either end or error)
  2182
  2183 									; was ',' so another INCR variable to do
  2184 B771 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2185 B774 4C 52 B7			JMP	LAB_17B7		; go do next var
  2186
  2187 B777			IncrErr
  2188 B777 4C A1 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  2189
  2190 				; perform LET
  2191 B77A			LAB_LET
  2192 B77A 20 71 BD			JSR	LAB_GVAR		; get var address
  2193 B77D 85 57			STA	Lvarpl			; save var address low byte
  2194 B77F 84 58			STY	Lvarph			; save var address high byte
  2195 B781 A9 D7			LDA	#TK_EQUAL		; get = token
  2196 B783 20 B6 BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2197 B786 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  2198 B788 48				PHA				; push data type flag
  2199 B789 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  2200 B78C 68				PLA				; pop data type flag
  2201 B78D 2A				ROL				; set carry if type = string
  2202 					; patch result of a string compare stores string pointer to variable
  2203 B78E 20 98 BA			JSR	LAB_CKTM		; type match check, keep C (expected type)
  2204 B791 B0 03			BCS	LAB_17D5		; branch if string
  2205
  2206 B793 4C 78 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2207
  2208 				; string LET
  2209 B796			LAB_17D5
  2210 B796 A0 02			LDY	#$02			; set index to pointer high byte
  2211 B798 B1 6E			LDA	(des_pl),Y		; get string pointer high byte
  2212 B79A C5 42			CMP	Sstorh			; compare bottom of string space high byte
  2213 B79C 90 17			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2214
  2215 B79E D0 07			BNE	LAB_17E6		; branch if >
  2216 									; else was equal so compare low bytes
  2217 B7A0 88				DEY				; decrement index
  2218 B7A1 B1 6E			LDA	(des_pl),Y		; get pointer low byte
  2219 B7A3 C5 41			CMP	Sstorl			; compare bottom of string space low byte
  2220 B7A5 90 0E			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2221 									; pointer was >= to bottom of string space pointer
  2222 B7A7			LAB_17E6
  2223 B7A7 A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2224 B7A9 C4 3C			CPY	Svarh			; compare start of vars high byte
  2225 B7AB 90 08			BCC	LAB_17F4		; branch if less (descriptor is on stack)
  2226
  2227 B7AD D0 0D			BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  2228
  2229 									; else high bytes were equal so ..
  2230 B7AF A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2231 B7B1 C5 3B			CMP	Svarl			; compare start of vars low byte
  2232 B7B3 B0 07			BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  2233
  2234 B7B5			LAB_17F4
  2235 B7B5 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2236 B7B7 A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2237 B7B9 4C D2 B7			JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  2238
  2239 									; make space and copy string
  2240 B7BC			LAB_17FB
  2241 B7BC A0 00			LDY	#$00			; index to length
  2242 B7BE B1 6E			LDA	(des_pl),Y		; get string length
  2243 B7C0 20 05 C1			JSR	LAB_209C		; copy string
  2244 B7C3 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  2245 B7C5 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  2246 B7C7 85 78			STA	ssptr_l			; save descriptor pointer low byte
  2247 B7C9 84 79			STY	ssptr_h			; save descriptor pointer high byte
  2248 B7CB 20 E6 C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  2249 B7CE A9 6C			LDA	#<FAC1_e		; set descriptor pointer low byte
  2250 B7D0 A0 00			LDY	#>FAC1_e		; get descriptor pointer high byte
  2251
  2252 									; clean stack and assign value to string variable
  2253 B7D2			LAB_1811
  2254 B7D2 85 5E			STA	des_2l			; save descriptor_2 pointer low byte
  2255 B7D4 84 5F			STY	des_2h			; save descriptor_2 pointer high byte
  2256 B7D6 20 48 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  2257 B7D9 A0 00			LDY	#$00			; index to length
  2258 B7DB B1 5E			LDA	(des_2l),Y		; get string length
  2259 B7DD 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2260 B7DF C8				INY				; index to string pointer low byte
  2261 B7E0 B1 5E			LDA	(des_2l),Y		; get string pointer low byte
  2262 B7E2 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2263 B7E4 C8				INY				; index to string pointer high byte
  2264 B7E5 B1 5E			LDA	(des_2l),Y		; get string pointer high byte
  2265 B7E7 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2266 B7E9 60				RTS
  2267
  2268 				; perform GET
  2269 B7EA			LAB_GET
  2270 B7EA 20 71 BD			JSR	LAB_GVAR		; get var address
  2271 B7ED 85 57			STA	Lvarpl			; save var address low byte
  2272 B7EF 84 58			STY	Lvarph			; save var address high byte
  2273 B7F1 20 D7 CE			JSR	INGET			; get input byte
  2274 B7F4 A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2275 B7F6 30 07			BMI	LAB_GETS		; go get string character
  2276
  2277 									; was numeric get
  2278 B7F8 A8				TAY				; copy character to Y
  2279 B7F9 20 39 C0			JSR	LAB_1FD0		; convert Y to byte in FAC1
  2280 B7FC 4C 78 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2281
  2282 B7FF			LAB_GETS
  2283 B7FF 48				PHA				; save character
  2284 B800 A9 01			LDA	#$01			; string is single byte
  2285 B802 B0 01			BCS	LAB_IsByte		; branch if byte received
  2286
  2287 B804 68				PLA				; string is null
  2288 B805			LAB_IsByte
  2289 B805 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  2290 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2291 B808 F0 05			BEQ	LAB_NoSt		; skip store if null string
  2292
  2293 B80A 68				PLA				; get character back
  2294 B80B A0 00			LDY	#$00			; clear index
  2295 B80D 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  2296 B80F			LAB_NoSt
  2297 B80F 20 5A C1			JSR	LAB_RTST		; check for space on descriptor stack then put address
  2298 									; and length on descriptor stack and update stack pointers
  2299
  2300 B812 4C 96 B7			JMP	LAB_17D5		; do string LET and return
  2301
  2302 				; perform PRINT
  2303 B815			LAB_1829
  2304 B815 20 9C B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2305 B818			LAB_182C
  2306 B818 20 82 00			JSR	LAB_GBYT		; scan memory
  2307
  2308 				; PRINT
  2309 B81B			LAB_PRINT
  2310 B81B F0 3B			BEQ	LAB_CRLF		; if nothing following just print CR/LF
  2311
  2312 B81D			LAB_1831
  2313 B81D C9 C0			CMP	#TK_TAB			; compare with TAB( token
  2314 B81F F0 56			BEQ	LAB_18A2		; go do TAB/SPC
  2315
  2316 B821 C9 C4			CMP	#TK_SPC			; compare with SPC( token
  2317 B823 F0 52			BEQ	LAB_18A2		; go do TAB/SPC
  2318
  2319 B825 C9 2C			CMP	#','			; compare with ','
  2320 B827 F0 38			BEQ	LAB_188B		; go do move to next TAB mark
  2321
  2322 B829 C9 3B			CMP	#';'			; compare with ';'
  2323 B82B F0 66			BEQ	LAB_18BD		; if ';' continue with PRINT processing
  2324
  2325 B82D 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  2326 B830 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2327 B832 30 E1			BMI	LAB_1829		; branch if string
  2328
  2329 B834 20 6A CA			JSR	LAB_296E		; convert FAC1 to string
  2330 B837 20 17 C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2331 B83A A0 00			LDY	#$00			; clear index
  2332
  2333 				; don't check fit if terminal width byte is zero
  2334
  2335 B83C A5 0F			LDA	TWidth			; get terminal width byte
  2336 B83E F0 0A			BEQ	LAB_185E		; skip check if zero
  2337
  2338 B840 38				SEC				; set carry for subtract
  2339 B841 E5 0E			SBC	TPos			; subtract terminal position
  2340 B843 F1 6E			SBC	(des_pl),Y		; subtract string length
  2341 B845 B0 03			BCS	LAB_185E		; branch if less than terminal width
  2342
  2343 B847 20 58 B8			JSR	LAB_CRLF		; else print CR/LF
  2344 B84A			LAB_185E
  2345 B84A 20 9C B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2346 B84D F0 C9			BEQ	LAB_182C		; always go continue processing line
  2347
  2348 				; CR/LF return to BASIC from BASIC input handler
  2349 B84F			LAB_1866
  2350 B84F A9 00			LDA	#$00			; clear byte
  2351 B851 9D 7F 18			STA	Ibuffs,X		; null terminate input
  2352 B854 A2 7F			LDX	#<Ibuffs		; set X to buffer start-1 low byte
  2353 B856 A0 18			LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  2354
  2355 				; print CR/LF
  2356 B858			LAB_CRLF
  2357 B858 A9 0D			LDA	#$0D			; load [CR]
  2358 B85A 20 B3 B8			JSR	LAB_PRNA		; go print the character
  2359 B85D A9 0A			LDA	#$0A			; load [LF]
  2360 B85F D0 52			BNE	LAB_PRNA		; go print the character and return, branch always
  2361
  2362 B861			LAB_188B
  2363 B861 A5 0E			LDA	TPos			; get terminal position
  2364 B863 C5 10			CMP	Iclim			; compare with input column limit
  2365 B865 90 05			BCC	LAB_1897		; branch if less
  2366
  2367 B867 20 58 B8			JSR	LAB_CRLF		; else print CR/LF (next line)
  2368 B86A D0 27			BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2369
  2370 B86C			LAB_1897
  2371 B86C 38				SEC				; set carry for subtract
  2372 B86D			LAB_1898
  2373 B86D E5 24			SBC	TabSiz			; subtract TAB size
  2374 B86F B0 FC			BCS	LAB_1898		; loop if result was +ve
  2375
  2376 B871 49 FF			EOR	#$FF			; complement it
  2377 B873 69 01			ADC	#$01			; +1 (twos complement)
  2378 B875 D0 12			BNE	LAB_18B6		; always print A spaces (result is never $00)
  2379 									; do TAB/SPC
  2380 B877			LAB_18A2
  2381 B877 48				PHA				; save token
  2382 B878 20 5E C4			JSR	LAB_SGBY		; scan and get byte parameter
  2383 B87B C9 29			CMP	#$29			; is next character )
  2384 B87D D0 7B			BNE	LAB_1910		; if not do syntax error then warm start
  2385
  2386 B87F 68				PLA				; get token back
  2387 B880 C9 C0			CMP	#TK_TAB			; was it TAB ?
  2388 B882 D0 06			BNE	LAB_18B7		; if not go do SPC
  2389
  2390 									; calculate TAB offset
  2391 B884 8A				TXA				; copy integer value to A
  2392 B885 E5 0E			SBC	TPos			; subtract terminal position
  2393 B887 90 0A			BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  2394 									; print A spaces
  2395 B889			LAB_18B6
  2396 B889 AA				TAX				; copy result to X
  2397 B88A			LAB_18B7
  2398 B88A 8A				TXA				; set flags on size for SPC
  2399 B88B F0 06			BEQ	LAB_18BD		; branch if result was = $0, already here
  2400
  2401 									; print X spaces
  2402 B88D			LAB_18BA
  2403 B88D 20 AE B8			JSR	LAB_18E0		; print ' '
  2404 B890 CA				DEX				; decrement count
  2405 B891 D0 FA			BNE	LAB_18BA		; loop if not all done
  2406
  2407 									; continue with PRINT processing
  2408 B893			LAB_18BD
  2409 B893 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2410 B896 D0 85			BNE	LAB_1831		; if more to print go do it
  2411
  2412 B898 60				RTS
  2413
  2414 				; print null terminated string from memory
  2415 B899			LAB_18C3
  2416 B899 20 17 C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2417
  2418 				; print string from Sutill/Sutilh
  2419 B89C			LAB_18C6
  2420 B89C 20 13 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2421 									; space returns with A = length, X=$71=pointer low byte,
  2422 									; Y=$72=pointer high byte
  2423 B89F A0 00			LDY	#$00			; reset index
  2424 B8A1 AA				TAX				; copy length to X
  2425 B8A2 F0 49			BEQ	LAB_188C		; exit (RTS) if null string
  2426
  2427 B8A4			LAB_18CD
  2428
  2429 B8A4 B1 31			LDA	(ut1_pl),Y		; get next byte
  2430 B8A6 20 B3 B8			JSR	LAB_PRNA		; go print the character
  2431 B8A9 C8				INY				; increment index
  2432 B8AA CA				DEX				; decrement count
  2433 B8AB D0 F7			BNE	LAB_18CD		; loop if not done yet
  2434
  2435 B8AD 60				RTS
  2436
  2437 									; Print single format character
  2438 				; print ' '
  2439 B8AE			LAB_18E0
  2440 B8AE A9 20			LDA	#$20			; load ' '
  2441 B8B0 2C				.byte	$2C			; change next line to BIT LAB_3FA9
  2442
  2443 				; print '?' character
  2444 B8B1			LAB_18E3
  2445 B8B1 A9 3F			LDA	#$3F			; load '?' character
  2446
  2447 				; print character in A
  2448 				; now includes the null handler
  2449 				; also includes infinite line length code
  2450 				; note! some routines expect this one to exit with Zb=0
  2451 B8B3			LAB_PRNA
  2452 B8B3 C9 20			CMP	#' '			; compare with ' '
  2453 B8B5 90 19			BCC	LAB_18F9		; branch if less (non printing)
  2454
  2455 									; else printable character
  2456 B8B7 48				PHA				; save the character
  2457
  2458 				; don't check fit if terminal width byte is zero
  2459 B8B8 A5 0F			LDA	TWidth			; get terminal width
  2460 B8BA D0 0A			BNE	LAB_18F0		; branch if not zero (not infinite length)
  2461
  2462 				; is 'infinite line' so check TAB position
  2463 B8BC A5 0E			LDA	TPos			; get position
  2464 B8BE E5 24			SBC	TabSiz			; subtract TAB size, carry set by CMP #$20 above
  2465 B8C0 D0 0B			BNE	LAB_18F7		; skip reset if different
  2466
  2467 B8C2 85 0E			STA	TPos			; else reset position
  2468 B8C4 F0 07			BEQ	LAB_18F7		; go print character
  2469
  2470 B8C6			LAB_18F0
  2471 B8C6 C5 0E			CMP	TPos			; compare with terminal character position
  2472 B8C8 D0 03			BNE	LAB_18F7		; branch if not at end of line
  2473
  2474 B8CA 20 58 B8			JSR	LAB_CRLF		; else print CR/LF
  2475 B8CD			LAB_18F7
  2476 B8CD E6 0E			INC	TPos			; increment terminal position
  2477 B8CF 68				PLA				; get character back
  2478 B8D0			LAB_18F9
  2479 B8D0 20 02 D3			JSR	V_OUTP			; output byte via output vector
  2480 B8D3 C9 0D			CMP	#$0D			; compare with [CR]
  2481 B8D5 D0 14			BNE	LAB_188A		; branch if not [CR]
  2482
  2483 									; else print nullct nulls after the [CR]
  2484 B8D7 86 38			STX	TempB			; save buffer index
  2485 B8D9 A6 0D			LDX	Nullct			; get null count
  2486 B8DB F0 0A			BEQ	LAB_1886		; branch if no nulls
  2487
  2488 B8DD A9 00			LDA	#$00			; load [NULL]
  2489 B8DF			LAB_1880
  2490 B8DF 20 B3 B8			JSR	LAB_PRNA		; go print the character
  2491 B8E2 CA				DEX				; decrement count
  2492 B8E3 D0 FA			BNE	LAB_1880		; loop if not all done
  2493
  2494 B8E5 A9 0D			LDA	#$0D			; restore the character (and set the flags)
  2495 B8E7			LAB_1886
  2496 B8E7 86 0E			STX	TPos			; clear terminal position (X always = zero when we get here)
  2497 B8E9 A6 38			LDX	TempB			; restore buffer index
  2498 B8EB			LAB_188A
  2499 B8EB 29 FF			AND	#$FF			; set the flags
  2500 B8ED			LAB_188C
  2501 B8ED 60				RTS
  2502
  2503 				; handle bad input data
  2504 B8EE			LAB_1904
  2505 B8EE A5 22			LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
  2506 B8F0 10 0B			BPL	LAB_1913		; branch if INPUT (go do redo)
  2507
  2508 B8F2 A5 4D			LDA	Dlinel			; get current DATA line low byte
  2509 B8F4 A4 4E			LDY	Dlineh			; get current DATA line high byte
  2510 B8F6 85 47			STA	Clinel			; save current line low byte
  2511 B8F8 84 48			STY	Clineh			; save current line high byte
  2512 B8FA			LAB_1910
  2513 B8FA 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  2514
  2515 									; mode was INPUT
  2516 B8FD			LAB_1913
  2517 B8FD A9 39			LDA	#<LAB_REDO		; point to redo message (low addr)
  2518 B8FF A0 DB			LDY	#>LAB_REDO		; point to redo message (high addr)
  2519 B901 20 99 B8			JSR	LAB_18C3		; print null terminated string from memory
  2520 B904 A5 4B			LDA	Cpntrl			; get continue pointer low byte
  2521 B906 A4 4C			LDY	Cpntrh			; get continue pointer high byte
  2522 B908 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2523 B90A 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  2524 B90C 60				RTS
  2525
  2526 				; perform INPUT
  2527 B90D			LAB_INPUT
  2528 B90D C9 22			CMP	#$22			; compare next byte with open quote
  2529 B90F D0 0B			BNE	LAB_1934		; branch if no prompt string
  2530
  2531 B911 20 83 BB			JSR	LAB_1BC1		; print '...' string
  2532 B914 A9 3B			LDA	#$3B			; load A with ';'
  2533 B916 20 B6 BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2534 B919 20 9C B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2535
  2536 									; done with prompt, now get data
  2537 B91C			LAB_1934
  2538 B91C 20 3D C0			JSR	LAB_CKRN		; check not Direct, back here if ok
  2539 B91F 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2540 B922 A9 00			LDA	#$00			; set mode = INPUT
  2541 B924 CD 7F 18			CMP	Ibuffs			; test first byte in buffer
  2542 B927 D0 09			BNE	LAB_1953		; branch if not null input
  2543
  2544 					; *** change p2: keep carry set to throw break message
  2545 					;CLC				; was null input so clear carry to exit program
  2546 B929 4C 05 B5			JMP	LAB_1647		; go do BREAK exit
  2547
  2548 				; perform READ
  2549 B92C			LAB_READ
  2550 B92C A6 4F			LDX	Dptrl			; get DATA pointer low byte
  2551 B92E A4 50			LDY	Dptrh			; get DATA pointer high byte
  2552 B930 A9 80			LDA	#$80			; set mode = READ
  2553
  2554 B932			LAB_1953
  2555 B932 85 22			STA	Imode			; set input mode flag, $00=INPUT, $80=READ
  2556 B934 86 51			STX	Rdptrl			; save READ pointer low byte
  2557 B936 84 52			STY	Rdptrh			; save READ pointer high byte
  2558 									; READ or INPUT next variable from list
  2559 B938			LAB_195B
  2560 B938 20 71 BD			JSR	LAB_GVAR		; get (var) address
  2561 B93B 85 57			STA	Lvarpl			; save address low byte
  2562 B93D 84 58			STY	Lvarph			; save address high byte
  2563 B93F A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2564 B941 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2565 B943 85 11			STA	Itempl			; save as temporary integer low byte
  2566 B945 84 12			STY	Itemph			; save as temporary integer high byte
  2567 B947 A6 51			LDX	Rdptrl			; get READ pointer low byte
  2568 B949 A4 52			LDY	Rdptrh			; get READ pointer high byte
  2569 B94B 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2570 B94D 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2571 B94F 20 82 00			JSR	LAB_GBYT		; scan memory
  2572 B952 D0 11			BNE	LAB_1988		; branch if not null
  2573
  2574 									; pointer was to null entry
  2575 B954 24 22			BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
  2576 B956 30 65			BMI	LAB_19DD		; branch if READ
  2577
  2578 									; mode was INPUT
  2579 B958 20 B1 B8			JSR	LAB_18E3		; print '?' character (double ? for extended input)
  2580 B95B 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2581 B95E 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2582 B960 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2583 B962			LAB_1985
  2584 B962 20 82 00			JSR	LAB_GBYT		; scan memory
  2585 B965			LAB_1988
  2586 B965 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2587 B967 10 24			BPL	LAB_19B0		; branch if numeric
  2588
  2589 									; else get string
  2590 B969 85 1B			STA	Srchc			; save search character
  2591 B96B C9 22			CMP	#$22			; was it ' ?
  2592 B96D F0 07			BEQ	LAB_1999		; branch if so
  2593
  2594 B96F A9 3A			LDA	#':'			; else search character is ':'
  2595 B971 85 1B			STA	Srchc			; set new search character
  2596 B973 A9 2C			LDA	#','			; other search character is ','
  2597 B975 18				CLC				; clear carry for add
  2598 B976			LAB_1999
  2599 B976 85 1C			STA	Asrch			; set second search character
  2600 B978 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2601 B97A A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2602
  2603 B97C 69 00			ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2604 B97E 90 01			BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2605
  2606 B980 C8				INY				; else increment high byte
  2607 B981			LAB_19A4
  2608 B981 20 1D C1			JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
  2609 B984 20 A4 C4			JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2610 B987 20 96 B7			JSR	LAB_17D5		; go do string LET
  2611 B98A 4C 93 B9			JMP	LAB_19B6		; go check string terminator
  2612
  2613 									; get numeric INPUT
  2614 B98D			LAB_19B0
  2615 B98D 20 7B C9			JSR	LAB_2887		; get FAC1 from string
  2616 B990 20 78 C8			JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
  2617 B993			LAB_19B6
  2618 B993 20 82 00			JSR	LAB_GBYT		; scan memory
  2619 B996 F0 0A			BEQ	LAB_19C5		; branch if null (last entry)
  2620
  2621 B998 C9 2C			CMP	#','			; else compare with ','
  2622 B99A F0 03			BEQ	LAB_19C2		; branch if ','
  2623
  2624 B99C 4C EE B8			JMP	LAB_1904		; else go handle bad input data
  2625
  2626 									; got good input data
  2627 B99F			LAB_19C2
  2628 B99F 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2629 B9A2			LAB_19C5
  2630 B9A2 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2631 B9A4 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2632 B9A6 85 51			STA	Rdptrl			; save for now
  2633 B9A8 84 52			STY	Rdptrh			; save for now
  2634 B9AA A5 11			LDA	Itempl			; get temporary integer low byte (temp BASIC execute ptr)
  2635 B9AC A4 12			LDY	Itemph			; get temporary integer high byte (temp BASIC execute ptr)
  2636 B9AE 85 83			STA	Bpntrl			; set BASIC execute pointer low byte
  2637 B9B0 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2638 B9B2 20 82 00			JSR	LAB_GBYT		; scan memory
  2639 B9B5 F0 2C			BEQ	LAB_1A03		; if null go do extra ignored message
  2640
  2641 B9B7 20 C3 BB			JSR	LAB_1C01		; else scan for ',' , else do syntax error then warm start
  2642 B9BA 4C 38 B9			JMP	LAB_195B		; go INPUT next variable from list
  2643
  2644 									; find next DATA statement or do 'Out of DATA' error
  2645 B9BD			LAB_19DD
  2646 B9BD 20 6E B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2647 B9C0 C8				INY				; increment index
  2648 B9C1 AA				TAX				; copy character ([:] or [EOL])
  2649 B9C2 D0 12			BNE	LAB_19F6		; branch if [:]
  2650
  2651 B9C4 A2 06			LDX	#$06			; set for 'Out of DATA' error
  2652 B9C6 C8				INY				; increment index, now points to next line pointer high byte
  2653 B9C7 B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  2654 B9C9 F0 73			BEQ	LAB_1A54		; branch if end (eventually does error X)
  2655
  2656 B9CB C8				INY				; increment index
  2657 B9CC B1 83			LDA	(Bpntrl),Y		; get next line # low byte
  2658 B9CE 85 4D			STA	Dlinel			; save current DATA line low byte
  2659 B9D0 C8				INY				; increment index
  2660 B9D1 B1 83			LDA	(Bpntrl),Y		; get next line # high byte
  2661 B9D3 C8				INY				; increment index
  2662 B9D4 85 4E			STA	Dlineh			; save current DATA line high byte
  2663 B9D6			LAB_19F6
  2664 B9D6 B1 83			LDA	(Bpntrl),Y		; get byte
  2665 B9D8 C8				INY				; increment index
  2666 B9D9 AA				TAX				; copy to X
  2667 B9DA 20 60 B6			JSR	LAB_170F		; set BASIC execute pointer
  2668 B9DD E0 83			CPX	#TK_DATA		; compare with 'DATA' token
  2669 B9DF F0 81			BEQ	LAB_1985		; was 'DATA' so go do next READ
  2670
  2671 B9E1 D0 DA			BNE	LAB_19DD		; go find next statement if not 'DATA'
  2672
  2673 				; end of INPUT/READ routine
  2674 B9E3			LAB_1A03
  2675 B9E3 A5 51			LDA	Rdptrl			; get temp READ pointer low byte
  2676 B9E5 A4 52			LDY	Rdptrh			; get temp READ pointer high byte
  2677 B9E7 A6 22			LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
  2678 B9E9 10 03			BPL	LAB_1A0E		; branch if INPUT
  2679
  2680 B9EB 4C 27 B5			JMP	LAB_1624		; save AY as DATA pointer and return
  2681
  2682 									; we were getting INPUT
  2683 B9EE			LAB_1A0E
  2684 B9EE A0 00			LDY	#$00			; clear index
  2685 B9F0 B1 51			LDA	(Rdptrl),Y		; get next byte
  2686 B9F2 D0 01			BNE	LAB_1A1B		; error if not end of INPUT
  2687
  2688 B9F4 60				RTS
  2689
  2690 									; user typed too much
  2691 B9F5			LAB_1A1B
  2692 B9F5 A9 28			LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2693 B9F7 A0 DB			LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2694 B9F9 4C 99 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  2695
  2696 				; search the stack for FOR activity
  2697 				; exit with z=1 if FOR else exit with z=0
  2698 B9FC			LAB_11A1
  2699 B9FC BA				TSX				; copy stack pointer
  2700 B9FD E8				INX				; +1 pass return address
  2701 B9FE E8				INX				; +2 pass return address
  2702 B9FF E8				INX				; +3 pass calling routine return address
  2703 BA00 E8				INX				; +4 pass calling routine return address
  2704 BA01			LAB_11A6
  2705 BA01 BD 01 01			LDA	LAB_STAK+1,X		; get token byte from stack
  2706 BA04 C9 81			CMP	#TK_FOR			; is it FOR token
  2707 BA06 D0 21			BNE	LAB_11CE		; exit if not FOR token
  2708
  2709 									; was FOR token
  2710 BA08 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  2711 BA0A D0 0A			BNE	LAB_11BB		; branch if not null
  2712
  2713 BA0C BD 02 01			LDA	LAB_STAK+2,X		; get FOR variable pointer low byte
  2714 BA0F 85 57			STA	Frnxtl			; save var pointer for FOR/NEXT low byte
  2715 BA11 BD 03 01			LDA	LAB_STAK+3,X		; get FOR variable pointer high byte
  2716 BA14 85 58			STA	Frnxth			; save var pointer for FOR/NEXT high byte
  2717 BA16			LAB_11BB
  2718 BA16 DD 03 01			CMP	LAB_STAK+3,X		; compare var pointer with stacked var pointer (high byte)
  2719 BA19 D0 07			BNE	LAB_11C7		; branch if no match
  2720
  2721 BA1B A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  2722 BA1D DD 02 01			CMP	LAB_STAK+2,X		; compare var pointer with stacked var pointer (low byte)
  2723 BA20 F0 07			BEQ	LAB_11CE		; exit if match found
  2724
  2725 BA22			LAB_11C7
  2726 BA22 8A				TXA				; copy index
  2727 BA23 18				CLC				; clear carry for add
  2728 BA24 69 10			ADC	#$10			; add FOR stack use size
  2729 BA26 AA				TAX				; copy back to index
  2730 BA27 D0 D8			BNE	LAB_11A6		; loop if not at start of stack
  2731
  2732 BA29			LAB_11CE
  2733 BA29 60				RTS
  2734
  2735 				; perform NEXT
  2736 BA2A			LAB_NEXT
  2737 BA2A D0 04			BNE	LAB_1A46		; branch if NEXT var
  2738
  2739 BA2C A0 00			LDY	#$00			; else clear Y
  2740 BA2E F0 03			BEQ	LAB_1A49		; branch always (no variable to search for)
  2741
  2742 				; NEXT var
  2743 BA30			LAB_1A46
  2744 BA30 20 71 BD			JSR	LAB_GVAR		; get variable address
  2745 BA33			LAB_1A49
  2746 BA33 85 57			STA	Frnxtl			; store variable pointer low byte
  2747 BA35 84 58			STY	Frnxth			; store variable pointer high byte
  2748 									; (both cleared if no variable defined)
  2749 BA37 20 FC B9			JSR	LAB_11A1		; search the stack for FOR activity
  2750 BA3A F0 04			BEQ	LAB_1A56		; branch if found
  2751
  2752 BA3C A2 00			LDX	#$00			; else set error $00 ('NEXT without FOR' error)
  2753 BA3E			LAB_1A54
  2754 BA3E F0 63			BEQ	LAB_1ABE		; do error #X, then warm start
  2755
  2756 BA40			LAB_1A56
  2757 BA40 9A				TXS				; set stack pointer, X set by search, dumps return addresses
  2758
  2759 BA41 8A				TXA				; copy stack pointer
  2760 BA42 38				SEC				; set carry for subtract
  2761 BA43 E9 F7			SBC	#$F7			; point to TO var
  2762 BA45 85 33			STA	ut2_pl			; save pointer to TO var for compare
  2763 BA47 69 FB			ADC	#$FB			; point to STEP var
  2764
  2765 BA49 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2766 BA4B 20 52 C8			JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
  2767 BA4E BA				TSX				; get stack pointer back
  2768 BA4F BD 08 01			LDA	LAB_STAK+8,X		; get step sign
  2769 BA52 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  2770 BA54 A5 57			LDA	Frnxtl			; get FOR variable pointer low byte
  2771 BA56 A4 58			LDY	Frnxth			; get FOR variable pointer high byte
  2772 BA58 20 93 C5			JSR	LAB_246C		; add (FOR variable) to FAC1
  2773 BA5B 20 78 C8			JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2774 BA5E A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2775 BA60 20 EE C8			JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
  2776 BA63 BA				TSX				; get stack pointer back
  2777 BA64 DD 08 01			CMP	LAB_STAK+8,X		; compare step sign
  2778 BA67 F0 17			BEQ	LAB_1A9B		; branch if = (loop complete)
  2779
  2780 									; loop back and do it all again
  2781 BA69 BD 0D 01			LDA	LAB_STAK+$0D,X		; get FOR line low byte
  2782 BA6C 85 47			STA	Clinel			; save current line low byte
  2783 BA6E BD 0E 01			LDA	LAB_STAK+$0E,X		; get FOR line high byte
  2784 BA71 85 48			STA	Clineh			; save current line high byte
  2785 BA73 BD 10 01			LDA	LAB_STAK+$10,X		; get BASIC execute pointer low byte
  2786 BA76 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2787 BA78 BD 0F 01			LDA	LAB_STAK+$0F,X		; get BASIC execute pointer high byte
  2788 BA7B 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  2789 BA7D			LAB_1A98
  2790 BA7D 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  2791
  2792 									; loop complete so carry on
  2793 BA80			LAB_1A9B
  2794 BA80 8A				TXA				; stack copy to A
  2795 BA81 69 0F			ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
  2796 BA83 AA				TAX				; copy back to index
  2797 BA84 9A				TXS				; copy to stack pointer
  2798 BA85 20 82 00			JSR	LAB_GBYT		; scan memory
  2799 BA88 C9 2C			CMP	#','			; compare with ','
  2800 BA8A D0 F1			BNE	LAB_1A98		; branch if not ',' (go do interpreter inner loop)
  2801
  2802 									; was ',' so another NEXT variable to do
  2803 BA8C 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  2804 BA8F 20 30 BA			JSR	LAB_1A46		; do NEXT (var)
  2805
  2806 				; evaluate expression and check is numeric, else do type mismatch
  2807 BA92			LAB_EVNM
  2808 BA92 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  2809
  2810 				; check if source is numeric, else do type mismatch
  2811 BA95			LAB_CTNM
  2812 BA95 18				CLC				; destination is numeric
  2813 BA96 24				.byte	$24			; makes next line BIT $38
  2814
  2815 				; check if source is string, else do type mismatch
  2816 BA97			LAB_CTST
  2817 BA97 38				SEC				; required type is string
  2818
  2819 				; type match check, set C for string, clear C for numeric
  2820 BA98			LAB_CKTM
  2821 BA98 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2822 BA9A 30 03			BMI	LAB_1ABA		; branch if data type is string
  2823
  2824 									; else data type was numeric
  2825 BA9C B0 03			BCS	LAB_1ABC		; if required type is string do type mismatch error
  2826 BA9E			LAB_1AB9
  2827 BA9E 60				RTS
  2828
  2829 									; data type was string, now check required type
  2830 BA9F			LAB_1ABA
  2831 BA9F B0 FD			BCS	LAB_1AB9		; exit if required type is string
  2832
  2833 									; else do type mismatch error
  2834 BAA1			LAB_1ABC
  2835 BAA1 A2 18			LDX	#$18			; error code $18 ('Type mismatch' error)
  2836 BAA3			LAB_1ABE
  2837 BAA3 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  2838
  2839 				; evaluate expression
  2840 BAA6			LAB_EVEX
  2841 BAA6 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2842 BAA8 D0 02			BNE	LAB_1AC7		; skip next if not zero
  2843
  2844 BAAA C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2845 BAAC			LAB_1AC7
  2846 BAAC C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2847
  2848 BAAE			LAB_EVEZ
  2849 BAAE A9 00			LDA	#$00			; set null precedence (flag done)
  2850 BAB0			LAB_1ACC
  2851 BAB0 48				PHA				; push precedence byte
  2852 BAB1 A9 02			LDA	#$02			; 2 bytes
  2853 BAB3 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  2854 BAB6 20 92 BB			JSR	LAB_GVAL		; get value from line
  2855 BAB9 A9 00			LDA	#$00			; clear A
  2856 BABB 85 5B			STA	comp_f			; clear compare function flag
  2857 BABD			LAB_1ADB
  2858 BABD 20 82 00			JSR	LAB_GBYT		; scan memory
  2859 BAC0			LAB_1ADE
  2860 BAC0 38				SEC				; set carry for subtract
  2861 BAC1 E9 D6			SBC	#TK_GT			; subtract token for > (lowest comparison function)
  2862 BAC3 90 17			BCC	LAB_1AFA		; branch if < TK_GT
  2863
  2864 BAC5 C9 03			CMP	#$03			; compare with '>' to '<' tokens
  2865 BAC7 B0 13			BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2866
  2867 									; was token for > = or < (A = 0, 1 or 2)
  2868 BAC9 C9 01			CMP	#$01			; compare with token for =
  2869 BACB 2A				ROL				; *2, b0 = carry (=1 if token was = or <)
  2870 									; (A = 0, 3 or 5)
  2871 BACC 49 01			EOR	#$01			; toggle b0
  2872 									; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2873 BACE 45 5B			EOR	comp_f			; EOR with compare function flag bits
  2874 BAD0 C5 5B			CMP	comp_f			; compare with compare function flag
  2875 BAD2 90 67			BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
  2876 									; was more than one <, = or >)
  2877
  2878 BAD4 85 5B			STA	comp_f			; save new compare function flag
  2879 BAD6 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2880 BAD9 4C C0 BA			JMP	LAB_1ADE		; go do next character
  2881
  2882 									; token is < '>' or > '<' tokens
  2883 BADC			LAB_1AFA
  2884 BADC A6 5B			LDX	comp_f			; get compare function flag
  2885 BADE D0 2C			BNE	LAB_1B2A		; branch if compare function
  2886
  2887 BAE0 B0 79			BCS	LAB_1B78		; go do functions
  2888
  2889 									; else was <  TK_GT so is operator or lower
  2890 BAE2 69 0B			ADC	#TK_GT-TK_PLUS		; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2891 BAE4 90 75			BCC	LAB_1B78		; branch if < + operator
  2892
  2893 									; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2894 BAE6 D0 07			BNE	LAB_1B0B		; branch if not + token
  2895
  2896 BAE8 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2897 BAEA 10 03			BPL	LAB_1B0B		; branch if not string
  2898
  2899 									; will only be $00 if type is string and token was +
  2900 BAEC 4C A9 C2			JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
  2901 									; is in line, and return
  2902
  2903 BAEF			LAB_1B0B
  2904 BAEF 85 31			STA	ut1_pl			; save it
  2905 BAF1 0A				ASL				; *2
  2906 BAF2 65 31			ADC	ut1_pl			; *3
  2907 BAF4 A8				TAY				; copy to index
  2908 BAF5			LAB_1B13
  2909 BAF5 68				PLA				; pull previous precedence
  2910 BAF6 D9 2A D5			CMP	LAB_OPPT,Y		; compare with precedence byte
  2911 BAF9 B0 65			BCS	LAB_1B7D		; branch if A >=
  2912
  2913 BAFB 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2914 BAFE			LAB_1B1C
  2915 BAFE 48				PHA				; save precedence
  2916 BAFF			LAB_1B1D
  2917 BAFF 20 27 BB			JSR	LAB_1B43		; get vector, execute function then continue evaluation
  2918 BB02 68				PLA				; restore precedence
  2919 BB03 A4 59			LDY	prstk			; get precedence stacked flag
  2920 BB05 10 19			BPL	LAB_1B3C		; branch if stacked values
  2921
  2922 BB07 AA				TAX				; copy precedence (set flags)
  2923 BB08 F0 76			BEQ	LAB_1B9D		; exit if done
  2924
  2925 BB0A D0 5D			BNE	LAB_1B86		; else pop FAC2 and return, branch always
  2926
  2927 BB0C			LAB_1B2A
  2928 BB0C 26 1F			ROL	Dtypef			; shift data type flag into Cb
  2929 BB0E 8A				TXA				; copy compare function flag
  2930 BB0F 85 1F			STA	Dtypef			; clear data type flag, X is 0xxx xxxx
  2931 BB11 2A				ROL				; shift data type into compare function byte b0
  2932 BB12 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2933 BB14 D0 02			BNE	LAB_1B34		; branch if no underflow
  2934
  2935 BB16 C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2936 BB18			LAB_1B34
  2937 BB18 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2938 = 000D			TK_LT_PLUS	= TK_LT-TK_PLUS
  2939 BB1A A0 27			LDY	#TK_LT_PLUS*3		; set offset to last operator entry
  2940 BB1C 85 5B			STA	comp_f			; save new compare function flag
  2941 BB1E D0 D5			BNE	LAB_1B13		; branch always
  2942
  2943 BB20			LAB_1B3C
  2944 BB20 D9 2A D5			CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  2945 BB23 B0 44			BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  2946
  2947 BB25 90 D7			BCC	LAB_1B1C		; branch always
  2948
  2949 				;.get vector, execute function then continue evaluation
  2950 BB27			LAB_1B43
  2951 BB27 B9 2C D5			LDA	LAB_OPPT+2,Y		; get function vector high byte
  2952 BB2A 48				PHA				; onto stack
  2953 BB2B B9 2B D5			LDA	LAB_OPPT+1,Y		; get function vector low byte
  2954 BB2E 48				PHA				; onto stack
  2955 									; now push sign, round FAC1 and put on stack
  2956 BB2F 20 3E BB			JSR	LAB_1B5B		; function will return here, then the next RTS will call
  2957 									; the function
  2958 BB32 A5 5B			LDA	comp_f			; get compare function flag
  2959 BB34 48				PHA				; push compare evaluation byte
  2960 BB35 B9 2A D5			LDA	LAB_OPPT,Y		; get precedence byte
  2961 BB38 4C B0 BA			JMP	LAB_1ACC		; continue evaluating expression
  2962
  2963 BB3B			LAB_1B53
  2964 BB3B 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  2965
  2966 				; push sign, round FAC1 and put on stack
  2967 BB3E			LAB_1B5B
  2968 BB3E 68				PLA				; get return addr low byte
  2969 BB3F 85 31			STA	ut1_pl			; save it
  2970 BB41 E6 31			INC	ut1_pl			; increment it (was ret-1 pushed? yes!)
  2971 									; note! no check is made on the high byte! if the calling
  2972 									; routine assembles to a page edge then this all goes
  2973 									; horribly wrong !!!
  2974 BB43 68				PLA				; get return addr high byte
  2975 BB44 85 32			STA	ut1_ph			; save it
  2976 BB46 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  2977 BB48 48				PHA				; push sign
  2978
  2979 				; round FAC1 and put on stack
  2980 BB49			LAB_1B66
  2981 BB49 20 AE C8			JSR	LAB_27BA		; round FAC1
  2982 BB4C A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  2983 BB4E 48				PHA				; push on stack
  2984 BB4F A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  2985 BB51 48				PHA				; push on stack
  2986 BB52 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  2987 BB54 48				PHA				; push on stack
  2988 BB55 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  2989 BB57 48				PHA				; push on stack
  2990 BB58 6C 31 00			JMP	(ut1_pl)		; return, sort of
  2991
  2992 				; do functions
  2993 BB5B			LAB_1B78
  2994 BB5B A0 FF			LDY	#$FF			; flag function
  2995 BB5D 68				PLA				; pull precedence byte
  2996 BB5E			LAB_1B7B
  2997 BB5E F0 20			BEQ	LAB_1B9D		; exit if done
  2998
  2999 BB60			LAB_1B7D
  3000 BB60 C9 64			CMP	#$64			; compare previous precedence with $64
  3001 BB62 F0 03			BEQ	LAB_1B84		; branch if was $64 (< function)
  3002
  3003 BB64 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3004 BB67			LAB_1B84
  3005 BB67 84 59			STY	prstk			; save precedence stacked flag
  3006
  3007 									; pop FAC2 and return
  3008 BB69			LAB_1B86
  3009 BB69 68				PLA				; pop byte
  3010 BB6A 4A				LSR				; shift out comparison evaluation lowest bit
  3011 BB6B 85 23			STA	Cflag			; save comparison evaluation flag
  3012 BB6D 68				PLA				; pop exponent
  3013 BB6E 85 73			STA	FAC2_e			; save FAC2 exponent
  3014 BB70 68				PLA				; pop mantissa1
  3015 BB71 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3016 BB73 68				PLA				; pop mantissa2
  3017 BB74 85 75			STA	FAC2_2			; save FAC2 mantissa2
  3018 BB76 68				PLA				; pop mantissa3
  3019 BB77 85 76			STA	FAC2_3			; save FAC2 mantissa3
  3020 BB79 68				PLA				; pop sign
  3021 BB7A 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  3022 BB7C 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  3023 BB7E 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  3024 BB80			LAB_1B9D
  3025 BB80 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3026 BB82 60				RTS
  3027
  3028 				; print '...' string to string util area
  3029 BB83			LAB_1BC1
  3030 BB83 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  3031 BB85 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  3032 BB87 69 00			ADC	#$00			; add carry to low byte
  3033 BB89 90 01			BCC	LAB_1BCA		; branch if no overflow
  3034
  3035 BB8B C8				INY				; increment high byte
  3036 BB8C			LAB_1BCA
  3037 BB8C 20 17 C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  3038 BB8F 4C A4 C4			JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  3039
  3040 				; get value from line
  3041 BB92			LAB_GVAL
  3042 BB92 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3043 BB95 B0 03			BCS	LAB_1BAC		; branch if not numeric character
  3044
  3045 									; else numeric string found (e.g. 123)
  3046 BB97			LAB_1BA9
  3047 BB97 4C 7B C9			JMP	LAB_2887		; get FAC1 from string and return
  3048
  3049 				; get value from line .. continued
  3050 									; wasn't a number so ..
  3051 BB9A			LAB_1BAC
  3052 BB9A AA				TAX				; set the flags
  3053 BB9B 30 2F			BMI	LAB_1BD0		; if -ve go test token values
  3054
  3055 									; else it is either a string, number, variable or (<expr>)
  3056 BB9D C9 24			CMP	#'$'			; compare with '$'
  3057 BB9F F0 F6			BEQ	LAB_1BA9		; branch if '$', hex number
  3058
  3059 BBA1 C9 25			CMP	#'%'			; else compare with '%'
  3060 BBA3 F0 F2			BEQ	LAB_1BA9		; branch if '%', binary number
  3061
  3062 BBA5 C9 2E			CMP	#'.'			; compare with '.'
  3063 BBA7 F0 EE			BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  3064
  3065 									; it wasn't any sort of number so ..
  3066 BBA9 C9 22			CMP	#$22			; compare with '
  3067 BBAB F0 D6			BEQ	LAB_1BC1		; branch if open quote
  3068
  3069 									; wasn't any sort of number so ..
  3070
  3071 				; evaluate expression within parentheses
  3072 BBAD C9 28			CMP	#'('			; compare with '('
  3073 BBAF D0 4F			BNE	LAB_1C18		; if not '(' get (var), return value in FAC1 and $ flag
  3074
  3075 BBB1			LAB_1BF7
  3076 BBB1 20 AE BA			JSR	LAB_EVEZ		; evaluate expression, no decrement
  3077
  3078 				; all the 'scan for' routines return the character after the sought character
  3079
  3080 				; scan for ')' , else do syntax error then warm start
  3081 BBB4			LAB_1BFB
  3082 BBB4 A9 29			LDA	#$29			; load A with ')'
  3083
  3084 				; scan for CHR$(A) , else do syntax error then warm start
  3085 BBB6			LAB_SCCA
  3086 BBB6 A0 00			LDY	#$00			; clear index
  3087 BBB8 D1 83			CMP	(Bpntrl),Y		; check next byte is = A
  3088 BBBA D0 0B			BNE	LAB_SNER		; if not do syntax error then warm start
  3089
  3090 BBBC 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then return
  3091
  3092 				; scan for '(' , else do syntax error then warm start
  3093 BBBF			LAB_1BFE
  3094 BBBF A9 28			LDA	#$28			; load A with '('
  3095 BBC1 D0 F3			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3096 									; (branch always)
  3097
  3098 				; scan for ',' , else do syntax error then warm start
  3099 BBC3			LAB_1C01
  3100 BBC3 A9 2C			LDA	#$2C			; load A with ','
  3101 BBC5 D0 EF			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3102 									; (branch always)
  3103
  3104 				; syntax error then warm start
  3105 BBC7			LAB_SNER
  3106 BBC7 A2 02			LDX	#$02			; error code $02 ('Syntax' error)
  3107 BBC9 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3108
  3109 				; get value from line .. continued
  3110 				; do tokens
  3111 BBCC			LAB_1BD0
  3112 BBCC C9 CC			CMP	#TK_MINUS		; compare with token for -
  3113 BBCE F0 29			BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  3114
  3115 									; wasn't -n so ..
  3116 BBD0 C9 CB			CMP	#TK_PLUS		; compare with token for +
  3117 BBD2 F0 BE			BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  3118
  3119 BBD4 C9 C6			CMP	#TK_NOT		; compare with token for NOT
  3120 BBD6 D0 13			BNE	LAB_1BE7		; branch if not token for NOT
  3121
  3122 									; was NOT token
  3123 = 000C			TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
  3124 BBD8 A0 24			LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  3125 BBDA D0 1F			BNE	LAB_1C13		; do set-up for function then execute (branch always)
  3126
  3127 				; do = compare
  3128 BBDC			LAB_EQUAL
  3129 BBDC 20 6D BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3130 BBDF A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3131 BBE1 49 FF			EOR	#$FF			; invert it
  3132 BBE3 A8				TAY				; copy it
  3133 BBE4 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3134 BBE6 49 FF			EOR	#$FF			; invert it
  3135 BBE8 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3136
  3137 				; get value from line .. continued
  3138 									; wasn't +, -, or NOT so ..
  3139 BBEB			LAB_1BE7
  3140 BBEB C9 C3			CMP	#TK_FN			; compare with token for FN
  3141 BBED D0 03			BNE	LAB_1BEE		; branch if not token for FN
  3142
  3143 BBEF 4C 87 C0			JMP	LAB_201E		; go evaluate FNx
  3144
  3145 				; get value from line .. continued
  3146 									; wasn't +, -, NOT or FN so ..
  3147 BBF2			LAB_1BEE
  3148 BBF2 E9 D9			SBC	#TK_SGN			; subtract with token for SGN
  3149 BBF4 B0 1B			BCS	LAB_1C27		; if a function token go do it
  3150
  3151 BBF6 4C C7 BB			JMP	LAB_SNER		; else do syntax error
  3152
  3153 				; set-up for functions
  3154 BBF9			LAB_1C11
  3155 = 000B			TK_GT_PLUS	= TK_GT-TK_PLUS
  3156 BBF9 A0 21			LDY	#TK_GT_PLUS*3		; set offset from base to > operator
  3157 BBFB			LAB_1C13
  3158 BBFB 68				PLA				; dump return address low byte
  3159 BBFC 68				PLA				; dump return address high byte
  3160 BBFD 4C FF BA			JMP	LAB_1B1D		; execute function then continue evaluation
  3161
  3162 				; variable name set-up
  3163 				; get (var), return value in FAC_1 and $ flag
  3164 BC00			LAB_1C18
  3165 BC00 20 71 BD			JSR	LAB_GVAR		; get (var) address
  3166 BC03 85 6E			STA	FAC1_2			; save address low byte in FAC1 mantissa2
  3167 BC05 84 6F			STY	FAC1_3			; save address high byte in FAC1 mantissa3
  3168 BC07 A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  3169 BC09 30 03			BMI	LAB_1C25		; if string then return (does RTS)
  3170
  3171 BC0B			LAB_1C24
  3172 BC0B 4C 52 C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  3173
  3174 BC0E			LAB_1C25	; patch string pointer high byte trashed when moved to stack
  3175 BC0E 46 79			LSR   	FAC1_r            	; clear bit 7 (<$80) = do not round up
  3176 BC10 60				RTS
  3177
  3178 				; get value from line .. continued
  3179 				; only functions left so ..
  3180
  3181 				; set up function references
  3182
  3183 				; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3184 				; to process function calls. now the function vector is computed and pushed on the stack
  3185 				; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3186 				; is calculated and the routine called, if not this routine just does RTS. whichever
  3187 				; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3188 				; the function code
  3189
  3190 				; this also removes some less than elegant code that was used to bypass type checking
  3191 				; for functions that returned strings
  3192 BC11			LAB_1C27
  3193 BC11 0A				ASL				; *2 (2 bytes per function address)
  3194 BC12 A8				TAY				; copy to index
  3195
  3196 BC13 B9 DD D4			LDA	LAB_FTBM,Y		; get function jump vector high byte
  3197 BC16 48				PHA				; push functions jump vector high byte
  3198 BC17 B9 DC D4			LDA	LAB_FTBL,Y		; get function jump vector low byte
  3199 BC1A 48				PHA				; push functions jump vector low byte
  3200
  3201 BC1B B9 8F D4			LDA	LAB_FTPM,Y		; get function pre process vector high byte
  3202 BC1E F0 05			BEQ	LAB_1C56		; skip pre process if null vector
  3203
  3204 BC20 48				PHA				; push functions pre process vector high byte
  3205 BC21 B9 8E D4			LDA	LAB_FTPL,Y		; get function pre process vector low byte
  3206 BC24 48				PHA				; push functions pre process vector low byte
  3207
  3208 BC25			LAB_1C56
  3209 BC25 60				RTS				; do function, or pre process, call
  3210
  3211 				; process string expression in parenthesis
  3212 BC26			LAB_PPFS
  3213 BC26 20 B1 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3214 BC29 4C 97 BA			JMP	LAB_CTST		; check if source is string then do function,
  3215 									; else do type mismatch
  3216
  3217 				; process numeric expression in parenthesis
  3218 BC2C			LAB_PPFN
  3219 BC2C 20 B1 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3220 BC2F 4C 95 BA			JMP	LAB_CTNM		; check if source is numeric then do function,
  3221 									; else do type mismatch
  3222
  3223 				; set numeric data type and increment BASIC execute pointer
  3224 BC32			LAB_PPBI
  3225 BC32 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3226 BC34 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then do function
  3227
  3228 				; process string for LEFT$, RIGHT$ or MID$
  3229 BC37			LAB_LRMS
  3230 BC37 20 AE BA			JSR	LAB_EVEZ		; evaluate (should be string) expression
  3231 BC3A 20 C3 BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3232 BC3D 20 97 BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  3233
  3234 BC40 68				PLA				; get function jump vector low byte
  3235 BC41 AA				TAX				; save functions jump vector low byte
  3236 BC42 68				PLA				; get function jump vector high byte
  3237 BC43 A8				TAY				; save functions jump vector high byte
  3238 BC44 A5 6F			LDA	des_ph			; get descriptor pointer high byte
  3239 BC46 48				PHA				; push string pointer high byte
  3240 BC47 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  3241 BC49 48				PHA				; push string pointer low byte
  3242 BC4A 98				TYA				; get function jump vector high byte back
  3243 BC4B 48				PHA				; save functions jump vector high byte
  3244 BC4C 8A				TXA				; get function jump vector low byte back
  3245 BC4D 48				PHA				; save functions jump vector low byte
  3246 BC4E 20 61 C4			JSR	LAB_GTBY		; get byte parameter
  3247 BC51 8A				TXA				; copy byte parameter to A
  3248 BC52 60				RTS				; go do function
  3249
  3250 				; process numeric expression(s) for BIN$ or HEX$
  3251 BC53			LAB_BHSS
  3252 BC53 20 AE BA			JSR	LAB_EVEZ		; process expression
  3253 BC56 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3254 BC59 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3255 BC5B C9 98			CMP	#$98			; compare with exponent = 2^24
  3256 BC5D B0 20			BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  3257
  3258 BC5F 20 25 C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  3259 BC62 A2 02			LDX	#$02			; 3 bytes to do
  3260 BC64			LAB_CFAC
  3261 BC64 B5 6D			LDA	FAC1_1,X		; get byte from FAC1
  3262 BC66 95 11			STA	nums_1,X		; save byte to temp
  3263 BC68 CA				DEX				; decrement index
  3264 BC69 10 F9			BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  3265
  3266 BC6B 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  3267 BC6E A2 00			LDX	#$00			; set default to no leading '0's
  3268 BC70 C9 29			CMP	#')'			; compare with close bracket
  3269 BC72 F0 0A			BEQ	LAB_1C54		; if ')' go do rest of function
  3270
  3271 BC74 20 B3 C4			JSR	LAB_SCGB		; scan for ',' and get byte
  3272 BC77 20 82 00			JSR	LAB_GBYT		; get last byte back
  3273 BC7A C9 29			CMP	#')'			; is next character )
  3274 BC7C D0 01			BNE	LAB_BHER		; if not ')' go do error
  3275
  3276 BC7E			LAB_1C54
  3277 BC7E 60				RTS				; else do function
  3278
  3279 BC7F			LAB_BHER
  3280 BC7F 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start
  3281
  3282 				; perform EOR
  3283
  3284 				; added operator format is the same as AND or OR, precedence is the same as OR
  3285
  3286 				; this bit worked first time but it took a while to sort out the operator table
  3287 				; pointers and offsets afterwards!
  3288 BC82			LAB_EOR
  3289 BC82 20 A9 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3290 BC85 45 1B			EOR	XOAw_l			; EOR with expression 1 low byte
  3291 BC87 A8				TAY				; save in Y
  3292 BC88 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3293 BC8A 45 1C			EOR	XOAw_h			; EOR with expression 1 high byte
  3294 BC8C 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3295
  3296 				; perform OR
  3297 BC8F			LAB_OR
  3298 BC8F 20 A9 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3299 BC92 05 1B			ORA	XOAw_l			; OR with expression 1 low byte
  3300 BC94 A8				TAY				; save in Y
  3301 BC95 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3302 BC97 05 1C			ORA	XOAw_h			; OR with expression 1 high byte
  3303 BC99 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3304
  3305 				; perform AND
  3306 BC9C			LAB_AND
  3307 BC9C 20 A9 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3308 BC9F 25 1B			AND	XOAw_l			; AND with expression 1 low byte
  3309 BCA1 A8				TAY				; save in Y
  3310 BCA2 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3311 BCA4 25 1C			AND	XOAw_h			; AND with expression 1 high byte
  3312 BCA6 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3313
  3314 				; get first value for OR, AND or EOR
  3315 BCA9			GetFirst
  3316 BCA9 20 6D BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3317 BCAC A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3318 BCAE 85 1C			STA	XOAw_h			; save it
  3319 BCB0 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3320 BCB2 85 1B			STA	XOAw_l			; save it
  3321 BCB4 20 98 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3322 BCB7 20 6D BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3323 BCBA A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3324 BCBC			LAB_1C95
  3325 BCBC 60				RTS
  3326
  3327 				; perform comparisons
  3328
  3329 				; do < compare
  3330 BCBD			LAB_LTHAN
  3331 BCBD 20 98 BA			JSR	LAB_CKTM		; type match check, set C for string
  3332 BCC0 B0 13			BCS	LAB_1CAE		; branch if string
  3333 									; do numeric < compare
  3334 BCC2 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  3335 BCC4 09 7F			ORA	#$7F			; set all non sign bits
  3336 BCC6 25 74			AND	FAC2_1			; and FAC2 mantissa1 (AND in sign bit)
  3337 BCC8 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3338 BCCA A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  3339 BCCC A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  3340 BCCE 20 EC C8			JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3341 BCD1 AA				TAX				; copy result
  3342 BCD2 4C 06 BD			JMP	LAB_1CE1		; go evaluate result
  3343 									; do string < compare
  3344 BCD5			LAB_1CAE
  3345 BCD5 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3346 BCD7 C6 5B			DEC	comp_f			; clear < bit in compare function flag
  3347 BCD9 20 13 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3348 									; space returns with A = length, X=pointer low byte,
  3349 									; Y=pointer high byte
  3350 BCDC 85 6C			STA	str_ln			; save length
  3351 BCDE 86 6D			STX	str_pl			; save string pointer low byte
  3352 BCE0 84 6E			STY	str_ph			; save string pointer high byte
  3353 BCE2 A5 75			LDA	FAC2_2			; get descriptor pointer low byte
  3354 BCE4 A4 76			LDY	FAC2_3			; get descriptor pointer high byte
  3355 BCE6 20 17 C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3356 									; returns with A = length, X=pointer low byte,
  3357 									; Y=pointer high byte
  3358 BCE9 86 75			STX	FAC2_2			; save string pointer low byte
  3359 BCEB 84 76			STY	FAC2_3			; save string pointer high byte
  3360 BCED AA				TAX				; copy length
  3361 BCEE 38				SEC				; set carry for subtract
  3362 BCEF E5 6C			SBC	str_ln			; subtract string 1 length
  3363 BCF1 F0 08			BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3364
  3365 BCF3 A9 01			LDA	#$01			; set str 1 length > string 2 length
  3366 BCF5 90 04			BCC	LAB_1CD6		; branch if so
  3367
  3368 BCF7 A6 6C			LDX	str_ln			; get string 1 length
  3369 BCF9 A9 FF			LDA	#$FF			; set str 1 length < string 2 length
  3370 BCFB			LAB_1CD6
  3371 BCFB 85 70			STA	FAC1_s			; save length compare
  3372 BCFD A0 FF			LDY	#$FF			; set index
  3373 BCFF E8				INX				; adjust for loop
  3374 BD00			LAB_1CDB
  3375 BD00 C8				INY				; increment index
  3376 BD01 CA				DEX				; decrement count
  3377 BD02 D0 07			BNE	LAB_1CE6		; branch if still bytes to do
  3378
  3379 BD04 A6 70			LDX	FAC1_s			; get length compare back
  3380 BD06			LAB_1CE1
  3381 BD06 30 0F			BMI	LAB_1CF2		; branch if str 1 < str 2
  3382
  3383 BD08 18				CLC				; flag str 1 <= str 2
  3384 BD09 90 0C			BCC	LAB_1CF2		; go evaluate result
  3385
  3386 BD0B			LAB_1CE6
  3387 BD0B B1 75			LDA	(FAC2_2),Y		; get string 2 byte
  3388 BD0D D1 6D			CMP	(FAC1_1),Y		; compare with string 1 byte
  3389 BD0F F0 EF			BEQ	LAB_1CDB		; loop if bytes =
  3390
  3391 BD11 A2 FF			LDX	#$FF			; set str 1 < string 2
  3392 BD13 B0 02			BCS	LAB_1CF2		; branch if so
  3393
  3394 BD15 A2 01			LDX	#$01			;  set str 1 > string 2
  3395 BD17			LAB_1CF2
  3396 BD17 E8				INX				; x = 0, 1 or 2
  3397 BD18 8A				TXA				; copy to A
  3398 BD19 2A				ROL				; *2 (1, 2 or 4)
  3399 BD1A 25 23			AND	Cflag			; AND with comparison evaluation flag
  3400 BD1C F0 02			BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3401
  3402 BD1E A9 FF			LDA	#$FF			; else set result true
  3403 BD20			LAB_1CFB
  3404 BD20 4C CF C8			JMP	LAB_27DB		; save A as integer byte and return
  3405
  3406 BD23			LAB_1CFE
  3407 BD23 20 C3 BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3408
  3409 				; perform DIM
  3410 BD26			LAB_DIM
  3411 BD26 AA				TAX				; copy 'DIM' flag to X
  3412 BD27 20 76 BD			JSR	LAB_1D10		; search for variable
  3413 BD2A 20 82 00			JSR	LAB_GBYT		; scan memory
  3414 BD2D D0 F4			BNE	LAB_1CFE		; scan for ',' and loop if not null
  3415
  3416 BD2F 60				RTS
  3417
  3418 				; perform << (left shift)
  3419 BD30			LAB_LSHIFT
  3420 BD30 20 66 BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3421 BD33 A5 6E			LDA	FAC1_2			; get expression high byte
  3422 BD35 A6 38			LDX	TempB			; get shift count
  3423 BD37 F0 22			BEQ	NoShift			; branch if zero
  3424
  3425 BD39 E0 10			CPX	#$10			; compare bit count with 16d
  3426 BD3B B0 23			BCS	TooBig			; branch if >=
  3427
  3428 BD3D			Ls_loop
  3429 BD3D 06 6F			ASL	FAC1_3			; shift low byte
  3430 BD3F 2A				ROL				; shift high byte
  3431 BD40 CA				DEX				; decrement bit count
  3432 BD41 D0 FA			BNE	Ls_loop			; loop if shift not complete
  3433
  3434 BD43 A4 6F			LDY	FAC1_3			; get expression low byte
  3435 BD45 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3436
  3437 				; perform >> (right shift)
  3438 BD48			LAB_RSHIFT
  3439 BD48 20 66 BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3440 BD4B A5 6E			LDA	FAC1_2			; get expression high byte
  3441 BD4D A6 38			LDX	TempB			; get shift count
  3442 BD4F F0 0A			BEQ	NoShift			; branch if zero
  3443
  3444 BD51 E0 10			CPX	#$10			; compare bit count with 16d
  3445 BD53 B0 0B			BCS	TooBig			; branch if >=
  3446
  3447 BD55			Rs_loop
  3448 BD55 4A				LSR				; shift high byte
  3449 BD56 66 6F			ROR	FAC1_3			; shift low byte
  3450 BD58 CA				DEX				; decrement bit count
  3451 BD59 D0 FA			BNE	Rs_loop			; loop if shift not complete
  3452
  3453 BD5B			NoShift
  3454 BD5B A4 6F			LDY	FAC1_3			; get expression low byte
  3455 BD5D 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3456
  3457 BD60			TooBig
  3458 BD60 A9 00			LDA	#$00			; clear high byte
  3459 BD62 A8				TAY				; copy to low byte
  3460 BD63 4C 2C C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3461
  3462 BD66			GetPair
  3463 BD66 20 64 C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  3464 BD69 86 38			STX	TempB			; save it
  3465 BD6B 20 98 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3466 BD6E 4C 6D BE			JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3467
  3468 				; search for variable
  3469
  3470 				; return pointer to variable in Cvaral/Cvarah
  3471 BD71			LAB_GVAR
  3472 BD71 A2 00			LDX	#$00			; set DIM flag = $00
  3473 BD73 20 82 00			JSR	LAB_GBYT		; scan memory (1st character)
  3474 BD76			LAB_1D10
  3475 BD76 86 1E			STX	Defdim			; save DIM flag
  3476 BD78			LAB_1D12
  3477 BD78 85 53			STA	Varnm1			; save 1st character
  3478 BD7A 29 7F			AND	#$7F			; clear FN flag bit
  3479 BD7C 20 E5 BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3480 BD7F B0 03			BCS	LAB_1D1F		; branch if ok
  3481
  3482 BD81 4C C7 BB			JMP	LAB_SNER		; else syntax error then warm start
  3483
  3484 									; was variable name so ..
  3485 BD84			LAB_1D1F
  3486 BD84 A2 00			LDX	#$00			; clear 2nd character temp
  3487 BD86 86 1F			STX	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3488 BD88 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (2nd character)
  3489 BD8B 90 05			BCC	LAB_1D2D		; branch if character = '0'-'9' (ok)
  3490
  3491 									; 2nd character wasn't '0' to '9' so ..
  3492 BD8D 20 E5 BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3493 BD90 90 0B			BCC	LAB_1D38		; branch if <'A' or >'Z' (go check if string)
  3494
  3495 BD92			LAB_1D2D
  3496 BD92 AA				TAX				; copy 2nd character
  3497
  3498 									; ignore further (valid) characters in the variable name
  3499 BD93			LAB_1D2E
  3500 BD93 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (3rd character)
  3501 BD96 90 FB			BCC	LAB_1D2E		; loop if character = '0'-'9' (ignore)
  3502
  3503 BD98 20 E5 BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3504 BD9B B0 F6			BCS	LAB_1D2E		; loop if character = 'A'-'Z' (ignore)
  3505
  3506 									; check if string variable
  3507 BD9D			LAB_1D38
  3508 BD9D C9 24			CMP	#'$'			; compare with '$'
  3509 BD9F D0 0B			BNE	LAB_1D47		; branch if not string
  3510
  3511 				; to introduce a new variable type (% suffix for integers say) then this branch
  3512 				; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3513 									; type is string
  3514 BDA1 A9 FF			LDA	#$FF			; set data type = string
  3515 BDA3 85 1F			STA	Dtypef			; set data type flag, $FF=string, $00=numeric
  3516 BDA5 8A				TXA				; get 2nd character back
  3517 BDA6 09 80			ORA	#$80			; set top bit (indicate string var)
  3518 BDA8 AA				TAX				; copy back to 2nd character temp
  3519 BDA9 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3520
  3521 				; after we have determined the variable type we need to come back here to determine
  3522 				; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3523 BDAC			LAB_1D47				; gets here with character after var name in A
  3524 BDAC 86 54			STX	Varnm2			; save 2nd character
  3525 BDAE 05 21			ORA	Sufnxf			; or with subscript/FNX flag (or FN name)
  3526 BDB0 C9 28			CMP	#'('			; compare with '('
  3527 BDB2 D0 03			BNE	LAB_1D53		; branch if not '('
  3528
  3529 BDB4 4C 7F BE			JMP	LAB_1E17		; go find, or make, array
  3530
  3531 				; either find or create var
  3532 				; var name (1st two characters only!) is in Varnm1,Varnm2
  3533 									; variable name wasn't var(... so look for plain var
  3534 BDB7			LAB_1D53
  3535 BDB7 A9 00			LDA	#$00			; clear A
  3536 BDB9 85 21			STA	Sufnxf			; clear subscript/FNX flag
  3537 BDBB A5 3B			LDA	Svarl			; get start of vars low byte
  3538 BDBD A6 3C			LDX	Svarh			; get start of vars high byte
  3539 BDBF A0 00			LDY	#$00			; clear index
  3540 BDC1			LAB_1D5D
  3541 BDC1 86 6B			STX	Vrschh			; save search address high byte
  3542 BDC3			LAB_1D5F
  3543 BDC3 85 6A			STA	Vrschl			; save search address low byte
  3544 BDC5 E4 3E			CPX	Sarryh			; compare high address with var space end
  3545 BDC7 D0 04			BNE	LAB_1D69		; skip next compare if <>
  3546
  3547 									; high addresses were = so compare low addresses
  3548 BDC9 C5 3D			CMP	Sarryl			; compare low address with var space end
  3549 BDCB F0 2C			BEQ	LAB_1D8B		; if not found go make new var
  3550
  3551 BDCD			LAB_1D69
  3552 BDCD A5 53			LDA	Varnm1			; get 1st character of var to find
  3553 BDCF D1 6A			CMP	(Vrschl),Y		; compare with variable name 1st character
  3554 BDD1 D0 08			BNE	LAB_1D77		; branch if no match
  3555
  3556 									; 1st characters match so compare 2nd characters
  3557 BDD3 A5 54			LDA	Varnm2			; get 2nd character of var to find
  3558 BDD5 C8				INY				; index to point to variable name 2nd character
  3559 BDD6 D1 6A			CMP	(Vrschl),Y		; compare with variable name 2nd character
  3560 BDD8 F0 69			BEQ	LAB_1DD7		; branch if match (found var)
  3561
  3562 BDDA 88				DEY				; else decrement index (now = $00)
  3563 BDDB			LAB_1D77
  3564 BDDB 18				CLC				; clear carry for add
  3565 BDDC A5 6A			LDA	Vrschl			; get search address low byte
  3566 BDDE 69 06			ADC	#$06			; +6 (offset to next var name)
  3567 BDE0 90 E1			BCC	LAB_1D5F		; loop if no overflow to high byte
  3568
  3569 BDE2 E8				INX				; else increment high byte
  3570 BDE3 D0 DC			BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3571
  3572 				; check byte, return C=0 if<'A' or >'Z' or 'a' to 'z'
  3573 BDE5			LAB_CASC
  3574 BDE5 C9 61			CMP	#'a'			; compare with 'a'
  3575 BDE7 B0 0A			BCS	LAB_1D83		; go check <'z'+1
  3576
  3577 				; check byte, return C=0 if<'A' or >'Z'
  3578 BDE9			LAB_1D82
  3579 BDE9 C9 41			CMP	#'A'			; compare with 'A'
  3580 BDEB 90 05			BCC	LAB_1D8A		; exit if less
  3581
  3582 									; carry is set
  3583 BDED E9 5B			SBC	#$5B			; subtract 'Z'+1
  3584 BDEF 38				SEC				; set carry
  3585 BDF0 E9 A5			SBC	#$A5			; subtract $A5 (restore byte)
  3586 									; carry clear if byte>$5A
  3587 BDF2			LAB_1D8A
  3588 BDF2 60				RTS
  3589
  3590 BDF3			LAB_1D83
  3591 BDF3 E9 7B			SBC	#$7B			; subtract 'z'+1
  3592 BDF5 38				SEC				; set carry
  3593 BDF6 E9 85			SBC	#$85			; subtract $85 (restore byte)
  3594 									; carry clear if byte>$7A
  3595 BDF8 60				RTS
  3596
  3597 									; reached end of variable mem without match
  3598 									; .. so create new variable
  3599 BDF9			LAB_1D8B
  3600 BDF9 68				PLA				; pop return address low byte
  3601 BDFA 48				PHA				; push return address low byte
  3602 = BC02			LAB_1C18p2	= LAB_1C18+2
  3603 BDFB C9 02			CMP	#<LAB_1C18p2		; compare with expected calling routine return low byte
  3604 BDFD D0 05			BNE	LAB_1D98		; if not get (var) go create new var
  3605
  3606 				; This will only drop through if the call was from LAB_1C18 and is only called
  3607 				; from there if it is searching for a variable from the RHS of a LET a=b statement
  3608 				; it prevents the creation of variables not assigned a value.
  3609
  3610 				; value returned by this is either numeric zero (exponent byte is $00) or null string
  3611 				; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3612
  3613 				; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3614
  3615 				; this is where you would put the undefined variable error call e.g.
  3616
  3617 				;					; variable doesn't exist so flag error
  3618 				;	LDX	#$24			; error code $24 ('undefined variable' error)
  3619 				;	JMP	LAB_XERR		; do error #X then warm start
  3620
  3621 				; the above code has been tested and works a treat! (it replaces the three code lines
  3622 				; below)
  3623 									; else return dummy null value
  3624 BDFF A9 E8			LDA	#<LAB_1D96		; low byte point to $00,$00
  3625 									; (uses part of misc constants table)
  3626 BE01 A0 D3			LDY	#>LAB_1D96		; high byte point to $00,$00
  3627 BE03 60				RTS
  3628
  3629 				; create new numeric variable
  3630 BE04			LAB_1D98
  3631 BE04 A5 3D			LDA	Sarryl			; get var mem end low byte
  3632 BE06 A4 3E			LDY	Sarryh			; get var mem end high byte
  3633 BE08 85 6A			STA	Ostrtl			; save old block start low byte
  3634 BE0A 84 6B			STY	Ostrth			; save old block start high byte
  3635 BE0C A5 3F			LDA	Earryl			; get array mem end low byte
  3636 BE0E A4 40			LDY	Earryh			; get array mem end high byte
  3637 BE10 85 66			STA	Obendl			; save old block end low byte
  3638 BE12 84 67			STY	Obendh			; save old block end high byte
  3639 BE14 18				CLC				; clear carry for add
  3640 BE15 69 06			ADC	#$06			; +6 (space for one var)
  3641 BE17 90 01			BCC	LAB_1DAE		; branch if no overflow to high byte
  3642
  3643 BE19 C8				INY				; else increment high byte
  3644 BE1A			LAB_1DAE
  3645 BE1A 85 64			STA	Nbendl			; set new block end low byte
  3646 BE1C 84 65			STY	Nbendh			; set new block end high byte
  3647 BE1E 20 8D B0			JSR	LAB_11CF		; open up space in memory
  3648 BE21 A5 64			LDA	Nbendl			; get new start low byte
  3649 BE23 A4 65			LDY	Nbendh			; get new start high byte (-$100)
  3650 BE25 C8				INY				; correct high byte
  3651 BE26 85 3D			STA	Sarryl			; save new var mem end low byte
  3652 BE28 84 3E			STY	Sarryh			; save new var mem end high byte
  3653 BE2A A0 00			LDY	#$00			; clear index
  3654 BE2C A5 53			LDA	Varnm1			; get var name 1st character
  3655 BE2E 91 6A			STA	(Vrschl),Y		; save var name 1st character
  3656 BE30 C8				INY				; increment index
  3657 BE31 A5 54			LDA	Varnm2			; get var name 2nd character
  3658 BE33 91 6A			STA	(Vrschl),Y		; save var name 2nd character
  3659 BE35 A9 00			LDA	#$00			; clear A
  3660 BE37 C8				INY				; increment index
  3661 BE38 91 6A			STA	(Vrschl),Y		; initialise var byte
  3662 BE3A C8				INY				; increment index
  3663 BE3B 91 6A			STA	(Vrschl),Y		; initialise var byte
  3664 BE3D C8				INY				; increment index
  3665 BE3E 91 6A			STA	(Vrschl),Y		; initialise var byte
  3666 BE40 C8				INY				; increment index
  3667 BE41 91 6A			STA	(Vrschl),Y		; initialise var byte
  3668
  3669 									; found a match for var ((Vrschl) = ptr)
  3670 BE43			LAB_1DD7
  3671 BE43 A5 6A			LDA	Vrschl			; get var address low byte
  3672 BE45 18				CLC				; clear carry for add
  3673 BE46 69 02			ADC	#$02			; +2 (offset past var name bytes)
  3674 BE48 A4 6B			LDY	Vrschh			; get var address high byte
  3675 BE4A 90 01			BCC	LAB_1DE1		; branch if no overflow from add
  3676
  3677 BE4C C8				INY				; else increment high byte
  3678 BE4D			LAB_1DE1
  3679 BE4D 85 55			STA	Cvaral			; save current var address low byte
  3680 BE4F 84 56			STY	Cvarah			; save current var address high byte
  3681 BE51 60				RTS
  3682
  3683 				; set-up array pointer (Adatal/h) to first element in array
  3684 				; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3685 BE52			LAB_1DE6
  3686 BE52 A5 1D			LDA	Dimcnt			; get # of dimensions (1, 2 or 3)
  3687 BE54 0A				ASL				; *2 (also clears the carry !)
  3688 BE55 69 05			ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3689 BE57 65 6A			ADC	Astrtl			; add array start pointer low byte
  3690 BE59 A4 6B			LDY	Astrth			; get array pointer high byte
  3691 BE5B 90 01			BCC	LAB_1DF2		; branch if no overflow
  3692
  3693 BE5D C8				INY				; else increment high byte
  3694 BE5E			LAB_1DF2
  3695 BE5E 85 64			STA	Adatal			; save array data pointer low byte
  3696 BE60 84 65			STY	Adatah			; save array data pointer high byte
  3697 BE62 60				RTS
  3698
  3699 				; evaluate integer expression
  3700 BE63			LAB_EVIN
  3701 BE63 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3702 BE66 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3703 									; else do type mismatch
  3704
  3705 				; evaluate integer expression (no check)
  3706 BE69			LAB_EVPI
  3707 BE69 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  3708 BE6B 30 0D			BMI	LAB_1E12		; do function call error if -ve
  3709
  3710 				; evaluate integer expression (no sign check)
  3711 BE6D			LAB_EVIR
  3712 BE6D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3713 BE6F C9 90			CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3714 BE71 90 09			BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3715
  3716 BE73 A9 EF			LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3717 BE75 A0 D3			LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3718 BE77 20 EC C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  3719 BE7A			LAB_1E12
  3720 BE7A D0 74			BNE	LAB_FCER		; if <> do function call error then warm start
  3721
  3722 BE7C			LAB_1E14
  3723 BE7C 4C 25 C9			JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  3724
  3725 				; find or make array
  3726 BE7F			LAB_1E17
  3727 BE7F A5 1E			LDA	Defdim			; get DIM flag
  3728 BE81 48				PHA				; push it
  3729 BE82 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  3730 BE84 48				PHA				; push it
  3731 BE85 A0 00			LDY	#$00			; clear dimensions count
  3732
  3733 				; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3734 BE87			LAB_1E1F
  3735 BE87 98				TYA				; copy dimensions count
  3736 BE88 48				PHA				; save it
  3737 BE89 A5 54			LDA	Varnm2			; get array name 2nd byte
  3738 BE8B 48				PHA				; save it
  3739 BE8C A5 53			LDA	Varnm1			; get array name 1st byte
  3740 BE8E 48				PHA				; save it
  3741 BE8F 20 63 BE			JSR	LAB_EVIN		; evaluate integer expression
  3742 BE92 68				PLA				; pull array name 1st byte
  3743 BE93 85 53			STA	Varnm1			; restore array name 1st byte
  3744 BE95 68				PLA				; pull array name 2nd byte
  3745 BE96 85 54			STA	Varnm2			; restore array name 2nd byte
  3746 BE98 68				PLA				; pull dimensions count
  3747 BE99 A8				TAY				; restore it
  3748 BE9A BA				TSX				; copy stack pointer
  3749 BE9B BD 02 01			LDA	LAB_STAK+2,X		; get DIM flag
  3750 BE9E 48				PHA				; push it
  3751 BE9F BD 01 01			LDA	LAB_STAK+1,X		; get data type flag
  3752 BEA2 48				PHA				; push it
  3753 BEA3 A5 6E			LDA	FAC1_2			; get this dimension size high byte
  3754 BEA5 9D 02 01			STA	LAB_STAK+2,X		; stack before flag bytes
  3755 BEA8 A5 6F			LDA	FAC1_3			; get this dimension size low byte
  3756 BEAA 9D 01 01			STA	LAB_STAK+1,X		; stack before flag bytes
  3757 BEAD C8				INY				; increment dimensions count
  3758 BEAE 20 82 00			JSR	LAB_GBYT		; scan memory
  3759 BEB1 C9 2C			CMP	#','			; compare with ','
  3760 BEB3 F0 D2			BEQ	LAB_1E1F		; if found go do next dimension
  3761
  3762 BEB5 84 1D			STY	Dimcnt			; store dimensions count
  3763 BEB7 20 B4 BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  3764 BEBA 68				PLA				; pull data type flag
  3765 BEBB 85 1F			STA	Dtypef			; restore data type flag, $FF=string, $00=numeric
  3766 BEBD 68				PLA				; pull DIM flag
  3767 BEBE 85 1E			STA	Defdim			; restore DIM flag
  3768 BEC0 A6 3D			LDX	Sarryl			; get array mem start low byte
  3769 BEC2 A5 3E			LDA	Sarryh			; get array mem start high byte
  3770
  3771 				; now check to see if we are at the end of array memory (we would be if there were
  3772 				; no arrays).
  3773 BEC4			LAB_1E5C
  3774 BEC4 86 6A			STX	Astrtl			; save as array start pointer low byte
  3775 BEC6 85 6B			STA	Astrth			; save as array start pointer high byte
  3776 BEC8 C5 40			CMP	Earryh			; compare with array mem end high byte
  3777 BECA D0 04			BNE	LAB_1E68		; branch if not reached array mem end
  3778
  3779 BECC E4 3F			CPX	Earryl			; else compare with array mem end low byte
  3780 BECE F0 39			BEQ	LAB_1EA1		; go build array if not found
  3781
  3782 									; search for array
  3783 BED0			LAB_1E68
  3784 BED0 A0 00			LDY	#$00			; clear index
  3785 BED2 B1 6A			LDA	(Astrtl),Y		; get array name first byte
  3786 BED4 C8				INY				; increment index to second name byte
  3787 BED5 C5 53			CMP	Varnm1			; compare with this array name first byte
  3788 BED7 D0 06			BNE	LAB_1E77		; branch if no match
  3789
  3790 BED9 A5 54			LDA	Varnm2			; else get this array name second byte
  3791 BEDB D1 6A			CMP	(Astrtl),Y		; compare with array name second byte
  3792 BEDD F0 16			BEQ	LAB_1E8D		; array found so branch
  3793
  3794 									; no match
  3795 BEDF			LAB_1E77
  3796 BEDF C8				INY				; increment index
  3797 BEE0 B1 6A			LDA	(Astrtl),Y		; get array size low byte
  3798 BEE2 18				CLC				; clear carry for add
  3799 BEE3 65 6A			ADC	Astrtl			; add array start pointer low byte
  3800 BEE5 AA				TAX				; copy low byte to X
  3801 BEE6 C8				INY				; increment index
  3802 BEE7 B1 6A			LDA	(Astrtl),Y		; get array size high byte
  3803 BEE9 65 6B			ADC	Astrth			; add array mem pointer high byte
  3804 BEEB 90 D7			BCC	LAB_1E5C		; if no overflow go check next array
  3805
  3806 				; do array bounds error
  3807 BEED			LAB_1E85
  3808 BEED A2 10			LDX	#$10			; error code $10 ('Array bounds' error)
  3809 BEEF 2C				.byte	$2C			; makes next bit BIT LAB_08A2
  3810
  3811 				; do function call error
  3812 BEF0			LAB_FCER
  3813 BEF0 A2 08			LDX	#$08			; error code $08 ('Function call' error)
  3814 BEF2			LAB_1E8A
  3815 BEF2 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3816
  3817 									; found array, are we trying to dimension it?
  3818 BEF5			LAB_1E8D
  3819 BEF5 A2 12			LDX	#$12			; set error $12 ('Double dimension' error)
  3820 BEF7 A5 1E			LDA	Defdim			; get DIM flag
  3821 BEF9 D0 F7			BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3822 									; start
  3823
  3824 				; found the array and we're not dimensioning it so we must find an element in it
  3825 BEFB 20 52 BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3826 									; (Astrtl,Astrth points to start of array)
  3827 BEFE A5 1D			LDA	Dimcnt			; get dimensions count
  3828 BF00 A0 04			LDY	#$04			; set index to array's # of dimensions
  3829 BF02 D1 6A			CMP	(Astrtl),Y		; compare with no of dimensions
  3830 BF04 D0 E7			BNE	LAB_1E85		; if wrong do array bounds error, could do 'Wrong
  3831 									; dimensions' error here .. if we want a different
  3832 									; error message
  3833
  3834 BF06 4C 8C BF			JMP	LAB_1F28		; found array so go get element
  3835 									; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3836 									; Dimcnt and save it at (Astrtl),Y which is already the
  3837 									; same or we would have taken the BNE)
  3838
  3839 									; array not found, so build it
  3840 BF09			LAB_1EA1
  3841 BF09 20 52 BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3842 									; (Astrtl,Astrth points to start of array)
  3843 BF0C 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3844 									; addr to check is in AY (low/high)
  3845 BF0F A0 00			LDY	#$00			; clear Y (don't need to clear A)
  3846 BF11 84 7B			STY	Aspth			; clear array data size high byte
  3847 BF13 A5 53			LDA	Varnm1			; get variable name 1st byte
  3848 BF15 91 6A			STA	(Astrtl),Y		; save array name 1st byte
  3849 BF17 C8				INY				; increment index
  3850 BF18 A5 54			LDA	Varnm2			; get variable name 2nd byte
  3851 BF1A 91 6A			STA	(Astrtl),Y		; save array name 2nd byte
  3852 BF1C A5 1D			LDA	Dimcnt			; get dimensions count
  3853 BF1E A0 04			LDY	#$04			; index to dimension count
  3854 BF20 84 7A			STY	Asptl			; set array data size low byte (four bytes per element)
  3855 BF22 91 6A			STA	(Astrtl),Y		; set array's dimensions count
  3856
  3857 									; now calculate the size of the data space for the array
  3858 BF24 18				CLC				; clear carry for add (clear on subsequent loops)
  3859 BF25			LAB_1EC0
  3860 BF25 A2 0B			LDX	#$0B			; set default dimension value low byte
  3861 BF27 A9 00			LDA	#$00			; set default dimension value high byte
  3862 BF29 24 1E			BIT	Defdim			; test default DIM flag
  3863 BF2B 50 07			BVC	LAB_1ED0		; branch if b6 of Defdim is clear
  3864
  3865 BF2D 68				PLA				; else pull dimension value low byte
  3866 BF2E 69 01			ADC	#$01			; +1 (allow for zeroeth element)
  3867 BF30 AA				TAX				; copy low byte to X
  3868 BF31 68				PLA				; pull dimension value high byte
  3869 BF32 69 00			ADC	#$00			; add carry from low byte
  3870
  3871 BF34			LAB_1ED0
  3872 BF34 C8				INY				; index to dimension value high byte
  3873 BF35 91 6A			STA	(Astrtl),Y		; save dimension value high byte
  3874 BF37 C8				INY				; index to dimension value high byte
  3875 BF38 8A				TXA				; get dimension value low byte
  3876 BF39 91 6A			STA	(Astrtl),Y		; save dimension value low byte
  3877 BF3B 20 DB BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3878 BF3E 86 7A			STX	Asptl			; save array data size low byte
  3879 BF40 85 7B			STA	Aspth			; save array data size high byte
  3880 BF42 A4 31			LDY	ut1_pl			; restore index (saved by subroutine)
  3881 BF44 C6 1D			DEC	Dimcnt			; decrement dimensions count
  3882 BF46 D0 DD			BNE	LAB_1EC0		; loop while not = 0
  3883
  3884 BF48 65 65			ADC	Adatah			; add size high byte to first element high byte
  3885 									; (carry is always clear here)
  3886 BF4A B0 5D			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3887
  3888 BF4C 85 65			STA	Adatah			; save end of array high byte
  3889 BF4E A8				TAY				; copy end high byte to Y
  3890 BF4F 8A				TXA				; get array size low byte
  3891 BF50 65 64			ADC	Adatal			; add array start low byte
  3892 BF52 90 03			BCC	LAB_1EF3		; branch if no carry
  3893
  3894 BF54 C8				INY				; else increment end of array high byte
  3895 BF55 F0 52			BEQ	LAB_1F45		; if overflow go do 'Out of memory' error
  3896
  3897 									; set-up mostly complete, now zero the array
  3898 BF57			LAB_1EF3
  3899 BF57 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3900 									; addr to check is in AY (low/high)
  3901 BF5A 85 3F			STA	Earryl			; save array mem end low byte
  3902 BF5C 84 40			STY	Earryh			; save array mem end high byte
  3903 BF5E A9 00			LDA	#$00			; clear byte for array clear
  3904 BF60 E6 7B			INC	Aspth			; increment array size high byte (now block count)
  3905 BF62 A4 7A			LDY	Asptl			; get array size low byte (now index to block)
  3906 BF64 F0 05			BEQ	LAB_1F07		; branch if low byte = $00
  3907
  3908 BF66			LAB_1F02
  3909 BF66 88				DEY				; decrement index (do 0 to n-1)
  3910 BF67 91 64			STA	(Adatal),Y		; zero byte
  3911 BF69 D0 FB			BNE	LAB_1F02		; loop until this block done
  3912
  3913 BF6B			LAB_1F07
  3914 BF6B C6 65			DEC	Adatah			; decrement array pointer high byte
  3915 BF6D C6 7B			DEC	Aspth			; decrement block count high byte
  3916 BF6F D0 F5			BNE	LAB_1F02		; loop until all blocks done
  3917
  3918 BF71 E6 65			INC	Adatah			; correct for last loop
  3919 BF73 38				SEC				; set carry for subtract
  3920 BF74 A0 02			LDY	#$02			; index to array size low byte
  3921 BF76 A5 3F			LDA	Earryl			; get array mem end low byte
  3922 BF78 E5 6A			SBC	Astrtl			; subtract array start low byte
  3923 BF7A 91 6A			STA	(Astrtl),Y		; save array size low byte
  3924 BF7C C8				INY				; index to array size high byte
  3925 BF7D A5 40			LDA	Earryh			; get array mem end high byte
  3926 BF7F E5 6B			SBC	Astrth			; subtract array start high byte
  3927 BF81 91 6A			STA	(Astrtl),Y		; save array size high byte
  3928 BF83 A5 1E			LDA	Defdim			; get default DIM flag
  3929 BF85 D0 53			BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  3930
  3931 									; else, find element
  3932 BF87 C8				INY				; index to # of dimensions
  3933
  3934 BF88			LAB_1F24
  3935 BF88 B1 6A			LDA	(Astrtl),Y		; get array's dimension count
  3936 BF8A 85 1D			STA	Dimcnt			; save it
  3937
  3938 				; we have found, or built, the array. now we need to find the element
  3939 BF8C			LAB_1F28
  3940 BF8C A9 00			LDA	#$00			; clear byte
  3941 BF8E 85 7A			STA	Asptl			; clear array data pointer low byte
  3942 BF90			LAB_1F2C
  3943 BF90 85 7B			STA	Aspth			; save array data pointer high byte
  3944 BF92 C8				INY				; increment index (point to array bound high byte)
  3945 BF93 68				PLA				; pull array index low byte
  3946 BF94 AA				TAX				; copy to X
  3947 BF95 85 6E			STA	FAC1_2			; save index low byte to FAC1 mantissa2
  3948 BF97 68				PLA				; pull array index high byte
  3949 BF98 85 6F			STA	FAC1_3			; save index high byte to FAC1 mantissa3
  3950 BF9A D1 6A			CMP	(Astrtl),Y		; compare with array bound high byte
  3951 BF9C 90 0E			BCC	LAB_1F48		; branch if within bounds
  3952
  3953 BF9E D0 06			BNE	LAB_1F42		; if outside bounds do array bounds error
  3954
  3955 									; else high byte was = so test low bytes
  3956 BFA0 C8				INY				; index to array bound low byte
  3957 BFA1 8A				TXA				; get array index low byte
  3958 BFA2 D1 6A			CMP	(Astrtl),Y		; compare with array bound low byte
  3959 BFA4 90 07			BCC	LAB_1F49		; branch if within bounds
  3960
  3961 BFA6			LAB_1F42
  3962 BFA6 4C ED BE			JMP	LAB_1E85		; else do array bounds error
  3963
  3964 BFA9			LAB_1F45
  3965 BFA9 4C 09 B1			JMP	LAB_OMER		; do 'Out of memory' error then warm start
  3966
  3967 BFAC			LAB_1F48
  3968 BFAC C8				INY				; index to array bound low byte
  3969 BFAD			LAB_1F49
  3970 BFAD A5 7B			LDA	Aspth			; get array data pointer high byte
  3971 BFAF 05 7A			ORA	Asptl			; OR with array data pointer low byte
  3972 BFB1 F0 0A			BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  3973
  3974 BFB3 20 DB BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3975 BFB6 8A				TXA				; get result low byte
  3976 BFB7 65 6E			ADC	FAC1_2			; add index low byte from FAC1 mantissa2
  3977 BFB9 AA				TAX				; save result low byte
  3978 BFBA 98				TYA				; get result high byte
  3979 BFBB A4 31			LDY	ut1_pl			; restore index
  3980 BFBD			LAB_1F5A
  3981 BFBD 65 6F			ADC	FAC1_3			; add index high byte from FAC1 mantissa3
  3982 BFBF 86 7A			STX	Asptl			; save array data pointer low byte
  3983 BFC1 C6 1D			DEC	Dimcnt			; decrement dimensions count
  3984 BFC3 D0 CB			BNE	LAB_1F2C		; loop if dimensions still to do
  3985
  3986 BFC5 06 7A			ASL	Asptl			; array data pointer low byte * 2
  3987 BFC7 2A				ROL				; array data pointer high byte * 2
  3988 BFC8 06 7A			ASL	Asptl			; array data pointer low byte * 4
  3989 BFCA 2A				ROL				; array data pointer high byte * 4
  3990 BFCB A8				TAY				; copy high byte
  3991 BFCC A5 7A			LDA	Asptl			; get low byte
  3992 BFCE 65 64			ADC	Adatal			; add array data start pointer low byte
  3993 BFD0 85 55			STA	Cvaral			; save as current var address low byte
  3994 BFD2 98				TYA				; get high byte back
  3995 BFD3 65 65			ADC	Adatah			; add array data start pointer high byte
  3996 BFD5 85 56			STA	Cvarah			; save as current var address high byte
  3997 BFD7 A8				TAY				; copy high byte to Y
  3998 BFD8 A5 55			LDA	Cvaral			; get current var address low byte
  3999 BFDA			LAB_1F7B
  4000 BFDA 60				RTS
  4001
  4002 				; does XY = (Astrtl),Y * (Asptl)
  4003 BFDB			LAB_1F7C
  4004 BFDB 84 31			STY	ut1_pl			; save index
  4005 BFDD B1 6A			LDA	(Astrtl),Y		; get dimension size low byte
  4006 BFDF 85 36			STA	dims_l			; save dimension size low byte
  4007 BFE1 88				DEY				; decrement index
  4008 BFE2 B1 6A			LDA	(Astrtl),Y		; get dimension size high byte
  4009 BFE4 85 37			STA	dims_h			; save dimension size high byte
  4010
  4011 BFE6 A9 10			LDA	#$10			; count = $10 (16 bit multiply)
  4012 BFE8 85 68			STA	numbit			; save bit count
  4013 BFEA A2 00			LDX	#$00			; clear result low byte
  4014 BFEC A0 00			LDY	#$00			; clear result high byte
  4015 BFEE			LAB_1F8F
  4016 BFEE 8A				TXA				; get result low byte
  4017 BFEF 0A				ASL				; *2
  4018 BFF0 AA				TAX				; save result low byte
  4019 BFF1 98				TYA				; get result high byte
  4020 BFF2 2A				ROL				; *2
  4021 BFF3 A8				TAY				; save result high byte
  4022 BFF4 B0 B3			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4023
  4024 BFF6 06 7A			ASL	Asptl			; shift multiplier low byte
  4025 BFF8 26 7B			ROL	Aspth			; shift multiplier high byte
  4026 BFFA 90 0B			BCC	LAB_1FA8		; skip add if no carry
  4027
  4028 BFFC 18				CLC				; else clear carry for add
  4029 BFFD 8A				TXA				; get result low byte
  4030 BFFE 65 36			ADC	dims_l			; add dimension size low byte
  4031 C000 AA				TAX				; save result low byte
  4032 C001 98				TYA				; get result high byte
  4033 C002 65 37			ADC	dims_h			; add dimension size high byte
  4034 C004 A8				TAY				; save result high byte
  4035 C005 B0 A2			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4036
  4037 C007			LAB_1FA8
  4038 C007 C6 68			DEC	numbit			; decrement bit count
  4039 C009 D0 E3			BNE	LAB_1F8F		; loop until all done
  4040
  4041 C00B 60				RTS
  4042
  4043 				; perform FRE()
  4044 C00C			LAB_FRE
  4045 C00C A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  4046 C00E 10 03			BPL	LAB_1FB4		; branch if numeric
  4047
  4048 C010 20 13 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  4049 									; space returns with A = length, X=$71=pointer low byte,
  4050 									; Y=$72=pointer high byte
  4051
  4052 									; FRE(n) was numeric so do this
  4053 C013			LAB_1FB4
  4054 C013 20 B4 C1			JSR	LAB_GARB		; go do garbage collection
  4055 C016 38				SEC				; set carry for subtract
  4056 C017 A5 41			LDA	Sstorl			; get bottom of string space low byte
  4057 C019 E5 3F			SBC	Earryl			; subtract array mem end low byte
  4058 C01B A8				TAY				; copy result to Y
  4059 C01C A5 42			LDA	Sstorh			; get bottom of string space high byte
  4060 C01E E5 40			SBC	Earryh			; subtract array mem end high byte
  4061
  4062 				; save and convert unsigned integer AY to FAC1
  4063 C020			LAB_UAYFC
  4064 C020 46 1F			LSR	Dtypef            	; clear data type flag, $FF=string, $00=numeric
  4065 C022 85 6D			STA	FAC1_1            	; save FAC1 mantissa1
  4066 C024 84 6E			STY	FAC1_2            	; save FAC1 mantissa2
  4067 C026 A2 90			LDX	#$90              	; set exponent=2^16 (integer)
  4068 C028 38				SEC                     	; always positive
  4069 C029 4C DC C8			JMP	LAB_STFA          	; set exp=X, clear FAC1_3, normalise and return 
  4070 				      
  4071 				; save and convert integer AY to FAC1
  4072 C02C			LAB_AYFC
  4073 C02C 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  4074 C02E 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  4075 C030 84 6E			STY	FAC1_2			; save FAC1 mantissa2
  4076 C032 A2 90			LDX	#$90			; set exponent=2^16 (integer)
  4077 C034 4C D7 C8			JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
  4078
  4079 				; perform POS()
  4080 C037			LAB_POS
  4081 C037 A4 0E			LDY	TPos			; get terminal position
  4082
  4083 				; convert Y to byte in FAC1
  4084 C039			LAB_1FD0
  4085 C039 A9 00			LDA	#$00			; clear high byte
  4086 C03B F0 EF			BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  4087
  4088 				; check not Direct (used by DEF and INPUT)
  4089 C03D			LAB_CKRN
  4090 C03D A6 48			LDX	Clineh			; get current line high byte
  4091 C03F E8				INX				; increment it
  4092 C040 D0 98			BNE	LAB_1F7B		; return if can continue not direct mode
  4093
  4094 									; else do illegal direct error
  4095 C042			LAB_1FD9
  4096 C042 A2 16			LDX	#$16			; error code $16 ('Illegal direct' error)
  4097 C044			LAB_1FDB
  4098 C044 4C 0B B1			JMP	LAB_XERR		; go do error #X, then warm start
  4099
  4100 				; perform DEF
  4101 C047			LAB_DEF
  4102 C047 20 78 C0			JSR	LAB_200B		; check FNx syntax
  4103 C04A 85 5C			STA	func_l			; save function pointer low byte
  4104 C04C 84 5D			STY	func_h			; save function pointer high byte
  4105 C04E 20 3D C0			JSR	LAB_CKRN		; check not Direct (back here if ok)
  4106 C051 20 BF BB			JSR	LAB_1BFE		; scan for '(' , else do syntax error then warm start
  4107 C054 A9 80			LDA	#$80			; set flag for FNx
  4108 C056 85 21			STA	Sufnxf			; save subscript/FNx flag
  4109 C058 20 71 BD			JSR	LAB_GVAR		; get (var) address
  4110 C05B 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4111 C05E 20 B4 BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4112 C061 A9 D7			LDA	#TK_EQUAL		; get = token
  4113 C063 20 B6 BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  4114 C066 A5 56			LDA	Cvarah			; get current var address high byte
  4115 C068 48				PHA				; push it
  4116 C069 A5 55			LDA	Cvaral			; get current var address low byte
  4117 C06B 48				PHA				; push it
  4118 C06C A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4119 C06E 48				PHA				; push it
  4120 C06F A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4121 C071 48				PHA				; push it
  4122 C072 20 5D B6			JSR	LAB_DATA		; go perform DATA
  4123 C075 4C E7 C0			JMP	LAB_207A		; put execute pointer and variable pointer into function
  4124 									; and return
  4125
  4126 				; check FNx syntax
  4127 C078			LAB_200B
  4128 C078 A9 C3			LDA	#TK_FN			; get FN' token
  4129 C07A 20 B6 BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  4130 									; return character after A
  4131 C07D 09 80			ORA	#$80			; set FN flag bit
  4132 C07F 85 21			STA	Sufnxf			; save FN flag so array variable test fails
  4133 C081 20 78 BD			JSR	LAB_1D12		; search for FN variable
  4134 C084 4C 95 BA			JMP	LAB_CTNM		; check if source is numeric and return, else do type
  4135 									; mismatch
  4136 									; Evaluate FNx
  4137 C087			LAB_201E
  4138 C087 20 78 C0			JSR	LAB_200B		; check FNx syntax
  4139 C08A 48				PHA				; push function pointer low byte
  4140 C08B 98				TYA				; copy function pointer high byte
  4141 C08C 48				PHA				; push function pointer high byte
  4142 C08D 20 BF BB			JSR	LAB_1BFE		; scan for '(', else do syntax error then warm start
  4143 C090 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  4144 C093 20 B4 BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4145 C096 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4146 C099 68				PLA				; pop function pointer high byte
  4147 C09A 85 5D			STA	func_h			; restore it
  4148 C09C 68				PLA				; pop function pointer low byte
  4149 C09D 85 5C			STA	func_l			; restore it
  4150 C09F A2 20			LDX	#$20			; error code $20 ('Undefined function' error)
  4151 C0A1 A0 03			LDY	#$03			; index to variable pointer high byte
  4152 C0A3 B1 5C			LDA	(func_l),Y		; get variable pointer high byte
  4153 C0A5 F0 9D			BEQ	LAB_1FDB		; if zero go do undefined function error
  4154
  4155 C0A7 85 56			STA	Cvarah			; save variable address high byte
  4156 C0A9 88				DEY				; index to variable address low byte
  4157 C0AA B1 5C			LDA	(func_l),Y		; get variable address low byte
  4158 C0AC 85 55			STA	Cvaral			; save variable address low byte
  4159 C0AE AA				TAX				; copy address low byte
  4160 									; now stack the function variable value before use
  4161 C0AF C8				INY				; index to mantissa_3
  4162 C0B0			LAB_2043
  4163 C0B0 B1 55			LDA	(Cvaral),Y		; get byte from variable
  4164 C0B2 48				PHA				; stack it
  4165 C0B3 88				DEY				; decrement index
  4166 C0B4 10 FA			BPL	LAB_2043		; loop until variable stacked
  4167
  4168 C0B6 A4 56			LDY	Cvarah			; get variable address high byte
  4169 C0B8 20 7C C8			JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  4170 									; (function variable), return Y=0, always
  4171 C0BB A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4172 C0BD 48				PHA				; push it
  4173 C0BE A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4174 C0C0 48				PHA				; push it
  4175 C0C1 B1 5C			LDA	(func_l),Y		; get function execute pointer low byte
  4176 C0C3 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  4177 C0C5 C8				INY				; index to high byte
  4178 C0C6 B1 5C			LDA	(func_l),Y		; get function execute pointer high byte
  4179 C0C8 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4180 C0CA A5 56			LDA	Cvarah			; get variable address high byte
  4181 C0CC 48				PHA				; push it
  4182 C0CD A5 55			LDA	Cvaral			; get variable address low byte
  4183 C0CF 48				PHA				; push it
  4184 C0D0 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4185 									; else do type mismatch
  4186 C0D3 68				PLA				; pull variable address low byte
  4187 C0D4 85 5C			STA	func_l			; save variable address low byte
  4188 C0D6 68				PLA				; pull variable address high byte
  4189 C0D7 85 5D			STA	func_h			; save variable address high byte
  4190 C0D9 20 82 00			JSR	LAB_GBYT		; scan memory
  4191 C0DC F0 03			BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  4192
  4193 C0DE 4C C7 BB			JMP	LAB_SNER		; else syntax error then warm start
  4194
  4195 				; restore Bpntrl,Bpntrh and function variable from stack
  4196 C0E1			LAB_2074
  4197 C0E1 68				PLA				; pull BASIC execute pointer low byte
  4198 C0E2 85 83			STA	Bpntrl			; restore BASIC execute pointer low byte
  4199 C0E4 68				PLA				; pull BASIC execute pointer high byte
  4200 C0E5 85 84			STA	Bpntrh			; restore BASIC execute pointer high byte
  4201
  4202 				; put execute pointer and variable pointer into function
  4203 C0E7			LAB_207A
  4204 C0E7 A0 00			LDY	#$00			; clear index
  4205 C0E9 68				PLA				; pull BASIC execute pointer low byte
  4206 C0EA 91 5C			STA	(func_l),Y		; save to function
  4207 C0EC C8				INY				; increment index
  4208 C0ED 68				PLA				; pull BASIC execute pointer high byte
  4209 C0EE 91 5C			STA	(func_l),Y		; save to function
  4210 C0F0 C8				INY				; increment index
  4211 C0F1 68				PLA				; pull current var address low byte
  4212 C0F2 91 5C			STA	(func_l),Y		; save to function
  4213 C0F4 C8				INY				; increment index
  4214 C0F5 68				PLA				; pull current var address high byte
  4215 C0F6 91 5C			STA	(func_l),Y		; save to function
  4216 C0F8 60				RTS
  4217
  4218 				; perform STR$()
  4219 C0F9			LAB_STRS
  4220 C0F9 20 95 BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4221 C0FC 20 6A CA			JSR	LAB_296E		; convert FAC1 to string
  4222 C0FF A9 9E			LDA	#<Decssp1		; set result string low pointer
  4223 C101 A0 00			LDY	#>Decssp1		; set result string high pointer
  4224 C103 F0 12			BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
  4225
  4226 				; Do string vector
  4227 				; copy des_pl/h to des_2l/h and make string space A bytes long
  4228 C105			LAB_209C
  4229 C105 A6 6E			LDX	des_pl			; get descriptor pointer low byte
  4230 C107 A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4231 C109 86 5E			STX	des_2l			; save descriptor pointer low byte
  4232 C10B 84 5F			STY	des_2h			; save descriptor pointer high byte
  4233
  4234 				; make string space A bytes long
  4235 				; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4236 C10D			LAB_MSSP
  4237 C10D 20 82 C1			JSR	LAB_2115		; make space in string memory for string A long
  4238 									; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4239 C110 86 6D			STX	str_pl			; save string pointer low byte
  4240 C112 84 6E			STY	str_ph			; save string pointer high byte
  4241 C114 85 6C			STA	str_ln			; save length
  4242 C116 60				RTS
  4243
  4244 				; Scan, set up string
  4245 				; print ' terminated string to Sutill/Sutilh
  4246 C117			LAB_20AE
  4247 C117 A2 22			LDX	#$22			; set terminator to '
  4248 C119 86 1B			STX	Srchc			; set search character (terminator 1)
  4249 C11B 86 1C			STX	Asrch			; set terminator 2
  4250
  4251 				; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4252 				; source is AY
  4253 C11D			LAB_20B4
  4254 C11D 85 78			STA	ssptr_l			; store string start low byte
  4255 C11F 84 79			STY	ssptr_h			; store string start high byte
  4256 C121 85 6D			STA	str_pl			; save string pointer low byte
  4257 C123 84 6E			STY	str_ph			; save string pointer high byte
  4258 C125 A0 FF			LDY	#$FF			; set length to -1
  4259 C127			LAB_20BE
  4260 C127 C8				INY				; increment length
  4261 C128 B1 78			LDA	(ssptr_l),Y		; get byte from string
  4262 C12A F0 0C			BEQ	LAB_20CF		; exit loop if null byte [EOS]
  4263
  4264 C12C C5 1B			CMP	Srchc			; compare with search character (terminator 1)
  4265 C12E F0 04			BEQ	LAB_20CB		; branch if terminator
  4266
  4267 C130 C5 1C			CMP	Asrch			; compare with terminator 2
  4268 C132 D0 F3			BNE	LAB_20BE		; loop if not terminator 2
  4269
  4270 C134			LAB_20CB
  4271 C134 C9 22			CMP	#$22			; compare with '
  4272 C136 F0 01			BEQ	LAB_20D0		; branch if ' (carry set if = !)
  4273
  4274 C138			LAB_20CF
  4275 C138 18				CLC				; clear carry for add (only if [EOL] terminated string)
  4276 C139			LAB_20D0
  4277 C139 84 6C			STY	str_ln			; save length in FAC1 exponent
  4278 C13B 98				TYA				; copy length to A
  4279 C13C 65 78			ADC	ssptr_l			; add string start low byte
  4280 C13E 85 7A			STA	Sendl			; save string end low byte
  4281 C140 A6 79			LDX	ssptr_h			; get string start high byte
  4282 C142 90 01			BCC	LAB_20DC		; branch if no low byte overflow
  4283
  4284 C144 E8				INX				; else increment high byte
  4285 C145			LAB_20DC				; RAM above code / Ibuff above EhBASIC patch V2
  4286 C145 86 7B			STX	Sendh			; save string end high byte
  4287 C147 A5 79			LDA	ssptr_h			; get string start high byte
  4288 C149 F0 04			BEQ   	LAB_MVST          	; fix STR$() using page zero via LAB_296E
  4289 					
  4290 C14B C9 18			CMP   	#>Ibuffs          	; compare with location of input buffer page
  4291 C14D D0 0B			BNE   	LAB_RTST          	; branch if not in utility area
  4292 C14F			LAB_MVST 
  4293 									; string in utility area, move to string memory
  4294 C14F 98				TYA				; copy length to A
  4295 C150 20 05 C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4296 									; long
  4297 C153 A6 78			LDX	ssptr_l			; get string start low byte
  4298 C155 A4 79			LDY	ssptr_h			; get string start high byte
  4299 C157 20 F4 C2			JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
  4300
  4301 				; check for space on descriptor stack then ..
  4302 				; put string address and length on descriptor stack and update stack pointers
  4303 C15A			LAB_RTST
  4304 C15A A6 25			LDX	next_s			; get string stack pointer
  4305 C15C E0 31			CPX	#des_sk+$09		; compare with max+1
  4306 C15E D0 05			BNE	LAB_20F8		; branch if space on string stack
  4307
  4308 									; else do string too complex error
  4309 C160 A2 1C			LDX	#$1C			; error code $1C ('String too complex' error)
  4310 C162			LAB_20F5
  4311 C162 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4312
  4313 				; put string address and length on descriptor stack and update stack pointers
  4314 C165			LAB_20F8
  4315 C165 A5 6C			LDA	str_ln			; get string length
  4316 C167 95 00			STA	PLUS_0,X		; put on string stack
  4317 C169 A5 6D			LDA	str_pl			; get string pointer low byte
  4318 C16B 95 01			STA	PLUS_1,X		; put on string stack
  4319 C16D A5 6E			LDA	str_ph			; get string pointer high byte
  4320 C16F 95 02			STA	PLUS_2,X		; put on string stack
  4321 C171 A0 00			LDY	#$00			; clear Y
  4322 C173 86 6E			STX	des_pl			; save string descriptor pointer low byte
  4323 C175 84 6F			STY	des_ph			; save string descriptor pointer high byte (always $00)
  4324 C177 88				DEY				; Y = $FF
  4325 C178 84 1F			STY	Dtypef			; save data type flag, $FF=string
  4326 C17A 86 26			STX	last_sl			; save old stack pointer (current top item)
  4327 C17C E8				INX				; update stack pointer
  4328 C17D E8				INX				; update stack pointer
  4329 C17E E8				INX				; update stack pointer
  4330 C17F 86 25			STX	next_s			; save new top item value
  4331 C181 60				RTS
  4332
  4333 				; Build descriptor
  4334 				; make space in string memory for string A long
  4335 				; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4336 C182			LAB_2115
  4337 C182 46 20			LSR	Gclctd			; clear garbage collected flag (b7)
  4338 									; make space for string A long
  4339 C184			LAB_2117
  4340 C184 48				PHA				; save string length
  4341 C185 49 FF			EOR	#$FF			; complement it
  4342 C187 38				SEC				; set carry for subtract (twos comp add)
  4343 C188 65 41			ADC	Sstorl			; add bottom of string space low byte (subtract length)
  4344 C18A A4 42			LDY	Sstorh			; get bottom of string space high byte
  4345 C18C B0 01			BCS	LAB_2122		; skip decrement if no underflow
  4346
  4347 C18E 88				DEY				; decrement bottom of string space high byte
  4348 C18F			LAB_2122
  4349 C18F C4 40			CPY	Earryh			; compare with array mem end high byte
  4350 C191 90 11			BCC	LAB_2137		; do out of memory error if less
  4351
  4352 C193 D0 04			BNE	LAB_212C		; if not = skip next test
  4353
  4354 C195 C5 3F			CMP	Earryl			; compare with array mem end low byte
  4355 C197 90 0B			BCC	LAB_2137		; do out of memory error if less
  4356
  4357 C199			LAB_212C
  4358 C199 85 41			STA	Sstorl			; save bottom of string space low byte
  4359 C19B 84 42			STY	Sstorh			; save bottom of string space high byte
  4360 C19D 85 43			STA	Sutill			; save string utility ptr low byte
  4361 C19F 84 44			STY	Sutilh			; save string utility ptr high byte
  4362 C1A1 AA				TAX				; copy low byte to X
  4363 C1A2 68				PLA				; get string length back
  4364 C1A3 60				RTS
  4365
  4366 C1A4			LAB_2137
  4367 C1A4 A2 0C			LDX	#$0C			; error code $0C ('Out of memory' error)
  4368 C1A6 A5 20			LDA	Gclctd			; get garbage collected flag
  4369 C1A8 30 B8			BMI	LAB_20F5		; if set then do error code X
  4370
  4371 C1AA 20 B4 C1			JSR	LAB_GARB		; else go do garbage collection
  4372 C1AD A9 80			LDA	#$80			; flag for garbage collected
  4373 C1AF 85 20			STA	Gclctd			; set garbage collected flag
  4374 C1B1 68				PLA				; pull length
  4375 C1B2 D0 D0			BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4376
  4377 				; garbage collection routine
  4378 C1B4			LAB_GARB
  4379 C1B4 A6 45			LDX	Ememl			; get end of mem low byte
  4380 C1B6 A5 46			LDA	Ememh			; get end of mem high byte
  4381
  4382 				; re-run routine from last ending
  4383 C1B8			LAB_214B
  4384 C1B8 86 41			STX	Sstorl			; set string storage low byte
  4385 C1BA 85 42			STA	Sstorh			; set string storage high byte
  4386 C1BC A0 00			LDY	#$00			; clear index
  4387 C1BE 84 5D			STY	garb_h			; clear working pointer high byte (flag no strings to move)
  4388 C1C0 A5 3F			LDA	Earryl			; get array mem end low byte
  4389 C1C2 A6 40			LDX	Earryh			; get array mem end high byte
  4390 C1C4 85 6A			STA	Histrl			; save as highest string low byte
  4391 C1C6 86 6B			STX	Histrh			; save as highest string high byte
  4392 C1C8 A9 28			LDA	#des_sk			; set descriptor stack pointer
  4393 C1CA 85 31			STA	ut1_pl			; save descriptor stack pointer low byte
  4394 C1CC 84 32			STY	ut1_ph			; save descriptor stack pointer high byte ($00)
  4395 C1CE			LAB_2161
  4396 C1CE C5 25			CMP	next_s			; compare with descriptor stack pointer
  4397 C1D0 F0 05			BEQ	LAB_216A		; branch if =
  4398
  4399 C1D2 20 38 C2			JSR	LAB_21D7		; go garbage collect descriptor stack
  4400 C1D5 F0 F7			BEQ	LAB_2161		; loop always
  4401
  4402 									; done stacked strings, now do string vars
  4403 C1D7			LAB_216A
  4404 C1D7 06 60			ASL	g_step			; set step size = $06
  4405 C1D9 A5 3B			LDA	Svarl			; get start of vars low byte
  4406 C1DB A6 3C			LDX	Svarh			; get start of vars high byte
  4407 C1DD 85 31			STA	ut1_pl			; save as pointer low byte
  4408 C1DF 86 32			STX	ut1_ph			; save as pointer high byte
  4409 C1E1			LAB_2176
  4410 C1E1 E4 3E			CPX	Sarryh			; compare start of arrays high byte
  4411 C1E3 D0 04			BNE	LAB_217E		; branch if no high byte match
  4412
  4413 C1E5 C5 3D			CMP	Sarryl			; else compare start of arrays low byte
  4414 C1E7 F0 05			BEQ	LAB_2183		; branch if = var mem end
  4415
  4416 C1E9			LAB_217E
  4417 C1E9 20 32 C2			JSR	LAB_21D1		; go garbage collect strings
  4418 C1EC F0 F3			BEQ	LAB_2176		; loop always
  4419
  4420 									; done string vars, now do string arrays
  4421 C1EE			LAB_2183
  4422 C1EE 85 64			STA	Nbendl			; save start of arrays low byte as working pointer
  4423 C1F0 86 65			STX	Nbendh			; save start of arrays high byte as working pointer
  4424 C1F2 A9 04			LDA	#$04			; set step size
  4425 C1F4 85 60			STA	g_step			; save step size
  4426 C1F6			LAB_218B
  4427 C1F6 A5 64			LDA	Nbendl			; get pointer low byte
  4428 C1F8 A6 65			LDX	Nbendh			; get pointer high byte
  4429 C1FA			LAB_218F
  4430 C1FA E4 40			CPX	Earryh			; compare with array mem end high byte
  4431 C1FC D0 04			BNE	LAB_219A		; branch if not at end
  4432
  4433 C1FE C5 3F			CMP	Earryl			; else compare with array mem end low byte
  4434 C200 F0 75			BEQ	LAB_2216		; tidy up and exit if at end
  4435
  4436 C202			LAB_219A
  4437 C202 85 31			STA	ut1_pl			; save pointer low byte
  4438 C204 86 32			STX	ut1_ph			; save pointer high byte
  4439 C206 A0 02			LDY	#$02			; set index
  4440 C208 B1 31			LDA	(ut1_pl),Y		; get array size low byte
  4441 C20A 65 64			ADC	Nbendl			; add start of this array low byte
  4442 C20C 85 64			STA	Nbendl			; save start of next array low byte
  4443 C20E C8				INY				; increment index
  4444 C20F B1 31			LDA	(ut1_pl),Y		; get array size high byte
  4445 C211 65 65			ADC	Nbendh			; add start of this array high byte
  4446 C213 85 65			STA	Nbendh			; save start of next array high byte
  4447 C215 A0 01			LDY	#$01			; set index
  4448 C217 B1 31			LDA	(ut1_pl),Y		; get name second byte
  4449 C219 10 DB			BPL	LAB_218B		; skip if not string array
  4450
  4451 				; was string array so ..
  4452 C21B A0 04			LDY	#$04			; set index
  4453 C21D B1 31			LDA	(ut1_pl),Y		; get # of dimensions
  4454 C21F 0A				ASL				; *2
  4455 C220 69 05			ADC	#$05			; +5 (array header size)
  4456 C222 20 6A C2			JSR	LAB_2208		; go set up for first element
  4457 C225			LAB_21C4
  4458 C225 E4 65			CPX	Nbendh			; compare with start of next array high byte
  4459 C227 D0 04			BNE	LAB_21CC		; branch if <> (go do this array)
  4460
  4461 C229 C5 64			CMP	Nbendl			; else compare element pointer low byte with next array
  4462 									; low byte
  4463 C22B F0 CD			BEQ	LAB_218F		; if equal then go do next array
  4464
  4465 C22D			LAB_21CC
  4466 C22D 20 38 C2			JSR	LAB_21D7		; go defrag array strings
  4467 C230 F0 F3			BEQ	LAB_21C4		; go do next array string (loop always)
  4468
  4469 				; defrag string variables
  4470 				; enter with XA = variable pointer
  4471 				; return with XA = next variable pointer
  4472 C232			LAB_21D1
  4473 C232 C8				INY				; increment index (Y was $00)
  4474 C233 B1 31			LDA	(ut1_pl),Y		; get var name byte 2
  4475 C235 10 30			BPL	LAB_2206		; if not string, step pointer to next var and return
  4476
  4477 C237 C8				INY				; else increment index
  4478 C238			LAB_21D7
  4479 C238 B1 31			LDA	(ut1_pl),Y		; get string length
  4480 C23A F0 2B			BEQ	LAB_2206		; if null, step pointer to next string and return
  4481
  4482 C23C C8				INY				; else increment index
  4483 C23D B1 31			LDA	(ut1_pl),Y		; get string pointer low byte
  4484 C23F AA				TAX				; copy to X
  4485 C240 C8				INY				; increment index
  4486 C241 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte
  4487 C243 C5 42			CMP	Sstorh			; compare bottom of string space high byte
  4488 C245 90 06			BCC	LAB_21EC		; branch if less
  4489
  4490 C247 D0 1E			BNE	LAB_2206		; if greater, step pointer to next string and return
  4491
  4492 									; high bytes were = so compare low bytes
  4493 C249 E4 41			CPX	Sstorl			; compare bottom of string space low byte
  4494 C24B B0 1A			BCS	LAB_2206		; if >=, step pointer to next string and return
  4495
  4496 									; string pointer is < string storage pointer (pos in mem)
  4497 C24D			LAB_21EC
  4498 C24D C5 6B			CMP	Histrh			; compare to highest string high byte
  4499 C24F 90 17			BCC	LAB_2207		; if <, step pointer to next string and return
  4500
  4501 C251 D0 04			BNE	LAB_21F6		; if > update pointers, step to next and return
  4502
  4503 									; high bytes were = so compare low bytes
  4504 C253 E4 6A			CPX	Histrl			; compare to highest string low byte
  4505 C255 90 11			BCC	LAB_2207		; if <, step pointer to next string and return
  4506
  4507 									; string is in string memory space
  4508 C257			LAB_21F6
  4509 C257 86 6A			STX	Histrl			; save as new highest string low byte
  4510 C259 85 6B			STA	Histrh			; save as new highest string high byte
  4511 C25B A5 31			LDA	ut1_pl			; get start of vars(descriptors) low byte
  4512 C25D A6 32			LDX	ut1_ph			; get start of vars(descriptors) high byte
  4513 C25F 85 5C			STA	garb_l			; save as working pointer low byte
  4514 C261 86 5D			STX	garb_h			; save as working pointer high byte
  4515 C263 88				DEY				; decrement index DIFFERS
  4516 C264 88				DEY				; decrement index (should point to descriptor start)
  4517 C265 84 62			STY	g_indx			; save index pointer
  4518
  4519 									; step pointer to next string
  4520 C267			LAB_2206
  4521 C267 18				CLC				; clear carry for add
  4522 C268			LAB_2207
  4523 C268 A5 60			LDA	g_step			; get step size
  4524 C26A			LAB_2208
  4525 C26A 65 31			ADC	ut1_pl			; add pointer low byte
  4526 C26C 85 31			STA	ut1_pl			; save pointer low byte
  4527 C26E 90 02			BCC	LAB_2211		; branch if no overflow
  4528
  4529 C270 E6 32			INC	ut1_ph			; else increment high byte
  4530 C272			LAB_2211
  4531 C272 A6 32			LDX	ut1_ph			; get pointer high byte
  4532 C274 A0 00			LDY	#$00			; clear Y
  4533 C276 60				RTS
  4534
  4535 				; search complete, now either exit or set-up and move string
  4536 C277			LAB_2216
  4537 C277 C6 60			DEC	g_step			; decrement step size (now $03 for descriptor stack)
  4538 C279 A6 5D			LDX	garb_h			; get string to move high byte
  4539 C27B F0 F5			BEQ	LAB_2211		; exit if nothing to move
  4540
  4541 C27D A4 62			LDY	g_indx			; get index byte back (points to descriptor)
  4542 C27F 18				CLC				; clear carry for add
  4543 C280 B1 5C			LDA	(garb_l),Y		; get string length
  4544 C282 65 6A			ADC	Histrl			; add highest string low byte
  4545 C284 85 66			STA	Obendl			; save old block end low pointer
  4546 C286 A5 6B			LDA	Histrh			; get highest string high byte
  4547 C288 69 00			ADC	#$00			; add any carry
  4548 C28A 85 67			STA	Obendh			; save old block end high byte
  4549 C28C A5 41			LDA	Sstorl			; get bottom of string space low byte
  4550 C28E A6 42			LDX	Sstorh			; get bottom of string space high byte
  4551 C290 85 64			STA	Nbendl			; save new block end low byte
  4552 C292 86 65			STX	Nbendh			; save new block end high byte
  4553 C294 20 94 B0			JSR	LAB_11D6		; open up space in memory, don't set array end
  4554 C297 A4 62			LDY	g_indx			; get index byte
  4555 C299 C8				INY				; point to descriptor low byte
  4556 C29A A5 64			LDA	Nbendl			; get string pointer low byte
  4557 C29C 91 5C			STA	(garb_l),Y		; save new string pointer low byte
  4558 C29E AA				TAX				; copy string pointer low byte
  4559 C29F E6 65			INC	Nbendh			; correct high byte (move sets high byte -1)
  4560 C2A1 A5 65			LDA	Nbendh			; get new string pointer high byte
  4561 C2A3 C8				INY				; point to descriptor high byte
  4562 C2A4 91 5C			STA	(garb_l),Y		; save new string pointer high byte
  4563 C2A6 4C B8 C1			JMP	LAB_214B		; re-run routine from last ending
  4564 									; (but don't collect this string)
  4565
  4566 				; concatenate
  4567 				; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4568 C2A9			LAB_224D
  4569 C2A9 A5 6F			LDA	des_ph			; get descriptor pointer high byte
  4570 C2AB 48				PHA				; put on stack
  4571 C2AC A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4572 C2AE 48				PHA				; put on stack
  4573 C2AF 20 92 BB			JSR	LAB_GVAL		; get value from line
  4574 C2B2 20 97 BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4575 C2B5 68				PLA				; get descriptor pointer low byte back
  4576 C2B6 85 78			STA	ssptr_l			; set pointer low byte
  4577 C2B8 68				PLA				; get descriptor pointer high byte back
  4578 C2B9 85 79			STA	ssptr_h			; set pointer high byte
  4579 C2BB A0 00			LDY	#$00			; clear index
  4580 C2BD B1 78			LDA	(ssptr_l),Y		; get length_1 from descriptor
  4581 C2BF 18				CLC				; clear carry for add
  4582 C2C0 71 6E			ADC	(des_pl),Y		; add length_2
  4583 C2C2 90 05			BCC	LAB_226D		; branch if no overflow
  4584
  4585 C2C4 A2 1A			LDX	#$1A			; else set error code $1A ('String too long' error)
  4586 C2C6 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4587
  4588 C2C9			LAB_226D
  4589 C2C9 20 05 C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4590 									; long
  4591 C2CC 20 E6 C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  4592 C2CF A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4593 C2D1 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4594 C2D3 20 17 C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4595 									; returns with A = length, ut1_pl = pointer low byte,
  4596 									; ut1_ph = pointer high byte
  4597 C2D6 20 F8 C2			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4598 C2D9 A5 78			LDA	ssptr_l			;.set descriptor pointer low byte
  4599 C2DB A4 79			LDY	ssptr_h			;.set descriptor pointer high byte
  4600 C2DD 20 17 C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4601 									; returns with A = length, X=ut1_pl=pointer low byte,
  4602 									; Y=ut1_ph=pointer high byte
  4603 C2E0 20 5A C1			JSR	LAB_RTST		; check for space on descriptor stack then put string
  4604 									; address and length on descriptor stack and update stack
  4605 									; pointers
  4606 C2E3 4C BD BA			JMP	LAB_1ADB		;.continue evaluation
  4607
  4608 				; copy string from descriptor (sdescr) to (Sutill)
  4609 C2E6			LAB_228A
  4610 C2E6 A0 00			LDY	#$00			; clear index
  4611 C2E8 B1 78			LDA	(sdescr),Y		; get string length
  4612 C2EA 48				PHA				; save on stack
  4613 C2EB C8				INY				; increment index
  4614 C2EC B1 78			LDA	(sdescr),Y		; get source string pointer low byte
  4615 C2EE AA				TAX				; copy to X
  4616 C2EF C8				INY				; increment index
  4617 C2F0 B1 78			LDA	(sdescr),Y		; get source string pointer high byte
  4618 C2F2 A8				TAY				; copy to Y
  4619 C2F3 68				PLA				; get length back
  4620
  4621 				; store string A bytes long from YX to (Sutill)
  4622 C2F4			LAB_2298
  4623 C2F4 86 31			STX	ut1_pl			; save source string pointer low byte
  4624 C2F6 84 32			STY	ut1_ph			; save source string pointer high byte
  4625
  4626 				; store string A bytes long from (ut1_pl) to (Sutill)
  4627 C2F8			LAB_229C
  4628 C2F8 AA				TAX				; copy length to index (don't count with Y)
  4629 C2F9 F0 14			BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4630
  4631 C2FB A0 00			LDY	#$00			; zero pointer (copy forward)
  4632 C2FD			LAB_22A0
  4633 C2FD B1 31			LDA	(ut1_pl),Y		; get source byte
  4634 C2FF 91 43			STA	(Sutill),Y		; save destination byte
  4635
  4636 C301 C8				INY				; increment index
  4637 C302 CA				DEX				; decrement counter
  4638 C303 D0 F8			BNE	LAB_22A0		; loop while <> 0
  4639
  4640 C305 98				TYA				; restore length from Y
  4641 C306			LAB_22A9
  4642 C306 18				CLC				; clear carry for add
  4643 C307 65 43			ADC	Sutill			; add string utility ptr low byte
  4644 C309 85 43			STA	Sutill			; save string utility ptr low byte
  4645 C30B 90 02			BCC	LAB_22B2		; branch if no carry
  4646
  4647 C30D E6 44			INC	Sutilh			; else increment string utility ptr high byte
  4648 C30F			LAB_22B2
  4649 C30F 60				RTS
  4650
  4651 				; evaluate string
  4652 C310			LAB_EVST
  4653 C310 20 97 BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4654
  4655 				; pop string off descriptor stack, or from top of string space
  4656 				; returns with A = length, X=pointer low byte, Y=pointer high byte
  4657 C313			LAB_22B6
  4658 C313 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4659 C315 A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4660
  4661 				; pop (YA) descriptor off stack or from top of string space
  4662 				; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4663 C317			LAB_22BA
  4664 C317 85 31			STA	ut1_pl			; save descriptor pointer low byte
  4665 C319 84 32			STY	ut1_ph			; save descriptor pointer high byte
  4666 C31B 20 48 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  4667 C31E 08				PHP				; save status flags
  4668 C31F A0 00			LDY	#$00			; clear index
  4669 C321 B1 31			LDA	(ut1_pl),Y		; get length from string descriptor
  4670 C323 48				PHA				; put on stack
  4671 C324 C8				INY				; increment index
  4672 C325 B1 31			LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
  4673 C327 AA				TAX				; copy to X
  4674 C328 C8				INY				; increment index
  4675 C329 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
  4676 C32B A8				TAY				; copy to Y
  4677 C32C 68				PLA				; get string length back
  4678 C32D 28				PLP				; restore status
  4679 C32E D0 13			BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
  4680
  4681 C330 C4 42			CPY	Sstorh			; compare bottom of string space high byte
  4682 C332 D0 0F			BNE	LAB_22E6		; branch if <>
  4683
  4684 C334 E4 41			CPX	Sstorl			; else compare bottom of string space low byte
  4685 C336 D0 0B			BNE	LAB_22E6		; branch if <>
  4686
  4687 C338 48				PHA				; save string length
  4688 C339 18				CLC				; clear carry for add
  4689 C33A 65 41			ADC	Sstorl			; add bottom of string space low byte
  4690 C33C 85 41			STA	Sstorl			; save bottom of string space low byte
  4691 C33E 90 02			BCC	LAB_22E5		; skip increment if no overflow
  4692
  4693 C340 E6 42			INC	Sstorh			; increment bottom of string space high byte
  4694 C342			LAB_22E5
  4695 C342 68				PLA				; restore string length
  4696 C343			LAB_22E6
  4697 C343 86 31			STX	ut1_pl			; save string pointer low byte
  4698 C345 84 32			STY	ut1_ph			; save string pointer high byte
  4699 C347 60				RTS
  4700
  4701 				; clean descriptor stack, YA = pointer
  4702 				; checks if AY is on the descriptor stack, if so does a stack discard
  4703 C348			LAB_22EB
  4704 C348 C4 27			CPY	last_sh			; compare pointer high byte
  4705 C34A D0 0C			BNE	LAB_22FB		; exit if <>
  4706
  4707 C34C C5 26			CMP	last_sl			; compare pointer low byte
  4708 C34E D0 08			BNE	LAB_22FB		; exit if <>
  4709
  4710 C350 85 25			STA	next_s			; save descriptor stack pointer
  4711 C352 E9 03			SBC	#$03			; -3
  4712 C354 85 26			STA	last_sl			; save low byte -3
  4713 C356 A0 00			LDY	#$00			; clear high byte
  4714 C358			LAB_22FB
  4715 C358 60				RTS
  4716
  4717 				; perform CHR$()
  4718 C359			LAB_CHRS
  4719 C359 20 64 C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  4720 C35C 8A				TXA				; copy to A
  4721 C35D 48				PHA				; save character
  4722 C35E A9 01			LDA	#$01			; string is single byte
  4723 C360 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4724 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4725 C363 68				PLA				; get character back
  4726 C364 A0 00			LDY	#$00			; clear index
  4727 C366 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  4728 C368 4C 5A C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4729 									; address and length on descriptor stack and update stack
  4730 									; pointers
  4731
  4732 				; perform LEFT$()
  4733 C36B			LAB_LEFT
  4734 C36B 48				PHA				; push byte parameter
  4735 C36C 20 CC C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4736 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4737 C36F D1 5E			CMP	(des_2l),Y		; compare byte parameter with string length
  4738 C371 98				TYA				; clear A
  4739 C372 F0 09			BEQ	LAB_2316		; go do string copy (branch always)
  4740
  4741 				; perform RIGHT$()
  4742 C374			LAB_RIGHT
  4743 C374 48				PHA				; push byte parameter
  4744 C375 20 CC C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4745 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4746 C378 18				CLC				; clear carry for add-1
  4747 C379 F1 5E			SBC	(des_2l),Y		; subtract string length
  4748 C37B 49 FF			EOR	#$FF			; invert it (A=LEN(expression$)-l)
  4749
  4750 C37D			LAB_2316
  4751 C37D 90 04			BCC	LAB_231C		; branch if string length > byte parameter
  4752
  4753 C37F B1 5E			LDA	(des_2l),Y		; else make parameter = length
  4754 C381 AA				TAX				; copy to byte parameter copy
  4755 C382 98				TYA				; clear string start offset
  4756 C383			LAB_231C
  4757 C383 48				PHA				; save string start offset
  4758 C384			LAB_231D
  4759 C384 8A				TXA				; copy byte parameter (or string length if <)
  4760 C385			LAB_231E
  4761 C385 48				PHA				; save string length
  4762 C386 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4763 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4764 C389 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4765 C38B A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4766 C38D 20 17 C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4767 									; returns with A = length, X=ut1_pl=pointer low byte,
  4768 									; Y=ut1_ph=pointer high byte
  4769 C390 68				PLA				; get string length back
  4770 C391 A8				TAY				; copy length to Y
  4771 C392 68				PLA				; get string start offset back
  4772 C393 18				CLC				; clear carry for add
  4773 C394 65 31			ADC	ut1_pl			; add start offset to string start pointer low byte
  4774 C396 85 31			STA	ut1_pl			; save string start pointer low byte
  4775 C398 90 02			BCC	LAB_2335		; branch if no overflow
  4776
  4777 C39A E6 32			INC	ut1_ph			; else increment string start pointer high byte
  4778 C39C			LAB_2335
  4779 C39C 98				TYA				; copy length to A
  4780 C39D 20 F8 C2			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4781 C3A0 4C 5A C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4782 									; address and length on descriptor stack and update stack
  4783 									; pointers
  4784
  4785 				; perform MID$()
  4786 C3A3			LAB_MIDS
  4787 C3A3 48				PHA				; push byte parameter
  4788 C3A4 A9 FF			LDA	#$FF			; set default length = 255
  4789 C3A6 85 6F			STA	mids_l			; save default length
  4790 C3A8 20 82 00			JSR	LAB_GBYT		; scan memory
  4791 C3AB C9 29			CMP	#')'			; compare with ')'
  4792 C3AD F0 06			BEQ	LAB_2358		; branch if = ')' (skip second byte get)
  4793
  4794 C3AF 20 C3 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4795 C3B2 20 61 C4			JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
  4796 C3B5			LAB_2358
  4797 C3B5 20 CC C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4798 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4799 C3B8 CA				DEX				; decrement start index
  4800 C3B9 8A				TXA				; copy to A
  4801 C3BA 48				PHA				; save string start offset
  4802 C3BB 18				CLC				; clear carry for sub-1
  4803 C3BC A2 00			LDX	#$00			; clear output string length
  4804 C3BE F1 5E			SBC	(des_2l),Y		; subtract string length
  4805 C3C0 B0 C2			BCS	LAB_231D		; if start>string length go do null string
  4806
  4807 C3C2 49 FF			EOR	#$FF			; complement -length
  4808 C3C4 C5 6F			CMP	mids_l			; compare byte parameter
  4809 C3C6 90 BD			BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4810
  4811 C3C8 A5 6F			LDA	mids_l			; get length byte
  4812 C3CA B0 B9			BCS	LAB_231E		; go do string copy (branch always)
  4813
  4814 				; pull string data and byte parameter from stack
  4815 				; return pointer in des_2l/h, byte in A (and X), Y=0
  4816 C3CC			LAB_236F
  4817 C3CC 20 B4 BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4818 C3CF 68				PLA				; pull return address low byte (return address)
  4819 C3D0 85 62			STA	Fnxjpl			; save functions jump vector low byte
  4820 C3D2 68				PLA				; pull return address high byte (return address)
  4821 C3D3 85 63			STA	Fnxjph			; save functions jump vector high byte
  4822 C3D5 68				PLA				; pull byte parameter
  4823 C3D6 AA				TAX				; copy byte parameter to X
  4824 C3D7 68				PLA				; pull string pointer low byte
  4825 C3D8 85 5E			STA	des_2l			; save it
  4826 C3DA 68				PLA				; pull string pointer high byte
  4827 C3DB 85 5F			STA	des_2h			; save it
  4828 C3DD A0 00			LDY	#$00			; clear index
  4829 C3DF 8A				TXA				; copy byte parameter
  4830 C3E0 F0 79			BEQ	LAB_23A8		; if null do function call error then warm start
  4831
  4832 C3E2 E6 62			INC	Fnxjpl			; increment function jump vector low byte
  4833 									; (JSR pushes return addr-1. this is all very nice
  4834 									; but will go tits up if either call is on a page
  4835 									; boundary!)
  4836 C3E4 6C 62 00			JMP	(Fnxjpl)		; in effect, RTS
  4837
  4838 				; perform LCASE$()
  4839 C3E7			LAB_LCASE
  4840 C3E7 20 10 C3			JSR	LAB_EVST		; evaluate string
  4841 C3EA 85 6C			STA	str_ln			; set string length
  4842 C3EC A8				TAY				; copy length to Y
  4843 C3ED F0 38			BEQ	NoString		; branch if null string
  4844
  4845 C3EF 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4846 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4847 C3F2 86 6D			STX	str_pl			; save string pointer low byte
  4848 C3F4 84 6E			STY	str_ph			; save string pointer high byte
  4849 C3F6 A8				TAY				; get string length back
  4850
  4851 C3F7			LC_loop
  4852 C3F7 88				DEY				; decrement index
  4853 C3F8 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4854 C3FA 20 E9 BD			JSR	LAB_1D82		; is character 'A' to 'Z'
  4855 C3FD 90 02			BCC	NoUcase			; branch if not upper case alpha
  4856
  4857 C3FF 09 20			ORA	#$20			; convert upper to lower case
  4858 C401			NoUcase
  4859 C401 91 43			STA	(Sutill),Y		; save byte back to string
  4860 C403 98				TYA				; test index
  4861 C404 D0 F1			BNE	LC_loop			; loop if not all done
  4862
  4863 C406 F0 1F			BEQ	NoString		; tidy up and exit, branch always
  4864
  4865 				; perform UCASE$()
  4866 C408			LAB_UCASE
  4867 C408 20 10 C3			JSR	LAB_EVST		; evaluate string
  4868 C40B 85 6C			STA	str_ln			; set string length
  4869 C40D A8				TAY				; copy length to Y
  4870 C40E F0 17			BEQ	NoString		; branch if null string
  4871
  4872 C410 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4873 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4874 C413 86 6D			STX	str_pl			; save string pointer low byte
  4875 C415 84 6E			STY	str_ph			; save string pointer high byte
  4876 C417 A8				TAY				; get string length back
  4877
  4878 C418			UC_loop
  4879 C418 88				DEY				; decrement index
  4880 C419 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4881 C41B 20 E5 BD			JSR	LAB_CASC		; is character 'a' to 'z' (or 'A' to 'Z')
  4882 C41E 90 02			BCC	NoLcase			; branch if not alpha
  4883
  4884 C420 29 DF			AND	#$DF			; convert lower to upper case
  4885 C422			NoLcase
  4886 C422 91 43			STA	(Sutill),Y		; save byte back to string
  4887 C424 98				TYA				; test index
  4888 C425 D0 F1			BNE	UC_loop			; loop if not all done
  4889
  4890 C427			NoString
  4891 C427 4C 5A C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4892 									; address and length on descriptor stack and update stack
  4893 									; pointers
  4894
  4895 				; perform SADD()
  4896 C42A			LAB_SADD
  4897 C42A 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4898 C42D 20 71 BD			JSR	LAB_GVAR		; get var address
  4899
  4900 C430 20 B4 BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4901 C433 20 97 BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4902
  4903 C436 A0 02			LDY	#$02			; index to string pointer high byte
  4904 C438 B1 55			LDA	(Cvaral),Y		; get string pointer high byte
  4905 C43A AA				TAX				; copy string pointer high byte to X
  4906 C43B 88				DEY				; index to string pointer low byte
  4907 C43C B1 55			LDA	(Cvaral),Y		; get string pointer low byte
  4908 C43E A8				TAY				; copy string pointer low byte to Y
  4909 C43F 8A				TXA				; copy string pointer high byte to A
  4910 C440 4C 20 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  4911
  4912 				; perform LEN()
  4913 C443			LAB_LENS
  4914 C443 20 49 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4915 C446 4C 39 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4916
  4917 				; evaluate string, get length in Y
  4918 C449			LAB_ESGL
  4919 C449 20 10 C3			JSR	LAB_EVST		; evaluate string
  4920 C44C A8				TAY				; copy length to Y
  4921 C44D 60				RTS
  4922
  4923 				; perform ASC()
  4924 C44E			LAB_ASC
  4925 C44E 20 49 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4926 C451 F0 08			BEQ	LAB_23A8		; if null do function call error then warm start
  4927
  4928 C453 A0 00			LDY	#$00			; set index to first character
  4929 C455 B1 31			LDA	(ut1_pl),Y		; get byte
  4930 C457 A8				TAY				; copy to Y
  4931 C458 4C 39 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4932
  4933 				; do function call error then warm start
  4934 C45B			LAB_23A8
  4935 C45B 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start
  4936
  4937 				; scan and get byte parameter
  4938 C45E			LAB_SGBY
  4939 C45E 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4940
  4941 				; get byte parameter
  4942 C461			LAB_GTBY
  4943 C461 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4944 									; else do type mismatch
  4945
  4946 				; evaluate byte expression, result in X
  4947 C464			LAB_EVBY
  4948 C464 20 69 BE			JSR	LAB_EVPI		; evaluate integer expression (no check)
  4949
  4950 C467 A4 6E			LDY	FAC1_2			; get FAC1 mantissa2
  4951 C469 D0 F0			BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  4952
  4953 C46B A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  4954 C46D 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4955
  4956 				; perform VAL()
  4957 C470			LAB_VAL
  4958 C470 20 49 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4959 C473 D0 03			BNE	LAB_23C5		; branch if not null string
  4960
  4961 									; string was null so set result = $00
  4962 C475 4C 25 C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  4963
  4964 C478			LAB_23C5
  4965 C478 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  4966 C47A A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  4967 C47C 86 7A			STX	Btmpl			; save BASIC execute pointer low byte
  4968 C47E 84 7B			STY	Btmph			; save BASIC execute pointer high byte
  4969 C480 A6 31			LDX	ut1_pl			; get string pointer low byte
  4970 C482 86 83			STX	Bpntrl			; save as BASIC execute pointer low byte
  4971 C484 18				CLC				; clear carry
  4972 C485 65 31			ADC	ut1_pl			; add string length
  4973 C487 85 33			STA	ut2_pl			; save string end low byte
  4974 C489 A5 32			LDA	ut1_ph			; get string pointer high byte
  4975 C48B 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4976 C48D 69 00			ADC	#$00			; add carry to high byte
  4977 C48F 85 34			STA	ut2_ph			; save string end high byte
  4978 C491 A0 00			LDY	#$00			; set index to $00
  4979 C493 B1 33			LDA	(ut2_pl),Y		; get string end +1 byte
  4980 C495 48				PHA				; push it
  4981 C496 98				TYA				; clear A
  4982 C497 91 33			STA	(ut2_pl),Y		; terminate string with $00
  4983 C499 20 82 00			JSR	LAB_GBYT		; scan memory
  4984 C49C 20 7B C9			JSR	LAB_2887		; get FAC1 from string
  4985 C49F 68				PLA				; restore string end +1 byte
  4986 C4A0 A0 00			LDY	#$00			; set index to zero
  4987 C4A2 91 33			STA	(ut2_pl),Y		; put string end byte back
  4988
  4989 				; restore BASIC execute pointer from temp (Btmpl/Btmph)
  4990 C4A4			LAB_23F3
  4991 C4A4 A6 7A			LDX	Btmpl			; get BASIC execute pointer low byte back
  4992 C4A6 A4 7B			LDY	Btmph			; get BASIC execute pointer high byte back
  4993 C4A8 86 83			STX	Bpntrl			; save BASIC execute pointer low byte
  4994 C4AA 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  4995 C4AC 60				RTS
  4996
  4997 				; get two parameters for POKE or WAIT
  4998 C4AD			LAB_GADB
  4999 C4AD 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5000 									; else do type mismatch
  5001 C4B0 20 C6 C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5002
  5003 				; scan for ',' and get byte, else do Syntax error then warm start
  5004 C4B3			LAB_SCGB
  5005 C4B3 20 C3 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5006 C4B6 A5 12			LDA	Itemph			; save temporary integer high byte
  5007 C4B8 48				PHA				; on stack
  5008 C4B9 A5 11			LDA	Itempl			; save temporary integer low byte
  5009 C4BB 48				PHA				; on stack
  5010 C4BC 20 61 C4			JSR	LAB_GTBY		; get byte parameter
  5011 C4BF 68				PLA				; pull low byte
  5012 C4C0 85 11			STA	Itempl			; restore temporary integer low byte
  5013 C4C2 68				PLA				; pull high byte
  5014 C4C3 85 12			STA	Itemph			; restore temporary integer high byte
  5015 C4C5 60				RTS
  5016
  5017 				; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5018 				; -ve and converts it into a right truncated integer in Itempl and Itemph
  5019
  5020 				; save unsigned 16 bit integer part of FAC1 in temporary integer
  5021 C4C6			LAB_F2FX
  5022 C4C6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5023 C4C8 C9 98			CMP	#$98			; compare with exponent = 2^24
  5024 C4CA B0 8F			BCS	LAB_23A8		; if >= do function call error then warm start
  5025
  5026 C4CC			LAB_F2FU
  5027 C4CC 20 25 C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5028 C4CF A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5029 C4D1 A4 6F			LDY	FAC1_3			; get FAC1 mantissa3
  5030 C4D3 84 11			STY	Itempl			; save temporary integer low byte
  5031 C4D5 85 12			STA	Itemph			; save temporary integer high byte
  5032 C4D7 60				RTS
  5033
  5034 				; perform PEEK()
  5035 C4D8			LAB_PEEK
  5036 C4D8 20 C6 C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5037 C4DB A2 00			LDX	#$00			; clear index
  5038 C4DD A1 11			LDA	(Itempl,X)		; get byte via temporary integer (addr)
  5039 C4DF A8				TAY				; copy byte to Y
  5040 C4E0 4C 39 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5041
  5042 				; perform POKE
  5043 C4E3			LAB_POKE
  5044 C4E3 20 AD C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5045 C4E6 8A				TXA				; copy byte argument to A
  5046 C4E7 A2 00			LDX	#$00			; clear index
  5047 C4E9 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  5048 C4EB 60				RTS
  5049
  5050 				; perform DEEK()
  5051 C4EC			LAB_DEEK
  5052 C4EC 20 C6 C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5053 C4EF A2 00			LDX	#$00			; clear index
  5054 C4F1 A1 11			LDA	(Itempl,X)		; PEEK low byte
  5055 C4F3 A8				TAY				; copy to Y
  5056 C4F4 E6 11			INC	Itempl			; increment pointer low byte
  5057 C4F6 D0 02			BNE	Deekh			; skip high increment if no rollover
  5058
  5059 C4F8 E6 12			INC	Itemph			; increment pointer high byte
  5060 C4FA			Deekh
  5061 C4FA A1 11			LDA	(Itempl,X)		; PEEK high byte
  5062 C4FC 4C 20 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  5063
  5064 				; perform DOKE
  5065 C4FF			LAB_DOKE
  5066 C4FF 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5067 									; else do type mismatch
  5068 C502 20 C6 C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5069
  5070 C505 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  5071 C507 85 58			STA	Frnxth			; save pointer high byte
  5072
  5073 C509 20 C3 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5074 C50C 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5075 									; else do type mismatch
  5076 C50F 20 C6 C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5077
  5078 C512 98				TYA				; copy value low byte (float to fixed returns word in AY)
  5079 C513 A2 00			LDX	#$00			; clear index
  5080 C515 81 57			STA	(Frnxtl,X)		; POKE low byte
  5081 C517 E6 57			INC	Frnxtl			; increment pointer low byte
  5082 C519 D0 02			BNE	Dokeh			; skip high increment if no rollover
  5083
  5084 C51B E6 58			INC	Frnxth			; increment pointer high byte
  5085 C51D			Dokeh
  5086 C51D A5 12			LDA	Itemph			; get value high byte
  5087 C51F 81 57			STA	(Frnxtl,X)		; POKE high byte
  5088 C521 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5089
  5090 				; perform SWAP
  5091 C524			LAB_SWAP
  5092 C524 20 71 BD			JSR	LAB_GVAR		; get var1 address
  5093 C527 85 57			STA	Lvarpl			; save var1 address low byte
  5094 C529 84 58			STY	Lvarph			; save var1 address high byte
  5095 C52B A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  5096 C52D 48				PHA				; save data type flag
  5097
  5098 C52E 20 C3 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5099 C531 20 71 BD			JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
  5100 C534 68				PLA				; pull var1 data type flag
  5101 C535 45 1F			EOR	Dtypef			; compare with var2 data type
  5102 C537 D0 10			BNE	SwapErr			; exit if not both the same type  (changed 2022/05/16 by Joerg Walke)
  5103
  5104 C539 A0 03			LDY	#$03			; four bytes to swap (either value or descriptor+1)
  5105 C53B			SwapLp
  5106 C53B B1 57			LDA	(Lvarpl),Y		; get byte from var1
  5107 C53D AA				TAX				; save var1 byte
  5108 C53E B1 55			LDA	(Cvaral),Y		; get byte from var2
  5109 C540 91 57			STA	(Lvarpl),Y		; save byte to var1
  5110 C542 8A				TXA				; restore var1 byte
  5111 C543 91 55			STA	(Cvaral),Y		; save byte to var2
  5112 C545 88				DEY				; decrement index
  5113 C546 10 F3			BPL	SwapLp			; loop until done
  5114
  5115 C548 60				RTS
  5116
  5117 C549			SwapErr
  5118 C549 4C A1 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  5119
  5120 				; perform CALL
  5121 C54C			LAB_CALL
  5122 C54C 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5123 									; else do type mismatch
  5124 C54F 20 C6 C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5125 C552 A9 C5			LDA	#>CallExit		; set return address high byte
  5126 C554 48				PHA				; put on stack
  5127 C555 A9 5A			LDA	#<CallExit-1		; set return address low byte
  5128 C557 48				PHA				; put on stack
  5129 C558 6C 11 00			JMP	(Itempl)		; do indirect jump to user routine
  5130
  5131 				; if the called routine exits correctly then it will return to here. this will then get
  5132 				; the next byte for the interpreter and return
  5133
  5134 C55B			CallExit
  5135 C55B 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5136
  5137 				; perform WAIT
  5138 C55E			LAB_WAIT
  5139 C55E 20 AD C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5140 C561 86 57			STX	Frnxtl			; save byte
  5141 C563 A2 00			LDX	#$00			; clear mask
  5142 C565 20 82 00			JSR	LAB_GBYT		; scan memory
  5143 C568 F0 03			BEQ	LAB_2441		; skip if no third argument
  5144
  5145 C56A 20 B3 C4			JSR	LAB_SCGB		; scan for ',' and get byte, else SN error then warm start
  5146 C56D			LAB_2441
  5147 C56D 86 58			STX	Frnxth			; save EOR argument
  5148 C56F			LAB_2445
  5149 C56F B1 11			LDA	(Itempl),Y		; get byte via temporary integer (addr)
  5150 C571 45 58			EOR	Frnxth			; EOR with second argument (mask)
  5151 C573 25 57			AND	Frnxtl			; AND with first argument (byte)
  5152 C575 F0 F8			BEQ	LAB_2445		; loop if result is zero
  5153
  5154 C577			LAB_244D
  5155 C577 60				RTS
  5156
  5157 				; perform subtraction, FAC1 from (AY)
  5158 C578			LAB_2455
  5159 C578 20 60 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5160
  5161 				; perform subtraction, FAC1 from FAC2
  5162
  5163 C57B			LAB_SUBTRACT
  5164 C57B A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5165 C57D 49 FF			EOR	#$FF			; complement it
  5166 C57F 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5167 C581 45 77			EOR	FAC2_s			; EOR with FAC2 sign (b7)
  5168 C583 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5169 C585 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5170 C587 4C 96 C5			JMP	LAB_ADD			; go add FAC2 to FAC1
  5171
  5172 				; perform addition
  5173 C58A			LAB_2467
  5174 C58A 20 AF C6			JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  5175 C58D 90 4D			BCC	LAB_24A8		;.go subtract mantissas
  5176
  5177 				; add 0.5 to FAC1
  5178 C58F			LAB_244E
  5179 C58F A9 F0			LDA	#<LAB_2A96		; set 0.5 pointer low byte
  5180 C591 A0 D3			LDY	#>LAB_2A96		; set 0.5 pointer high byte
  5181
  5182 				; add (AY) to FAC1
  5183 C593			LAB_246C
  5184 C593 20 60 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5185
  5186 				; add FAC2 to FAC1
  5187 C596			LAB_ADD
  5188 C596 D0 10			BNE	LAB_2474		; branch if FAC1 was not zero
  5189
  5190 				; copy FAC2 to FAC1
  5191 C598			LAB_279B
  5192 C598 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  5193
  5194 				; save FAC1 sign and copy ABS(FAC2) to FAC1
  5195 C59A			LAB_279D
  5196 C59A 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5197 C59C A2 04			LDX	#$04			; 4 bytes to copy
  5198 C59E			LAB_27A1
  5199 C59E B5 72			LDA	FAC1_o,X		; get byte from FAC2,X
  5200 C5A0 95 6B			STA	FAC1_e-1,X		; save byte at FAC1,X
  5201 C5A2 CA				DEX				; decrement count
  5202 C5A3 D0 F9			BNE	LAB_27A1		; loop if not all done
  5203
  5204 C5A5 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5205 C5A7 60				RTS
  5206 									; FAC1 is non zero
  5207 C5A8			LAB_2474
  5208 C5A8 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5209 C5AA 86 63			STX	FAC2_r			; save as FAC2 rounding byte
  5210 C5AC A2 73			LDX	#FAC2_e			; set index to FAC2 exponent addr
  5211 C5AE A5 73			LDA	FAC2_e			; get FAC2 exponent
  5212 C5B0			LAB_247C
  5213 C5B0 A8				TAY				; copy exponent
  5214 C5B1 F0 C4			BEQ	LAB_244D		; exit if zero
  5215
  5216 C5B3 38				SEC				; set carry for subtract
  5217 C5B4 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5218 C5B6 F0 24			BEQ	LAB_24A8		; branch if = (go add mantissa)
  5219
  5220 C5B8 90 12			BCC	LAB_2498		; branch if <
  5221
  5222 									; FAC2>FAC1
  5223 C5BA 84 6C			STY	FAC1_e			; save FAC1 exponent
  5224 C5BC A4 77			LDY	FAC2_s			; get FAC2 sign (b7)
  5225 C5BE 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5226 C5C0 49 FF			EOR	#$FF			; complement A
  5227 C5C2 69 00			ADC	#$00			; +1 (twos complement, carry is set)
  5228 C5C4 A0 00			LDY	#$00			; clear Y
  5229 C5C6 84 63			STY	FAC2_r			; clear FAC2 rounding byte
  5230 C5C8 A2 6C			LDX	#FAC1_e			; set index to FAC1 exponent addr
  5231 C5CA D0 04			BNE	LAB_249C		; branch always
  5232
  5233 C5CC			LAB_2498
  5234 C5CC A0 00			LDY	#$00			; clear Y
  5235 C5CE 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5236 C5D0			LAB_249C
  5237 C5D0 C9 F9			CMP	#$F9			; compare exponent diff with $F9
  5238 C5D2 30 B6			BMI	LAB_2467		; branch if range $79-$F8
  5239
  5240 C5D4 A8				TAY				; copy exponent difference to Y
  5241 C5D5 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5242 C5D7 56 01			LSR	PLUS_1,X		; shift FAC? mantissa1
  5243 C5D9 20 C6 C6			JSR	LAB_2592		; shift FACX Y times right
  5244
  5245 									; exponents are equal now do mantissa subtract
  5246 C5DC			LAB_24A8
  5247 C5DC 24 78			BIT	FAC_sc			; test sign compare (FAC1 EOR FAC2)
  5248 C5DE 10 4C			BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  5249
  5250 C5E0 A0 6C			LDY	#FAC1_e			; set index to FAC1 exponent addr
  5251 C5E2 E0 73			CPX	#FAC2_e			; compare X to FAC2 exponent addr
  5252 C5E4 F0 02			BEQ	LAB_24B4		; branch if =
  5253
  5254 C5E6 A0 73			LDY	#FAC2_e			; else set index to FAC2 exponent addr
  5255
  5256 									; subtract smaller from bigger (take sign of bigger)
  5257 C5E8			LAB_24B4
  5258 C5E8 38				SEC				; set carry for subtract
  5259 C5E9 49 FF			EOR	#$FF			; ones complement A
  5260 C5EB 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5261 C5ED 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5262 C5EF B9 03 00			LDA	PLUS_3,Y		; get FACY mantissa3
  5263 C5F2 F5 03			SBC	PLUS_3,X		; subtract FACX mantissa3
  5264 C5F4 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5265 C5F6 B9 02 00			LDA	PLUS_2,Y		; get FACY mantissa2
  5266 C5F9 F5 02			SBC	PLUS_2,X		; subtract FACX mantissa2
  5267 C5FB 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5268 C5FD B9 01 00			LDA	PLUS_1,Y		; get FACY mantissa1
  5269 C600 F5 01			SBC	PLUS_1,X		; subtract FACX mantissa1
  5270 C602 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5271
  5272 				; do ABS and normalise FAC1
  5273 C604			LAB_24D0
  5274 C604 B0 03			BCS	LAB_24D5		; branch if number is +ve
  5275
  5276 C606 20 6B C6			JSR	LAB_2537		; negate FAC1
  5277
  5278 				; normalise FAC1
  5279 C609			LAB_24D5
  5280 C609 A0 00			LDY	#$00			; clear Y
  5281 C60B 98				TYA				; clear A
  5282 C60C 18				CLC				; clear carry for add
  5283 C60D			LAB_24D9
  5284 C60D A6 6D			LDX	FAC1_1			; get FAC1 mantissa1
  5285 C60F D0 3E			BNE	LAB_251B		; if not zero normalise FAC1
  5286
  5287 C611 A6 6E			LDX	FAC1_2			; get FAC1 mantissa2
  5288 C613 86 6D			STX	FAC1_1			; save FAC1 mantissa1
  5289 C615 A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  5290 C617 86 6E			STX	FAC1_2			; save FAC1 mantissa2
  5291 C619 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5292 C61B 86 6F			STX	FAC1_3			; save FAC1 mantissa3
  5293 C61D 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5294 C61F 69 08			ADC	#$08			; add x to exponent offset
  5295 C621 C9 18			CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5296 C623 D0 E8			BNE	LAB_24D9		; loop if not max
  5297
  5298 				; clear FAC1 exponent and sign
  5299 C625			LAB_24F1
  5300 C625 A9 00			LDA	#$00			; clear A
  5301 C627			LAB_24F3
  5302 C627 85 6C			STA	FAC1_e			; set FAC1 exponent
  5303
  5304 				; save FAC1 sign
  5305 C629			LAB_24F5
  5306 C629 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5307 C62B 60				RTS
  5308
  5309 				; add FAC2 mantissa to FAC1 mantissa
  5310 C62C			LAB_24F8
  5311 C62C 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5312 C62E 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5313 C630 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5314 C632 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5315 C634 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5316 C636 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5317 C638 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5318 C63A 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5319 C63C A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5320 C63E 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5321 C640 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5322 C642 B0 1A			BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  5323
  5324 C644 60				RTS				; else just exit
  5325
  5326 C645			LAB_2511
  5327 C645 69 01			ADC	#$01			; add 1 to exponent offset
  5328 C647 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5329 C649 26 6F			ROL	FAC1_3			; shift FAC1 mantissa3
  5330 C64B 26 6E			ROL	FAC1_2			; shift FAC1 mantissa2
  5331 C64D 26 6D			ROL	FAC1_1			; shift FAC1 mantissa1
  5332
  5333 				; normalise FAC1
  5334 C64F			LAB_251B
  5335 C64F 10 F4			BPL	LAB_2511		; loop if not normalised
  5336
  5337 C651 38				SEC				; set carry for subtract
  5338 C652 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5339 C654 B0 CF			BCS	LAB_24F1		; branch if underflow (set result = $0)
  5340
  5341 C656 49 FF			EOR	#$FF			; complement exponent
  5342 C658 69 01			ADC	#$01			; +1 (twos complement)
  5343 C65A 85 6C			STA	FAC1_e			; save FAC1 exponent
  5344 					
  5345 				; test and normalise FAC1 for C=0/1
  5346 C65C			LAB_2528
  5347 C65C 90 0C			BCC	LAB_2536		; exit if no overflow
  5348
  5349 				; normalise FAC1 for C=1
  5350 C65E			LAB_252A
  5351 C65E E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5352 C660 F0 36			BEQ	LAB_2564		; if zero do overflow error and warm start
  5353
  5354 C662 66 6D			ROR	FAC1_1			; shift FAC1 mantissa1
  5355 C664 66 6E			ROR	FAC1_2			; shift FAC1 mantissa2
  5356 C666 66 6F			ROR	FAC1_3			; shift FAC1 mantissa3
  5357 C668 66 79			ROR	FAC1_r			; shift FAC1 rounding byte
  5358 C66A			LAB_2536
  5359 C66A 60				RTS
  5360
  5361 				; negate FAC1
  5362 C66B			LAB_2537
  5363 C66B A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5364 C66D 49 FF			EOR	#$FF			; complement it
  5365 C66F 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5366
  5367 				; twos complement FAC1 mantissa
  5368 C671			LAB_253D
  5369 C671 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5370 C673 49 FF			EOR	#$FF			; complement it
  5371 C675 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5372 C677 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5373 C679 49 FF			EOR	#$FF			; complement it
  5374 C67B 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5375 C67D A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5376 C67F 49 FF			EOR	#$FF			; complement it
  5377 C681 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5378 C683 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5379 C685 49 FF			EOR	#$FF			; complement it
  5380 C687 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5381 C689 E6 79			INC	FAC1_r			; increment FAC1 rounding byte
  5382 C68B D0 0A			BNE	LAB_2563		; exit if no overflow
  5383
  5384 				; increment FAC1 mantissa
  5385 C68D			LAB_2559
  5386 C68D E6 6F			INC	FAC1_3			; increment FAC1 mantissa3
  5387 C68F D0 06			BNE	LAB_2563		; finished if no rollover
  5388
  5389 C691 E6 6E			INC	FAC1_2			; increment FAC1 mantissa2
  5390 C693 D0 02			BNE	LAB_2563		; finished if no rollover
  5391
  5392 C695 E6 6D			INC	FAC1_1			; increment FAC1 mantissa1
  5393 C697			LAB_2563
  5394 C697 60				RTS
  5395
  5396 				; do overflow error (overflow exit)
  5397 C698			LAB_2564
  5398 C698 A2 0A			LDX	#$0A			; error code $0A ('Overflow' error)
  5399 C69A 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5400
  5401 				; shift FCAtemp << A+8 times
  5402 C69D			LAB_2569
  5403 C69D A2 34			LDX	#FACt_1-1		; set offset to FACtemp
  5404 C69F			LAB_256B
  5405 C69F B4 03			LDY	PLUS_3,X		; get FACX mantissa3
  5406 C6A1 84 79			STY	FAC1_r			; save as FAC1 rounding byte
  5407 C6A3 B4 02			LDY	PLUS_2,X		; get FACX mantissa2
  5408 C6A5 94 03			STY	PLUS_3,X		; save FACX mantissa3
  5409 C6A7 B4 01			LDY	PLUS_1,X		; get FACX mantissa1
  5410 C6A9 94 02			STY	PLUS_2,X		; save FACX mantissa2
  5411 C6AB A4 72			LDY	FAC1_o			; get FAC1 overflow byte
  5412 C6AD 94 01			STY	PLUS_1,X		; save FACX mantissa1
  5413
  5414 				; shift FACX -A times right (> 8 shifts)
  5415 C6AF			LAB_257B
  5416 C6AF 69 08			ADC	#$08			; add 8 to shift count
  5417 C6B1 30 EC			BMI	LAB_256B		; go do 8 shift if still -ve
  5418
  5419 C6B3 F0 EA			BEQ	LAB_256B		; go do 8 shift if zero
  5420
  5421 C6B5 E9 08			SBC	#$08			; else subtract 8 again
  5422 C6B7 A8				TAY				; save count to Y
  5423 C6B8 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5424 C6BA B0 12			BCS	LAB_259A		;.
  5425
  5426 C6BC			LAB_2588
  5427 C6BC 16 01			ASL	PLUS_1,X		; shift FACX mantissa1
  5428 C6BE 90 02			BCC	LAB_258E		; branch if +ve
  5429
  5430 C6C0 F6 01			INC	PLUS_1,X		; this sets b7 eventually
  5431 C6C2			LAB_258E
  5432 C6C2 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5433 C6C4 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5434
  5435 				; shift FACX Y times right
  5436 C6C6			LAB_2592
  5437 C6C6 76 02			ROR	PLUS_2,X		; shift FACX mantissa2
  5438 C6C8 76 03			ROR	PLUS_3,X		; shift FACX mantissa3
  5439 C6CA 6A				ROR				; shift FACX rounding byte
  5440 C6CB C8				INY				; increment exponent diff
  5441 C6CC D0 EE			BNE	LAB_2588		; branch if range adjust not complete
  5442
  5443 C6CE			LAB_259A
  5444 C6CE 18				CLC				; just clear it
  5445 C6CF 60				RTS
  5446
  5447 				; perform LOG()
  5448 C6D0			LAB_LOG
  5449 C6D0 20 BE C8			JSR	LAB_27CA		; test sign and zero
  5450 C6D3 F0 02			BEQ	LAB_25C4		; if zero do function call error then warm start
  5451
  5452 C6D5 10 03			BPL	LAB_25C7		; skip error if +ve
  5453
  5454 C6D7			LAB_25C4
  5455 C6D7 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start (-ve)
  5456
  5457 C6DA			LAB_25C7
  5458 C6DA A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5459 C6DC E9 7F			SBC	#$7F			; normalise it
  5460 C6DE 48				PHA				; save it
  5461 C6DF A9 80			LDA	#$80			; set exponent to zero
  5462 C6E1 85 6C			STA	FAC1_e			; save FAC1 exponent
  5463 C6E3 A9 70			LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5464 C6E5 A0 D3			LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5465 C6E7 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5466 C6EA A9 74			LDA	#<LAB_25B1		; set root2 pointer low byte
  5467 C6EC A0 D3			LDY	#>LAB_25B1		; set root2 pointer high byte
  5468 C6EE 20 D6 C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5469 C6F1 A9 E7			LDA	#<LAB_259C		; set 1 pointer low byte
  5470 C6F3 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  5471 C6F5 20 78 C5			JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5472 C6F8 A9 63			LDA	#<LAB_25A0		; set pointer low byte to counter
  5473 C6FA A0 D3			LDY	#>LAB_25A0		; set pointer high byte to counter
  5474 C6FC 20 26 CC			JSR	LAB_2B6E		; ^2 then series evaluation
  5475 C6FF A9 78			LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5476 C701 A0 D3			LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5477 C703 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1
  5478 C706 68				PLA				; restore FAC1 exponent
  5479 C707 20 1A CA			JSR	LAB_2912		; evaluate new ASCII digit
  5480 C70A A9 7C			LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5481 C70C A0 D3			LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5482
  5483 				; do convert AY, FCA1*(AY)
  5484 C70E			LAB_25FB
  5485 C70E 20 60 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5486 C711			LAB_MULTIPLY
  5487 C711 F0 4C			BEQ	LAB_264C		; exit if zero
  5488
  5489 C713 20 86 C7			JSR	LAB_2673		; test and adjust accumulators
  5490 C716 A9 00			LDA	#$00			; clear A
  5491 C718 85 35			STA	FACt_1			; clear temp mantissa1
  5492 C71A 85 36			STA	FACt_2			; clear temp mantissa2
  5493 C71C 85 37			STA	FACt_3			; clear temp mantissa3
  5494 C71E A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5495 C720 20 35 C7			JSR	LAB_2622		; go do shift/add FAC2
  5496 C723 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5497 C725 20 35 C7			JSR	LAB_2622		; go do shift/add FAC2
  5498 C728 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5499 C72A 20 35 C7			JSR	LAB_2622		; go do shift/add FAC2
  5500 C72D A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5501 C72F 20 3A C7			JSR	LAB_2627		; go do shift/add FAC2
  5502 C732 4C 43 C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5503
  5504 C735			LAB_2622
  5505 C735 D0 03			BNE	LAB_2627		; branch if byte <> zero
  5506
  5507 C737 4C 9D C6			JMP	LAB_2569		; shift FCAtemp << A+8 times
  5508
  5509 									; else do shift and add
  5510 C73A			LAB_2627
  5511 C73A 4A				LSR				; shift byte
  5512 C73B 09 80			ORA	#$80			; set top bit (mark for 8 times)
  5513 C73D			LAB_262A
  5514 C73D A8				TAY				; copy result
  5515 C73E 90 13			BCC	LAB_2640		; skip next if bit was zero
  5516
  5517 C740 18				CLC				; clear carry for add
  5518 C741 A5 37			LDA	FACt_3			; get temp mantissa3
  5519 C743 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5520 C745 85 37			STA	FACt_3			; save temp mantissa3
  5521 C747 A5 36			LDA	FACt_2			; get temp mantissa2
  5522 C749 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5523 C74B 85 36			STA	FACt_2			; save temp mantissa2
  5524 C74D A5 35			LDA	FACt_1			; get temp mantissa1
  5525 C74F 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5526 C751 85 35			STA	FACt_1			; save temp mantissa1
  5527 C753			LAB_2640
  5528 C753 66 35			ROR	FACt_1			; shift temp mantissa1
  5529 C755 66 36			ROR	FACt_2			; shift temp mantissa2
  5530 C757 66 37			ROR	FACt_3			; shift temp mantissa3
  5531 C759 66 79			ROR	FAC1_r			; shift temp rounding byte
  5532 C75B 98				TYA				; get byte back
  5533 C75C 4A				LSR				; shift byte
  5534 C75D D0 DE			BNE	LAB_262A		; loop if all bits not done
  5535
  5536 C75F			LAB_264C
  5537 C75F 60				RTS
  5538
  5539 				; unpack memory (AY) into FAC2
  5540 C760			LAB_264D
  5541 C760 85 31			STA	ut1_pl			; save pointer low byte
  5542 C762 84 32			STY	ut1_ph			; save pointer high byte
  5543 C764 A0 03			LDY	#$03			; 4 bytes to get (0-3)
  5544 C766 B1 31			LDA	(ut1_pl),Y		; get mantissa3
  5545 C768 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5546 C76A 88				DEY				; decrement index
  5547 C76B B1 31			LDA	(ut1_pl),Y		; get mantissa2
  5548 C76D 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5549 C76F 88				DEY				; decrement index
  5550 C770 B1 31			LDA	(ut1_pl),Y		; get mantissa1+sign
  5551 C772 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  5552 C774 45 70			EOR	FAC1_s			; EOR with FAC1 sign (b7)
  5553 C776 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5554 C778 A5 77			LDA	FAC2_s			; recover FAC2 sign (b7)
  5555 C77A 09 80			ORA	#$80			; set 1xxx xxx (set normal bit)
  5556 C77C 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5557 C77E 88				DEY				; decrement index
  5558 C77F B1 31			LDA	(ut1_pl),Y		; get exponent byte
  5559 C781 85 73			STA	FAC2_e			; save FAC2 exponent
  5560 C783 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5561 C785 60				RTS
  5562
  5563 				; test and adjust accumulators
  5564 C786			LAB_2673
  5565 C786 A5 73			LDA	FAC2_e			; get FAC2 exponent
  5566 C788			LAB_2675
  5567 C788 F0 1D			BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5568
  5569 C78A 18				CLC				; clear carry for add
  5570 C78B 65 6C			ADC	FAC1_e			; add FAC1 exponent
  5571 C78D 90 04			BCC	LAB_2680		; branch if sum of exponents <$0100
  5572
  5573 C78F 30 31			BMI	LAB_269B		; do overflow error
  5574
  5575 C791 18				CLC				; clear carry for the add
  5576 C792 2C				.byte	$2C			; makes next line BIT $1410
  5577 C793			LAB_2680
  5578 C793 10 12			BPL	LAB_2696		; if +ve go handle underflow
  5579
  5580 C795 69 80			ADC	#$80			; adjust exponent
  5581 C797 85 6C			STA	FAC1_e			; save FAC1 exponent
  5582 C799 D0 03			BNE	LAB_268B		; branch if not zero
  5583
  5584 C79B 4C 29 C6			JMP	LAB_24F5		; save FAC1 sign and return
  5585
  5586 C79E			LAB_268B
  5587 C79E A5 78			LDA	FAC_sc			; get sign compare (FAC1 EOR FAC2)
  5588 C7A0 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5589 C7A2			LAB_268F
  5590 C7A2 60				RTS
  5591
  5592 				; handle overflow and underflow
  5593 C7A3			LAB_2690
  5594 C7A3 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5595 C7A5 10 1B			BPL	LAB_269B		; do overflow error
  5596
  5597 									; handle underflow
  5598 C7A7			LAB_2696
  5599 C7A7 68				PLA				; pop return address low byte
  5600 C7A8 68				PLA				; pop return address high byte
  5601 C7A9 4C 25 C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5602
  5603 				; multiply by 10
  5604 C7AC			LAB_269E
  5605 C7AC 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5606 C7AF AA				TAX				; copy exponent (set the flags)
  5607 C7B0 F0 F0			BEQ	LAB_268F		; exit if zero
  5608
  5609 C7B2 18				CLC				; clear carry for add
  5610 C7B3 69 02			ADC	#$02			; add two to exponent (*4)
  5611 C7B5 B0 0B			BCS	LAB_269B		; do overflow error if > $FF
  5612
  5613 C7B7 A2 00			LDX	#$00			; clear byte
  5614 C7B9 86 78			STX	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  5615 C7BB 20 B0 C5			JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5616 C7BE E6 6C			INC	FAC1_e			; increment FAC1 exponent (*10)
  5617 C7C0 D0 E0			BNE	LAB_268F		; if non zero just do RTS
  5618
  5619 C7C2			LAB_269B
  5620 C7C2 4C 98 C6			JMP	LAB_2564		; do overflow error and warm start
  5621
  5622 				; divide by 10
  5623 C7C5			LAB_26B9
  5624 C7C5 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5625 C7C8 A9 F8			LDA	#<LAB_26B5		; set pointer to 10d low addr
  5626 C7CA A0 D3			LDY	#>LAB_26B5		; set pointer to 10d high addr
  5627 C7CC A2 00			LDX	#$00			; clear sign
  5628
  5629 				; divide by (AY) (X=sign)
  5630 C7CE			LAB_26C2
  5631 C7CE 86 78			STX	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5632 C7D0 20 52 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5633 C7D3 4C D9 C7			JMP	LAB_DIVIDE		; do FAC2/FAC1
  5634
  5635 									; Perform divide-by
  5636 				; convert AY and do (AY)/FAC1
  5637 C7D6			LAB_26CA
  5638 C7D6 20 60 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5639
  5640 				; Perform divide-into
  5641 C7D9			LAB_DIVIDE
  5642 C7D9 F0 63			BEQ	LAB_2737		; if zero go do /0 error
  5643
  5644 C7DB 20 AE C8			JSR	LAB_27BA		; round FAC1
  5645 C7DE A9 00			LDA	#$00			; clear A
  5646 C7E0 38				SEC				; set carry for subtract
  5647 C7E1 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent (2s complement)
  5648 C7E3 85 6C			STA	FAC1_e			; save FAC1 exponent
  5649 C7E5 20 86 C7			JSR	LAB_2673		; test and adjust accumulators
  5650 C7E8 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5651 C7EA F0 D6			BEQ	LAB_269B		; if zero do overflow error
  5652
  5653 C7EC A2 FF			LDX	#$FF			; set index for pre increment
  5654 C7EE A9 01			LDA	#$01			; set bit to flag byte save
  5655 C7F0			LAB_26E4
  5656 C7F0 A4 74			LDY	FAC2_1			; get FAC2 mantissa1
  5657 C7F2 C4 6D			CPY	FAC1_1			; compare FAC1 mantissa1
  5658 C7F4 D0 0A			BNE	LAB_26F4		; branch if <>
  5659
  5660 C7F6 A4 75			LDY	FAC2_2			; get FAC2 mantissa2
  5661 C7F8 C4 6E			CPY	FAC1_2			; compare FAC1 mantissa2
  5662 C7FA D0 04			BNE	LAB_26F4		; branch if <>
  5663
  5664 C7FC A4 76			LDY	FAC2_3			; get FAC2 mantissa3
  5665 C7FE C4 6F			CPY	FAC1_3			; compare FAC1 mantissa3
  5666 C800			LAB_26F4
  5667 C800 08				PHP				; save FAC2-FAC1 compare status
  5668 C801 2A				ROL				; shift the result byte
  5669 C802 90 0E			BCC	LAB_2702		; if no carry skip the byte save
  5670
  5671 C804 A0 01			LDY	#$01			; set bit to flag byte save
  5672 C806 E8				INX				; else increment the index to FACt
  5673 C807 E0 02			CPX	#$02			; compare with the index to FACt_3
  5674 C809 30 04			BMI	LAB_2701		; if not last byte just go save it
  5675
  5676 C80B D0 28			BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5677 									; return
  5678
  5679 C80D A0 40			LDY	#$40			; set bit to flag byte save for the rounding byte
  5680 C80F			LAB_2701
  5681 C80F 95 35			STA	FACt_1,X		; write result byte to FACt_1 + index
  5682 C811 98				TYA				; copy the next save byte flag
  5683 C812			LAB_2702
  5684 C812 28				PLP				; restore FAC2-FAC1 compare status
  5685 C813 90 14			BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5686
  5687 C815 A8				TAY				; save FAC2-FAC1 compare status
  5688 C816 A5 76			LDA	FAC2_3			; get FAC2 mantissa3
  5689 C818 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5690 C81A 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5691 C81C A5 75			LDA	FAC2_2			; get FAC2 mantissa2
  5692 C81E E5 6E			SBC	FAC1_2			; subtract FAC1 mantissa2
  5693 C820 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5694 C822 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  5695 C824 E5 6D			SBC	FAC1_1			; subtract FAC1 mantissa1
  5696 C826 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5697 C828 98				TYA				; restore FAC2-FAC1 compare status
  5698
  5699 									; FAC2 = FAC2*2
  5700 C829			LAB_2704
  5701 C829 06 76			ASL	FAC2_3			; shift FAC2 mantissa3
  5702 C82B 26 75			ROL	FAC2_2			; shift FAC2 mantissa2
  5703 C82D 26 74			ROL	FAC2_1			; shift FAC2 mantissa1
  5704 C82F B0 CF			BCS	LAB_26F4		; loop with no compare
  5705
  5706 C831 30 BD			BMI	LAB_26E4		; loop with compare
  5707
  5708 C833 10 CB			BPL	LAB_26F4		; loop always with no compare
  5709
  5710 				; do A<<6, save as FAC1 rounding byte, normalise and return
  5711 C835			LAB_272B
  5712 C835 4A				LSR				; shift b1 - b0 ..
  5713 C836 6A				ROR				; ..
  5714 C837 6A				ROR				; .. to b7 - b6
  5715 C838 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5716 C83A 28				PLP				; dump FAC2-FAC1 compare status
  5717 C83B 4C 43 C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5718
  5719 				; do 'Divide by zero' error
  5720 C83E			LAB_2737
  5721 C83E A2 14			LDX	#$14			; error code $14 ('Divide by zero' error)
  5722 C840 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5723
  5724 				; copy temp to FAC1 and normalise
  5725 C843			LAB_273C
  5726 C843 A5 35			LDA	FACt_1			; get temp mantissa1
  5727 C845 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5728 C847 A5 36			LDA	FACt_2			; get temp mantissa2
  5729 C849 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5730 C84B A5 37			LDA	FACt_3			; get temp mantissa3
  5731 C84D 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5732 C84F 4C 09 C6			JMP	LAB_24D5		; normalise FAC1 and return
  5733
  5734 				; unpack memory (AY) into FAC1
  5735 C852			LAB_UFAC
  5736 C852 85 31			STA	ut1_pl			; save pointer low byte
  5737 C854 84 32			STY	ut1_ph			; save pointer high byte
  5738 C856 A0 03			LDY	#$03			; 4 bytes to do
  5739 C858 B1 31			LDA	(ut1_pl),Y		; get last byte
  5740 C85A 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5741 C85C 88				DEY				; decrement index
  5742 C85D B1 31			LDA	(ut1_pl),Y		; get last-1 byte
  5743 C85F 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5744 C861 88				DEY				; decrement index
  5745 C862 B1 31			LDA	(ut1_pl),Y		; get second byte
  5746 C864 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5747 C866 09 80			ORA	#$80			; set 1xxx xxxx (add normal bit)
  5748 C868 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5749 C86A 88				DEY				; decrement index
  5750 C86B B1 31			LDA	(ut1_pl),Y		; get first byte (exponent)
  5751 C86D 85 6C			STA	FAC1_e			; save FAC1 exponent
  5752 C86F 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5753 C871 60				RTS
  5754
  5755 				; pack FAC1 into Adatal
  5756 C872			LAB_276E
  5757 C872 A2 64			LDX	#<Adatal		; set pointer low byte
  5758 C874			LAB_2770
  5759 C874 A0 00			LDY	#>Adatal		; set pointer high byte
  5760 C876 F0 04			BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5761
  5762 				; pack FAC1 into (Lvarpl)
  5763 C878			LAB_PFAC
  5764 C878 A6 57			LDX	Lvarpl			; get destination pointer low byte
  5765 C87A A4 58			LDY	Lvarph			; get destination pointer high byte
  5766
  5767 				; pack FAC1 into (XY)
  5768 C87C			LAB_2778
  5769 C87C 20 AE C8			JSR	LAB_27BA		; round FAC1
  5770 C87F 86 31			STX	ut1_pl			; save pointer low byte
  5771 C881 84 32			STY	ut1_ph			; save pointer high byte
  5772 C883 A0 03			LDY	#$03			; set index
  5773 C885 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5774 C887 91 31			STA	(ut1_pl),Y		; store in destination
  5775 C889 88				DEY				; decrement index
  5776 C88A A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5777 C88C 91 31			STA	(ut1_pl),Y		; store in destination
  5778 C88E 88				DEY				; decrement index
  5779 C88F A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5780 C891 09 7F			ORA	#$7F			; set bits x111 1111
  5781 C893 25 6D			AND	FAC1_1			; AND in FAC1 mantissa1
  5782 C895 91 31			STA	(ut1_pl),Y		; store in destination
  5783 C897 88				DEY				; decrement index
  5784 C898 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5785 C89A 91 31			STA	(ut1_pl),Y		; store in destination
  5786 C89C 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5787 C89E 60				RTS
  5788
  5789 				; round and copy FAC1 to FAC2
  5790 C89F			LAB_27AB
  5791 C89F 20 AE C8			JSR	LAB_27BA		; round FAC1
  5792
  5793 				; copy FAC1 to FAC2
  5794 C8A2			LAB_27AE
  5795 C8A2 A2 05			LDX	#$05			; 5 bytes to copy
  5796 C8A4			LAB_27B0
  5797 C8A4 B5 6B			LDA	FAC1_e-1,X		; get byte from FAC1,X
  5798 C8A6 95 72			STA	FAC1_o,X		; save byte at FAC2,X
  5799 C8A8 CA				DEX				; decrement count
  5800 C8A9 D0 F9			BNE	LAB_27B0		; loop if not all done
  5801
  5802 C8AB 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5803 C8AD			LAB_27B9
  5804 C8AD 60				RTS
  5805
  5806 				; round FAC1
  5807 C8AE			LAB_27BA
  5808 C8AE A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5809 C8B0 F0 FB			BEQ	LAB_27B9		; exit if zero
  5810
  5811 C8B2 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5812 C8B4 90 F7			BCC	LAB_27B9		; exit if no overflow
  5813
  5814 				; round FAC1 (no check)
  5815 C8B6			LAB_27C2
  5816 C8B6 20 8D C6			JSR	LAB_2559		; increment FAC1 mantissa
  5817 C8B9 D0 F2			BNE	LAB_27B9		; branch if no overflow
  5818
  5819 C8BB 4C 5E C6			JMP	LAB_252A		; normalise FAC1 for C=1 and return
  5820
  5821 				; get FAC1 sign
  5822 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5823 C8BE			LAB_27CA
  5824 C8BE A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5825 C8C0 F0 09			BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  5826
  5827 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5828 				; no = 0 check
  5829 C8C2			LAB_27CE
  5830 C8C2 A5 70			LDA	FAC1_s			; else get FAC1 sign (b7)
  5831
  5832 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5833 				; no = 0 check, sign in A
  5834 C8C4			LAB_27D0
  5835 C8C4 2A				ROL				; move sign bit to carry
  5836 C8C5 A9 FF			LDA	#$FF			; set byte for -ve result
  5837 C8C7 B0 02			BCS	LAB_27D7		; return if sign was set (-ve)
  5838
  5839 C8C9 A9 01			LDA	#$01			; else set byte for +ve result
  5840 C8CB			LAB_27D7
  5841 C8CB 60				RTS
  5842
  5843 				; perform SGN()
  5844 C8CC			LAB_SGN
  5845 C8CC 20 BE C8			JSR	LAB_27CA		; get FAC1 sign
  5846 									; return A=$FF/-ve A=$01/+ve
  5847 				; save A as integer byte
  5848 C8CF			LAB_27DB
  5849 C8CF 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5850 C8D1 A9 00			LDA	#$00			; clear A
  5851 C8D3 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5852 C8D5 A2 88			LDX	#$88			; set exponent
  5853
  5854 				; set exp=X, clearFAC1 mantissa3 and normalise
  5855 C8D7			LAB_27E3
  5856 C8D7 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5857 C8D9 49 FF			EOR	#$FF			; complement it
  5858 C8DB 2A				ROL				; sign bit into carry
  5859
  5860 				; set exp=X, clearFAC1 mantissa3 and normalise
  5861 C8DC			LAB_STFA
  5862 C8DC A9 00			LDA	#$00			; clear A
  5863 C8DE 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5864 C8E0 86 6C			STX	FAC1_e			; set FAC1 exponent
  5865 C8E2 85 79			STA	FAC1_r			; clear FAC1 rounding byte
  5866 C8E4 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  5867 C8E6 4C 04 C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5868
  5869 				; perform ABS()
  5870 C8E9			LAB_ABS
  5871 C8E9 46 70			LSR	FAC1_s			; clear FAC1 sign (put zero in b7)
  5872 C8EB 60				RTS
  5873
  5874 				; compare FAC1 with (AY)
  5875 				; returns A=$00 if FAC1 = (AY)
  5876 				; returns A=$01 if FAC1 > (AY)
  5877 				; returns A=$FF if FAC1 < (AY)
  5878 C8EC			LAB_27F8
  5879 C8EC 85 33			STA	ut2_pl			; save pointer low byte
  5880 C8EE			LAB_27FA
  5881 C8EE 84 34			STY	ut2_ph			; save pointer high byte
  5882 C8F0 A0 00			LDY	#$00			; clear index
  5883 C8F2 B1 33			LDA	(ut2_pl),Y		; get exponent
  5884 C8F4 C8				INY				; increment index
  5885 C8F5 AA				TAX				; copy (AY) exponent to X
  5886 C8F6 F0 C6			BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  5887 									; A=FF,C=1/-ve A=01,C=0/+ve
  5888
  5889 C8F8 B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5890 C8FA 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  5891 C8FC 30 C4			BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  5892 									; A=01,C=0/+ve and return
  5893
  5894 C8FE E4 6C			CPX	FAC1_e			; compare (AY) exponent with FAC1 exponent
  5895 C900 D0 1A			BNE	LAB_2828		; branch if different
  5896
  5897 C902 B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5898 C904 09 80			ORA	#$80			; normalise top bit
  5899 C906 C5 6D			CMP	FAC1_1			; compare with FAC1 mantissa1
  5900 C908 D0 12			BNE	LAB_2828		; branch if different
  5901
  5902 C90A C8				INY				; increment index
  5903 C90B B1 33			LDA	(ut2_pl),Y		; get mantissa2
  5904 C90D C5 6E			CMP	FAC1_2			; compare with FAC1 mantissa2
  5905 C90F D0 0B			BNE	LAB_2828		; branch if different
  5906
  5907 C911 C8				INY				; increment index
  5908 C912 A9 7F			LDA	#$7F			; set for 1/2 value rounding byte
  5909 C914 C5 79			CMP	FAC1_r			; compare with FAC1 rounding byte (set carry)
  5910 C916 B1 33			LDA	(ut2_pl),Y		; get mantissa3
  5911 C918 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5912 C91A F0 28			BEQ	LAB_2850		; exit if mantissa3 equal
  5913
  5914 				; gets here if number <> FAC1
  5915 C91C			LAB_2828
  5916 C91C A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5917 C91E 90 02			BCC	LAB_282E		; branch if FAC1 > (AY)
  5918
  5919 C920 49 FF			EOR	#$FF			; else toggle FAC1 sign
  5920 C922			LAB_282E
  5921 C922 4C C4 C8			JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  5922
  5923 				; convert FAC1 floating-to-fixed
  5924 C925			LAB_2831
  5925 C925 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5926 C927 F0 4A			BEQ	LAB_287F		; if zero go clear FAC1 and return
  5927
  5928 C929 38				SEC				; set carry for subtract
  5929 C92A E9 98			SBC	#$98			; subtract maximum integer range exponent
  5930 C92C 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  5931 C92E 10 09			BPL	LAB_2845		; branch if FAC1 +ve
  5932
  5933 									; FAC1 was -ve
  5934 C930 AA				TAX				; copy subtracted exponent
  5935 C931 A9 FF			LDA	#$FF			; overflow for -ve number
  5936 C933 85 72			STA	FAC1_o			; set FAC1 overflow byte
  5937 C935 20 71 C6			JSR	LAB_253D		; twos complement FAC1 mantissa
  5938 C938 8A				TXA				; restore subtracted exponent
  5939 C939			LAB_2845
  5940 C939 A2 6C			LDX	#FAC1_e			; set index to FAC1
  5941 C93B C9 F9			CMP	#$F9			; compare exponent result
  5942 C93D 10 06			BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  5943
  5944 C93F 20 AF C6			JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  5945 C942 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5946 C944			LAB_2850
  5947 C944 60				RTS
  5948
  5949 				; shift FAC1 A times right
  5950 C945			LAB_2851
  5951 C945 A8				TAY				; copy shift count
  5952 C946 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5953 C948 29 80			AND	#$80			; mask sign bit only (x000 0000)
  5954 C94A 46 6D			LSR	FAC1_1			; shift FAC1 mantissa1
  5955 C94C 05 6D			ORA	FAC1_1			; OR sign in b7 FAC1 mantissa1
  5956 C94E 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5957 C950 20 C6 C6			JSR	LAB_2592		; shift FAC1 Y times right
  5958 C953 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5959 C955 60				RTS
  5960
  5961 				; perform INT()
  5962 C956			LAB_INT
  5963 C956 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5964 C958 C9 98			CMP	#$98			; compare with max int
  5965 C95A B0 1E			BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  5966
  5967 C95C 20 25 C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5968 C95F 84 79			STY	FAC1_r			; save FAC1 rounding byte
  5969 C961 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5970 C963 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5971 C965 49 80			EOR	#$80			; toggle FAC1 sign
  5972 C967 2A				ROL				; shift into carry
  5973 C968 A9 98			LDA	#$98			; set new exponent
  5974 C96A 85 6C			STA	FAC1_e			; save FAC1 exponent
  5975 C96C A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5976 C96E 85 1B			STA	Temp3			; save for EXP() function
  5977 C970 4C 04 C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5978
  5979 				; clear FAC1 and return
  5980 C973			LAB_287F
  5981 C973 85 6D			STA	FAC1_1			; clear FAC1 mantissa1
  5982 C975 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5983 C977 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5984 C979 A8				TAY				; clear Y
  5985 C97A			LAB_2886
  5986 C97A 60				RTS
  5987
  5988 				; get FAC1 from string
  5989 				; this routine now handles hex and binary values from strings
  5990 				; starting with '$' and '%' respectively
  5991 C97B			LAB_2887
  5992 C97B A0 00			LDY	#$00			; clear Y
  5993 C97D 84 1F			STY	Dtypef			; clear data type flag, $FF=string, $00=numeric
  5994 C97F A2 09			LDX	#$09			; set index
  5995 C981			LAB_288B
  5996 C981 94 68			STY	numexp,X		; clear byte
  5997 C983 CA				DEX				; decrement index
  5998 C984 10 FB			BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
  5999
  6000 C986 90 7F			BCC	LAB_28FE		; branch if 1st character numeric
  6001
  6002 				; get FAC1 from string .. first character wasn't numeric
  6003 C988 C9 2D			CMP	#'-'			; else compare with '-'
  6004 C98A D0 04			BNE	LAB_289A		; branch if not '-'
  6005
  6006 C98C 86 71			STX	negnum			; set flag for -ve number (X = $FF)
  6007 C98E F0 04			BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  6008
  6009 				; get FAC1 from string .. first character wasn't numeric or -
  6010 C990			LAB_289A
  6011 C990 C9 2B			CMP	#'+'			; else compare with '+'
  6012 C992 D0 05			BNE	LAB_289D		; branch if not '+' (go check for hex/bin)
  6013
  6014 				; was '+' or '-' to start, so get next character
  6015 C994			LAB_289C
  6016 C994 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6017 C997 90 6E			BCC	LAB_28FE		; branch if numeric character
  6018
  6019 				; code here for hex and binary numbers
  6020 C999			LAB_289D
  6021 C999 C9 24			CMP	#'$'			; else compare with '$'
  6022 C99B D0 03			BNE	LAB_NHEX		; branch if not '$'
  6023
  6024 C99D 4C 45 CE			JMP	LAB_CHEX		; branch if '$'
  6025
  6026 C9A0			LAB_NHEX
  6027 C9A0 C9 25			CMP	#'%'			; else compare with '%'
  6028 C9A2 D0 08			BNE	LAB_28A3		; branch if not '%' (continue original code)
  6029
  6030 C9A4 4C 73 CE			JMP	LAB_CBIN		; branch if '%'
  6031
  6032 C9A7			LAB_289E
  6033 C9A7 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  6034 C9AA			LAB_28A1
  6035 C9AA 90 5B			BCC	LAB_28FE		; branch if numeric character
  6036
  6037 				; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6038 C9AC			LAB_28A3
  6039 C9AC C9 2E			CMP	#'.'			; else compare with '.'
  6040 C9AE F0 2E			BEQ	LAB_28D5		; branch if '.'
  6041
  6042 				; get FAC1 from string .. character wasn't numeric, -, + or .
  6043 C9B0 C9 45			CMP	#'E'			; else compare with 'E'
  6044 C9B2 D0 30			BNE	LAB_28DB		; branch if not 'E'
  6045
  6046 									; was 'E' so evaluate exponential part
  6047 C9B4 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6048 C9B7 90 17			BCC	LAB_28C7		; branch if numeric character
  6049
  6050 C9B9 C9 CC			CMP	#TK_MINUS		; else compare with token for -
  6051 C9BB F0 0E			BEQ	LAB_28C2		; branch if token for -
  6052
  6053 C9BD C9 2D			CMP	#'-'			; else compare with '-'
  6054 C9BF F0 0A			BEQ	LAB_28C2		; branch if '-'
  6055
  6056 C9C1 C9 CB			CMP	#TK_PLUS		; else compare with token for +
  6057 C9C3 F0 08			BEQ	LAB_28C4		; branch if token for +
  6058
  6059 C9C5 C9 2B			CMP	#'+'			; else compare with '+'
  6060 C9C7 F0 04			BEQ	LAB_28C4		; branch if '+'
  6061
  6062 C9C9 D0 07			BNE	LAB_28C9		; branch always
  6063
  6064 C9CB			LAB_28C2
  6065 C9CB 66 6B			ROR	expneg			; set exponent -ve flag (C, which=1, into b7)
  6066 C9CD			LAB_28C4
  6067 C9CD 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6068 C9D0			LAB_28C7
  6069 C9D0 90 5B			BCC	LAB_2925		; branch if numeric character
  6070
  6071 C9D2			LAB_28C9
  6072 C9D2 24 6B			BIT	expneg			; test exponent -ve flag
  6073 C9D4 10 0E			BPL	LAB_28DB		; if +ve go evaluate exponent
  6074
  6075 									; else do exponent = -exponent 
  6076 C9D6 A9 00			LDA	#$00			; clear result
  6077 C9D8 38				SEC				; set carry for subtract
  6078 C9D9 E5 69			SBC	expcnt			; subtract exponent byte
  6079 C9DB 4C E6 C9			JMP	LAB_28DD		; go evaluate exponent
  6080
  6081 C9DE			LAB_28D5
  6082 C9DE 66 6A			ROR	numdpf			; set decimal point flag
  6083 C9E0 24 6A			BIT	numdpf			; test decimal point flag
  6084 C9E2 50 C3			BVC	LAB_289E		; branch if only one decimal point so far
  6085
  6086 									; evaluate exponent
  6087 C9E4			LAB_28DB
  6088 C9E4 A5 69			LDA	expcnt			; get exponent count byte
  6089 C9E6			LAB_28DD
  6090 C9E6 38				SEC				; set carry for subtract
  6091 C9E7 E5 68			SBC	numexp			; subtract numerator exponent
  6092 C9E9 85 69			STA	expcnt			; save exponent count byte
  6093 C9EB F0 12			BEQ	LAB_28F6		; branch if no adjustment
  6094
  6095 C9ED 10 09			BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
  6096
  6097 									; else go do FAC1/10^(0-expcnt)
  6098 C9EF			LAB_28E6
  6099 C9EF 20 C5 C7			JSR	LAB_26B9		; divide by 10
  6100 C9F2 E6 69			INC	expcnt			; increment exponent count byte
  6101 C9F4 D0 F9			BNE	LAB_28E6		; loop until all done
  6102
  6103 C9F6 F0 07			BEQ	LAB_28F6		; branch always
  6104
  6105 C9F8			LAB_28EF
  6106 C9F8 20 AC C7			JSR	LAB_269E		; multiply by 10
  6107 C9FB C6 69			DEC	expcnt			; decrement exponent count byte
  6108 C9FD D0 F9			BNE	LAB_28EF		; loop until all done
  6109
  6110 C9FF			LAB_28F6
  6111 C9FF A5 71			LDA	negnum			; get -ve flag
  6112 CA01 30 01			BMI	LAB_28FB		; if -ve do - FAC1 and return
  6113
  6114 CA03 60				RTS
  6115
  6116 				; do - FAC1 and return
  6117 CA04			LAB_28FB
  6118 CA04 4C C9 CB			JMP	LAB_GTHAN		; do - FAC1 and return
  6119
  6120 				; do unsigned FAC1*10+number
  6121 CA07			LAB_28FE
  6122 CA07 48				PHA				; save character
  6123 CA08 24 6A			BIT	numdpf			; test decimal point flag
  6124 CA0A 10 02			BPL	LAB_2905		; skip exponent increment if not set
  6125
  6126 CA0C E6 68			INC	numexp			; else increment number exponent
  6127 CA0E			LAB_2905
  6128 CA0E 20 AC C7			JSR	LAB_269E		; multiply FAC1 by 10
  6129 CA11 68				PLA				; restore character
  6130 CA12 29 0F			AND	#$0F			; convert to binary
  6131 CA14 20 1A CA			JSR	LAB_2912		; evaluate new ASCII digit
  6132 CA17 4C A7 C9			JMP	LAB_289E		; go do next character
  6133
  6134 				; evaluate new ASCII digit
  6135 CA1A			LAB_2912
  6136 CA1A 48				PHA				; save digit
  6137 CA1B 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6138 CA1E 68				PLA				; restore digit
  6139 CA1F 20 CF C8			JSR	LAB_27DB		; save A as integer byte
  6140 CA22 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6141 CA24 45 70			EOR	FAC1_s			; toggle with FAC1 sign (b7)
  6142 CA26 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6143 CA28 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6144 CA2A 4C 96 C5			JMP	LAB_ADD			; add FAC2 to FAC1 and return
  6145
  6146 				; evaluate next character of exponential part of number
  6147 CA2D			LAB_2925
  6148 CA2D A5 69			LDA	expcnt			; get exponent count byte
  6149 CA2F C9 0A			CMP	#$0A			; compare with 10 decimal
  6150 CA31 90 09			BCC	LAB_2934		; branch if less
  6151
  6152 CA33 A9 64			LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  6153 CA35 24 6B			BIT	expneg			; test exponent -ve flag
  6154 CA37 30 0E			BMI	LAB_2942		; branch if -ve
  6155
  6156 CA39 4C 98 C6			JMP	LAB_2564		; else do overflow error
  6157
  6158 CA3C			LAB_2934
  6159 CA3C 0A				ASL				; * 2
  6160 CA3D 0A				ASL				; * 4
  6161 CA3E 65 69			ADC	expcnt			; * 5
  6162 CA40 0A				ASL				; * 10
  6163 CA41 A0 00			LDY	#$00			; set index
  6164 CA43 71 83			ADC	(Bpntrl),Y		; add character (will be $30 too much!)
  6165 CA45 E9 2F			SBC	#'0'-1			; convert character to binary
  6166 CA47			LAB_2942
  6167 CA47 85 69			STA	expcnt			; save exponent count byte
  6168 CA49 4C CD C9			JMP	LAB_28C4		; go get next character
  6169
  6170 				; print ' in line [LINE #]'
  6171 CA4C			LAB_2953
  6172 CA4C A9 14			LDA	#<LAB_LMSG		; point to ' in line ' message low byte
  6173 CA4E A0 DB			LDY	#>LAB_LMSG		; point to ' in line ' message high byte
  6174 CA50 20 99 B8			JSR	LAB_18C3		; print null terminated string from memory
  6175
  6176 									; print Basic line #
  6177 CA53 A5 48			LDA	Clineh			; get current line high byte
  6178 CA55 A6 47			LDX	Clinel			; get current line low byte
  6179
  6180 				; print XA as unsigned integer
  6181 CA57			LAB_295E
  6182 CA57 85 6D			STA	FAC1_1			; save low byte as FAC1 mantissa1
  6183 CA59 86 6E			STX	FAC1_2			; save high byte as FAC1 mantissa2
  6184 CA5B A2 90			LDX	#$90			; set exponent to 16d bits
  6185 CA5D 38				SEC				; set integer is +ve flag
  6186 CA5E 20 DC C8			JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  6187 CA61 A0 00			LDY	#$00			; clear index
  6188 CA63 98				TYA				; clear A
  6189 CA64 20 77 CA			JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  6190 CA67 4C 99 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  6191
  6192 				; convert FAC1 to ASCII string result in (AY)
  6193 				; not any more, moved scratchpad to page 0
  6194 CA6A			LAB_296E
  6195 CA6A A0 01			LDY	#$01			; set index = 1
  6196 CA6C A9 20			LDA	#$20			; character = ' ' (assume +ve)
  6197 CA6E 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  6198 CA70 10 02			BPL	LAB_2978		; branch if +ve
  6199
  6200 CA72 A9 2D			LDA	#$2D			; else character = '-'
  6201 CA74			LAB_2978
  6202 CA74 99 9D 00			STA	Decss,Y			; save leading character (' ' or '-')
  6203 CA77			LAB_297B
  6204 CA77 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6205 CA79 84 7A			STY	Sendl			; save index
  6206 CA7B C8				INY				; increment index
  6207 CA7C A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6208 CA7E D0 05			BNE	LAB_2989		; branch if FAC1<>0
  6209
  6210 									; exponent was $00 so FAC1 is 0
  6211 CA80 A9 30			LDA	#'0'			; set character = '0'
  6212 CA82 4C 83 CB			JMP	LAB_2A89		; save last character, [EOT] and exit
  6213
  6214 									; FAC1 is some non zero value
  6215 CA85			LAB_2989
  6216 CA85 A9 00			LDA	#$00			; clear (number exponent count)
  6217 CA87 E0 81			CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  6218
  6219 CA89 B0 09			BCS	LAB_299A		; branch if FAC1=>1
  6220
  6221 									; FAC1<1
  6222 CA8B A9 88			LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  6223 CA8D A0 D3			LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  6224 CA8F 20 0E C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6225 CA92 A9 FA			LDA	#$FA			; set number exponent count (-6)
  6226 CA94			LAB_299A
  6227 CA94 85 68			STA	numexp			; save number exponent count
  6228 CA96			LAB_299C
  6229 CA96 A9 84			LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  6230 CA98 A0 D3			LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  6231 CA9A 20 EC C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  6232 CA9D F0 1E			BEQ	LAB_29C3		; exit if FAC1 = (AY)
  6233
  6234 CA9F 10 12			BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  6235
  6236 									; FAC1 < (AY)
  6237 CAA1			LAB_29A7
  6238 CAA1 A9 80			LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  6239 CAA3 A0 D3			LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  6240 CAA5 20 EC C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  6241 CAA8 F0 02			BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  6242
  6243 CAAA 10 0E			BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  6244
  6245 									; FAC1 <= (AY)
  6246 CAAC			LAB_29B2
  6247 CAAC 20 AC C7			JSR	LAB_269E		; multiply by 10
  6248 CAAF C6 68			DEC	numexp			; decrement number exponent count
  6249 CAB1 D0 EE			BNE	LAB_29A7		; go test again (branch always)
  6250
  6251 CAB3			LAB_29B9
  6252 CAB3 20 C5 C7			JSR	LAB_26B9		; divide by 10
  6253 CAB6 E6 68			INC	numexp			; increment number exponent count
  6254 CAB8 D0 DC			BNE	LAB_299C		; go test again (branch always)
  6255
  6256 				; now we have just the digits to do
  6257 CABA			LAB_29C0
  6258 CABA 20 8F C5			JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  6259 CABD			LAB_29C3
  6260 CABD 20 25 C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6261 CAC0 A2 01			LDX	#$01			; set default digits before dp = 1
  6262 CAC2 A5 68			LDA	numexp			; get number exponent count
  6263 CAC4 18				CLC				; clear carry for add
  6264 CAC5 69 07			ADC	#$07			; up to 6 digits before point
  6265 CAC7 30 09			BMI	LAB_29D8		; if -ve then 1 digit before dp
  6266
  6267 CAC9 C9 08			CMP	#$08			; A>=8 if n>=1E6
  6268 CACB B0 06			BCS	LAB_29D9		; branch if >= $08
  6269
  6270 									; carry is clear
  6271 CACD 69 FF			ADC	#$FF			; take 1 from digit count
  6272 CACF AA				TAX				; copy to A
  6273 CAD0 A9 02			LDA	#$02			;.set exponent adjust
  6274 CAD2			LAB_29D8
  6275 CAD2 38				SEC				; set carry for subtract
  6276 CAD3			LAB_29D9
  6277 CAD3 E9 02			SBC	#$02			; -2
  6278 CAD5 85 69			STA	expcnt			;.save exponent adjust
  6279 CAD7 86 68			STX	numexp			; save digits before dp count
  6280 CAD9 8A				TXA				; copy to A
  6281 CADA F0 02			BEQ	LAB_29E4		; branch if no digits before dp
  6282
  6283 CADC 10 13			BPL	LAB_29F7		; branch if digits before dp
  6284
  6285 CADE			LAB_29E4
  6286 CADE A4 7A			LDY	Sendl			; get output string index
  6287 CAE0 A9 2E			LDA	#$2E			; character '.'
  6288 CAE2 C8				INY				; increment index
  6289 CAE3 99 9D 00			STA	Decss,Y			; save to output string
  6290 CAE6 8A				TXA				;.
  6291 CAE7 F0 06			BEQ	LAB_29F5		;.
  6292
  6293 CAE9 A9 30			LDA	#'0'			; character '0'
  6294 CAEB C8				INY				; increment index
  6295 CAEC 99 9D 00			STA	Decss,Y			; save to output string
  6296 CAEF			LAB_29F5
  6297 CAEF 84 7A			STY	Sendl			; save output string index
  6298 CAF1			LAB_29F7
  6299 CAF1 A0 00			LDY	#$00			; clear index (point to 100,000)
  6300 CAF3 A2 80			LDX	#$80			; 
  6301 CAF5			LAB_29FB
  6302 CAF5 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  6303 CAF7 18				CLC				; clear carry for add
  6304 CAF8 79 FE D3			ADC	LAB_2A9C,Y		; add -ve LSB
  6305 CAFB 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  6306 CAFD A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  6307 CAFF 79 FD D3			ADC	LAB_2A9B,Y		; add -ve NMSB
  6308 CB02 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  6309 CB04 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  6310 CB06 79 FC D3			ADC	LAB_2A9A,Y		; add -ve MSB
  6311 CB09 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  6312 CB0B E8				INX				; 
  6313 CB0C B0 04			BCS	LAB_2A18		; 
  6314
  6315 CB0E 10 E5			BPL	LAB_29FB		; not -ve so try again
  6316
  6317 CB10 30 02			BMI	LAB_2A1A		; 
  6318
  6319 CB12			LAB_2A18
  6320 CB12 30 E1			BMI	LAB_29FB		; 
  6321
  6322 CB14			LAB_2A1A
  6323 CB14 8A				TXA				; 
  6324 CB15 90 04			BCC	LAB_2A21		; 
  6325
  6326 CB17 49 FF			EOR	#$FF			; 
  6327 CB19 69 0A			ADC	#$0A			; 
  6328 CB1B			LAB_2A21
  6329 CB1B 69 2F			ADC	#'0'-1			; add '0'-1 to result
  6330 CB1D C8				INY				; increment index ..
  6331 CB1E C8				INY				; .. to next less ..
  6332 CB1F C8				INY				; .. power of ten
  6333 CB20 84 55			STY	Cvaral			; save as current var address low byte
  6334 CB22 A4 7A			LDY	Sendl			; get output string index
  6335 CB24 C8				INY				; increment output string index
  6336 CB25 AA				TAX				; copy character to X
  6337 CB26 29 7F			AND	#$7F			; mask out top bit
  6338 CB28 99 9D 00			STA	Decss,Y			; save to output string
  6339 CB2B C6 68			DEC	numexp			; decrement # of characters before the dp
  6340 CB2D D0 06			BNE	LAB_2A3B		; branch if still characters to do
  6341
  6342 									; else output the point
  6343 CB2F A9 2E			LDA	#$2E			; character '.'
  6344 CB31 C8				INY				; increment output string index
  6345 CB32 99 9D 00			STA	Decss,Y			; save to output string
  6346 CB35			LAB_2A3B
  6347 CB35 84 7A			STY	Sendl			; save output string index
  6348 CB37 A4 55			LDY	Cvaral			; get current var address low byte
  6349 CB39 8A				TXA				; get character back
  6350 CB3A 49 FF			EOR	#$FF			; 
  6351 CB3C 29 80			AND	#$80			; 
  6352 CB3E AA				TAX				; 
  6353 CB3F C0 12			CPY	#$12			; compare index with max
  6354 CB41 D0 B2			BNE	LAB_29FB		; loop if not max
  6355
  6356 									; now remove trailing zeroes
  6357 CB43 A4 7A			LDY	Sendl			; get output string index
  6358 CB45			LAB_2A4B
  6359 CB45 B9 9D 00			LDA	Decss,Y			; get character from output string
  6360 CB48 88				DEY				; decrement output string index
  6361 CB49 C9 30			CMP	#'0'			; compare with '0'
  6362 CB4B F0 F8			BEQ	LAB_2A4B		; loop until non '0' character found
  6363
  6364 CB4D C9 2E			CMP	#'.'			; compare with '.'
  6365 CB4F F0 01			BEQ	LAB_2A58		; branch if was dp
  6366
  6367 									; restore last character
  6368 CB51 C8				INY				; increment output string index
  6369 CB52			LAB_2A58
  6370 CB52 A9 2B			LDA	#$2B			; character '+'
  6371 CB54 A6 69			LDX	expcnt			; get exponent count
  6372 CB56 F0 2E			BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6373
  6374 									; exponent isn't zero so write exponent
  6375 CB58 10 08			BPL	LAB_2A68		; branch if exponent count +ve
  6376
  6377 CB5A A9 00			LDA	#$00			; clear A
  6378 CB5C 38				SEC				; set carry for subtract
  6379 CB5D E5 69			SBC	expcnt			; subtract exponent count adjust (convert -ve to +ve)
  6380 CB5F AA				TAX				; copy exponent count to X
  6381 CB60 A9 2D			LDA	#'-'			; character '-'
  6382 CB62			LAB_2A68
  6383 CB62 99 9F 00			STA	Decss+2,Y		; save to output string
  6384 CB65 A9 45			LDA	#$45			; character 'E'
  6385 CB67 99 9E 00			STA	Decss+1,Y		; save exponent sign to output string
  6386 CB6A 8A				TXA				; get exponent count back
  6387 CB6B A2 2F			LDX	#'0'-1			; one less than '0' character
  6388 CB6D 38				SEC				; set carry for subtract
  6389 CB6E			LAB_2A74
  6390 CB6E E8				INX				; increment 10's character
  6391 CB6F E9 0A			SBC	#$0A			;.subtract 10 from exponent count
  6392 CB71 B0 FB			BCS	LAB_2A74		; loop while still >= 0
  6393
  6394 CB73 69 3A			ADC	#':'			; add character ':' ($30+$0A, result is 10 less that value)
  6395 CB75 99 A1 00			STA	Decss+4,Y		; save to output string
  6396 CB78 8A				TXA				; copy 10's character
  6397 CB79 99 A0 00			STA	Decss+3,Y		; save to output string
  6398 CB7C A9 00			LDA	#$00			; set null terminator
  6399 CB7E 99 A2 00			STA	Decss+5,Y		; save to output string
  6400 CB81 F0 08			BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6401
  6402 									; save last character, [EOT] and exit
  6403 CB83			LAB_2A89
  6404 CB83 99 9D 00			STA	Decss,Y			; save last character to output string
  6405
  6406 									; set null terminator and exit
  6407 CB86			LAB_2A8C
  6408 CB86 A9 00			LDA	#$00			; set null terminator
  6409 CB88 99 9E 00			STA	Decss+1,Y		; save after last character
  6410
  6411 									; set string pointer (AY) and exit
  6412 CB8B			LAB_2A91
  6413 CB8B A9 9E			LDA	#<Decssp1		; set result string low pointer
  6414 CB8D A0 00			LDY	#>Decssp1		; set result string high pointer
  6415 CB8F 60				RTS
  6416
  6417 				; perform power function
  6418 CB90			LAB_POWER
  6419 CB90 F0 42			BEQ	LAB_EXP			; go do  EXP()
  6420
  6421 CB92 A5 73			LDA	FAC2_e			; get FAC2 exponent
  6422 CB94 D0 03			BNE	LAB_2ABF		; branch if FAC2<>0
  6423
  6424 CB96 4C 27 C6			JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6425
  6426 CB99			LAB_2ABF
  6427 CB99 A2 5C			LDX	#<func_l		; set destination pointer low byte
  6428 CB9B A0 00			LDY	#>func_l		; set destination pointer high byte
  6429 CB9D 20 7C C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6430 CBA0 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6431 CBA2 10 0F			BPL	LAB_2AD9		; branch if FAC2>0
  6432
  6433 									; else FAC2 is -ve and can only be raised to an
  6434 									; integer power which gives an x +j0 result
  6435 CBA4 20 56 C9			JSR	LAB_INT			; perform INT
  6436 CBA7 A9 5C			LDA	#<func_l		; set source pointer low byte
  6437 CBA9 A0 00			LDY	#>func_l		; set source pointer high byte
  6438 CBAB 20 EC C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  6439 CBAE D0 03			BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6440 									; this will leave FAC1 -ve and cause a Function Call
  6441 									; error when LOG() is called
  6442
  6443 CBB0 98				TYA				; clear sign b7
  6444 CBB1 A4 1B			LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
  6445 									; for possible later negation, b0
  6446 CBB3			LAB_2AD9
  6447 CBB3 20 9A C5			JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6448 CBB6 98				TYA				; copy sign back ..
  6449 CBB7 48				PHA				; .. and save it
  6450 CBB8 20 D0 C6			JSR	LAB_LOG			; do LOG(n)
  6451 CBBB A9 5C			LDA	#<garb_l		; set pointer low byte
  6452 CBBD A0 00			LDY	#>garb_l		; set pointer high byte
  6453 CBBF 20 0E C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6454 CBC2 20 D4 CB			JSR	LAB_EXP			; go do EXP(n)
  6455 CBC5 68				PLA				; pull sign from stack
  6456 CBC6 4A				LSR				; b0 is to be tested, shift to Cb
  6457 CBC7 90 0A			BCC	LAB_2AF9		; if no bit then exit
  6458
  6459 									; Perform negation
  6460 				; do - FAC1
  6461 CBC9			LAB_GTHAN
  6462 CBC9 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6463 CBCB F0 06			BEQ	LAB_2AF9		; exit if FAC1_e = $00
  6464
  6465 CBCD A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6466 CBCF 49 FF			EOR	#$FF			; complement it
  6467 CBD1 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  6468 CBD3			LAB_2AF9
  6469 CBD3 60				RTS
  6470
  6471 				; perform EXP()	(x^e)
  6472 CBD4			LAB_EXP
  6473 CBD4 A9 8C			LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6474 CBD6 A0 D3			LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6475 CBD8 20 0E C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6476 CBDB A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  6477 CBDD 69 50			ADC	#$50			; +$50/$100
  6478 CBDF 90 03			BCC	LAB_2B2B		; skip rounding if no carry
  6479
  6480 CBE1 20 B6 C8			JSR	LAB_27C2		; round FAC1 (no check)
  6481 CBE4			LAB_2B2B
  6482 CBE4 85 63			STA	FAC2_r			; save FAC2 rounding byte
  6483 CBE6 20 A2 C8			JSR	LAB_27AE		; copy FAC1 to FAC2
  6484 CBE9 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6485 CBEB C9 88			CMP	#$88			; compare with EXP limit (256d)
  6486 CBED 90 03			BCC	LAB_2B39		; branch if less
  6487
  6488 CBEF			LAB_2B36
  6489 CBEF 20 A3 C7			JSR	LAB_2690		; handle overflow and underflow
  6490 CBF2			LAB_2B39
  6491 CBF2 20 56 C9			JSR	LAB_INT			; perform INT
  6492 CBF5 A5 1B			LDA	Temp3			; get mantissa 3 from INT() function
  6493 CBF7 18				CLC				; clear carry for add
  6494 CBF8 69 81			ADC	#$81			; normalise +1
  6495 CBFA F0 F3			BEQ	LAB_2B36		; if $00 go handle overflow
  6496
  6497 CBFC 38				SEC				; set carry for subtract
  6498 CBFD E9 01			SBC	#$01			; now correct for exponent
  6499 CBFF 48				PHA				; save FAC2 exponent
  6500
  6501 									; swap FAC1 and FAC2
  6502 CC00 A2 04			LDX	#$04			; 4 bytes to do
  6503 CC02			LAB_2B49
  6504 CC02 B5 73			LDA	FAC2_e,X		; get FAC2,X
  6505 CC04 B4 6C			LDY	FAC1_e,X		; get FAC1,X
  6506 CC06 95 6C			STA	FAC1_e,X		; save FAC1,X
  6507 CC08 94 73			STY	FAC2_e,X		; save FAC2,X
  6508 CC0A CA				DEX				; decrement count/index
  6509 CC0B 10 F5			BPL	LAB_2B49		; loop if not all done
  6510
  6511 CC0D A5 63			LDA	FAC2_r			; get FAC2 rounding byte
  6512 CC0F 85 79			STA	FAC1_r			; save as FAC1 rounding byte
  6513 CC11 20 7B C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6514 CC14 20 C9 CB			JSR	LAB_GTHAN		; do - FAC1
  6515 CC17 A9 90			LDA	#<LAB_2AFE		; set counter pointer low byte
  6516 CC19 A0 D3			LDY	#>LAB_2AFE		; set counter pointer high byte
  6517 CC1B 20 3C CC			JSR	LAB_2B84		; go do series evaluation
  6518 CC1E A9 00			LDA	#$00			; clear A
  6519 CC20 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6520 CC22 68				PLA				;.get saved FAC2 exponent
  6521 CC23 4C 88 C7			JMP	LAB_2675		; test and adjust accumulators and return
  6522
  6523 				; ^2 then series evaluation
  6524 CC26			LAB_2B6E
  6525 CC26 85 7A			STA	Cptrl			; save count pointer low byte
  6526 CC28 84 7B			STY	Cptrh			; save count pointer high byte
  6527 CC2A 20 72 C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6528 CC2D A9 64			LDA	#<Adatal		; set pointer low byte (Y already $00)
  6529 CC2F 20 0E C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6530 CC32 20 40 CC			JSR	LAB_2B88		; go do series evaluation
  6531 CC35 A9 64			LDA	#<Adatal		; pointer to original # low byte
  6532 CC37 A0 00			LDY	#>Adatal		; pointer to original # high byte
  6533 CC39 4C 0E C7			JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6534
  6535 				; series evaluation
  6536 CC3C			LAB_2B84
  6537 CC3C 85 7A			STA	Cptrl			; save count pointer low byte
  6538 CC3E 84 7B			STY	Cptrh			; save count pointer high byte
  6539 CC40			LAB_2B88
  6540 CC40 A2 68			LDX	#<numexp		; set pointer low byte
  6541 CC42 20 74 C8			JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
  6542 CC45 B1 7A			LDA	(Cptrl),Y		; get constants count
  6543 CC47 85 71			STA	numcon			; save constants count
  6544 CC49 A4 7A			LDY	Cptrl			; get count pointer low byte
  6545 CC4B C8				INY				; increment it (now constants pointer)
  6546 CC4C 98				TYA				; copy it
  6547 CC4D D0 02			BNE	LAB_2B97		; skip next if no overflow
  6548
  6549 CC4F E6 7B			INC	Cptrh			; else increment high byte
  6550 CC51			LAB_2B97
  6551 CC51 85 7A			STA	Cptrl			; save low byte
  6552 CC53 A4 7B			LDY	Cptrh			; get high byte
  6553 CC55			LAB_2B9B
  6554 CC55 20 0E C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6555 CC58 A5 7A			LDA	Cptrl			; get constants pointer low byte
  6556 CC5A A4 7B			LDY	Cptrh			; get constants pointer high byte
  6557 CC5C 18				CLC				; clear carry for add
  6558 CC5D 69 04			ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6559 CC5F 90 01			BCC	LAB_2BA8		; skip next if no overflow
  6560
  6561 CC61 C8				INY				; increment high byte
  6562 CC62			LAB_2BA8
  6563 CC62 85 7A			STA	Cptrl			; save pointer low byte
  6564 CC64 84 7B			STY	Cptrh			; save pointer high byte
  6565 CC66 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1
  6566 CC69 A9 68			LDA	#<numexp		; set pointer low byte to partial @ numexp
  6567 CC6B A0 00			LDY	#>numexp		; set pointer high byte to partial @ numexp
  6568 CC6D C6 71			DEC	numcon			; decrement constants count
  6569 CC6F D0 E4			BNE	LAB_2B9B		; loop until all done
  6570
  6571 CC71 60				RTS
  6572
  6573 				; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6574 				; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6575 				; the Galois method and a sample of 65536 bytes produced gives the following values.
  6576
  6577 				; Entropy = 7.997442 bits per byte
  6578 				; Optimum compression would reduce these 65536 bytes by 0 percent
  6579
  6580 				; Chi square distribution for 65536 samples is 232.01, and
  6581 				; randomly would exceed this value 75.00 percent of the time
  6582
  6583 				; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6584 				; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6585 				; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6586 CC72			LAB_RND
  6587 CC72 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6588 CC74 F0 07			BEQ	NextPRN			; do next random # if zero
  6589
  6590 									; else get seed into random number store
  6591 CC76 A2 98			LDX	#Rbyte4			; set PRNG pointer low byte
  6592 CC78 A0 00			LDY	#$00			; set PRNG pointer high byte
  6593 CC7A 20 7C C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6594 CC7D			NextPRN
  6595 CC7D A2 AF			LDX	#$AF			; set EOR byte
  6596 CC7F A0 13			LDY	#$13			; do this nineteen times
  6597 CC81			LoopPRN
  6598 CC81 06 99			ASL	Rbyte1			; shift PRNG most significant byte
  6599 CC83 26 9A			ROL	Rbyte2			; shift PRNG middle byte
  6600 CC85 26 9B			ROL	Rbyte3			; shift PRNG least significant byte
  6601 CC87 26 98			ROL	Rbyte4			; shift PRNG extra byte
  6602 CC89 90 05			BCC	Ninc1			; branch if bit 32 clear
  6603
  6604 CC8B 8A				TXA				; set EOR byte
  6605 CC8C 45 99			EOR	Rbyte1			; EOR PRNG extra byte
  6606 CC8E 85 99			STA	Rbyte1			; save new PRNG extra byte
  6607 CC90			Ninc1
  6608 CC90 88				DEY				; decrement loop count
  6609 CC91 D0 EE			BNE	LoopPRN			; loop if not all done
  6610
  6611 CC93 A2 02			LDX	#$02			; three bytes to copy
  6612 CC95			CopyPRNG
  6613 CC95 B5 99			LDA	Rbyte1,X		; get PRNG byte
  6614 CC97 95 6D			STA	FAC1_1,X		; save FAC1 byte
  6615 CC99 CA				DEX
  6616 CC9A 10 F9			BPL	CopyPRNG		; loop if not complete
  6617
  6618 CC9C A9 80			LDA	#$80			; set the exponent
  6619 CC9E 85 6C			STA	FAC1_e			; save FAC1 exponent
  6620
  6621 CCA0 0A				ASL				; clear A
  6622 CCA1 85 70			STA	FAC1_s			; save FAC1 sign
  6623
  6624 CCA3 4C 09 C6			JMP	LAB_24D5		; normalise FAC1 and return
  6625
  6626 				; perform COS()
  6627 CCA6			LAB_COS
  6628 CCA6 A9 AD			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6629 CCA8 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6630 CCAA 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1
  6631
  6632 				; perform SIN()
  6633 CCAD			LAB_SIN
  6634 CCAD 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6635 CCB0 A9 C2			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6636 CCB2 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6637 CCB4 A6 77			LDX	FAC2_s			; get FAC2 sign (b7)
  6638 CCB6 20 CE C7			JSR	LAB_26C2		; divide by (AY) (X=sign)
  6639 CCB9 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6640 CCBC 20 56 C9			JSR	LAB_INT			; perform INT
  6641 CCBF A9 00			LDA	#$00			; clear byte
  6642 CCC1 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6643 CCC3 20 7B C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6644 CCC6 A9 F4			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6645 CCC8 A0 D3			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6646 CCCA 20 78 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6647 CCCD A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6648 CCCF 48				PHA				; save FAC1 sign
  6649 CCD0 10 0D			BPL	LAB_2C35		; branch if +ve
  6650
  6651 									; FAC1 sign was -ve
  6652 CCD2 20 8F C5			JSR	LAB_244E		; add 0.5 to FAC1
  6653 CCD5 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6654 CCD7 30 09			BMI	LAB_2C38		; branch if -ve
  6655
  6656 CCD9 A5 23			LDA	Cflag			; get comparison evaluation flag
  6657 CCDB 49 FF			EOR	#$FF			; toggle flag
  6658 CCDD 85 23			STA	Cflag			; save comparison evaluation flag
  6659 CCDF			LAB_2C35
  6660 CCDF 20 C9 CB			JSR	LAB_GTHAN		; do - FAC1
  6661 CCE2			LAB_2C38
  6662 CCE2 A9 F4			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6663 CCE4 A0 D3			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6664 CCE6 20 93 C5			JSR	LAB_246C		; add (AY) to FAC1
  6665 CCE9 68				PLA				; restore FAC1 sign
  6666 CCEA 10 03			BPL	LAB_2C45		; branch if was +ve
  6667
  6668 									; else correct FAC1
  6669 CCEC 20 C9 CB			JSR	LAB_GTHAN		; do - FAC1
  6670 CCEF			LAB_2C45
  6671 CCEF A9 B1			LDA	#<LAB_2C84		; set pointer low byte to counter
  6672 CCF1 A0 D3			LDY	#>LAB_2C84		; set pointer high byte to counter
  6673 CCF3 4C 26 CC			JMP	LAB_2B6E		; ^2 then series evaluation and return
  6674
  6675 				; perform TAN()
  6676 CCF6			LAB_TAN
  6677 CCF6 20 72 C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6678 CCF9 A9 00			LDA	#$00			; clear byte
  6679 CCFB 85 23			STA	Cflag			; clear comparison evaluation flag
  6680 CCFD 20 AD CC			JSR	LAB_SIN			; go do SIN(n)
  6681 CD00 A2 5C			LDX	#<func_l		; set sin(n) pointer low byte
  6682 CD02 A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6683 CD04 20 7C C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6684 CD07 A9 64			LDA	#<Adatal		; set n pointer low addr
  6685 CD09 A0 00			LDY	#>Adatal		; set n pointer high addr
  6686 CD0B 20 52 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6687 CD0E A9 00			LDA	#$00			; clear byte
  6688 CD10 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6689 CD12 A5 23			LDA	Cflag			; get comparison evaluation flag
  6690 CD14 20 1E CD			JSR	LAB_2C74		; save flag and go do series evaluation
  6691
  6692 CD17 A9 5C			LDA	#<func_l		; set sin(n) pointer low byte
  6693 CD19 A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6694 CD1B 4C D6 C7			JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6695
  6696 CD1E			LAB_2C74
  6697 CD1E 48				PHA				; save comparison evaluation flag
  6698 CD1F 4C DF CC			JMP	LAB_2C35		; go do series evaluation
  6699
  6700 				; perform USR()
  6701 CD22			LAB_USR
  6702 CD22 20 0A 00			JSR	Usrjmp			; call user code
  6703 CD25 4C B4 BB			JMP	LAB_1BFB		; scan for ')', else do syntax error then warm start
  6704
  6705 				; perform ATN()
  6706 CD28			LAB_ATN
  6707 CD28 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6708 CD2A 48				PHA				; save sign
  6709 CD2B 10 03			BPL	LAB_2CA1		; branch if +ve
  6710
  6711 CD2D 20 C9 CB			JSR	LAB_GTHAN		; else do - FAC1
  6712 CD30			LAB_2CA1
  6713 CD30 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6714 CD32 48				PHA				; push exponent
  6715 CD33 C9 81			CMP	#$81			; compare with 1
  6716 CD35 90 07			BCC	LAB_2CAF		; branch if FAC1<1
  6717
  6718 CD37 A9 E7			LDA	#<LAB_259C		; set 1 pointer low byte
  6719 CD39 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  6720 CD3B 20 D6 C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6721 CD3E			LAB_2CAF
  6722 CD3E A9 C6			LDA	#<LAB_2CC9		; set pointer low byte to counter
  6723 CD40 A0 D3			LDY	#>LAB_2CC9		; set pointer high byte to counter
  6724 CD42 20 26 CC			JSR	LAB_2B6E		; ^2 then series evaluation
  6725 CD45 68				PLA				; restore old FAC1 exponent
  6726 CD46 C9 81			CMP	#$81			; compare with 1
  6727 CD48 90 07			BCC	LAB_2CC2		; branch if FAC1<1
  6728
  6729 CD4A A9 AD			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6730 CD4C A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6731 CD4E 20 78 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6732 CD51			LAB_2CC2
  6733 CD51 68				PLA				; restore FAC1 sign
  6734 CD52 10 16			BPL	LAB_2D04		; exit if was +ve
  6735
  6736 CD54 4C C9 CB			JMP	LAB_GTHAN		; else do - FAC1 and return
  6737
  6738 				; perform BITSET
  6739 CD57			LAB_BITSET
  6740 CD57 20 AD C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6741 CD5A E0 08			CPX	#$08			; only 0 to 7 are allowed
  6742 CD5C B0 20			BCS	FCError			; branch if > 7
  6743
  6744 CD5E A9 00			LDA	#$00			; clear A
  6745 CD60 38				SEC				; set the carry
  6746 CD61			S_Bits
  6747 CD61 2A				ROL				; shift bit
  6748 CD62 CA				DEX				; decrement bit number
  6749 CD63 10 FC			BPL	S_Bits			; loop if still +ve
  6750
  6751 CD65 E8				INX				; make X = $00
  6752 CD66 01 11			ORA	(Itempl,X)		; or with byte via temporary integer (addr)
  6753 CD68 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6754 CD6A			LAB_2D04
  6755 CD6A 60				RTS
  6756
  6757 				; perform BITCLR
  6758 CD6B			LAB_BITCLR
  6759 CD6B 20 AD C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6760 CD6E E0 08			CPX	#$08			; only 0 to 7 are allowed
  6761 CD70 B0 0C			BCS	FCError			; branch if > 7
  6762
  6763 CD72 A9 FF			LDA	#$FF			; set A
  6764 CD74			S_Bitc
  6765 CD74 2A				ROL				; shift bit
  6766 CD75 CA				DEX				; decrement bit number
  6767 CD76 10 FC			BPL	S_Bitc			; loop if still +ve
  6768
  6769 CD78 E8				INX				; make X = $00
  6770 CD79 21 11			AND	(Itempl,X)		; and with byte via temporary integer (addr)
  6771 CD7B 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6772 CD7D 60				RTS
  6773
  6774 CD7E			FCError
  6775 CD7E 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start
  6776
  6777 				; perform BITTST()
  6778 CD81			LAB_BTST
  6779 CD81 20 7C 00			JSR	LAB_IGBY		; increment BASIC pointer
  6780 CD84 20 AD C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6781 CD87 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6782 CD89 B0 F3			BCS	FCError			; branch if > 7
  6783
  6784 CD8B 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  6785 CD8E C9 29			CMP	#')'			; is next character ')'
  6786 CD90 F0 03			BEQ	TST_OK			; if ')' go do rest of function
  6787
  6788 CD92 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  6789
  6790 CD95			TST_OK
  6791 CD95 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6792 CD98 A9 00			LDA	#$00			; clear A
  6793 CD9A 38				SEC				; set the carry
  6794 CD9B			T_Bits
  6795 CD9B 2A				ROL				; shift bit
  6796 CD9C CA				DEX				; decrement bit number
  6797 CD9D 10 FC			BPL	T_Bits			; loop if still +ve
  6798
  6799 CD9F E8				INX				; make X = $00
  6800 CDA0 21 11			AND	(Itempl,X)		; AND with byte via temporary integer (addr)
  6801 CDA2 F0 02			BEQ	LAB_NOTT		; branch if zero (already correct)
  6802
  6803 CDA4 A9 FF			LDA	#$FF			; set for -1 result
  6804 CDA6			LAB_NOTT
  6805 CDA6 4C CF C8			JMP	LAB_27DB		; go do SGN tail
  6806
  6807 				; perform BIN$()
  6808 CDA9			LAB_BINS
  6809 CDA9 E0 19			CPX	#$19			; max + 1
  6810 CDAB B0 48			BCS	BinFErr			; exit if too big ( > or = )
  6811
  6812 CDAD 86 38			STX	TempB			; save # of characters ($00 = leading zero remove)
  6813 CDAF A9 18			LDA	#$18			; need A byte long space
  6814 CDB1 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long
  6815 CDB4 A0 17			LDY	#$17			; set index
  6816 CDB6 A2 18			LDX	#$18			; character count
  6817 CDB8			NextB1
  6818 CDB8 46 11			LSR	nums_1			; shift highest byte
  6819 CDBA 66 12			ROR	nums_2			; shift middle byte
  6820 CDBC 66 13			ROR	nums_3			; shift lowest byte bit 0 to carry
  6821 CDBE 8A				TXA				; load with '0'/2
  6822 CDBF 2A				ROL				; shift in carry
  6823 CDC0 91 6D			STA	(str_pl),Y		; save to temp string + index
  6824 CDC2 88				DEY				; decrement index
  6825 CDC3 10 F3			BPL	NextB1			; loop if not done
  6826
  6827 CDC5 A5 38			LDA	TempB			; get # of characters
  6828 CDC7 F0 0A			BEQ	EndBHS			; branch if truncate
  6829
  6830 CDC9 AA				TAX				; copy length to X
  6831 CDCA 38				SEC				; set carry for add !
  6832 CDCB 49 FF			EOR	#$FF			; 1's complement
  6833 CDCD 69 18			ADC	#$18			; add 24d
  6834 CDCF F0 1C			BEQ	GoPr2			; if zero print whole string
  6835
  6836 CDD1 D0 0F			BNE	GoPr1			; else go make output string
  6837 					
  6838 				; this is the exit code and is also used by HEX$()
  6839 				; truncate string to remove leading '0's
  6840 CDD3			EndBHS
  6841 CDD3 A8				TAY				; clear index (A=0, X=length here)
  6842 CDD4			NextB2
  6843 CDD4 B1 6D			LDA	(str_pl),Y		; get character from string
  6844 CDD6 C9 30			CMP	#'0'			; compare with '0'
  6845 CDD8 D0 07			BNE	GoPr			; if not '0' then go print string from here
  6846
  6847 CDDA CA				DEX				; decrement character count
  6848 CDDB F0 03			BEQ	GoPr3			; if zero then end of string so go print it
  6849
  6850 CDDD C8				INY				; else increment index
  6851 CDDE 10 F4			BPL	NextB2			; loop always
  6852
  6853 				; make fixed length output string - ignore overflows!
  6854 CDE0			GoPr3
  6855 CDE0 E8				INX				; need at least 1 character
  6856 CDE1			GoPr
  6857 CDE1 98				TYA				; copy result
  6858 CDE2			GoPr1
  6859 CDE2 18				CLC				; clear carry for add
  6860 CDE3 65 6D			ADC	str_pl			; add low address
  6861 CDE5 85 6D			STA	str_pl			; save low address
  6862 CDE7 A9 00			LDA	#$00			; do high byte
  6863 CDE9 65 6E			ADC	str_ph			; add high address
  6864 CDEB 85 6E			STA	str_ph			; save high address
  6865 CDED			GoPr2
  6866 CDED 86 6C			STX	str_ln			; X holds string length
  6867 CDEF 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6868 CDF2 4C 5A C1			JMP	LAB_RTST		; check for space on descriptor stack then put address
  6869 									; and length on descriptor stack and update stack pointers
  6870
  6871 CDF5			BinFErr
  6872 CDF5 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start
  6873
  6874 				; perform HEX$()
  6875 CDF8			LAB_HEXS
  6876 CDF8 E0 07			CPX	#$07			; max + 1
  6877 CDFA B0 F9			BCS	BinFErr			; exit if too big ( > or = )
  6878
  6879 CDFC 86 38			STX	TempB			; save # of characters
  6880
  6881 CDFE A9 06			LDA	#$06			; need 6 bytes for string
  6882 CE00 20 0D C1			JSR	LAB_MSSP		; make string space A bytes long
  6883 CE03 A0 05			LDY	#$05			; set string index
  6884
  6885 					; Disable decimal mode patch
  6886 					;SED				; need decimal mode for nibble convert
  6887 CE05 A5 13			LDA	nums_3			; get lowest byte
  6888 CE07 20 24 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6889 CE0A A5 12			LDA	nums_2			; get middle byte
  6890 CE0C 20 24 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6891 CE0F A5 11			LDA	nums_1			; get highest byte
  6892 CE11 20 24 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6893 					;CLD				; back to binary
  6894
  6895 CE14 A2 06			LDX	#$06			; character count
  6896 CE16 A5 38			LDA	TempB			; get # of characters
  6897 CE18 F0 B9			BEQ	EndBHS			; branch if truncate
  6898
  6899 CE1A AA				TAX				; copy length to X
  6900 CE1B 38				SEC				; set carry for add !
  6901 CE1C 49 FF			EOR	#$FF			; 1's complement
  6902 CE1E 69 06			ADC	#$06			; add 6d
  6903 CE20 F0 CB			BEQ	GoPr2			; if zero print whole string
  6904
  6905 CE22 D0 BE			BNE	GoPr1			; else go make output string (branch always)
  6906
  6907 				; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6908 CE24			LAB_A2HX
  6909 CE24 AA				TAX				; save byte
  6910 CE25 29 0F			AND	#$0F			; mask off top bits
  6911 CE27 20 2F CE			JSR	LAB_AL2X		; convert low nibble to ASCII and output
  6912 CE2A 8A				TXA				; get byte back
  6913 CE2B 4A				LSR				; /2	shift high nibble to low nibble
  6914 CE2C 4A				LSR				; /4
  6915 CE2D 4A				LSR				; /8
  6916 CE2E 4A				LSR				; /16
  6917 CE2F			LAB_AL2X				; Disable decimal mode patch added
  6918 CE2F C9 0A			CMP	#$0A			; set carry for +1 if >9
  6919 CE31 90 02			BCC   	LAB_AL20          	; skip adjust if <= 9
  6920 CE33 69 06			ADC   	#$06              	; adjust for A to F 
  6921 CE35			LAB_AL20
  6922 CE35 69 30			ADC	#'0'			; add ASCII '0'
  6923 CE37 91 6D			STA	(str_pl),Y		; save to temp string
  6924 CE39 88				DEY				; decrement counter
  6925 CE3A 60				RTS
  6926
  6927 CE3B			LAB_NLTO
  6928 CE3B 85 6C			STA	FAC1_e			; save FAC1 exponent
  6929 CE3D A9 00			LDA	#$00			; clear sign compare
  6930 CE3F			LAB_MLTE
  6931 CE3F 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6932 CE41 8A				TXA				; restore character
  6933 CE42 20 1A CA			JSR	LAB_2912		; evaluate new ASCII digit
  6934
  6935 				; gets here if the first character was '$' for hex
  6936 				; get hex number
  6937 CE45			LAB_CHEX
  6938 CE45 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6939 CE48 90 0A			BCC	LAB_ISHN		; branch if numeric character
  6940
  6941 CE4A 09 20			ORA	#$20			; case convert, allow 'A' to 'F' and 'a' to 'f'
  6942 CE4C E9 61			SBC	#'a'			; subtract 'a' (carry set here)
  6943 CE4E C9 06			CMP	#$06			; compare normalised with $06 (max+1)
  6944 CE50 B0 2A			BCS	LAB_EXCH		; exit if >'f' or <'0'
  6945
  6946 CE52 69 0A			ADC	#$0A			; convert to nibble
  6947 CE54			LAB_ISHN
  6948 CE54 29 0F			AND	#$0F			; convert to binary
  6949 CE56 AA				TAX				; save nibble
  6950 CE57 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6951 CE59 F0 E4			BEQ	LAB_MLTE		; skip multiply if zero
  6952
  6953 CE5B 69 04			ADC	#$04			; add four to exponent (*16 - carry clear here)
  6954 CE5D 90 DC			BCC	LAB_NLTO		; if no overflow do evaluate digit
  6955
  6956 CE5F			LAB_MLTO
  6957 CE5F 4C 98 C6			JMP	LAB_2564		; do overflow error and warm start
  6958
  6959 CE62			LAB_NXCH
  6960 CE62 AA				TAX				; save bit
  6961 CE63 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6962 CE65 F0 06			BEQ	LAB_MLBT		; skip multiply if zero
  6963
  6964 CE67 E6 6C			INC	FAC1_e			; increment FAC1 exponent (*2)
  6965 CE69 F0 F4			BEQ	LAB_MLTO		; do overflow error if = $00
  6966
  6967 CE6B A9 00			LDA	#$00			; clear sign compare
  6968 CE6D			LAB_MLBT
  6969 CE6D 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6970 CE6F 8A				TXA				; restore bit
  6971 CE70 20 1A CA			JSR	LAB_2912		; evaluate new ASCII digit
  6972
  6973 				; gets here if the first character was  '%' for binary
  6974 				; get binary number
  6975 CE73			LAB_CBIN
  6976 CE73 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6977 CE76 49 30			EOR	#'0'			; convert '0' to 0 etc.
  6978 CE78 C9 02			CMP	#$02			; compare with max+1
  6979 CE7A 90 E6			BCC	LAB_NXCH		; branch exit if < 2
  6980
  6981 CE7C			LAB_EXCH
  6982 CE7C 4C FF C9			JMP	LAB_28F6		; evaluate -ve flag and return
  6983
  6984 				; ctrl-c check routine. includes limited 'life' byte save for INGET routine
  6985 				; now also the code that checks to see if an interrupt has occurred
  6986 CE7F			CTRLC
  6987 CE7F AD 68 18			LDA	ccflag			; get [CTRL-C] check flag
  6988 CE82 D0 18			BNE	LAB_FBA2		; exit if inhibited
  6989
  6990 CE84 20 FF D2			JSR	V_INPT			; scan input device
  6991 CE87 90 0B			BCC	LAB_FBA0		; exit if buffer empty
  6992
  6993 CE89 8D 69 18			STA	ccbyte			; save received byte
  6994 CE8C A2 20			LDX	#$20			; 'life' timer for bytes
  6995 CE8E 8E 6A 18			STX	ccnull			; set countdown
  6996 CE91 4C F6 B4			JMP	LAB_1636		; return to BASIC
  6997
  6998 CE94			LAB_FBA0
  6999 CE94 AE 6A 18			LDX	ccnull			; get countdown byte
  7000 CE97 F0 03			BEQ	LAB_FBA2		; exit if finished
  7001
  7002 CE99 CE 6A 18			DEC	ccnull			; else decrement countdown
  7003 CE9C			LAB_FBA2
  7004 CE9C A2 03			LDX	#NmiBase		; set pointer to NMI values
  7005 CE9E 20 A7 CE			JSR	LAB_CKIN		; go check interrupt
  7006 CEA1 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7007 CEA3 20 A7 CE			JSR	LAB_CKIN		; go check interrupt
  7008 CEA6			LAB_CRTS
  7009 CEA6 60				RTS
  7010
  7011 				; check whichever interrupt is indexed by X
  7012 CEA7			LAB_CKIN
  7013 CEA7 B5 00			LDA	PLUS_0,X		; get interrupt flag byte
  7014 CEA9 10 FB			BPL	LAB_CRTS		; branch if interrupt not enabled
  7015
  7016 				; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  7017 				; automatically enable the interrupt when we exit
  7018 CEAB 0A				ASL				; move happened bit to setup bit
  7019 CEAC 29 40			AND	#$40			; mask happened bits
  7020 CEAE F0 F6			BEQ	LAB_CRTS		; if no interrupt then exit
  7021
  7022 CEB0 95 00			STA	PLUS_0,X		; save interrupt flag byte
  7023
  7024 CEB2 8A				TXA				; copy index ..
  7025 CEB3 A8				TAY				; .. to Y
  7026
  7027 CEB4 68				PLA				; dump return address low byte, call from CTRL-C
  7028 CEB5 68				PLA				; dump return address high byte
  7029
  7030 CEB6 A9 05			LDA	#$05			; need 5 bytes for GOSUB
  7031 CEB8 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  7032 CEBB A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  7033 CEBD 48				PHA				; push on stack
  7034 CEBE A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  7035 CEC0 48				PHA				; push on stack
  7036 CEC1 A5 48			LDA	Clineh			; get current line high byte
  7037 CEC3 48				PHA				; push on stack
  7038 CEC4 A5 47			LDA	Clinel			; get current line low byte
  7039 CEC6 48				PHA				; push on stack
  7040 CEC7 A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  7041 CEC9 48				PHA				; push on stack
  7042
  7043 CECA B9 01 00			LDA	PLUS_1,Y		; get interrupt code pointer low byte
  7044 CECD 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  7045 CECF B9 02 00			LDA	PLUS_2,Y		; get interrupt code pointer high byte
  7046 CED2 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  7047
  7048 CED4 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  7049 									; can't RTS, we used the stack! the RTS from the ctrl-c
  7050 									; check will be taken when the RETIRQ/RETNMI/RETURN is
  7051 									; executed at the end of the subroutine
  7052
  7053 				; get byte from input device, no waiting
  7054 				; returns with carry set if byte in A
  7055 CED7			INGET
  7056 CED7 20 FF D2			JSR	V_INPT			; call scan input device
  7057 CEDA B0 09			BCS	LAB_FB95		; if byte go reset timer
  7058
  7059 CEDC AD 6A 18			LDA	ccnull			; get countdown
  7060 CEDF F0 09			BEQ	LAB_FB96		; exit if empty
  7061
  7062 CEE1 AD 69 18			LDA	ccbyte			; get last received byte
  7063 CEE4 38				SEC				; flag we got a byte
  7064 CEE5			LAB_FB95
  7065 CEE5 A2 00			LDX	#$00			; clear X
  7066 CEE7 8E 6A 18			STX	ccnull			; clear timer because we got a byte
  7067 CEEA			LAB_FB96
  7068 CEEA 60				RTS
  7069
  7070 				; 21-07-'25 Emile LAB_IRQ, LAB_NMI, LAB_SIRQ, LAB_SNMI, RETIRQ and RETNMI removed (+105 bytes)
  7071
  7072 				; MAX() MIN() pre process
  7073 CEEB			LAB_MMPP
  7074 CEEB 20 AE BA			JSR	LAB_EVEZ		; process expression
  7075 CEEE 4C 95 BA			JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  7076
  7077 				; perform MAX()
  7078 CEF1			LAB_MAX
  7079 CEF1 20 1F CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7080 									; pull FAC2 and compare with FAC1
  7081 CEF4 10 FB			BPL	LAB_MAX			; branch if no swap to do
  7082
  7083 CEF6 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7084 CEF8 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7085 CEFA 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7086 CEFC 20 98 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7087 CEFF F0 F0			BEQ	LAB_MAX			; go do next (branch always)
  7088
  7089 				; perform MIN()
  7090 CF01			LAB_MIN
  7091 CF01 20 1F CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7092 									; pull FAC2 and compare with FAC1
  7093 CF04 30 FB			BMI	LAB_MIN			; branch if no swap to do
  7094
  7095 CF06 F0 F9			BEQ	LAB_MIN			; branch if no swap to do
  7096
  7097 CF08 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7098 CF0A 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7099 CF0C 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7100 CF0E 20 98 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7101 CF11 F0 EE			BEQ	LAB_MIN			; go do next (branch always)
  7102
  7103 				; exit routine. don't bother returning to the loop code
  7104 				; check for correct exit, else so syntax error
  7105 CF13			LAB_MMEC
  7106 CF13 C9 29			CMP	#')'			; is it end of function?
  7107 CF15 D0 05			BNE	LAB_MMSE		; if not do MAX MIN syntax error
  7108
  7109 CF17 68				PLA				; dump return address low byte
  7110 CF18 68				PLA				; dump return address high byte
  7111 CF19 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ')')
  7112
  7113 CF1C			LAB_MMSE
  7114 CF1C 4C C7 BB			JMP	LAB_SNER		; do syntax error then warm start
  7115
  7116 				; check for next, evaluate and return or exit
  7117 				; this is the routine that does most of the work
  7118 CF1F			LAB_PHFA
  7119 CF1F 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  7120 CF22 C9 2C			CMP	#','			; is there more ?
  7121 CF24 D0 ED			BNE	LAB_MMEC		; if not go do end check
  7122
  7123 									; push FAC1
  7124 CF26 20 AE C8			JSR	LAB_27BA		; round FAC1
  7125 CF29 A5 70			LDA	FAC1_s			; get FAC1 sign
  7126 CF2B 09 7F			ORA	#$7F			; set all non sign bits
  7127 CF2D 25 6D			AND	FAC1_1			; AND FAC1 mantissa1 (AND in sign bit)
  7128 CF2F 48				PHA				; push on stack
  7129 CF30 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  7130 CF32 48				PHA				; push on stack
  7131 CF33 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  7132 CF35 48				PHA				; push on stack
  7133 CF36 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  7134 CF38 48				PHA				; push on stack
  7135
  7136 CF39 20 7C 00			JSR	LAB_IGBY		; scan and get next BASIC byte (after ',')
  7137 CF3C 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7138 									; else do type mismatch
  7139
  7140 									; pop FAC2 (MAX/MIN expression so far)
  7141 CF3F 68				PLA				; pop exponent
  7142 CF40 85 73			STA	FAC2_e			; save FAC2 exponent
  7143 CF42 68				PLA				; pop mantissa3
  7144 CF43 85 76			STA	FAC2_3			; save FAC2 mantissa3
  7145 CF45 68				PLA				; pop mantissa1
  7146 CF46 85 75			STA	FAC2_2			; save FAC2 mantissa2
  7147 CF48 68				PLA				; pop sign/mantissa1
  7148 CF49 85 74			STA	FAC2_1			; save FAC2 sign/mantissa1
  7149 CF4B 85 77			STA	FAC2_s			; save FAC2 sign
  7150
  7151 									; compare FAC1 with (packed) FAC2
  7152 CF4D A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  7153 CF4F A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  7154 CF51 4C EC C8			JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  7155 									; returns A=$00 if FAC1 = (AY)
  7156 									; returns A=$01 if FAC1 > (AY)
  7157 									; returns A=$FF if FAC1 < (AY)
  7158
  7159 				; perform WIDTH
  7160 CF54			LAB_WDTH
  7161 CF54 C9 2C			CMP	#','			; is next byte ','
  7162 CF56 F0 1B			BEQ	LAB_TBSZ		; if so do tab size
  7163
  7164 CF58 20 61 C4			JSR	LAB_GTBY		; get byte parameter
  7165 CF5B 8A				TXA				; copy width to A
  7166 CF5C F0 0A			BEQ	LAB_NSTT		; branch if set for infinite line
  7167
  7168 CF5E E0 10			CPX	#$10			; else make min width = 16d
  7169 CF60 90 45			BCC	TabErr			; if less do function call error and exit
  7170
  7171 				; this next compare ensures that we can't exit WIDTH via an error leaving the
  7172 				; tab size greater than the line length.
  7173 CF62 E4 24			CPX	TabSiz			; compare with tab size
  7174 CF64 B0 02			BCS	LAB_NSTT		; branch if >= tab size
  7175
  7176 CF66 86 24			STX	TabSiz			; else make tab size = terminal width
  7177 CF68			LAB_NSTT
  7178 CF68 86 0F			STX	TWidth			; set the terminal width
  7179 CF6A 20 82 00			JSR	LAB_GBYT		; get BASIC byte back
  7180 CF6D F0 1A			BEQ	WExit			; exit if no following
  7181
  7182 CF6F C9 2C			CMP	#','			; else is it ','
  7183 CF71 D0 A9			BNE	LAB_MMSE		; if not do syntax error
  7184
  7185 CF73			LAB_TBSZ
  7186 CF73 20 5E C4			JSR	LAB_SGBY		; scan and get byte parameter
  7187 CF76 8A				TXA				; copy TAB size
  7188 CF77 30 2E			BMI	TabErr			; if >127 do function call error and exit
  7189
  7190 CF79 E0 01			CPX	#$01			; compare with min-1
  7191 CF7B 90 2A			BCC	TabErr			; if <=1 do function call error and exit
  7192
  7193 CF7D A5 0F			LDA	TWidth			; set flags for width
  7194 CF7F F0 06			BEQ	LAB_SVTB		; skip check if infinite line
  7195
  7196 CF81 E4 0F			CPX	TWidth			; compare TAB with width
  7197 CF83 F0 02			BEQ	LAB_SVTB		; ok if =
  7198
  7199 CF85 B0 20			BCS	TabErr			; branch if too big
  7200
  7201 CF87			LAB_SVTB
  7202 CF87 86 24			STX	TabSiz			; save TAB size
  7203
  7204 				; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7205 				; position on a line that still has at least one whole tab width between it
  7206 				; and the end of the line.
  7207 CF89			WExit
  7208 CF89 A5 0F			LDA	TWidth			; get width
  7209 CF8B F0 06			BEQ	LAB_SULP		; branch if infinite line
  7210
  7211 CF8D C5 24			CMP	TabSiz			; compare with tab size
  7212 CF8F B0 03			BCS	LAB_WDLP		; branch if >= tab size
  7213
  7214 CF91 85 24			STA	TabSiz			; else make tab size = terminal width
  7215 CF93			LAB_SULP
  7216 CF93 38				SEC				; set carry for subtract
  7217 CF94			LAB_WDLP
  7218 CF94 E5 24			SBC	TabSiz			; subtract tab size
  7219 CF96 B0 FC			BCS	LAB_WDLP		; loop while no borrow
  7220
  7221 CF98 65 24			ADC	TabSiz			; add tab size back
  7222 CF9A 18				CLC				; clear carry for add
  7223 CF9B 65 24			ADC	TabSiz			; add tab size back again
  7224 CF9D 85 10			STA	Iclim			; save for now
  7225 CF9F A5 0F			LDA	TWidth			; get width back
  7226 CFA1 38				SEC				; set carry for subtract
  7227 CFA2 E5 10			SBC	Iclim			; subtract remainder
  7228 CFA4 85 10			STA	Iclim			; save tab column limit
  7229 CFA6			LAB_NOSQ
  7230 CFA6 60				RTS
  7231
  7232 CFA7			TabErr
  7233 CFA7 4C F0 BE			JMP	LAB_FCER		; do function call error then warm start
  7234
  7235 				; perform SQR()
  7236 CFAA			LAB_SQR
  7237 CFAA A5 70			LDA	FAC1_s			; get FAC1 sign
  7238 CFAC 30 F9			BMI	TabErr			; if -ve do function call error
  7239
  7240 CFAE A5 6C			LDA	FAC1_e			; get exponent
  7241 CFB0 F0 F4			BEQ	LAB_NOSQ		; if zero just return
  7242
  7243 									; else do root
  7244 CFB2 20 9F C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  7245 CFB5 A9 00			LDA	#$00			; clear A
  7246
  7247 CFB7 85 37			STA	FACt_3			; clear remainder
  7248 CFB9 85 36			STA	FACt_2			; ..
  7249 CFBB 85 35			STA	FACt_1			; ..
  7250 CFBD 85 38			STA	TempB			; ..
  7251
  7252 CFBF 85 6F			STA	FAC1_3			; clear root
  7253 CFC1 85 6E			STA	FAC1_2			; ..
  7254 CFC3 85 6D			STA	FAC1_1			; ..
  7255
  7256 CFC5 A2 18			LDX	#$18			; 24 pairs of bits to do
  7257 CFC7 A5 73			LDA	FAC2_e			; get exponent
  7258 CFC9 4A				LSR				; check odd/even
  7259 CFCA B0 0E			BCS	LAB_SQE2		; if odd only 1 shift first time
  7260
  7261 CFCC			LAB_SQE1
  7262 CFCC 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7263 CFCE 26 75			ROL	FAC2_2			; ..
  7264 CFD0 26 74			ROL	FAC2_1			; ..
  7265 CFD2 26 37			ROL	FACt_3			; .. into remainder
  7266 CFD4 26 36			ROL	FACt_2			; ..
  7267 CFD6 26 35			ROL	FACt_1			; ..
  7268 CFD8 26 38			ROL	TempB			; .. never overflows
  7269 CFDA			LAB_SQE2
  7270 CFDA 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7271 CFDC 26 75			ROL	FAC2_2			; ..
  7272 CFDE 26 74			ROL	FAC2_1			; ..
  7273 CFE0 26 37			ROL	FACt_3			; .. into remainder
  7274 CFE2 26 36			ROL	FACt_2			; ..
  7275 CFE4 26 35			ROL	FACt_1			; ..
  7276 CFE6 26 38			ROL	TempB			; .. never overflows
  7277
  7278 CFE8 06 6F			ASL	FAC1_3			; root = root * 2
  7279 CFEA 26 6E			ROL	FAC1_2			; ..
  7280 CFEC 26 6D			ROL	FAC1_1			; .. never overflows
  7281
  7282 CFEE A5 6F			LDA	FAC1_3			; get root low byte
  7283 CFF0 2A				ROL				; *2
  7284 CFF1 85 1B			STA	Temp3			; save partial low byte
  7285 CFF3 A5 6E			LDA	FAC1_2			; get root low mid byte
  7286 CFF5 2A				ROL				; *2
  7287 CFF6 85 1C			STA	Temp3+1			; save partial low mid byte
  7288 CFF8 A5 6D			LDA	FAC1_1			; get root high mid byte
  7289 CFFA 2A				ROL				; *2
  7290 CFFB 85 1D			STA	Temp3+2			; save partial high mid byte
  7291 CFFD A9 00			LDA	#$00			; get root high byte (always $00)
  7292 CFFF 2A				ROL				; *2
  7293 D000 85 1E			STA	Temp3+3			; save partial high byte
  7294
  7295 									; carry clear for subtract +1
  7296 D002 A5 37			LDA	FACt_3			; get remainder low byte
  7297 D004 E5 1B			SBC	Temp3			; subtract partial low byte
  7298 D006 85 1B			STA	Temp3			; save partial low byte
  7299
  7300 D008 A5 36			LDA	FACt_2			; get remainder low mid byte
  7301 D00A E5 1C			SBC	Temp3+1			; subtract partial low mid byte
  7302 D00C 85 1C			STA	Temp3+1			; save partial low mid byte
  7303
  7304 D00E A5 35			LDA	FACt_1			; get remainder high mid byte
  7305 D010 E5 1D			SBC	Temp3+2			; subtract partial high mid byte
  7306 D012 A8				TAY				; copy partial high mid byte
  7307
  7308 D013 A5 38			LDA	TempB			; get remainder high byte
  7309 D015 E5 1E			SBC	Temp3+3			; subtract partial high byte
  7310 D017 90 0E			BCC	LAB_SQNS		; skip sub if remainder smaller
  7311
  7312 D019 85 38			STA	TempB			; save remainder high byte
  7313
  7314 D01B 84 35			STY	FACt_1			; save remainder high mid byte
  7315
  7316 D01D A5 1C			LDA	Temp3+1			; get remainder low mid byte
  7317 D01F 85 36			STA	FACt_2			; save remainder low mid byte
  7318
  7319 D021 A5 1B			LDA	Temp3			; get partial low byte
  7320 D023 85 37			STA	FACt_3			; save remainder low byte
  7321
  7322 D025 E6 6F			INC	FAC1_3			; increment root low byte (never any rollover)
  7323 D027			LAB_SQNS
  7324 D027 CA				DEX				; decrement bit pair count
  7325 D028 D0 A2			BNE	LAB_SQE1		; loop if not all done
  7326
  7327 D02A 38				SEC				; set carry for subtract
  7328 D02B A5 73			LDA	FAC2_e			; get exponent
  7329 D02D E9 80			SBC	#$80			; normalise
  7330 D02F 6A				ROR				; /2 and re-bias to $80
  7331 D030 69 00			ADC	#$00			; add bit zero back in (allow for half shift)
  7332 D032 85 6C			STA	FAC1_e			; save it
  7333 D034 4C 09 C6			JMP	LAB_24D5		; normalise FAC1 and return
  7334
  7335 				; perform VARPTR()
  7336 D037			LAB_VARPTR
  7337 D037 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  7338 D03A 20 71 BD			JSR	LAB_GVAR		; get var address
  7339 D03D 20 B4 BB			JSR	LAB_1BFB		; scan for ')" , else do syntax error then warm start
  7340 D040 A4 55			LDY	Cvaral			; get var address low byte
  7341 D042 A5 56			LDA	Cvarah			; get var address high byte
  7342 D044 4C 20 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  7343
  7344 				; perform PI
  7345 D047			LAB_PI
  7346 D047 A9 C2			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7347 D049 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7348 D04B 20 52 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  7349 D04E C6 6C			DEC	FAC1_e			; make result = PI
  7350 D050 60				RTS
  7351
  7352 				; perform TWOPI
  7353 D051			LAB_TWOPI
  7354 D051 A9 C2			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7355 D053 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7356 D055 4C 52 C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
  7357 					
  7358 				; *****************************************
  7359 				; ** New Commands For Junior Computer 2 ***
  7360 				; *****************************************
  7361 D058			LAB_MOD
  7362 D058 60				RTS
  7363 				;	LDX	#$04
  7364 				;LAB_STO_FAC2
  7365 				;	LDA	FAC2_e,X
  7366 				;	PHA
  7367 				;	DEX
  7368 				;	BPL	LAB_STO_FAC2
  7369 D059 A2 04			LDX	#$04
  7370 D05B			LAB_STO_FAC1
  7371 D05B B5 6C			LDA	FAC1_e,X
  7372 D05D 48				PHA
  7373 D05E CA				DEX
  7374 D05F 10 FA			BPL	LAB_STO_FAC1
  7375
  7376 D061 20 D9 C7			JSR 	LAB_DIVIDE
  7377 D064 20 56 C9			JSR	LAB_INT
  7378
  7379 D067 20 A2 C8			JSR	LAB_27AE
  7380 				;	LDX	#$00
  7381 				;	STX	FAC1_r
  7382 				;LAB_LOD_FAC2_1
  7383 				;	PLA
  7384 				;	STA	FAC1_e,X
  7385 				;	INX
  7386 				;	CPX	#$05
  7387 				;	BNE	LAB_LOD_FAC2_1
  7388
  7389 					;JSR	LAB_MULTIPLY
  7390 					
  7391 D06A A2 00			LDX	#$00
  7392 D06C			LAB_LOD_FAC2_2
  7393 D06C 68				PLA
  7394 D06D 95 6C			STA	FAC1_e,X
  7395 D06F E8				INX
  7396 D070 E0 05			CPX	#$05
  7397 D072 D0 F8			BNE	LAB_LOD_FAC2_2
  7398
  7399 					;JSR	LAB_SUBTRACT
  7400 D074 4C 11 C7			JMP	LAB_MULTIPLY		; call routine and return
  7401
  7402 				; Call Device Command Routine *************
  7403 D077			CALL_CMD
  7404 D077 6C 6C 1A			JMP	(DEVCMD)		; current opened device command vector (Junior Computer 2)
  7405
  7406 				; Get Null Terminated String Parameter ****
  7407 D07A			LAB_GETSTRPARM
  7408 D07A 85 1A			STA	Temp1
  7409 D07C 20 A6 BA			JSR	LAB_EVEX		; evaluate expression
  7410 D07F A5 1F			LDA	Dtypef			; is it a string expression
  7411 D081 D0 03			BNE	LAB_GETSTR0		; yes, get string				
  7412 D083 20 A1 BA			JSR	LAB_1ABC		; no, throw type mismatch error
  7413 D086			LAB_GETSTR0
  7414 D086 A0 00			LDY	#$00			; set string index to 0
  7415 D088			LAB_GETSTR1
  7416 D088 B1 78			LDA	(ssptr_l),Y		; load a string char
  7417 D08A F0 0B			BEQ	LAB_GETSTR2		; is it a NULL? yes, exit
  7418 D08C C9 22			CMP	#'"'			; is it a '"'?
  7419 D08E F0 03			BEQ	LAB_TERM		; yes, set string termination
  7420 D090 C8				INY				; increment string index
  7421 D091 D0 F5			BNE	LAB_GETSTR1		; and repeat loop
  7422 D093			LAB_TERM
  7423 D093 A9 00			LDA 	#$00			; store termination char
  7424 D095 91 78			STA 	(ssptr_l),Y		; at the end of the string
  7425 D097			LAB_GETSTR2
  7426 D097 A6 78			LDX	ssptr_l			; load string pointer low byte into X
  7427 D099 A4 79			LDY	ssptr_h			; load string pointer high byte into X
  7428 D09B A5 1A			LDA	Temp1
  7429 D09D 60				RTS
  7430
  7431 				; Get Device Parameters *******************
  7432 D09E			LAB_GETDEVPARM
  7433 D09E 20 61 C4			JSR	LAB_GTBY		; scan for byte value
  7434 D0A1 8A				TXA				; and set A to result
  7435 D0A2 F0 08			BEQ	LAB_DEV0		; device is 0, no more parameters needed
  7436 D0A4 85 1A			STA	Temp1			; save device number
  7437 D0A6 20 C3 BB			JSR	LAB_1C01		; check for ','
  7438 D0A9 A5 1A			LDA	Temp1
  7439 D0AB 60				RTS
  7440 D0AC			LAB_DEV0
  7441 D0AC 4C B6 BB			JMP	LAB_SCCA		; check if more token, if so throw syntax error
  7442
  7443 				; Get Two Byte Parameters *****************
  7444 D0AF			LAB_GET2BYTEPARMS
  7445 					;JSR	LAB_EVBY		; evaluate byte expression, result in X
  7446 D0AF 20 61 C4			JSR	LAB_GTBY		; get first byte parameter into X
  7447 D0B2 86 1A			STX	Temp1			; and store it in temp var
  7448 D0B4 20 C3 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7449 D0B7 20 61 C4			JSR	LAB_GTBY		; get second byte parameter into X
  7450 D0BA 8A				TXA
  7451 D0BB A8				TAY				; and transfer it into Y
  7452 D0BC A6 1A			LDX	Temp1			; restore first parameter into X
  7453 D0BE 60				RTS
  7454
  7455 				; get device number parameter *************
  7456 D0BF			LAB_GETDEVID
  7457 D0BF 20 61 C4			JSR	LAB_GTBY		; get byte parameter into X
  7458 D0C2 8A				TXA				; and transfer it into A
  7459 D0C3 09 10			ORA	#$10			; search for stdio devices
  7460 D0C5 60				RTS
  7461
  7462 				; perform LOAD ****************************
  7463 D0C6			LAB_LOAD 
  7464 D0C6 D0 04			BNE	LOAD_DEV		; if no following token use device 0
  7465 D0C8 A9 00			LDA	#$00			; set device id = 0
  7466 D0CA F0 03			BEQ	SET_LOADADR		; branch always
  7467 D0CC			LOAD_DEV
  7468 D0CC 20 9E D0			JSR	LAB_GETDEVPARM		; get device id
  7469 D0CF			SET_LOADADR
  7470 D0CF 48				PHA
  7471 D0D0 A2 00			LDX	#$00
  7472 D0D2 86 FA			STX	ADRL			; set load destination address low, needed by XModem routines
  7473 D0D4 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7474 D0D6 A2 B0			LDX	#>RAM_TOP		; Highest RAM load-address for BASIC
  7475 D0D8 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7476 D0DA A2 20			LDX	#$20
  7477 D0DC 86 FB			STX	ADRH			; set load destination address high, needed by XModem routines
  7478 D0DE 86 FF			STX	MODE			; Set to a non-zero value so that XModemRcv uses ADRL/ADRH as dest. address
  7479 D0E0 09 20			ORA	#$20			; it's a storage device
  7480 D0E2 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7481 D0E5 68				PLA
  7482 D0E6 F0 03			BEQ	CALL_LOAD		; device id = 0?
  7483 D0E8 20 7A D0			JSR	LAB_GETSTRPARM		; no, get string parameter
  7484 D0EB			CALL_LOAD
  7485 D0EB A9 20			LDA	#CMD_LOAD
  7486 D0ED 20 77 D0			JSR	CALL_CMD		; call load command
  7487 D0F0 90 40			BCC	CLEAR_BASE		; load interrupted, exit
  7488 D0F2 AE 00 20			LDX	Ram_base-1
  7489 D0F5 86 3B			STX	Svarl
  7490 D0F7 AE 01 20			LDX	Ram_base
  7491 D0FA 86 3C			STX	Svarh
  7492 D0FC 20 32 D1			JSR	CLEAR_BASE
  7493 D0FF 4C 55 B3			JMP	LAB_147A
  7494
  7495 				; perform SAVE ****************************
  7496 D102			LAB_SAVE
  7497 D102 D0 04			BNE	SAVE_DEV		; if no following token use device 0
  7498 D104 A9 00			LDA	#$00			; set device id = 0
  7499 D106 F0 03			BEQ	SET_SAVEADR
  7500 D108			SAVE_DEV
  7501 D108 20 9E D0			JSR	LAB_GETDEVPARM		; get device id
  7502 D10B			SET_SAVEADR
  7503 D10B 48				PHA
  7504 D10C A2 00			LDX	#$00			; Basic-files start at $2000
  7505 D10E 86 FA			STX	ADRL			; Start of File pointer LSB, needed by XModem routines
  7506 D110 A2 20			LDX	#$20			
  7507 D112 86 FB			STX	ADRH			; Start of File pointer MSB, needed by XModem routines
  7508 D114 A6 3B			LDX	Svarl
  7509 D116 8E 00 20			STX	Ram_base-1
  7510 D119 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7511 D11B A6 3C			LDX	Svarh
  7512 D11D 8E 01 20			STX	Ram_base
  7513 D120 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7514 D122 09 20			ORA	#$20			; Disk-devices
  7515 D124 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7516 D127 68				PLA
  7517 D128 F0 03			BEQ	CALL_SAVE
  7518 D12A 20 7A D0			JSR	LAB_GETSTRPARM		; X,Y = Ptr to Filename
  7519 D12D			CALL_SAVE
  7520 D12D A9 21			LDA	#CMD_SAVE
  7521 D12F 20 77 D0			JSR	CALL_CMD		; Device-driver Write
  7522 D132			CLEAR_BASE
  7523 D132 A2 00			LDX	#$00
  7524 D134 8E 00 20			STX	Ram_base-1
  7525 D137 8E 01 20			STX	Ram_base
  7526 D13A 60				RTS
  7527 					
  7528 				; 'BEEP' command **************************
  7529 D13B			LAB_JC001
  7530 D13B 6C 66 1A			JMP 	(STDBEEP)		; Jump to Junior Computer standard BEEP routine
  7531
  7532 				; perform BEEP ****************************
  7533 D13E			LAB_BEEP
  7534 D13E F0 FB			BEQ 	LAB_JC001		; if no following token go do 'BEEP'
  7535 D140 60				RTS
  7536
  7537 D141			LAB_SYSBEEP
  7538 D141 48				PHA
  7539 D142 98				TYA
  7540 D143 48				PHA
  7541 D144 8A				TXA
  7542 D145 48				PHA
  7543 D146 20 3B D1			JSR	LAB_JC001
  7544 D149 68				PLA
  7545 D14A AA				TAX
  7546 D14B 68				PLA
  7547 D14C A8				TAY
  7548 D14D 68				PLA
  7549 D14E 60				RTS	
  7550 					
  7551 				; perform PLIST ***************************
  7552 				; #### TODO: save current output device and restore pointer after list command !!!!!!!
  7553 D14F			LAB_PLIST
  7554 D14F 48			    	PHA				; save token
  7555 D150 AD 76 1A		    	LDA	STDPRINTDEV		; get standard printer id
  7556 D153 20 18 E0			JSR	SET_STDOUTID		; and set it as standard output device
  7557 D156 68				PLA				; restore token
  7558 D157 20 84 B3			JSR 	LAB_LIST		; call list command
  7559 D15A AD 75 1A			LDA	STDOUTDEV		; get standard output device id
  7560 D15D 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device and return
  7561
  7562 				; perform DOS ****************************
  7563 D160			LAB_DOS					; If no DOS is loaded, this could hang the system!
  7564 D160 6C 0A 18			JMP 	(RETURN_VECT)		; Return to DOS through return vector
  7565
  7566 				; perform HOME ****************************
  7567 D163			LAB_HOME
  7568 D163 A9 05			LDA	#CMD_HOME		; Call Junior Computer standard HOME routine
  7569 D165 D0 0E			BNE	STDCMD_JMP		; branch always
  7570
  7571 				; perform CLS *****************************
  7572 D167			LAB_CLS
  7573 D167 A9 07			LDA	#CMD_CLRSCRN		; Call Junior Computer standard CLS routine
  7574 D169 D0 0A			BNE	STDCMD_JMP		; branch always
  7575
  7576 				; perform NORMAL **************************
  7577 D16B			LAB_NORMAL
  7578 D16B A9 02			LDA	#CMD_NORMAL		; Call Junior Computer standard NORMAL routine
  7579 D16D D0 06			BNE	STDCMD_JMP		; branch always
  7580
  7581 				; perform INVERSE *************************
  7582 D16F			LAB_INVERSE
  7583 D16F A9 03			LDA	#CMD_INVERSE		; Call Junior Computer standard INVERSE routine
  7584 D171 D0 02			BNE	STDCMD_JMP		; branch always
  7585
  7586 				; perform FLASH ***************************
  7587 D173			LAB_FLASH
  7588 D173 A9 04			LDA	#CMD_FLASH		; Call Junior Computer standard FLASH routine
  7589 D175			STDCMD_JMP
  7590 D175 6C 72 1A			JMP 	(STDCMD)		; call STDOUT routine
  7591 					
  7592 				; perform LOCATE **************************
  7593 D178			LAB_LOCATE
  7594 D178 F0 70			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7595 D17A 20 AF D0			JSR	LAB_GET2BYTEPARMS	; get two byte parameters into X and Y
  7596 D17D A9 08			LDA	#CMD_SETCURSOR
  7597 D17F 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard SETCURSOR routine
  7598
  7599 				; perform IN# *****************************
  7600 D182			LAB_INNUM
  7601 D182 F0 66			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7602 D184 20 BF D0			JSR	LAB_GETDEVID
  7603 D187 4C 2F E0			JMP	SET_STDINID		; Set Standard In Routine ID
  7604
  7605 				; perform PR# *****************************
  7606 D18A			LAB_PRNUM
  7607 D18A F0 5E			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7608 D18C 20 BF D0			JSR	LAB_GETDEVID
  7609 D18F 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device
  7610
  7611 				; perform PORTIO ******************************************************************************
  7612 				; Set Port-bits to Input (0) or Output (1). Port number is between 0 and 9.
  7613 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7614 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7615 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7616 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7617 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7618 				; *********************************************************************************************
  7619 D192			LAB_PORTIO
  7620 D192 F0 56			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7621 D194 20 AF D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X = par1 (0=PORTA, 1=PORTB, ..), Y = par2 (value to write)
  7622 D197 98				TYA				; A = par2, value to write to data dir. register
  7623 D198 E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7624 D19A B0 13			BCS	MCPIO			; branch if not a VIA, might be a MCP23017
  7625 					
  7626 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7627 D19C 48				PHA				; save value to write to DDR register
  7628 D19D 8A				TXA				; A = port number 0, 1, 2 or 3
  7629 D19E 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7630 D1A0 09 02			ORA	#$02			; A = 2 (X=1 or X=3) or A = 3 (X=0 or X=2)
  7631 D1A2 A8				TAY				; Y = DDRB (X=1 or X=3) or Y = DDRA (X=0 or X=2)
  7632 D1A3 68				PLA				; get value to write back
  7633 					
  7634 D1A4 E0 02		VIA_WR	CPX	#2			; VIA U5 on IO-board?
  7635 D1A6 B0 03			BCS	VIA_U15			; branch if it is VIA on JC2 V4.1 main-board
  7636 					
  7637 D1A8 91 14			STA	(IOBASE),Y		; store in VIA (U5) of IO board, DDRA (X=0,Y=1) or DDRB (X=1,Y=0) register
  7638 D1AA 60				RTS				; return
  7639
  7640 D1AB			VIA_U15	; VIA on new JC2 main-board (V4.1), is has a fixed address of $1750-$175F
  7641 D1AB 99 50 17			STA	$1750,Y			; Y = 2 or 3, VIA on JC2 V4.1 main-board, fixed address $1750
  7642 D1AE 60			LPIO_X	RTS
  7643
  7644 D1AF			MCPIO	; X > 4, either a MCP23017 or a port number error
  7645 D1AF E0 0A			CPX	#10
  7646 D1B1 B0 FB			BCS	LPIO_X			; Error if port number > 9
  7647 					
  7648 					; ------------------------------------------------------------------------------------------
  7649 					; The MCP23017 direction registers are IODIRA ($00) and IODIRB ($01)
  7650 					;
  7651 					; A: value to write to register
  7652 					; X: port number [4..9]
  7653 					; ------------------------------------------------------------------------------------------
  7654 D1B3 49 FF			EOR	#$FF			; Invert all bytes, since 0 = output for a MCP23017 but input for a VIA
  7655 D1B5 A8				TAY				; Y = databyte to write into IODIRx register
  7656 D1B6 8A				TXA				; A = port number [4..9]
  7657 D1B7 29 FE			AND	#$FE			; clear bit 0 of port number, A is now 4, 6 or 8
  7658 D1B9 18				CLC
  7659 D1BA 69 3C			ADC	#MCP23017_I2C_0-4	; A = $40 (ports 4 & 5), $42 (ports 6 & 7) or $44 (ports 8 & 9)
  7660 D1BC 48				PHA				; save I2C-address
  7661 D1BD 8A				TXA				; A = port number [4..9]
  7662 D1BE 29 01			AND	#$01			; A = 0 or 1
  7663 D1C0 AA				TAX				; X = 0 (IODIRA) or 1 (IODIRB)
  7664 D1C1 68				PLA				; Get I2C-address back
  7665 D1C2 4C 96 ED			JMP 	MCP23017_WRITE		; A = I2C-addr, X = register, Y = data to write and return
  7666 					
  7667 				;--------------------------------------------------------------------------------------------- 
  7668 				; Input  : X: Port number for MCP23017 ICs [4..9]
  7669 				; Outputs: A: I2C-address of MCP23017: $40, $42 or $44
  7670 				;          X: $12 (GPIOA) or $13 (GPIOB)
  7671 				;--------------------------------------------------------------------------------------------- 
  7672 D1C5			PORT2GPIO
  7673 D1C5 8A				TXA				; A = port number [4..9]
  7674 D1C6 29 FE			AND	#$FE			; clear bit 0 of I2C-address
  7675 D1C8 18				CLC
  7676 D1C9 69 3C			ADC	#MCP23017_I2C_0-4	; A = $40 (ports 4 & 5), $42 (ports 6 & 7) or $44 (ports 8 & 9)
  7677 D1CB 48				PHA				; save I2C-address
  7678 D1CC 8A				TXA				; A = port number [4..9]
  7679 D1CD 29 01			AND	#$01			; A = 0 or 1
  7680 D1CF 18				CLC
  7681 D1D0 69 12			ADC	#GPIOA			; $12 = GPIOA
  7682 D1D2 AA				TAX				; X = $12 (GPIOA) or 1 (GPIOB)
  7683 D1D3 68				PLA				; Get I2C-address back
  7684 D1D4 60				RTS				; return
  7685 					
  7686 				; perform PORTOUT ****************************************************************************
  7687 				; Write Port outputbits. Port number is between 0 and 9.
  7688 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7689 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7690 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7691 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7692 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7693 				; *********************************************************************************************
  7694 D1D5			LAB_PORTOUT
  7695 D1D5 F0 13			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7696 D1D7 20 AF D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X = par1 (0=PORTA, 1=PORTB, ..), Y = par2 (value to write)
  7697 D1DA 98				TYA				; A = par2, value to write to data dir. register
  7698 D1DB E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7699 D1DD B0 0E			BCS	MCP_OUT			; branch if not a VIA, might be a MCP23017
  7700
  7701 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7702 D1DF 48				PHA				; save value to write to DDR register
  7703 D1E0 8A				TXA				; A = port number 0, 1, 2 or 3
  7704 D1E1 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7705 D1E3 29 01			AND	#$01			; A = 0 (X=1 or X=3) or A = 1 (X=0 or X=2)
  7706 D1E5 A8				TAY				; Y = PORTB (X=1 or X=3) or Y = PORTA (X=0 or X=2)
  7707 D1E6 68				PLA				; get value to write back
  7708 D1E7 4C A4 D1			JMP	VIA_WR			; Write value into VIA PORTA or PORTB register
  7709
  7710 D1EA			LAB_SYNTAX_ERR
  7711 D1EA 4C C7 BB			JMP	LAB_SNER		; throw syntax error and return
  7712
  7713 D1ED			MCP_OUT	; X > 4, either a MCP23017 or a port number error
  7714 D1ED E0 0A			CPX	#10
  7715 D1EF B0 BD			BCS	LPIO_X			; Error if port number > 9
  7716
  7717 					; ------------------------------------------------------------------------------------------
  7718 					; The MCP23017 output registers are GPIOA ($12) and GPIOB ($13)
  7719 					; A: value to write to register
  7720 					; X: port number [4..9]
  7721 					; ------------------------------------------------------------------------------------------
  7722 D1F1 A8				TAY				; Y = databyte to write into GPIOx register
  7723 D1F2 20 C5 D1			JSR	PORT2GPIO		; Returns A=I2C-address, X= GPIOA or GPIOB
  7724 D1F5 4C 96 ED			JMP 	MCP23017_WRITE		; A = I2C-addr, X = register, Y = data to write and return
  7725
  7726 				; perform I2C write operations ************
  7727 D1F8			LAB_I2COUT
  7728 D1F8 F0 F0			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7729 D1FA 20 AF D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X=addr, Y=ctrl
  7730 D1FD 86 1A			STX	Temp1			; Temp1=X=addr/data byte
  7731 D1FF 98				TYA				; A=ctrl byte
  7732 D200 C9 01			CMP	#I2C_STA		; I2C-start?
  7733 D202 D0 08			BNE	I2C_WR			; branch if not I2C-start
  7734 					
  7735 D204 20 26 E3			JSR	I2C_START		; send start condition (affects A and Y)
  7736 D207 E0 00			CPX	#$00			; Is address byte 0?
  7737 D209 D0 01			BNE	I2C_WR			; branch if address byte > 0
  7738 D20B 60				RTS				; otherwise, just return
  7739
  7740 D20C A5 1A		I2C_WR	LDA	Temp1			; restore data byte to A
  7741 D20E 20 67 E3			JSR	I2C_SEND		; I2C-write: write byte
  7742 D211 90 04			BCC	SET_NAK			; C=0: NACK, C=1: ACK, branch if NACK
  7743
  7744 D213 A9 00			LDA	#0			; return I2C ACK (0)
  7745 D215 F0 02			BEQ	SV_NAK			; branch always
  7746 D217 A9 01		SET_NAK	LDA	#1			; return I2C NACK (1)
  7747 D219 85 9C		SV_NAK	STA	I2Cstat			; save in I2C status
  7748 D21B 60				RTS
  7749
  7750 				; perform I2C read operations ************
  7751 D21C			LAB_I2CIN
  7752 D21C 20 C6 C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer (Itempl)
  7753 D21F A5 11			LDA	Itempl			; get byte via temporary integer
  7754 D221 C9 03			CMP	#I2C_STO		; I2C-stop command only?
  7755 D223 F0 17			BEQ	I2C_STOP_CMD		; branch if stop-command only
  7756
  7757 D225 C9 00			CMP	#I2C_STAT		; Return I2Cstat result?
  7758 D227 F0 16			BEQ	I2C_RD_X		; branch if I2Cstat return only
  7759
  7760 D229 20 9F E3			JSR	I2C_RCV			; I2C-read: receive byte 
  7761 D22C 85 9C			STA	I2Cstat			; save received byte
  7762 D22E A5 11			LDA	Itempl			; get ctrl byte back
  7763 D230 C9 01			CMP	#I2C_RD_ACK		; Read followed by ACK?
  7764 D232 D0 05			BNE	RD_NAK			; branch if not an ACK
  7765 					
  7766 D234 20 44 E3			JSR	I2C_ACK			; send ACK (more bytes to read) and return
  7767 D237 D0 06			BNE	I2C_RD_X		; branch always
  7768 					
  7769 D239 20 53 E3		RD_NAK	JSR	I2C_NACK		; send NACK (done reading)
  7770 D23C			I2C_STOP_CMD
  7771 D23C 20 35 E3			JSR	I2C_STOP		; send I2C-stop Command
  7772 D23F			I2C_RD_X
  7773 D23F A4 9C			LDY	I2Cstat			; load I2C-status byte in Y
  7774 D241 4C 39 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7775 					
  7776 				; perform PORTIN *****************************************************************************
  7777 				; Read Port inputbits. Port number is between 0 and 9.
  7778 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7779 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7780 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7781 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7782 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7783 				; *********************************************************************************************
  7784 D244			LAB_PORTIN
  7785 D244 20 64 C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  7786 D247 E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7787 D249 B0 16			BCS	MCP_IN			; branch if not a VIA, might be a MCP23017
  7788
  7789 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7790 D24B 8A				TXA				; A = port number 0, 1, 2 or 3
  7791 D24C 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7792 D24E 29 01			AND	#$01			; A = 0 (X=1 or X=3) or A = 1 (X=0 or X=2)
  7793 D250 A8				TAY				; Y = PORTB (X=1 or X=3) or Y = PORTA (X=0 or X=2)
  7794 D251 E0 02			CPX	#2			; VIA U5 on IO-board?
  7795 D253 B0 05			BCS	U15_IN			; branch if it is VIA on JC2 V4.1 main-board
  7796 					
  7797 D255 B1 14			LDA	(IOBASE),Y		; Load from VIA (U5), PORTA (X=0) or PORTB (X=1)
  7798 D257 4C 5D D2			JMP	PIN_X			; convert byte and return it
  7799
  7800 D25A			U15_IN	; VIA on new JC2 main-board (V4.1), is has a fixed address of $1750-$175F
  7801 D25A B9 50 17			LDA	$1750,Y			; Y = 0 or 1, VIA on JC2 V4.1 main-board
  7802 D25D A8			PIN_X	TAY				; copy received byte into Y
  7803 D25E 4C 39 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7804 					
  7805 D261 E0 0A		MCP_IN	CPX	#10
  7806 D263 90 01			BCC	MCPRC			; Continue if port number < 10
  7807
  7808 D265 60				RTS				; return if port number > 9
  7809 					
  7810 					; ------------------------------------------------------------------------------------------
  7811 					; The MCP23017 input registers are GPIOA ($12) and GPIOB ($13)
  7812 					; X: port number [4..9]
  7813 					; ------------------------------------------------------------------------------------------
  7814 D266 20 C5 D1		MCPRC	JSR	PORT2GPIO		; Returns A=I2C-address, X= GPIOA or GPIOB
  7815 D269 20 B5 ED			JSR	MCP23017_READ		; A = I2C-address of MCP23017 ($40, $42 or $44), X = register to read from
  7816 D26C 4C 5D D2			JMP	PIN_X			; convert byte and return
  7817 					
  7818 				; perform DELAY *************************
  7819 D26F			LAB_DELAY
  7820 D26F 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7821 									; else do type mismatch
  7822 D272 20 69 BE			JSR	LAB_EVPI		; evaluate positive integer expression
  7823 D275 A5 15			LDA	IOBASE+1
  7824 D277 F0 2F			BEQ	LAB_DELAY_OLD		; check if IO is available (needed for RAM based EhBasic only)
  7825 D279 A0 0E			LDY	#VIA_IER		; select interrupt enable register
  7826 D27B A9 7F			LDA	#$7F
  7827 D27D 91 14			STA	(IOBASE),Y		; disable all VIA2 interrupts
  7828 D27F			LAB_DELAY_LOOP
  7829 D27F A0 08			LDY	#VIA_T2CL		; select Timer2 lower byte register
  7830 D281 A9 E8			LDA	#$E8			; set Timer2
  7831 D283 91 14			STA	(IOBASE),Y		; store timer low value
  7832 D285 A9 03			LDA	#$03
  7833 D287 C8				INY				; select Timer2 higher byte register
  7834 D288 91 14			STA	(IOBASE),Y		; store timer high value and start timer
  7835 D28A A0 0D			LDY	#VIA_IFR		; select interrupt flag register
  7836 D28C A5 6E			LDA	FAC1_2
  7837 D28E D0 04			BNE	LAB_WAIT_TIMER
  7838 D290 A5 6F			LDA	FAC1_3
  7839 D292 F0 13			BEQ	LAB_DELAY_END
  7840 D294			LAB_WAIT_TIMER
  7841 D294 B1 14			LDA	(IOBASE),Y
  7842 D296 29 20			AND	#$20
  7843 D298 F0 FA			BEQ	LAB_WAIT_TIMER
  7844 D29A C6 6F			DEC	FAC1_3
  7845 D29C A5 6F			LDA	FAC1_3
  7846 D29E C9 FF			CMP	#$FF
  7847 D2A0 D0 DD			BNE	LAB_DELAY_LOOP
  7848 D2A2 C6 6E			DEC	FAC1_2
  7849 D2A4 4C 7F D2			JMP	LAB_DELAY_LOOP
  7850 D2A7			LAB_DELAY_END
  7851 D2A7 60				RTS
  7852
  7853 D2A8			LAB_DELAY_OLD
  7854 D2A8 A6 6E			LDX	FAC1_2
  7855 D2AA F0 FB			BEQ	LAB_DELAY_END
  7856 D2AC			LAB_SET_TIMER
  7857 D2AC A5 6F			LDA	FAC1_3
  7858 D2AE 20 4D E1			JSR	DELAY			; Delay routine
  7859 D2B1 A9 FF			LDA	#$FF
  7860 D2B3 85 6F			STA	FAC1_3
  7861 D2B5 CA				DEX
  7862 D2B6 D0 F4			BNE	LAB_SET_TIMER
  7863 D2B8 60				RTS
  7864
  7865 				; perform SOUND ****************************************************************************
  7866 				; SOUND sends data to the SN76489 sound-generator.
  7867 				; Syntax: SOUND ch, N, att
  7868 				;   ch = 0, 1, 2, 3: channel number, channel 3 is the noise channel
  7869 				;   N: 1-1023: 10-bit number: frequency = 125000/N for ch = 0, 1 or 2
  7870 				;      000-111 bit 2 = FB (0 = Periodic, 1= White Noise), bit 1 = NF0, bit 0 = NF1
  7871 				;   att: attenutation: 0 = 0 dB, 1 = 2 dB ... 14 = 28 dB, 15 = OFF
  7872 				; *********************************************************************************************
  7873 D2B9			LAB_SOUND
  7874 D2B9 D0 03			BNE	SND_CONT		; branch if tokens present
  7875 D2BB 4C EA D1			JMP	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7876 D2BE			SND_CONT
  7877 D2BE 20 61 C4			JSR	LAB_GTBY		; get first byte parameter (ch) into X
  7878 D2C1 8A				TXA				; A = channel number
  7879 D2C2 29 03			AND	#$03			; Only channels 0-3 are allowed
  7880 D2C4 85 1A			STA	Temp1			; Temp1 = channel number 
  7881 D2C6 20 C3 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7882
  7883 D2C9 20 92 BA			JSR	LAB_EVNM		; evaluate expression and check if numeric, else do type mismatch
  7884 D2CC 20 C6 C4			JSR	LAB_F2FX		; convert floating-to-fixed
  7885 D2CF 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  7886 D2D1 29 03			AND	#$03			; only bits 9 and 8 are valid
  7887 D2D3 85 58			STA	Frnxth			; save pointer high byte
  7888 D2D5 20 C3 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7889 D2D8 A6 1A			LDX	Temp1			; Get channel number
  7890 D2DA E0 03			CPX	#3			; ch 3 = noise-channel
  7891 D2DC B0 0B			BCS	NOISE_CH		; branch if noise-channel
  7892
  7893 D2DE 8A				TXA				; A = channel number: 0, 1 or 2
  7894 D2DF A6 57			LDX	Frnxtl			; Get frequency low byte
  7895 D2E1 A4 58			LDY	Frnxth			; Get frequency bits 9 and 8
  7896 D2E3 20 FB E3			JSR	SOUND_SETFREQ		; A - Channel (0..2), X - Freq. LSB 7..0, Y - Freq. MSB 9..8
  7897 D2E6 4C F2 D2			JMP	SEND_ATTN		; branch always
  7898
  7899 D2E9			NOISE_CH				; Channel 3, noise channel
  7900 D2E9 A5 57			LDA	Frnxtl			; 000-111 bit 2 = FB (0 = Periodic, 1= White Noise), bit 1 = NF0, bit 0 = NF1  
  7901 D2EB 29 07			AND	#$07			; Only use bits 2-0
  7902 D2ED 09 E0			ORA	#$E0			; Noise control register
  7903 D2EF 20 BB E3			JSR	SOUND_SENDBYTE		; send complete command byte to the sound chip
  7904
  7905 D2F2			SEND_ATTN				; Send attenuation to SN76489
  7906 D2F2 20 61 C4			JSR	LAB_GTBY		; get 3rd byte parameter (att) into X
  7907 D2F5 8A				TXA				; A = attenuation
  7908 D2F6 29 0F			AND	#$0F			; Only 0-15 is allowed
  7909 D2F8 AA				TAX				; X = attenuation [0..15]
  7910 D2F9 A5 1A			LDA	Temp1			; A = channel number
  7911 D2FB 4C DC E3			JMP	SOUND_SETATN		; A = channel [0..3], X = att. level [0..15] and return
  7912
  7913 				; *****************************************
  7914
  7915 D2FE			LAB_SCREEN	
  7916 D2FE			LAB_PIXEL
  7917 D2FE			LAB_LINE	
  7918 D2FE			LAB_OVAL
  7919 D2FE			LAB_COLOR
  7920 D2FE			LAB_RECT
  7921 							
  7922 D2FE			LAB_RES1
  7923 D2FE			LAB_RES2
  7924 D2FE			LAB_RES3
  7925 D2FE			LAB_RES4
  7926 D2FE			LAB_RES5
  7927 D2FE			LAB_RES6
  7928 D2FE 60				RTS
  7929
  7930 				; **** end of new commands ****
  7931
  7932
  7933 				; system dependent i/o vectors
  7934 				; these are in RAM and are set by the monitor at start-up
  7935
  7936 D2FF 6C 6E 1A		V_INPT	JMP	(STDIN)			; non halting scan input device vector (Junior Computer 2)
  7937 D302 6C 70 1A		V_OUTP	JMP	(STDOUT)		; send byte to output device vector (Junior Computer 2)
  7938
  7939 				; The rest are tables messages and code for RAM
  7940
  7941 				; the rest of the code is tables and BASIC start-up code
  7942
  7943 D305			PG2_TABS
  7944 D305 00				.byte	$00			; ctrl-c flag		-	$00 = enabled
  7945 D306 00				.byte	$00			; ctrl-c byte		-	GET needs this
  7946 D307 00				.byte	$00			; ctrl-c byte timeout	-	GET needs this
  7947 D308 7F CE			.word	CTRLC			; ctrl c check vector
  7948 				;	.word	xxxx			; non halting key input	-	monitor to set this
  7949 				;	.word	xxxx			; output vector		-	monitor to set this
  7950 				;	.word	xxxx			; load vector		-	monitor to set this
  7951 				;	.word	xxxx			; save vector		-	monitor to set this
  7952 D30A			PG2_TABE
  7953
  7954 				; character get subroutine for zero page
  7955
  7956 				; For a 1.8432MHz 6502 including the JSR and RTS
  7957 				; fastest (>=':')	=  29 cycles =  15.7uS
  7958 				; slowest (<':')	=  40 cycles =  21.7uS
  7959 				; space skip	= +21 cycles = +11.4uS
  7960 				; inc across page	=  +4 cycles =  +2.2uS
  7961
  7962 				; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7963 				; block is copied to it's destination, any non zero page address will do at assembly
  7964 				; time, to assemble a three byte instruction.
  7965
  7966 				; page 0 initialisation table from $BC
  7967 				; increment and scan memory
  7968 D30A			LAB_2CEE
  7969 D30A E6 83			INC	Bpntrl			; increment BASIC execute pointer low byte
  7970 D30C D0 02			BNE	LAB_2CF4		; branch if no carry
  7971 									; else
  7972 D30E E6 84			INC	Bpntrh			; increment BASIC execute pointer high byte
  7973
  7974 				; page 0 initialisation table from $C2
  7975 				; scan memory
  7976 D310			LAB_2CF4
  7977 D310 AD FF FF			LDA	$FFFF			; get byte to scan (addr set by call routine)
  7978 D313 C9 C1			CMP	#TK_ELSE		; compare with the token for ELSE
  7979 D315 F0 0E			BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
  7980
  7981 D317 C9 3A			CMP	#':'			; compare with ':'
  7982 D319 B0 0A			BCS	LAB_2D05		; exit if >= ':', not numeric, carry set
  7983
  7984 D31B C9 20			CMP	#' '			; compare with ' '
  7985 D31D F0 EB			BEQ	LAB_2CEE		; if ' ' go do next
  7986
  7987 D31F 38				SEC				; set carry for SBC
  7988 D320 E9 30			SBC	#'0'			; subtract '0'
  7989 D322 38				SEC				; set carry for SBC
  7990 D323 E9 D0			SBC	#$D0			; subtract -'0'
  7991 									; clear carry if byte = '0'-'9'
  7992 D325			LAB_2D05
  7993 D325 60				RTS
  7994
  7995 				; page zero initialisation table $00-$12 inclusive
  7996 D326			StrTab
  7997 D326 4C				.byte	$4C			; JMP opcode
  7998 D327 00 B0			.word 	LAB_COLD		; initial warm start vector (cold start)
  7999
  8000 D329 00				.byte	$00			; these bytes are not used by BASIC
  8001 D32A 00 00			.word	$0000			; 
  8002 D32C 00 00			.word	$0000			; 
  8003 D32E 00 00			.word	$0000			; 
  8004
  8005 D330 4C				.byte	$4C			; JMP opcode
  8006 D331 F0 BE			.word	LAB_FCER		; initial user function vector ('Function call' error)
  8007 D333 00				.byte	$00			; default NULL count
  8008 D334 00				.byte	$00			; clear terminal position
  8009 D335 00				.byte	$00			; default terminal width byte
  8010 D336 F2				.byte	$F2			; default limit for TAB = 14
  8011 D337 01 20			.word	Ram_base		; start of user RAM
  8012 D339			EndTab
  8013
  8014 D339			LAB_MSZM
  8015 D339 45 6E 68 61 6E 63 + 	.by	'Enhanced BASIC 2.29',$0A,$00
  8016 				;	.byte	$0D,$0A,'Memory size ',$00
  8017
  8018 D34E			LAB_SMSG
  8019 D34E 20 42 61 73 69 63 + 	.by	' Basic Bytes free',$0D,$0A,$0A,$00
  8020 				;	.byte	'Enhanced BASIC 2.25',$0A,$00
  8021
  8022 				; numeric constants and series
  8023
  8024 									; constants and series for LOG(n)
  8025 D363			LAB_25A0
  8026 D363 02				.byte	$02			; counter
  8027 D364 80 19 56 62			.byte	$80,$19,$56,$62		; 0.59898
  8028 D368 80 76 22 F3			.byte	$80,$76,$22,$F3		; 0.96147
  8029 				;##	.byte	$80,$76,$22,$F1		; 0.96147
  8030 D36C 82 38 AA 40			.byte	$82,$38,$AA,$40		; 2.88539
  8031 				;##	.byte	$82,$38,$AA,$45		; 2.88539
  8032
  8033 D370			LAB_25AD
  8034 D370 80 35 04 F3			.byte	$80,$35,$04,$F3		; 0.70711	1/root 2
  8035 D374			LAB_25B1
  8036 D374 81 35 04 F3			.byte	$81,$35,$04,$F3		; 1.41421	root 2
  8037 D378			LAB_25B5
  8038 D378 80 80 00 00			.byte	$80,$80,$00,$00		; -0.5
  8039 D37C			LAB_25B9
  8040 D37C 80 31 72 18			.byte	$80,$31,$72,$18		; 0.69315	LOG(2)
  8041
  8042 									; numeric PRINT constants
  8043 D380			LAB_2947
  8044 D380 91 43 4F F8			.byte	$91,$43,$4F,$F8		; 99999.9375 (max value with at least one decimal)
  8045 D384			LAB_294B
  8046 D384 94 74 23 F7			.byte	$94,$74,$23,$F7		; 999999.4375 (max value before scientific notation)
  8047 D388			LAB_294F
  8048 D388 94 74 24 00			.byte	$94,$74,$24,$00		; 1000000
  8049
  8050 									; EXP(n) constants and series
  8051 D38C			LAB_2AFA
  8052 D38C 81 38 AA 3B			.byte	$81,$38,$AA,$3B		; 1.4427	(1/LOG base 2 e)
  8053 D390			LAB_2AFE
  8054 D390 06				.byte	$06			; counter
  8055 D391 74 63 90 8C			.byte	$74,$63,$90,$8C		; 2.17023e-4
  8056 D395 77 23 0C AB			.byte	$77,$23,$0C,$AB		; 0.00124
  8057 D399 7A 1E 94 00			.byte	$7A,$1E,$94,$00		; 0.00968
  8058 D39D 7C 63 42 80			.byte	$7C,$63,$42,$80		; 0.05548
  8059 D3A1 7E 75 FE D0			.byte	$7E,$75,$FE,$D0		; 0.24023
  8060 D3A5 80 31 72 15			.byte	$80,$31,$72,$15		; 0.69315
  8061 D3A9 81 00 00 00			.byte	$81,$00,$00,$00		; 1.00000
  8062
  8063 				;##	.byte	$07			; counter
  8064 				;##	.byte	$74,$94,$2E,$40		; -1/7! (-1/5040)
  8065 				;##	.byte	$77,$2E,$4F,$70		;  1/6! ( 1/720)
  8066 				;##	.byte	$7A,$88,$02,$6E		; -1/5! (-1/120)
  8067 				;##	.byte	$7C,$2A,$A0,$E6		;  1/4! ( 1/24)
  8068 				;##	.byte	$7E,$AA,$AA,$50		; -1/3! (-1/6)
  8069 				;##	.byte	$7F,$7F,$FF,$FF		;  1/2! ( 1/2)
  8070 				;##	.byte	$81,$80,$00,$00		; -1/1! (-1/1)
  8071 				;##	.byte	$81,$00,$00,$00		;  1/0! ( 1/1)
  8072
  8073 									; trigonometric constants and series
  8074 D3AD			LAB_2C78
  8075 D3AD 81 49 0F DB			.byte	$81,$49,$0F,$DB		; 1.570796371 (pi/2) as floating #
  8076 D3B1			LAB_2C84
  8077 D3B1 04				.byte	$04			; counter
  8078 D3B2 86 1E D7 FB			.byte	$86,$1E,$D7,$FB		; 39.7109
  8079 				;##	.byte	$86,$1E,$D7,$BA		; 39.7109
  8080 D3B6 87 99 26 65			.byte	$87,$99,$26,$65		;-76.575
  8081 				;##	.byte	$87,$99,$26,$64		;-76.575
  8082 D3BA 87 23 34 58			.byte	$87,$23,$34,$58		; 81.6022
  8083 D3BE 86 A5 5D E1			.byte	$86,$A5,$5D,$E1		;-41.3417
  8084 				;##	.byte	$86,$A5,$5D,$E0		;-41.3417
  8085 D3C2			LAB_2C7C
  8086 D3C2 83 49 0F DB			.byte	$83,$49,$0F,$DB		; 6.28319 (2*pi) as floating #
  8087 				;##	.byte	$83,$49,$0F,$DA		; 6.28319 (2*pi) as floating #
  8088
  8089 D3C6			LAB_2CC9
  8090 D3C6 08				.byte	$08			; counter
  8091 D3C7 78 3A C5 37			.byte	$78,$3A,$C5,$37		; 0.00285
  8092 D3CB 7B 83 A2 5C			.byte	$7B,$83,$A2,$5C		;-0.0160686
  8093 D3CF 7C 2E DD 4D			.byte	$7C,$2E,$DD,$4D		; 0.0426915
  8094 D3D3 7D 99 B0 1E			.byte	$7D,$99,$B0,$1E		;-0.0750429
  8095 D3D7 7D 59 ED 24			.byte	$7D,$59,$ED,$24		; 0.106409
  8096 D3DB 7E 91 72 00			.byte	$7E,$91,$72,$00		;-0.142036
  8097 D3DF 7E 4C B9 73			.byte	$7E,$4C,$B9,$73		; 0.199926
  8098 D3E3 7F AA AA 53			.byte	$7F,$AA,$AA,$53		;-0.333331
  8099
  8100 				;##	.byte	$08			; counter
  8101 				;##	.byte	$78,$3B,$D7,$4A		; 1/17
  8102 				;##	.byte	$7B,$84,$6E,$02		;-1/15
  8103 				;##	.byte	$7C,$2F,$C1,$FE		; 1/13
  8104 				;##	.byte	$7D,$9A,$31,$74		;-1/11
  8105 				;##	.byte	$7D,$5A,$3D,$84		; 1/9
  8106 				;##	.byte	$7E,$91,$7F,$C8		;-1/7
  8107 				;##	.byte	$7E,$4C,$BB,$E4		; 1/5
  8108 				;##	.byte	$7F,$AA,$AA,$6C		;-1/3
  8109
  8110 = D3E8			LAB_1D96	= *+1			; $00,$00 used for undefined variables
  8111 D3E7			LAB_259C
  8112 D3E7 81 00 00 00			.byte	$81,$00,$00,$00		; 1.000000, used for INC
  8113 D3EB			LAB_2AFD
  8114 D3EB 81 80 00 00			.byte	$81,$80,$00,$00		; -1.00000, used for DEC. must be on the same page as +1.00
  8115
  8116 									; misc constants
  8117 D3EF			LAB_1DF7
  8118 D3EF 90				.byte	$90			;-32768 (uses first three bytes from 0.5)
  8119 D3F0			LAB_2A96
  8120 D3F0 80 00 00 00			.byte	$80,$00,$00,$00		; 0.5
  8121 D3F4			LAB_2C80
  8122 D3F4 7F 00 00 00			.byte	$7F,$00,$00,$00		; 0.25
  8123 D3F8			LAB_26B5
  8124 D3F8 84 20 00 00			.byte	$84,$20,$00,$00		; 10.0000 divide by 10 constant
  8125
  8126 				; This table is used in converting numbers to ASCII.
  8127 D3FC			LAB_2A9A
  8128 = D3FD			LAB_2A9B = LAB_2A9A+1
  8129 = D3FE			LAB_2A9C = LAB_2A9B+1
  8130 D3FC FE 79 60			.byte	$FE,$79,$60		; -100000
  8131 D3FF 00 27 10			.byte	$00,$27,$10		; 10000
  8132 D402 FF FC 18			.byte	$FF,$FC,$18		; -1000
  8133 D405 00 00 64			.byte	$00,$00,$64		; 100
  8134 D408 FF FF F6			.byte	$FF,$FF,$F6		; -10
  8135 D40B 00 00 01			.byte	$00,$00,$01		; 1
  8136
  8137 D40E			LAB_CTBL
  8138 D40E F9 B4			.word	LAB_END-1		; END
  8139 D410 38 B4			.word	LAB_FOR-1		; FOR
  8140 D412 29 BA			.word	LAB_NEXT-1		; NEXT
  8141 D414 5C B6			.word	LAB_DATA-1		; DATA
  8142 D416 0C B9			.word	LAB_INPUT-1		; INPUT
  8143 D418 25 BD			.word	LAB_DIM-1		; DIM
  8144 D41A 2B B9			.word	LAB_READ-1		; READ
  8145 D41C 79 B7			.word	LAB_LET-1		; LET
  8146 D41E 4B B7			.word	LAB_DEC-1		; DEC		new command
  8147 D420 BB B5			.word	LAB_GOTO-1		; GOTO
  8148 D422 7A B5			.word	LAB_RUN-1		; RUN
  8149 D424 8A B6			.word	LAB_IF-1		; IF
  8150 D426 1A B5			.word	LAB_RESTORE-1		; RESTORE	modified command
  8151 D428 9E B5			.word	LAB_GOSUB-1		; GOSUB
  8152 D42A B8 D2			.word	LAB_SOUND-1		; SOUND	
  8153 D42C FD D2			.word	LAB_RES2-1		; RET2
  8154 D42E 47 B6			.word	LAB_RETURN-1		; RETURN
  8155 D430 F1 B6			.word	LAB_REM-1		; REM
  8156 D432 F7 B4			.word	LAB_STOP-1		; STOP
  8157 D434 FA B6			.word	LAB_ON-1		; ON		modified command
  8158 D436 58 B5			.word	LAB_NULL-1		; NULL		modified command
  8159 D438 4E B7			.word	LAB_INC-1		; INC		new command
  8160 D43A 5D C5			.word	LAB_WAIT-1		; WAIT
  8161 D43C C5 D0			.word	LAB_LOAD-1		; LOAD
  8162 D43E 01 D1			.word	LAB_SAVE-1		; SAVE
  8163 D440 46 C0			.word	LAB_DEF-1		; DEF
  8164 D442 E2 C4			.word	LAB_POKE-1		; POKE
  8165 D444 FE C4			.word	LAB_DOKE-1		; DOKE		new command
  8166 D446 4B C5			.word	LAB_CALL-1		; CALL		new command
  8167 D448 84 B5			.word	LAB_DO-1		; DO		new command
  8168 D44A ED B5			.word	LAB_LOOP-1		; LOOP		new command
  8169 D44C 1A B8			.word	LAB_PRINT-1		; PRINT
  8170 D44E 5E B5			.word	LAB_CONT-1		; CONT
  8171 D450 83 B3			.word	LAB_LIST-1		; LIST
  8172 D452 80 B3			.word	LAB_CLEAR-1		; CLEAR
  8173 D454 30 B3			.word	LAB_NEW-1		; NEW
  8174 D456 53 CF			.word	LAB_WDTH-1		; WIDTH		new command
  8175 D458 E9 B7			.word	LAB_GET-1		; GET		new command
  8176 D45A 23 C5			.word	LAB_SWAP-1		; SWAP		new command
  8177 D45C 56 CD			.word	LAB_BITSET-1		; BITSET	new command
  8178 D45E 6A CD			.word	LAB_BITCLR-1		; BITCLR	new command
  8179 D460 FD D2			.word	LAB_RES3-1		; RES3
  8180 D462 FD D2			.word	LAB_RES4-1		; RES4		
  8181 D464 3D D1			.word	LAB_BEEP-1		; BEEP		new command (Junior Computer 2)
  8182 D466 4E D1			.word	LAB_PLIST-1		; PLIST		new command (Junior Computer 2)
  8183 D468 62 D1			.word	LAB_HOME-1		; HOME		new command (Junior Computer 2)
  8184 D46A 66 D1			.word	LAB_CLS-1		; CLS		new command (Junior Computer 2)
  8185 D46C 6A D1			.word	LAB_NORMAL-1		; NORMAL	new command (Junior Computer 2)
  8186 D46E 6E D1			.word	LAB_INVERSE-1		; INVERSE	new command (Junior Computer 2)
  8187 D470 72 D1			.word	LAB_FLASH-1		; FLASH		new command (Junior Computer 2)
  8188 D472 77 D1			.word	LAB_LOCATE-1		; LOCATE	new command (Junior Computer 2)
  8189 D474 81 D1			.word	LAB_INNUM-1		; IN#		new command (Junior Computer 2)
  8190 D476 89 D1			.word	LAB_PRNUM-1		; PR#		new command (Junior Computer 2)
  8191 D478 91 D1			.word	LAB_PORTIO-1		; PORTIO	new command (Junior Computer 2)
  8192 D47A D4 D1			.word	LAB_PORTOUT-1		; PORTOUT	new command (Junior Computer 2)
  8193 D47C FD D2			.word	LAB_SCREEN-1		; SCREEN	new command (Junior Computer 2)	
  8194 D47E FD D2			.word	LAB_PIXEL-1		; PIXEL		new command (Junior Computer 2)
  8195 D480 FD D2			.word	LAB_LINE-1		; LINE		new command (Junior Computer 2)	
  8196 D482 FD D2			.word	LAB_OVAL-1		; OVAL		new command (Junior Computer 2)	
  8197 D484 FD D2			.word	LAB_RECT-1		; RECT		new command (Junior Computer 2)	
  8198 D486 FD D2			.word	LAB_COLOR-1		; COLOR		new command (Junior Computer 2)	
  8199 D488 6E D2			.word	LAB_DELAY-1		; DELAY		new command (Junior Computer 2)	
  8200 D48A F7 D1			.word	LAB_I2COUT-1		; I2COUT	new command (Junior Computer 2)
  8201 D48C 5F D1			.word	LAB_DOS-1		; DOS		new command (Junior Computer 2)
  8202
  8203 				; function pre process routine table
  8204
  8205 D48E			LAB_FTPL
  8206 = D48F			LAB_FTPM	= LAB_FTPL+$01
  8207 D48E 2B BC			.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
  8208 D490 2B BC			.word	LAB_PPFN-1		; INT(n)		"
  8209 D492 2B BC			.word	LAB_PPFN-1		; ABS(n)		"
  8210 D494 AD BA			.word	LAB_EVEZ-1		; USR(x)	process any expression
  8211 D496 B0 BB			.word	LAB_1BF7-1		; FRE(x)		"
  8212 D498 B0 BB			.word	LAB_1BF7-1		; POS(x)		"
  8213 D49A 2B BC			.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
  8214 D49C 2B BC			.word	LAB_PPFN-1		; RND(n)		"
  8215 D49E 2B BC			.word	LAB_PPFN-1		; LOG(n)		"
  8216 D4A0 2B BC			.word	LAB_PPFN-1		; EXP(n)		"
  8217 D4A2 2B BC			.word	LAB_PPFN-1		; COS(n)		"
  8218 D4A4 2B BC			.word	LAB_PPFN-1		; SIN(n)		"
  8219 D4A6 2B BC			.word	LAB_PPFN-1		; TAN(n)		"
  8220 D4A8 2B BC			.word	LAB_PPFN-1		; ATN(n)		"
  8221 D4AA 2B BC			.word	LAB_PPFN-1		; PEEK(n)		"
  8222 D4AC 2B BC			.word	LAB_PPFN-1		; DEEK(n)		"
  8223 D4AE 00 00			.word	$0000			; SADD()	none
  8224 D4B0 25 BC			.word	LAB_PPFS-1		; LEN($)	process string expression in ()
  8225 D4B2 2B BC			.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
  8226 D4B4 25 BC			.word	LAB_PPFS-1		; VAL($)	process string expression in ()
  8227 D4B6 25 BC			.word	LAB_PPFS-1		; ASC($)		"
  8228 D4B8 25 BC			.word	LAB_PPFS-1		; UCASE$($)		"
  8229 D4BA 25 BC			.word	LAB_PPFS-1		; LCASE$($)		"
  8230 D4BC 2B BC			.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
  8231 D4BE 52 BC			.word	LAB_BHSS-1		; HEX$(n)		"
  8232 D4C0 52 BC			.word	LAB_BHSS-1		; BIN$(n)		"
  8233 D4C2 00 00			.word	$0000			; BITTST()	none
  8234 D4C4 EA CE			.word	LAB_MMPP-1		; MAX()		process numeric expression
  8235 D4C6 EA CE			.word	LAB_MMPP-1		; MIN()		"
  8236 D4C8 31 BC			.word	LAB_PPBI-1		; PI		advance pointer
  8237 D4CA 31 BC			.word	LAB_PPBI-1		; TWOPI		"
  8238 D4CC 00 00			.word	$0000			; VARPTR()	none
  8239 D4CE 36 BC			.word	LAB_LRMS-1		; LEFT$()	process string expression
  8240 D4D0 36 BC			.word	LAB_LRMS-1		; RIGHT$()		"
  8241 D4D2 36 BC			.word	LAB_LRMS-1		; MID$()		"
  8242 D4D4 2B BC			.word	LAB_PPFN-1		; PORTIN(n)	process string expression in ()
  8243 D4D6 2B BC			.word	LAB_PPFN-1		; I2CIN(n)	process string expression in ()
  8244 D4D8 00 00			.word	$0000			; RESERVED	none TEMP
  8245 D4DA 00 00			.word	$0000			; RESERVED	none TEMP
  8246
  8247 				; action addresses for functions
  8248 D4DC			LAB_FTBL
  8249 = D4DD			LAB_FTBM	= LAB_FTBL+$01
  8250 D4DC CB C8			.word	LAB_SGN-1		; SGN()
  8251 D4DE 55 C9			.word	LAB_INT-1		; INT()
  8252 D4E0 E8 C8			.word	LAB_ABS-1		; ABS()
  8253 D4E2 21 CD			.word	LAB_USR-1		; USR()
  8254 D4E4 0B C0			.word	LAB_FRE-1		; FRE()
  8255 D4E6 36 C0			.word	LAB_POS-1		; POS()
  8256 D4E8 A9 CF			.word	LAB_SQR-1		; SQR()
  8257 D4EA 71 CC			.word	LAB_RND-1		; RND()		modified function
  8258 D4EC CF C6			.word	LAB_LOG-1		; LOG()
  8259 D4EE D3 CB			.word	LAB_EXP-1		; EXP()
  8260 D4F0 A5 CC			.word	LAB_COS-1		; COS()
  8261 D4F2 AC CC			.word	LAB_SIN-1		; SIN()
  8262 D4F4 F5 CC			.word	LAB_TAN-1		; TAN()
  8263 D4F6 27 CD			.word	LAB_ATN-1		; ATN()
  8264 D4F8 D7 C4			.word	LAB_PEEK-1		; PEEK()
  8265 D4FA EB C4			.word	LAB_DEEK-1		; DEEK()	new function
  8266 D4FC 29 C4			.word	LAB_SADD-1		; SADD()	new function
  8267 D4FE 42 C4			.word	LAB_LENS-1		; LEN()
  8268 D500 F8 C0			.word	LAB_STRS-1		; STR$()
  8269 D502 6F C4			.word	LAB_VAL-1		; VAL()
  8270 D504 4D C4			.word	LAB_ASC-1		; ASC()
  8271 D506 07 C4			.word	LAB_UCASE-1		; UCASE$()	new function
  8272 D508 E6 C3			.word	LAB_LCASE-1		; LCASE$()	new function
  8273 D50A 58 C3			.word	LAB_CHRS-1		; CHR$()
  8274 D50C F7 CD			.word	LAB_HEXS-1		; HEX$()	new function
  8275 D50E A8 CD			.word	LAB_BINS-1		; BIN$()	new function
  8276 D510 80 CD			.word	LAB_BTST-1		; BITTST()	new function
  8277 D512 F0 CE			.word	LAB_MAX-1		; MAX()		new function
  8278 D514 00 CF			.word	LAB_MIN-1		; MIN()		new function
  8279 D516 46 D0			.word	LAB_PI-1		; PI		new function
  8280 D518 50 D0			.word	LAB_TWOPI-1		; TWOPI		new function
  8281 D51A 36 D0			.word	LAB_VARPTR-1		; VARPTR()	new function
  8282 D51C 6A C3			.word	LAB_LEFT-1		; LEFT$()
  8283 D51E 73 C3			.word	LAB_RIGHT-1		; RIGHT$()
  8284 D520 A2 C3			.word	LAB_MIDS-1		; MID$()
  8285 D522 43 D2			.word	LAB_PORTIN-1		; PORTIN	new function (Junior Computer 2)
  8286 D524 1B D2			.word	LAB_I2CIN-1		; I2CIN()	new function (Junior Computer 2)		
  8287 D526 FD D2			.word	LAB_RES5-1		; RESERVED	new function (Junior Computer 2)
  8288 D528 FD D2			.word	LAB_RES6-1		; RESERVED	new function (Junior Computer 2)
  8289
  8290 				; hierarchy and action addresses for operator
  8291 D52A			LAB_OPPT
  8292 D52A 79				.byte	$79			; +
  8293 D52B 95 C5			.word	LAB_ADD-1
  8294 D52D 79				.byte	$79			; -
  8295 D52E 7A C5			.word	LAB_SUBTRACT-1
  8296 D530 7B				.byte	$7B			; *
  8297 D531 10 C7			.word	LAB_MULTIPLY-1
  8298 D533 7B				.byte	$7B			; /
  8299 D534 D8 C7			.word	LAB_DIVIDE-1
  8300 D536 7B				.byte	$7B			; MOD		new operator (Junior Computer 2)
  8301 D537 57 D0			.word	LAB_MOD-1
  8302 D539 7F				.byte	$7F			; ^
  8303 D53A 8F CB			.word	LAB_POWER-1
  8304 D53C 50				.byte	$50			; AND
  8305 D53D 9B BC			.word	LAB_AND-1
  8306 D53F 46				.byte	$46			; EOR		new operator
  8307 D540 81 BC			.word	LAB_EOR-1
  8308 D542 46				.byte	$46			; OR
  8309 D543 8E BC			.word	LAB_OR-1
  8310 D545 56				.byte	$56			; >>		new operator
  8311 D546 47 BD			.word	LAB_RSHIFT-1
  8312 D548 56				.byte	$56			; <<		new operator
  8313 D549 2F BD			.word	LAB_LSHIFT-1
  8314 D54B 7D				.byte	$7D			; >
  8315 D54C C8 CB			.word	LAB_GTHAN-1
  8316 D54E 5A				.byte	$5A			; =
  8317 D54F DB BB			.word	LAB_EQUAL-1
  8318 D551 64				.byte	$64			; <
  8319 D552 BC BC			.word	LAB_LTHAN-1
  8320
  8321 				; keywords start with ..
  8322 				; this is the first character table and must be in alphabetic order
  8323 D554			TAB_1STC
  8324 D554 2A				.byte	'*'
  8325 D555 2B				.byte	'+'
  8326 D556 2D				.byte	'-'
  8327 D557 2F				.byte	'/'
  8328 D558 3C				.byte	'<'
  8329 D559 3D				.byte	'='
  8330 D55A 3E				.byte	'>'
  8331 D55B 3F				.byte	'?'
  8332 D55C 41				.byte	'A'
  8333 D55D 42				.byte	'B'
  8334 D55E 43				.byte	'C'
  8335 D55F 44				.byte	'D'
  8336 D560 45				.byte	'E'
  8337 D561 46				.byte	'F'
  8338 D562 47				.byte	'G'
  8339 D563 48				.byte	'H'
  8340 D564 49				.byte	'I'
  8341 D565 4C				.byte	'L'
  8342 D566 4D				.byte	'M'
  8343 D567 4E				.byte	'N'
  8344 D568 4F				.byte	'O'
  8345 D569 50				.byte	'P'
  8346 D56A 52				.byte	'R'
  8347 D56B 53				.byte	'S'
  8348 D56C 54				.byte	'T'
  8349 D56D 55				.byte	'U'
  8350 D56E 56				.byte	'V'
  8351 D56F 57				.byte	'W'
  8352 D570 5E				.byte	'^'
  8353 D571 00				.byte	$00			; table terminator
  8354
  8355 				; pointers to keyword tables
  8356
  8357 D572			TAB_CHRT
  8358 D572 AC D5			.word	TAB_STAR		; table for '*'
  8359 D574 AE D5			.word	TAB_PLUS		; table for '+'
  8360 D576 B0 D5			.word	TAB_MNUS		; table for '-'
  8361 D578 B2 D5			.word	TAB_SLAS		; table for '/'
  8362 D57A B4 D5			.word	TAB_LESS		; table for '<'
  8363 D57C B8 D5			.word	TAB_EQUL		; table for '='
  8364 D57E BA D5			.word	TAB_MORE		; table for '>'
  8365 D580 BE D5			.word	TAB_QEST		; table for '?'
  8366 D582 C0 D5			.word	TAB_ASCA		; table for 'A'
  8367 D584 D0 D5			.word	TAB_ASCB		; table for 'B'
  8368 D586 ED D5			.word	TAB_ASCC		; table for 'C'
  8369 D588 0C D6			.word	TAB_ASCD		; table for 'D'
  8370 D58A 2D D6			.word	TAB_ASCE		; table for 'E'
  8371 D58C 3C D6			.word	TAB_ASCF		; table for 'F'
  8372 D58E 4B D6			.word	TAB_ASCG		; table for 'G'
  8373 D590 58 D6			.word	TAB_ASCH		; table for 'H'
  8374 D592 62 D6			.word	TAB_ASCI		; table for 'I'
  8375 D594 87 D6			.word	TAB_ASCL		; table for 'L'
  8376 D596 B6 D6			.word	TAB_ASCM		; table for 'M'
  8377 D598 C9 D6			.word	TAB_ASCN		; table for 'N'
  8378 D59A DE D6			.word	TAB_ASCO		; table for 'O'
  8379 D59C EA D6			.word	TAB_ASCP		; table for 'P'
  8380 D59E 1B D7			.word	TAB_ASCR		; table for 'R'
  8381 D5A0 58 D7			.word	TAB_ASCS		; table for 'S'
  8382 D5A2 8E D7			.word	TAB_ASCT		; table for 'T'
  8383 D5A4 A2 D7			.word	TAB_ASCU		; table for 'U'
  8384 D5A6 B3 D7			.word	TAB_ASCV		; table for 'V'
  8385 D5A8 BF D7			.word	TAB_ASCW		; table for 'W'
  8386 D5AA CE D7			.word	TAB_POWR		; table for '^'
  8387
  8388 				; tables for each start character, note if a longer keyword with the same start
  8389 				; letters as a shorter one exists then it must come first, else the list is in
  8390 				; alphabetical order as follows ..
  8391
  8392 				; [keyword,token
  8393 				; [keyword,token]]
  8394 				; end marker (#$00)
  8395
  8396 D5AC			TAB_STAR
  8397 D5AC CD 00			.byte TK_MUL,$00		; *
  8398 D5AE			TAB_PLUS
  8399 D5AE CB 00			.byte TK_PLUS,$00		; +
  8400 D5B0			TAB_MNUS
  8401 D5B0 CC 00			.byte TK_MINUS,$00		; -
  8402 D5B2			TAB_SLAS
  8403 D5B2 CE 00			.byte TK_DIV,$00		; /
  8404 D5B4			TAB_LESS
  8405 D5B4			LBB_LSHIFT
  8406 D5B4 3C D5			.byte	'<',TK_LSHIFT		; <<	note - '<<' must come before '<'
  8407 D5B6 D8				.byte 	TK_LT			; <
  8408 D5B7 00				.byte	$00
  8409 D5B8			TAB_EQUL
  8410 D5B8 D7 00			.byte 	TK_EQUAL,$00		; =
  8411 D5BA			TAB_MORE
  8412 D5BA			LBB_RSHIFT
  8413 D5BA 3E D4			.byte	'>',TK_RSHIFT		; >>	note - '>>' must come before '>'
  8414 D5BC D6				.byte 	TK_GT			; >
  8415 D5BD 00				.byte	$00
  8416 D5BE			TAB_QEST
  8417 D5BE 9F 00			.byte 	TK_PRINT,$00		; ?
  8418 D5C0			TAB_ASCA
  8419 D5C0			LBB_ABS
  8420 D5C0 42 53 28 DB			.byte	'BS(',TK_ABS		; ABS(
  8421 D5C4			LBB_AND
  8422 D5C4 4E 44 D1			.byte	'ND',TK_AND		; AND
  8423 D5C7			LBB_ASC
  8424 D5C7 53 43 28 ED			.byte	'SC(',TK_ASC		; ASC(
  8425 D5CB			LBB_ATN
  8426 D5CB 54 4E 28 E6			.byte	'TN(',TK_ATN		; ATN(
  8427 D5CF 00				.byte	$00
  8428 D5D0			TAB_ASCB
  8429 D5D0			LBB_BEEP
  8430 D5D0 45 45 50 AB			.byte	'EEP',TK_BEEP		; BEEP
  8431 D5D4			LBB_BINS
  8432 D5D4 49 4E 24 28 F2		.byte	'IN$(',TK_BINS		; BIN$(
  8433 D5D9			LBB_BITCLR
  8434 D5D9 49 54 43 4C 52 A8		.byte	'ITCLR',TK_BITCLR	; BITCLR
  8435 D5DF			LBB_BITSET
  8436 D5DF 49 54 53 45 54 A7		.byte	'ITSET',TK_BITSET	; BITSET
  8437 D5E5			LBB_BITTST
  8438 D5E5 49 54 54 53 54 28 + 	.byte	'ITTST(',TK_BITTST  	; BITTST(
  8439 D5EC 00				.byte	$00
  8440 D5ED			TAB_ASCC
  8441 D5ED			LBB_CALL
  8442 D5ED 41 4C 4C 9C			.byte	'ALL',TK_CALL		; CALL
  8443 D5F1			LBB_CHRS
  8444 D5F1 48 52 24 28 F0		.byte	'HR$(',TK_CHRS		; CHR$(
  8445 D5F6			LBB_CLEAR
  8446 D5F6 4C 45 41 52 A2		.byte	'LEAR',TK_CLEAR		; CLEAR
  8447 D5FB			LBB_CLS
  8448 D5FB 4C 53 AE		    	.byte   'LS',TK_CLS 		; CLS
  8449 D5FE			LBB_COLOR
  8450 D5FE 4F 4C 4F 52 BC		.byte	'OLOR',TK_COLOR		; COLOR
  8451 D603			LBB_CONT
  8452 D603 4F 4E 54 A0			.byte	'ONT',TK_CONT		; CONT
  8453 D607			LBB_COS
  8454 D607 4F 53 28 E3			.byte	'OS(',TK_COS		; COS(
  8455 D60B 00				.byte	$00
  8456 D60C			TAB_ASCD
  8457 D60C			LBB_DATA
  8458 D60C 41 54 41 83			.byte	'ATA',TK_DATA		; DATA
  8459 D610			LBB_DEC
  8460 D610 45 43 88			.byte	'EC',TK_DEC		; DEC
  8461 D613			LBB_DEEK
  8462 D613 45 45 4B 28 E8		.byte	'EEK(',TK_DEEK		; DEEK(
  8463 D618			LBB_DEF
  8464 D618 45 46 99			.byte	'EF',TK_DEF		; DEF
  8465 D61B			LBB_DELAY
  8466 D61B 45 4C 41 59 BD		.byte	'ELAY',TK_DELAY		; DELAY
  8467 D620			LBB_DIM
  8468 D620 49 4D 85			.byte	'IM',TK_DIM		; DIM
  8469 D623			LBB_DOKE
  8470 D623 4F 4B 45 9B			.byte	'OKE',TK_DOKE		; DOKE
  8471 D627			LBB_DOS
  8472 D627 4F 53 BF			.byte	'OS',TK_DOS		; DOS note - 'DOS' must come before 'DO'
  8473 D62A			LBB_DO
  8474 D62A 4F 9D			.byte	'O',TK_DO		; DO
  8475 D62C 00				.byte	$00
  8476 D62D			TAB_ASCE
  8477 D62D			LBB_ELSE
  8478 D62D 4C 53 45 C1			.byte	'LSE',TK_ELSE		; ELSE
  8479 D631			LBB_END
  8480 D631 4E 44 80			.byte	'ND',TK_END		; END
  8481 D634			LBB_EOR
  8482 D634 4F 52 D2			.byte	'OR',TK_EOR		; EOR
  8483 D637			LBB_EXP
  8484 D637 58 50 28 E2			.byte	'XP(',TK_EXP		; EXP(
  8485 D63B 00				.byte	$00
  8486 D63C			TAB_ASCF
  8487 D63C			LBB_FLASH
  8488 D63C 4C 41 53 48 B1	    	.byte   'LASH',TK_FLASH 	; FLASH
  8489 D641			LBB_FN
  8490 D641 4E C3			.byte	'N',TK_FN		; FN
  8491 D643			LBB_FOR
  8492 D643 4F 52 81			.byte	'OR',TK_FOR		; FOR
  8493 D646			LBB_FRE
  8494 D646 52 45 28 DD			.byte	'RE(',TK_FRE		; FRE(
  8495 D64A 00				.byte	$00
  8496 D64B			TAB_ASCG
  8497 D64B			LBB_GET
  8498 D64B 45 54 A5			.byte	'ET',TK_GET		; GET
  8499 D64E			LBB_GOSUB
  8500 D64E 4F 53 55 42 8D		.byte	'OSUB',TK_GOSUB		; GOSUB
  8501 D653			LBB_GOTO
  8502 D653 4F 54 4F 89			.byte	'OTO',TK_GOTO		; GOTO
  8503 D657 00				.byte	$00
  8504 D658			TAB_ASCH
  8505 D658			LBB_HEXS
  8506 D658 45 58 24 28 F1		.byte	'EX$(',TK_HEXS		; HEX$(
  8507 D65D			LBB_HOME
  8508 D65D 4F 4D 45 AD		    	.byte   'OME',TK_HOME 		; HOME
  8509 D661 00				.byte	$00
  8510 D662			TAB_ASCI
  8511 D662			LBB_I2CIN
  8512 D662 32 43 69 6E 28 FD		.byte	'2Cin(',TK_I2CIN	; I2Cin
  8513 D668			LBB_I2COUT
  8514 D668 32 43 6F 75 74 BE		.byte	'2Cout',TK_I2COUT	; I2Cout
  8515 D66E			LBB_IF
  8516 D66E 46 8B			.byte	'F',TK_IF		; IF
  8517 D670			LBB_INNUM
  8518 D670 4E 23 B3			.byte	'N#',TK_INNUM		; IN#
  8519 D673			LBB_INC
  8520 D673 4E 43 95			.byte	'NC',TK_INC		; INC
  8521 D676			LBB_INPUT
  8522 D676 4E 50 55 54 84		.byte	'NPUT',TK_INPUT		; INPUT
  8523 D67B			LBB_INT
  8524 D67B 4E 54 28 DA			.byte	'NT(',TK_INT		; INT(
  8525 D67F			LBB_INVERSE
  8526 D67F 4E 56 45 52 53 45 +     	.byte   'NVERSE',TK_INVERSE 	; INVERSE
  8527 D686 00				.byte	$00
  8528 D687			TAB_ASCL
  8529 D687			LBB_LCASES
  8530 D687 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_LCASES
  8531 									; LCASE$(
  8532 D68E			LBB_LEFTS
  8533 D68E 45 46 54 24 28 F9		.byte	'EFT$(',TK_LEFTS	; LEFT$(
  8534 D694			LBB_LEN
  8535 D694 45 4E 28 EA			.byte	'EN(',TK_LEN		; LEN(
  8536 D698			LBB_LET
  8537 D698 45 54 87			.byte	'ET',TK_LET		; LET
  8538 D69B			LBB_LINE
  8539 D69B 49 4E 45 B9			.byte	'INE',TK_LINE		; LINE
  8540 D69F			LBB_LIST
  8541 D69F 49 53 54 A1			.byte	'IST',TK_LIST		; LIST
  8542 D6A3			LBB_LOAD
  8543 D6A3 4F 41 44 97			.byte	'OAD',TK_LOAD		; LOAD
  8544 D6A7			LBB_LOCATE
  8545 D6A7 4F 43 41 54 45 B2	    	.byte   'OCATE',TK_LOCATE 	; LOCATE
  8546 D6AD			LBB_LOG
  8547 D6AD 4F 47 28 E1			.byte	'OG(',TK_LOG		; LOG(
  8548 D6B1			LBB_LOOP
  8549 D6B1 4F 4F 50 9E			.byte	'OOP',TK_LOOP		; LOOP
  8550 D6B5 00				.byte	$00
  8551 D6B6			TAB_ASCM
  8552 D6B6			LBB_MAX
  8553 D6B6 41 58 28 F4			.byte	'AX(',TK_MAX		; MAX(
  8554 D6BA			LBB_MIDS
  8555 D6BA 49 44 24 28 FB		.byte	'ID$(',TK_MIDS		; MID$(
  8556 D6BF			LBB_MIN
  8557 D6BF 49 4E 28 F5			.byte	'IN(',TK_MIN		; MIN(
  8558 D6C3			LBB_MOD
  8559 D6C3 4F 44 5F 23 CF		.byte	'OD_#',TK_MOD		; MOD
  8560 D6C8 00				.byte	$00
  8561 D6C9			TAB_ASCN
  8562 D6C9			LBB_NEW
  8563 D6C9 45 57 A3			.byte	'EW',TK_NEW		; NEW
  8564 D6CC			LBB_NEXT
  8565 D6CC 45 58 54 82			.byte	'EXT',TK_NEXT		; NEXT
  8566 D6D0			LBB_NOT
  8567 D6D0 4F 54 C6			.byte	'OT',TK_NOT		; NOT
  8568 D6D3			LBB_NORMAL
  8569 D6D3 4F 52 4D 41 4C AF	    	.byte   'ORMAL',TK_NORMAL 	; NORMAL
  8570 D6D9			LBB_NULL
  8571 D6D9 55 4C 4C 94			.byte	'ULL',TK_NULL		; NULL
  8572 D6DD 00				.byte	$00
  8573 D6DE			TAB_ASCO
  8574 D6DE			LBB_OFF
  8575 D6DE 46 46 CA			.byte	'FF',TK_OFF		; OFF
  8576 D6E1			LBB_ON
  8577 D6E1 4E 93			.byte	'N',TK_ON		; ON
  8578 D6E3			LBB_OR
  8579 D6E3 52 D3			.byte	'R',TK_OR		; OR
  8580 D6E5			LBB_OVAL
  8581 D6E5 56 41 4C BA			.byte	'VAL',TK_OVAL		; OVAL
  8582 D6E9 00				.byte	$00
  8583 D6EA			TAB_ASCP
  8584 D6EA			LBB_PEEK
  8585 D6EA 45 45 4B 28 E7		.byte	'EEK(',TK_PEEK		; PEEK(
  8586 D6EF			LBB_PIXEL
  8587 D6EF 49 58 45 4C B8		.byte	'IXEL',TK_PIXEL		; PIXEL
  8588 D6F4			LBB_PI
  8589 D6F4 49 F6			.byte	'I',TK_PI		; PI
  8590 D6F6			LBB_PLIST
  8591 D6F6 4C 49 53 54 AC	    .byte   	'LIST',TK_PLIST 	; PLIST
  8592 D6FB			LBB_POKE
  8593 D6FB 4F 4B 45 9A			.byte	'OKE',TK_POKE		; POKE
  8594 D6FF			LBB_PORTIO
  8595 D6FF 4F 52 54 49 4F B5		.byte	'ORTIO',TK_PORTIO	; PORTIO
  8596 D705			LBB_PORTIN
  8597 D705 4F 52 54 28 FC		.byte	'ORT(',TK_PORTIN	; PORT IN
  8598 D70A			LBB_PORTOUT
  8599 D70A 4F 52 54 B6			.byte	'ORT',TK_PORTOUT	; PORT OUT
  8600 D70E			LBB_POS
  8601 D70E 4F 53 28 DE			.byte	'OS(',TK_POS		; POS(
  8602 D712			LBB_PRNUM
  8603 D712 52 23 B4			.byte	'R#',TK_PRNUM		; PR#
  8604 D715			LBB_PRINT
  8605 D715 52 49 4E 54 9F		.byte	'RINT',TK_PRINT		; PRINT
  8606 D71A 00				.byte	$00
  8607 D71B			TAB_ASCR
  8608 D71B			LBB_READ
  8609 D71B 45 41 44 86			.byte	'EAD',TK_READ		; READ
  8610 D71F			LBB_RECT
  8611 D71F 45 43 54 BB			.byte	'ECT',TK_RECT		; RECT
  8612 D723			LBB_REM
  8613 D723 45 4D 91			.byte	'EM',TK_REM		; REM
  8614 D726			LBB_RESTORE
  8615 D726 45 53 54 4F 52 45 + 	.byte	'ESTORE',TK_RESTORE	; RESTORE
  8616 D72D			LBB_RES2
  8617 D72D 45 53 32 8F			.byte	'ES2',TK_RES2		; RES2
  8618 D731			LBB_RES3
  8619 D731 45 53 33 A9			.byte	'ES3',TK_RES3		; RES3
  8620 D735			LBB_RES4
  8621 D735 45 53 34 AA			.byte	'ES4',TK_RES4		; RES4
  8622 D739			LBB_RES5
  8623 D739 45 53 35 28 FE		.byte	'ES5(',TK_RES5		; RES5
  8624 D73E			LBB_RES6
  8625 D73E 45 53 36 28 FF		.byte	'ES6(',TK_RES6		; RES6
  8626 D743			LBB_RETURN
  8627 D743 45 54 55 52 4E 90		.byte	'ETURN',TK_RETURN	; RETURN
  8628 D749			LBB_RIGHTS
  8629 D749 49 47 48 54 24 28 + 	.byte	'IGHT$(',TK_RIGHTS
  8630 									; RIGHT$(
  8631 D750			LBB_RND
  8632 D750 4E 44 28 E0			.byte	'ND(',TK_RND		; RND(
  8633 D754			LBB_RUN
  8634 D754 55 4E 8A			.byte	'UN',TK_RUN		; RUN
  8635 D757 00				.byte	$00
  8636 D758			TAB_ASCS
  8637 D758			LBB_SADD
  8638 D758 41 44 44 28 E9		.byte	'ADD(',TK_SADD		; SADD(
  8639 D75D			LBB_SAVE
  8640 D75D 41 56 45 98			.byte	'AVE',TK_SAVE		; SAVE
  8641 D761			LBB_SCREEN
  8642 D761 43 52 45 45 4E B7		.byte	'CREEN',TK_SCREEN	; SCREEN
  8643 D767			LBB_SGN
  8644 D767 47 4E 28 D9			.byte	'GN(',TK_SGN		; SGN(
  8645 D76B			LBB_SIN
  8646 D76B 49 4E 28 E4			.byte	'IN(',TK_SIN		; SIN(
  8647 D76F			LBB_SOUND
  8648 D76F 4F 55 4E 44 8E		.byte	'OUND',TK_SOUND		; SOUND
  8649 D774			LBB_SPC
  8650 D774 50 43 28 C4			.byte	'PC(',TK_SPC		; SPC(
  8651 D778			LBB_SQR
  8652 D778 51 52 28 DF			.byte	'QR(',TK_SQR		; SQR(
  8653 D77C			LBB_STEP
  8654 D77C 54 45 50 C7			.byte	'TEP',TK_STEP		; STEP
  8655 D780			LBB_STOP
  8656 D780 54 4F 50 92			.byte	'TOP',TK_STOP		; STOP
  8657 D784			LBB_STRS
  8658 D784 54 52 24 28 EB		.byte	'TR$(',TK_STRS		; STR$(
  8659 D789			LBB_SWAP
  8660 D789 57 41 50 A6			.byte	'WAP',TK_SWAP		; SWAP
  8661 D78D 00				.byte	$00
  8662 D78E			TAB_ASCT
  8663 D78E			LBB_TAB
  8664 D78E 41 42 28 C0			.byte	'AB(',TK_TAB		; TAB(
  8665 D792			LBB_TAN
  8666 D792 41 4E 28 E5			.byte	'AN(',TK_TAN		; TAN(
  8667 D796			LBB_THEN
  8668 D796 48 45 4E C5			.byte	'HEN',TK_THEN		; THEN
  8669 D79A			LBB_TO
  8670 D79A 4F C2			.byte	'O',TK_TO		; TO
  8671 D79C			LBB_TWOPI
  8672 D79C 57 4F 50 49 F7		.byte	'WOPI',TK_TWOPI		; TWOPI
  8673 D7A1 00				.byte	$00
  8674 D7A2			TAB_ASCU
  8675 D7A2			LBB_UCASES
  8676 D7A2 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_UCASES
  8677 									; UCASE$(
  8678 D7A9			LBB_UNTIL
  8679 D7A9 4E 54 49 4C C8		.byte	'NTIL',TK_UNTIL		; UNTIL
  8680 D7AE			LBB_USR
  8681 D7AE 53 52 28 DC			.byte	'SR(',TK_USR		; USR(
  8682 D7B2 00				.byte	$00
  8683 D7B3			TAB_ASCV
  8684 D7B3			LBB_VAL
  8685 D7B3 41 4C 28 EC			.byte	'AL(',TK_VAL		; VAL(
  8686 D7B7			LBB_VPTR
  8687 D7B7 41 52 50 54 52 28 + 	.byte	'ARPTR(',TK_VPTR	; VARPTR(
  8688 D7BE 00				.byte	$00
  8689 D7BF			TAB_ASCW
  8690 D7BF			LBB_WAIT
  8691 D7BF 41 49 54 96			.byte	'AIT',TK_WAIT		; WAIT
  8692 D7C3			LBB_WHILE
  8693 D7C3 48 49 4C 45 C9		.byte	'HILE',TK_WHILE		; WHILE
  8694 D7C8			LBB_WIDTH
  8695 D7C8 49 44 54 48 A4		.byte	'IDTH',TK_WIDTH		; WIDTH
  8696 D7CD 00				.byte	$00
  8697 D7CE			TAB_POWR
  8698 D7CE D0 00			.byte	TK_POWER,$00		; ^
  8699
  8700 				; new decode table for LIST
  8701 				; Table is ..
  8702 				; byte - keyword length, keyword first character
  8703 				; word - pointer to rest of keyword from dictionary
  8704
  8705 				; note if length is 1 then the pointer is ignored
  8706 D7D0			LAB_KEYT
  8707 D7D0 03 45			.byte	3,'E'
  8708 D7D2 31 D6			.word	LBB_END			; END
  8709 D7D4 03 46			.byte	3,'F'
  8710 D7D6 43 D6			.word	LBB_FOR			; FOR
  8711 D7D8 04 4E			.byte	4,'N'
  8712 D7DA CC D6			.word	LBB_NEXT		; NEXT
  8713 D7DC 04 44			.byte	4,'D'
  8714 D7DE 0C D6			.word	LBB_DATA		; DATA
  8715 D7E0 05 49			.byte	5,'I'
  8716 D7E2 76 D6			.word	LBB_INPUT		; INPUT
  8717 D7E4 03 44			.byte	3,'D'
  8718 D7E6 20 D6			.word	LBB_DIM			; DIM
  8719 D7E8 04 52			.byte	4,'R'
  8720 D7EA 1B D7			.word	LBB_READ		; READ
  8721 D7EC 03 4C			.byte	3,'L'
  8722 D7EE 98 D6			.word	LBB_LET			; LET
  8723 D7F0 03 44			.byte	3,'D'
  8724 D7F2 10 D6			.word	LBB_DEC			; DEC
  8725 D7F4 04 47			.byte	4,'G'
  8726 D7F6 53 D6			.word	LBB_GOTO		; GOTO
  8727 D7F8 03 52			.byte	3,'R'
  8728 D7FA 54 D7			.word	LBB_RUN			; RUN
  8729 D7FC 02 49			.byte	2,'I'
  8730 D7FE 6E D6			.word	LBB_IF			; IF
  8731 D800 07 52			.byte	7,'R'
  8732 D802 26 D7			.word	LBB_RESTORE		; RESTORE
  8733 D804 05 47			.byte	5,'G'
  8734 D806 4E D6			.word	LBB_GOSUB		; GOSUB
  8735 D808 05 53			.byte	5,'S'
  8736 D80A 6F D7			.word	LBB_SOUND		; SOUND
  8737 D80C 04 52			.byte	4,'R'
  8738 D80E 2D D7			.word	LBB_RES2		; RES2
  8739 D810 06 52			.byte	6,'R'
  8740 D812 43 D7			.word	LBB_RETURN		; RETURN
  8741 D814 03 52			.byte	3,'R'
  8742 D816 23 D7			.word	LBB_REM			; REM
  8743 D818 04 53			.byte	4,'S'
  8744 D81A 80 D7			.word	LBB_STOP		; STOP
  8745 D81C 02 4F			.byte	2,'O'
  8746 D81E E1 D6			.word	LBB_ON			; ON
  8747 D820 04 4E			.byte	4,'N'
  8748 D822 D9 D6			.word	LBB_NULL		; NULL
  8749 D824 03 49			.byte	3,'I'
  8750 D826 73 D6			.word	LBB_INC			; INC
  8751 D828 04 57			.byte	4,'W'
  8752 D82A BF D7			.word	LBB_WAIT		; WAIT
  8753 D82C 04 4C			.byte	4,'L'
  8754 D82E A3 D6			.word	LBB_LOAD		; LOAD
  8755 D830 04 53			.byte	4,'S'
  8756 D832 5D D7			.word	LBB_SAVE		; SAVE
  8757 D834 03 44			.byte	3,'D'
  8758 D836 18 D6			.word	LBB_DEF			; DEF
  8759 D838 04 50			.byte	4,'P'
  8760 D83A FB D6			.word	LBB_POKE		; POKE
  8761 D83C 04 44			.byte	4,'D'
  8762 D83E 23 D6			.word	LBB_DOKE		; DOKE
  8763 D840 04 43			.byte	4,'C'
  8764 D842 ED D5			.word	LBB_CALL		; CALL
  8765 D844 02 44			.byte	2,'D'
  8766 D846 2A D6			.word	LBB_DO			; DO
  8767 D848 04 4C			.byte	4,'L'
  8768 D84A B1 D6			.word	LBB_LOOP		; LOOP
  8769 D84C 05 50			.byte	5,'P'
  8770 D84E 15 D7			.word	LBB_PRINT		; PRINT
  8771 D850 04 43			.byte	4,'C'
  8772 D852 03 D6			.word	LBB_CONT		; CONT
  8773 D854 04 4C			.byte	4,'L'
  8774 D856 9F D6			.word	LBB_LIST		; LIST
  8775 D858 05 43			.byte	5,'C'
  8776 D85A F6 D5			.word	LBB_CLEAR		; CLEAR
  8777 D85C 03 4E			.byte	3,'N'
  8778 D85E C9 D6			.word	LBB_NEW			; NEW
  8779 D860 05 57			.byte	5,'W'
  8780 D862 C8 D7			.word	LBB_WIDTH		; WIDTH
  8781 D864 03 47			.byte	3,'G'
  8782 D866 4B D6			.word	LBB_GET			; GET
  8783 D868 04 53			.byte	4,'S'
  8784 D86A 89 D7			.word	LBB_SWAP		; SWAP
  8785 D86C 06 42			.byte	6,'B'
  8786 D86E DF D5			.word	LBB_BITSET		; BITSET
  8787 D870 06 42			.byte	6,'B'
  8788 D872 D9 D5			.word	LBB_BITCLR		; BITCLR
  8789 D874 04 52			.byte	4,'R'
  8790 D876 31 D7			.word	LBB_RES3		; RES3
  8791 D878 04 52			.byte	4,'R'
  8792 D87A 35 D7			.word	LBB_RES4		; RES4
  8793 D87C 04 42			.byte	4,'B'
  8794 D87E D0 D5			.word	LBB_BEEP		; BEEP
  8795 D880 05 50			.byte	5,'P'
  8796 D882 F6 D6			.word	LBB_PLIST		; PLIST
  8797 D884 04 48			.byte	4,'H'
  8798 D886 5D D6			.word	LBB_HOME		; HOME
  8799 D888 03 43			.byte	3,'C'
  8800 D88A FB D5			.word	LBB_CLS			; CLS
  8801 D88C 06 4E			.byte	6,'N'
  8802 D88E D3 D6			.word	LBB_NORMAL		; NORMAL
  8803 D890 07 49			.byte	7,'I'
  8804 D892 7F D6			.word	LBB_INVERSE		; INVERSE
  8805 D894 05 46			.byte	5,'F'
  8806 D896 3C D6			.word	LBB_FLASH		; FLASH
  8807 D898 06 4C			.byte	6,'L'
  8808 D89A A7 D6			.word	LBB_LOCATE		; LOCATE
  8809 D89C 03 49			.byte	3,'I'
  8810 D89E 70 D6			.word	LBB_INNUM		; IN#
  8811 D8A0 03 50			.byte	3,'P'
  8812 D8A2 12 D7			.word	LBB_PRNUM		; PR#
  8813
  8814 D8A4 06 50			.byte	6,'P'
  8815 D8A6 FF D6			.word	LBB_PORTIO		; PORTIO
  8816 D8A8 04 50			.byte	4,'P'
  8817 D8AA 0A D7			.word	LBB_PORTOUT		; PORTOUT
  8818 D8AC 06 53			.byte	6,'S'
  8819 D8AE 61 D7			.word	LBB_SCREEN		; SCREEN
  8820 D8B0 05 50			.byte	5,'P'
  8821 D8B2 EF D6			.word	LBB_PIXEL		; PIXEL
  8822 D8B4 04 4C			.byte	4,'L'
  8823 D8B6 9B D6			.word	LBB_LINE		; LINE
  8824 D8B8 04 4F			.byte	4,'O'
  8825 D8BA E5 D6			.word	LBB_OVAL		; OVAL
  8826 D8BC 04 52			.byte	4,'R'
  8827 D8BE 1F D7			.word	LBB_RECT		; RECT
  8828 D8C0 05 43			.byte	5,'C'
  8829 D8C2 FE D5			.word	LBB_COLOR		; COLOR
  8830 D8C4 05 44			.byte	5,'D'
  8831 D8C6 1B D6			.word	LBB_DELAY		; DELAY	
  8832 D8C8 06 49			.byte	6,'I'
  8833 D8CA 68 D6			.word	LBB_I2COUT		; I2COUT
  8834 D8CC 03 44			.byte	3,'D'
  8835 D8CE 27 D6			.word	LBB_DOS			; DOS
  8836
  8837 				; secondary commands (can't start a statement)
  8838 D8D0 04 54			.byte	4,'T'
  8839 D8D2 8E D7			.word	LBB_TAB			; TAB
  8840 D8D4 04 45			.byte	4,'E'
  8841 D8D6 2D D6			.word	LBB_ELSE		; ELSE
  8842 D8D8 02 54			.byte	2,'T'
  8843 D8DA 9A D7			.word	LBB_TO			; TO
  8844 D8DC 02 46			.byte	2,'F'
  8845 D8DE 41 D6			.word	LBB_FN			; FN
  8846 D8E0 04 53			.byte	4,'S'
  8847 D8E2 74 D7			.word	LBB_SPC			; SPC
  8848 D8E4 04 54			.byte	4,'T'
  8849 D8E6 96 D7			.word	LBB_THEN		; THEN
  8850 D8E8 03 4E			.byte	3,'N'
  8851 D8EA D0 D6			.word	LBB_NOT			; NOT
  8852 D8EC 04 53			.byte	4,'S'
  8853 D8EE 7C D7			.word	LBB_STEP		; STEP
  8854 D8F0 05 55			.byte	5,'U'
  8855 D8F2 A9 D7			.word	LBB_UNTIL		; UNTIL
  8856 D8F4 05 57			.byte	5,'W'
  8857 D8F6 C3 D7			.word	LBB_WHILE		; WHILE
  8858 D8F8 03 4F			.byte	3,'O'
  8859 D8FA DE D6			.word	LBB_OFF			; OFF
  8860
  8861 				; opperators
  8862 D8FC 01 2B			.byte	1,'+'
  8863 D8FE 00 00			.word	$0000			; +
  8864 D900 01 2D			.byte	1,'-'
  8865 D902 00 00			.word	$0000			; -
  8866 D904 01 2A			.byte	1,'*'
  8867 D906 00 00			.word	$0000			; *
  8868 D908 01 2F			.byte	1,'/'
  8869 D90A 00 00			.word	$0000			; /
  8870 D90C 05 4D			.byte	5,'M'
  8871 D90E C3 D6			.word	LBB_MOD			; MOD
  8872 D910 01 5E			.byte	1,'^'
  8873 D912 00 00			.word	$0000			; ^
  8874 D914 03 41			.byte	3,'A'
  8875 D916 C4 D5			.word	LBB_AND			; AND
  8876 D918 03 45			.byte	3,'E'
  8877 D91A 34 D6			.word	LBB_EOR			; EOR
  8878 D91C 02 4F			.byte	2,'O'
  8879 D91E E3 D6			.word	LBB_OR			; OR
  8880 D920 02 3E			.byte	2,'>'
  8881 D922 BA D5			.word	LBB_RSHIFT		; >>
  8882 D924 02 3C			.byte	2,'<'
  8883 D926 B4 D5			.word	LBB_LSHIFT		; <<
  8884 D928 01 3E			.byte	1,'>'
  8885 D92A 00 00			.word	$0000			; >
  8886 D92C 01 3D			.byte	1,'='
  8887 D92E 00 00			.word	$0000			; =
  8888 D930 01 3C			.byte	1,'<'
  8889 D932 00 00			.word	$0000			; <
  8890
  8891 				; functions
  8892 D934 04 53			.byte	4,'S'			;
  8893 D936 67 D7			.word	LBB_SGN			; SGN
  8894 D938 04 49			.byte	4,'I'			;
  8895 D93A 7B D6			.word	LBB_INT			; INT
  8896 D93C 04 41			.byte	4,'A'			;
  8897 D93E C0 D5			.word	LBB_ABS			; ABS
  8898 D940 04 55			.byte	4,'U'			;
  8899 D942 AE D7			.word	LBB_USR			; USR
  8900 D944 04 46			.byte	4,'F'			;
  8901 D946 46 D6			.word	LBB_FRE			; FRE
  8902 D948 04 50			.byte	4,'P'			;
  8903 D94A 0E D7			.word	LBB_POS			; POS
  8904 D94C 04 53			.byte	4,'S'			;
  8905 D94E 78 D7			.word	LBB_SQR			; SQR
  8906 D950 04 52			.byte	4,'R'			;
  8907 D952 50 D7			.word	LBB_RND			; RND
  8908 D954 04 4C			.byte	4,'L'			;
  8909 D956 AD D6			.word	LBB_LOG			; LOG
  8910 D958 04 45			.byte	4,'E'			;
  8911 D95A 37 D6			.word	LBB_EXP			; EXP
  8912 D95C 04 43			.byte	4,'C'			;
  8913 D95E 07 D6			.word	LBB_COS			; COS
  8914 D960 04 53			.byte	4,'S'			;
  8915 D962 6B D7			.word	LBB_SIN			; SIN
  8916 D964 04 54			.byte	4,'T'			;
  8917 D966 92 D7			.word	LBB_TAN			; TAN
  8918 D968 04 41			.byte	4,'A'			;
  8919 D96A CB D5			.word	LBB_ATN			; ATN
  8920 D96C 05 50			.byte	5,'P'			;
  8921 D96E EA D6			.word	LBB_PEEK		; PEEK
  8922 D970 05 44			.byte	5,'D'			;
  8923 D972 13 D6			.word	LBB_DEEK		; DEEK
  8924 D974 05 53			.byte	5,'S'			;
  8925 D976 58 D7			.word	LBB_SADD		; SADD
  8926 D978 04 4C			.byte	4,'L'			;
  8927 D97A 94 D6			.word	LBB_LEN			; LEN
  8928 D97C 05 53			.byte	5,'S'			;
  8929 D97E 84 D7			.word	LBB_STRS		; STR$
  8930 D980 04 56			.byte	4,'V'			;
  8931 D982 B3 D7			.word	LBB_VAL			; VAL
  8932 D984 04 41			.byte	4,'A'			;
  8933 D986 C7 D5			.word	LBB_ASC			; ASC
  8934 D988 07 55			.byte	7,'U'			;
  8935 D98A A2 D7			.word	LBB_UCASES		; UCASE$
  8936 D98C 07 4C			.byte	7,'L'			;
  8937 D98E 87 D6			.word	LBB_LCASES		; LCASE$
  8938 D990 05 43			.byte	5,'C'			;
  8939 D992 F1 D5			.word	LBB_CHRS		; CHR$
  8940 D994 05 48			.byte	5,'H'			;
  8941 D996 58 D6			.word	LBB_HEXS		; HEX$
  8942 D998 05 42			.byte	5,'B'			;
  8943 D99A D4 D5			.word	LBB_BINS		; BIN$
  8944 D99C 07 42			.byte	7,'B'			;
  8945 D99E E5 D5			.word	LBB_BITTST		; BITTST
  8946 D9A0 04 4D			.byte	4,'M'			;
  8947 D9A2 B6 D6			.word	LBB_MAX			; MAX
  8948 D9A4 04 4D			.byte	4,'M'			;
  8949 D9A6 BF D6			.word	LBB_MIN			; MIN
  8950 D9A8 02 50			.byte	2,'P'			;
  8951 D9AA F4 D6			.word	LBB_PI			; PI
  8952 D9AC 05 54			.byte	5,'T'			;
  8953 D9AE 9C D7			.word	LBB_TWOPI		; TWOPI
  8954 D9B0 07 56			.byte	7,'V'			;
  8955 D9B2 B7 D7			.word	LBB_VPTR		; VARPTR
  8956 D9B4 06 4C			.byte	6,'L'			;
  8957 D9B6 8E D6			.word	LBB_LEFTS		; LEFT$
  8958 D9B8 07 52			.byte	7,'R'			;
  8959 D9BA 49 D7			.word	LBB_RIGHTS		; RIGHT$
  8960 D9BC 05 4D			.byte	5,'M'			;
  8961 D9BE BA D6			.word	LBB_MIDS		; MID$
  8962 D9C0 05 50			.byte	5,'P'			;
  8963 D9C2 05 D7			.word	LBB_PORTIN		; PORTIN
  8964 D9C4 06 49			.byte	6,'I'			;
  8965 D9C6 62 D6			.word	LBB_I2CIN		; I2CIN
  8966 D9C8 05 52			.byte	5,'R'			;
  8967 D9CA 39 D7			.word	LBB_RES5		; RESERVED
  8968 D9CC 05 52			.byte	5,'R'			;
  8969 D9CE 3E D7			.word	LBB_RES6		; RESERVED
  8970
  8971 				; BASIC messages, mostly error messages
  8972 D9D0			LAB_BAER
  8973 D9D0 F4 D9			.word	ERR_NF			;$00 NEXT without FOR
  8974 D9D2 05 DA			.word	ERR_SN			;$02 syntax
  8975 D9D4 0C DA			.word	ERR_RG			;$04 RETURN without GOSUB
  8976 D9D6 21 DA			.word	ERR_OD			;$06 out of data
  8977 D9D8 2D DA			.word	ERR_FC			;$08 function call
  8978 D9DA 3B DA			.word	ERR_OV			;$0A overflow
  8979 D9DC 44 DA			.word	ERR_OM			;$0C out of memory
  8980 D9DE 52 DA			.word	ERR_US			;$0E undefined statement
  8981 D9E0 66 DA			.word	ERR_BS			;$10 array bounds
  8982 D9E2 73 DA			.word	ERR_DD			;$12 double dimension array
  8983 D9E4 84 DA			.word	ERR_D0			;$14 divide by 0
  8984 D9E6 93 DA			.word	ERR_ID			;$16 illegal direct
  8985 D9E8 A2 DA			.word	ERR_TM			;$18 type mismatch
  8986 D9EA B0 DA			.word	ERR_LS			;$1A long string
  8987 D9EC C0 DA			.word	ERR_ST			;$1C string too complex
  8988 D9EE D3 DA			.word	ERR_CN			;$1E continue error
  8989 D9F0 E2 DA			.word	ERR_UF			;$20 undefined function
  8990 D9F2 F5 DA			.word 	ERR_LD			;$22 LOOP without DO
  8991
  8992 				; I may implement these two errors to force definition of variables and
  8993 				; dimensioning of arrays before use.
  8994
  8995 				;	.word ERR_UV		;$24 undefined variable
  8996
  8997 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8998
  8999 				;	.word ERR_UA		;$26 undimensioned array
  9000 D9F4 4E 45 58 54 20 77 + ERR_NF	.by	'NEXT without FOR',$00
  9001 DA05 53 79 6E 74 61 78 + ERR_SN	.by	'Syntax',$00
  9002 DA0C 52 45 54 55 52 4E + ERR_RG	.by	'RETURN without GOSUB',$00
  9003 DA21 4F 75 74 20 6F 66 + ERR_OD	.by	'Out of DATA',$00
  9004 DA2D 46 75 6E 63 74 69 + ERR_FC	.by	'Function call',$00
  9005 DA3B 4F 76 65 72 66 6C + ERR_OV	.by	'Overflow',$00
  9006 DA44 4F 75 74 20 6F 66 + ERR_OM	.by	'Out of memory',$00
  9007 DA52 55 6E 64 65 66 69 + ERR_US	.by	'Undefined statement',$00
  9008 DA66 41 72 72 61 79 20 + ERR_BS	.by	'Array bounds',$00
  9009 DA73 44 6F 75 62 6C 65 + ERR_DD	.by	'Double dimension',$00
  9010 DA84 44 69 76 69 64 65 + ERR_D0	.by	'Divide by zero',$00
  9011 DA93 49 6C 6C 65 67 61 + ERR_ID	.by	'Illegal direct',$00
  9012 DAA2 54 79 70 65 20 6D + ERR_TM	.by	'Type mismatch',$00
  9013 DAB0 53 74 72 69 6E 67 + ERR_LS	.by	'String too long',$00
  9014 DAC0 53 74 72 69 6E 67 + ERR_ST	.by	'String too complex',$00
  9015 DAD3 43 61 6E 27 74 20 + ERR_CN	.by	'Can' $27 't continue',$00
  9016 DAE2 55 6E 64 65 66 69 + ERR_UF	.by	'Undefined function',$00
  9017 DAF5 4C 4F 4F 50 20 77 + ERR_LD	.by	'LOOP without DO',$00
  9018
  9019 				;ERR_UV	.byte	'Undefined variable',$00
  9020
  9021 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  9022
  9023 				;ERR_UA	.byte	'Undimensioned array',$00
  9024 DB05 0D 0A 42 72 65 61 + LAB_BMSG	.byte	$0D,$0A,'Break',$00
  9025 DB0D 20 45 72 72 6F 72 + LAB_EMSG	.byte	' Error',$00
  9026 DB14 20 69 6E 20 6C 69 + LAB_LMSG	.byte	' in line ',$00
  9027 DB1E 0D 0A 52 65 61 64 + LAB_RMSG	.byte	$0D,$0A,'Ready',$0D,$0A,$00
  9028
  9029 DB28 20 45 78 74 72 61 + LAB_IMSG	.byte	' Extra ignored',$0D,$0A,$00
  9030 DB39 20 52 65 64 6F 20 + LAB_REDO	.byte	' Redo from start',$0D,$0A,$00
  9031
  9032 DB4C			AA_end_basic
    39 						
    40 DB4C					ORG	$DFD8
    41 				;----------------------------------------------------------------------------
    42 				; This function enables BIOS-ROM at $E000-$FFFF and disables the RAM behind it.
    43 				;----------------------------------------------------------------------------
    44 DFD8 AD 00 17		BIOS2ROM	LDA	MMU		; MMU-register
    45 DFDB 09 01				ORA	#BIOS_EN	; 1 = enable BIOS ROM
    46 DFDD 8D 00 17				STA	MMU		; Activate BIOS ROM
    47 DFE0 60					RTS			; return
    48 						
    49 				;----------------------------------------------------------------------------
    50 				; This function Enables BIOS-RAM at $E000-$FFFF and disables BIOS-ROM.
    51 				;----------------------------------------------------------------------------
    52 DFE1 AD 00 17		BIOS2RAM	LDA	MMU		; MMU-register
    53 DFE4 29 FE				AND	#~BIOS_EN	; 0 = enable BIOS RAM, disable ROM
    54 DFE6 8D 00 17				STA	MMU		; Activate BIOS RAM
    55 DFE9 60					RTS			; return
    56
    57 DFEA					ORG 	$DFF0
    58 DFF0 42			LANGKEY		.byte	'B'
    59 DFF1 28 42 29 61 73 69 + LANGNAME 	.by	'(B)asic' $00
    60
    61 DFF9					ORG 	$E000       		; start address of BIOS (8K)
    62 E000					icl 	"jc2_bios.asm"
Source: jc2_bios.asm
     1 				; ******************************************************************************
     2 				; Junior Computer ][ BIOS Version 1.2.0 by Joerg Walke
     3 				;
     4 				; first implementation 28.12.2021
     5 				; updated 16.11.2024 by Joerg Walke
     6 				;
     7 				; Assembled With A65
     8 				;
     9 				; 20.03.2023 A bug in the disassembler code was fixed by the German Classic 
    10 				; Computing forum user jet2bue. See version history
    11 				;
    12 				; 01.08.2023 A bug in SD_WR_BLK was fixed. The bug was found by German Classic 
    13 				; Computing forum user Dietrich Lausberg. See version history
    14 				;
    15 				; 29.04.2024 SPI & IRQ optimization by Dietrich Lausberg
    16 				;
    17 				; 26.05.24 Changes in Fast SPI by Dietrich Lausberg
    18 				;
    19 				; 21.04.24 Integration with CF-IDE drivers into 1 32K eprom
    20 				; ******************************************************************************
    21
    22 E000 4C 3F E4		MON_COLD_START	JMP  	MAINSTART	; jump to monitor cold start
    23 E003 4C 3E E6		MON_WARM_START	JMP	MONINP		; jump to monitor warm start
    24
    25 				; **** Switch BASIC To RAM Page (B000..DFFF) ***********************************
    26 				; ******************************************************************************
    27 E006 20 8F FD		SWITCH_TO_RAM	JSR	BAS2RAM		; Set MMU bit 7 to 0, enable BASIC RAM
    28 E009 60					RTS			; return
    29
    30 				; **** Switch BASIC To ROM Page (B000..DFFF) ***********************************
    31 				; ******************************************************************************
    32 E00A 20 98 FD		SWITCH_TO_ROM	JSR	BAS2ROM		; Set MMU bit 7 to 1, enable BASIC ROM
    33 E00D EA			SWITCH		NOP			; maintain compatibility with v1.1.4
    34 E00E 60					RTS
    35
    36 				; **** Set Standard In/Out Routine ID ******************************************
    37 				; Input: A - ID Of Standard IO Device
    38 				; ******************************************************************************
    39 E00F 20 BE F7		SET_STDIOID	JSR	DEV_OPEN
    40
    41 				; **** Set Standard In/Out Routine *********************************************
    42 				; Input: X - Low Byte Of Standard Device Descriptor
    43 				;	 Y - High Byte Of Standard Device Descriptor
    44 				; ******************************************************************************
    45 E012 20 32 E0		SET_STDIO	JSR	SET_STDIN
    46 E015 4C 1F E0				JMP	SET_STDOUT0
    47
    48 				; **** Set Standard Out Routine ID *********************************************
    49 				; Input: A - ID Of Standard Output Device
    50 				; ******************************************************************************
    51 E018 20 BE F7		SET_STDOUTID	JSR	DEV_OPEN
    52
    53 				; **** Set Standard Out Routine ************************************************
    54 				; Input: X - Low Byte Of Standard Out Device Descriptor
    55 				;	 Y - High Byte Of Standard Out Device Descriptor
    56 				; ******************************************************************************
    57 E01B 86 DE		SET_STDOUT	STX	PDEVL
    58 E01D 84 DF				STY	PDEVH
    59 E01F A0 04		SET_STDOUT0	LDY	#$04
    60 E021 A2 00				LDX	#$00
    61 E023 B1 DE		SET_STDOUT1	LDA	(PDEV),Y
    62 E025 9D 70 1A				STA	STDOUT,X
    63 E028 C8					INY
    64 E029 E8					INX
    65 E02A E0 04				CPX	#$04
    66 E02C D0 F5				BNE	SET_STDOUT1
    67 E02E 60					RTS
    68
    69 				; **** Set Standard In Routine ID **********************************************
    70 				; Input: A - ID Of Standard Input Device
    71 				; ******************************************************************************
    72 E02F 20 BE F7		SET_STDINID	JSR	DEV_OPEN
    73
    74 				; **** Set Standard In Routine *************************************************
    75 				; Input: X - Low Byte Of Standard In Device Descriptor
    76 				;	 Y - High Byte Of Standard In Device Descriptor
    77 				; ******************************************************************************
    78 E032 86 DE		SET_STDIN	STX	PDEVL
    79 E034 84 DF				STY	PDEVH
    80 E036 A0 02				LDY	#$02
    81 E038 B1 DE				LDA	(PDEV),Y
    82 E03A 8D 6E 1A				STA	STDIN
    83 E03D C8					INY
    84 E03E B1 DE				LDA	(PDEV),Y
    85 E040 8D 6F 1A				STA	STDIN+1
    86 E043 60			         	RTS
    87
    88 				; **** Write Binary Routine ****************************************************
    89 				; Input: A - Output Byte to Standard Out
    90 				; ******************************************************************************
    91 E044 6C 70 1A		BOUT		JMP	(STDOUT)
    92
    93 				; **** Read Character Routine **************************************************
    94 				; Output: A - character read from standard in
    95 				; ******************************************************************************
    96 E047 20 4D E0		CIN		JSR	CGET		; call standard in. Character available?
    97 E04A 90 FB				BCC	CIN		; no, repeat
    98 E04C 60					RTS
    99
   100 				; **** Get Character (no wait) Routine *****************************************
   101 				; Output: A - character read from standard in
   102 				;         C - 1 char get, 0 no char get
   103 				; ******************************************************************************
   104 E04D 4C D4 E1		CGET            JMP     CHAR_GET
   105
   106 				; **** Write LF Character Routine **********************************************
   107 				; ******************************************************************************
   108 E050 A9 0A		LFOUT		LDA  	#LF        	; write a LF
   109 									; fall through to COUT
   110
   111 				; **** Write Character Routine *************************************************
   112 				; Input: A - character to write
   113 				; ******************************************************************************
   114 E052 20 44 E0		COUT 		JSR     BOUT
   115 E055 C9 0D		                CMP  	#CR        	; character was a CR?
   116 E057 F0 F7				BEQ  	LFOUT      	; yes, also write LF
   117 E059 60					RTS
   118
   119 				; **** Write CR/LF To Terminal *************************************************
   120 				; ******************************************************************************
   121 E05A A9 0D		CROUT		LDA	#CR		; write a CR
   122 E05C D0 F4				BNE	COUT
   123
   124 				; **** Write Single Space Char To Terminal *************************************
   125 				; ******************************************************************************
   126 E05E A9 20		SPCOUT		LDA	#$20		; write a Space char
   127 E060 D0 E2				BNE	BOUT
   128
   129 				; **** Read String Routine *****************************************************
   130 				; Output:  (PSTRL, PSTRH) - pointer to CR terminated string data
   131 				; ******************************************************************************
   132 E062 A2 02		STRIN           LDX  	#$02		; initialize character index
   133 E064 CA			BACKSPACE       DEX
   134 E065 F0 FB				BEQ  	STRIN		; if line empty, restart
   135 E067 20 47 E0		NEXTCHR         JSR  	CIN        	; get next character from input buffer
   136 E06A 9D 00 14				STA  	STRBUF,X   	; store character in string buffer
   137 E06D C9 0D				CMP  	#CR		; is it a CR?
   138 E06F F0 0F		                BEQ  	ENDSTRIN	; yes, exit
   139 E071 20 52 E0		                JSR  	COUT		; echo character
   140 E074 C9 08				CMP  	#BS        	; backspace key?
   141 E076 F0 EC				BEQ  	BACKSPACE  	; yes
   142 E078 E8			                INX             	; advance string index
   143 E079 D0 EC		                BNE  	NEXTCHR    	; more then 255 characters? No, read next char
   144 E07B A9 0D		                LDA  	#CR        	; yes, auto new line and stop reading
   145 E07D 9D 00 14				STA  	STRBUF,X   	; store CR in string buffer
   146 E080 4C 52 E0		ENDSTRIN        JMP  	COUT       	; send CR
   147
   148 				; **** Write String Routine ****************************************************
   149 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   150 				; ******************************************************************************
   151 E083 A0 00		STROUT		LDY  	#$00       	; index y is 0
   152
   153 				; **** Write String From Index Routine *****************************************
   154 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   155 				;	  Y              - start index into string data
   156 				; ******************************************************************************
   157 E085 B1 EA		WRSTR		LDA  	(PSTR),Y   	; load char at string pos y
   158 E087 F0 07				BEQ  	ENDSTROUT  	; exit, if NULL char
   159 E089 20 52 E0				JSR  	COUT       	; write character
   160 E08C C8					INY             	; next index
   161 E08D 4C 85 E0				JMP  	WRSTR
   162 E090 60			ENDSTROUT	RTS
   163
   164 				; **** Print A Byte In Hexadecimal *********************************************
   165 				; Input: A - data byte to print in hex
   166 				; ******************************************************************************
   167 E091 48			HEXOUT          PHA             	; save A for lower hex digit
   168 E092 4A			                LSR  	
   169 E093 4A			                LSR  	
   170 E094 4A			                LSR  	
   171 E095 4A			                LSR  	
   172 E096 20 9A E0		                JSR  	HEXDIG		; write upper hex digit
   173 E099 68			                PLA             	; write lower hex digit
   174 									; fall through to HEXDIG
   175
   176 				; **** Print A Single Hexadecimal Digit ****************************************
   177 				; Input: A - data nibble in Bit 0-3 to print in hex
   178 				; ******************************************************************************
   179 E09A 29 0F		HEXDIG          AND     #$0F    	; mask lower digit
   180 E09C 09 30		                ORA     #'0'    	; add 48
   181 E09E C9 3A		                CMP     #'9'+1  	; decimal digit?
   182 E0A0 90 02		                BCC     PRHEX   	; yes, print it
   183 E0A2 69 06		                ADC     #6      	; add offset for letter digit
   184 E0A4 4C 44 E0		PRHEX		JMP     BOUT
   185
   186 				; **** Print A Byte As Decimal Number ******************************************
   187 				; Input: A - number 00..FF (0..255)
   188 				; ******************************************************************************
   189 E0A7 20 BD E0		NUMOUT		JSR	DEC2STR
   190 E0AA A2 02				LDX	#2
   191 E0AC B5 F8		NEXTNUMOUT	LDA	DIG0,X
   192 E0AE 20 44 E0				JSR	BOUT
   193 E0B1 CA					DEX
   194 E0B2 10 F8				BPL	NEXTNUMOUT
   195 E0B4 60					RTS
   196
   197 				; **** Clear Screen Routine ****************************************************
   198 				; ******************************************************************************
   199 E0B5 A9 07		CLRSCRN		LDA	#CMD_CLRSCRN
   200
   201 				; **** Call Standard Print Command Routine *************************************
   202 				; Input : A - command byte
   203 				;         X - command data byte low
   204 				;         Y - command data byte high
   205 				; ******************************************************************************
   206 E0B7 6C 72 1A		CMDPRINT	JMP	(STDCMD)
   207
   208 				; **** Call Opened Device Command Routine **************************************
   209 				; Input : A - command byte
   210 				;         X - command data byte low
   211 				;         Y - command data byte high
   212 				; ******************************************************************************
   213 E0BA 6C 6C 1A		CMDDEV		JMP	(DEVCMD)
   214
   215 				; **** Convert a Byte To Decimal String ****************************************
   216 				; Input:  A - number 00..FF (0..255)
   217 				; Output; DIG0 (10^0), DIG1 (10^1), DIG2 (10^2)
   218 				; ******************************************************************************
   219 E0BD A2 30		DEC2STR		LDX	#48
   220 E0BF 86 F8				STX	DIG0		; initialize digit counter 0 to '0'
   221 E0C1 86 F9				STX	DIG1		; initialize digit counter 1 to '0'
   222 E0C3 86 FA				STX	DIG2		; initialize digit counter 2 to '0'
   223 E0C5 C9 64		GETDIG2		CMP	#100		; is A >= 100?
   224 E0C7 90 06				BCC	GETDIG1		; no, convert next digit
   225 E0C9 E9 64				SBC	#100		; yes, subract 100 from A
   226 E0CB E6 FA				INC	DIG2		; and increment digit counter 2
   227 E0CD D0 F6				BNE	GETDIG2		; branch always
   228 E0CF C9 0A		GETDIG1		CMP	#10		; is A >= 10?
   229 E0D1 90 06				BCC	GETDIG0		; no, convert next digit
   230 E0D3 E9 0A				SBC	#10		; yes, subract 10 from A
   231 E0D5 E6 F9				INC	DIG1		; and increment digit counter 1
   232 E0D7 D0 F6				BNE	GETDIG1		; branch always
   233 E0D9 65 F8		GETDIG0		ADC	DIG0		; add digit counter 0 to remainder in A
   234 E0DB 85 F8				STA	DIG0		; and store it back to digit counter 0
   235 E0DD 60					RTS
   236
   237 				; **** Print Tab Routine *******************************************************
   238 				; Input: A - number of space characters to print
   239 				; ******************************************************************************
   240 E0DE 85 FC		TAB		STA  	TEMP
   241 E0E0 A9 20				LDA  	#SPC		; load SPC char
   242 E0E2 20 52 E0		PRINTTAB	JSR  	COUT		; write SPC
   243 E0E5 C6 FC				DEC   	TEMP
   244 E0E7 D0 F9		                BNE   	PRINTTAB   	; all spaces written? No, repeat
   245 E0E9 60					RTS
   246
   247 				; **** Read Hex Number From Input String ***************************************
   248 				; Input:  Y - current input string position to read from
   249 				; Output: (NUML, NUMH) - last 8 digits of read hex number
   250 				; ******************************************************************************
   251 E0EA A2 00		HEXINPUT	LDX   	#$00
   252 E0EC 86 F8				STX   	NUML       	; clear input value
   253 E0EE 86 F9				STX   	NUMH
   254 E0F0 B9 00 14		NEXTDIGIT       LDA   	STRBUF,Y   	; get next input char
   255 E0F3 C9 30				CMP   	#'0'
   256 E0F5 90 21				BCC   	NOTHEX     	; char < '0'? Yes, no hex digit
   257 E0F7 C9 3A				CMP   	#':'
   258 E0F9 90 0C				BCC   	NUMDIGIT   	; char is in '0'..'9'
   259 E0FB 29 DF				AND   	#$DF	 	; uppercase chars only
   260 E0FD C9 41		HEXDIGIT	CMP   	#'A'
   261 E0FF 90 17				BCC   	NOTHEX     	; char < 'A'? Yes, no hex digit
   262 E101 C9 47				CMP   	#'G'
   263 E103 B0 13				BCS   	NOTHEX     	; char > 'F'? Yes, no hex digit
   264 E105 E9 36				SBC   	#'A'-11	 	; char 'A'..'F' to value 10..16
   265 E107 0A			NUMDIGIT        ASL   	
   266 E108 0A					ASL   	
   267 E109 0A					ASL   	
   268 E10A 0A					ASL   			; digit shifted to upper nibble
   269 E10B A2 04				LDX   	#$04      	; load shift loop counter
   270 E10D 0A			SHIFT		ASL   			; shift msb in C
   271 E10E 26 F8				ROL   	NUML
   272 E110 26 F9				ROL   	NUMH
   273 E112 CA					DEX
   274 E113 D0 F8				BNE   	SHIFT	 	; 4 times shifted? No, repeat
   275 E115 C8					INY		 	; increment string index
   276 E116 D0 D8				BNE   	NEXTDIGIT	; branch always
   277 E118 60			NOTHEX		RTS
   278
   279 				; **** Read String From Input Buffer *******************************************
   280 				; Input:  Y - current input string position to read from
   281 				; Output: C = 1, string found C = 0, string not found
   282 				;         PSTRL = low byte of string pointer
   283 				;	  PSTRH = high byte of string pointer
   284 				; ******************************************************************************
   285 E119 18			STRINPUT	CLC
   286 E11A B9 00 14		NEXTSTRCHAR	LDA  	STRBUF,Y   	; get next input char
   287 E11D C8					INY
   288 E11E C9 20				CMP  	#' '
   289 E120 F0 F8				BEQ  	NEXTSTRCHAR 	; ignore spaces
   290 E122 C9 0D				CMP  	#CR
   291 E124 F0 19				BEQ  	ENDSTRING 	; end of input line, no filename found
   292 E126 C9 22				CMP	#'"'
   293 E128 D0 15				BNE	ENDSTRING
   294 E12A A2 00				LDX	#$00
   295 E12C 38					SEC
   296 E12D B9 00 14		READSTRING	LDA  	STRBUF,Y   	; get next input char
   297 E130 C9 0D				CMP	#CR
   298 E132 F0 0B				BEQ	ENDSTRING
   299 E134 C9 22				CMP	#'"'
   300 E136 F0 07				BEQ	ENDSTRING
   301 E138 9D 00 15				STA	RBUFF,X		; char to buffer
   302 E13B C8					INY
   303 E13C E8					INX
   304 E13D D0 EE				BNE	READSTRING	; read next char of filename
   305 E13F A9 00		ENDSTRING	LDA	#$00
   306 E141 9D 00 15				STA	RBUFF,X		; terminate filename string with NULL
   307
   308 				; **** Set String Pointer To Read Buffer ***************************************
   309 				; Output: X - low byte of string pointer
   310 				;	  Y - high byte of string pointer
   311 				; ******************************************************************************
   312
   313 E144 A2 00		SETSTRBUFF	LDX	#< RBUFF	; set string pointer to filename buffer
   314 E146 A0 15				LDY	#> RBUFF
   315 E148 86 EA		SETSTRBUFF0	STX	PSTRL
   316 E14A 84 EB				STY	PSTRH
   317 E14C 60					RTS
   318
   319 				; **** Delay Routine ***********************************************************
   320 				; Input: A - milliseconds to wait
   321 				; ******************************************************************************
   322 E14D 8D 97 1A		DELAY           STA  	CNTD
   323 E150 D0 04				BNE	LOOPDELAY
   324
   325 				; **** Short Delay Routine *****************************************************
   326 				; Input: A - microseconds to wait
   327 				; ******************************************************************************
   328 E152 A8			SHORTDELAY	TAY
   329 E153 8C 94 1A		SHORTDELAY1	STY  	CNTA		; set counter
   330 E156 2C 9F 1A		LOOPDELAY	BIT  	CNTIRQ		; check if counter reached 0
   331 E159 10 FB				BPL  	LOOPDELAY	; no, check again
   332 E15B 60					RTS
   333
   334 				; **** Check ESC Routine *******************************************************
   335 				; Output: C = 1 ESC pressed, 0 ESC not pressed
   336 				; Beep if ESC pressed
   337 				; ******************************************************************************
   338 E15C 20 4D E0		CHKESC		JSR     CGET            ; key pressed?
   339 E15F 90 05				BCC	NOTESC		; no
   340 E161 C9 1B				CMP     #ESC		; ESC pressed?
   341 E163 F0 02				BEQ	BEEP		; yes, exit and beep.
   342 E165 18					CLC			; no, clear carry flag
   343 E166 60			NOTESC		RTS
   344
   345 				; **** System Beep Routine *****************************************************
   346 				; ******************************************************************************
   347 E167 6C 66 1A		BEEP		JMP	(STDBEEP)	; call standard BEEP routine
   348
   349 				; **** Simple Beep Routine *****************************************************
   350 				; ******************************************************************************
   351 E16A AD 83 1A		DOBEEP		LDA	PBDD		; save port b data direction register
   352 E16D 48					PHA
   353 E16E A2 60				LDX     #$60		; repeat 60 times
   354 E170 A9 21				LDA     #$21
   355 E172 A8					TAY
   356 E173 8D 83 1A				STA     PBDD		; turn speaker on
   357 E176 8C 82 1A		BEEPLOOP	STY     PBD		; set PB0 high
   358 E179 A9 01				LDA     #$01
   359 E17B 20 4D E1				JSR     DELAY		; delay of ~1ms
   360 E17E 88					DEY
   361 E17F 8C 82 1A				STY	PBD		; set PB0 low
   362 E182 A9 01				LDA	#$01
   363 E184 20 4D E1				JSR	DELAY		; delay of ~1ms
   364 E187 A0 21				LDY	#$21
   365 E189 CA					DEX
   366 E18A D0 EA				BNE	BEEPLOOP	; not finished, repeat
   367 E18C 68					PLA
   368 E18D 8D 83 1A				STA	PBDD		; restore port b data direction register
   369 E190 38					SEC
   370 E191 60					RTS
   371
   372 				; ******************************************************************************
   373 				; REAL TIME CLOCK ROUTINES ALIASES
   374 				; ******************************************************************************
   375
   376 				; **** Print Date And Time *****************************************************
   377
   378 				; ******************************************************************************
   379
   380 E192 4C F9 EB		PRINT_DATETIME	JMP	PRINTDATETIME
   381
   382 				; **** Print Time *************************************************************
   383
   384 				; ******************************************************************************
   385
   386 E195 4C 05 EC		PRINT_TIME	JMP	PRINTTIME
   387
   388 				; **** Print Date **************************************************************
   389
   390 				; ******************************************************************************
   391
   392 E198 4C 2B EC		PRINT_DATE	JMP	PRINTDATE
   393
   394 				; **** Print Date Including Day Of Week ****************************************
   395
   396 				; ******************************************************************************
   397
   398 E19B 4C 17 EC		PRINT_FULLDATE	JMP	PRINTFULLDATE
   399
   400 				; **** Set Date And Time *******************************************************
   401
   402 				; ******************************************************************************
   403
   404 E19E 4C 59 EB		SET_DATETIME	JMP	SETDATETIME
   405
   406 				; **** Set Time ****************************************************************
   407
   408 				; ******************************************************************************
   409
   410 E1A1 4C 86 EB		SET_TIME	JMP	SETTIME
   411
   412 				; **** Set Date ****************************************************************
   413
   414 				; ******************************************************************************
   415
   416 E1A4 4C 5C EB		SET_DATE	JMP	SETDATE
   417
   418 				; **** Add Storage Device ******************************************************
   419
   420 				; Input:   X - device descriptor pointer low
   421 				;          Y - device descriptor pointer high
   422 				; Output - C = 1 Success, C = 0 Error
   423 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
   424
   425 				; ******************************************************************************
   426
   427 E1A7 4C 6F F7		ADD_DEVICE	JMP	DEV_ADD
   428
   429 				; **** Open Device For Read/Write **********************************************
   430
   431 				; Input:  A - device id
   432 				; Output: C = 1 Success, C = 0 Error
   433 				;         X - device descriptor pointer low
   434 				;         Y - device descriptor pointer high
   435
   436 				; ******************************************************************************
   437
   438 E1AA 4C BE F7		OPEN_DEVICE	JMP	DEV_OPEN
   439
   440 				; **** Reset Standard I/O To First Screen Device *******************************
   441
   442 				; ******************************************************************************
   443
   444 E1AD AD 74 1A		RESET_STDIO	LDA	STDINDEV	; open base In device
   445 E1B0 20 2F E0				JSR	SET_STDINID	; and set it as standard input
   446 E1B3 AD 75 1A				LDA	STDOUTDEV	; open base Out device
   447 E1B6 4C 18 E0				JMP	SET_STDOUTID	; and set it as standard output
   448
   449 				; **** Read Joystick Port ******************************************************
   450
   451 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   452 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   453 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   454 				;         C = 0 - No joystick port available; C = 1 - Joystickport available
   455
   456 				; ******************************************************************************
   457
   458 E1B9 4C 15 F7		READ_JOYSTICK   JMP     READ_JOY_PORT
   459
   460 				; **** Decode Joystick Data ****************************************************
   461
   462 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   463 				;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   464 				;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   465
   466 				; ******************************************************************************
   467
   468 E1BC 4C 1D F7		DECODE_JOYSTICK JMP     DECODE_JOY_PORT
   469
   470 				; **** Mute All Sound Chip Channels ********************************************
   471
   472 				; ******************************************************************************
   473
   474 E1BF 4C D0 E3		SOUND_MUTE_ALL  JMP     SOUND_MUTEALL
   475
   476 				; **** Mute A Sound Chip Channel ***********************************************
   477
   478 				; Input: A - Channel # (0..3)
   479
   480 				; ******************************************************************************
   481
   482 E1C2 4C DA E3		SOUND_MUTE_CHAN JMP     SOUND_MUTE
   483
   484 				; **** Set Attenuation For A Sound Chip Channel ********************************
   485
   486 				; Input: A - Channel # (0..3)
   487 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
   488
   489 				; ******************************************************************************
   490
   491 E1C5 4C DC E3		SOUND_SET_ATN   JMP     SOUND_SETATN
   492
   493 				; **** Set Periodic Noise ******************************************************
   494
   495 				; Input: X - Noise Shift Rate
   496
   497 				; ******************************************************************************
   498
   499 E1C8 4C EA E3		SOUND_P_NOISE   JMP     SOUND_PNOISE
   500
   501 				; **** Set White Noise *********************************************************
   502
   503 				; Input: X - Noise Shift Rate
   504
   505 				; ******************************************************************************
   506
   507 E1CB 4C EE E3		SOUND_W_NOISE   JMP     SOUND_WNOISE
   508
   509 				; **** Set Noise ***************************************************************
   510
   511 				; Input: A - 0 = Periodic Noise  1 = White Noise
   512 				;	 X - Noise Shift Rate
   513
   514 				; ******************************************************************************
   515
   516 E1CE 4C F0 E3		SOUND_SET_NOISE JMP     SOUND_SETNOISE
   517
   518 				; **** Set Sound Frequency in HZ ***********************************************
   519
   520 				; Input: A - Channel (0..2)
   521 				;	 X - Frequency Low Bits 7..0
   522 				;	 Y - Frequency High Bits 9..8
   523
   524 				; ******************************************************************************
   525
   526 E1D1 4C FB E3		SOUND_SET_FREQ  JMP     SOUND_SETFREQ
   527
   528 				; ******************************************************************************
   529 				; INTERNAL
   530 				; ******************************************************************************
   531
   532 				; **** Extended Read-Character Handler *****************************************
   533
   534 E1D4 20 DF E1		CHAR_GET        JSR     READ_STD_IN
   535 E1D7 90 03		                BCC     NO_CHAR_GET
   536 E1D9 6C 24 1A		                JMP     (KEY_HANDLER)
   537 E1DC 6C 26 1A		NO_CHAR_GET     JMP     (NKEY_HANDLER)
   538 E1DF 6C 6E 1A		READ_STD_IN     JMP	(STDIN)
   539
   540 				; ******************************************************************************
   541 				; TTY DEVICE DRIVER
   542 				; ******************************************************************************
   543
   544 				; **** Terminal Command Routine ************************************************
   545
   546 				; Input : A - command byte
   547 				;         X - command data byte low
   548 				;         Y - command data byte high
   549
   550 				; ******************************************************************************
   551
   552 E1E2 C9 09		TTY_CMD		CMP	#9
   553 E1E4 B0 13				BCS	END_TTY_CMD
   554 E1E6 84 FD				STY	YSAV
   555 E1E8 0A					ASL	
   556 E1E9 A8					TAY
   557 E1EA B9 FA E1				LDA	TTY_CMD_TABLE,Y
   558 E1ED 85 EA				STA	PSTRL
   559 E1EF B9 FB E1				LDA	TTY_CMD_TABLE+1,Y
   560 E1F2 85 EB				STA	PSTRH
   561 E1F4 A4 FD				LDY	YSAV
   562 E1F6 6C EA 00				JMP     (PSTR)
   563 E1F9 60			END_TTY_CMD	RTS
   564
   565 E1FA 0C E2 3A E2 3E E2 + TTY_CMD_TABLE	.word	TTY_INIT,TTY_IDENTIFY,TTY_NORMAL,TTY_INVERSE,TTY_FLASH
   566 E204 4A E2 4E E2 57 E2 + 		.word	TTY_HOME,TTY_CLRLINE,TTY_CLRSCRN,TTY_SETCURSOR
   567
   568 				; **** Initialize TTY Device ***************************************************
   569
   570 				; ******************************************************************************
   571
   572 E20C A9 00		TTY_INIT	LDA  	#$00
   573 E20E 85 E0				STA  	BAUDRATE   	; initialize baud rate variable
   574 E210 A9 0B				LDA  	#$0B       	; set ACIA to
   575 E212 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   576 E215 A2 19				LDX  	#$19		; start with 1 stop bit, 8 data bits, 2400 bps as the current baud rate
   577 E217 8E 03 16		NEXTBAUD	STX  	CTRL_REG	; set the baud rate
   578 E21A 20 3A E2				JSR  	TTY_IDENTIFY	; send identify string to terminal
   579 E21D A9 28				LDA  	#40
   580 E21F 20 4D E1				JSR  	DELAY		; wait for ~64ms
   581 E222 AD 01 16				LDA  	STAT_REG
   582 E225 29 08				AND  	#$08		; ACIA input register full?
   583 E227 F0 0B				BEQ  	NOESC	 	; no, go on
   584 E229 AD 00 16				LDA  	DATA_REG    	; read data register from ACIA
   585 E22C C9 1B				CMP  	#ESC	 	; is it a ESC char
   586 E22E D0 04				BNE  	NOESC	 	; no, go on
   587 E230 86 E0				STX  	BAUDRATE    	; and store it
   588 E232 A2 1F				LDX  	#$1F	 	; detection finished
   589 E234 E8			NOESC           INX  			; try next baud rate
   590 E235 E0 20				CPX  	#$20
   591 E237 90 DE				BCC  	NEXTBAUD   	; tried all baud rates?
   592 E239 60					RTS
   593
   594 				; **** Identify TTY Device *****************************************************
   595
   596 				; ******************************************************************************
   597
   598 E23A A0 09		TTY_IDENTIFY    LDY  	#ESCGID-STRINGP	; load sequence index
   599 E23C D0 1B				BNE  	PRINTESC   	; jump always
   600
   601 				; **** Set Normal Text *********************************************************
   602
   603 				; ******************************************************************************
   604
   605 E23E A0 0C		TTY_NORMAL      LDY  	#ESCNORM-STRINGP; load sequence index
   606 E240 D0 17				BNE  	PRINTESC   	; jump always
   607
   608 				; **** Set Inverse Text ********************************************************
   609
   610 				; ******************************************************************************
   611
   612 E242 A0 0E		TTY_INVERSE     LDY  	#ESCINV-STRINGP ; load sequence index
   613 E244 D0 13				BNE  	PRINTESC   	; jump always
   614
   615 				; **** Set Blinking Text *******************************************************
   616
   617 				; ******************************************************************************
   618
   619 E246 A0 11		TTY_FLASH       LDY  	#ESCBLNK-STRINGP; load sequence index
   620 E248 D0 0F				BNE  	PRINTESC   	; jump always
   621
   622 				; **** Set Cursor To Home Position *********************************************
   623
   624 				; ******************************************************************************
   625
   626 E24A A0 04		TTY_HOME        LDY  	#ESCHOME-STRINGP; load sequence index
   627 E24C D0 0B				BNE  	PRINTESC   	; jump always
   628
   629 				; **** Clear Line **************************************************************
   630
   631 				; ******************************************************************************
   632
   633 E24E A9 0D		TTY_CLRLINE     LDA	#$0D
   634 E250 20 44 E0				JSR	BOUT
   635 E253 A0 06				LDY  	#ESCCLL-STRINGP	; load sequence index
   636 E255 D0 02				BNE  	PRINTESC   	; jump always
   637
   638 				; **** Clear Screen And Set Cursor To Home Position ****************************
   639
   640 				; ******************************************************************************
   641
   642 E257 A0 00		TTY_CLRSCRN     LDY  	#ESCCLS-STRINGP	; load sequence index
   643 									; fall through to PRINTESC
   644
   645 				; **** VT100 ESC Sequence Loader ***********************************************
   646
   647 				; ******************************************************************************
   648
   649 E259 20 62 E2		PRINTESC        JSR	TTY_ESCCODE
   650 E25C 20 43 E5				JSR	LOADSTRING
   651 E25F 4C 85 E0				JMP  	WRSTR
   652
   653 				; **** VT100 ESC Start Code ****************************************************
   654
   655 				; ******************************************************************************
   656
   657 E262 A9 1B		TTY_ESCCODE	LDA	#$1B
   658 E264 20 44 E0				JSR	BOUT
   659 E267 A9 5B				LDA	#'['
   660 E269 4C 44 E0				JMP	BOUT
   661
   662 				; **** Set Cursor Location *****************************************************
   663
   664 				; Input: X - x position of cursor.  Y - y position of cursor
   665
   666 				; ******************************************************************************
   667
   668 E26C 8A			TTY_SETCURSOR	TXA
   669 E26D 48					PHA
   670 E26E 20 62 E2				JSR	TTY_ESCCODE
   671 E271 98					TYA
   672 E272 20 A7 E0				JSR	NUMOUT
   673 E275 A9 3B				LDA	#';'
   674 E277 20 44 E0				JSR	BOUT
   675 E27A 68					PLA
   676 E27B 20 A7 E0				JSR	NUMOUT
   677 E27E A9 48				LDA	#'H'
   678 E280 4C 44 E0				JMP	BOUT
   679
   680 				; ******************************************************************************
   681 				; LOW LEVEL REAL TIME CLOCK CODE
   682 				; ******************************************************************************
   683
   684 				; **** Set Day Of Week *********************************************************
   685
   686 				; Input: A - Day Of Week 1 (MON) - 7 (SUN)
   687
   688 				; ******************************************************************************
   689
   690 E283 85 F3		WRITEDOW	STA	ACC
   691 E285 A9 03				LDA	#$03
   692 E287 20 13 E3				JSR	SETRTCADR
   693 E28A A5 F3				LDA	ACC
   694 E28C 20 67 E3				JSR	I2C_SEND	; set day of week
   695 E28F 4C 35 E3				JMP	I2C_STOP
   696
   697 				; **** Get Day Of Week *********************************************************
   698
   699 				; Output: A - Day Of Week 1 (MON) - 7 (SUN)
   700
   701 				; ******************************************************************************
   702
   703 E292 A9 03		READDOW		LDA	#$03
   704 E294 20 E6 E2				JSR	READCLOCK
   705 E297 98					TYA
   706 E298 60					RTS
   707
   708 				; **** Write Time **************************************************************
   709
   710 				; Input: A - HOUR 	in BCD ($00-$23)
   711 				;	 X - MINUTE 	in BCD ($00-$59)
   712 				;	 Y - SECOND	in BCD ($00-$59)
   713
   714 				; ******************************************************************************
   715
   716 E299 85 F3		WRITETIME	STA	ACC
   717 E29B 86 F5				STX	XREG
   718 E29D 84 F4				STY	YREG
   719 E29F A9 00		WRITETIME2	LDA	#$00		; start at register 0
   720 E2A1 20 C9 E2				JSR	WRITECLOCK	; write time bytes to clock registers
   721 E2A4 A9 08				LDA	#$08		; set address pointer to ram
   722 E2A6 20 13 E3				JSR	SETRTCADR
   723 E2A9 A9 65				LDA	#$65		; time set mark
   724 E2AB 20 67 E3				JSR	I2C_SEND
   725 E2AE 4C 35 E3				JMP	I2C_STOP
   726
   727 				; **** Write Date **************************************************************
   728
   729 				; Input: A - YEAR 	in BCD ($00-$99)
   730 				;	 X - MONTH 	in BCD ($01-$12)
   731 				;	 Y - DAY	in BCD ($01-$31)
   732
   733 				; ******************************************************************************
   734
   735 E2B1 85 F3		WRITEDATE	STA	ACC
   736 E2B3 86 F5				STX	XREG
   737 E2B5 84 F4				STY	YREG
   738 E2B7 A9 04		WRITEDATE2	LDA	#$04		; start at register 4
   739 E2B9 20 C9 E2				JSR	WRITECLOCK	; write date bytes to clock register
   740 E2BC A9 09				LDA	#$09		; set address pointer to ram
   741 E2BE 20 13 E3				JSR	SETRTCADR
   742 E2C1 A9 02				LDA	#$02		; date set mark
   743 E2C3 20 67 E3				JSR	I2C_SEND
   744 E2C6 4C 35 E3				JMP	I2C_STOP
   745
   746 				; **** Write Data To Clock *****************************************************
   747
   748 				; ******************************************************************************
   749
   750 E2C9 20 13 E3		WRITECLOCK	JSR	SETRTCADR
   751 E2CC A5 F4				LDA	YREG
   752 E2CE 20 67 E3				JSR	I2C_SEND	; set second or day
   753 E2D1 A5 F5				LDA	XREG
   754 E2D3 20 67 E3				JSR	I2C_SEND	; set minute or month
   755 E2D6 A5 F3				LDA	ACC
   756 E2D8 20 67 E3				JSR	I2C_SEND	; set hour or year
   757 E2DB 4C 35 E3				JMP	I2C_STOP
   758
   759 				; **** Read Time ***************************************************************
   760
   761 				; Output: A - HOUR 	in BCD ($00-$23)
   762 				;	  X - MINUTE 	in BCD ($00-$59)
   763 				;	  Y - SECOND	in BCD ($00-$59)
   764
   765 				; ******************************************************************************
   766
   767 E2DE A9 00		READTIME	LDA	#$00
   768 E2E0 F0 04				BEQ	READCLOCK
   769
   770 				; **** Read Date ***************************************************************
   771
   772 				; Output: A - YEAR 	in BCD ($00-$99)
   773 				; 	  X - MONTH 	in BCD ($01-$12)
   774 				; 	  Y - DAY	in BCD ($01-$31)
   775
   776
   777 				; ******************************************************************************
   778
   779 E2E2 A9 04		READDATE	LDA	#$04
   780 E2E4 D0 00				BNE	READCLOCK
   781
   782 				; **** Read Data From Clock ****************************************************
   783
   784 				; ******************************************************************************
   785
   786 E2E6 20 13 E3		READCLOCK	JSR	SETRTCADR	; set read pointer
   787 E2E9 20 26 E3				JSR	I2C_START	; send start condition
   788 E2EC A9 68				LDA	#I2C_RTC_ADR	; the I2C address
   789 E2EE 20 62 E3				JSR	I2C_READ_DEV	; send device id and set read mode
   790 E2F1 20 9F E3				JSR	I2C_RCV		; receive first data byte
   791 E2F4 85 F4				STA	YREG		; and store it
   792 E2F6 20 44 E3				JSR	I2C_ACK		; send acknowlege
   793 E2F9 20 9F E3				JSR	I2C_RCV		; receive second data byte
   794 E2FC 85 F5				STA	XREG		; and store it
   795 E2FE 20 44 E3				JSR	I2C_ACK		; send acknowlege
   796 E301 20 9F E3				JSR	I2C_RCV		; receive third data byte
   797 E304 85 F3				STA	ACC		; and store it
   798 E306 20 53 E3				JSR	I2C_NACK	; no more data
   799 E309 20 35 E3				JSR	I2C_STOP	; stop communication
   800 E30C A5 F3				LDA	ACC		; load third data byte into A
   801 E30E A6 F5				LDX	XREG		; load second data byte into X
   802 E310 A4 F4				LDY	YREG		; load first data byte into Y
   803 E312 60					RTS
   804
   805 				; **** Set RTC Address Read/Write Pointer **************************************
   806
   807 				; Input: A - Register Address
   808
   809 				; ******************************************************************************
   810
   811 E313 48			SETRTCADR	PHA			; save register address onto stack
   812 E314 20 26 E3				JSR	I2C_START	; send start condition
   813 E317 A9 68				LDA	#I2C_RTC_ADR	; the I2C device address
   814 E319 20 66 E3				JSR	I2C_WRITE_DEV	; send device address and write bit
   815 E31C 68					PLA			; restore register address
   816 E31D 4C 67 E3				JMP	I2C_SEND	; send register address
   817
   818 						; 25-07-25 Emile: WRITE_VIA and READ_VIA removed
   819 E320					ORG	*+6		; Maintain compatibility with v1.1.4
   820 						
   821 				; ******************************************************************************
   822 				; START OF I2C CODE
   823 				; ******************************************************************************
   824
   825 				; **** Send I2C Start Condition ************************************************
   826
   827 				; ******************************************************************************
   828
   829 E326 A0 12		I2C_START	LDY	#DDRB
   830 E328 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   831 E32A 91 14				STA	(IOBASE),Y
   832 E32C A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   833 E32E 91 14				STA	(IOBASE),Y
   834 E330 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   835 E332 91 14				STA	(IOBASE),Y
   836 E334 60					RTS
   837
   838 				; **** Send I2C Stop Condition *************************************************
   839
   840 				; ******************************************************************************
   841
   842 E335 A0 12		I2C_STOP	LDY	#DDRB
   843 E337 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   844 E339 91 14				STA	(IOBASE),Y
   845 E33B A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   846 E33D 91 14				STA	(IOBASE),Y
   847 E33F A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   848 E341 91 14				STA	(IOBASE),Y
   849 E343 60					RTS
   850
   851 				; **** Send I2C Acknowledged ***************************************************
   852
   853 				; ******************************************************************************
   854
   855 E344 A0 12		I2C_ACK		LDY	#DDRB
   856 E346 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   857 E348 91 14				STA	(IOBASE),Y
   858 E34A A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   859 E34C 91 14				STA	(IOBASE),Y
   860 E34E A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   861 E350 91 14				STA	(IOBASE),Y
   862 E352 60					RTS
   863
   864 				; **** Send I2C Not Acknowledged ***********************************************
   865
   866 				; ******************************************************************************
   867
   868 E353 A0 12		I2C_NACK	LDY	#DDRB
   869 E355 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   870 E357 91 14				STA	(IOBASE),Y
   871 E359 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   872 E35B 91 14				STA	(IOBASE),Y
   873 E35D A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   874 E35F 91 14				STA	(IOBASE),Y
   875 E361 60					RTS
   876
   877 				; **** Read I2C Device *********************************************************
   878
   879 				; Input:  A - Device Address
   880 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   881
   882 				; ******************************************************************************
   883
   884 E362 38			I2C_READ_DEV	SEC			; set carry flag
   885 E363 2A					ROL			; shift device address one bit left and rotate C in LSB. LSB = 1 = read
   886 E364 D0 01				BNE	I2C_SEND	; and send it
   887
   888 				; **** Write I2C Device ********************************************************
   889
   890 				; Input:  A - Device Address
   891 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   892
   893 				; ******************************************************************************
   894
   895 E366 0A			I2C_WRITE_DEV	ASL			; shift device address one bit left. LSB is now 0 = write
   896 									; directly fallthrough to I2C_SEND
   897
   898 				; **** Send a Byte to I2C Device ***********************************************
   899
   900 				; Input:  A - Data Byte
   901 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   902
   903 				; ******************************************************************************
   904
   905 E367 85 E0		I2C_SEND	STA	I2C_DATA
   906 E369 A2 08				LDX	#$08		; send 8 bits
   907 E36B A0 12				LDY	#DDRB
   908 E36D 06 E0		SENDLOOP	ASL	I2C_DATA	; get next bit into C flag
   909 E36F B0 04				BCS	MSENDH		; is it a 1 bit?
   910 E371 A9 DF				LDA	#%11011111	; no, SDA = 0; SCL = 0
   911 E373 D0 02				BNE	SETBIT		; branch always
   912 E375 A9 5F		MSENDH		LDA	#%01011111	; yes, SDA = 1; SCL = 0
   913 E377 91 14		SETBIT		STA	(IOBASE),Y
   914 E379 29 FE				AND	#%11111110	; SDA = X; SCL = 1
   915 E37B 91 14				STA	(IOBASE),Y
   916 E37D 09 01				ORA	#%00000001	; SDA = X, SCL = 0
   917 E37F 91 14				STA	(IOBASE),Y
   918 E381 CA					DEX
   919 E382 D0 E9				BNE	SENDLOOP
   920
   921 E384 A0 12		I2C_ACK?	LDY	#DDRB
   922
   923 E386 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   924 E388 91 14				STA	(IOBASE),Y
   925
   926 E38A A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   927 E38C 91 14				STA	(IOBASE),Y
   928 E38E A0 10				LDY	#PORTB
   929 E390 B1 14				LDA	(IOBASE),Y	; get SDA
   930 E392 10 03				BPL	ISACK		; SDA = 1 ?
   931 E394 18					CLC			; no, not acknowledeged
   932 E395 90 01				BCC	CLKDOWN
   933 E397 38			ISACK		SEC			; yes, acknowledeged
   934 E398 A0 12		CLKDOWN		LDY	#DDRB
   935 E39A A9 5F				LDA	#%01011111	; SCL = 0
   936 E39C 91 14				STA	(IOBASE),Y
   937 E39E 60					RTS
   938
   939 				; **** Receive a Byte from I2C Device ******************************************
   940
   941 				; Output: A - Data Byte
   942
   943 				; ******************************************************************************
   944
   945 E39F A2 09		I2C_RCV		LDX	#$09
   946 E3A1 A0 12		RCVLOOP		LDY	#DDRB
   947 E3A3 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   948 E3A5 91 14				STA	(IOBASE),Y
   949 E3A7 CA					DEX
   950 E3A8 F0 0E				BEQ	RCVEND		; all eight bits received?
   951 E3AA A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   952 E3AC 91 14				STA	(IOBASE),Y
   953 E3AE A0 10				LDY	#PORTB
   954 E3B0 B1 14				LDA	(IOBASE),Y	; get SDA
   955 E3B2 0A					ASL			; and shift it into C
   956 E3B3 26 E0				ROL	I2C_DATA	; shift byte buffer one bit left. C goes into LSB
   957 E3B5 4C A1 E3				JMP	RCVLOOP
   958 E3B8 A5 E0		RCVEND		LDA	I2C_DATA	; load data into A
   959 E3BA 60					RTS
   960
   961 				; ******************************************************************************
   962 				; START OF SOUND GENERATOR CODE
   963 				; ******************************************************************************
   964
   965 				; **** Send A Command Byte To The Sound Chip ***********************************
   966
   967 				; Input: A - Data Byte
   968
   969 				; ******************************************************************************
   970
   971 E3BB 84 FD		SOUND_SENDBYTE	STY	YSAV		; save current Y register
   972 E3BD A0 11				LDY	#PORTA
   973 E3BF 91 14				STA	(IOBASE),Y	; set data
   974 E3C1 A0 10				LDY	#PORTB
   975 E3C3 A9 FD				LDA	#%11111101	; Set sound WE low
   976 E3C5 25 E4				AND	VIA_STATUS
   977 E3C7 91 14				STA	(IOBASE),Y	; enable sound data write
   978 E3C9 A5 E4				LDA	VIA_STATUS	; set sound WE high
   979 E3CB 91 14				STA	(IOBASE),Y	; disable sound data write
   980 E3CD A4 FD				LDY	YSAV		; restore Y register
   981 E3CF 60					RTS
   982
   983 				; **** Mute All Sound Chip Channels ********************************************
   984
   985 				; ******************************************************************************
   986
   987 E3D0 A0 03		SOUND_MUTEALL	LDY	#$03		; channels 0..3 to mute
   988 E3D2 98			NEXTCHANNEL	TYA
   989 E3D3 20 DA E3				JSR	SOUND_MUTE	; mute current channel
   990 E3D6 88					DEY			; next channel
   991 E3D7 10 F9				BPL	NEXTCHANNEL	; loop if not all four channels done
   992 E3D9 60					RTS
   993
   994 				; **** Mute A Sound Chip Channel ***********************************************
   995
   996 				; Input: A - Channel # (0..3)
   997
   998 				; ******************************************************************************
   999
  1000 E3DA A2 0F		SOUND_MUTE	LDX	#$0F		; set attenuation level to maximum
  1001 									; fall through to set attenuation level
  1002
  1003 				; **** Set Attenuation For A Sound Chip Channel ********************************
  1004
  1005 				; Input: A - Channel # (0..3)
  1006 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
  1007
  1008 				; ******************************************************************************
  1009
  1010 E3DC 86 FC		SOUND_SETATN	STX	TEMP		; store attenuation level in TEMP variable
  1011 E3DE 18					CLC			; clear carry flag
  1012 E3DF 6A					ROR			; and rotate channel number to bit 5 and 6
  1013 E3E0 6A					ROR	
  1014 E3E1 6A					ROR	
  1015 E3E2 6A					ROR	
  1016 E3E3 05 FC				ORA	TEMP		; combine channel number with attenuation value
  1017 E3E5 09 90				ORA	#$90		; and also set bit 7 and 4
  1018 E3E7 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1019
  1020 				; **** Set Periodic Noise ******************************************************
  1021
  1022 				; Input: X - Noise Shift Rate
  1023
  1024 				; ******************************************************************************
  1025
  1026 E3EA A9 00		SOUND_PNOISE	LDA	#$00
  1027 E3EC F0 04				BEQ	SET_NOISE
  1028
  1029 				; **** Set White Noise *********************************************************
  1030
  1031 				; Input: X - Noise Shift Rate
  1032
  1033 				; ******************************************************************************
  1034
  1035 E3EE A9 01		SOUND_WNOISE	LDA	#$01
  1036
  1037 				; **** Set Noise ***************************************************************
  1038
  1039 				; Input: A - 0 = Periodic Noise  1 = White Noise
  1040 				;	 X - Noise Shift Rate [0..3]
  1041
  1042 				; ******************************************************************************
  1043
  1044 E3F0 0A			SOUND_SETNOISE	ASL	
  1045 E3F1 0A					ASL	
  1046 E3F2 86 FC		SET_NOISE	STX	TEMP
  1047 E3F4 05 FC				ORA	TEMP
  1048 E3F6 09 E0				ORA	#$E0		; Emile: 23-07-25, corrected, was $F0 (noise-att.), $E0 is noise-control register
  1049 E3F8 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1050
  1051 				; **** Set Sound Frequency in HZ ***********************************************
  1052
  1053 				; Input: A - Channel (0..2)
  1054 				;	 X - Frequency Low Bits 7..0
  1055 				;	 Y - Frequency High Bits 9..8
  1056
  1057 				; *****************************************************************************
  1058
  1059 E3FB 18			SOUND_SETFREQ	CLC			; clear carry flag
  1060 E3FC 6A					ROR			; and rotate channel number to bit 5 and 6
  1061 E3FD 6A					ROR	
  1062 E3FE 6A					ROR	
  1063 E3FF 6A					ROR	
  1064 E400 09 80				ORA	#$80		; set high bit
  1065 E402 85 FC				STA	TEMP		; and store it in TEMP variable
  1066 E404 8A					TXA			; load frequency low bits into A
  1067 E405 29 0F				AND	#$0F		; we first want to send the lower 4 bits
  1068 E407 05 FC				ORA	TEMP		; combined it with the channel number
  1069 E409 20 BB E3				JSR	SOUND_SENDBYTE	; send complete first command byte to the sound chip
  1070 E40C 98					TYA			; load frequency high bits into A
  1071 E40D 86 FC				STX	TEMP		; store frequency low bits to TEMP variable
  1072 E40F A2 04				LDX	#$04		; we need four bits shifted
  1073 E411 06 FC		LOOP_NXT	ASL	TEMP		; shift highest bit of low frequency to Carry flag
  1074 E413 2A					ROL			; and shift it into the high frequency bits
  1075 E414 CA					DEX			; decrement counter
  1076 E415 D0 FA				BNE	LOOP_NXT	; do we need more shifts?
  1077 E417 4C BB E3				JMP	SOUND_SENDBYTE	; send complete second command byte to the sound chip
  1078
  1079 				; ******************************************************************************
  1080 				; ***************************** MAIN MONITOR ***********************************
  1081 				; ******************************************************************************
  1082
  1083 				; **** Auto Terminal And Baud Rate Detection Routine ***************************
  1084
  1085 				; ******************************************************************************
  1086
  1087 E41A A2 2D		INITVECT        LDX	#< NMI		; set NMI service routine
  1088 E41C A0 F3		                LDY	#> NMI
  1089 E41E 8E 7A 1A				STX	NMIVECT
  1090 E421 8C 7B 1A				STY	NMIVECT+1
  1091 E424 8E 7C 1A				STX	IRQUSR
  1092 E427 8C 7D 1A				STY	IRQUSR+1
  1093 E42A 8E 78 1A				STX	BRKUSR
  1094 E42D 8C 79 1A		                STY	BRKUSR+1
  1095 E430 A2 18				LDX	#< IRQ
  1096 E432 A0 F3				LDY	#> IRQ
  1097 E434 4C 40 ED				JMP	SETIRQVECT	; Set IRQ vector and return
  1098
  1099 E437					ORG	*+8		; maintain compatibility with v1.1.4
  1100 						
  1101 E43F 78			MAINSTART       SEI			; disable Interrupts
  1102 E440 A2 FF		                LDX     #$FF
  1103 E442 9A					TXS			; initialize stack pointer
  1104 E443 D8					CLD			; set binary mode
  1105
  1106 E444 A9 4F		                LDA     #< _HANDLER_  ; low address to empty event handler (RTS)
  1107 E446 8D 24 1A		                STA     KEY_HANDLER     ; init character input handler low address
  1108 E449 8D 26 1A		                STA     NKEY_HANDLER    ; init no character input handler low address
  1109 E44C A9 F8		                LDA     #> _HANDLER_ ; high address to empty event handler (RTS)
  1110 E44E 8D 25 1A		                STA     KEY_HANDLER+1   ; init character input handler high address
  1111 E451 8D 27 1A		                STA     NKEY_HANDLER+1  ; init no character input handler high address
  1112
  1113 E454 20 1A E4		                JSR     INITVECT
  1114
  1115 E457 A2 03		INITRESET       LDX     #< MON_WARM_START
  1116 E459 A0 E0				LDY     #> MON_WARM_START
  1117 E45B 20 C5 E5				JSR	SET_RETURN_VECT		; set entry point for monitor warm start
  1118 E45E EA					NOP				; maintain compatibility with v1.1.4
  1119
  1120 E45F A9 80				LDA     #$80
  1121 E461 20 4D E1				JSR  	DELAY		; wait for ~128ms after reset
  1122 E464 20 6A EC				JSR	INITIO		; find and initialize IO cards
  1123 E467 20 4D E1		VTDETECT	JSR  	DELAY		; wait for ~128ms after reset
  1124 E46A 8D 01 16				STA  	STAT_REG   	; reset ACIA
  1125
  1126 				; ******************************************************************************
  1127 				; Set Fixed Baud Rate Patch
  1128 				; ******************************************************************************
  1129
  1130 E46D A9 3E				LDA	#$3E
  1131 E46F 8D 83 1A				STA	PBDD
  1132 E472 A9 06				LDA	#$06		; set keyboard decoder Q4 to low
  1133 E474 8D 82 1A				STA	PBD		; write value to RIOT port B
  1134 E477 AD F9 FF				LDA	$FFF9		; load standard baud rate value
  1135 E47A 85 E0				STA	BAUDRATE	; and store it in detected baud rate variable
  1136 E47C A9 0B				LDA  	#$0B       	; set ACIA to
  1137 E47E 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
  1138 E481 AD 82 1A				LDA	PBD		; read RIOT port B
  1139 E484 A2 0F				LDX	#$0F		; set all keyboard decoder outputs to high
  1140 E486 8E 82 1A				STX	PBD		; write value to RIOT port B
  1141 E489 6A					ROR			; rotate bit 0 into Carry
  1142 E48A 90 05				BCC	INIT		; if Carry = 0 then skip autodetection
  1143
  1144 				; ******************************************************************************
  1145
  1146 E48C A9 00				LDA	#CMD_INIT
  1147 E48E 20 B7 E0				JSR	CMDPRINT	; try to detect connected terminal
  1148
  1149 				; **** Main Initialization Routine *********************************************
  1150
  1151 				; ******************************************************************************
  1152
  1153 E491 20 67 E1		INIT            JSR     BEEP		; give some feedback
  1154 E494 A5 E0				LDA  	BAUDRATE   	; load selected baud rate
  1155 E496 D0 1A				BNE     SETBAUDRATE	; terminal detected or fixed baud rate?
  1156 E498 AD F9 FF				LDA	$FFF9		; no, load standard baud rate value
  1157 E49B 8D 03 16				STA  	CTRL_REG	; set baud rate
  1158 E49E A5 C9				LDA     DEVID
  1159 E4A0 C9 10				CMP     #TTY1_ID        ; is TTY still the standard output device?
  1160 E4A2 D0 03				BNE     SET_CRTDEV      ; no, CRT controller is installed. Continue initialization
  1161 E4A4 4C 55 E7				JMP  	JCRESET		; TTY ist still sdtoutdev, but not connected. Jump to junior monitor
  1162
  1163 E4A7 8D 75 1A		SET_CRTDEV      STA     STDOUTDEV       ; make CRT controller the standard output device
  1164 E4AA 20 18 E0		                JSR     SET_STDOUTID
  1165 E4AD A9 00		                LDA	#CMD_INIT
  1166 E4AF 20 B7 E0				JSR	CMDPRINT	; initialize standard output device
  1167
  1168 E4B2 8D 03 16		SETBAUDRATE     STA  	CTRL_REG	; set detected baud rate
  1169
  1170 E4B5 58					CLI			; enable interrupts
  1171
  1172 				; **** Main Program Loop *******************************************************
  1173
  1174 				; ******************************************************************************
  1175
  1176 E4B6 20 4D E0		MAIN		JSR	CGET		; clear input buffer
  1177 E4B9 20 40 E5				JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1178 E4BC A9 1F				LDA  	#$1F
  1179 E4BE 20 DE E0				JSR  	TAB		; send some space chars to center title
  1180 E4C1 A0 14		        	LDY  	#TITLE-STRINGP 	; load title string
  1181 E4C3 20 85 E0				JSR  	WRSTR		; and write it
  1182 E4C6 20 16 F9				JSR     INIT_CFC	; init. CFC-driver
  1183
  1184 E4C9 A5 15		CHK_IO_CARD     LDA	IOBASEH		; language card available?
  1185 E4CB F0 21				BEQ	TRY_BOOT	; no, try to boot from CF-device
  1186 						
  1187 E4CD A0 60				LDY	#IOCARD-STRINGP ; load detect message
  1188 E4CF 20 85 E0				JSR	WRSTR		; and write it
  1189 E4D2 A5 15				LDA	IOBASEH
  1190 E4D4 20 91 E0				JSR	HEXOUT
  1191 E4D7 A9 00				LDA	#$00
  1192 E4D9 20 91 E0				JSR	HEXOUT
  1193 E4DC AD 74 1A				LDA	STDINDEV
  1194 E4DF C9 13				CMP	#KEYBD1_ID	; is ASCII keyboard the standard input device?
  1195 E4E1 D0 08				BNE	SHOW_CLOCK 	; no, show clock
  1196 						
  1197 E4E3 A0 6E				LDY	#KBDSTR-STRINGP	; yes, load detect message
  1198 E4E5 20 85 E0				JSR	WRSTR		; and write it
  1199 E4E8 20 10 F4				JSR	SETPPORTIN
  1200 E4EB 20 34 EB		SHOW_CLOCK	JSR	CLOCKSTART	; call clock
  1201
  1202 E4EE 20 B8 F6		TRY_BOOT        JSR     SYS_BOOT        ; try to boot from CF or SD device
  1203 E4F1 90 03		                BCC     NO_BOOT_DEV     ; no boot device found, show menu
  1204 						
  1205 E4F3 4C 00 06		                JMP     BLOCK_BUF       ; jump to boot code in Volume-ID with C=1
  1206
  1207 E4F6 A5 15		NO_BOOT_DEV     LDA	IOBASEH		; language card available?
  1208 E4F8 F0 43				BEQ	SHOWMON		; no, just start monitor
  1209
  1210 E4FA A9 00				LDA	#$00
  1211 E4FC A0 1B		                LDY	#ACR		; select auxilary control register
  1212 E4FE 91 14				STA	(IOBASE),Y	; disable shift operation
  1213 E500 20 43 E5		                JSR     LOADSTRING
  1214 E503 A0 89				LDY	#SPACE-STRINGP
  1215 E505 20 85 E0				JSR	WRSTR		; write spacer lines
  1216 E508 A9 1E				LDA	#$1E		; send some space chars to center menu
  1217 E50A 20 DE E0				JSR  	TAB
  1218 E50D A0 8E				LDY	#MENU-STRINGP   ; load menu string
  1219 E50F 20 85 E0				JSR	WRSTR		; and write it
  1220 E512 A2 F1				LDX	#< LANGNAME	; load language name
  1221 E514 A0 DF				LDY	#> LANGNAME
  1222 E516 20 82 F6				JSR	SPRINT		; and write it
  1223 E519 A9 20				LDA	#SPC
  1224 E51B 20 52 E0				JSR	COUT
  1225 E51E A9 3F				LDA	#'?'
  1226 E520 20 52 E0				JSR	COUT
  1227 E523 20 47 E0		MLOOP		JSR  	CIN		; main menu loop
  1228 E526 29 DF		        	AND  	#$DF		; convert the input to uppercase char
  1229 E528 C9 4D		        	CMP  	#'M'		; (M)onitor choosen?
  1230 E52A D0 03				BNE	MNEXT1
  1231
  1232 E52C 4C 33 E6		STARTMON	JMP  	MONITOR		; yes, start monitor
  1233 E52F CD F0 DF		MNEXT1		CMP	LANGKEY		; compare with language key char
  1234 E532 D0 06				BNE	MNEXT
  1235
  1236 E534 20 B5 E0				JSR  	CLRSCRN    	; clear screen
  1237 E537 4C 00 B0				JMP	$B000		; jump to language start
  1238 E53A 4C 23 E5		MNEXT		JMP  	MLOOP		; no valid input choosen, try again
  1239 E53D 4C 3B E6		SHOWMON		JMP	MONRESET
  1240
  1241 				; Load String Pointer **********************************************************
  1242
  1243 E540 20 B5 E0		CLRLOADSTR      JSR     CLRSCRN
  1244 E543 A9 72		LOADSTRING	LDA  	#< STRINGP 	; load string pointer 1
  1245 E545 85 EA				STA  	PSTRL
  1246 E547 A9 E7				LDA  	#> STRINGP
  1247 E549 85 EB				STA  	PSTRH
  1248 E54B 60					RTS
  1249 						
  1250 E54C A9 62		LOADSTRING2	LDA  	#< STRINGP2 	; load string pointer 2
  1251 E54E 85 EA				STA  	PSTRL
  1252 E550 A9 E8				LDA  	#> STRINGP2
  1253 E552 85 EB				STA  	PSTRH
  1254 E554 60					RTS
  1255
  1256 E555 A9 10		WRITE_IO_INFO   LDA     #$10
  1257 E557 8D 00 1A				STA     IO_INFO
  1258 E55A A5 17		CHK_IO_0	LDA     FGCBASEH        ; controller card 0 available?
  1259 E55C F0 06				BEQ     CHK_IO_1        ; no, check next card
  1260 E55E 8D 01 1A				STA     IO_INFO+1
  1261 E561 20 6F E5				JSR     CALL_INFO
  1262 E564 A5 19		CHK_IO_1        LDA     CARD3BASEH      ; controller card 1 available?
  1263 E566 F0 06		                BEQ     IO_INFO_END     ; no, exit
  1264 						
  1265 E568 8D 01 1A		                STA     IO_INFO+1
  1266 E56B 20 6F E5				JSR     CALL_INFO
  1267 E56E 60			IO_INFO_END	RTS
  1268
  1269 E56F 6C 00 1A		CALL_INFO       JMP     (IO_INFO)
  1270
  1271 				; ******************************************************************************
  1272 				; MONITOR COMMAND EXECUTOR ROUTINES
  1273 				; ******************************************************************************
  1274
  1275 				; print command ****************************************************************
  1276
  1277 E572 84 FD		PRINTOUT	STY	YSAV		; save y register
  1278 E574 AD 76 1A				LDA	STDPRINTDEV	; get standard printer
  1279 E577 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1280 E57A A4 FD				LDY	YSAV		; restore y register
  1281 E57C C8					INY
  1282 E57D B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1283 E580 29 DF				AND  	#$DF		; uppercase chars only
  1284 E582 C9 44				CMP  	#'D'		; print mem dump?
  1285 E584 F0 06				BEQ	PRINTDUMP
  1286 E586 20 AC E8				JSR	DISASSEM
  1287 E589 4C 94 E5				JMP	ENDINP
  1288 E58C 20 C7 E6		PRINTDUMP	JSR	MEMDUMP		; print memory dump
  1289 E58F 90 03				BCC	ENDINP 		; normal termination?
  1290 E591 20 67 E1				JSR	BEEP		; no, ESC pressed. Beep
  1291 E594 20 5A E0		ENDINP		JSR	CROUT		; send CR/LF to print last line
  1292 E597 AD 75 1A				LDA	STDOUTDEV	; get standard output device
  1293 E59A 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1294 E59D 4C 3E E6				JMP	MONINP		; get next command line
  1295
  1296 				; XMODEM load/save command *****************************************************
  1297
  1298 E5A0 CA			XMODEM		DEX			; check read/write mode
  1299 E5A1 F0 09				BEQ	XMODEML		; read mode?
  1300 E5A3 A5 FF				LDA	MODE		; no, test if valid address mode
  1301 E5A5 F0 6A				BEQ	NOTVALID	; not valid, get next input
  1302 E5A7 20 06 F1				JSR	XModemSnd	; call xmodem send
  1303 E5AA F0 03				BEQ	XMODEME
  1304 E5AC 20 15 F0		XMODEML		JSR	XModemRcv	; yes, call xmodem receive
  1305 E5AF 4C 3E E6		XMODEME		JMP	MONINP		; get next command line
  1306
  1307 				; parallel load/save command ***************************************************
  1308
  1309 E5B2 CA			PARALLEL	DEX			; check read/write mode
  1310 E5B3 F0 0A				BEQ	PARALLELL	; read mode?
  1311 E5B5 A5 FF				LDA	MODE		; no, test if valid address mode
  1312 E5B7 F0 58				BEQ	NOTVALID	; not valid, get next input
  1313 E5B9 20 03 18				JSR	PPORTSAVE	; call save pport ### not implemented yet
  1314 E5BC 4C 3E E6				JMP	MONINP
  1315 E5BF 20 00 18		PARALLELL	JSR	PPORTLOAD	; call load pport ### not implemented yet
  1316 E5C2 4C 3E E6				JMP	MONINP		; get next command line
  1317
  1318 				; Removed 20-07-'25 (+34 bytes): tape load/save command **********************************
  1319
  1320 				;----------------------------------------------------------------------------------		
  1321 				; This routine sets the return vector that is used by both Monitor and boot.sys.
  1322 				;----------------------------------------------------------------------------------		
  1323 E5C5 8E 0A 18		SET_RETURN_VECT	STX     RETURN_VECT     	; set entry point for monitor warm start
  1324 E5C8 8C 0B 18		                STY     RETURN_VECT+1
  1325 E5CB 60					RTS
  1326
  1327 E5CC					ORG	$E5E7		; maintain compatibility with previous BIOS versions
  1328 				; load/save command ************************************************************
  1329
  1330 E5E7 A5 FF		LOADSAVE	LDA	MODE		; check address mode
  1331 E5E9 0A					ASL	
  1332 E5EA 30 06				BMI	CHKNEXTCMD	; mode = $C0 (block mode)?
  1333 E5EC A9 FF				LDA	#$FF		; no, set end address to $ffff
  1334 E5EE 85 F8				STA	NUML
  1335 E5F0 85 F9				STA	NUMH
  1336 E5F2 C8			CHKNEXTCMD	INY
  1337 E5F3 B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1338 E5F6 29 DF				AND  	#$DF		; uppercase chars only
  1339 E5F8 C9 4D				CMP  	#'M'		; load/save via xmodem
  1340 E5FA F0 A4				BEQ  	XMODEM
  1341 E5FC C9 50				CMP  	#'P'		; load/save via parallel port
  1342 E5FE F0 B2				BEQ  	PARALLEL
  1343 E600 EA EA EA EA			:4	NOP			; REMOVED load/save via tape
  1344 E604 C9 30				CMP	#'0'
  1345 E606 B0 09				BCS	NOTVALID
  1346 E608 CA					DEX			; check load/save mode
  1347 E609 D0 06				BNE	NOTVALID	; if save mode, just get next input char
  1348 E60B 20 AC E8				JSR	DISASSEM	; last command was L, so call disassembler
  1349 E60E 4C 3E E6				JMP	MONINP		; we are finnished, get next input line
  1350 E611 A9 00		NOTVALID	LDA	#$00		; no valid command, so restore registers
  1351 E613 AA					TAX
  1352 E614 4C A1 E6				JMP  	SETMODE2   	; and get next input char
  1353
  1354 				; save command *****************************************************************
  1355
  1356 E617 E8			SAVE		INX
  1357
  1358 				; load command *****************************************************************
  1359
  1360 E618 E8			LOAD		INX
  1361 E619 4C E7 E5				JMP	LOADSAVE
  1362
  1363 				; print command ****************************************************************
  1364
  1365 E61C 4C 72 E5		PRINT		JMP	PRINTOUT
  1366
  1367 				; call a program ***************************************************************
  1368
  1369 E61F 20 36 E7		RUN		JSR	PRADDRESS
  1370 E622 A9 52				LDA	#'R'		; print R to signal run mode
  1371 E624 20 52 E0				JSR	COUT
  1372 E627 20 5A E0				JSR	CROUT
  1373 E62A 20 30 E6				JSR     EXECPROG
  1374 E62D 4C 3E E6				JMP  	MONINP		; jump back from program call
  1375 E630 6C FA 00		EXECPROG	JMP  	(ADRL)     	; jump to program address; execute program
  1376
  1377 				; **** Start Of Hex Monitor ****************************************************
  1378
  1379 				; ******************************************************************************
  1380 E633 20 40 E5		MONITOR 	JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1381 E636 A0 9A				LDY  	#MONSTR-STRINGP
  1382 E638 20 85 E0		        	JSR  	WRSTR		; show monitor title
  1383 E63B 20 10 F4		MONRESET	JSR	SETPPORTIN	; initialize RIOT
  1384 E63E 20 5A E0		MONINP		JSR  	CROUT
  1385 E641 A9 2A				LDA  	#PROMPT
  1386 E643 20 52 E0				JSR  	COUT		; show monitor prompt
  1387 E646 20 62 E0				JSR  	STRIN      	; read input string
  1388 E649 A0 00				LDY  	#$00       	; reset string index
  1389 E64B 98					TYA			; mode = 0 (none)
  1390
  1391 E64C AA			MONINIT		TAX
  1392 E64D 85 FF		SETADRMODE	STA  	MODE
  1393 E64F C8			SKIPCMDCHR      INY			; increment string index
  1394 E650 B9 00 14		NEXTCMDCHR	LDA  	STRBUF,Y   	; get next input char
  1395 E653 C9 0D				CMP  	#CR
  1396 E655 F0 52				BEQ  	ENDCMD 		; end of input line, return to reader routine
  1397 E657 C9 20				CMP  	#' '
  1398 E659 F0 F4				BEQ  	SKIPCMDCHR 	; ignore spaces
  1399 E65B C9 2E				CMP  	#'.'
  1400 E65D F0 46				BEQ  	SETBLKMODE 	; block mode
  1401 E65F C9 3A				CMP	#':'
  1402 E661 F0 EA				BEQ	SETADRMODE
  1403 E663 29 DF				AND  	#$DF		; uppercase chars only
  1404 E665 C9 4C				CMP  	#'L'		; LOAD/LIST command
  1405 E667 F0 AF				BEQ	LOAD 		; load or list data
  1406 E669 C9 53				CMP  	#'S'		; SAVE command
  1407 E66B F0 AA				BEQ	SAVE		; save data
  1408 E66D C9 50				CMP	#'P'		; PRINT command
  1409 E66F F0 AB				BEQ	PRINT		; print data
  1410 E671 C9 47				CMP  	#'G'		; GO command
  1411 E673 F0 AA				BEQ  	RUN		; call program
  1412 E675 C9 4D				CMP  	#'M'		; JUNIOR MONITOR command
  1413 E677 D0 03				BNE  	NEXTCMD
  1414 E679 4C 55 E7				JMP	JCRESET		; execute original junior computer monitor
  1415 E67C C9 51		NEXTCMD		CMP  	#'Q'		; QUIT command
  1416 E67E F0 30				BEQ  	MONEND		; exit monitor program
  1417 E680 A5 FF				LDA	MODE		; test if list command pending
  1418 E682 30 3C				BMI	DUMP		; if mode = $80, dump last line
  1419 E684 84 FD				STY  	YSAV		; save Y
  1420 E686 20 EA E0				JSR  	HEXINPUT   	; read hex number
  1421 E689 C4 FD			 	CPY  	YSAV		; min 1 hex digit entered?
  1422 E68B F0 C2				BEQ  	SKIPCMDCHR     	; no, read next command
  1423 E68D A5 FF				LDA  	MODE
  1424 E68F D0 0A				BNE	SETMODE
  1425 E691 A5 F8		STOREADR	LDA  	NUML       	; yes, copy input value to last address
  1426 E693 85 FA		                STA  	ADRL
  1427 E695 A5 F9		                LDA  	NUMH
  1428 E697 85 FB		                STA  	ADRH
  1429 E699 A9 00				LDA	#$00		; line list mode
  1430 E69B C9 3A		SETMODE		CMP	#':'		; is it store mode?
  1431 E69D F0 14				BEQ	STOREDATA	; yes, store data
  1432 E69F 09 80				ORA	#$80
  1433 E6A1 85 FF		SETMODE2	STA	MODE
  1434 E6A3 D0 AB				BNE	NEXTCMDCHR	; branch always
  1435 E6A5 A9 40		SETBLKMODE	LDA	#$40		; set block list mode
  1436 E6A7 D0 A4				BNE	SETADRMODE
  1437 E6A9 A5 FF		ENDCMD		LDA	MODE		; test if list command pending
  1438 E6AB 30 13				BMI	DUMP		; yes, dump last line
  1439 E6AD 4C 3E E6		CMDEND		JMP	MONINP		; read next command line
  1440 E6B0 6C 0A 18		MONEND		JMP     (RETURN_VECT)   ; return to monitor caller
  1441
  1442 				; store data *******************************************************************
  1443
  1444 E6B3 A5 F8		STOREDATA	LDA  	NUML       	; load lower byte of number
  1445 E6B5 81 FA		                STA  	(ADRL,X)   	; store current store address (X=0)
  1446 E6B7 E6 FA		                INC  	ADRL       	; increment lower store index.
  1447 E6B9 D0 02		                BNE  	NEXTITEM    	; no overflow
  1448 E6BB E6 FB		                INC  	ADRH       	; add carry to upper store index
  1449 E6BD 4C 50 E6		NEXTITEM        JMP  	NEXTCMDCHR    	; get next command string
  1450
  1451 				; call memory dump *************************************************************
  1452
  1453 E6C0 20 C7 E6		DUMP		JSR	MEMDUMP
  1454 E6C3 90 8B				BCC	NEXTCMDCHR   	; get next input
  1455 E6C5 B0 E6				BCS	CMDEND		; yes, stop printing memory dump
  1456
  1457 				; print memory dump ************************************************************
  1458
  1459 E6C7 A2 00		MEMDUMP		LDX	#$00
  1460 E6C9 86 FE				STX  	PDBCNT		; printed data byte count = 0
  1461 E6CB 20 5C E1				JSR	CHKESC		; ESC pressed?
  1462 E6CE 90 01				BCC	PRADR		; no, go on dumping
  1463 E6D0 60					RTS			; yes, exit leaving carry flag set
  1464 E6D1 20 36 E7		PRADR		JSR	PRADDRESS	; print current address
  1465
  1466 				; print current data byte ******************************************************
  1467
  1468 E6D4 20 5E E0		PRDATA		JSR  	SPCOUT		; print space
  1469 E6D7 A1 FA		                LDA  	(ADRL,X)   	; get data from address (X=0)
  1470 E6D9 20 91 E0		                JSR  	HEXOUT     	; print data in hex format
  1471 E6DC E6 FE				INC  	PDBCNT     	; increment data counter
  1472
  1473 				; examine next address *********************************************************
  1474
  1475 E6DE 20 4C E7		ADRNEXT		JSR	CMPADDR		; see if there's more to print
  1476 E6E1 B0 18		                BCS  	FINISHED?  	; no more data to output
  1477
  1478 E6E3 20 7F E9				JSR	INCADR          ; increment list index
  1479 E6E6 A5 FE		DIVCHK          LDA  	PDBCNT
  1480 E6E8 C9 08				CMP  	#$08
  1481 E6EA D0 03				BNE  	MOD16CHK	; do we need a divider?
  1482 E6EC 20 5E E0				JSR  	SPCOUT		; yes, print single SPC as block divider
  1483 E6EF A5 FA		MOD16CHK	LDA  	ADRL       	; if address MOD 16 = 0 start new line
  1484 E6F1 29 0F		                AND  	#$0F
  1485 E6F3 D0 DF				BNE  	PRDATA
  1486 E6F5 20 07 E7				JSR  	PRASCII
  1487 E6F8 4C C7 E6				JMP  	MEMDUMP		; print next line
  1488
  1489 				; check if line print completed ************************************************
  1490
  1491 E6FB A5 FF		FINISHED?	LDA  	MODE		; examine last mode
  1492 E6FD 86 FF				STX  	MODE       	; set mode 0
  1493 E6FF 0A					ASL			; mode = $D0?
  1494 E700 10 03				BPL  	ENDDUMP		; no, get next input
  1495 E702 20 07 E7				JSR  	PRASCII		; yes, we are not finished, print ASCII output for last address
  1496 E705 18			ENDDUMP		CLC			; normal exit, so clear carry flag
  1497 E706 60					RTS
  1498
  1499 				; print a column with ASCII representation of data *****************************
  1500
  1501 E707 84 FD		PRASCII         STY  	YSAV       	; store Y
  1502 E709 38					SEC			; no carry to subtract
  1503 E70A A9 34				LDA  	#52		; max tabs
  1504 E70C E5 FE				SBC  	PDBCNT		; calc tab count to print ASCII column
  1505 E70E E5 FE				SBC  	PDBCNT		; tab = 52-3*printed_data_bytes_count
  1506 E710 E5 FE				SBC  	PDBCNT
  1507 E712 A4 FE				LDY  	PDBCNT
  1508 E714 C0 09				CPY  	#9		; more than 8 bytes viewed?
  1509 E716 B0 02				BCS  	NOADJUST	; no
  1510 E718 69 01				ADC  	#1		; yes, adjust by one char for block divider
  1511 E71A 20 DE E0		NOADJUST	JSR  	TAB		; print tab spaces
  1512
  1513 E71D A0 00				LDY  	#$00
  1514 E71F B1 E6		NEXTASC		LDA  	(ASCL),Y   	; get data from address
  1515 E721 C9 7F				CMP	#$7F
  1516 E723 B0 04				BCS  	NOASC      	; char >= ASCII 127? yes, print '.'
  1517 E725 C9 20				CMP  	#' '
  1518 E727 B0 02				BCS  	ASCOUT		; printable character?
  1519 E729 A9 2E		NOASC		LDA  	#'.'       	; no, print '.'
  1520 E72B 20 52 E0		ASCOUT		JSR  	COUT
  1521 E72E C8					INY
  1522 E72F C4 FE				CPY  	PDBCNT
  1523 E731 D0 EC				BNE  	NEXTASC
  1524 E733 A4 FD				LDY  	YSAV       	; restore Y
  1525 E735 60					RTS
  1526
  1527 				; Prompt new line with current address *****************************************
  1528
  1529 				;*******************************************************************************
  1530
  1531 E736 20 5A E0		PRADDRESS	JSR  	CROUT
  1532 E739 A5 FB				LDA  	ADRH
  1533 E73B 85 E7		                STA  	ASCH		; store current print address high-order byte
  1534 E73D 20 91 E0				JSR  	HEXOUT		; print high-order byte of address
  1535 E740 A5 FA		                LDA  	ADRL
  1536 E742 85 E6				STA  	ASCL		; store current print address low-order byte
  1537 E744 20 91 E0		                JSR  	HEXOUT		; print low-order byte of address
  1538 E747 A9 2D				LDA  	#ADIV      	; print '-'
  1539 E749 4C 52 E0		                JMP  	COUT
  1540
  1541 				; Compare if start address ADR is greater end address NUM **********************
  1542
  1543 				;*******************************************************************************
  1544
  1545 E74C A5 FA		CMPADDR		LDA  	ADRL       	; see if there's more to print
  1546 E74E C5 F8		                CMP  	NUML
  1547 E750 A5 FB		                LDA  	ADRH
  1548 E752 E5 F9		                SBC  	NUMH
  1549 E754 60					RTS
  1550
  1551 				; Jump to original Junior Computer reset vector ********************************
  1552
  1553 				;*******************************************************************************
  1554 E755 A9 06		JCRESET		LDA	#$06			; set PB5 = L (WRITE)
  1555 E757 8D 82 1A				STA	PBD
  1556 E75A 78					SEI
  1557 E75B 20 1A E4				JSR     INITVECT
  1558 E75E 20 81 ED		                JSR     VIA2IRQ_OFF
  1559 E761 58					CLI
  1560 E762 4C 1D 1C				JMP	MONITOR_BLOCK.RESET	; jump to Junior Computer reset routine
  1561
  1562 				; ******************************************************************************
  1563 				; String Data Section
  1564 				; ******************************************************************************
  1565
  1566 E765 00 00 00 00		MAGIC0		.byte	$00,$00,$00,$00                 ; Removed by Emile
  1567 E769 18 90 00 90		MAGIC1          .byte   $18,$90,$00,$90                 ; clc bcc 00 bcc
  1568
  1569 E76D 50 53 41 59 58	PSSTR		.by	'PSAYX'				; processor status string
  1570
  1571 E772			STRINGP							; *** string base pointer ***
  1572 E772 32 4A 1B 5B		ESCCLS  	.byte   $32,$4A,$1B,$5B                 ; VT100 clear screen sequence
  1573 E776 48 00		ESCHOME        	.byte   $48,$00                 	; VT100 cursor home sequence
  1574 E778 32 4B 00		ESCCLL        	.byte   $32,$4B,$00         		; VT100 clear line sequence
  1575 E77B 30 63 00		ESCGID		.byte   $30,$63,$00	        	; VT100 get ID sequence
  1576 E77E 6D 00		ESCNORM		.byte   $6D,$00	        		; VT100 set normal text mode
  1577 E780 37 6D 00		ESCINV		.byte   $37,$6D,$00	        	; VT100 set inverse text mode
  1578 E783 35 6D 00		ESCBLNK		.byte   $35,$6D,$00	        	; VT100 set blinking text mode
  1579
  1580 E786 4A 75 6E 69 6F 72 + TITLE		.by   	'Junior Computer ][ ' CR,CR,CR
  1581 E79C 20 42 49 4F 53 20 + 		.by   	' BIOS V'
  1582 E7A3 31 2E 32 2E 34 0D	        	.byte   VERMAIN,$2E,VERPSUB,$2E,VERSSUB,CR
  1583 E7A9 20 32 30 32 30 2F +         	.by   	' 2020/24 by Joerg Walke, 2025 by Emile' CR CR $00
  1584 E7D2 20 49 4F 2D 43 61 + IOCARD		.by	' IO-Card at $' $00
  1585 E7E0 0D 20 41 53 43 49 + KBDSTR		.by	CR ' ASCII Keyboard connected' $00
  1586 E7FB 0D 0D 0D 0D 00	SPACE    	.byte  	CR, CR, CR, CR, $00
  1587 E800 28 4D 29 6F 6E 69 + MENU		.by   	'(M)onitor  ' $00
  1588 E80C 0D 48 65 78 20 4D + MONSTR		.by	CR 'Hex Monitor' CR $00
  1589
  1590 E81A 0D 0D 20 44 61 74 + DT_NOT_SET	.by	CR CR ' Date/Time not set' CR $00
  1591 E830 0D 20 44 61 74 65 + DATEINPUT	.by	CR ' Date: DD' DATEDIV 'MM' DATEDIV 'YY'
  1592 E840 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1593 E849 0D 20 54 69 6D 65 + TIMEINPUT	.by	CR ' Time: HH' TIMEDIV 'MM' TIMEDIV 'SS'
  1594 E859 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1595
  1596 E862			STRINGP2
  1597 E862 4D 6F 6E 00		DAYS		.by	'Mon' $00
  1598 E866 54 75 65 00				.by	'Tue' $00
  1599 E86A 57 65 64 00				.by	'Wed' $00
  1600 E86E 54 68 75 00				.by	'Thu' $00
  1601 E872 46 72 69 00				.by	'Fri' $00
  1602 E876 53 61 74 00				.by	'Sat' $00
  1603 E87A 53 75 6E 00				.by	'Sun' $00
  1604 E87E 4A 43 4F 53		OSID            .by    'JCOS'
  1605 E882 0D 20 42 6F 6F 74 + BOOTDEV         .by    CR ' Booting from ' $00
  1606 E892 0D 20 4E 6F 20 42 + NOBOOTDEV       .by    CR ' No Boot Disk ' $00
  1607 E8A2 43 46 43 31 00	CFCDEV          .by    'CFC1' $00
  1608 E8A7 53 44 43 31 00	SDCDEV          .by    'SDC1' $00
  1609
  1610 				; ******************************************************************************
  1611 				; START OF DISASSEMBLER
  1612 				; ******************************************************************************
  1613
  1614 E8AC A5 FF		DISASSEM	LDA	MODE
  1615 E8AE 0A					ASL	
  1616 E8AF 10 0E				BPL	SHOW1PAGE	; mode <> $C0 (block mode)?
  1617 E8B1 20 5C E1		NEXTLINE1	JSR     CHKESC          ; ESC pressed?
  1618 E8B4 B0 14				BCS	ENDDISASSEM	; yes, quit disassembling
  1619 E8B6 20 CB E8		NEXTOP		JSR	LOADOPCODE	; load current opcode
  1620 E8B9 20 4C E7		MORE?		JSR	CMPADDR		; see if there's more to print
  1621 E8BC 90 F3		                BCC  	NEXTLINE1  	; no more data to output
  1622 E8BE 60					RTS
  1623 E8BF A9 17		SHOW1PAGE	LDA	#23		; show 23 disassembled lines
  1624 E8C1 85 E1				STA	LINECNT
  1625 E8C3 20 CB E8		NEXTLINE2	JSR	LOADOPCODE	; load current opcode
  1626 E8C6 C6 E1				DEC	LINECNT
  1627 E8C8 D0 F9				BNE	NEXTLINE2	; more lines to show?
  1628 E8CA 60			ENDDISASSEM	RTS			; no, jump back to monitor
  1629
  1630 				; load next opcode
  1631
  1632 E8CB 20 36 E7		LOADOPCODE	JSR	PRADDRESS	; print current address
  1633 E8CE A0 00				LDY	#$00
  1634 E8D0 B1 FA				LDA	(ADRL),Y	; load opcode
  1635 E8D2 A8					TAY			; store opcode in Y
  1636 E8D3 29 03				AND	#$03
  1637 E8D5 C9 03				CMP	#$03		; is it a unused opcode?
  1638 E8D7 D0 05				BNE	DECODE  	; no, decode it
  1639 E8D9 A0 02				LDY	#$02		; Y points to unused opcode $02 to print '???'
  1640 E8DB 98					TYA			; and we also need it in A
  1641 E8DC D0 09				BNE	DECODEMNEM	; branch always
  1642
  1643 				; decode opcode index into compressed opcode instruction table
  1644
  1645 E8DE 98			DECODE		TYA			; reload opcode into A
  1646 E8DF 4A					LSR			; every fourth column in the opcode table is a (opcode) gap
  1647 E8E0 4A					LSR			; so we have to adjust the index because these columns are
  1648 									; stripped off in our indirect index table
  1649 E8E1 85 FC				STA	TEMP		; store number of bytes to subtract
  1650 E8E3 98					TYA			; reload opcode again
  1651 E8E4 38					SEC
  1652 E8E5 E5 FC				SBC	TEMP		; and subtract value in TEMP from the original opcode.
  1653 E8E7 84 E0		DECODEMNEM	STY	OPCODE		; store opcode
  1654 E8E9 A8					TAY			; Y holds now the actual index to the stripped opcode table
  1655 E8EA B9 74 EA				LDA	OPCODES,Y	; load packed mnemonic_index/instr._bytes from opcode table
  1656 E8ED A8					TAY			; and save to Y
  1657 E8EE 29 03				AND	#$03		; the lower two bits are the number of instruction bytes
  1658 E8F0 85 E3				STA	IBYTES		; store it in IBYTES var
  1659 E8F2 98					TYA			; reload packed index
  1660 E8F3 4A					LSR			; and strip the lower two bits off
  1661 E8F4 4A					LSR	
  1662 E8F5 A8					TAY			; Y holds now the index to the mnemonics table
  1663 E8F6 B9 3B EA				LDA   	MNEMONICSH,Y    ; load first packed byte of mnemonic string
  1664 E8F9 85 E7				STA   	ASCH            ; and store it as left byte of mnemonic
  1665 E8FB B9 02 EA				LDA   	MNEMONICSL,Y    ; load second packed byte of mnemonic string
  1666 E8FE 85 E6				STA   	ASCL            ; and store it as right byte of mnemonic
  1667 E900 20 AB E9				JSR	SHOWHEX		; first print out all instruction bytes as hex numbers
  1668 E903 A2 03				LDX   	#$03		; we have to unpack three chars
  1669 E905 A9 00		NEXTMCHR        LDA   	#$00		; clear A
  1670 E907 A0 05				LDY   	#$05            ; shift 5 bits into A
  1671 E909 06 E6		NEXTSHIFT       ASL   	ASCL           	; MSBit of ASCL in C
  1672 E90B 26 E7				ROL   	ASCH		; C in LSBit of ASCH and MSBit of ASCH in C
  1673 E90D 2A					ROL   			; C in A
  1674 E90E 88					DEY
  1675 E90F D0 F8				BNE   	NEXTSHIFT
  1676 E911 69 3F				ADC   	#'?'		; add offset to result, to make it an ASCII char
  1677 E913 20 52 E0				JSR     COUT		; print one character of mnemonic
  1678 E916 CA					DEX
  1679 E917 D0 EC				BNE     NEXTMCHR	; more chars to decode?
  1680 E919 A9 02				LDA	#$02		; print two space chars
  1681 E91B 20 DE E0				JSR	TAB
  1682
  1683 				; decode address mode and print left part of mode string ('#', '(' or 'A')
  1684
  1685 E91E A2 A0				LDX     #$A0            ; default address mode is implied
  1686 E920 A0 FF				LDY	#$FF
  1687 E922 C8			NEXTMASK	INY
  1688 E923 C0 0F				CPY	#$0F		; all masks tested?
  1689 E925 F0 0D				BEQ	ENDMASK		; yes, finish. Address mode is implied
  1690 E927 B9 C5 E9				LDA	ADRMODEM,Y	; load mask
  1691 E92A 25 E0				AND	OPCODE		; mask opcode
  1692 E92C D9 D4 E9				CMP	ADRMODEC,Y	; is it the mask result?
  1693 E92F D0 F1				BNE	NEXTMASK	; no, try next mask
  1694 E931 BE E3 E9				LDX	ADRMODER,Y	; yes, load the resulting address mode
  1695 E934 86 E2		ENDMASK		STX	ADRMODE		; save address mode
  1696 E936 8A					TXA			; address mode is in A
  1697 E937 29 0F				AND	#$0F		; A holds left mode string index
  1698 E939 A8					TAY
  1699 E93A B9 F2 E9				LDA	ADRMSTRL,Y      ; load left mode string
  1700 E93D F0 03				BEQ	PRINTVAL	; is it a NULL char? Then there is nothing to print
  1701 E93F 20 52 E0				JSR	COUT		; else print character
  1702
  1703 				; print either one or two operand value bytes
  1704
  1705 E942 20 7F E9		PRINTVAL	JSR	INCADR		; increment current address
  1706 E945 A6 E3				LDX	IBYTES		; load number of instruction bytes
  1707 E947 CA					DEX			; more than one IBs?
  1708 E948 F0 3B				BEQ	ENDINC		; no, just finish
  1709 E94A A9 24				LDA	#'$'		; yes, print operant value
  1710 E94C 20 52 E0				JSR	COUT		; first print out '$' as hex number indicator
  1711 E94F A0 01				LDY	#$01
  1712 E951 CA					DEX			; more than two IBs?
  1713 E952 F0 05				BEQ	HEX1		; no, just print one byte
  1714 E954 B1 FA				LDA	(ADRL),Y	; load high byte
  1715 E956 20 91 E0				JSR	HEXOUT		; and print it as hex number
  1716 E959 88			HEX1		DEY
  1717 E95A B1 FA				LDA	(ADRL),Y	; load low byte
  1718 E95C A6 E2				LDX	ADRMODE
  1719 E95E E0 A4				CPX	#$A4		; is it a branch opcode?
  1720 E960 F0 24				BEQ	CALCADR		; yes, calculate branch destination address
  1721 E962 20 91 E0				JSR	HEXOUT		; no, print byte as hex number
  1722
  1723 				; print right part of mode string. (',X', ',Y', ',X)', '),Y' or ')' )
  1724
  1725 E965 8A					TXA			; load address mode in A
  1726 E966 4A					LSR			; upper nibble is index to right address mode string
  1727 E967 4A					LSR			; so we have to shift it right by four bits
  1728 E968 4A					LSR	
  1729 E969 4A					LSR	
  1730 E96A A8					TAY
  1731 E96B B9 F7 E9		NEXTAMCHR	LDA	ADRMSTRR,Y	; load one char of right mode string
  1732 E96E F0 06				BEQ     ENDMODE		; if a NULL char then we are finished
  1733 E970 20 52 E0				JSR	COUT		; else print char
  1734 E973 C8					INY
  1735 E974 D0 F5				BNE	NEXTAMCHR	; branch always
  1736
  1737 				; finish current instruction
  1738
  1739 E976 A5 E3		ENDMODE		LDA	IBYTES		; how many address increments left?
  1740 E978 C9 03				CMP	#$03
  1741 E97A D0 03				BNE	INCADR		; just one?
  1742 E97C 20 7F E9				JSR	INCADR		; no, two increments needed
  1743
  1744 				; increment current address
  1745
  1746 E97F E6 FA		INCADR  	INC  	ADRL    	; increment current address
  1747 E981 D0 02		        	BNE  	ENDINC  	; no carry!
  1748 E983 E6 FB		        	INC  	ADRH
  1749 E985 60			ENDINC		RTS			; end of disassembly
  1750
  1751 				; calculate destination address for branch instructions
  1752
  1753 E986 38			CALCADR		SEC
  1754 E987 A8					TAY			; transfer A to Y for sign test
  1755 E988 10 10				BPL	ADDOFS		; is the branch offset positiv?
  1756 E98A 49 FF				EOR	#$FF		; no, subtract offset from current address
  1757 E98C 85 E8				STA	STOL
  1758 E98E A5 FA				LDA	ADRL
  1759 E990 E5 E8				SBC	STOL		; subtract branch offset from LSB current address
  1760 E992 A8					TAY			; store low byte of address to Y
  1761 E993 A5 FB				LDA	ADRH
  1762 E995 E9 00				SBC	#$00		; substract carry from MSB of address
  1763 E997 4C A1 E9				JMP	PRINTOFFS
  1764 E99A 65 FA		ADDOFS		ADC	ADRL		; add branch offset to LSB of current address
  1765 E99C A8					TAY			; store low byte of address to Y
  1766 E99D A5 FB				LDA	ADRH
  1767 E99F 69 00				ADC	#$00		; add carry to MSB of address
  1768 E9A1 20 91 E0		PRINTOFFS	JSR	HEXOUT		; print high byte of branch address
  1769 E9A4 98					TYA
  1770 E9A5 20 91 E0				JSR	HEXOUT		; print low byte of branch address
  1771 E9A8 4C 7F E9				JMP	INCADR		; and increment current address by one
  1772
  1773 				; show instruction bytes as hex values and trailing variable number of space chars
  1774
  1775 E9AB A0 00		SHOWHEX		LDY	#$00
  1776 E9AD 20 5E E0		NEXTBYTE	JSR	SPCOUT		; print leading space char
  1777 E9B0 B1 FA				LDA	(ADRL),Y	; load data byte
  1778 E9B2 20 91 E0				JSR	HEXOUT		; and print it
  1779 E9B5 C8					INY
  1780 E9B6 C4 E3				CPY	IBYTES		; all data bytes printed?
  1781 E9B8 D0 F3				BNE	NEXTBYTE	; no, print next byte
  1782 E9BA A9 0C				LDA	#$0C		; tab size is 12
  1783 E9BC 38					SEC
  1784 E9BD E9 03		CALCTAB		SBC	#$03		; reduce tab space by 3 for every data byte
  1785 E9BF 88					DEY
  1786 E9C0 D0 FB				BNE	CALCTAB		; all data bytes considered?
  1787 E9C2 4C DE E0				JMP	TAB
  1788
  1789 				; Address Mode Decode Tables ***************************************************
  1790
  1791 				; Mask, Mask Result and Mode tables. If Opcode and Mask = Mask Result then Mode
  1792 				; each Mode holds two indices (4 bits R | 4 bits L) to the mode string parts
  1793
  1794 				; ******************************************************************************
  1795
  1796 E9C5 FF FF FF 1F 1F 1F + ADRMODEM	.byte	$FF,$FF,$FF,$1F,$1F,$1F,$1F,$1F,$9F,$9F,$1C,$1C,$DF,$1C,$1C ; mask bits
  1797
  1798 E9D4 6C A2 BE 01 09 10 + ADRMODEC	.byte	$6C,$A2,$BE,$01,$09,$10,$11,$19,$0A,$80,$04,$0C,$96,$14,$1C ; mask result bits
  1799
  1800 E9E3 52 A1 80 32 A1 A4 + ADRMODER	.byte	$52,$A1,$80,$32,$A1,$A4,$72,$80,$A3,$A1,$A0,$A0,$80,$00,$00 ; packed mode bits
  1801
  1802 				; Address Mode Strings *********************************************************
  1803
  1804 E9F2 00 23 28 41 00	ADRMSTRL	.byte	$00,$23,$28,$41,$00
  1805 						;	 0   #   (   A   0
  1806
  1807 E9F7 2C 58 00 2C 58 29 + ADRMSTRR	.byte	$2C,$58,$00,$2C,$58,$29,$00,$29,$2C,$59,$00
  1808 						;	 ,   X   0   ,   X   )   0   )   ,   Y   0
  1809
  1810 				; Mnemonics Table **************************************************************
  1811
  1812 				; three characters packed in two bytes. Each character uses 5 bits, last bit is
  1813 				; unused
  1814
  1815 				; ******************************************************************************
  1816
  1817 				; low bytes of table
  1818
  1819 EA02 48 CA 1A 08 28 A4 + MNEMONICSL	.byte	$48, $CA, $1A, $08, $28, $A4, $AA, $94
  1820 EA0A CC 5A D8 C8 E8 48 +      		.byte	$CC, $5A, $D8, $C8, $E8, $48, $4A, $54
  1821 EA12 6E A2 72 74 88 B2 +      		.byte	$6E, $A2, $72, $74, $88, $B2, $B4, $26
  1822 EA1A C8 F2 F4 A2 26 44 +      		.byte	$C8, $F2, $F4, $A2, $26, $44, $72, $74
  1823 EA22 26 22 C4 44 62 44 +      		.byte	$26, $22, $C4, $44, $62, $44, $62, $1A
  1824 EA2A 26 54 68 C8 88 8A +      		.byte	$26, $54, $68, $C8, $88, $8A, $94, $44
  1825 EA32 72 74 B2 B4 32 44 +      		.byte	$72, $74, $B2, $B4, $32, $44, $68, $84, $00
  1826
  1827 				; high bytes of table
  1828
  1829 EA3B 11 13 15 19 19 19 + MNEMONICSH	.byte	$11, $13, $15, $19, $19, $19, $1A, $1B
  1830 EA43 1B 1C 1C 1D 1D 23 +      		.byte	$1B, $1C, $1C, $1D, $1D, $23, $23, $23
  1831 EA4B 23 23 24 24 29 29 +      		.byte	$23, $23, $24, $24, $29, $29, $29, $34
  1832 EA53 53 53 53 5B 5D 69 +      		.byte	$53, $53, $53, $5B, $5D, $69, $69, $69
  1833 EA5B 6D 7C 84 8A 8A 8B +      		.byte	$6D, $7C, $84, $8A, $8A, $8B, $8B, $9C
  1834 EA63 9C 9D 9D A0 A1 A1 +      		.byte	$9C, $9D, $9D, $A0, $A1, $A1, $A1, $A5
  1835 EA6B A5 A5 A8 A8 AD AE +      		.byte	$A5, $A5, $A8, $A8, $AD, $AE, $AE, $AE, $00
  1836
  1837 				; Compressed Opcode Table ******************************************************
  1838
  1839 				; each byte holds a 6 bit index to the mnemonic table and 2 bits instruction
  1840 				; byte count
  1841 				; empty opcode table columns (3,7,B,F) are stripped out
  1842
  1843 				; ******************************************************************************
  1844
  1845 EA74 29 8A E1 E1 8A 0A + OPCODES         .byte	$29, $8A, $E1, $E1, $8A, $0A, $91, $8A, $09, $E1, $8B, $0B
  1846 EA80 26 8A E1 E1 8A 0A +      		.byte	$26, $8A, $E1, $E1, $8A, $0A, $35, $8B, $E1, $E1, $8B, $0B
  1847 EA8C 73 06 E1 1A 06 9E +      		.byte	$73, $06, $E1, $1A, $06, $9E, $99, $06, $9D, $1B, $07, $9F
  1848 EA98 1E 06 E1 E1 06 9E +      		.byte	$1E, $06, $E1, $E1, $06, $9E, $B1, $07, $E1, $E1, $07, $9F
  1849 EAA4 A5 5E E1 E1 5E 82 +      		.byte	$A5, $5E, $E1, $E1, $5E, $82, $8D, $5E, $81, $6F, $5F, $83
  1850 EAB0 2E 5E E1 E1 5E 82 +      		.byte	$2E, $5E, $E1, $E1, $5E, $82, $3D, $5F, $E1, $E1, $5F, $83
  1851 EABC A9 02 E1 E1 02 A2 +      		.byte	$A9, $02, $E1, $E1, $02, $A2, $95, $02, $A1, $6F, $03, $A3
  1852 EAC8 32 02 E1 E1 02 A2 +      		.byte	$32, $02, $E1, $E1, $02, $A2, $B9, $03, $E1, $E1, $03, $A3
  1853 EAD4 E1 BE E1 C6 BE C2 +      		.byte	$E1, $BE, $E1, $C6, $BE, $C2, $59, $E1, $D5, $C7, $BF, $C3
  1854 EAE0 0E BE E1 C6 BE C2 +      		.byte	$0E, $BE, $E1, $C6, $BE, $C2, $DD, $BF, $D9, $E1, $BF, $E1
  1855 EAEC 7E 76 7A 7E 76 7A +      		.byte	$7E, $76, $7A, $7E, $76, $7A, $CD, $76, $C9, $7F, $77, $7B
  1856 EAF8 12 76 E1 7E 76 7A +      		.byte	$12, $76, $E1, $7E, $76, $7A, $41, $77, $D1, $7F, $77, $7B
  1857 EB04 4E 46 E1 4E 46 52 +      		.byte	$4E, $46, $E1, $4E, $46, $52, $69, $46, $55, $4F, $47, $53
  1858 EB10 22 46 E1 E1 46 52 +      		.byte	$22, $46, $E1, $E1, $46, $52, $39, $47, $E1, $E1, $47, $53
  1859 EB1C 4A AE E1 4A AE 62 +      		.byte	$4A, $AE, $E1, $4A, $AE, $62, $65, $AE, $85, $4B, $AF, $63
  1860 EB28 16 AE E1 E1 AE 62 +      		.byte	$16, $AE, $E1, $E1, $AE, $62, $B5, $AF, $E1, $E1, $AF, $63
  1861
  1862 				; ******************************************************************************
  1863 				; START OF HIGH LEVEL REAL TIME CLOCK CODE
  1864 				; ******************************************************************************
  1865
  1866 				; **** Check If Date/Time Is Set And Show Date/Time ****************************
  1867
  1868 EB34 20 43 EB		CLOCKSTART	JSR	CHECKDATETIME
  1869 EB37 20 5A E0				JSR	CROUT
  1870 EB3A 20 5A E0				JSR	CROUT
  1871 EB3D 20 5E E0				JSR	SPCOUT
  1872 EB40 4C F9 EB				JMP	PRINTDATETIME
  1873
  1874 				; **** Check If Date/Time Is Set ***********************************************
  1875
  1876 				; ******************************************************************************
  1877
  1878 EB43 A9 08		CHECKDATETIME	LDA	#$08
  1879 EB45 20 E6 E2				JSR	READCLOCK
  1880 EB48 C0 65				CPY	#$65
  1881 EB4A D0 05				BNE	DATETIMELOST
  1882 EB4C E0 02				CPX	#$02
  1883 EB4E D0 01				BNE	DATETIMELOST
  1884 EB50 60					RTS
  1885
  1886 EB51 20 43 E5		DATETIMELOST	JSR	LOADSTRING
  1887 EB54 A0 A8				LDY	#DT_NOT_SET-STRINGP
  1888 EB56 20 85 E0				JSR	WRSTR
  1889
  1890 EB59 20 86 EB		SETDATETIME	JSR	SETTIME
  1891
  1892 EB5C 20 43 E5		SETDATE		JSR	LOADSTRING
  1893 EB5F A9 2E				LDA	#'.'
  1894 EB61 85 F2				STA	DIVCHAR
  1895 EB63 A0 BE				LDY	#DATEINPUT-STRINGP
  1896 EB65 20 85 E0				JSR	WRSTR
  1897 EB68 A0 31				LDY	#$31
  1898 EB6A 20 B0 EB				JSR	GETDIGIT
  1899 EB6D 85 F4				STA	YREG
  1900 EB6F 20 49 EC				JSR	PRINTDIVCHAR
  1901 EB72 A0 12				LDY	#$12
  1902 EB74 20 B0 EB				JSR	GETDIGIT
  1903 EB77 85 F5				STA	XREG
  1904 EB79 20 49 EC				JSR	PRINTDIVCHAR
  1905 EB7C A0 99				LDY	#$99
  1906 EB7E 20 B0 EB				JSR	GETDIGIT
  1907 EB81 85 F3				STA	ACC
  1908 EB83 4C B7 E2				JMP	WRITEDATE2
  1909
  1910 EB86 20 43 E5		SETTIME		JSR	LOADSTRING
  1911 EB89 A9 3A				LDA	#':'
  1912 EB8B 85 F2				STA	DIVCHAR
  1913 EB8D A0 D7				LDY	#TIMEINPUT-STRINGP
  1914 EB8F 20 85 E0				JSR	WRSTR
  1915 EB92 A0 23				LDY	#$23
  1916 EB94 20 B0 EB				JSR	GETDIGIT
  1917 EB97 85 F3				STA	ACC
  1918 EB99 20 49 EC				JSR	PRINTDIVCHAR
  1919 EB9C A0 59				LDY	#$59
  1920 EB9E 20 B0 EB				JSR	GETDIGIT
  1921 EBA1 85 F5				STA	XREG
  1922 EBA3 20 49 EC				JSR	PRINTDIVCHAR
  1923 EBA6 A0 59				LDY	#$59
  1924 EBA8 20 B0 EB				JSR	GETDIGIT
  1925 EBAB 85 F4				STA	YREG
  1926 EBAD 4C 9F E2				JMP	WRITETIME2
  1927
  1928 EBB0 C8			GETDIGIT	INY
  1929 EBB1 84 FD				STY	YSAV
  1930 EBB3 20 EA EB		GETDIGIT1	JSR	NUMINPUT
  1931 EBB6 90 FB				BCC	GETDIGIT1
  1932 EBB8 AA					TAX
  1933 EBB9 E9 30				SBC	#48
  1934 EBBB 0A					ASL	
  1935 EBBC 0A					ASL	
  1936 EBBD 0A					ASL	
  1937 EBBE 0A					ASL	
  1938 EBBF C5 FD				CMP	YSAV
  1939 EBC1 B0 F0				BCS	GETDIGIT1
  1940 EBC3 85 FC				STA	TEMP
  1941 EBC5 8A					TXA
  1942 EBC6 20 52 E0				JSR	COUT
  1943 EBC9 20 EA EB		GETDIGIT2	JSR	NUMINPUT
  1944 EBCC 90 FB				BCC	GETDIGIT2
  1945 EBCE AA					TAX
  1946 EBCF E9 30				SBC	#48
  1947 EBD1 05 FC				ORA	TEMP
  1948 EBD3 C5 FD				CMP	YSAV
  1949 EBD5 B0 F2				BCS	GETDIGIT2
  1950 EBD7 85 FC				STA	TEMP
  1951 EBD9 A9 2E				LDA	#'.'
  1952 EBDB C5 F2				CMP	DIVCHAR
  1953 EBDD D0 04				BNE	GETDIGITEND
  1954 EBDF A5 FC				LDA	TEMP
  1955 EBE1 F0 E6				BEQ	GETDIGIT2
  1956 EBE3 8A			GETDIGITEND	TXA
  1957 EBE4 20 52 E0				JSR	COUT
  1958 EBE7 A5 FC				LDA	TEMP
  1959 EBE9 60					RTS
  1960
  1961
  1962 EBEA 20 47 E0		NUMINPUT	JSR	CIN
  1963 EBED C9 30				CMP	#'0'
  1964 EBEF 90 04				BCC	NOTNUM
  1965 EBF1 C9 3A				CMP	#':'
  1966 EBF3 90 02				BCC	ISNUM
  1967 EBF5 18			NOTNUM		CLC
  1968 EBF6 60					RTS
  1969 EBF7 38			ISNUM		SEC
  1970 EBF8 60					RTS
  1971
  1972 				; **** Print Date And Time *****************************************************
  1973
  1974 				; ******************************************************************************
  1975
  1976 EBF9 20 2B EC		PRINTDATETIME	JSR	PRINTDATE	; print current date	; PRINTFULLDATE
  1977 EBFC 20 5E E0				JSR	SPCOUT
  1978 EBFF 20 05 EC				JSR	PRINTTIME	; print current time
  1979 EC02 4C 5A E0				JMP	CROUT
  1980
  1981 				; **** Print Time **************************************************************
  1982
  1983 				; ******************************************************************************
  1984
  1985 EC05 A9 3A		PRINTTIME	LDA	#':'
  1986 EC07 85 F2				STA	DIVCHAR
  1987 EC09 20 DE E2				JSR	READTIME
  1988 EC0C 20 46 EC				JSR	PRINTDIGIT
  1989 EC0F 8A					TXA
  1990 EC10 20 46 EC				JSR	PRINTDIGIT
  1991 EC13 98					TYA
  1992 EC14 4C 91 E0				JMP	HEXOUT
  1993
  1994 				; **** Print Date And Day Of Week **********************************************
  1995
  1996 				; ******************************************************************************
  1997
  1998 EC17 20 92 E2		PRINTFULLDATE	JSR	READDOW
  1999 EC1A 0A					ASL	
  2000 EC1B 0A					ASL	
  2001 EC1C A8					TAY
  2002 EC1D A9 5E				LDA  	#< (DAYS-4)
  2003 EC1F 85 EA				STA  	PSTRL
  2004 EC21 A9 E8				LDA  	#> (DAYS-4)
  2005 EC23 85 EB				STA  	PSTRH
  2006 EC25 20 85 E0				JSR	WRSTR
  2007 EC28 20 5E E0				JSR	SPCOUT
  2008
  2009 				; **** Print Date **************************************************************
  2010
  2011 				; ******************************************************************************
  2012
  2013 EC2B A9 2E		PRINTDATE	LDA	#DATEDIV	; load divider char
  2014 EC2D 85 F2				STA	DIVCHAR
  2015 EC2F 20 E2 E2				JSR	READDATE	; read current date
  2016 EC32 85 FC				STA	TEMP		; store year value in TEMP
  2017 EC34 98					TYA
  2018 EC35 20 46 EC				JSR	PRINTDIGIT	; print day
  2019 EC38 8A					TXA
  2020 EC39 20 46 EC				JSR	PRINTDIGIT	; print month
  2021 EC3C A9 20				LDA	#CENTURY
  2022 EC3E 20 91 E0				JSR	HEXOUT		; print century
  2023 EC41 A5 FC				LDA	TEMP
  2024 EC43 4C 91 E0				JMP	HEXOUT		; print year
  2025
  2026 EC46 20 91 E0		PRINTDIGIT	JSR	HEXOUT		; print digit
  2027 EC49 A5 F2		PRINTDIVCHAR	LDA	DIVCHAR		; print divider char
  2028 EC4B 4C 52 E0				JMP	COUT
  2029
  2030 				; ******************************************************************************
  2031 				; START OF LOW LEVEL ROUTINES
  2032 				; ******************************************************************************
  2033
  2034 				; **** Print Processor Status **************************************************
  2035
  2036 				; ******************************************************************************
  2037
  2038 EC4E 20 36 E7		PRSTATUS	JSR	PRADDRESS	; print current program counter
  2039 EC51 A2 04				LDX	#$04
  2040 EC53 20 5E E0		NXTREG		JSR	SPCOUT		; print space char
  2041 EC56 BD 6D E7				LDA	PSSTR,X		; load register label
  2042 EC59 20 52 E0				JSR	COUT		; and print it
  2043 EC5C A9 3D				LDA	#'='
  2044 EC5E 20 52 E0				JSR	COUT		; print =
  2045 EC61 B5 F1				LDA	PREG,X
  2046 EC63 20 91 E0				JSR	HEXOUT
  2047 EC66 CA					DEX
  2048 EC67 10 EA				BPL	NXTREG
  2049 EC69 60					RTS
  2050
  2051 				; **** Initialize IO Devices ***************************************************
  2052
  2053 				; ******************************************************************************
  2054
  2055 EC6A A9 00		INITIO          LDA     #$00
  2056 EC6C A2 06		                LDX     #$06
  2057 EC6E 95 14		INITIO1         STA     IOBASE,X        ; clear K2,K3 and K4 base address pointers
  2058 EC70 CA			                DEX
  2059 EC71 D0 FB		                BNE     INITIO1
  2060
  2061 EC73 20 64 F7		                JSR     DEV_INIT        ; initialize driver list
  2062 EC76 A2 88		SET_TTY_DEV     LDX     #<  TTY_DEV
  2063 EC78 A0 F9		                LDY     #> TTY_DEV
  2064 EC7A 20 6F F7		                JSR     DEV_ADD         ; add terminal driver
  2065 EC7D 8D 74 1A				STA	STDINDEV        ; and initially set TTY as standard IO
  2066 EC80 8D 75 1A				STA	STDOUTDEV
  2067 EC83 85 C9				STA     DEVID
  2068
  2069 EC85 A2 A8		SET_XMODEM_DEV  LDX     #<  XMODEM_DEV
  2070 EC87 A0 F9		                LDY     #> XMODEM_DEV
  2071 EC89 20 6F F7		                JSR     DEV_ADD         ; add xmodem driver
  2072
  2073 EC8C A2 90		SET_PRINTER_DEV LDX     #<  PPRINT_DEV
  2074 EC8E A0 F9		                LDY     #> PPRINT_DEV
  2075 EC90 20 6F F7		                JSR     DEV_ADD         ; add parallel printer driver
  2076 EC93 8D 76 1A		                STA	STDPRINTDEV     ; and initially set parallel port printer as standard printer
  2077
  2078 EC96 20 A9 EC				JSR     DETECT_IO       ; detect IO cards
  2079
  2080 				; TEMP #### future: Set std beep only if no language card found
  2081
  2082 EC99 A9 6A		INIT_BEEP	LDA	#< DOBEEP	; load low byte of address of system beep
  2083 EC9B 8D 66 1A				STA	STDBEEP
  2084 EC9E A9 E1				LDA	#> DOBEEP	; load high byte of address of system beep
  2085 ECA0 8D 67 1A				STA	STDBEEP+1
  2086
  2087 ECA3 4C AD E1		                JMP     RESET_STDIO     ; reset to standard IO devices
  2088
  2089 ECA6 6C FA 00		IO_INITIALIZE   JMP     (ADRL)
  2090
  2091 				; **** Scan Bus And Detect IO Cards ********************************************
  2092 				;
  2093 				; ******************************************************************************
  2094
  2095 ECA9 A9 FB		DETECT_IO       LDA     #$FB
  2096 ECAB 85 FA		                STA     ADRL            ; set pointer to init routine
  2097 ECAD A9 07		                LDA     #$07
  2098 ECAF 85 FB		                STA     ADRH
  2099 ECB1 A9 03		                LDA     #$03            ; search on three slot base addresses
  2100 ECB3 85 FE		                STA     PDBCNT
  2101 ECB5 18			DETECT_LOOP     CLC
  2102 ECB6 A5 FB		                LDA     ADRH
  2103 ECB8 AA			                TAX
  2104 ECB9 E8			                INX                     ; X holds slot base address high byte
  2105 ECBA 69 04		                ADC     #$04
  2106 ECBC 85 FB		                STA     ADRH            ; set high byte to init routine
  2107 ECBE A0 03		                LDY	#$03            ; test byte string in card ROM against magic number
  2108 ECC0 B9 69 E7		COMP_LOOP	LDA	MAGIC1,Y        ; get one byte of magic number
  2109 ECC3 D1 FA				CMP	(ADRL),Y        ; and compare it with ROM content.
  2110 ECC5 D0 06				BNE	NO_MATCH        ; byte does not match, exit inner detection loop
  2111 ECC7 88					DEY                     ; byte matched magic number, try next one
  2112 ECC8 10 F6				BPL	COMP_LOOP       ; more bytes to compare?
  2113 ECCA 20 A6 EC				JSR     IO_INITIALIZE   ; IO card detected. Call init routine
  2114 ECCD C6 FE		NO_MATCH        DEC     PDBCNT
  2115 ECCF D0 E4		                BNE     DETECT_LOOP     ; try next card base address
  2116 				                                        ; fall through to IO/Language Card detection
  2117
  2118 				; **** Try To Detect IO/Language Card ******************************************
  2119 				;
  2120 				; ******************************************************************************
  2121
  2122 ECD1 A9 00		DETECT_IOL_CARD	LDA	#$00
  2123 ECD3 85 14				STA	IOBASEL		; set low byte of IO base pointer to $00
  2124 ECD5 A9 08				LDA	#$08		; try 1st IO-card at $0800
  2125 ECD7 85 15				STA	IOBASEH		; set high byte of IO base pointer to $00
  2126 						
  2127 ECD9 A0 03		DETECT_LP	LDY	#VIA_DDRA	; input & output regs are the same
  2128 ECDB A9 55				LDA	#$55		; DDRA = $55
  2129 ECDD 91 14				STA	(IOBASE),Y	; DDRA = 0101 0101 (0=input, 1=output)
  2130 ECDF A0 01				LDY	#VIA_PORTA	; 
  2131 ECE1 A9 00				LDA	#0
  2132 ECE3 91 14				STA	(IOBASE),Y	; Write all zeros to PORTA	
  2133 ECE5 B1 14				LDA	(IOBASE),Y	; Get PORTA value
  2134 ECE7 C9 AA				CMP	#$AA		; input bits should be 1, output bits should be 0
  2135 ECE9 F0 16				BEQ	INIT_IOCARD	; branch if a card is found
  2136 						
  2137 ECEB A5 15				LDA	IOBASEH		; MSB of IO base pointer
  2138 ECED 18					CLC
  2139 ECEE 69 04				ADC	#4		; next IO base-address
  2140 ECF0 85 15				STA	IOBASEH		; next card-address
  2141 ECF2 C9 14				CMP	#$14
  2142 ECF4 90 E3				BCC	DETECT_LP	; branch if MSB base-address < $14
  2143 						
  2144 ECF6 A9 00				LDA	#0
  2145 ECF8 85 15				STA	IOBASEH		; 0 = no card found
  2146 ECFA 60			NOCARD          RTS                     ; no card found
  2147
  2148 ECFB					ORG	$ED01		; maintain compatibility with v1.1.4
  2149 						
  2150 				; **** Initialize The IO/Language Card *****************************************
  2151 ED01 AD 74 1A		INIT_IOCARD     LDA     STDINDEV
  2152 ED04 C9 10		                CMP     #TTY1_ID
  2153 ED06 D0 03		                BNE     INIT_VIA        ; is standard input device still TTY?
  2154 ED08 20 BD F3		                JSR	DETECT_ASCIIKBD	; yes, check if ASCII keyboard available, else skip it
  2155 ED0B A0 10		INIT_VIA	LDY	#PORTB
  2156 ED0D A9 4E				LDA	#%01001110	; SDA=0,/CAS_MOT=1,CAS_SENSE=0,CAS_WR=0,/SPI_LOAD=1,SPI_CS=1,/SND_WE=1,SCL=0
  2157 ED0F 85 E4				STA	VIA_STATUS	; store current PortB output status
  2158 ED11 91 14				STA	(IOBASE),Y	; set SDA as input to pull it high, set SCL as input to pull it high
  2159 ED13 A0 12				LDY	#DDRB		; initialize data direction of port B
  2160 ED15 A9 5E				LDA	#%01011110	; SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
  2161 ED17 91 14				STA	(IOBASE),Y
  2162 ED19 A0 13				LDY	#DDRA		; initialize data direction of port A
  2163 ED1B A9 FF				LDA	#$FF		; all pins of port A are outputs
  2164 ED1D 91 14				STA	(IOBASE),Y
  2165 ED1F 20 D0 E3				JSR	SOUND_MUTEALL	; mute sound output
  2166 ED22 20 26 F4		INIT_SDCARD     JSR     SPI_INIT        ; initialize SPI
  2167 ED25 A2 B8		                LDX     #< SDC_DEV
  2168 ED27 A0 F9		                LDY     #> SDC_DEV
  2169 ED29 20 6F F7		                JSR     DEV_ADD         ; add sd-card driver
  2170 ED2C A9 00		INIT_TAPE       LDA	#$00
  2171 ED2E A0 1B		                LDY	#ACR		; select auxilary control register
  2172 ED30 91 14				STA	(IOBASE),Y	; set one shot timer mode
  2173 ED32 A0 1C				LDY	#PCR		; select peripheral control register
  2174 ED34 91 14				STA	(IOBASE),Y	; set interrupt on falling edge of CA1
  2175 ED36 20 8B ED				JSR	VIA2IRQ_ON	; Enable VIA2 Timer interrupt
  2176 ED39 20 75 ED				JSR	RESET_TIMER2	; set Timer2 to 1/60 second
  2177 ED3C A2 47				LDX	#< VIA2IRQ 	; set low address of clock interrupt routine
  2178 ED3E A0 ED				LDY	#> VIA2IRQ   	; set high address of clock interrupt routine
  2179 ED40 8E 7E 1A		SETIRQVECT	STX	IRQVECT
  2180 ED43 8C 7F 1A				STY	IRQVECT+1
  2181 ED46 60					RTS
  2182
  2183 				; ******************************************************************************
  2184 				; TAPE READ/WRITE ROUTINES removed 24-07-'25 Emile
  2185 				; ******************************************************************************
  2186
  2187 				; **** VIA2 IRQ Routine ********************************************************
  2188 ED47 48			VIA2IRQ		PHA			; save accumulator
  2189 ED48 98					TYA
  2190 ED49 48					PHA			; save Y register
  2191 ED4A A0 1D				LDY	#IFR		; select interrupt flag register
  2192 ED4C B1 14				LDA	(IOBASE),Y
  2193 ED4E 10 1F				BPL	NOVIA2IRQ	; check if it was a VIA2 interrupt
  2194 						
  2195 ED50 29 02				AND	#$02		; yes, CA1 interrupt occured?
  2196 ED52 F0 0E				BEQ	CHECKKEY	; no, check key status
  2197 						
  2198 ED54 A0 11		CHECKBIT	LDY	#PORTA		; VIA2 PORTA
  2199 ED56 B1 14				LDA	(IOBASE),Y	; clear CA1 interrupt flag
  2200 ED58 AD 9F 1A				LDA	CNTIRQ		; load timer IRQ status
  2201 ED5B A9 31				LDA	#RPTIME
  2202 ED5D 8D 95 1A				STA	CNTB		; set RIOT timer B to Read-Point-Time
  2203 ED60 D0 09				BNE	ENDVIA2IRQ	; and exit IRQ routine
  2204 						
  2205 ED62 20 75 ED		CHECKKEY	JSR	RESET_TIMER2	; reset Timer2 and interrupt flags
  2206 ED65 A5 DA				LDA     TICKCNT         ; load the tick counter
  2207 ED67 F0 02				BEQ     ENDVIA2IRQ      ; is it 0?
  2208 						
  2209 ED69 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  2210 ED6B 68			ENDVIA2IRQ	PLA
  2211 ED6C A8					TAY			; restore Y register
  2212 ED6D 68					PLA			; restore accumulator
  2213 ED6E 40					RTI
  2214
  2215 ED6F 68			NOVIA2IRQ	PLA
  2216 ED70 A8					TAY			; restore Y register
  2217 ED71 68				        PLA			; restore accumulator
  2218 ED72 4C 18 F3		USRIRQ		JMP	IRQ		; call user interrupt routine
  2219
  2220 				; **** Reset Timer2 Routine ****************************************************
  2221 ED75 A0 18		RESET_TIMER2	LDY	#T2CL		; select Timer2 lower byte register
  2222 ED77 A9 4B				LDA	#$4B		; reset Timer2
  2223 ED79 91 14				STA	(IOBASE),Y	; store timer low value
  2224 ED7B A9 41				LDA	#$41		; $411A = 16666 => 1/60 second
  2225 ED7D C8					INY			; select Timer2 higher byte register
  2226 ED7E 91 14		VIA2IRQ_W	STA	(IOBASE),Y	; store timer high value
  2227 ED80 60			VIA2IRQ_X	RTS			; return
  2228
  2229 				; **** VIA2 IRQ Off ************************************************************
  2230 ED81 A0 1E		VIA2IRQ_OFF     LDY	#IER		; select interrupt enable register
  2231 ED83 A5 15		                LDA     IOBASEH
  2232 ED85 F0 F9		                BEQ     VIA2IRQ_X    	; IO card available? No, just exit
  2233 ED87 A9 7F				LDA	#$7F		; Disable all VIA2 interrupts
  2234 ED89 D0 F3				BNE	VIA2IRQ_W	; branch always
  2235
  2236 				; **** VIA2 IRQ On *************************************************************
  2237 ED8B 20 81 ED		VIA2IRQ_ON	JSR	VIA2IRQ_OFF	; disable all VIA2 interrupts
  2238 ED8E A5 15		                LDA     IOBASEH
  2239 ED90 F0 EE		                BEQ     VIA2IRQ_X    	; IO card available? No, just exit
  2240 ED92 A9 A0				LDA	#$A0		; Enable interrupt for Timer2
  2241 ED94 D0 E8				BNE	VIA2IRQ_W	; branch always
  2242 						
  2243 				; ------------------------------------------------------------------------------
  2244 				; Writes one data byte to a specific register of the MCP23017.
  2245 				; Inputs: A: I2C-address of MCP23017 ($40, $42 or $44).
  2246 				;         X: the register to write to
  2247 				;         Y: the databyte to write into the register
  2248 				; Output: C=0: Error writing byte
  2249 				;         C=1: OK
  2250 				; ------------------------------------------------------------------------------
  2251 ED96 86 D8		MCP23017_WRITE	STX	SAVEX		; Save register address
  2252 ED98 84 D9				STY	SAVEY		; Save register data
  2253 ED9A AA					TAX			; X = I2C-address
  2254 ED9B 20 26 E3				JSR	I2C_START	; Send I2C start condition (affects A and Y)
  2255 ED9E 8A					TXA			; A now contains the address of the MCP23017 to write to
  2256 ED9F 29 FE				AND	#$FE		; Make sure it is an I2C write address
  2257 EDA1 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 address
  2258 EDA4 90 0C				BCC	MCP_WRX		; branch if C=0 (NACK)
  2259 						
  2260 EDA6 A5 D8				LDA	SAVEX		; Get register address
  2261 EDA8 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2262 EDAB 90 05				BCC	MCP_WRX		; branch if C=0 (NACK)
  2263
  2264 EDAD A5 D9				LDA	SAVEY		; Get databyte to write
  2265 EDAF 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2266 EDB2 4C 35 E3		MCP_WRX		JMP	I2C_STOP	; send I2C-stop and return
  2267
  2268 				; ------------------------------------------------------------------------------
  2269 				; Reads one data byte from a specific register of the MCP23017.
  2270 				; Inputs: A: I2C-address of MCP23017 ($40, $42 or $44).
  2271 				;         X: the register to read from
  2272 				; Output: C=0: Error reading byte
  2273 				;         C=1: A = byte read
  2274 				; ------------------------------------------------------------------------------
  2275 EDB5 29 FE		MCP23017_READ	AND	#$FE		; Make sure it is an I2C write address
  2276 EDB7 85 D9				STA	SAVEY		; Save I2C write address in SAVEY
  2277 EDB9 86 D8				STX	SAVEX		; SAVEX = register address
  2278 EDBB AA					TAX			; X = I2C write-address
  2279 EDBC 20 26 E3				JSR	I2C_START	; Send I2C start condition (affects A and Y)
  2280 EDBF 8A					TXA			; A now contains the address of the MCP23017 to write to
  2281 EDC0 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 address
  2282 EDC3 90 ED				BCC	MCP_WRX		; branch if C=0 (NACK)
  2283 						
  2284 EDC5 A5 D8				LDA	SAVEX		; Get register address
  2285 EDC7 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2286 EDCA 90 E6				BCC	MCP_WRX		; branch if C=0 (NACK)
  2287 						
  2288 EDCC 20 26 E3				JSR	I2C_START	; Send I2C repeated start condition
  2289 EDCF A5 D9				LDA	SAVEY		; Get I2C write address back
  2290 EDD1 09 01				ORA	#$01		; Make it an I2C read-address
  2291 EDD3 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 read-address
  2292 EDD6 90 DA				BCC	MCP_WRX		; branch if C=0 (NACK)
  2293
  2294 EDD8 20 9F E3				JSR	I2C_RCV		; I2C-read: receive byte 
  2295 EDDB 48					PHA			; Save for now
  2296 EDDC 20 53 E3				JSR	I2C_NACK	; Send NACK (done reading)
  2297 EDDF 20 35 E3				JSR	I2C_STOP	; send I2C-stop and return
  2298 EDE2 68					PLA			; Get byte read back
  2299 EDE3 38					SEC			; C=1: ok
  2300 EDE4 60					RTS			; and return
  2301
  2302 EDE5					ORG 	$F015		; maintain compatibility with previous BIOS versions
  2303
  2304 				; ******************************************************************************
  2305 				; START OF XMODEM CODE
  2306 				; ******************************************************************************
  2307 				;
  2308 				; XMODEM/CRC Sender/Receiver for the 6502
  2309 				;
  2310 				; By Daryl Rictor Aug 2002
  2311 				;
  2312 				; A simple file transfer program to allow transfers between the SBC and a
  2313 				; console device utilizing the x-modem/CRC transfer protocol.
  2314 				;
  2315 				;*******************************************************************************
  2316 				; This implementation of XMODEM/CRC does NOT conform strictly to the
  2317 				; XMODEM protocol standard in that it (1) does not accurately time character
  2318 				; reception or (2) fall back to the Checksum mode.
  2319
  2320 				; (1) For timing, it uses a crude timing loop to provide approximate
  2321 				; delays.  These have been calibrated against a 1MHz CPU clock.  I have
  2322 				; found that CPU clock speed of up to 5MHz also work but may not in
  2323 				; every case.  Windows HyperTerminal worked quite well at both speeds!
  2324 				;
  2325 				; (2) Most modern terminal programs support XMODEM/CRC which can detect a
  2326 				; wider range of transmission errors so the fallback to the simple checksum
  2327 				; calculation was not implemented to save space.
  2328 				;*******************************************************************************
  2329 				;
  2330 				; Files transferred via XMODEM-CRC will have the load address contained in
  2331 				; the first two bytes in little-endian format:
  2332 				;  FIRST BLOCK
  2333 				;     offset(0) = lo(load start address),
  2334 				;     offset(1) = hi(load start address)
  2335 				;     offset(2) = data byte (0)
  2336 				;     offset(n) = data byte (n-2)
  2337 				;
  2338 				; Subsequent blocks
  2339 				;     offset(n) = data byte (n)
  2340 				;
  2341 				; One note, XMODEM send 128 byte blocks.  If the block of memory that
  2342 				; you wish to save is smaller than the 128 byte block boundary, then
  2343 				; the last block will be padded with zeros.  Upon reloading, the
  2344 				; data will be written back to the original location.  In addition, the
  2345 				; padded zeros WILL also be written into RAM, which could overwrite other
  2346 				; data.
  2347 				;
  2348 				;*******************************************************************************
  2349 				;
  2350 				; Code extensions 2022 by Joerg Walke
  2351 				;
  2352 				; Included: CAN command in addition to ESC to cancel sending and receiving data.
  2353 				; Included: EOT command to signal end of transmition.
  2354 				; Included: address range for received data, to override the start address in
  2355 				;           the first data block and to prevent overwriting of data by
  2356 				;	    trailing zeros.
  2357
  2358 				; XMODEM Receive Routine *******************************************************
  2359
  2360 F015 20 39 F2		XModemRcv       JSR     PrintXStart
  2361 F018 85 E0				STA	BLKEND		; set flag to false
  2362 F01A A9 01		                LDA     #$01
  2363 F01C 85 E2		                STA     BLKNO           ; set block # to 1
  2364 F01E 85 E1		                STA	BFLAG           ; set flag to get address from block 1
  2365 F020 A9 43		StartRcv        LDA     #'C'            ; "C" start with CRC mode
  2366 F022 20 65 F3		                JSR     SOUT	     	; send it
  2367 F025 A9 FF		                LDA     #$FF
  2368 F027 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2369 F029 A9 00		                LDA     #$00
  2370 F02B 85 DC		                STA     CRCL
  2371 F02D 85 DD		                STA     CRCH            ; init CRC value
  2372 F02F 20 E2 F1		                JSR     GetByte         ; wait for input
  2373 F032 B0 0C				BCS     GotByte         ; byte received, process it
  2374 F034 4C 20 F0				JMP     StartRcv
  2375 F037 A9 FF		StartBlk        LDA     #$FF
  2376 F039 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2377 F03B 20 E2 F1		                JSR     GetByte         ; get first byte of block
  2378 F03E 90 F7		                BCC     StartBlk        ; timed out, keep waiting...
  2379 F040 C9 1B		GotByte         CMP     #ESC            ; quitting?
  2380 F042 F0 04		                BEQ     GotESC          ; yes
  2381 F044 C9 18				CMP	#CAN		; cancel?
  2382 F046 D0 03				BNE     GotByte1	; no
  2383 F048 4C 41 F2		GotESC          JMP     PrintXErr       ; print error and return
  2384 F04B C9 01		GotByte1        CMP     #SOH            ; start of block?
  2385 F04D F0 07		                BEQ     BegBlk          ; yes
  2386 F04F C9 04		                CMP     #EOT            ;
  2387 F051 D0 45		                BNE     BadCRC          ; Not SOH or EOT, so flush buffer & send NAK
  2388 F053 4C FB F0		                JMP     RDone           ; EOT - all done!
  2389 F056 A2 00		BegBlk          LDX     #$00
  2390 F058 A9 FF		GetBlk          LDA     #$FF            ; 3 sec window to receive characters
  2391 F05A 85 DF		                STA     RETRYH
  2392 F05C 20 CF F1		GetBlk1         JSR     GetData         ; get next character
  2393 F05F 90 37		                BCC     BadCRC          ; chr rcv error, flush and send NAK
  2394 F061 9D 00 15		GetBlk2         STA     RBUFF,x         ; good char, save it in the rcv buffer
  2395 F064 E8			                INX                     ; inc buffer pointer
  2396 F065 E0 84		                CPX     #$84            ; <01> <FE> <128 bytes> <CRCH> <CRCL>
  2397 F067 D0 EF		                BNE     GetBlk          ; get 132 characters
  2398 F069 A2 00		                LDX     #$00
  2399 F06B BD 00 15		                LDA     RBUFF,x         ; get block # from buffer
  2400 F06E C5 E2		                CMP     BLKNO           ; compare to expected block #
  2401 F070 F0 06		                BEQ     GoodBlk1        ; matched!
  2402 F072 20 41 F2		                jsr     PrintXErr       ; Unexpected block number - abort
  2403 F075 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2404 F078 49 FF		GoodBlk1        EOR     #$FF            ; 1's comp of block #
  2405 F07A E8			                INX                     ;
  2406 F07B DD 00 15		                CMP     RBUFF,x         ; compare with expected 1's comp of block #
  2407 F07E F0 06		                BEQ     GoodBlk2        ; matched!
  2408 F080 20 41 F2		                JSR     PrintXErr       ; Unexpected block number - abort
  2409 F083 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2410 F086 20 19 F2		GoodBlk2        JSR     CalcCRC         ; calc CRC
  2411 F089 B9 00 15		                LDA     RBUFF,y         ; get hi CRC from buffer
  2412 F08C C5 DD		                CMP     CRCH            ; compare to calculated hi CRC
  2413 F08E D0 08		                BNE     BadCRC          ; bad crc, send NAK
  2414 F090 C8			                INY                     ;
  2415 F091 B9 00 15		                LDA     RBUFF,y         ; get lo CRC from buffer
  2416 F094 C5 DC		                CMP     CRCL            ; compare to calculated lo CRC
  2417 F096 F0 0B		                BEQ     GoodCRC         ; good CRC
  2418 F098 20 0F F2		BadCRC          JSR     Flush           ; flush the input port
  2419 F09B A9 15		                LDA     #NAK            ;
  2420 F09D 20 65 F3		                JSR     SOUT            ; send NAK to resend block
  2421 F0A0 4C 37 F0		                JMP     StartBlk        ; start over, get the block again
  2422 F0A3 A2 02		GoodCRC         LDX     #$02            ;
  2423 F0A5 A5 E2		                LDA     BLKNO           ; get the block number
  2424 F0A7 C9 01		                CMP     #$01            ; 1st block?
  2425 F0A9 D0 21		                BNE     CopyBlk         ; no, copy all 128 bytes
  2426 F0AB A5 E1		                LDA     BFLAG           ; is it really block 1, not block 257, 513 etc.
  2427 F0AD F0 1D		                BEQ     CopyBlk         ; no, copy all 128 bytes
  2428 F0AF A5 FF				LDA     MODE		; address mode = 0?
  2429 F0B1 F0 03				BEQ	READADR         ; yes, read start address from data stream
  2430 F0B3 E8			                INX
  2431 F0B4 D0 0B				BNE     READDATA	; branch always
  2432 F0B6 BD 00 15		READADR         LDA     RBUFF,x         ; get target address from 1st 2 bytes of blk 1
  2433 F0B9 85 FA				STA     ADRL            ; save lo address
  2434 F0BB E8			                INX
  2435 F0BC BD 00 15		                LDA     RBUFF,x         ; get hi address
  2436 F0BF 85 FB		                STA     ADRH            ; save it
  2437 F0C1 A5 FA		READDATA        LDA	ADRL
  2438 F0C3 85 E8				STA	STOL		; save start address low byte
  2439 F0C5 A5 FB				LDA	ADRH
  2440 F0C7 85 E9				STA	STOH		; save start address high byte
  2441 F0C9 E8					INX                     ; point to first byte of data
  2442 F0CA C6 E1		                DEC     BFLAG           ; set the flag so we won't get another address
  2443 F0CC A0 00		CopyBlk         LDY     #$00            ; set offset to zero
  2444 F0CE A5 E0		CopyBlk3        LDA     BLKEND		; block end flag set?
  2445 F0D0 D0 14				BNE     CopyBlk5	; yes, skip reading data
  2446 F0D2 BD 00 15				LDA     RBUFF,x         ; get data byte from buffer
  2447 F0D5 91 E8				STA     (STOL),y        ; save to target
  2448 F0D7 38					SEC
  2449 F0D8 A5 F8		                LDA     NUML
  2450 F0DA E5 E8		                SBC     STOL            ; are we at the last address?
  2451 F0DC D0 08		                BNE     CopyBlk5  	; no, inc pointer and continue
  2452 F0DE A5 F9		                LDA     NUMH
  2453 F0E0 E5 E9		                SBC     STOH
  2454 F0E2 D0 02		                BNE     CopyBlk5
  2455 F0E4 E6 E0		                INC     BLKEND		; yes, set last byte flag
  2456 F0E6 E6 E8		CopyBlk5	INC     STOL            ; point to next address
  2457 F0E8 D0 02		                BNE     CopyBlk4        ; did it step over page boundary?
  2458 F0EA E6 E9		                INC     STOH            ; adjust high address for page crossing
  2459 F0EC E8			CopyBlk4        INX                     ; point to next data byte
  2460 F0ED E0 82		                CPX     #$82            ; is it the last byte
  2461 F0EF D0 DD		                BNE     CopyBlk3        ; no, get the next one
  2462 F0F1 E6 E2		IncBlk          INC     BLKNO           ; done.  Inc the block #
  2463 F0F3 A9 06		                LDA     #ACK            ; send ACK
  2464 F0F5 20 65 F3		                JSR     SOUT
  2465 F0F8 4C 37 F0		                JMP     StartBlk        ; get next block
  2466 F0FB A9 06		RDone           LDA     #ACK            ; last block, send ACK and exit.
  2467 F0FD 20 65 F3		                JSR     SOUT
  2468 F100 20 0F F2		                JSR     Flush           ; get leftover characters, if any
  2469 F103 4C 49 F2		                JMP     PrintXSucc
  2470
  2471 				; XMODEM Send Routine **********************************************************
  2472
  2473 F106 20 39 F2		XModemSnd       JSR     PrintXStart
  2474 F109 85 E3				STA     ERRCNT          ; error counter set to 0
  2475 F10B 85 E0				STA     BLKEND          ; set flag to false
  2476 F10D A9 01				LDA     #$01
  2477 F10F 85 E2		                STA     BLKNO           ; set block # to 1
  2478 F111 A9 FF		Wait4CRC        LDA     #$FF            ; 3 seconds
  2479 F113 85 DF		                STA     RETRYH
  2480 F115 20 E2 F1		                JSR     GetByte
  2481 F118 90 F7		                BCC     Wait4CRC        ; wait for something to come in...
  2482 F11A C9 43		                CMP     #'C'            ; is it the "C" to start a CRC xfer?
  2483 F11C F0 0B		                BEQ     SetStoAddr      ; yes
  2484 F11E C9 1B		                CMP     #ESC            ; is it a cancel? <Esc> Key
  2485 F120 F0 04		                BEQ     DoCancel        ; No, wait for another character
  2486 F122 C9 18				CMP     #CAN            ; is it a cancel?
  2487 F124 D0 EB		                BNE     Wait4CRC        ; No, wait for another character
  2488 F126 4C C6 F1		DoCancel        JMP     PrtAbort        ; Print abort msg and exit
  2489 F129 A9 01		SetStoAddr	LDA     #$01            ; manually load blk number
  2490 F12B 8D 00 15		                STA     RBUFF           ; into 1st byte
  2491 F12E A9 FE		                LDA     #$FE            ; load 1's comp of block #
  2492 F130 8D 01 15		                STA     RBUFF+1         ; into 2nd byte
  2493 F133 A5 FA		                LDA     ADRL            ; load low byte of start address
  2494 F135 8D 02 15		                STA     RBUFF+2         ; into 3rd byte
  2495 F138 A5 FB		                LDA     ADRH            ; load hi byte of start address
  2496 F13A 8D 03 15		                STA     RBUFF+3         ; into 4th byte
  2497 F13D A2 04				LDX     #$04            ; preload X to receive buffer
  2498 F13F A0 00				LDY     #$00            ; init data block offset to 0
  2499 F141 F0 17		                BEQ     LdBuff1         ; jump into buffer load routine
  2500 F143 A5 E0		LdBuffer        LDA     BLKEND          ; was the last block sent?
  2501 F145 F0 03		                BEQ     LdBuff0         ; no, send the next one
  2502 F147 4C CC F1		                JMP     SDone           ; yes, we're done
  2503 F14A A2 02		LdBuff0         LDX     #$02            ; init pointers
  2504 F14C A0 00		                LDY     #$00
  2505 F14E E6 E2		                INC     BLKNO           ; inc block counter
  2506 F150 A5 E2		                LDA     BLKNO
  2507 F152 8D 00 15		                STA     RBUFF           ; save in 1st byte of buffer
  2508 F155 49 FF		                EOR     #$FF
  2509 F157 8D 01 15		                STA     RBUFF+1         ; save 1's comp of blkno next
  2510 F15A B1 FA		LdBuff1         LDA     (ADRL),y        ; save 128 bytes of data
  2511 F15C 9D 00 15		                STA     RBUFF,x
  2512 F15F 38			LdBuff2         SEC
  2513 F160 A5 F8		                LDA     NUML
  2514 F162 E5 FA		                SBC     ADRL            ; are we at the last address?
  2515 F164 D0 14		                BNE     LdBuff4         ; no, inc pointer and continue
  2516 F166 A5 F9		                LDA     NUMH
  2517 F168 E5 FB		                SBC     ADRH
  2518 F16A D0 0E		                BNE     LdBuff4
  2519 F16C E6 E0		                INC     BLKEND          ; yes, set last byte flag
  2520 F16E E8			LdBuff3         INX
  2521 F16F E0 82		                CPX     #$82            ; are we at the end of the 128 byte block?
  2522 F171 F0 12		                BEQ     SCalcCRC        ; yes, calc CRC
  2523 F173 A9 00		                LDA     #$00            ; fill rest of 128 bytes with $00
  2524 F175 9D 00 15		                STA     RBUFF,x
  2525 F178 F0 F4		                BEQ     LdBuff3         ; branch always
  2526 F17A E6 FA		LdBuff4         INC     ADRL            ; inc address pointer
  2527 F17C D0 02		                BNE     LdBuff5
  2528 F17E E6 FB		                INC     ADRH
  2529 F180 E8			LdBuff5         INX
  2530 F181 E0 82		                CPX     #$82            ; last byte in block?
  2531 F183 D0 D5		                BNE     LdBuff1         ; no, get the next
  2532 F185 20 19 F2		SCalcCRC        JSR     CalcCRC
  2533 F188 A5 DD		                LDA     CRCH            ; save hi byte of CRC to buffer
  2534 F18A 99 00 15		                STA     RBUFF,y
  2535 F18D C8			                INY
  2536 F18E A5 DC		                LDA     CRCL            ; save lo byte of CRC to buffer
  2537 F190 99 00 15		                STA     RBUFF,y
  2538 F193 A2 00		Resend          LDX     #$00
  2539 F195 A9 01		                LDA     #SOH
  2540 F197 20 65 F3		                JSR     SOUT            ; send SOH
  2541 F19A BD 00 15		SendBlk         LDA     RBUFF,x         ; send 132 bytes in buffer to the console
  2542 F19D 20 65 F3		                JSR     SOUT
  2543 F1A0 E8			                INX
  2544 F1A1 E0 84		                CPX     #$84            ; last byte?
  2545 F1A3 D0 F5		                BNE     SendBlk         ; no, get next
  2546 F1A5 A9 FF		                LDA     #$FF            ; yes, set 3 second delay
  2547 F1A7 85 DF		                STA     RETRYH          ; and
  2548 F1A9 20 E2 F1		                JSR     GetByte         ; wait for ACK/NACK
  2549 F1AC 90 10		                BCC     SetError        ; no char received after 3 seconds, resend
  2550 F1AE C9 06		                CMP     #ACK            ; char received... is it:
  2551 F1B0 F0 91		                BEQ     LdBuffer        ; ACK, send next block
  2552 F1B2 C9 15		                CMP     #NAK
  2553 F1B4 F0 08		                BEQ     SetError        ; NAK, inc errors and resend
  2554 F1B6 C9 1B		                CMP     #ESC
  2555 F1B8 F0 0C		                BEQ     PrtAbort        ; ESC pressed to abort
  2556 F1BA C9 18				CMP	#CAN
  2557 F1BC F0 08				BEQ     PrtAbort	; CANCEL send
  2558 									; fall through to error counter
  2559 F1BE E6 E3		SetError        INC     ERRCNT          ; inc error counter
  2560 F1C0 A5 E3		                LDA     ERRCNT
  2561 F1C2 C9 0A		                CMP     #$0A            ; are there 10 errors? (Xmodem spec for failure)
  2562 F1C4 D0 CD		                BNE     Resend          ; no, resend block
  2563
  2564 F1C6 20 0F F2		PrtAbort        JSR     Flush           ; yes, too many errors, flush buffer,
  2565 F1C9 4C 41 F2		                JMP     PrintXErr       ; print error msg and exit
  2566 F1CC 4C 49 F2		SDone           JMP     PrintXSucc   	; All Done..Print msg and exit
  2567
  2568 				; Get Data From Serial Port ****************************************************
  2569
  2570 F1CF A9 00		GetData		LDA     #$00            ; wait for chr input and cycle timing loop
  2571 F1D1 85 DE		                STA     RETRYL          ; set low value of timing loop
  2572 F1D3 20 75 F3		LoopGetData     JSR     SIN        	; get chr from serial port, don't wait
  2573 F1D6 B0 09		                BCS     EndGetData      ; got one, so exit
  2574 F1D8 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2575 F1DA D0 F7		                BNE     LoopGetData
  2576 F1DC C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2577 F1DE D0 F3		                BNE     LoopGetData     ; look for character again
  2578 F1E0 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2579 F1E1 60			EndGetData      RTS                     ; with character in A
  2580
  2581 				; Get Byte From Serial Port. Check if ESC pressed ******************************
  2582
  2583 F1E2 A9 00		GetByte		LDA     #$00            ; wait for chr input and cycle timing loop
  2584 F1E4 85 DE		                STA     RETRYL          ; set low value of timing loop
  2585 F1E6 A9 75		LoopGetByte     LDA     #< SIN        ; check low byte of serial in address
  2586 F1E8 CD 6E 1A				CMP	STDIN	        ; is Low(stdin) = Low(SIN)?
  2587 F1EB D0 07		                BNE     GetChar         ; no, use standard Get Char Routine
  2588 F1ED A9 F3		                LDA     #> SIN       ; yes, check high byte of serial in address
  2589 F1EF CD 6F 1A		                CMP     STDIN+1         ; is High(stdin) = High(SIN)?
  2590 F1F2 F0 0C		                BEQ	ReadByte	; yes, just read input stream
  2591 F1F4 20 4D E0		GetChar		JSR	CGET
  2592 F1F7 90 07				BCC	ReadByte
  2593 F1F9 C9 1B				CMP	#ESC
  2594 F1FB D0 03				BNE	ReadByte
  2595 F1FD 38					SEC
  2596 F1FE B0 0E				BCS	EndGetByte
  2597 				;		JSR	CHKESC		; no, check stdin if ESC key pressed
  2598 				;		BCC	ReadByte	; no ESC pressed, read data byte from serial port
  2599 				;		LDA	#ESC
  2600 				;		BNE     EndGetByte      ; ESC pressed, so exit
  2601 F200 20 75 F3		ReadByte	JSR     SIN        	; get chr from serial port, don't wait
  2602 F203 B0 09		                BCS     EndGetByte      ; got one, so exit
  2603 F205 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2604 F207 D0 DD		                BNE     LoopGetByte
  2605 F209 C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2606 F20B D0 D9		                BNE     LoopGetByte     ; look for character again
  2607 F20D 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2608 F20E 60			EndGetByte      RTS                     ; with character in A
  2609
  2610 				; Empty Buffer *****************************************************************
  2611
  2612 F20F A9 1C		Flush           LDA     #$1C            ; flush receive buffer
  2613 F211 85 DF		                STA     RETRYH          ; flush until empty for ~1/4 sec.
  2614 F213 20 CF F1		Flush1          JSR     GetData         ; read the port
  2615 F216 B0 F7		                BCS     Flush           ; if char received, wait for another
  2616 F218 60			                RTS
  2617
  2618 				; Calculate CRC ****************************************************************
  2619
  2620 F219 A9 00		CalcCRC		LDA	#$00		; calculate the CRC for the 128 bytes
  2621 F21B 85 DC				STA	CRCL
  2622 F21D 85 DD				STA	CRCH
  2623 F21F A0 02				LDY	#$02
  2624 F221 B9 00 15		CalcCRC1	LDA	RBUFF,y
  2625 F224 45 DD				EOR 	CRCH 		; Quick CRC computation with lookup tables
  2626 F226 AA			       		TAX		 	; updates the two bytes at crc & crc+1
  2627 F227 A5 DC		       		LDA 	CRCL		; with the byte send in the "A" register
  2628 F229 5D 00 FB		       		EOR 	CRCHI,x
  2629 F22C 85 DD		       		STA 	CRCH
  2630 F22E BD 00 FA		      	 	LDA 	CRCLO,x
  2631 F231 85 DC		       		STA 	CRCL
  2632 F233 C8					INY
  2633 F234 C0 82				CPY	#$82		; done yet?
  2634 F236 D0 E9				BNE	CalcCRC1	; no, get next
  2635 F238 60					RTS			; y=82 on exit
  2636
  2637 				; Print XModem Messages ********************************************************
  2638
  2639 F239 78			PrintXStart     SEI			; disable interrupts during XModem transfer
  2640 F23A 20 0F F2				JSR	Flush		; clear buffer
  2641 F23D A0 00				LDY     #$00		; load start message
  2642 F23F F0 0C				BEQ	PrintXMsg
  2643
  2644 F241 20 67 E1		PrintXErr       JSR	BEEP
  2645 F244 A0 28		PrintXError	LDY     #(ERRX-MSGX)	; load error message
  2646 F246 18					CLC
  2647 F247 D0 03				BNE     PrintXEnd
  2648
  2649 F249 A0 39		PrintXSucc      LDY     #(SUCCX-MSGX)	; load success message
  2650 F24B 38					SEC
  2651 F24C 58			PrintXEnd	CLI			; enable interrupts
  2652
  2653 F24D A9 00		PrintXMsg	LDA     #$00
  2654 F24F 2A					ROL			; save carry
  2655 F250 48					PHA
  2656 F251 B9 5F F2		PrintXMsg1	LDA  	MSGX,Y   	; load char at string pos y
  2657 F254 F0 06				BEQ  	EndXMsg  	; exit, if NULL char
  2658 F256 20 52 E0				JSR  	COUT       	; write character
  2659 F259 C8					INY             	; next index
  2660 F25A D0 F5				BNE  	PrintXMsg1
  2661 F25C 68			EndXMsg		PLA
  2662 F25D 4A					LSR			; restore carry and leave A = 0
  2663 F25E 60					RTS
  2664
  2665 				; ******************************************************************************
  2666 				; String Data Section
  2667 				; ******************************************************************************
  2668 F25F 0D 42 65 67 69 6E + MSGX            .by     CR 'Begin data transfer, <ESC> to cancel. ' $00
  2669 F287 0D 54 72 61 6E 73 + ERRX		.by	CR 'Transfer Error' CR $00
  2670 F298 04 04 04		SUCCX           .byte	EOT,EOT,EOT
  2671 F29B 0D 4F 4B 0D 00	MSG_OK		.by	CR 'OK' CR $00
  2672 									; Tape Messages removed 25-07-'25 Emile
  2673 F2A0					ORG	*+120		; maintain compatibility with v1.1.4
  2674 						
  2675 				; **** IRQ, NMI and BREAK Service Routines *************************************
  2676
  2677 				; ******************************************************************************
  2678
  2679 F318 8D 77 1A		IRQ		STA	STOACC		; save current accumulator
  2680 F31B 68					PLA			; get current processor status in A
  2681 F31C 48					PHA			; and push it back to stack
  2682 F31D 29 10				AND	#$10		; mask break flag
  2683 F31F D0 06				BNE	USRBREAK	; if break flag set, jump to user break handler
  2684 F321 AD 77 1A				LDA	STOACC
  2685 F324 6C 7C 1A				JMP	(IRQUSR)	; else jump to clock IRQ routine
  2686
  2687 F327 AD 77 1A		USRBREAK	LDA	STOACC
  2688 F32A 6C 78 1A				JMP	(BRKUSR)
  2689
  2690 F32D 85 F3		NMI		STA	ACC		; save current accumulator
  2691
  2692 F32F			BREAK					; default IRQUSR & BRKUSR entry
  2693 F32F 68					PLA			; get current processor status in A
  2694 F330 85 F1				STA	PREG		; save it
  2695 F332 48					PHA			; and push it back to stack
  2696 F333 86 F5				STX	XREG		; save x-register
  2697 F335 84 F4				STY	YREG		; save y-register
  2698 F337 20 AD E1				JSR	RESET_STDIO	; always reset to standard I/O
  2699 F33A 28					PLP			; get last processor status
  2700 F33B 68					PLA			; get last program counter low byte
  2701 F33C 85 EF				STA	PCL		; and store it
  2702 F33E 85 FA				STA	ADRL
  2703 F340 68					PLA			; get last program counter high byte
  2704 F341 85 F0				STA	PCH		; and store it
  2705 F343 85 FB				STA	ADRH
  2706 F345 BA					TSX			; get current stack pointer
  2707 F346 86 F2				STX	SPUSER		; and store it
  2708 F348 D8					CLD			; set binary mode
  2709 F349 20 67 E1				JSR	BEEP		; error beep
  2710 F34C 20 4E EC				JSR	PRSTATUS	; print user program status
  2711 F34F A2 FF				LDX     #$FF
  2712 F351 9A					TXS			; initialize stack pointer
  2713 F352 58					CLI			; enable interrupts
  2714 F353 4C 3B E6				JMP	MONRESET	; and return to monitor
  2715
  2716 									; GETMAGIC removed 25-07-'25 Emile
  2717 F356					ORG	*+15		; maintain compatibility with v1.1.4
  2718
  2719 				; **** Write To Serial Routine *************************************************
  2720
  2721 				; Input: A - Output Byte to RS232
  2722
  2723 				; ******************************************************************************
  2724
  2725 F365			SOUT
  2726 F365 08			SERIALOUT	PHP			; save processor status
  2727 F366 78					SEI			; disable interrupts
  2728 F367 48					PHA			; save character
  2729 F368 A9 10				LDA  	#$10
  2730 F36A 2C 01 16		EMPTY?		BIT  	STAT_REG	; ACIA output register empty?
  2731 F36D F0 FB				BEQ  	EMPTY?		; no, check again.
  2732 F36F 68					PLA			; restore character
  2733 F370 8D 00 16				STA  	DATA_REG   	; write character to ACIA
  2734 F373 28					PLP			; restore processor status
  2735 F374 60					RTS
  2736
  2737 				; **** Read From Serial Routine ************************************************
  2738
  2739 				; Output: A - Input Byte from RS232
  2740 				;         C - 1 char get, 0 no char get
  2741
  2742 				; ******************************************************************************
  2743
  2744 F375			SIN
  2745 F375 18			SERIALIN	CLC              	; set to no chr present
  2746 F376 AD 01 16				LDA	STAT_REG
  2747 F379 29 08				AND	#$08		; ACIA input register full?
  2748 F37B F0 04				BEQ	SERIALEND	; no, just exit
  2749 F37D AD 00 16				LDA	DATA_REG	; yes, read character
  2750 F380 38					SEC		 	; and set C = 1, char present
  2751 F381 60			SERIALEND	RTS
  2752
  2753 				; **** Read From ASCII Keyboard Routine ****************************************
  2754
  2755 				; Output: A - Input Byte from Keyboard
  2756 				;         C - 1 char get, 0 no char get
  2757
  2758 				; ******************************************************************************
  2759
  2760 F382 AD 81 1A		ASCIIKBD	LDA	PADD		; are we in read mode?
  2761 F385 F0 03				BEQ	READMODE	; yes, check if data available
  2762 F387 20 10 F4				JSR	SETPPORTIN	; no, first set parallel port as an input
  2763 F38A 18			READMODE	CLC			; set to no char present
  2764 F38B 2C 85 1A				BIT	WRDC		; test PA7 (DATA_AVAIL)
  2765 F38E 50 09				BVC	NODATA		; no new data, just exit with C = 0
  2766 F390 AD 85 1A				LDA	WRDC		; clear PA7 flag
  2767 F393 AD 80 1A				LDA	PAD		; load keyboard ASCII code from port A
  2768 F396 29 7F				AND	#%01111111	; clear MSB
  2769 F398 38			DATA_AVAIL	SEC			; and set C = 1, char present
  2770 F399 60			NODATA		RTS
  2771
  2772 				; **** PS2 Keyboard Driver Routine *********************************************
  2773
  2774 				; Output: A - Input Byte from Keyboard
  2775 				;         C - 1 char get, 0 no char get
  2776
  2777 				; ******************************************************************************
  2778
  2779 F39A 18			PS2KBD          CLC                     ; set to no char present
  2780 F39B 84 F1		                STY     PREG            ; save current Y register
  2781 F39D A0 0E		                LDY     #PIA_PORTC
  2782 F39F B1 16		                LDA     (FGCBASE),Y     ; load data from Port C
  2783 F3A1 29 20		                AND     #$20            ; and check Strobe line
  2784 F3A3 F0 15		                BEQ     PS2_NODATA      ; no data received, just exit with C = 0
  2785 F3A5 A0 0C		                LDY     #PIA_PORTA
  2786 F3A7 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  2787 F3A9 D0 0E		                BNE     PS2_DATA_AVAIL
  2788 F3AB A0 0E		                LDY     #PIA_PORTC      ; NULL Byte received, check for second byte
  2789 F3AD B1 16		PS2_CHECK       LDA     (FGCBASE),Y     ; load data from Port C
  2790 F3AF 29 20		                AND     #$20            ; and check Strobe line
  2791 F3B1 F0 FA		                BEQ     PS2_CHECK       ; no data received, repeat
  2792 F3B3 A0 0C		                LDY     #PIA_PORTA
  2793 F3B5 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  2794 F3B7 09 80		                ORA     #$80            ; set bit 7
  2795 F3B9 38			PS2_DATA_AVAIL  SEC			; and set C = 1, char present
  2796 F3BA A4 F1		PS2_NODATA      LDY     PREG            ; restore Y register
  2797 F3BC 60			                RTS
  2798
  2799 				; **** Detect ASCII Keyboard Routine *******************************************
  2800
  2801 				; ******************************************************************************
  2802
  2803 F3BD 20 10 F4		DETECT_ASCIIKBD JSR	SETPPORTIN	; set parallel port as an input
  2804 F3C0 AD 80 1A				LDA	PAD		; read parallel port
  2805 F3C3 C9 FF				CMP	#$FF		; is there anything connected?
  2806 F3C5 F0 0A				BEQ	NOKBD		; no, just exit
  2807 F3C7 A2 98		                LDX     #<  KEYBD_DEV
  2808 F3C9 A0 F9		                LDY     #> KEYBD_DEV
  2809 F3CB 20 6F F7		                JSR     DEV_ADD         ; add ASCII keyboard driver
  2810 F3CE 8D 74 1A				STA	STDINDEV	; make it the standard input device
  2811 F3D1 60			NOKBD		RTS
  2812
  2813 				; **** Write To Parallel Port Routine ******************************************
  2814
  2815 				; Input: A - Output Byte to parallel port
  2816
  2817 				; ******************************************************************************
  2818
  2819 F3D2 48			PPORTOUT	PHA			; save character
  2820 F3D3 A9 BE				LDA	#$BE		; initialize handshake line I/O on port b
  2821 F3D5 CD 83 1A				CMP	PBDD		; already initialized?
  2822 F3D8 F0 03				BEQ	SETHSK		; yes, just set output values
  2823 F3DA 8D 83 1A				STA	PBDD		; no, PB7 = /strobe, PB6 = busy, PB5 = r/w, PB0 = speaker off
  2824 F3DD A9 86		SETHSK		LDA	#$86		; set handshake lines to their initial values
  2825 F3DF 8D 82 1A				STA	PBD		; r/w = L, strobe = H, PB1,PB2 = H -> hex-kbd disabled; speaker = H
  2826 F3E2 A9 FF				LDA	#$FF		; all port A lines are outputs
  2827 F3E4 8D 81 1A				STA	PADD
  2828 F3E7 68					PLA			; reload character in A
  2829 F3E8 48					PHA
  2830 F3E9 8D 80 1A				STA	PAD		; set output data
  2831 F3EC 2C 82 1A		PPORTBSY?	BIT	PBD		; bussy line is high?
  2832 F3EF 70 FB				BVS	PPORTBSY?	; yes, check bussy line again
  2833 F3F1 A9 06				LDA	#$06		; generate strobe pulse
  2834 F3F3 8D 82 1A				STA	PBD		; set strobe line low
  2835 F3F6 A9 86				LDA	#$86
  2836 F3F8 8D 82 1A				STA	PBD		; set strobe line high
  2837 F3FB 68					PLA			; restore character
  2838 F3FC 60					RTS
  2839
  2840 				; **** Read From Parallel Port Routine *****************************************
  2841
  2842 				; Output: A - Input Byte from parallel port
  2843 				;         C - 1 char get, 0 no char get
  2844
  2845 				; ******************************************************************************
  2846
  2847 F3FD 20 10 F4		PPORTIN		JSR	SETPPORTIN	; set parallel port as input
  2848 F400 18					CLC
  2849 F401 2C 82 1A				BIT	PBD		; check if /STROBE = 0
  2850 F404 30 09				BMI	NOSTROBE	; no, just exit with C = 0
  2851 F406 2C 82 1A		STROBE?		BIT	PBD		; yes, wait for strobe to come high again
  2852 F409 30 FB				BMI	STROBE?
  2853 F40B AD 80 1A				LDA	PAD		; load data from port A
  2854 F40E 38					SEC			; and set C = 1, data present
  2855 F40F 60			NOSTROBE	RTS
  2856
  2857 				; **** Switch Parallel Port To Data Input **************************************
  2858
  2859 				; ******************************************************************************
  2860
  2861 F410 A9 00		SETPPORTIN	LDA	#$00		; initialize port A as input
  2862 F412 8D 81 1A				STA	PADD
  2863 F415 A9 3E				LDA	#$3E		; initialize port B bits for read operation
  2864 F417 8D 83 1A				STA	PBDD
  2865 F41A A9 26				LDA	#$26		; set PB5 = H (READ)
  2866 F41C 8D 82 1A				STA	PBD
  2867 F41F 8D 85 1A				STA	WRDC		; set PA7 raising edge detection, no interrupt
  2868 F422 AD 85 1A				LDA	WRDC		; clear interrupt flag
  2869 F425 60					RTS
  2870
  2871 				; ******************************************************************************
  2872 				; SPI Driver
  2873 				; ******************************************************************************
  2874
  2875 				; ******************************************************************************
  2876 				; Initialize SPI Interface
  2877 				; ******************************************************************************
  2878
  2879 F426			SPI_INIT					;fall trough to SPI_SLOW
  2880
  2881 				; ******************************************************************************
  2882 				; Set SPI to Slow Mode (250KHz)
  2883 				; ******************************************************************************
  2884
  2885 F426 A9 04		SPI_SLOW        LDA	#$04
  2886 F428 A0 1B				LDY	#ACR
  2887 F42A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under T2 control"
  2888 F42C A9 00				LDA	#$00			; reset Timer2
  2889 F42E A0 18				LDY	#T2CL
  2890 F430 91 14				STA	(IOBASE),Y		; store timer low value
  2891 F432 20 61 F4				JSR	SPI_RESET		; flush shift register
  2892 F435 60					RTS				; Clock is set to 250 kHz
  2893 						
  2894 				; ******************************************************************************
  2895 				; Set SPI to Fast Mode (500KHz)
  2896 				; ******************************************************************************
  2897
  2898 F436 A9 08		SPI_FAST	LDA	#$08
  2899 F438 A0 1B				LDY	#ACR
  2900 F43A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under phi2 control"
  2901 F43C 60					RTS				; Clock is set to 500 kHz
  2902
  2903 				; ******************************************************************************
  2904 				; Write a Single Byte to the SPI Interface
  2905 				;
  2906 				; Input: A = Byte to Send
  2907 				; ******************************************************************************
  2908
  2909 F43D 84 FD		SPI_WRITE	STY	YSAV
  2910 F43F A0 11				LDY	#PORTA
  2911 F441 91 14				STA	(IOBASE),Y		; output data to shift register
  2912 F443 A0 1D				LDY	#IFR
  2913 F445 A9 04		SPI_WRITE1	LDA	#$04			; set bit mask for data available flag
  2914 F447 31 14				AND	(IOBASE),Y		; shift register full?
  2915 F449 F0 FA				BEQ	SPI_WRITE1		; no, check again
  2916 F44B A0 10				LDY	#PORTB
  2917 F44D A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  2918 F44F 91 14				STA	(IOBASE),Y		; load data into shift register
  2919 F451 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  2920 F453 91 14				STA	(IOBASE),Y		; data is now in shift register
  2921 F455 D0 0A				BNE	SPI_RESET               ; branch always
  2922
  2923 				; ******************************************************************************
  2924 				; Read a Single Byte from the SPI Interface
  2925 				;
  2926 				; Output: A = Received Byte
  2927 				; ******************************************************************************
  2928
  2929 F457 84 FD		SPI_READ	STY	YSAV
  2930 F459 A0 1D				LDY	#IFR
  2931 F45B A9 04		SPI_READ1	LDA	#$04			; set bit mask for data available flag
  2932 F45D 31 14				AND	(IOBASE),Y		; shift register full?
  2933 F45F F0 FA				BEQ	SPI_READ1		; no, check again
  2934 F461 A0 1A		SPI_RESET	LDY	#SR
  2935 F463 B1 14				LDA	(IOBASE),Y		; start next shifting, clear data available flag
  2936 F465 A4 FD				LDY	YSAV
  2937 F467 60					RTS
  2938
  2939 				; ******************************************************************************
  2940 				; SD-Card Driver Routines
  2941 				; ******************************************************************************
  2942
  2943 				; ******************************************************************************
  2944 				; Initialize SD-Card
  2945 				; Output: C = 1 Init OK, C = 0 Error
  2946 				; ******************************************************************************
  2947
  2948 F468 78			SD_INIT		SEI                             ; disable interrupts
  2949 F469 A9 00		                LDA	#$00
  2950 F46B 85 DB				STA	SD_TYPE
  2951 F46D 20 E1 F5				JSR	SD_RESET		; reset SD-Card
  2952 F470 C9 01				CMP	#$01			; SD-Card present?
  2953 F472 D0 57				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2954 F474 20 D0 F4				JSR	SD_GET_VERS		; get SD-Card version
  2955 F477 C9 05				CMP	#$05			; seems to be a version 1 card
  2956 F479 F0 08				BEQ	INIT_SD0		; so just try to initialize it
  2957 F47B C9 AA				CMP	#$AA			; version 2 cards should response with $(01)AA
  2958 F47D D0 4C				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2959 F47F A9 40				LDA	#$40			; try ACMD41($40000000) init (SD Ver. 2+)
  2960 F481 D0 02				BNE	INIT_SD1
  2961 F483 A9 00		INIT_SD0	LDA	#$00			; try ACMD41($00000000) init (SD Ver. 1)
  2962 F485 20 F3 F4		INIT_SD1	JSR	SD_CLEAR_CMD		; prepare for new command
  2963 F488 85 DF				STA	SD_PB3
  2964 F48A A9 77		INIT_SD2	LDA	#CMD55			; send prefix CMD55 (application cmd)
  2965 F48C 20 02 F5				JSR	SD_SEND_CMD
  2966 F48F C9 01				CMP	#$01
  2967 F491 D0 38				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2968 F493 A9 69				LDA	#ACMD41			; send ACMD41 (initialize)
  2969 F495 20 02 F5				JSR	SD_SEND_CMD
  2970 F498 F0 06				BEQ	INIT_SD3		; response = 0 means card waked up,
  2971 F49A C9 01				CMP	#$01			; card still idle?
  2972 F49C F0 EC				BEQ	INIT_SD2		; yes, try again
  2973 F49E D0 2B				BNE	SDC_NOT_FOUND		; no, invalid response, no usable card found
  2974 F4A0 A5 DF		INIT_SD3	LDA	SD_PB3			; Ver. 2+ Card?
  2975 F4A2 F0 13				BEQ	INIT_SD4		; no, just set block size
  2976 F4A4 20 F3 F4				JSR	SD_CLEAR_CMD		; prepare for new command
  2977 F4A7 A9 7A				LDA	#CMD58			; send CMD58 (get OCR)
  2978 F4A9 20 02 F5				JSR	SD_SEND_CMD
  2979 F4AC D0 1D				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2980 F4AE 20 E5 F4				JSR	SD_WAIT_RESP3		; wait for OCR response
  2981 F4B1 A5 DF				LDA	SD_PB3			; Test Bit 30
  2982 F4B3 29 40				AND	#$40			; 1 if SDHC/SDXC card, 0 else
  2983 F4B5 85 DB				STA	SD_TYPE			; set type $00 Byte mode, $40 LBA mode
  2984 F4B7 20 F3 F4		INIT_SD4	JSR	SD_CLEAR_CMD		; prepare for new command
  2985 F4BA A9 02				LDA	#$02			; set blocksize to 512 byte
  2986 F4BC 85 E1				STA	SD_PB1
  2987 F4BE A9 50				LDA	#CMD16			; send CMD16 (set block size)
  2988 F4C0 20 02 F5				JSR	SD_SEND_CMD
  2989 F4C3 D0 06				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2990 F4C5 20 36 F4				JSR	SPI_FAST		; and switch to SPI fast mode (500kHz)
  2991 F4C8 58					CLI                             ; reenable interrupts
  2992 F4C9 38					SEC				; everything gone well, set carry
  2993 F4CA 60					RTS
  2994 F4CB A9 80		SDC_NOT_FOUND	LDA	#$80
  2995 F4CD 58			                CLI                             ; reenable interrupts
  2996 F4CE 18					CLC				; something went wrong, clear carry
  2997 F4CF 60					RTS				; to signal error
  2998
  2999 				; ******************************************************************************
  3000 				; Get SD-Card Version
  3001 				; ******************************************************************************
  3002
  3003 F4D0 A9 01		SD_GET_VERS	LDA	#$01			; set parameter byte 1
  3004 F4D2 85 E1				STA	SD_PB1
  3005 F4D4 A9 AA				LDA	#$AA			; set parameter byte 0
  3006 F4D6 85 E2				STA	SD_PB0
  3007 F4D8 A9 87				LDA	#$87			; set crc
  3008 F4DA 85 E3				STA	SD_CRC
  3009 F4DC A9 48				LDA	#CMD8			; send CMD8($000001AA) (get version)
  3010 F4DE 20 02 F5				JSR	SD_SEND_CMD		; response should be $01
  3011 F4E1 C9 01				CMP	#$01			; SD-Card present?
  3012 F4E3 D0 0D				BNE	END_GET_VERS		; no, exit with result <> $01
  3013 										; yes, fall through to sd_wait_resp
  3014
  3015 				; ******************************************************************************
  3016 				; Wait for a 32 Bit Command R3 Response from SD-Card
  3017 				; ******************************************************************************
  3018
  3019 F4E5 A0 00		SD_WAIT_RESP3	LDY	#$00
  3020 F4E7 20 13 F5		READ_RESP3	JSR	SD_WAIT_RESP		; yes, receive 4 response bytes
  3021 F4EA 99 DF 00				STA	SD_PB3,Y		; store response bytes in PB0..3
  3022 F4ED C8					INY
  3023 F4EE C0 04				CPY	#$04
  3024 F4F0 D0 F5				BNE	READ_RESP3
  3025 F4F2 60			END_GET_VERS	RTS
  3026
  3027 				; ******************************************************************************
  3028 				; Clear SD-Card Command Parameters
  3029 				; ******************************************************************************
  3030
  3031 F4F3 A9 00		SD_CLEAR_CMD	LDA	#$00
  3032 F4F5 A0 04				LDY	#$04			; 4 parameter bytes to clear
  3033 F4F7 99 DE 00		NEXT_PARAM	STA	SD_CMD,Y		; clear parameter byte
  3034 F4FA 88					DEY
  3035 F4FB D0 FA				BNE	NEXT_PARAM		; more to clear?
  3036 F4FD A9 FF				LDA	#$FF
  3037 F4FF 85 E3				STA	SD_CRC			; no, finally set CRC byte to $FF
  3038 F501 60					RTS
  3039
  3040 				; ******************************************************************************
  3041 				; Send Command to SD-Card
  3042 				; Input: A = Command Index
  3043 				; ******************************************************************************
  3044
  3045 F502 85 DE		SD_SEND_CMD	STA	SD_CMD
  3046 F504 20 57 F4				JSR	SPI_READ		; send one dummy
  3047 F507 A2 00				LDX	#$00
  3048 F509 B5 DE		SEND_BYTE	LDA	SD_CMD,X		; get one command byte
  3049 F50B 20 3D F4				JSR	SPI_WRITE		; and send it
  3050 F50E E8					INX
  3051 F50F E0 06				CPX	#$06			; all 6 cmd bytes send?
  3052 F511 D0 F6				BNE	SEND_BYTE		; no, send more bytes
  3053 										; yes, fall through to sd_wait_resp
  3054
  3055 				; ******************************************************************************
  3056 				; Wait for a 8 Bit Command R1 Response from SD-Card
  3057 				; Output: A = Response Byte
  3058 				; ******************************************************************************
  3059
  3060 F513 A2 08		SD_WAIT_RESP	LDX	#$08			; wait for max 8 cycles
  3061 F515 20 57 F4		READ_RESP1	JSR	SPI_READ		; receive data
  3062 F518 C9 FF				CMP	#$FF			; is it a $FF?
  3063 F51A D0 03				BNE	RESPONSE		; no, card did response
  3064 F51C CA					DEX				; yes, try again
  3065 F51D D0 F6				BNE	READ_RESP1		; check for timeout
  3066 F51F AA			RESPONSE	TAX
  3067 F520 8A					TXA				; set proper status flags for A
  3068 F521 60					RTS
  3069
  3070 				; ******************************************************************************
  3071 				; Wait for a Special Token Response from SD-Card
  3072 				; Input:  A = Token Byte
  3073 				; Output: A = Response Byte
  3074 				; ******************************************************************************
  3075
  3076 F522 85 FC		SD_WAIT_TOKEN	STA	TEMP			; store token into TEMP variable
  3077 F524 A0 FF				LDY	#$FF			; load low byte of time out counter
  3078 F526 A2 0A				LDX	#$0A			; load high byte of time out counter
  3079 F528 20 57 F4		WAIT_RESP	JSR	SPI_READ		; read byte from SPI
  3080 F52B 88					DEY				; decrement wait counter
  3081 F52C D0 03				BNE	WAIT_RESP0
  3082 F52E CA					DEX
  3083 F52F F0 04				BEQ	WAIT_RESP_END		; wait counter is 0 -> time out
  3084 F531 C5 FC		WAIT_RESP0	CMP	TEMP			; did we read the token we are waiting for?
  3085 F533 D0 F3				BNE	WAIT_RESP		; no, read next byte
  3086 F535 60			WAIT_RESP_END	RTS
  3087
  3088 				; ******************************************************************************
  3089 				; Read Single Data Block to Std. Block Buffer
  3090 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3091 				; Output: C = 0 Error, C = 1 Read OK
  3092 				;	  A = Error Code
  3093 				; ******************************************************************************
  3094
  3095 F536 20 8B F6		SD_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3096 F539 F0 06				BEQ	SD_RD_BLK
  3097
  3098 				; ******************************************************************************
  3099 				; Read Single Data Block from Logical Address to Std. Block Buffer
  3100 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3101 				; Output: C = 0 Error, C = 1 Data OK
  3102 				;	  A = Error Code
  3103 				; ******************************************************************************
  3104
  3105 F53B 20 8B F6		SD_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3106 										; fall through to sd_rd_lblk
  3107
  3108 				; ******************************************************************************
  3109 				; Read Single Data Block from Logical Address
  3110 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3111 				;	  BLKBUF,BLKBUFH = 16 Bit Destination Address
  3112 				; Output: C = 0 Error, C = 1 Data OK
  3113 				;	  A = Error Code
  3114 				; ******************************************************************************
  3115
  3116 F53E 20 94 F6		SD_RD_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3117 										; fall through to sd_rd_blk
  3118
  3119 				; ******************************************************************************
  3120 				; Read Single Data Block
  3121 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3122 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
  3123 				; Output: C = 0 Error, C = 1 Read OK
  3124 				;	  A = Error Code
  3125 				; ******************************************************************************
  3126
  3127 F541 A9 51		SD_RD_BLK	LDA	#CMD17			; send CMD17 (blk read)
  3128 F543 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3129 F546 20 22 F5				JSR	SD_WAIT_TOKEN		; wait for data token $FE
  3130 F549 C9 FE				CMP	#$FE			; is card ready for block read?
  3131 F54B 18					CLC
  3132 F54C D0 1F				BNE	SD_RD_END		; did not receive data token, exit with C = 0
  3133 F54E A2 01				LDX	#$01			; initialize page counter
  3134 F550 A0 00				LDY	#$00			; initialize byte counter
  3135 F552 84 FD		SD_RD_BLK0	STY	YSAV			; read a byte
  3136 F554 A0 1A				LDY 	#SR
  3137 F556 B1 14				LDA	(IOBASE),Y
  3138 F558 A4 FD				LDY	YSAV
  3139 F55A 91 DC				STA	(BLKBUF),Y		; and store it into the block buffer
  3140 F55C C8					INY				; increment destination pointer
  3141 F55D D0 F3				BNE	SD_RD_BLK0		; pointer overflow? No, read next byte
  3142 F55F E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3143 F561 CA					DEX
  3144 F562 10 EE				BPL	SD_RD_BLK0		; two pages read? no, read next byte
  3145 F564 20 57 F4		SD_RD_BLK1	JSR	SPI_READ		; yes, read 3 more bytes (CRC H, CRC L, dummy)
  3146 F567 C8					INY
  3147 F568 C0 03				CPY	#$03			; all 3 bytes read?
  3148 F56A D0 F8				BNE	SD_RD_BLK1		; no, read next byte
  3149 F56C 38					SEC				; yes, all data read, set C = 1
  3150 F56D 60			SD_RD_END	RTS
  3151
  3152 				; ******************************************************************************
  3153 				; Write Single Data Block from Std. Block Buffer
  3154 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Destination Address
  3155 				; Output: C = 0 Error, C = 1 Read OK
  3156 				;	  A = Error Code
  3157 				; ******************************************************************************
  3158
  3159 F56E 20 8B F6		SD_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3160 F571 F0 06				BEQ	SD_WR_BLK
  3161
  3162 				; ******************************************************************************
  3163 				; Write Single Data Block from Std. Block Buffer to Logical Address
  3164 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3165 				; Output: C = 0 Error, C = 1 Data OK
  3166 				;	  A = Error Code
  3167 				; ******************************************************************************
  3168
  3169 F573 20 8B F6		SD_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3170 										; fall through to sd_rd_lblk
  3171
  3172 				; ******************************************************************************
  3173 				; Write Single Data Block to Logical Address
  3174 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3175 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3176 				; Output: C = 0 Error, C = 1 Data OK
  3177 				;	  A = Error Code
  3178 				; ******************************************************************************
  3179
  3180 F576 20 94 F6		SD_WR_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3181 										; fall through to sd_rd_blk
  3182
  3183 				; ******************************************************************************
  3184 				; Write Single Data Block
  3185 				; Input:  SD_PB3..SD_PB0 = 32 Bit CommandBlock Destination Address
  3186 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3187 				; Output: C = 0 Error, C = 1 Write OK
  3188 				;	  A = Error Code
  3189 				; ******************************************************************************
  3190
  3191 F579 A9 58		SD_WR_BLK	LDA	#CMD24			; send CMD24 (blk write)
  3192 F57B 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3193 F57E 20 3D F4				JSR	SPI_WRITE		; write data token
  3194 F581 A2 01				LDX	#1			; initialize page counter
  3195 F583 86 FD				STX	YSAV
  3196 F585 CA					DEX				; initialize byte counter
  3197 F586 8A			SD_WR_BLK0	TXA
  3198 F587 A8					TAY
  3199 F588 B1 DC				LDA	(BLKBUF),Y		; read next byte from buffer
  3200 F58A A0 11				LDY	#PORTA			; and write it to the card
  3201 F58C 91 14				STA	(IOBASE),Y		; output data to shift register
  3202 F58E 88					DEY				; set for PORTB
  3203 F58F A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3204 F591 91 14				STA	(IOBASE),Y		; load data into shift register
  3205 F593 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3206 F595 91 14				STA	(IOBASE),Y		; data is now in shift register
  3207 F597 A0 1A				LDY 	#SR
  3208 F599 B1 14				LDA	(IOBASE),Y		; and start clk'ing
  3209 F59B E8					INX				; increment source pointer
  3210 F59C D0 E8				BNE	SD_WR_BLK0		; pointer overflow? No, write next byte
  3211 F59E E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3212 F5A0 C6 FD				DEC	YSAV
  3213 F5A2 10 E2				BPL	SD_WR_BLK0		; two pages written? no, write next byte
  3214 F5A4 20 57 F4				JSR	SPI_READ		; yes, send a (dummy) CRC ($FFFF)
  3215 F5A7 20 57 F4				JSR	SPI_READ
  3216 F5AA 20 57 F4				JSR	SPI_READ		; read one dummy byte
  3217 F5AD 20 57 F4				JSR	SPI_READ		; read response byte
  3218 F5B0 48			                PHA                             ; and save it onto the stack
  3219 F5B1 20 57 F4		SD_WR_BUSY?	JSR	SPI_READ		; read next byte
  3220 F5B4 C9 00				CMP	#0
  3221 F5B6 F0 F9				BEQ	SD_WR_BUSY?		; check if busy ($00)
  3222 F5B8 68					PLA
  3223 F5B9 29 1F				AND	#$1F			; mask result bits
  3224 F5BB C9 05				CMP	#$05			; data accepted?
  3225 F5BD 18					CLC
  3226 F5BE D0 01				BNE	SD_WR_END		; no, exit with C = 0
  3227 F5C0 38					SEC				; yes, exit with C = 1
  3228 F5C1 60			SD_WR_END	RTS
  3229
  3230 				; ******************************************************************************
  3231 				; Send Block Read or Write Command
  3232 				; Input :  A = Command (CMD17,CMD24)
  3233 				; Output : A = Data Token
  3234 				; ******************************************************************************
  3235
  3236 F5C2 20 02 F5		SD_SEND_BLK_CMD	JSR	SD_SEND_CMD
  3237 F5C5 D0 03				BNE	SD_RESP_ERR		; response <> 0 check error type
  3238 F5C7 A9 FE				LDA	#DATA_TOKEN
  3239 F5C9 60					RTS
  3240
  3241 				; ******************************************************************************
  3242 				; Check Error
  3243 				; ******************************************************************************
  3244
  3245 F5CA 29 01		SD_RESP_ERR	AND	#$01			; is card in idle mode?
  3246 F5CC F0 0B				BEQ	SD_DISK_RW		; no, print error
  3247 F5CE 20 26 F4				JSR	SPI_SLOW		; set SPI slow mode
  3248 F5D1 20 68 F4				JSR	SD_INIT			; yes, maybe card changed, reset
  3249 F5D4 B0 07				BCS	SD_DISK_CHNG
  3250 F5D6 A9 80		SD_NO_DISK	LDA	#$80
  3251 F5D8 60					RTS
  3252 F5D9 A9 81		SD_DISK_RW	LDA	#$81
  3253 F5DB 18					CLC
  3254 F5DC 60					RTS
  3255 F5DD A9 82		SD_DISK_CHNG	LDA	#$82
  3256 F5DF 18					CLC
  3257 F5E0 60					RTS
  3258
  3259 				; ******************************************************************************
  3260 				; Reset SD-Card
  3261 				; ******************************************************************************
  3262
  3263 F5E1 20 F3 F4		SD_RESET	JSR	SD_CLEAR_CMD		; clear command parameters
  3264 F5E4 A9 95				LDA	#$95
  3265 F5E6 85 E3				STA	SD_CRC			; and set crc to $95 for CMD0
  3266 F5E8 20 FF F5				JSR	SD_PREPARE		; send dummy sequence to SD-Card
  3267 F5EB D0 0A				BNE	RESET_SDC		; is MISO line high?
  3268 F5ED A9 40				LDA	#CMD0			; no, send CMD0 (reset) to SD-Card
  3269 F5EF 20 02 F5				JSR	SD_SEND_CMD
  3270 F5F2 20 FF F5				JSR	SD_PREPARE		; send init dummy sequence again
  3271 F5F5 F0 05				BEQ	END_SD_RESET		; MISO still low? Exit with A = $FF
  3272 F5F7 A9 40		RESET_SDC	LDA	#CMD0			; send CMD0 (reset) to SD-Card
  3273 F5F9 4C 02 F5				JMP	SD_SEND_CMD		; response should be $01
  3274
  3275 F5FC A9 FF		END_SD_RESET	LDA	#$FF			; reset failed
  3276 F5FE 60					RTS
  3277
  3278 				; **** Prepare SD-Card for Communication ***************************************
  3279 				;
  3280 				; ******************************************************************************
  3281
  3282 F5FF 20 26 F4		SD_PREPARE	JSR	SPI_SLOW		; set SPI slow mode
  3283 F602 A0 10				LDY	#PORTB			; initialize VIA Port B
  3284 F604 A9 4E				LDA	#$4E			; set /SPI_CS = H and /SPI_LOAD = H
  3285 F606 91 14				STA	(IOBASE),Y
  3286 F608 A2 0A				LDX	#10			; first send 80 clocks to SD-Card
  3287 F60A 20 57 F4		SEND_CLOCK	JSR	SPI_READ		; send 8 clock cycles
  3288 F60D CA					DEX
  3289 F60E D0 FA				BNE	SEND_CLOCK		; send more clock cycles
  3290 F610 AA					TAX
  3291 F611 A0 1D				LDY	#IFR
  3292 F613 A9 04		SD_PREPARE1	LDA	#$04
  3293 F615 31 14				AND	(IOBASE),Y
  3294 F617 F0 FA				BEQ	SD_PREPARE1
  3295 F619 A0 10				LDY	#PORTB
  3296 F61B A9 4A				LDA	#$4A			; set /SPI_CS = L and /SPI_LOAD = H
  3297 F61D 91 14				STA	(IOBASE),Y
  3298 F61F 8A					TXA				; set proper status flags
  3299 F620 60			SD_END		RTS
  3300
  3301 				; **** SD-Card Boot Routine ****************************************************
  3302 				;
  3303 				; ******************************************************************************
  3304 F621 20 F3 F4		SD_BOOT         JSR	SD_CLEAR_CMD
  3305 F624 20 36 F5				JSR	SD_RD_BLK_BUF           ; read MBR
  3306 F627 90 F7		                BCC     SD_END                  ; error reading MBR. Exit
  3307
  3308 F629 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3309 F62C 90 F2				BCC	SD_END			; branch if error
  3310 						
  3311 F62E A0 45				LDY     #SDCDEV-STRINGP2        ; load pointer to device name
  3312 F630 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3313 					
  3314 				;----------------------------------------------------------------------------------		
  3315 				; This routine is the same for both the CF and SD cards. It does the following:
  3316 				; - Load the MBR (sector 0) and does check for $55 $AA and $65 $02
  3317 				; - It runs the boot-menu routine in the MBR
  3318 				; - It loads the begin-LBA of the selected partition
  3319 				; - It loads the Volume ID (first sector) of the partition
  3320 				; Exit: C=0: Error, C=1: OK
  3321 				;----------------------------------------------------------------------------------		
  3322 F633 20 EE F6		LOAD_RUN_PART   JSR     SYS_MBR_ID              ; check boot block ID tag
  3323 F636 90 E8		                BCC     SD_END                  ; error, wrong ID. Exit
  3324 F638 AD BC 07		                LDA     PART0-2                 ; check if partition ID1 is $65
  3325 F63B C9 65		                CMP     #$65
  3326 F63D D0 20		                BNE     LOAD_PART0              ; no, just load partition 0
  3327 F63F AD BD 07		                LDA     PART0-1                 ; check if partition ID2 is $02
  3328 F642 C9 02		                CMP     #$02
  3329 F644 D0 19		                BNE     LOAD_PART0              ; no, just load partition 0
  3330 F646 20 00 06		                JSR     MBR                     ; partition ID $65 $02 found. Call MBR code
  3331 F649 D0 02		                BNE     LOAD_PART1              ; is boot menu result 1,2,3, or 4 ?
  3332 F64B 18			                CLC                             ; no, ESC pressed or no valid partition found
  3333 F64C 60			LRP_END         RTS                             ; abort booting from SD-Card
  3334
  3335 F64D CA			LOAD_PART1      DEX                             ; set result to 0,1,2 or 3
  3336 F64E 8A			                TXA                             ; transfer result to Accu
  3337 F64F A8			                TAY                             ; and to Y-Register
  3338 F650 0A			                ASL                            ; multiply result by 16
  3339 F651 0A			                ASL     
  3340 F652 0A			                ASL     
  3341 F653 0A			                ASL     
  3342 F654 09 08		                ORA     #$08                    ; and add 8
  3343 F656 AA			                TAX                             ; move partition table index into X
  3344 F657 98			                TYA
  3345 F658 18			                CLC
  3346 F659 69 31		                ADC     #49                     ; convert partition number to ASCII char (+1)
  3347 F65B 85 EE		                STA     PSAV                    ; and store it to PSAV
  3348 F65D D0 0B		                BNE     LOAD_PART               ; branch always
  3349 F65F A2 08		LOAD_PART0      LDX     #$08                    ; for partition 0 the table index is 8
  3350 F661 A9 31		                LDA     #'1'                    ; partition 0 number as ASCII char (+1)
  3351 F663 85 EE		                STA     PSAV                    ; store it in PSAV
  3352 F665 AD BE 07		                LDA     PART0                   ; read boot indicator
  3353 F668 F0 75		                BEQ     SYS_MSG_ERR             ; if $00 then exit
  3354 F66A A0 08		LOAD_PART       LDY     #$08
  3355 F66C BD C6 07		SD_BOOT1        LDA     PART0_RS,X              ; load partition start and length
  3356 F66F 99 00 04		                STA     BOOT_PART,Y             ; and save it to boot device descriptor
  3357 F672 CA			                DEX
  3358 F673 88			                DEY
  3359 F674 10 F6		                BPL     SD_BOOT1
  3360 F676 A2 00		                LDX	#< BOOT_PART            ; read partition boot blk ptr
  3361 F678 A0 04				LDY	#> BOOT_PART
  3362 F67A 20 E7 F6				JSR     SYS_LD_BOOTBLK          ; load partition boot block
  3363 F67D 90 CD		                BCC     LRP_END                 ; block not found. Exit
  3364 F67F 4C 00 F7		                JMP     SYS_CHECK_OS            ; check OS OEM string C=0: wrong OEM string. And return
  3365 						
  3366 				;----------------------------------------------------------------------------
  3367 				; This routine prints a string to the terminal: A=LSB, Y=MSB
  3368 				;----------------------------------------------------------------------------
  3369 F682 86 CA		SPRINT		STX 	PRSTR	    	; LSB of text-pointer
  3370 F684 84 CB				STY 	PRSTR+1	    	; MSB of text-pointer
  3371 F686 20 4D FE				JSR 	SPROUT	    	; BIOS print string routine
  3372 F689 60					RTS
  3373 F68A EA					NOP			; maintain v1.1.4 compatibility
  3374 						
  3375 				; ******************************************************************************
  3376 				; Initialize Block Buffer Pointer, it must return with A = 0.
  3377 				; ******************************************************************************
  3378
  3379 F68B A9 06		INIT_BLKBUF	LDA	#> BLOCK_BUF         ; set pointer to standard block buffer
  3380 F68D 85 DD				STA	BLKBUFH
  3381 F68F A9 00				LDA	#$00
  3382 F691 85 DC				STA	BLKBUF
  3383 F693 60					RTS
  3384
  3385 				; ******************************************************************************
  3386 				; Load Logical Block Address into SD-card Command Address.
  3387 				; Swap Endian and Shift Bits if Desired
  3388 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
  3389 				; Output: ADR in SD_PB3..SD_PB0
  3390 				; ******************************************************************************
  3391
  3392 F694 86 E6		LOAD_LBA_SD	STX	PLBAL
  3393 F696 84 E7				STY	PLBAH
  3394 F698 A2 04				LDX	#$04
  3395 F69A A0 00				LDY	#$00
  3396 F69C A5 DB				LDA	SD_TYPE
  3397 F69E D0 0F				BNE	BLK_MODE
  3398 F6A0 18					CLC
  3399 F6A1 98					TYA
  3400 F6A2 95 DE		                STA	SD_CMD,X
  3401 F6A4 CA					DEX
  3402 F6A5 B1 E6		BIT_MODE	LDA	(PLBA),Y
  3403 F6A7 2A					ROL	
  3404 F6A8 95 DE		                STA	SD_CMD,X
  3405 F6AA C8					INY
  3406 F6AB CA					DEX
  3407 F6AC D0 F7				BNE	BIT_MODE
  3408 F6AE 60					RTS
  3409 F6AF B1 E6		BLK_MODE	LDA	(PLBA),Y
  3410 F6B1 95 DE				STA	SD_CMD,X
  3411 F6B3 C8					INY
  3412 F6B4 CA					DEX
  3413 F6B5 D0 F8				BNE	BLK_MODE
  3414 F6B7 60					RTS
  3415
  3416 				; ******************************************************************************
  3417 				; Boot Routines
  3418 				; ******************************************************************************
  3419
  3420 				; **** Main Boot Routine *******************************************************
  3421 				;
  3422 				; Find first bootable device
  3423 				; Output : C = 0 No Boot Device Found
  3424 				;          C = 1 Boot Device Found. Boot Code at $0600 Available
  3425 				;
  3426 				; ******************************************************************************
  3427
  3428 F6B8 A0 20		SYS_BOOT        LDY     #STORAGE_DEV            ; boot from storage device only
  3429 F6BA 84 F4		SYS_BOOT1       STY     YREG
  3430 F6BC 98			                TYA
  3431 F6BD 20 BE F7		                JSR     DEV_OPEN                ; open device descriptor
  3432 F6C0 90 0E		                BCC     SYS_BOOT2               ; device not found, try next one
  3433 F6C2 A9 00		                LDA     #CMD_INIT
  3434 F6C4 20 BA E0		                JSR     CMDDEV                  ; initialize device
  3435 F6C7 90 07		                BCC     SYS_BOOT2               ; could not initialize, try next one
  3436 F6C9 A9 24		                LDA     #CMD_BOOT
  3437 F6CB 20 BA E0		                JSR     CMDDEV                  ; can we boot from device?
  3438 F6CE B0 11		                BCS     SYS_BOOT_END            ; yes, exit
  3439 F6D0 A4 F4		SYS_BOOT2       LDY     YREG                    ; no, try next device
  3440 F6D2 C8			                INY
  3441 F6D3 C0 2F		                CPY     #$2F                    ; all devices checked?
  3442 F6D5 D0 E3		                BNE     SYS_BOOT1               ; no, try next one
  3443 F6D7 A0 30		                LDY     #NOBOOTDEV-STRINGP2     ; yes, no boot device found
  3444
  3445 				; ***** Show System Message ****************************************************
  3446 				;
  3447 				; Input:  Y - Index To Message String
  3448 				; Output: C = 0
  3449 				;
  3450 				; ******************************************************************************
  3451
  3452 F6D9 20 4C E5		SYS_MSG         JSR     LOADSTRING2
  3453 F6DC 20 85 E0		                JSR  	WRSTR                   ; show error message
  3454 F6DF 18			SYS_MSG_ERR     CLC
  3455 F6E0 60			SYS_MSG_END     RTS
  3456
  3457 				; ***** Finalize Boot Procedure ************************************************
  3458
  3459 F6E1 A9 B0		SYS_BOOT_END    LDA     #$B0                    ; boot block could be loaded
  3460 F6E3 8D 00 06		                STA     $0600                   ; modify jump opcode in boot block into BCS
  3461 F6E6 60			                RTS
  3462
  3463 				; ***** Load Boot Block From Device ********************************************
  3464 				;
  3465 				; Input:  X - Pointer to Boot Block Low Address
  3466 				;         Y - Pointer to Boot Block High Address
  3467 				; Output: C = 0 No Boot Block Found
  3468 				;         C = 1 Boot Block Loaded at $0600
  3469 				;
  3470 				; ******************************************************************************
  3471
  3472 F6E7 A9 25		SYS_LD_BOOTBLK  LDA     #CMD_READ_BUF
  3473 F6E9 20 BA E0		                JSR     CMDDEV                   ; load master boot block
  3474 F6EC 90 10		                BCC     SYS_TAG_ERR
  3475
  3476 				; ***** Check Boot Block ID Tag ($55 $AA) **************************************
  3477 				;
  3478 				; Output: C = 0 No Boot Block Tag Found
  3479 				;         C = 1 Boot Block Tag Found
  3480 				;
  3481 				; ******************************************************************************
  3482
  3483 F6EE AD FE 07		SYS_MBR_ID      LDA     BOOTBLK_TAG             ; check boot block ID tag
  3484 F6F1 C9 55		                CMP     #$55
  3485 F6F3 D0 09		                BNE     SYS_TAG_ERR
  3486 F6F5 AD FF 07		                LDA     BOOTBLK_TAG+1
  3487 F6F8 C9 AA		                CMP     #$AA
  3488 F6FA D0 02		                BNE     SYS_TAG_ERR
  3489 F6FC 38			                SEC
  3490 F6FD 60			                RTS
  3491 F6FE 18			SYS_TAG_ERR     CLC
  3492 F6FF 60			                RTS
  3493
  3494 				; ***** Check OS OEM String ****************************************************
  3495 				;
  3496 				; Output: C = 0 OS OEM String Not Found
  3497 				;         C = 1 OS OEM String Found
  3498 				;
  3499 				; ******************************************************************************
  3500
  3501 F700 A2 04		SYS_CHECK_OS    LDX     #04                     ; check four characters of OEM string
  3502 F702 BD 7D E8		SYS_ID_LOOP     LDA     OSID-1,X
  3503 F705 DD 02 06		                CMP     BLOCK_BUF+2,X
  3504 F708 18			                CLC
  3505 F709 D0 09		                BNE     SYS_CHECK_END           ; wrong OEM string
  3506 F70B CA			                DEX
  3507 F70C D0 F4		                BNE     SYS_ID_LOOP             ; more charactrs to check
  3508 F70E A0 20		                LDY     #BOOTDEV-STRINGP2
  3509 F710 20 D9 F6		SYS_BOOTMSG     JSR     SYS_MSG                 ; write boot message
  3510 F713 38			                SEC
  3511 F714 60			SYS_CHECK_END   RTS
  3512
  3513 				; ******************************************************************************
  3514 				; Miscellanious Routines
  3515 				; ******************************************************************************
  3516
  3517 				; **** Read Joystick Port ******************************************************
  3518
  3519 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
  3520 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
  3521 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
  3522
  3523 				; ******************************************************************************
  3524
  3525 F715 A5 17		READ_JOY_PORT   LDA     FGCBASEH
  3526 F717 F0 47		                BEQ     NO_JOY_PORT             ; check if Floppy-/Graphisc-Controller installed
  3527 F719 A0 0D		                LDY     #PIA_PORTB
  3528 F71B B1 16		                LDA     (FGCBASE),Y             ; yes, read joystick port
  3529 F71D A2 00		DECODE_JOY_PORT LDX     #$00                    ; preset x position to CENTER
  3530 F71F A0 00		                LDY     #$00                    ; preset y position to CENTER
  3531 F721 86 FC		                STX     TEMP                    ; clear temp value
  3532 F723 4A			JP_UP           LSR                             ; get /UP flag
  3533 F724 B0 06		                BCS     JP_DOWN                 ; not set, check DOWN position
  3534 F726 A0 FF		                LDY     #$FF                    ; set y position to -1 (UP)
  3535 F728 4A			                LSR                             ; skip DOWN bit
  3536 F729 4C 31 F7		                JMP     JP_LEFT                 ; and test x position
  3537 F72C 4A			JP_DOWN         LSR                             ; get /DOWN flag
  3538 F72D B0 02		                BCS     JP_LEFT                 ; not set, test x position
  3539 F72F A0 01		                LDY     #$01                    ; set y position to 1 (DOWN)
  3540 F731 4A			JP_LEFT         LSR                             ; get /LEFT flag
  3541 F732 B0 06		                BCS     JP_RIGHT                ; not set, check RIGHT position
  3542 F734 A2 FF		                LDX     #$FF                    ; set x position to -1 (UP)
  3543 F736 4A			                LSR                             ; skip RIGHT bit
  3544 F737 4C 3F F7		                JMP     JP_BUTTON3              ; and test button 3
  3545 F73A 4A			JP_RIGHT        LSR                             ; get /RIGHT flag
  3546 F73B B0 02		                BCS     JP_BUTTON3              ; not set, test button 3
  3547 F73D A2 01		                LDX     #$01                    ; set x position to 1 (RIGHT)
  3548 F73F 4A			JP_BUTTON3      LSR                             ; get /BUTTON3 flag
  3549 F740 B0 06		                BCS     JP_BUTTON1              ; not set, test button 1
  3550 F742 48			                PHA                             ; save joystick port value
  3551 F743 A9 04		                LDA     #$04
  3552 F745 85 FC		                STA     TEMP                    ; set bit 2 of temp button result
  3553 F747 68			                PLA                             ; restore joystick port value
  3554 F748 4A			JP_BUTTON1      LSR                             ; get /BUTTON1 flag
  3555 F749 B0 08		                BCS     JP_BUTTON2              ; not set, test button 2
  3556 F74B 48			                PHA                             ; save joystick port value
  3557 F74C A9 01		                LDA     #$01
  3558 F74E 05 FC		                ORA     TEMP
  3559 F750 85 FC		                STA     TEMP                    ; set bit 0 of temp button result
  3560 F752 68			                PLA                             ; restore joystick port value
  3561 F753 4A			JP_BUTTON2      LSR                             ; get /BUTTON2 flag
  3562 F754 B0 06		                BCS     END_JOY_PORT            ; not set, exit
  3563 F756 A9 02		                LDA     #$02
  3564 F758 05 FC		                ORA     TEMP
  3565 F75A 85 FC		                STA     TEMP                    ; set bit 1 of temp button result
  3566 F75C A5 FC		END_JOY_PORT    LDA     TEMP                    ; load temp button result into A
  3567 F75E 38			                SEC                             ; data valid
  3568 F75F 60			                RTS
  3569 F760 AA			NO_JOY_PORT     TAX                             ; no joystick port available, clear X
  3570 F761 A8			                TAY                             ; and Y
  3571 F762 18			                CLC                             ; no joystick port available, data invalid
  3572 F763 60			                RTS
  3573
  3574 				; ******************************************************************************
  3575 				; Device Driver Routines
  3576 				; ******************************************************************************
  3577
  3578 				; **** Initialize Device Driver List *******************************************
  3579 				;
  3580 				; ******************************************************************************
  3581
  3582 F764 A0 3E		DEV_INIT	LDY	#$3E                    ; clear entire list
  3583 F766 A9 00		                LDA     #$00                    ; and fill it with zeros
  3584 F768 99 28 1A		DEV_INIT1       STA     DEVLIST,Y
  3585 F76B 88			                DEY
  3586 F76C 10 FA				BPL	DEV_INIT1
  3587 F76E 60			END_DEV_INIT	RTS
  3588
  3589 				; **** Add Device Driver *******************************************************
  3590 				;
  3591 				; Input  - X : Driver Descriptor Address Low Byte
  3592 				;          Y : Driver Descriptor Address High Byte
  3593 				; Output - C = 1 Success, C = 0 Error
  3594 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
  3595 				;
  3596 				; ******************************************************************************
  3597 F76F 86 DE		DEV_ADD		STX	PDEVL			; LSB of device driver descriptor
  3598 F771 84 DF				STY	PDEVH			; MSB of device driver descriptor
  3599 F773 A0 00				LDY	#$00
  3600 F775 B1 DE				LDA	(PDEV),Y                ; load device ID into A
  3601 F777 85 FC				STA     TEMP			; TEMP = Device ID
  3602 F779 20 B2 F7		                JSR     DEV_CHECK		; Check device ID
  3603 F77C 90 2F		                BCC     END_DEV_ADD		; Exit if device ID error
  3604 						
  3605 F77E 4A			                LSR     			; A = Device ID again
  3606 F77F 29 0F		                AND     #$0F			; Get ID-nr from Device ID
  3607 F781 C9 0F		                CMP     #$0F			; Device 15 ?
  3608 F783 D0 14		                BNE     ADD_DEV			; branch if not full yet
  3609 						
  3610 F785 98			FIND_FREE_DEV   TYA				; A now contains 2 * Device ID = $5E			
  3611 F786 29 E0		                AND     #$E0			; A = $50
  3612 F788 A8			                TAY				; Y = $50
  3613 F789 A2 00		                LDX     #$00			; init. X
  3614 F78B B9 08 1A		FIND_NEXT_DEV   LDA     DEVLIST-$20,Y		; Check if Device List entry is empty
  3615 F78E F0 0A		                BEQ     ADD_DEV1		; branch if it is empty
  3616 						
  3617 F790 C8			                INY				; Next entry in Device List
  3618 F791 C8			                INY
  3619 F792 E8			                INX				; Next device
  3620 F793 E0 0F		                CPX     #$0F			; 15 device entries checked?
  3621 F795 90 F4		                BCC     FIND_NEXT_DEV		; branch if not at end of list yet
  3622 						
  3623 F797 18			                CLC				; error
  3624 F798 60			                RTS				; return
  3625 						
  3626 F799 AA			ADD_DEV         TAX				; X = nr. of Device ID
  3627 F79A A5 DE		ADD_DEV1        LDA     PDEVL			; LSB of device driver descriptor
  3628 F79C 99 08 1A		                STA     DEVLIST-$20,Y		; Start of device driver list in RIOT memory
  3629 F79F A5 DF		                LDA     PDEVH			; MSB of device driver descriptor
  3630 F7A1 99 09 1A		                STA     DEVLIST-$1F,Y		;
  3631 F7A4 A5 FC		                LDA     TEMP			; Get Device ID back
  3632 F7A6 29 F0		                AND     #$F0			; A = $20
  3633 F7A8 86 FC		                STX     TEMP			; Temp = nr. of Device ID
  3634 F7AA 05 FC		                ORA     TEMP			; Original Device ID again
  3635 F7AC 38			                SEC				; No error
  3636 F7AD 60			END_DEV_ADD     RTS				; Return
  3637
  3638 F7AE A2 FF		DEV_ERR         LDX     #$FF			; Error, unknown Device Type
  3639 F7B0 18			                CLC
  3640 F7B1 60			               	RTS
  3641
  3642 				;----------------------------------------------------------------------
  3643 				; This functions checks if the Device ID is correct
  3644 				;----------------------------------------------------------------------
  3645 F7B2 C9 30		DEV_CHECK       CMP     #STORAGE_DEV+$10	; Not too many devices?
  3646 F7B4 B0 F8				BCS     DEV_ERR			; branch if so
  3647 						
  3648 F7B6 C9 10				CMP     #COM_DEV		; Device ID too small?
  3649 F7B8 90 F4		                BCC     DEV_ERR			; branch if so
  3650 						
  3651 F7BA 0A			                ASL     			; Why?
  3652 F7BB A8			                TAY				; y = ID * 2
  3653 F7BC 38			                SEC				; No error
  3654 F7BD 60			                RTS				; return
  3655
  3656 				; **** Open Device Driver ******************************************************
  3657 				;
  3658 				; Input  - A : Device ID
  3659 				; Output - C = 1 Success, C = 0 Error
  3660 				;          X : Descriptor Address Low Byte
  3661 				;          Y : Descriptor Address High Byte
  3662 				;
  3663 				; ******************************************************************************
  3664 F7BE 20 B2 F7		DEV_OPEN        JSR     DEV_CHECK		; Check Device ID
  3665 F7C1 90 26		                BCC     END_DEV_OPEN		; exit if ID error
  3666 						
  3667 F7C3 B9 08 1A		                LDA     DEVLIST-$20,Y		; DEVLIST = $1A28, Y=2*Device ID, $1A48 ???
  3668 F7C6 D0 02		                BNE     DEV_OPEN1		
  3669 						
  3670 F7C8 A9 80		                LDA	#< NULL_DEV   		; no device found use NULL device
  3671 F7CA 85 DE		DEV_OPEN1       STA     PDEVL
  3672 F7CC B9 09 1A		                LDA     DEVLIST-$1F,Y		; Get MSB
  3673 F7CF D0 02		                BNE     DEV_OPEN2
  3674 						
  3675 F7D1 A9 F9		                LDA	#> NULL_DEV  		; no device found use NULL device
  3676 F7D3 85 DF		DEV_OPEN2       STA     PDEVH
  3677 F7D5 A0 02				LDY	#$02
  3678 F7D7 A2 00				LDX	#$00
  3679 F7D9 B1 DE		DEV_OPEN3	LDA	(PDEV),Y		; Start Input vector LSB
  3680 F7DB 9D 68 1A				STA	DEVIN,X			
  3681 F7DE C8					INY
  3682 F7DF E8					INX
  3683 F7E0 E0 06				CPX	#$06			; Copy Input, Output & Command vector
  3684 F7E2 D0 F5				BNE	DEV_OPEN3		; branch if not done yet
  3685 						
  3686 F7E4 A6 DE				LDX	PDEVL			; X = LSB of Descriptor Address
  3687 F7E6 A4 DF				LDY	PDEVH			; Y = MSB of Descriptor Address
  3688 F7E8 38					SEC				; No error
  3689 F7E9 60			END_DEV_OPEN    RTS				; Return
  3690
  3691 				; ******************************************************************************
  3692 				; Standard Driver Command Routines
  3693 				; ******************************************************************************
  3694
  3695 				; ******************************************************************************
  3696 				; XModem Command Interpreter
  3697 				; ******************************************************************************
  3698
  3699 F7EA C9 20		XMODEM_CMD	CMP	#CMD_LOAD
  3700 F7EC D0 03				BNE	XM_SAVE
  3701 F7EE 4C 15 F0				JMP	XModemRcv
  3702 F7F1 C9 21		XM_SAVE  	CMP	#CMD_SAVE
  3703 F7F3 D0 45				BNE     COM_CMD
  3704 F7F5 4C 06 F1				JMP	XModemSnd
  3705
  3706 				; ******************************************************************************
  3707 				; Tape Device Command Interpreter (14 bytes, removed 24-07-25 Emile)
  3708 				; ******************************************************************************
  3709
  3710 F7F8					ORG	$F806		; maintain compatibilitywith v1.1.4
  3711 				; ******************************************************************************
  3712 				; XSD_Card Command Interpreter
  3713 				; ******************************************************************************
  3714
  3715 F806 C9 00		SDC_CMD         CMP     #CMD_INIT
  3716 F808 D0 03		                BNE     SDC_READ
  3717 F80A 4C 68 F4		                JMP     SD_INIT
  3718 F80D C9 22		SDC_READ        CMP     #CMD_READ
  3719 F80F D0 03		                BNE     SDC_WRITE
  3720 F811 4C 3E F5		                JMP     SD_RD_LBLK
  3721 F814 C9 23		SDC_WRITE       CMP     #CMD_WRITE
  3722 F816 D0 03		                BNE     SDC_RD_BUF
  3723 F818 4C 76 F5		                JMP     SD_WR_LBLK
  3724 F81B C9 25		SDC_RD_BUF      CMP     #CMD_READ_BUF
  3725 F81D D0 03		                BNE     SDC_WR_BUF
  3726 F81F 4C 3B F5		                JMP     SD_RD_LBLK_BUF
  3727 F822 C9 26		SDC_WR_BUF      CMP     #CMD_WRITE_BUF
  3728 F824 D0 03		                BNE     SDC_SETADR
  3729 F826 4C 73 F5		                JMP     SD_WR_LBLK_BUF
  3730 F829 C9 10		SDC_SETADR      CMP     #CMD_SETSTARTADR
  3731 F82B D0 06		                BNE     SDC_BOOT
  3732 F82D 86 DC		                STX     BLKBUFL
  3733 F82F 84 DD		                STY     BLKBUFH
  3734 F831 38			                SEC
  3735 F832 60			                RTS
  3736 F833 C9 24		SDC_BOOT        CMP     #CMD_BOOT
  3737 F835 D0 17		                BNE     _EMPTY_
  3738 F837 4C 21 F6		                JMP     SD_BOOT
  3739
  3740 				; ******************************************************************************
  3741 				; Common Command Interpreter
  3742 				; ******************************************************************************
  3743
  3744 F83A C9 10		COM_CMD	        CMP	#CMD_SETSTARTADR
  3745 F83C D0 06				BNE     COM_SETENDADR
  3746 F83E 86 FA				STX	ADRL
  3747 F840 84 FB				STY	ADRH
  3748 F842 38					SEC
  3749 F843 60					RTS
  3750 F844 C9 11		COM_SETENDADR	CMP	#CMD_SETENDADR
  3751 F846 D0 06		                BNE     _EMPTY_
  3752 F848 86 F8				STX	NUML
  3753 F84A 84 F9				STY	NUMH
  3754 F84C 38					SEC
  3755 F84D 60					RTS
  3756
  3757 				; EMPTY Command Handler ********************************************************
  3758 F84E 18			_EMPTY_         CLC
  3759 F84F 60			_HANDLER_       RTS
  3760
  3761 				; Command Handler For Floppy Drive 2 *******************************************
  3762 F850 09 80		FGC_FDC_CMD2    ORA     #$80            ; set bit 7 of command byte (drive 2 operation)
  3763 F852 4C 17 10		                JMP     FGC_FDC_CMD     ; call command handler
  3764
  3765 				;----------------------------------------------------------------------------
  3766 				; This routine contains the entry routines for the CF-card routines
  3767 				;----------------------------------------------------------------------------
  3768 F855 C9 00		CFC_CMD         CMP     #CMD_INIT
  3769 F857 D0 03		                BNE     CFC_READ
  3770 F859 4C 8D F8		                JMP     CF_INIT		; Init. CF-card with HW-reset
  3771 F85C C9 22		CFC_READ        CMP     #CMD_READ
  3772 F85E D0 03		                BNE     CFC_WRITE
  3773 F860 4C BF FC		                JMP     CF_RD_LBLK	; used a lot in boot.sys and mkboot.sys
  3774 F863 C9 23		CFC_WRITE       CMP     #CMD_WRITE
  3775 F865 D0 03		                BNE     CFC_RD_BUF
  3776 F867 4C FA FC		                JMP     CF_WR_LBLK
  3777 F86A C9 25		CFC_RD_BUF      CMP     #CMD_READ_BUF
  3778 F86C D0 03		                BNE     CFC_WR_BUF
  3779 F86E 4C BC FC		                JMP     CF_RD_LBLK_BUF
  3780 F871 C9 26		CFC_WR_BUF      CMP     #CMD_WRITE_BUF
  3781 F873 D0 03		                BNE     CFC_LOAD
  3782 F875 4C F7 FC		                JMP     CF_WR_LBLK_BUF
  3783 F878 C9 20		CFC_LOAD	CMP	#CMD_LOAD
  3784 F87A D0 03				BNE	CFC_SAVE
  3785 F87C 6C 06 18				JMP	(CF_LOAD_VEC)	; Filled in by boot.sys
  3786 F87F C9 21		CFC_SAVE	CMP	#CMD_SAVE
  3787 F881 D0 03				BNE	CFC_BOOT
  3788 F883 6C 08 18				JMP	(CF_SAVE_VEC)	; Filled in by boot.sys
  3789 F886 C9 24		CFC_BOOT        CMP     #CMD_BOOT
  3790 F888 D0 C4		                BNE     _EMPTY_
  3791 F88A 4C 04 F9		                JMP     CF_BOOT
  3792
  3793 				; ******************************************************************************
  3794 				; CF-Card Driver Routines
  3795 				; ******************************************************************************
  3796 				;----------------------------------------------------------------------------
  3797 				; Command: CMD_INIT, Initialize CF-Card
  3798 				; Output : C = 1 Init OK, C = 0 Error
  3799 				;----------------------------------------------------------------------------
  3800 F88D A9 00		CF_INIT		LDA #$00		; Reset command
  3801 F88F 8D 88 0C		                STA CFREG8		; HW reset command
  3802 F892 A9 01				LDA #1
  3803 F894 85 D7				STA RSTACT		; 1 = Reset pending
  3804 F896 20 B5 F8				JSR CFWAIT
  3805 F899 B0 03				BCS INITOK		; branch if CF-card init OK
  3806 						
  3807 F89B A9 80		CF_ERR		LDA #$80
  3808 F89D 60					RTS			; return if error (C=0)
  3809 						
  3810 F89E A9 E0		INITOK		LDA #$E0		; LBA3=0, Master, Mode=LBA
  3811 F8A0 8D 86 0C				STA CFREG6
  3812 F8A3 A9 01				LDA #$01		; 8-bit transfers
  3813 F8A5 8D 81 0C				STA CFREG1
  3814 F8A8 A9 EF				LDA #$EF		; Set feature command
  3815 F8AA 8D 87 0C				STA CFREG7		; CF command register
  3816 F8AD 20 B5 F8				JSR CFWAIT		; Wait and return
  3817 F8B0 90 E9				BCC CF_ERR		; branch if Error
  3818 						
  3819 F8B2 4C 00 FC				JMP CF_INFO		; Print CF-Card Info, returns with C=1 (OK)
  3820
  3821 				;----------------------------------------------------------------------------
  3822 				; This routine waits until the CF-card is ready.
  3823 				;----------------------------------------------------------------------------
  3824 F8B5 A9 00		CFWAIT		LDA #0
  3825 F8B7 85 D6				STA MSEC		; msec counter
  3826 F8B9 A5 D7		CFWLP		LDA RSTACT		; 1 = Reset pending
  3827 F8BB F0 05				BEQ NO_DLY10		; branch if no 10 msec. delay needed
  3828 						
  3829 F8BD A9 0A				LDA #10			; delay = 10 msec.
  3830 F8BF 20 4D E1				JSR DELAY		; delay 10 msec.
  3831 F8C2 E6 D6		NO_DLY10	INC MSEC		; msec-counter
  3832 F8C4 A5 D6				LDA MSEC
  3833 F8C6 F0 2D				BEQ CFWLPTO		; branch after 2550 msec. and no reset
  3834 						
  3835 F8C8 AD 87 0C				LDA CFREG7		; read status register
  3836 F8CB 29 80				AND #$80		; check busy flag
  3837 F8CD D0 EA				BNE CFWLP		; branch if BSY flag is still set
  3838 						
  3839 						; Busy flag cleared
  3840 F8CF AD 87 0C				LDA CFREG7		; read status register
  3841 F8D2 29 50				AND #$50		; check for RDY and DSC flags
  3842 F8D4 C9 50				CMP #$50		; BSY and DSC flags both set?
  3843 F8D6 D0 E1				BNE CFWLP		; branch if RDY and DSC not both set
  3844
  3845 F8D8 A5 D7				LDA RSTACT		; 1 = Reset pending
  3846 F8DA F0 17				BEQ PRENDOK		; branch if no Reset pending
  3847 						
  3848 F8DC A9 00				LDA #0
  3849 F8DE 85 D7				STA RSTACT		; Reset no longer pending
  3850 F8E0 A2 32				LDX #<TXT_RSTOK     	; Print Reset OK + msec
  3851 F8E2 A0 F9				LDY #>TXT_RSTOK
  3852 F8E4 20 82 F6				JSR SPRINT	    	; print
  3853 F8E7 A5 D6				LDA MSEC		; #msec. * 10
  3854 F8E9 20 A7 E0				JSR NUMOUT		; Print decimal number
  3855 F8EC A2 3F				LDX #<TXT_MSEC     	; Print msec
  3856 F8EE A0 F9				LDY #>TXT_MSEC
  3857 F8F0 20 82 F6				JSR SPRINT	    	; print
  3858 F8F3 38			PRENDOK		SEC			; C=1, no error
  3859 F8F4 60					RTS			; return if BSY=0 and RDY=DSC=1
  3860 					
  3861 F8F5 A2 48		CFWLPTO		LDX #<TXT_HWERR     	; Print HW error
  3862 F8F7 A0 F9				LDY #>TXT_HWERR
  3863 F8F9 20 82 F6				JSR SPRINT	    	; print		
  3864 F8FC AD 87 0C				LDA CFREG7		; Status register
  3865 F8FF 20 91 E0				JSR HEXOUT		; Print and return
  3866 F902 18					CLC			; C=0, error
  3867 F903 60			CF_END		RTS			; return
  3868
  3869 				;-------------------------------------------------------------------------------
  3870 				; CF-Card Boot Routine
  3871 				;-------------------------------------------------------------------------------
  3872 F904 20 78 FC		CF_BOOT         JSR	INIT_LBA		; CFLBA0..CFLBA3 = 0 (MBR) and load into CF-card
  3873 F907 20 B7 FC				JSR	CF_RD_BLK_BUF		; Read MBR and store in BLOCK_BUF ($0600)
  3874 F90A 90 F7				BCC     CF_END                  ; error reading MBR. Exit
  3875 						
  3876 F90C 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3877 F90F 90 F2				BCC	CF_END			; branch if error
  3878 						
  3879 F911 A0 40				LDY     #CFCDEV-STRINGP2        ; load pointer to device name
  3880 F913 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3881
  3882 				;-------------------------------------------------------------------------------
  3883 				; Init CFC-card, this is called from within MAIN loop.
  3884 				; The first instruction comes from the beginning of the MAIN routine and 
  3885 				; ensures that addresses do not change in a new firmware version
  3886 				;-------------------------------------------------------------------------------
  3887 F916 20 55 E5		INIT_CFC	JSR     WRITE_IO_INFO		; instruction from MAIN routine
  3888 F919 20 A1 FD				JSR	CHECK_ROMS		; Check ROM checksum
  3889 F91C A2 D0				LDX     #<CFC_DEV
  3890 F91E A0 F9		                LDY     #>CFC_DEV
  3891 F920 4C 6F F7		                JMP     DEV_ADD         	; add CF-card driver and return
  3892
  3893 				;----------------------------------------------------------------------------------		
  3894 				; This routine is the same for both the CF and SD cards. It displays the device ID
  3895 				;----------------------------------------------------------------------------------		
  3896 F923 20 D9 F6		DISP_DVC        JSR     SYS_MSG                 ; print device name to screen
  3897 F926 A9 5F		                LDA     #'_'
  3898 F928 20 52 E0		                JSR     COUT
  3899 F92B A5 EE		                LDA     PSAV                    ; add partition number to name (_1.._4)
  3900 F92D 20 52 E0		                JSR     COUT
  3901 F930 38			                SEC                             ; normal boot, set carry flag
  3902 F931 60			                RTS
  3903
  3904 F932 0D 20 43 46 20 52 + TXT_RSTOK       .by     CR ' CF Reset: ' $00
  3905 F93F 30 20 6D 73 65 63 + TXT_MSEC	.by	'0 msec.' CR $00
  3906 F948 4E 6F 20 43 46 20 + TXT_HWERR       .by     'No CF Reset, Status=$' $00
  3907
  3908 				; **** VPU IRQ Routine *********************************************************
  3909 				; ******************************************************************************
  3910 F95E			                ORG     $F960
  3911
  3912 F960 48			VPU_IRQ         PHA
  3913 F961 A9 00		                LDA     #VPU_STAT0
  3914 F963 8D 09 10		                STA     VPU_PORT1
  3915 F966 A9 8F		                LDA     #VPU_REG15
  3916 F968 8D 09 10		                STA     VPU_PORT1
  3917 F96B AD 09 10		                LDA     VPU_PORT1       ; is it a line interrupt?
  3918 F96E 10 08		                BPL     NO_VPU_IRQ      ; no, exit
  3919 F970 A5 DA		                LDA     TICKCNT         ; yes, load the tick counter
  3920 F972 F0 02				BEQ     IRQ_END         ; is it 0?
  3921 F974 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  3922 F976 68			IRQ_END         PLA
  3923 F977 40			                RTI
  3924 F978 68			NO_VPU_IRQ	PLA			; restore accumulator
  3925 F979 4C 18 F3				JMP	IRQ		; call user interrupt routine
  3926
  3927 				; ******************************************************************************
  3928 				; Standard Driver Descriptors
  3929 				; ******************************************************************************
  3930
  3931 F97C			                ORG     $FA00-16*8
  3932
  3933 F980 00 00		NULL_DEV	.byte	NULL_ID, $00     ; Null Device Driver Descriptor
  3934 F982 4E F8				.word	_EMPTY_
  3935 F984 4E F8				.word	_EMPTY_
  3936 F986 4E F8				.word	_EMPTY_
  3937
  3938 F988 10 00		TTY_DEV		.byte	TTY1_ID, $00     ; Terminal Driver Descriptor
  3939 F98A 75 F3				.word	SERIALIN
  3940 F98C 65 F3				.word	SERIALOUT
  3941 F98E E2 E1				.word	TTY_CMD
  3942
  3943 F990 11 00		PPRINT_DEV	.byte	PRINTER1_ID, $00 ; Parallel Printer Driver Descriptor
  3944 F992 4E F8				.word	_EMPTY_
  3945 F994 D2 F3				.word	PPORTOUT
  3946 F996 4E F8				.word	_EMPTY_
  3947
  3948 F998 13 00		KEYBD_DEV       .byte	KEYBD1_ID, $00   ; ASCII Keyboard Driver Descriptor
  3949 F99A 82 F3				.word	ASCIIKBD
  3950 F99C 4E F8				.word	_EMPTY_
  3951 F99E 4E F8				.word	_EMPTY_
  3952
  3953 F9A0 15 00		VDP_DEV         .byte	VDP1_ID, $00     ; Video Display Processor Driver Descriptor
  3954 F9A2 9A F3				.word   PS2KBD
  3955 F9A4 27 10		                .word   FGC_VPU_OUT
  3956 F9A6 1F 10				.word   FGC_VPU_CMD
  3957
  3958 F9A8 20 00		XMODEM_DEV	.byte	XMODEM1_ID, $00  ; XModem Device Driver Descriptor
  3959 F9AA 75 F3				.word	SERIALIN
  3960 F9AC 65 F3				.word	SERIALOUT
  3961 F9AE EA F7				.word	XMODEM_CMD
  3962
  3963 F9B0 21 00		TAPE_DEV	.byte	TAPE1_ID, $00    ; Tape Device Driver Descriptor
  3964 F9B2 4E F8				.word	_EMPTY_
  3965 F9B4 4E F8				.word	_EMPTY_
  3966 F9B6 4E F8				.word	_EMPTY_
  3967
  3968 F9B8 24 00		SDC_DEV	        .byte	SDC1_ID, $00     ; SD-Card Driver Descriptor
  3969 F9BA 4E F8				.word	_EMPTY_
  3970 F9BC 4E F8				.word	_EMPTY_
  3971 F9BE 06 F8				.word   SDC_CMD
  3972
  3973 F9C0 22 00		FDD1_DEV	.byte	FDD1_ID, $00     ; Floppy Disk Drive 1 Driver Descriptor
  3974 F9C2 4E F8				.word	_EMPTY_
  3975 F9C4 4E F8				.word	_EMPTY_
  3976 F9C6 17 10				.word   FGC_FDC_CMD
  3977
  3978 F9C8 23 00		FDD2_DEV	.byte	FDD2_ID, $00     ; Floppy Disk Drive 2 Driver Descriptor
  3979 F9CA 4E F8				.word	_EMPTY_
  3980 F9CC 4E F8				.word	_EMPTY_
  3981 F9CE 50 F8				.word   FGC_FDC_CMD2
  3982
  3983 F9D0 25 00		CFC_DEV	        .byte	HDD1_ID, $00     ; CF-Card Driver Descriptor
  3984 F9D2 4E F8				.word	_EMPTY_
  3985 F9D4 4E F8				.word	_EMPTY_
  3986 F9D6 55 F8				.word   CFC_CMD		 ; CF-card driver descriptor
  3987
  3988 				; ******************************************************************************
  3989 				; Low Byte CRC Lookup Table (XMODEM)
  3990 				; ******************************************************************************
  3991
  3992 F9D8			                ORG 	$FA00
  3993 FA00			CRCLO
  3994 FA00 00 21 42 63 84 A5 +  		.byte 	$00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
  3995 FA10 31 10 73 52 B5 94 +  		.byte 	$31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
  3996 FA20 62 43 20 01 E6 C7 +  		.byte 	$62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
  3997 FA30 53 72 11 30 D7 F6 +  		.byte 	$53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
  3998 FA40 C4 E5 86 A7 40 61 +  		.byte 	$C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
  3999 FA50 F5 D4 B7 96 71 50 +  		.byte 	$F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
  4000 FA60 A6 87 E4 C5 22 03 +  		.byte 	$A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
  4001 FA70 97 B6 D5 F4 13 32 +  		.byte 	$97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
  4002 FA80 88 A9 CA EB 0C 2D +  		.byte 	$88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
  4003 FA90 B9 98 FB DA 3D 1C +  		.byte 	$B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
  4004 FAA0 EA CB A8 89 6E 4F +  		.byte 	$EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
  4005 FAB0 DB FA 99 B8 5F 7E +  		.byte 	$DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
  4006 FAC0 4C 6D 0E 2F C8 E9 +  		.byte 	$4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
  4007 FAD0 7D 5C 3F 1E F9 D8 +  		.byte 	$7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
  4008 FAE0 2E 0F 6C 4D AA 8B +  		.byte 	$2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
  4009 FAF0 1F 3E 5D 7C 9B BA +  		.byte 	$1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
  4010
  4011 				; ******************************************************************************
  4012 				; Hi Byte CRC Lookup Table (XMODEM)
  4013 				; ******************************************************************************
  4014
  4015 FB00			                ORG 	$FB00
  4016 FB00			CRCHI
  4017 FB00 00 10 20 30 40 50 +  		.byte 	$00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
  4018 FB10 12 02 32 22 52 42 +  		.byte 	$12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
  4019 FB20 24 34 04 14 64 74 +  		.byte 	$24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
  4020 FB30 36 26 16 06 76 66 +  		.byte 	$36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
  4021 FB40 48 58 68 78 08 18 +  		.byte 	$48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
  4022 FB50 5A 4A 7A 6A 1A 0A +  		.byte 	$5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
  4023 FB60 6C 7C 4C 5C 2C 3C +  		.byte 	$6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
  4024 FB70 7E 6E 5E 4E 3E 2E +  		.byte 	$7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
  4025 FB80 91 81 B1 A1 D1 C1 +  		.byte 	$91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
  4026 FB90 83 93 A3 B3 C3 D3 +  		.byte 	$83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
  4027 FBA0 B5 A5 95 85 F5 E5 +  		.byte 	$B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
  4028 FBB0 A7 B7 87 97 E7 F7 +  		.byte 	$A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
  4029 FBC0 D9 C9 F9 E9 99 89 +  		.byte 	$D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
  4030 FBD0 CB DB EB FB 8B 9B +  		.byte 	$CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
  4031 FBE0 FD ED DD CD BD AD +  		.byte 	$FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
  4032 FBF0 EF FF CF DF AF BF +  		.byte 	$EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
    63
    64 FC00					ORG	$FC00			; start address of CF-IDE and MMU routines
    65 FC00					icl	"jc2_cf_ide.asm"	; cf-ide and MMU routines
Source: jc2_cf_ide.asm
     1 				;---------------------------------------------------------------------------
     2 				; JC2 CF-IDE Device Driver & MMU related functions.
     3 				; This program adds the necessary files for the CF-IDE Interface and the
     4 				; MMU related routines. 
     5 				;---------------------------------------------------------------------------
     6
     7 				;----------------------------------------------------------------------------
     8 				; This routine reads CF information and prints it.
     9 				;----------------------------------------------------------------------------
    10 FC00 20 B5 F8		CF_INFO		JSR CFWAIT	    	; Wait until CF-card ready
    11 FC03 A9 EC				LDA #$EC	    	; Drive ID command
    12 FC05 8D 87 0C				STA CFREG7		; CF command register
    13 FC08 20 8B F6				JSR INIT_BLKBUF		; Init. buffer-pointer
    14 FC0B 20 D1 FC				JSR CF_RD_INFO		; Read 512 bytes (= CF_RD_BLK without the Read 1 sector commands)
    15
    16 				; Print serial number
    17 FC0E A2 2D				LDX #<TXT_SER     	; Print Serial text
    18 FC10 A0 FD				LDY #>TXT_SER
    19 FC12 20 82 F6				JSR SPRINT	    	; print
    20 FC15 A9 14				LDA #<(BLOCK_BUF+20)
    21 FC17 85 DC				STA BLKBUF
    22 FC19 A9 06				LDA #>(BLOCK_BUF+20)
    23 FC1B 85 DD				STA BLKBUF+1
    24 FC1D A2 14				LDX #20			; len = 20
    25 FC1F 20 4F FC				JSR PRTRSN		; Print serial-number info
    26
    27 				; Print Firmware revision
    28 FC22 A2 39				LDX #<TXT_FW     	; Print Firmware text
    29 FC24 A0 FD				LDY #>TXT_FW
    30 FC26 20 82 F6				JSR SPRINT	    	; print
    31 FC29 A9 2E				LDA #<(BLOCK_BUF+46)
    32 FC2B 85 DC				STA BLKBUF
    33 FC2D A9 06				LDA #>(BLOCK_BUF+46)
    34 FC2F 85 DD				STA BLKBUF+1
    35 FC31 A2 08				LDX #8			; len = 8
    36 FC33 20 4F FC				JSR PRTRSN		; Print firmware info
    37
    38 				; Print Model number
    39 FC36 A2 46				LDX #<TXT_MOD     	; Print Model number text
    40 FC38 A0 FD				LDY #>TXT_MOD
    41 FC3A 20 82 F6				JSR SPRINT	    	; print
    42 FC3D A9 36				LDA #<(BLOCK_BUF+54)
    43 FC3F 85 DC				STA BLKBUF
    44 FC41 A9 06				LDA #>(BLOCK_BUF+54)
    45 FC43 85 DD				STA BLKBUF+1
    46 FC45 A2 28				LDX #40			; len = 40
    47 FC47 20 4F FC				JSR PRTRSN		; Print firmware info
    48 FC4A 20 5A E0				JSR CROUT		; Print CR
    49 FC4D 38					SEC			; C=1 (no error)
    50 FC4E 60					RTS
    51
    52 				;----------------------------------------------------------------------------
    53 				; This routine print a Big-Endian string of N characters, skipping all spaces.
    54 				; BUFPTR: points to begin of buffer to print
    55 				; X     : #bytes to print
    56 				;----------------------------------------------------------------------------
    57 FC4F A0 01		PRTRSN		LDY #1			; start at MSB
    58 FC51 B1 DC		PRTRSN1		LDA (BLKBUF),Y		; get MSB 		
    59 FC53 C9 20				CMP #' '		; skip if space
    60 FC55 F0 03				BEQ PRSNLP2		; branch if space
    61
    62 FC57 20 6C FC				JSR COUTXY		; output MSB to screen
    63 FC5A 88			PRSNLP2		DEY			; LSB now
    64 FC5B CA					DEX			; #bytes to print
    65 FC5C B1 DC				LDA (BLKBUF),Y		
    66 FC5E C9 20				CMP #' '		; skip if space
    67 FC60 F0 03				BEQ PRSNLP3		; branch if space
    68
    69 FC62 20 6C FC				JSR COUTXY		; output LSB to screen
    70 FC65 C8			PRSNLP3		INY			; 
    71 FC66 C8					INY			; points to next LSB
    72 FC67 C8					INY			; points to next MSB
    73 FC68 CA					DEX			; #bytes to print
    74 FC69 D0 E6				BNE PRTRSN1		; branch if more to print
    75 						
    76 FC6B 60					RTS			; return
    77
    78 				;----------------------------------------------------------------------------
    79 				; This routine calls COUT while preserving the values of X and Y
    80 				;----------------------------------------------------------------------------
    81 FC6C 86 D8		COUTXY		STX SAVEX		; Save X	
    82 FC6E 84 D9				STY SAVEY		; Save Y
    83 FC70 20 52 E0				JSR COUT		; Print char.
    84 FC73 A4 D9				LDY SAVEY		; Get Y back
    85 FC75 A6 D8				LDX SAVEX		; Get X back
    86 FC77 60					RTS			; return
    87
    88 				;----------------------------------------------------------------------------
    89 				; This routine sets the LBA for the CF-card to 0 (the MBR) and loads it
    90 				; into the CF-card.
    91 				;----------------------------------------------------------------------------
    92 FC78 A9 00		INIT_LBA	LDA #0
    93 FC7A 85 D2				STA CFLBA0	    	; LBA 0 (LSB)
    94 FC7C 85 D3				STA CFLBA1
    95 FC7E 85 D4				STA CFLBA2
    96 FC80 85 D5				STA CFLBA3		; LBA 3 (MSB)
    97 FC82 4C 9E FC				JMP LOAD_CFLBA		; Load into CF-card and return
    98
    99 				;----------------------------------------------------------------------------
   100 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   101 				; Input :  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
   102 				; Output: LBA in CFLBA3..CFLBA0
   103 				;----------------------------------------------------------------------------
   104 FC85 86 E6		LOAD_LBA_CF	STX PLBA		; Store pointer
   105 FC87 84 E7				STY PLBA+1
   106 FC89 A0 00				LDY #0
   107 FC8B B1 E6				LDA (PLBA),Y		; LBA 0 (LSB)
   108 FC8D 85 D2				STA CFLBA0
   109 FC8F C8					INY
   110 FC90 B1 E6				LDA (PLBA),Y		; LBA 1
   111 FC92 85 D3				STA CFLBA1
   112 FC94 C8					INY
   113 FC95 B1 E6				LDA (PLBA),Y		; LBA 2
   114 FC97 85 D4				STA CFLBA2
   115 FC99 C8					INY
   116 FC9A B1 E6				LDA (PLBA),Y		; LBA 3 (MSB)
   117 FC9C 85 D5				STA CFLBA3
   118 						;JMP LOAD_CFLBA		; Load into CF-card and return
   119
   120 				;----------------------------------------------------------------------------
   121 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   122 				; Input : CFLBA3..CFLBA0
   123 				; Output: -
   124 				;----------------------------------------------------------------------------
   125 FC9E A5 D2		LOAD_CFLBA	LDA CFLBA0		; CFLBA0 -> CFREG3
   126 FCA0 8D 83 0C				STA CFREG3		; 
   127 FCA3 A5 D3				LDA CFLBA1		; CFLBA1 -> CFREG4
   128 FCA5 8D 84 0C				STA CFREG4
   129 FCA8 A5 D4				LDA CFLBA2		; CFLBA2 -> CFREG5
   130 FCAA 8D 85 0C				STA CFREG5
   131 FCAD A5 D5				LDA CFLBA3		; CFLBA3 -> CFREG6
   132 FCAF 29 0F				AND #$0F		; Filter out LBA bits
   133 FCB1 09 E0				ORA #$E0		; Mode LBA, master dev
   134 FCB3 8D 86 0C				STA CFREG6		; Store in CFREG6
   135 FCB6 60					RTS
   136 						
   137 				;----------------------------------------------------------------------------
   138 				; Command: None, Read Single Data Block to Std. Block Buffer
   139 				; Input  : CFLBA3..CFLBA0 = 32 Bit Command Block Source Address. 
   140 				;          NOTE: These have to loaded prior to calling this function!!!
   141 				; Output : C = 0 Error, C = 1 Read OK
   142 				;	   A = Error Code
   143 				;----------------------------------------------------------------------------
   144 FCB7 20 8B F6		CF_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   145 FCBA F0 06				BEQ	CF_RD_BLK		; branch always
   146
   147 				;----------------------------------------------------------------------------
   148 				; Command: CMD_READ_BUF, Read Single Data Block from Logical Address to Std. Block Buffer
   149 				; Input  :  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   150 				; Output :  C   = 0 Error, C = 1 Data OK
   151 				;	    A   = Error Code
   152 				;----------------------------------------------------------------------------
   153 FCBC 20 8B F6		CF_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   154 										; fall through to CF_RD_LBLK
   155
   156 				;----------------------------------------------------------------------------
   157 				; Command: CMD_READ, Read Single Data Block from Logical Address
   158 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   159 				;	   BLKBUF,BLKBUFH = 16 Bit Destination Address
   160 				; Output : C = 0 Error, C = 1 Data OK
   161 				;	   A = Error Code
   162 				;----------------------------------------------------------------------------
   163 FCBF 20 85 FC		CF_RD_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   164 										; fall through to CF_RD_BLK
   165
   166 				;----------------------------------------------------------------------------
   167 				; Read Single Data Block
   168 				; Input:  CFLBA3..CFLBA0 = 32 Bit LBA Address
   169 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
   170 				; Output: C = 0 Error, C = 1 Read OK
   171 				;	  A = Error Code
   172 				;----------------------------------------------------------------------------
   173 FCC2 A9 01		CF_RD_BLK	LDA 	#$01
   174 FCC4 8D 82 0C				STA 	CFREG2			; Read one Sector
   175 FCC7 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   176 FCCA 90 24				BCC 	CF_RD_END		; branch on error
   177
   178 FCCC A9 20				LDA 	#$20			; Read Sector Command
   179 FCCE 8D 87 0C				STA 	CFREG7			; CF command register
   180 FCD1 A2 01		CF_RD_INFO	LDX	#$01			; initialize page counter
   181 FCD3 A0 00				LDY	#$00			; initialize byte counter
   182 FCD5 20 B5 F8		CF_RD_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   183 FCD8 90 16				BCC	CF_RD_END		; Exit on CF-card error
   184
   185 FCDA AD 87 0C				LDA 	CFREG7			; CF status register
   186 FCDD 29 08				AND 	#$08			; Filter out DRQ
   187 FCDF F0 0F				BEQ 	CF_RD_END		; branch if DRQ is no longer set
   188
   189 FCE1 AD 80 0C				LDA 	CFREG0			; read data-bytes
   190 FCE4 91 DC				STA 	(BLKBUF),Y		; store in buffer
   191 FCE6 C8					INY				; next byte
   192 FCE7 D0 EC				BNE 	CF_RD_BLK0		; branch if more bytes to read
   193
   194 FCE9 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   195 FCEB CA					DEX
   196 FCEC 10 E7				BPL	CF_RD_BLK0		; two pages read? no, read next byte
   197 						
   198 FCEE 38					SEC				; yes, all data read, set C = 1 (no error)
   199 FCEF 60					RTS
   200 FCF0 18			CF_RD_END	CLC				; C=0 (error), DRQ reset should not happen
   201 FCF1 60					RTS
   202
   203 				;----------------------------------------------------------------------------
   204 				; Command: None, Write Single Data Block from Std. Block Buffer
   205 				; Input  : CFLBA3..CFLBA0 = 32 Bit LBA Address to write to
   206 				;          NOTE: These have to loaded prior to calling this function!!!
   207 				; Output : C = 0 Error, C = 1 Read OK
   208 				;	   A = Error Code
   209 				;----------------------------------------------------------------------------
   210 FCF2 20 8B F6		CF_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   211 FCF5 F0 06				BEQ	CF_WR_BLK		; branch always
   212
   213 				;----------------------------------------------------------------------------
   214 				; Command: WRITE_BUF, Write Single Data Block from Std. Block Buffer to Logical Address
   215 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   216 				; Output : C = 0 Error, C = 1 Data OK
   217 				;	   A = Error Code
   218 				;----------------------------------------------------------------------------
   219 FCF7 20 8B F6		CF_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   220 										; fall through to CR_WR_LBLK
   221
   222 				;----------------------------------------------------------------------------
   223 				; Command: CMD_WRITE, Write Single Data Block to Logical Address
   224 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   225 				;	   BLKBUF,BLKBUFH = 16 Bit Source Address
   226 				; Output : C = 0 Error, C = 1 Data OK
   227 				;	   A = Error Code
   228 				;----------------------------------------------------------------------------
   229 FCFA 20 85 FC		CF_WR_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   230 										; fall through to CF_WR_BLK
   231
   232 				;----------------------------------------------------------------------------
   233 				; Write Single Data Block
   234 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   235 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
   236 				; Output: C = 0 Error, C = 1 Write OK
   237 				;	  A = Error Code
   238 				;----------------------------------------------------------------------------
   239 FCFD A9 01		CF_WR_BLK	LDA 	#$01
   240 FCFF 8D 82 0C				STA 	CFREG2			; Read one Sector
   241 FD02 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   242 FD05 90 24				BCC 	CF_WR_END		; branch on error
   243
   244 FD07 A9 30				LDA 	#$30			; Write Sector Command
   245 FD09 8D 87 0C				STA 	CFREG7			; CF command register
   246 FD0C A2 01		CF_WR_INFO	LDX	#$01			; initialize page counter
   247 FD0E A0 00				LDY	#$00			; initialize byte counter
   248 FD10 20 B5 F8		CF_WR_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   249 FD13 90 16				BCC	CF_WR_END		; Exit on CF-card error
   250
   251 FD15 AD 87 0C				LDA 	CFREG7			; CF status register
   252 FD18 29 08				AND 	#$08			; Filter out DRQ
   253 FD1A F0 0F				BEQ 	CF_WR_END		; branch if DRQ is no longer set
   254
   255 FD1C B1 DC				LDA 	(BLKBUF),Y		; read from buffer
   256 FD1E 8D 80 0C				STA 	CFREG0			; Write to CF-card
   257 FD21 C8					INY				; next byte
   258 FD22 D0 EC				BNE 	CF_WR_BLK0		; branch if more bytes to write
   259
   260 FD24 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   261 FD26 CA					DEX
   262 FD27 10 E7				BPL	CF_WR_BLK0		; two pages read? no, read next byte
   263 						
   264 FD29 38					SEC				; yes, all data read, set C = 1 (no error)
   265 FD2A 60					RTS
   266 						
   267 FD2B 18			CF_WR_END	CLC				; C=0 (error), DRQ reset should not happen
   268 FD2C 60					RTS
   269
   270 				;----------------------------------------------------------------------------
   271 				; Text-strings needed for Printing
   272 				;----------------------------------------------------------------------------
   273 FD2D 20 20 20 53 65 72 + TXT_SER		.by        '   Serial: ' $00
   274 FD39 0D 20 46 69 72 6D + TXT_FW		.by     CR ' Firmware: ' $00
   275 FD46 0D 20 20 20 20 4D + TXT_MOD		.by     CR '    Model: ' $00
   276
   277 				;----------------------------------------------------------------------------
   278 				; This function enables a RAM-bank at $4000-$7FFF.
   279 				; Input: X: the RAM-bank number to enable [0..28]. A RAM-bank starts at 4,
   280 				;           so 0..3 disables the RAM-banks and enables main-memory
   281 				;----------------------------------------------------------------------------
   282 FD53 AD 00 17		SET_RAMBANK	LDA	MMU		; Get MMU register
   283 FD56 29 83				AND	#$83		; Set RAM-bank bits 6..2 to 0
   284 FD58 8D 00 17				STA	MMU		; Update MMU register
   285 FD5B 8A					TXA			; A is now RAM-bank number
   286 FD5C C9 1D				CMP	#29		; RAM-bank 28 is the highest nr
   287 FD5E B0 04				BCS	SET_RAMB0	; branch if >= 29
   288 FD60 C9 04				CMP	#4		; <= 28, now check for >= 4
   289 FD62 B0 02				BCS	RAMBVLD		; branch if >= 4
   290 						
   291 FD64 A9 00		SET_RAMB0	LDA	#0		; set to no RAM-bank (main-memory)
   292 FD66 0A			RAMBVLD		ASL
   293 FD67 0A					ASL			; nr now in RAM-bank bits 6..2
   294 FD68 0D 00 17				ORA	MMU		; add to MMU-register
   295 FD6B 8D 00 17				STA	MMU		; Enable RAM-bank
   296 FD6E 60					RTS			; return
   297 						
   298 				;----------------------------------------------------------------------------
   299 				; This function returns the currently active RAM-bank at $4000-$7FFF.
   300 				; Output: A: the active RAM-bank number [4..28] or 0 if no RAM-bank is selected.
   301 				;----------------------------------------------------------------------------
   302 FD6F AD 00 17		GET_RAMBANK	LDA	MMU		; MMU-register
   303 FD72 29 7C				AND	#$7C		; Only RAM-bank bits
   304 FD74 4A					LSR
   305 FD75 4A					LSR			; Now in bits 4..0
   306 FD76 C9 04				CMP	#4		; Is it 4 or more?
   307 FD78 B0 02				BCS	RAMBX		; branch if >= 4, RAM-bank selected
   308 						
   309 FD7A A9 00				LDA	#0		; RAM-bank 0..3 => main memory
   310 FD7C 60			RAMBX		RTS			; return		
   311 						
   312 				;----------------------------------------------------------------------------
   313 				; This function enables Monitor-ROM at $1C00-$1FFF and disables the RAM behind it.
   314 				;----------------------------------------------------------------------------
   315 FD7D AD 00 17		MON2ROM		LDA	MMU		; MMU-register
   316 FD80 09 02				ORA	#MON_EN		; 1 = enable Monitor ROM
   317 FD82 8D 00 17				STA	MMU		; Activate Monitor ROM
   318 FD85 60					RTS			; return
   319 						
   320 				;----------------------------------------------------------------------------
   321 				; This function Enables Monitor-RAM at $1C00-$1FFF and disables Monitor-ROM.
   322 				;----------------------------------------------------------------------------
   323 FD86 AD 00 17		MON2RAM		LDA	MMU		; MMU-register
   324 FD89 29 FD				AND	#~MON_EN	; 0 = enable Monitor RAM, disable ROM
   325 FD8B 8D 00 17				STA	MMU		; Activate Monitor RAM
   326 FD8E 60					RTS			; return
   327
   328 				;----------------------------------------------------------------------------------		
   329 				; This routine disables the BASIC ROM and enables the RAM behind it.
   330 				;----------------------------------------------------------------------------------		
   331 FD8F AD 00 17		BAS2RAM		LDA	MMU			; MMU register		
   332 FD92 29 7F				AND 	#~BAS_EN		; Set bit to 0, disable BASIC		   
   333 FD94 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   334 FD97 60					RTS				; return
   335
   336 				;----------------------------------------------------------------------------------		
   337 				; This routine enables the BASIC ROM and disables the RAM behind it.
   338 				;----------------------------------------------------------------------------------		
   339 FD98 AD 00 17		BAS2ROM		LDA	MMU			; MMU register		
   340 FD9B 09 80				ORA 	#BAS_EN			; Set bit to 0, disable BASIC		   
   341 FD9D 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   342 FDA0 60					RTS				; return
   343
   344 				;----------------------------------------------------------------------------
   345 				; Check both ROMs: 
   346 				; 1) Monitor ROM at $1C00-$1FFF
   347 				; 2) BASIC + BIOS ROM at $B000-$FFF0
   348 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   349 				;        X: LSB of end-Address
   350 				;        Y: MSB of end-Address
   351 				;----------------------------------------------------------------------------
   352 FDA1 A9 1C		CHECK_ROMS	LDA	#$1C		; MSB of $1C00
   353 FDA3 A2 00				LDX	#$00		; LSB of $1FFF+1 (end-address)
   354 FDA5 A0 20				LDY	#$20		; MSB of $1FFF+1 (end-address)
   355 FDA7 20 B9 FD				JSR	CHECK_ROM_STRT	; Check Monitor ROM Checksum
   356 FDAA A9 B0				LDA	#$B0		; MSB of $B000
   357 FDAC A2 00				LDX	#$00		; LSB of $DFFF+1 (end-address)
   358 FDAE A0 E0				LDY	#$E0		; MSB of $DFFF+1 (end-address)
   359 FDB0 20 B9 FD				JSR	CHECK_ROM_STRT	; Check BASIC ROM Checksum
   360 FDB3 A9 E0				LDA	#$E0		; MSB of $B000
   361 FDB5 A2 F0				LDX	#$F0		; LSB of $FFF0 (end-address)
   362 FDB7 A0 FF				LDY	#$FF		; MSB of $FFF0 (end-address)
   363 						;JMP 	CHECK_ROM_STRT	; Check BIOS ROM checksum and return
   364 						
   365 				;----------------------------------------------------------------------------
   366 				; This routine is the entry-point for the ROM checksum routines.
   367 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   368 				;        X: LSB of end-Address
   369 				;        Y: MSB of end-Address
   370 				;----------------------------------------------------------------------------
   371 FDB9 86 CC		CHECK_ROM_STRT	STX	END_PTR		; LSB of end-address
   372 FDBB 84 CD				STY	END_PTR+1	; MSB of end-address
   373 FDBD A2 00				LDX	#0
   374 FDBF 86 D0				STX 	ROM_CS		; Init ROM checksum
   375 FDC1 86 D1				STX 	ROM_CS+1
   376 FDC3 86 CE				STX	ROM_PTR		; LSB of begin-address
   377 FDC5 85 CF				STA	ROM_PTR+1	; MSB of begin-address
   378 FDC7 C9 1C				CMP	#$1C		; Monitor ROM?
   379 FDC9 F0 10				BEQ	MON_CHK_ROM	; branch if Monitor ROM
   380 						
   381 FDCB C9 B0				CMP	#$B0		; BASIC ROM?
   382 FDCD F0 06				BEQ	BAS_CHK_ROM	; branch if BASIC ROM
   383
   384 FDCF A2 6E				LDX	#<TXT_ROM	; BIOS ROM
   385 FDD1 A0 FE				LDY	#>TXT_ROM
   386 FDD3 D0 0A				BNE 	PR_CHKROM_TXT	; branch always
   387 						
   388 FDD5 A2 64		BAS_CHK_ROM	LDX	#<TXT_BAS	; BASIC ROM
   389 FDD7 A0 FE				LDY	#>TXT_BAS
   390 FDD9 D0 04				BNE 	PR_CHKROM_TXT	; branch always
   391
   392 FDDB A2 5A		MON_CHK_ROM	LDX	#<TXT_MON	; Monitor ROM
   393 FDDD A0 FE				LDY	#>TXT_MON
   394 FDDF 20 82 F6		PR_CHKROM_TXT	JSR	SPRINT
   395 FDE2 A2 78				LDX	#<TXT_CS	; Print ' KB ROM '
   396 FDE4 A0 FE				LDY	#>TXT_CS
   397 FDE6 20 82 F6				JSR	SPRINT
   398 FDE9 A0 00				LDY	#0
   399 						;JMP	ROM_LP1		; fall-through to ROM_LP1
   400
   401 				;----------------------------------------------------------------------------
   402 				; This routine calculates the checksum of the entire ROM area from 
   403 				; ROM_PTR to END_PTR.
   404 				;----------------------------------------------------------------------------
   405 FDEB B1 CE		ROM_LP1		LDA 	(ROM_PTR),Y	; get byte from ROM
   406 FDED					ADCAW	ROM_CS		; ROM_CS = ROM_CS + A
Macro: ADCAW [Source: jc2_defines.inc]
     1 FDED 18					CLC
     2 FDEE 65 D0				ADC	ROM_CS
     3 FDF0 85 D0				STA	ROM_CS
     4 FDF2 A5 D1				LDA	ROM_CS+1
     5 FDF4 69 00				ADC	#0
     6 FDF6 85 D1				STA	ROM_CS+1
Source: jc2_cf_ide.asm
   407 FDF8 C8					INY			; next byte
   408 FDF9 D0 02				BNE	ROM_CHK_END	; branch if not on a new page
   409 						
   410 FDFB E6 CF				INC 	ROM_PTR+1	; MSB, next page
   411 FDFD A5 CF		ROM_CHK_END	LDA	ROM_PTR+1	; Current ROM address MSB
   412 FDFF C5 CD				CMP	END_PTR+1	; MSB of end-address
   413 FE01 D0 E8				BNE	ROM_LP1		; branch if not done yet
   414 						
   415 FE03 C4 CC				CPY	END_PTR		; End-address?
   416 FE05 D0 E4				BNE	ROM_LP1		; branch if not at end-address yet
   417 						
   418 FE07 A5 CD				LDA	END_PTR+1
   419 FE09 C9 FF				CMP	#$FF		; BIOS ROM?
   420 FE0B D0 10				BNE	ROM_CHK2	; branch if not BIOS ROM
   421 						
   422 FE0D A5 D1 CD F9 FF D0 + 		CPW	ROM_CS ROM_CS16	; Compare 2 words BIOS checksum
   423 FE19 D0 2B				BNE	ROM_CS_ERR	; branch if not the same
   424 FE1B F0 22				BEQ	ROM_CS_OK	; branch if the same
   425
   426 FE1D C9 E0		ROM_CHK2	CMP	#$E0		; BASIC ROM?
   427 FE1F D0 10				BNE	MON_ROM_CMP	; branch if Monitor ROM
   428 						
   429 FE21 A5 D1 CD F7 FF D0 + 		CPW	ROM_CS BAS_CS16	; Compare 2 words BASIC checksum
   430 FE2D D0 17				BNE	ROM_CS_ERR	; branch if not the same
   431 FE2F F0 0E				BEQ	ROM_CS_OK	; branch if the same
   432 						
   433 FE31 A5 D1 CD F5 FF D0 + MON_ROM_CMP	CPW	ROM_CS MON_CS16	; Compare 2 words Monitor checksum
   434 FE3D D0 07				BNE	ROM_CS_ERR	; branch if not the same
   435
   436 FE3F A2 81		ROM_CS_OK	LDX	#<TXT_CS_OK	; Print 'OKE'
   437 FE41 A0 FE				LDY	#>TXT_CS_OK
   438 FE43 4C 82 F6				JMP	SPRINT		; Print and return
   439 FE46 A2 85		ROM_CS_ERR	LDX	#<TXT_CS_ERR	; Print 'Error'
   440 FE48 A0 FE				LDY	#>TXT_CS_ERR
   441 FE4A 4C 82 F6				JMP	SPRINT		; Print and return
   442
   443 				;----------------------------------------------------------------------------
   444 				; This routine prints a string to the terminal: X=LSB, Y=MSB.
   445 				; In order not to interfere with the BIOS STROUT / WRSTR with PSTR, a copy
   446 				; of these routines is made with SPRINT and SPROUT.
   447 				;----------------------------------------------------------------------------
   448 FE4D A0 00		SPROUT		LDY  	#$00       	; index y is 0
   449 FE4F B1 CA		SPROUTLP	LDA  	(PRSTR),Y   	; load char at string pos y
   450 FE51 F0 06				BEQ  	ENDSPROUT  	; exit, if NULL char
   451 						
   452 FE53 20 52 E0				JSR  	COUT       	; write character
   453 FE56 C8					INY             	; next index
   454 FE57 D0 F6				BNE  	SPROUTLP	; branch always
   455 						
   456 FE59 60			ENDSPROUT	RTS			; return
   457
   458 FE5A 20 4A 43 2D 4D 4F + TXT_MON		.by	' JC-MON 1' $00
   459 FE64 20 42 41 53 49 43 + TXT_BAS		.by	' BASIC 12' $00
   460 FE6E 20 42 49 4F 53 20 + TXT_ROM		.by	' BIOS   8' $00
   461 FE78 20 4B 42 20 52 4F + TXT_CS		.by	' KB ROM ' $00
   462 FE81 4F 4B 0D 00		TXT_CS_OK	.by	'OK' CR $00
   463 FE85 45 72 72 6F 72 0D + TXT_CS_ERR	.by	'Error' CR $00		
   464 								
   465
   466
   467
   468
   469
   470
   471
   472
   473
   474
   475
   476
   477 						
    66 						
    67 				;----------------------------------------------------------------------------
    68 				;       VECTORS AT THE END OF THE ROM AREA
    69 				;----------------------------------------------------------------------------
    70 FE8C					ORG	$FFEE
    71 FFEE 6C 7A 1A		NMI_JMP_VEC    	JMP     (NMIVECT)		; Jump to a user selectable NMI vector (moved from Monitor $1F2F)
    72 FFF1 6C 7E 1A		IRQ_JMP_VEC    	JMP     (IRQVECT)		; Jump to a user selectable IRQ vector (moved from Monitor $1F32)
    73 FFF4 00 00		MON_CS16	.word	$000			;  1 KB Monitor ROM checksum
    74 FFF6 00 00		BAS_CS16	.word	$000			; 12 KB BASIC ROM checksum
    75 FFF8 00 00		ROM_CS16	.word	$000			;  8 KB BIOS ROM checksum
    76 FFFA EE FF		NMI_VECTOR	.word	NMI_JMP_VEC		; This was $1F2F in Junior Computer Monitor program
    77 FFFC 00 E0		RESET_VECTOR	.word  	MON_COLD_START		; $E000 (was $1C1D in Junior Computer Monitor program)
    78 FFFE F1 FF		IRQ_BRK_VECTOR	.word	IRQ_JMP_VEC		; This was $1F32 in Junior Computer Monitor program
    79
    80 						END
