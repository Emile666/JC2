mads 2.1.7 build 33 (1 Aug 24)
Source: jc2_main.asm
     1 				; ------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS Version 1.2.2 by Joerg Walke
     3 				;
     4 				; 21-04-25: v1.2.0 Emile, Integration into 1 eprom
     5 				; 08-05-25: v1.2.1 -Basic update (v2.22 patches + I2COUT, I2CIN and DOS commands)
     6 				;                  -CF_LOAD_VEC/CF_SAVE_VEC added, RETURN_VECT moved to $180A 
     7 				;                  -Address corrections to maintain V1.1.4 compatibility (broken in V1.2.0)
     8 				; 19-05-25: v1.2.2 -ZP addresses reorganised to avoid conflicts between Basic, BIOS & boot.sys.
     9 				;		   -NMI & IRQ JMP vectors moved from Monitor to here to prepare for Monitor ROM switching
    10 				; ------------------------------------------------------------------------------
    11 = 0031			VERMAIN   	EQU     '1'    			; BIOS main version
    12 = 0032			VERPSUB    	EQU     '2'    			; BIOS primary sub version
    13 = 0032			VERSSUB		EQU	'2'			; BIOS secondary sub version
    14
    15 				        	OPT h-                          ; no DOS file-header
    16 				        	OPT f+                          ; save as single block
    17
    18 				        	icl 	"jc2_defines.inc"  	; all address defines for the JC-II
Source: jc2_defines.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor CONSTANTS
     3 				;------------------------------------------------------------------------------ 
     4
     5 				; PIA Register Indices *********************************************************
     6 = 000C			PIA_PORTA       EQU     $0C             ; Port A input/output register
     7 = 000D			PIA_PORTB       EQU     $0D             ; Port B input/output register
     8 = 000E			PIA_PORTC       EQU     $0E             ; Port C input/output register
     9 = 000F			PIA_CONTROL     EQU     $0F             ; Control/Setup register
    10
    11 				; Memory Management Unit (MMU) Register Indices ********************************
    12 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    13 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    14 = 0080			BAS_EN		EQU	$80		; PORTB bit 7: 1 = enable BASIC at $B000
    15
    16 				; VIA 1 Register Indices *******************************************************
    17 = 0000			VIA_PORTB     	EQU  	$00  		; Port B input/output register
    18 = 0001			VIA_PORTA     	EQU  	$01  		; Port A input/output register
    19 = 0002			VIA_DDRB   	EQU  	$02		; Port B data direction register
    20 = 0003			VIA_DDRA   	EQU  	$03		; Port A data direction register
    21 = 0004			VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
    22 = 0005			VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
    23 = 0006			VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
    24 = 0007			VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
    25 = 0008			VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
    26 = 0009			VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
    27 = 000A			VIA_SR     	EQU  	$0A		; Shift register
    28 = 000B			VIA_ACR    	EQU  	$0B		; Auxilary control register
    29 = 000C			VIA_PCR    	EQU  	$0C		; Periheral control register
    30 = 000D			VIA_IFR    	EQU  	$0D		; Interrupt flag register
    31 = 000E			VIA_IER    	EQU  	$0E		; Interrupt enable register
    32 = 000F			VIA_PANOHS 	EQU  	$0F
    33
    34 				; VIA 2 Register Indices *******************************************************
    35 = 0010			PORTB     	EQU  	$10  		; Port B input/output register
    36 = 0011			PORTA     	EQU  	$11  		; Port A input/output register
    37 = 0012			DDRB   		EQU  	$12		; Port B data direction register
    38 = 0013			DDRA   		EQU  	$13		; Port A data direction register
    39 = 0014			T1CL   		EQU  	$14		; Timer 1 counter low byte register
    40 = 0015			T1CH   		EQU  	$15		; Timer 1 counter high byte register
    41 = 0016			T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
    42 = 0017			T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
    43 = 0018			T2CL   		EQU  	$18		; Timer 2 counter low byte register
    44 = 0019			T2CH   		EQU  	$19		; Timer 2 counter high byte register
    45 = 001A			SR     		EQU  	$1A		; Shift register
    46 = 001B			ACR    		EQU  	$1B		; Auxilary control register
    47 = 001C			PCR    		EQU  	$1C		; Peripheral control register
    48 = 001D			IFR    		EQU  	$1D		; Interrupt flag register
    49 = 001E			IER    		EQU  	$1E		; Interrupt enable register
    50 = 001F			PANOHS 		EQU  	$1F
    51
    52 = 0020			CENTURY		EQU	$20		; the 20th century. change to travel in time
    53 = 002E			DATEDIV		EQU	'.'		; divider char for date string
    54 = 003A			TIMEDIV		EQU	':'		; divider char for time string
    55 = 002A			PROMPT    	EQU     '*'    		; prompt character
    56 = 002D			ADIV      	EQU     '-'    		; address divider
    57 = 0001			SOH       	EQU     $01    		; start of header
    58 = 0004			EOT       	EQU     $04    		; end of text
    59 = 0006			ACK       	EQU     $06    		; acknowledged
    60 = 0008			BS        	EQU     $08    		; backspace key
    61 = 000D			CR        	EQU     $0D    		; carriage return
    62 = 000A			LF	  	EQU     $0A    		; line feed
    63 = 0015			NAK       	EQU     $15    		; not acknowledged
    64 = 0018			CAN		EQU     $18		; Cancel
    65 = 001B			ESC       	EQU     $1B    		; ESC
    66 = 0020			SPC		EQU     $20		; space char
    67
    68 				; Tape Reader/Writer Constants *************************************************
    69 = 002E			SYNCMARK	EQU	$2E		; synchronisation mark
    70 = 00A0			NAMEMARK	EQU	$A0		; start of name mark
    71 = 00A1			ADDRMARK	EQU	$A1		; start of address mark
    72 = 001F			FILEMARK	EQU	$1F		; start of file mark
    73
    74 = 0031			RPTIME		EQU	49		; read point time   49x8uS     = 392uS
    75 = 00BE			LPTIME		EQU	190		; long pulse time   190uS+50uS = 240uS
    76 = 003C			SPTIME		EQU	60		; short pulse time  60uS+50uS  = 120uS
    77
    78 				; Device Driver Constants ******************************************************
    79 = 0081			KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
    80
    81 = 0010			COM_DEV	        EQU	$10             ; COM devices base ID
    82 = 0020			STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
    83
    84 = 0000			NULL_ID		EQU	$00             ; the NULL device
    85
    86 = 0010			TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
    87 = 0011			PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
    88 = 0012			PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
    89 = 0013			KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
    90 = 0014			KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
    91 = 0015			VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
    92
    93 = 0020			XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
    94 = 0021			TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
    95 = 0022			FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
    96 = 0023			FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
    97 = 0024			SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
    98 = 0025			HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID (CF-card)
    99 = 0026			HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
   100
   101 				; Device Command Constants *****************************************************
   102 = 0000			CMD_INIT	EQU	0               ; Init device
   103 = 0001			CMD_IDENTIFY	EQU	1               ; Identify device
   104 = 0002			CMD_NORMAL	EQU	2               ; Set normal text
   105 = 0003			CMD_INVERSE	EQU	3               ; Set inverse text
   106 = 0004			CMD_FLASH	EQU	4               ; Set blinking text
   107 = 0005			CMD_HOME	EQU	5               ; Set cursor to home position
   108 = 0006			CMD_CLRLINE	EQU	6               ; Clear line at cursor
   109 = 0007			CMD_CLRSCRN	EQU	7               ; Clear screen
   110 = 0008			CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   111
   112 = 0010			CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   113 = 0011			CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
   114
   115 = 0020			CMD_LOAD	EQU	32              ; Load data byte from device
   116 = 0021			CMD_SAVE	EQU	33              ; Save data byte to device
   117 = 0022			CMD_READ	EQU	34              ; Read data block from device
   118 = 0023			CMD_WRITE	EQU	35              ; Write data block to device
   119 = 0024			CMD_BOOT        EQU     36              ; Boot from device
   120 = 0025			CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   121 = 0026			CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
   122
   123 				; SD Command Constants *********************************************************
   124 = 0040			CMD0		EQU	$40		; Reset SD-Card
   125 = 0041			CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   126 = 0048			CMD8		EQU	CMD0 + 8	; Check voltage range
   127 = 004D			CMD13		EQU	CMD0 + 13	;
   128 = 0050			CMD16		EQU	CMD0 + 16	; Change block size
   129 = 0051			CMD17		EQU	CMD0 + 17	; Read single block
   130 = 0058			CMD24		EQU	CMD0 + 24	; Write single block
   131 = 0077			CMD55		EQU	CMD0 + 55	; Application command prefix
   132 = 007A			CMD58		EQU	CMD0 + 58	; Get OCR
   133 = 0069			ACMD41		EQU	CMD0 + 41	; Initialize SDC
   134
   135 = 00FE			DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
   136
   137 				;----------------------------------------------------------------------------
   138 				; CF-IDE Hardware Registers
   139 				;----------------------------------------------------------------------------
   140 = 0C80			CFBASE		EQU 	$0C80		; Base card-address for CF-IDE card
   141 = 0C80			CFREG0		EQU	CFBASE+0	; Data port
   142 = 0C81			CFREG1		EQU	CFBASE+1	; Read: error-code, write: feature
   143 = 0C82			CFREG2		EQU	CFBASE+2	; Number of sectors to transfer
   144 = 0C83			CFREG3		EQU	CFBASE+3	; Sector address LBA 0 [0:7] (LSB)
   145 = 0C84			CFREG4		EQU	CFBASE+4	; Sector address LBA 1 [8:15]
   146 = 0C85			CFREG5		EQU	CFBASE+5	; Sector address LBA 2 [16:23]
   147 = 0C86			CFREG6		EQU	CFBASE+6	; Sector address LBA 3 [24:27] (MSB)
   148 = 0C87			CFREG7		EQU	CFBASE+7	; Read: Status, Write: Command
   149 = 0C88			CFREG8		EQU	CFBASE+8	; A write with 0x00 is a HW reset
   150
   151 				; Block Device Constants *******************************************************
   152 = 0400			MOUNT_TABLE     EQU     $0400           ; Table of mounted devices
   153 = 0400			BOOT_PART       EQU     MOUNT_TABLE     ; Boot Medium Descriptor
   154 = 0600			BLOCK_BUF	EQU	$0600           ; Block Device Block Buffer
   155 = 0600			MBR             EQU     BLOCK_BUF       ; Master Boot Block Code
   156 = 07BE			PART0		EQU	$07BE		; Partition 0 start
   157 = 07C6			PART0_RS	EQU	PART0 + 8 	; Partition 0 relative sector field
   158 = 07CE			PART0_SIZE	EQU	PART0 + 16	; Partition 0 sector size field
   159
   160 = 07FE			BOOTBLK_TAG     EQU     $07FE           ; Address of Boot Block Tag ($55 $AA)
   161
   162 				; Miscellaneous Constants ******************************************************
   163 = 0068			I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
   164
   165 = 1000			FGC_BASE        EQU     $1000
   166 = 1010			FGC_INFO        EQU     FGC_BASE+$10
   167 = 1013			FGC_SET_PAGE    EQU     FGC_BASE+$13
   168 = 1017			FGC_FDC_CMD     EQU     FGC_BASE+$17
   169 = 101F			FGC_VPU_CMD     EQU     FGC_BASE+$1F
   170 = 1027			FGC_VPU_OUT     EQU     FGC_BASE+$27
   171
   172 = 1009			VPU_PORT1       EQU     FGC_BASE+$09    ; VPU Port 1
   173 = 0080			VPU_REG0        EQU     $80             ; VPU register 0
   174 = 008F			VPU_REG15       EQU     VPU_REG0+15     ; VPU status register pointer
   175 = 0000			VPU_STAT0       EQU     0               ; VPU status register 0
   176
   177 				;------------------------------------------------------------------------------
   178 				; Junior Computer ][ BIOS & Monitor Address defines
   179 				;------------------------------------------------------------------------------ 
   180
   181 				; Card Base Addresses **********************************************************
   182 = 0014			IOBASE		EQU	$14		; pointer to IO card base
   183 = 0014			IOBASEL		EQU	$14		; always $00
   184 = 0015			IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
   185 = 0016			FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
   186 = 0016			FGCBASEL	EQU	$16		; always $00
   187 = 0017			FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always be K4 = $10
   188 = 0018			CARD3BASE	EQU	$18		; reserved (controller base)
   189 = 0018			CARD3BASEL	EQU	$18		; always $00
   190 = 0019			CARD3BASEH	EQU	$19		;K2 = $08, K3 = $0C, K4 = $10
   191
   192 				;-----------------------------------------------------------------------------
   193 				; Addresses up to $9C are in use by BASIC, see jc2_basic.asm
   194 				; Addresses from $A0 up to $AF are in use by DOS and boot.sys
   195 				;-----------------------------------------------------------------------------
   196
   197 = 00C9			DEVID		EQU	$C9		; 1-byte temp device id (moved from $03 to avoid Basic collision)
   198 = 00CA			PRSTR		EQU	$CA		; 2-bytes replacement for PSTR
   199 = 00CC			END_PTR		EQU	$CC		; ROM end-pointer (2 bytes), also used by BASIC
   200 = 00CE			ROM_PTR		EQU	$CE		; ROM pointer (2 bytes)
   201 = 00CE			FILE_PTR	EQU	$CE		; Start of file pointer (2 bytes), used by BASIC
   202 = 00D0			ROM_CS		EQU	$D0		; ROM checksum counter (2 bytes)
   203 = 00D2			CFLBA0          EQU     $D2		; CF-card LBA 0 [0:7]
   204 = 00D3			CFLBA1          EQU     $D3		; CF-card LBA 1 [8:15]
   205 = 00D4			CFLBA2          EQU     $D4		; CF-card LBA 2 [16:23]
   206 = 00D5			CFLBA3          EQU     $D5		; CF-card LBA 3 [24:27]
   207 = 00D6			MSEC		EQU	$D6		; msec time-out counter
   208 = 00D7			RSTACT		EQU	$D7		; 1 = Reset Pending
   209 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register
   210 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register
   211 = 00DA			TICKCNT         EQU     $DA             ; current tick counter
   212 = 00DB			SD_TYPE		EQU	$DB		; SD Card Type: $00 Byte mode, $40 LBA mode
   213 = 00DC			BLKBUF		EQU	$DC             ; pointer to block buffer
   214 = 00DC			BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
   215 = 00DC			CHECKSUM	EQU	$DC		; TAPE file checksum
   216 = 00DC			CRCL      	EQU   	$DC      	; XModem CRC lo byte
   217 = 00DD			BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
   218 = 00DD			OUTBYTE		EQU	$DD		; TAPE data byte read/written from/to tape
   219 = 00DD			CRCH      	EQU   	$DD     	; XModem CRC hi byte
   220 = 00DE			SD_CMD		EQU	$DE		; SD-Card CMD Byte
   221 = 00DE			RETRYL    	EQU   	$DE      	; XModem retry counter lo byte
   222 = 00DE			PDEV		EQU	$DE		; device descriptor pointer
   223 = 00DE			PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
   224 = 00DF			SD_PB3      	EQU   	$DF   		; SD-Card Parameter Byte 3
   225 = 00DF			RETRYH    	EQU   	$DF      	; XModem retry counter hi byte
   226 = 00DF			PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
   227
   228 = 00E0			SD_PB2		EQU   	$E0   		; SD-Card Parameter Byte 2
   229 = 00E0			BAUDRATE  	EQU   	$E0    		; ACIA current baud rate
   230 = 00E0			OPCODE		EQU	$E0		; DISASSEM current opcode
   231 = 00E0			I2C_DATA	EQU	$E0		; I2C current I2C data byte
   232 = 00E0			BLKEND      	EQU     $E0		; XModem block end flag
   233 = 00E1			KEY     	EQU     $E1   		; MON 1-byte Editor 
   234 = 00E1			SD_PB1      	EQU   	$E1   		; SD-Card Parameter Byte 1
   235 = 00E1			LINECNT		EQU	$E1		; DISASSEM number of disassembled lines
   236 = 00E1			BFLAG     	EQU   	$E1      	; XModem block flag
   237 = 00E1			EQUFLAG		EQU	$E1		; TAPE file name equal flag
   238 = 00E2			BEGADR  	EQU     $E2   		; MON 2-byte Editor Begin Address Pointer
   239 = 00E2			SD_PB0		EQU	$E2   		; SD-Card Parameter Byte 0
   240 = 00E2			ADRMODE		EQU	$E2		; DISASSEM addressing mode
   241 = 00E2			BLKNO     	EQU   	$E2      	; XModem block number
   242 = 00E3			SD_CRC		EQU	$E3   		; SD-Card CRC Byte
   243 = 00E3			IBYTES		EQU	$E3		; DISASSEM instruction byte count
   244 = 00E3			ERRCNT    	EQU   	$E3      	; XModem error counter 10 is the limit
   245 = 00E4			ENDADR  	EQU     $E4   		; MON 2-byte Editor End Address Pointer
   246 = 00E4			VIA_STATUS 	EQU	$E4 		; VIA2 current VIA2 PortB output status
   247 = 00E5			KEY_SENSE	EQU	$E5		; TAPE datasette key sense flag
   248 = 00E6			CURADR  	EQU     $E6   		; MON 2-byte Editor Current Address Pointer
   249 = 00E6			ASCL	  	EQU   	$E6     	; MON ASCII list start address low
   250 = 00E6			PLBA		EQU	$E6		; LBA pointer
   251 = 00E6			PLBAL		EQU	$E6		; LBA pointer low byte
   252 = 00E7			ASCH      	EQU   	$E7     	; MON ASCII list start address high
   253 = 00E7			PLBAH		EQU	$E7		; LBA pointer high byte
   254 = 00E8			CENDADR 	EQU     $E8   		; MON 2-byte Editor Current End Address Pointer
   255 = 00E8			STOL      	EQU   	$E8     	; MON store address Low
   256 = 00E9			STOH      	EQU   	$E9     	; MON store address High
   257 = 00EA			MOVADR  	EQU     $EA   		; MON 2-byte Editor 
   258 = 00EA			PSTR      	EQU   	$EA      	; ACIA output string Pointer
   259 = 00EA			PSTRL     	EQU   	$EA      	; ACIA lower address byte of output string pointer
   260 = 00EB			PSTRH     	EQU   	$EB      	; ACIA upper address byte of output string pointer
   261 = 00EC			TABLEA  	EQU     $EC   		; MON 2-byte Editor 
   262 = 00EC			WBUF      	EQU   	$EC      	; ACIA character output buffer
   263 = 00ED			BITCNT		EQU	$ED		; TAPE current read bit count
   264 = 00EE			LABELS  	EQU     $EE   		; MON 1-byte Editor 
   265 = 00EE			PSAV            EQU     $EE		; MON
   266 = 00EF			PCL		EQU	$EF		; CPU program counter Low
   267
   268 = 00F0			PCH		EQU	$F0		; CPU program counter High
   269 = 00F1			PREG		EQU	$F1		; CPU processor status register
   270 = 00F2			SPUSER		EQU	$F2		; CPU stack pointer
   271 = 00F2			DIVCHAR		EQU	$F2             ; CLOCK current divider char (. or / for date : for time)
   272 = 00F3			ACC		EQU	$F3		; CPU accumulator
   273 = 00F4			YREG		EQU	$F4		; CPU y-register
   274 = 00F5			XREG		EQU	$F5		; CPU x-register
   275 = 00F6			BYTES   	EQU     $F6   		; MON 1-byte Number of bytes to be displayed
   276 = 00F7			COUNT   	EQU     $F7   		; MON 1-byte
   277 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
   278 = 00F8			NUML      	EQU   	$F8     	; MON low number byte
   279 = 00F8			INL     	EQU     $F8   		; MON 1-byte hex display buffer
   280 = 00F9			INH     	EQU     $F9   		; MON 1-byte hex display buffer
   281 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
   282 = 00F9			NUMH	  	EQU   	$F9	 	; MON high number byte
   283 = 00FA			POINT   	EQU     $FA   		; MON 2-byte
   284 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
   285 = 00FA			ADRL      	EQU   	$FA     	; MON last address Low
   286 = 00FB			ADRH      	EQU   	$FB     	; MON last address High
   287 = 00FC			TEMP      	EQU   	$FC     	; MON temp storage
   288 = 00FD			TEMPX   	EQU     $FD   		; MON 1-byte temp. data-buffer
   289 = 00FD			YSAV      	EQU   	$FD     	; MON Y register storage
   290 = 00FE			NIBBLE  	EQU     $FE   		; MON 1-byte temp. data-buffer
   291 = 00FE			PDBCNT    	EQU   	$FE     	; MON number of printed data bytes
   292 = 00FF			MODE      	EQU   	$FF     	; MON current edit mode
   293
   294 				; IO Base Addresses ************************************************************
   295 = 0800			K2		EQU	$0800		; Base address of IO select K2
   296 = 0C00			K3		EQU	$0C00		; Base address of IO select K3
   297 = 1000			K4		EQU	$1000		; Base address of IO select K4
   298
   299 				; Buffers **********************************************************************
   300 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400
   301 = 1500			RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
   302
   303 				; ACIA Registers ***************************************************************
   304 = 1600			DATA_REG  	EQU   	$1600    	; ACIA Data Register
   305 = 1601			STAT_REG  	EQU   	$1601    	; ACIA Status Register
   306 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
   307 = 1603			CTRL_REG  	EQU   	$1603    	; ACIA Control Register
   308
   309 				; ATF1504 Memory Management Unit (MMU) Register ********************************
   310 = 1700			MMU		EQU	$1700		; MMU Register
   311
   312 				;------------------------------------------------------------------------------
   313 				; $1800 - $19FF 512 Bytes, this was previously unused, with the new MMU this
   314 				; has become RAM.
   315 				;------------------------------------------------------------------------------
   316 = 1800			PPORTLOAD	EQU	$1800		; jump location for test code
   317 = 1803			PPORTSAVE	EQU	$1803		; jump location for test code
   318 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
   319 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
   320 = 180A			RETURN_VECT     EQU     $180A           ; 2-byte return vector to monitor caller (moved from $01 to avoid Basic collision)
   321
   322 				; INPBUF is the BASIC Input Buffer. It is defined from $1868 - $18FF
   323 = 1868			INPBUF	  	EQU 	$1868		; change input buffer to last 151 bytes in page
   324 = 1868			ccflag		EQU	INPBUF		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   325 = 1869			ccbyte		EQU 	ccflag+1	; BASIC CTRL-C byte
   326 = 186A			ccnull		EQU 	ccbyte+1	; BASIC CTRL-C byte timeout
   327 = 186B			VEC_CC		EQU 	ccnull+1	; ctrl c check vector
   328
   329 				; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   330 = 187F			Ibuffs		EQU 	VEC_CC+$14	; start of input buffer after IRQ/NMI code
   331 = 18FE			Ibuffe		EQU 	Ibuffs+$7F	; end of input buffer
   332
   333 				; RIOT RAM Area ****************************************************************
   334 = 1A00			IO_INFO         EQU     $1A00           ; Initialization info call for IO card
   335
   336 = 1A24			KEY_HANDLER     EQU     $1A24           ; character input handler
   337 = 1A26			NKEY_HANDLER    EQU     $1A26           ; no character input handler
   338 = 1A28			DEVLIST		EQU	$1A28		; start of device driver list
   339
   340 = 1A66			STDBEEP		EQU	$1A66		; current standard beep routine
   341 = 1A68			DEVIN		EQU	$1A68		; current opened device input routine
   342 = 1A6A			DEVOUT		EQU	$1A6A		; current opened device output routine
   343 = 1A6C			DEVCMD		EQU	$1A6C		; current opened device command routine
   344 = 1A6E			STDIN		EQU	$1A6E		; current standard input routine
   345 = 1A70			STDOUT		EQU	$1A70		; current standard output routine
   346 = 1A72			STDCMD		EQU	$1A72		; current standard command routine
   347 = 1A74			STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   348 = 1A75			STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   349 = 1A76			STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   350 = 1A77			STOACC		EQU	$1A77		; last accumulator before interrupt
   351
   352 				; Interrupt Vectors ************************************************************
   353 = 1A78			BRKUSR		EQU	$1A78		; address of user BREAK vector
   354 = 1A7A			NMIVECT		EQU     $1A7A           ; address of NMI vector
   355 = 1A7C			IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   356 = 1A7E			IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
   357
   358 				; Port Register ****************************************************************
   359 = 1A80			PAD		EQU     $1A80		; Port A Data Register
   360 = 1A81			PADD		EQU	$1A81		; Port A Data Direction Register
   361 = 1A82			PBD		EQU	$1A82		; Port B Data Register
   362 = 1A83			PBDD		EQU	$1A83		; Port B Data Direction Register
   363
   364 = 1A85			WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
   365 									; Read = get Edge Control Interrupt Register
   366
   367 				; Timer Register ***************************************************************
   368 = 1A94			CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   369 = 1A95			CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   370 = 1A96			CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   371 = 1A97			CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
   372 = 1A9F			CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
   373
   374 				;------------------------------------------------------------------------------
   375 				; MACROS for use with the MAD-Assembler
   376 				;------------------------------------------------------------------------------ 
   377 				.macro		ADCAW			; Add A to word and store in word
   378 						CLC
   379 						ADC	:1
   380 						STA	:1
   381 						LDA	:1+1
   382 						ADC	#0
   383 						STA	:1+1
   384 				.endm
   385
   386 				.macro		SBCAW			; Subtract A from word and store in word
   387 						SEC
   388 						SBC	:1
   389 						STA	:1
   390 						LDA	:1+1
   391 						SBC	#0
   392 						STA	:1+1
   393 				.endm
   394
   395 				.macro		SBWB	b16 b8	      	; Subtract a byte from a word
   396 						SEC
   397 						LDA	:b16
   398 						SBC	:b8
   399 						STA	:b16
   400 						LDA	:b16+1
   401 						SBC	#0
   402 						STA	:b16+1
   403 				.endm
   404 						
    19
    20 						ORG	$8000
    21 8000 FF					.byte	$FF			; Fill entire eprom
    22 						
    23 8001					ORG	$9C00			; start address of 1K Monitor in 32K combined EPROM
    24 				;-------------------------------------------------------------------------------------------------------
    25 1C00			MONITOR_BLOCK	.local, $1C00
    26 				;-------------------------------------------------------------------------------------------------------
    27 1C00					icl 	"jc2_mon.asm"		; Monitor source-file
Source: jc2_mon.asm
     1 				;-------------------------------------------------------------------------------------------------------
     2 				; SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER
     3 				;
     4 				; Written by: A. NACHTMANN
     5 				; Date      :  7 FEB. 1980
     6 				;
     7 				; The features of Junior's monitor program are:
     8 				; - Hex address data display (entry via RST)
     9 				; - Hex editor (start address is $1CB5)
    10 				; - Hex assembler (start address is $1F51)
    11 				;----------------------------------------------------------------------------
    12 				; Original code restored and adapted for the 
    13 				; TASM (Telemark Assembler) by : A.J. Prosman, October 26, 2019
    14 				; MADS (MAD-Assembler) by : E. v.d. Logt,      December 2024
    15 				;----------------------------------------------------------------------------
    16
    17 				;       Beginners may load these locations
    18 				;       $1C00 for step by step modus and BRK command
    19
    20 				;----------------------------------------------------------------------------
    21 				;        JUNIOR'S MAIN ROUTINES
    22 				;----------------------------------------------------------------------------
    23 1C00 85 F3		SAVE    STA     ACC         ; Save ACCU
    24 1C02 68			        PLA                 ; Get current P-Register
    25 1C03 85 F1		        STA     PREG        ; Save P-Register
    26
    27 1C05 68			SAVEA   PLA                 ; Get current PCL
    28 1C06 85 EF		        STA	PCL         ; Save current PCL
    29 1C08 85 FA		        STA     POINT       ; PCL to display buffer
    30 1C0A 68			        PLA                 ; Get current PCH
    31 1C0B 85 F0		        STA     PCH         ; Save current PCH
    32 1C0D 85 FB		        STA     POINT+1     ; PCH to display buffer
    33
    34 1C0F 84 F4		SAVEB   STY     YREG        ; Save current Y-Register
    35 1C11 86 F5		        STX     XREG        ; Save current X-Register 
    36 1C13 BA			        TSX                 ; Get current SP
    37 1C14 86 F2		        STX     SPUSER      ; Save current SP
    38 1C16 A2 01		        LDX     #$01        ; Set AD-Mode
    39 1C18 86 FF		        STX     MODE
    40 1C1A 4C 33 1C		        JMP     START
    41
    42 				; RESET vector 6502
    43 1C1D A9 3F		RESET   LDA     #$3F        ; PB5---PB0
    44 1C1F 8D 83 1A		        STA     PBDD        ; IS output
    45 1C22 A9 04		        LDA     #$04        ; Reset P-Register
    46 1C24 85 F1		        STA     PREG
    47 1C26 A9 03		        LDA     #$03
    48 1C28 85 FF		        STA     MODE        ; Set AD-Mode
    49 1C2A 85 F6		        STA     BYTES       ; Display POINT, INH
    50 1C2C A2 FF		        LDX     #$FF
    51 1C2E 9A			        TXS 
    52 1C2F 86 F2		        STX     SPUSER
    53 1C31 D8			        CLD 
    54 1C32 78			        SEI 
    55
    56 1C33 20 88 1D		START   JSR     SCAND       ; Display data specified by POINT
    57 1C36 D0 FB		        BNE     START       ; Wait until key is released
    58
    59 1C38 20 88 1D		STARA   JSR     SCAND       ; Display data specified by point
    60 1C3B F0 FB		        BEQ     STARA       ;  Any key pressed
    61 1C3D 20 88 1D		        JSR     SCAND       ;  Debounce key
    62 1C40 F0 F6		        BEQ     STARA       ; Any key still pressed
    63 1C42 20 F9 1D		        JSR     GETKEY      ; If Yes, decode key, return with key in ACC
    64
    65 1C45 C9 13		GOEXEC  CMP     #$13        ; GO-Key ?
    66 1C47 D0 13		        BNE     ADMODE
    67 1C49 A6 F2		        LDX     SPUSER      ; Get current SP
    68 1C4B 9A			        TXS 
    69 1C4C A5 FB		        LDA     POINT+1     ; Start execution at POINT
    70 1C4E 48			        PHA 
    71 1C4F A5 FA		        LDA     POINT
    72 1C51 48			        PHA 
    73 1C52 A5 F1		        LDA     PREG        ; Restore current P register
    74 1C54 48			        PHA 
    75 1C55 A6 F5		        LDX     XREG
    76 1C57 A4 F4		        LDY     YREG
    77 1C59 A5 F3		        LDA     ACC
    78 1C5B 40			        RTI                 ; Execute program
    79
    80 1C5C C9 10		ADMODE  CMP     #$10        ; AD-Key ?
    81 1C5E D0 06		        BNE     DAMODE
    82 1C60 A9 03		        LDA     #$03        ; Set AD-Mode
    83 1C62 85 FF		        STA     MODE
    84 1C64 D0 14		        BNE     STEPA       ; Always
    85 				        
    86 1C66 C9 11		DAMODE  CMP     #$11        ; DA-Key ?
    87 1C68 D0 06		        BNE     STEP
    88 1C6A A9 00		        LDA     #$00        ; Set DA-Mode
    89 1C6C 85 FF		        STA     MODE
    90 1C6E F0 0A		        BEQ     STEPA
    91
    92 1C70 C9 12		STEP    CMP     #$12        ; PLUS-Key ?
    93 1C72 D0 09		        BNE     PCKEY
    94 1C74 E6 FA		        INC     POINT
    95 1C76 D0 02		        BNE     STEPA
    96 1C78 E6 FB		        INC     POINT+1
    97
    98 1C7A 4C 33 1C		STEPA   JMP     START
    99
   100 1C7D C9 14		PCKEY   CMP     #$14        ; PC-Key
   101 1C7F D0 0B		        BNE     ILLKEY
   102 1C81 A5 EF		        LDA     PCL
   103 1C83 85 FA		        STA     POINT      ; Last PC to display buffer
   104 1C85 A5 F0		        LDA     PCH
   105 1C87 85 FB		        STA     POINT+1
   106 1C89 4C 7A 1C		        JMP     STEPA
   107 				        
   108 1C8C C9 15		ILLKEY  CMP     #$15        ; Illegal key?
   109 1C8E 10 EA		        BPL     STEPA       ; If Yes, ignore it
   110
   111 1C90 85 E1		DATA    STA     KEY         ; Save key
   112 1C92 A4 FF		        LDY     MODE        ; Y=0 Is data mode, else address mode
   113 1C94 D0 0D		        BNE     ADDRESS
   114 1C96 B1 FA		        LDA     (POINT),Y   ; Get Data specified
   115 1C98 0A			        ASL                 ; by point
   116 1C99 0A			        ASL                 ; shift low order
   117 1C9A 0A			        ASL                 ; nibble into high order nibble
   118 1C9B 0A			        ASL      
   119 1C9C 05 E1		        ORA     KEY         ; Data with key
   120 1C9E 91 FA		        STA     (POINT),Y   ; Restore data
   121 1CA0 4C 7A 1C		        JMP     STEPA
   122
   123 1CA3 A2 04		ADDRESS LDX     #$04        ; 4 Shifts
   124 1CA5 06 FA		ADLOOP  ASL     POINT       ; POINT+1, POINT 4 Positions to the left
   125 1CA7 26 FB		        ROL     POINT+1
   126 1CA9 CA			        DEX 
   127 1CAA D0 F9		        BNE     ADLOOP
   128 1CAC A5 FA		        LDA     POINT
   129 1CAE 05 E1		        ORA     KEY         ; Restore address
   130 1CB0 85 FA		        STA     POINT
   131 1CB2 4C 7A 1C		        JMP     STEPA
   132
   133 				;-------------------------------------------------------------------------------
   134 				;       JUNIOR'S HEX EDITOR
   135 				;
   136 				;       FOLLOWING COMMANDS ARE VALID:
   137 				;       "INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
   138 				;       "INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
   139 				;       "SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2BYTE PATTERN
   140 				;       "SKIP": SKIP TO NEXT INSTRUCTION
   141 				;       "DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
   142 				;
   143 				;       AN ERROR IS INDICATED, IF THE INSTRUCTION POINTER CURAD IS OUT OF RANGE
   144 				;-------------------------------------------------------------------------------
   145 1CB5 20 D3 1E		EDITOR  JSR     BEGIN       ; CURAD := BEGAD
   146 1CB8 A4 E3		        LDY     BEGADR+1
   147 1CBA A6 E2		        LDX     BEGADR
   148 1CBC E8			        INX 
   149 1CBD D0 01		        BNE     EDIT
   150 1CBF C8			        INY 
   151
   152 1CC0 86 E8		EDIT    STX     CENDADR     ; CEND := BEGAD + 1
   153 1CC2 84 E9		        STY     CENDADR+1
   154 1CC4 A9 77		        LDA     #$77        ; Display "77"
   155 1CC6 A0 00		        LDY     #$00
   156 1CC8 91 E6		        STA     (CURADR),Y
   157 1CCA 20 4D 1D		CMND    JSR     SCAN        ; Display current instruction,
   158 				                            ; wait for a key
   159 1CCD C9 14		SEARCH  CMP     #$14        ; Search command ?
   160 1CCF D0 2A		        BNE     INSERT
   161 1CD1 20 6F 1D		        JSR     GETBYT      ; Read 1st byte
   162 1CD4 10 F7		        BPL     SEARCH      ; COM. Key ?
   163 1CD6 85 FB		        STA     POINT+1     ; Discard data
   164 1CD8 20 6F 1D		        JSR     GETBYT      ; Read 2nd byte
   165 1CDB 10 F0		        BPL     SEARCH      ; COM. Key ?
   166 1CDD 85 FA		        STA     POINT       ; Discard data
   167 1CDF 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   168
   169 1CE2 A0 00		SELOOP  LDY     #$00
   170 1CE4 B1 E6		        LDA     (CURADR),Y  ; Compare instruction
   171 1CE6 C5 FB		        CMP     POINT+1     ; against data to be searched
   172 1CE8 D0 07		        BNE     SEARA       ; Skip to the next instruction, if not equal
   173 1CEA C8			        INY 
   174 1CEB B1 E6		        LDA     (CURADR),Y
   175 1CED C5 FA		        CMP     POINT
   176 1CEF F0 D9		        BEQ     CMND        ; Return if 2byte pattern is found
   177
   178 1CF1 20 5C 1E		SEARA   JSR     OPLEN       ; Get length of the current instruction
   179 1CF4 20 F8 1E		        JSR     NEXT        ; Skip to the next instruction
   180 1CF7 30 E9		        BMI     SELOOP      ; Search again, if CURAD is less than CEND
   181 1CF9 10 3E		        BPL     ERRA
   182
   183 1CFB C9 10		INSERT  CMP     #$10        ; Insert command ?
   184 1CFD D0 0A		        BNE     INPUT
   185 1CFF 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   186 1D02 10 C9		        BPL     SEARCH      ; COM. key?
   187 1D04 20 47 1E		        JSR     FILLWS      ; Move data in WS downward by the amount in bytes
   188 1D07 F0 C1		        BEQ     CMND        ; Return to display the inserted instruction
   189
   190 1D09 C9 13		INPUT   CMP     #$13        ; Input command ?
   191 1D0B D0 14		        BNE     SKIP
   192 1D0D 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   193 1D10 10 BB		        BPL     SEARCH      ; COM. key ?
   194 1D12 20 5C 1E		        JSR     OPLEN       ; Length of the current instruction
   195 1D15 20 F8 1E		        JSR     NEXT        ; Return with N=1, if CURAD is less than CEND
   196 1D18 A5 FD		        LDA     TEMPX       ; Length of instr. to be inserted
   197 1D1A 85 F6		        STA     BYTES
   198 1D1C 20 47 1E		        JSR     FILLWS      ; Move data in ws downward by the amount in bytes
   199 1D1F F0 A9		        BEQ     CMND        ; Return to display the inserted data
   200
   201 1D21 C9 12		SKIP    CMP     #$12        ; Skip command ?
   202 1D23 D0 07		        BNE     DELETE
   203 1D25 20 F8 1E		        JSR     NEXT        ; Skip to next instruction. CURAD less than CEND?
   204 1D28 30 A0		        BMI     CMND
   205 1D2A 10 0D		        BPL     ERRA
   206
   207 1D2C C9 11		DELETE  CMP     #$11        ; Delete command ?
   208 1D2E D0 09		        BNE     ERRA
   209 1D30 20 83 1E		        JSR     UP          ; Delete current instruction by moving up the WS
   210 1D33 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   211 1D36 4C CA 1C		        JMP     CMND
   212
   213 1D39 A9 EE		ERRA    LDA     #$EE
   214 1D3B 85 FB		        STA     POINT+1
   215 1D3D 85 FA		        STA     POINT
   216 1D3F 85 F9		        STA     INH
   217 1D41 A9 03		        LDA     #$03
   218 1D43 85 F6		        STA     BYTES
   219
   220 1D45 20 8E 1D		ERRB    JSR     SCANDS      ; Display "EEEEEE" until key is released
   221 1D48 D0 FB		        BNE     ERRB
   222 1D4A 4C CA 1C		        JMP     CMND
   223
   224 				;----------------------------------------------------------------------------
   225 				;       EDITOR'S SUBROUTINES
   226 				;
   227 				;       SCAN is a subroutine, filling up the display-buffer determined by
   228 				;       CURADR. Then the display is scanned depending on the length of the  
   229 				;       instruction pointed to by CURADR if a keypress is detected.
   230 				;----------------------------------------------------------------------------
   231
   232 				;       SCAN RETURNS WITH VALUE IN A
   233 1D4D A2 02		SCAN    LDX     #$02        ; Fill up the display buffer
   234 1D4F A0 00		        LDY     #$00
   235
   236 1D51 B1 E6		FILBUF  LDA     (CURADR),Y  ; Start filling at OPCode
   237 1D53 95 F9		        STA     INH,X
   238 1D55 C8			        INY 
   239 1D56 CA			        DEX 
   240 1D57 10 F8		        BPL     FILBUF
   241 1D59 20 5C 1E		        JSR     OPLEN       ; Store instruction length in bytes
   242
   243 1D5C 20 8E 1D		SCANA   JSR     SCANDS      ; Display current instruction
   244 1D5F D0 FB		        BNE     SCANA       ; Key released ?
   245
   246 1D61 20 8E 1D		SCANB   JSR     SCANDS      ; Display current instruction
   247 1D64 F0 FB		        BEQ     SCANB       ; Any key pressed
   248 1D66 20 8E 1D		        JSR     SCANDS      ; Display current instruction
   249 1D69 F0 F6		        BEQ     SCANB       ; Any key still pressed ?
   250 1D6B 20 F9 1D		        JSR     GETKEY      ; If yes, return with key in ACC
   251 1D6E 60			        RTS 
   252
   253 				;----------------------------------------------------------------------------
   254 				;       GETBYT reads 2 hex-keys and composes their values in the A register.
   255 				;       If only hex-keys were pressed, it returns with N=1. If a command-key
   256 				;       was pressed, it returns with N=0;
   257 				;----------------------------------------------------------------------------
   258 1D6F 20 5C 1D		GETBYT  JSR     SCANA       ; Read high order nibble
   259 1D72 C9 10		        CMP     #$10
   260 1D74 10 11		        BPL     BYTEND      ; Command key ?
   261 1D76 0A			        ASL     
   262 1D77 0A			        ASL                 ; If not, save high order nibble
   263 1D78 0A			        ASL     
   264 1D79 0A			        ASL     
   265 1D7A 85 FE		        STA     NIBBLE
   266 1D7C 20 5C 1D		        JSR     SCANA       ; Read low order nibble
   267 1D7F C9 10		        CMP     #$10
   268 1D81 10 04		        BPL     BYTEND      ; Command key ?
   269 1D83 05 FE		        ORA     NIBBLE      ; If not, compose byte
   270 1D85 A2 FF		        LDX     #$FF        ; Set N=1
   271 1D87 60			BYTEND  RTS 
   272
   273 				;----------------------------------------------------------------------------
   274 				;       SCAND is a subroutine showing data specified by POINT.
   275 				;       SCANDS is a subroutine showing the contents of the display-buffer as
   276 				;       a function of BYTES.
   277 				;       The next subroutine AK scans the keyboard, it returns with A=0 if no
   278 				;       key was pressed and with A > 0 if a key was pressed.
   279 				;       When SCAND or SCANDS are exit, PA0..PA7 are set to input.
   280 				;----------------------------------------------------------------------------
   281 1D88 A0 00		SCAND   LDY     #$00
   282 1D8A B1 FA		        LDA     (POINT),Y   ; Get data specified by point
   283 1D8C 85 F9		        STA     INH
   284
   285 1D8E A9 7F		SCANDS  LDA     #$7F
   286 1D90 8D 81 1A		        STA     PADD        ; PA0..PA6 is output
   287 1D93 A2 08		        LDX     #$08        ; Enable display
   288 1D95 A4 F6		        LDY     BYTES       ; Fetch length from bytes
   289
   290 1D97 A5 FB		SCDSA   LDA     POINT+1     ; Output 1st byte
   291 1D99 20 CC 1D		        JSR     SHOW
   292 1D9C 88			        DEY 
   293 1D9D F0 0D		        BEQ     SCDSB       ; More bytes ?
   294 1D9F A5 FA		        LDA     POINT
   295 1DA1 20 CC 1D		        JSR     SHOW        ; If yes, output 2nd byte
   296 1DA4 88			        DEY 
   297 1DA5 F0 05		        BEQ     SCDSB       ; More bytes ?
   298 1DA7 A5 F9		        LDA     INH
   299 1DA9 20 CC 1D		        JSR     SHOW        ; If yes, output 3rd byte
   300
   301 1DAC A9 00		SCDSB   LDA     #$00
   302 1DAE 8D 81 1A		        STA     PADD        ; PA0..PA7 is input
   303 1DB1 A0 03		AK      LDY     #$03        ; Scan 3 rows
   304 1DB3 A2 00		        LDX     #$00        ; Reset row counter
   305
   306 1DB5 A9 FF		ONEKEY  LDA     #$FF
   307 1DB7 8E 82 1A		AKA     STX     PBD         ; Output row number
   308 1DBA E8			        INX                 ; Enable next row
   309 1DBB E8			        INX 
   310 1DBC 2D 80 1A		        AND     PAD         ; Input row pattern
   311 1DBF 88			        DEY                 ; All rows scanned ?
   312 1DC0 D0 F5		        BNE     AKA
   313 1DC2 A0 06		        LDY     #$06        ; Turn display off
   314 1DC4 8C 82 1A		        STY     PBD
   315 1DC7 09 80		        ORA     #$80        ; Set BIT7=1
   316 1DC9 49 FF		        EOR     #$FF        ; Invert key pattern
   317 1DCB 60			        RTS 
   318
   319 				;----------------------------------------------------------------------------
   320 				;       Subroutine SHOW copies the contents of a display-buffer to the display.
   321 				;       The X-register is used as a scan-counter. It determines if POINT+1,
   322 				;       POINT or INH is transported to the displays.
   323 				;----------------------------------------------------------------------------
   324 1DCC 48			SHOW    PHA                 ; Save display 
   325 1DCD 84 FC		        STY     TEMP        ; Save Y register
   326 1DCF 4A			        LSR     
   327 1DD0 4A			        LSR                 ; Get high order nibble
   328 1DD1 4A			        LSR     
   329 1DD2 4A			        LSR     
   330 1DD3 20 DF 1D		        JSR     CONVD       ; Output high order nibble
   331 1DD6 68			        PLA                 ; Get display again
   332 1DD7 29 0F		        AND     #$0F        ; Mask off high order nibble
   333 1DD9 20 DF 1D		        JSR     CONVD       ; Output low order nibble
   334 1DDC A4 FC		        LDY     TEMP
   335 1DDE 60			        RTS 
   336
   337 				;----------------------------------------------------------------------------
   338 				;       Subroutine CONVD controls the display scanning. It converts the
   339 				;       contents of the display-buffer to be displayed into a segment pattern.
   340 				;----------------------------------------------------------------------------
   341 1DDF A8			CONVD   TAY                 ; Use nibble as index
   342 1DE0 B9 0F 1F		        LDA     LOOK,Y      ; Fetch segment pattern
   343 1DE3 8D 80 1A		        STA     PAD         ; Output segment pattern
   344 1DE6 8E 82 1A		        STX     PBD         ; Output digit enable
   345 1DE9 A0 7F		        LDY     #$7F
   346
   347 1DEB 88			DELAY   DEY                 ; Delay 500uS approx
   348 1DEC 10 FD		        BPL     DELAY
   349 1DEE 8C 80 1A		        STY     PAD         ; Turns segments off
   350 1DF1 A0 06		        LDY     #$06
   351 1DF3 8C 82 1A		        STY     PBD         ; Turn display off
   352 1DF6 E8			        INX                 ; Enable next digit
   353 1DF7 E8			        INX 
   354 1DF8 60			        RTS 
   355
   356 				;----------------------------------------------------------------------------
   357 				;       GETKEY converts a key-press into a hex number. It returns with the
   358 				;       key value in A. 
   359 				;       If an invalid key was pressed ?
   360 				;----------------------------------------------------------------------------
   361 1DF9 A2 00		GETKEY  LDX     #$00        ; Start at row 0
   362 1DFB A0 01		GETKEA  LDY     #$01        ; Get one row
   363 1DFD 20 B5 1D		        JSR     ONEKEY      ; A=0, No key pressed
   364 1E00 D0 07		        BNE     KEYIN
   365 1E02 E0 06		        CPX     #$06
   366 1E04 D0 F5		        BNE     GETKEA      ; Each row scanned ?
   367 1E06 A9 15		        LDA     #$15        ; Return if invalid key
   368 1E08 60			        RTS 
   369
   370 1E09 A0 FF		KEYIN   LDY     #$FF
   371 1E0B 0A			KEYINA  ASL                 ; Shift left until Y=Key number
   372 1E0C B0 03		        BCS     KEYINB
   373 1E0E C8			        INY 
   374 1E0F 10 FA		        BPL     KEYINA
   375
   376 1E11 8A			KEYINB  TXA 
   377 1E12 29 0F		        AND     #$0F        ; Mask MSD
   378 1E14 4A			        LSR                 ; Divide by 2
   379 1E15 AA			        TAX 
   380 1E16 98			        TYA 
   381 1E17 10 03		        BPL     KEYIND
   382
   383 1E19 18			KEYINC  CLC 
   384 1E1A 69 07		        ADC     #$07        ; Add row offset
   385 1E1C CA			KEYIND  DEX 
   386 1E1D D0 FA		        BNE     KEYINC
   387 1E1F 60			        RTS 
   388
   389 				;----------------------------------------------------------------------------
   390 				;       RDINST transfers an instruction from the keyboard to the display-buffer. 
   391 				;       It returns with N=0 if a command-key was pressed. Once the entire
   392 				;       instruction is read, RDINST returns with N=1;
   393 				;----------------------------------------------------------------------------
   394 1E20 20 6F 1D		RDINST  JSR     GETBYT      ; Read OPCode
   395 1E23 10 21		        BPL     RDB         ; Return if it is the command key
   396 1E25 85 FB		        STA     POINT+1     ; Store OP cod in the display buffer
   397 1E27 20 60 1E		        JSR     LENACC      ; Calculate instruction length
   398 1E2A 84 F7		        STY     COUNT
   399 1E2C 84 FD		        STY     TEMPX
   400 1E2E C6 F7		        DEC     COUNT
   401 1E30 F0 12		        BEQ     RDA         ; 1 Byte instruction ?
   402 1E32 20 6F 1D		        JSR     GETBYT      ; If not, read first operand
   403 1E35 10 0F		        BPL     RDB         ; Return if it is the command key
   404 				        
   405 1E37 85 FA		        STA     POINT       ; Store 1st operand in the display buffer
   406 1E39 C6 F7		        DEC     COUNT
   407 1E3B F0 07		        BEQ     RDA         ; 2 Byte instruction ?
   408 				        
   409 1E3D 20 6F 1D		        JSR     GETBYT      ; If not, read second operand
   410 1E40 10 04		        BPL     RDB         ; Return if it is the command key
   411 				        
   412 1E42 85 F9		        STA     INH         ; Store 2nd operand in the display buffer
   413 1E44 A2 FF		RDA     LDX     #$FF        ; N=1
   414 1E46 60			RDB     RTS 
   415
   416 				;----------------------------------------------------------------------------
   417 				;       WILLWS transfers data from the display to the workspace. It always
   418 				;       returns with Z=1.
   419 				;----------------------------------------------------------------------------
   420 1E47 20 A6 1E		FILLWS  JSR     DOWN        ; Move data down by the amount in bytes
   421 1E4A 20 DC 1E		        JSR     ADCEND      ; Adjust current end address
   422 1E4D A2 02		        LDX     #$02
   423 1E4F A0 00		        LDY     #$00
   424 1E51 B5 F9		WS      LDA     INH,X       ; Fetch data from display buffer
   425 1E53 91 E6		        STA     (CURADR),Y  ; Insert data into the data field
   426 1E55 CA			        DEX 
   427 1E56 C8			        INY 
   428 1E57 C4 F6		        CPY     BYTES       ; All inserted ?
   429 1E59 D0 F6		        BNE     WS          ; If not, continue
   430 1E5B 60			        RTS 
   431
   432 				;----------------------------------------------------------------------------
   433 				;       OPLEN calculates the length of a 6502 instruction.
   434 				;       Instruction length is saved in BYTES.
   435 				;----------------------------------------------------------------------------
   436 1E5C A0 00		OPLEN   LDY     #$00
   437 1E5E B1 E6		        LDA     (CURADR),Y  ; Fetch OPCode from WS
   438 1E60 A0 01		LENACC  LDY     #$01        ; Length of the OPCode is 1 byte
   439 1E62 C9 00		        CMP     #$00
   440 1E64 F0 1A		        BEQ     LENEND      ; BRK Instruction ?
   441 				        
   442 1E66 C9 40		        CMP     #$40
   443 1E68 F0 16		        BEQ     LENEND      ; TRI Instruction ?
   444 				        
   445 1E6A C9 60		        CMP     #$60
   446 1E6C F0 12		        BEQ     LENEND      ; RTS Instruction ?
   447 				        
   448 1E6E A0 03		        LDY     #$03
   449 1E70 C9 20		        CMP     #$20
   450 1E72 F0 0C		        BEQ     LENEND      ; JSR Instruction ?
   451 				        
   452 1E74 29 1F		        AND     #$1F        ; Strip to 5 bits
   453 1E76 C9 19		        CMP     #$19
   454 1E78 F0 06		        BEQ     LENEND      ; Any ABS,Y instruction ?
   455 				        
   456 1E7A 29 0F		        AND     #$0F        ; Strip to 4 bits
   457 1E7C AA			        TAX                 ; Use nibble as index
   458 1E7D BC 1F 1F		        LDY     LEN,X       ; Fetch length from LEN
   459 1E80 84 F6		LENEND  STY     BYTES       ; Discard length in bytes
   460 1E82 60			        RTS 
   461
   462 				;----------------------------------------------------------------------------
   463 				;       UP moves a data-field between CURADR and CENDADR upwards by the
   464 				;       amount in BYTES.
   465 				;----------------------------------------------------------------------------
   466 1E83 A5 E6		UP      LDA     CURADR
   467 1E85 85 EA		        STA     MOVADR
   468 1E87 A5 E7		        LDA     CURADR+1    ; MOVAD := CURADR
   469 1E89 85 EB		        STA     MOVADR+1
   470 1E8B A4 F6		UPLOOP  LDY     BYTES
   471 1E8D B1 EA		        LDA     (MOVADR),Y  ; Move upward by the number of bytes
   472 1E8F A0 00		        LDY     #$00
   473 1E91 91 EA		        STA     (MOVADR),Y
   474 1E93 E6 EA		        INC     MOVADR
   475 1E95 D0 02		        BNE     UPA
   476 				        
   477 1E97 E6 EB		        INC     MOVADR+1    ; MOVADR+1 := MOVADR+1 + 1
   478 1E99 A5 EA		UPA     LDA     MOVADR
   479 1E9B C5 E8		        CMP     CENDADR
   480 1E9D D0 EC		        BNE     UPLOOP      ; All data moved ?
   481 1E9F A5 EB		        LDA     MOVADR+1    ; If not continue
   482 1EA1 C5 E9		        CMP     CENDADR+1
   483 1EA3 D0 E6		        BNE     UPLOOP
   484 1EA5 60			        RTS 
   485
   486 				;----------------------------------------------------------------------------
   487 				;       DOWN moves a data-field between CURADR and CENDADR downwards by the
   488 				;       amount in BYTES.
   489 				;----------------------------------------------------------------------------
   490 1EA6 A5 E8		DOWN    LDA     CENDADR
   491 1EA8 85 EA		        STA     MOVADR      ; MOVAD := CEND
   492 1EAA A5 E9		        LDA     CENDADR+1
   493 1EAC 85 EB		        STA     MOVADR+1
   494 1EAE A0 00		DNLOOP  LDY     #$00
   495 1EB0 B1 EA		        LDA     (MOVADR),Y  ; Move downward by the number of bytes
   496 1EB2 A4 F6		        LDY     BYTES
   497 1EB4 91 EA		        STA     (MOVADR),Y
   498 1EB6 A5 EA		        LDA     MOVADR
   499 1EB8 C5 E6		        CMP     CURADR
   500 1EBA D0 06		        BNE     DNA         ; All data moved ?
   501 				        
   502 1EBC A5 EB		        LDA     MOVADR+1    ; If not, continue
   503 1EBE C5 E7		        CMP     CURADR+1
   504 1EC0 F0 10		        BEQ     DNEND
   505 1EC2 38			DNA     SEC 
   506 1EC3 A5 EA		        LDA     MOVADR
   507 1EC5 E9 01		        SBC     #$01
   508 1EC7 85 EA		        STA     MOVADR
   509 1EC9 A5 EB		        LDA     MOVADR+1    ; MOVAD := MOVAD - 1
   510 1ECB E9 00		        SBC     #$00
   511 1ECD 85 EB		        STA     MOVADR+1
   512 1ECF 4C AE 1E		        JMP     DNLOOP
   513 1ED2 60			DNEND   RTS 
   514
   515 				;----------------------------------------------------------------------------
   516 				;       BEGIN sets CURADR TO BEGADR
   517 				;----------------------------------------------------------------------------
   518 1ED3 A5 E2		BEGIN   LDA     BEGADR
   519 1ED5 85 E6		        STA     CURADR
   520 1ED7 A5 E3		        LDA     BEGADR+1    ; CURAD := BEGADR
   521 1ED9 85 E7		        STA     CURADR+1
   522 1EDB 60			        RTS 
   523
   524 				;----------------------------------------------------------------------------
   525 				;       ADCEND increases the current end-address by the number in BYTES.
   526 				;----------------------------------------------------------------------------
   527 1EDC 18			ADCEND  CLC 
   528 1EDD A5 E8		        LDA     CENDADR
   529 1EDF 65 F6		        ADC     BYTES       ; CEND := CEND + BYTES
   530 1EE1 85 E8		        STA     CENDADR
   531 1EE3 A5 E9		        LDA     CENDADR+1
   532 1EE5 69 00		        ADC     #$00
   533 1EE7 85 E9		        STA     CENDADR+1
   534 1EE9 60			        RTS 
   535
   536 				;----------------------------------------------------------------------------
   537 				;       RECEND decreases the current end-address by the number in BYTES.
   538 				;----------------------------------------------------------------------------
   539 1EEA 38			RECEND  SEC 
   540 1EEB A5 E8		        LDA     CENDADR
   541 1EED E5 F6		        SBC     BYTES       ; CEND := CEND - BYTES
   542 1EEF 85 E8		        STA     CENDADR
   543 1EF1 A5 E9		        LDA     CENDADR+1
   544 1EF3 E9 00		        SBC     #$00
   545 1EF5 85 E9		        STA     CENDADR+1
   546 1EF7 60			        RTS 
   547
   548 				;----------------------------------------------------------------------------
   549 				;       NEXT increases the current displayed address by the number in BYTES.
   550 				;----------------------------------------------------------------------------
   551 1EF8 18			NEXT    CLC 
   552 1EF9 A5 E6		        LDA     CURADR
   553 1EFB 65 F6		        ADC     BYTES       ; CURAD := CURAD + BYTES
   554 1EFD 85 E6		        STA     CURADR
   555 1EFF A5 E7		        LDA     CURADR+1
   556 1F01 69 00		        ADC     #$00
   557 1F03 85 E7		        STA     CURADR+1
   558 1F05 38			        SEC 
   559 1F06 A5 E6		        LDA     CURADR
   560 1F08 E5 E8		        SBC     CENDADR
   561 1F0A A5 E7		        LDA     CURADR+1
   562 1F0C E5 E9		        SBC     CENDADR+1
   563 1F0E 60			        RTS 
   564
   565 				;----------------------------------------------------------------------------
   566 				;       Lookup table "LOOK"" is used to convert a hex number into a pattern
   567 				;       for the seven-segment displays. 
   568 				;       Lookup table "LEN" is used to convert an instruction into an 
   569 				;       instruction length.
   570 				;----------------------------------------------------------------------------
   571 1F0F 40			LOOK    .byte   $40         ; "0"
   572 1F10 79			        .byte   $79         ; "1"
   573 1F11 24			        .byte   $24         ; "2"
   574 1F12 30			        .byte   $30         ; "3"
   575 1F13 19			        .byte   $19         ; "4"
   576 1F14 12			        .byte   $12         ; "5"
   577 1F15 02			        .byte   $02         ; "6"
   578 1F16 78			        .byte   $78         ; "7"
   579 1F17 00			        .byte   $00         ; "8"
   580 1F18 10			        .byte   $10         ; "9"
   581 1F19 08			        .byte   $08         ; "A"
   582 1F1A 03			        .byte   $03         ; "B"
   583 1F1B 46			        .byte   $46         ; "C"
   584 1F1C 21			        .byte   $21         ; "D"
   585 1F1D 06			        .byte   $06         ; "E"
   586 1F1E 0E			        .byte   $0E         ; "F"
   587
   588 1F1F 02			LEN     .byte   $02
   589 1F20 02			        .byte   $02
   590 1F21 02			        .byte   $02
   591 1F22 01			        .byte   $01
   592 1F23 02			        .byte   $02
   593 1F24 02			        .byte   $02
   594 1F25 02			        .byte   $02
   595 1F26 01			        .byte   $01
   596 1F27 01			        .byte   $01
   597 1F28 02			        .byte   $02
   598 1F29 01			        .byte   $01
   599 1F2A 01			        .byte   $01
   600 1F2B 03			        .byte   $03
   601 1F2C 03			        .byte   $03
   602 1F2D 03			        .byte   $03
   603 1F2E 03			        .byte   $03
   604
   605 				; NMI and IRQ JMP vectors are now moved to jc2_main.asm
   606
   607 1F2F				ORG	$1F35		; maintain compatibility with original Monitor
   608 				;----------------------------------------------------------------------------
   609 				;       GETLBL is an assembler subroutine. It searches for labels on the
   610 				;       symbol pseudo stack. If this stack contains a valid label, it returns
   611 				;       with the high-order label address in X and the low-order label
   612 				;       address in A. If no valid label is found, it returns with Z=1.
   613 				;----------------------------------------------------------------------------
   614 1F35 B1 E6		GETLBL  LDA     (CURADR),Y  ; Fetch current label number from WS
   615 1F37 A0 FF		        LDY     #$FF        ; Reset pseudo stack
   616 1F39 C4 EE		SYMA    CPY     LABELS      ; Upper most symbol table address ?
   617 1F3B F0 0D		        BEQ     SYMB        ; If yes, return, no label on pseudo stack
   618 				        
   619 1F3D D1 EC		        CMP     (TABLEA),Y  ; Label Nr. in WS = Label Nr. on pseudo stack
   620 1F3F D0 0A		        BNE     SYMNXT
   621 				        
   622 1F41 88			        DEY                 ; If yes, get high order address
   623 1F42 B1 EC		        LDA     (TABLEA),Y
   624 1F44 AA			        TAX                 ; Discard high order, add in X
   625 1F45 88			        DEY 
   626 1F46 B1 EC		        LDA     (TABLEA),Y  ; Get low order add
   627 1F48 A0 01		        LDY     #$01        ; Prepare Y register
   628 1F4A 60			SYMB    RTS 
   629
   630 1F4B 88			SYMNXT  DEY                 ; *********   *********
   631 1F4C 88			        DEY                 ; * X=ADH *   * A=ADL *
   632 1F4D 88			        DEY                 ; *********   *********
   633 1F4E D0 E9		        BNE     SYMA
   634 1F50 60			        RTS 
   635
   636 				;----------------------------------------------------------------------------
   637 				;       ASSEMBLER main routine.
   638 				;
   639 				;       The following instructions are assembled:
   640 				;       - JSR instruction
   641 				;       - JMP instruction 
   642 				;       - BRANCH instructions
   643 				;----------------------------------------------------------------------------
   644 1F51 38			ASSEMB  SEC 
   645 1F52 A5 E4		        LDA     ENDADR
   646 1F54 E9 FF		        SBC     #$FF
   647 1F56 85 EC		        STA     TABLEA      ; TABLE := ENDAD - $FF
   648 1F58 A5 E5		        LDA     ENDADR+1
   649 1F5A E9 00		        SBC     #$00
   650 1F5C 85 ED		        STA     TABLEA+1
   651 1F5E A9 FF		        LDA     #$FF
   652 1F60 85 EE		        STA     LABELS
   653 1F62 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   654
   655 1F65 20 5C 1E		PASSA   JSR     OPLEN       ; Start pass one, get current instruction
   656 1F68 A0 00		        LDY     #$00
   657 1F6A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   658 1F6C C9 FF		        CMP     #$FF        ; Is the current instruction a label ? 
   659 1F6E D0 1D		        BNE     NXTINS
   660 				        
   661 1F70 C8			        INY 
   662 1F71 B1 E6		        LDA     (CURADR),Y  ; If yes, fetch label number
   663 1F73 A4 EE		        LDY     LABELS
   664 1F75 91 EC		        STA     (TABLEA),Y  ; Push label number on symbol stack
   665 1F77 88			        DEY 
   666 1F78 A5 E7		        LDA     CURADR+1    ; Get high order address
   667 1F7A 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   668 1F7C 88			        DEY 
   669 1F7D A5 E6		        LDA     CURADR      ; Get high order address
   670 1F7F 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   671 1F81 88			        DEY 
   672 1F82 84 EE		        STY     LABELS      ; Adjust pseudo stack pointer
   673 1F84 20 83 1E		        JSR     UP          ; Delete current label in ws
   674 1F87 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   675 1F8A 4C 65 1F		        JMP     PASSA       ; Look for more labels
   676
   677 1F8D 20 F8 1E		NXTINS  JSR     NEXT        ; If no label skip to the next instruction
   678 1F90 30 D3		        BMI     PASSA       ; All labels in WS collected ?
   679 1F92 20 D3 1E		        JSR     BEGIN       ; Start pass 2
   680 				        
   681 1F95 20 5C 1E		PASSB   JSR     OPLEN       ; Get length of the current instruction
   682 1F98 A0 00		        LDY     #$00
   683 1F9A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   684 1F9C C9 4C		        CMP     #$4C        ; JMP instruction ?
   685 1F9E F0 16		        BEQ     JUMPS
   686 				        
   687 1FA0 C9 20		        CMP     #$20        ; JSR Instruction ?
   688 1FA2 F0 12		        BEQ     JUMPS
   689 				        
   690 1FA4 29 1F		        AND     #$1F        ; Strip to 5 bits
   691 1FA6 C9 10		        CMP     #$10        ; Any branch instruction ?
   692 1FA8 F0 1A		        BEQ     BRINST
   693 				        
   694 1FAA 20 F8 1E		PB      JSR     NEXT        ; If not, return
   695 1FAD 30 E6		        BMI     PASSB       ; All labels between CURAD and ENDAD assembled ?
   696 				        
   697 1FAF A9 03		        LDA     #$03        ; Enable 3 display buffers
   698 1FB1 85 F6		        STA     BYTES
   699 1FB3 4C 33 1C		        JMP     START       ; Exit here
   700
   701 1FB6 C8			JUMPS   INY                 ; Set pointer to label number
   702 1FB7 20 35 1F		        JSR     GETLBL      ; Get label address
   703 1FBA F0 EE		        BEQ     PB          ; Return if not found
   704 				        
   705 1FBC 91 E6		        STA     (CURADR),Y  ; Store low order address
   706 1FBE 8A			        TXA 
   707 1FBF C8			        INY 
   708 1FC0 91 E6		        STA     (CURADR),Y  ; Store high order address
   709 1FC2 D0 E6		        BNE     PB
   710
   711 1FC4 C8			BRINST  INY                 ; Set pointer to label number
   712 1FC5 20 35 1F		        JSR     GETLBL      ; Get label address
   713 1FC8 F0 E0		        BEQ     PB          ; Return if label not found
   714 				        
   715 1FCA 38			        SEC 
   716 1FCB E5 E6		        SBC     CURADR      ; Calculate branch offset
   717 1FCD 38			        SEC 
   718 1FCE E9 02		        SBC     #$02        ; DESTINATION - SOURCE - 2 = OFFSET
   719 1FD0 91 E6		        STA     (CURADR),Y  ; Insert branch offset in WS
   720 1FD2 4C AA 1F		        JMP     PB
   721
   722 				;----------------------------------------------------------------------------
   723 				;       BRANCH calculates the offset of branch instructions. The 2 right-hand
   724 				;       displays show the calculated offset defined by the 4 left-hand
   725 				;       displays. The program must be stopped by the RESET key.
   726 				;----------------------------------------------------------------------------
   727 1FD5 D8			BRANCH  CLD 
   728 1FD6 A9 00		        LDA     #$00        ; Reset display buffer
   729 1FD8 85 FB		        STA     POINT+1
   730 1FDA 85 FA		        STA     POINT
   731 1FDC 85 F9		        STA     INH
   732 1FDE 20 6F 1D		BR      JSR     GETBYT      ; Read source
   733 1FE1 10 F2		        BPL     BRANCH      ; Command key ?
   734 				        
   735 1FE3 85 FB		        STA     POINT+1    ; Save source in buffer
   736 1FE5 20 6F 1D		        JSR     GETBYT      ; Read destination
   737 1FE8 10 EB		        BPL     BRANCH      ; Command key ?
   738
   739 1FEA 85 FA		        STA     POINT       ; Save destination in buffer
   740 1FEC 18			        CLC 
   741 1FED A5 FA		        LDA     POINT       ; Fetch destination
   742 1FEF E5 FB		        SBC     POINT+1     ; Substract source
   743 1FF1 85 F9		        STA     INH
   744 1FF3 C6 F9		        DEC     INH         ; Equalize and save offset in buffer
   745 1FF5 4C DE 1F		        JMP     BR
   746
   747 				;----------------------------------------------------------------------------
   748 				;       END OF JUNIOR'S MONITOR
   749 				;----------------------------------------------------------------------------
    28 				;-------------------------------------------------------------------------------------------------------
    29 1FF8			MONITOR_END	
    30 						.endl
    31 				;-------------------------------------------------------------------------------------------------------
    32
    33 9FF8					ORG 	$B000       		; start address of BASIC (12K)
    34 B000			RAM_TOP		icl 	"jc2_basic.asm"		; end of user RAM+1 (set as needed, should be page aligned)
Source: jc2_basic.asm
     1
     2 				; Enhanced BASIC ver 2.27
     3
     4 				; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     5
     6 				; 2.00	new revision numbers start here
     7 				; 2.01	fixed LCASE$() and UCASE$()
     8 				; 2.02	new get value routine done
     9 				; 2.03	changed RND() to galoise method
    10 				; 2.04	fixed SPC()
    11 				; 2.05	new get value routine fixed
    12 				; 2.06	changed USR() code
    13 				; 2.07	fixed STR$()
    14 				; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    15 				; 2.09	fixed RND()
    16 				; 2.10	integrated missed changes from an earlier version
    17 				; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    18 				; 2.21	fixed IF .. THEN RETURN to not cause error
    19 				; 2.22	fixed RND() breaking the get byte routine
    20 				; 2.25  Emile: I2C addresses corrected for V1.1.4 bios and integrated with BIOS & MON source-files.
    21 				; 2.26  - I2Cout, I2Cin() and DOS commands added
    22 				;	- Destructive RAM memory test disabled
    23 				;       - Patches from EhBASIC 2.22 added: 
    24 				;         - RAM above code/Ibuff above patch (LAB_20DC)
    25 				;	  - Some function outputs (e.g. FRE()) limited to integers are negative (LAB_UAYFC)
    26 				;         - Use of decimal mode and invalid BCD (LAB_AL2X)
    27 				;	  - First statement after direct mode does not set continue pointer (LAB_1491, LAB_15C2, LAB_163B, LAB_CONT, LAB_1934)
    28 				;	  - String compare of equal strings in direct mode returns FALSE (LAB_1C25)
    29 				;	  - FALSE value stored to a variable after string compare is not exactly zero (LAB_LET)
    30 				;	  - Stack floor protection does not cater for background interrupts (LAB_1212)
    31 				;	  - Allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack (LAB_174D)
    32 				; 2.27	  - INPBUF moved from $768 to $1868. Also moved Decss, Decssp1, ADREL, ADREH, ADRSL, ADRSH to lower ZP-addresses
    33 				; ********************************************************************************************************
    34
    35 				; changes by Joerg Walke
    36 				; ----------------------
    37 				; 2022/05/14 added command BEEP
    38 				; 2022/05/15 added command PLIST
    39 				; 2022/05/16 changed BPL SwapErr to BNE SwapErr in LAB_SWAP to avoid command always throwing 'Type mismatch Error'
    40 				; 2024/02/03 Source adapted for MAD-Assembler
    41 				; ********************************************************************************************************
    42
    43 				; zero page use ..
    44 = 0000			LAB_WARM		= $00			; BASIC warm start entry point
    45 = 0001			Wrmjpl 			= LAB_WARM+1		; BASIC warm start vector jump low byte
    46 = 0002			Wrmjph 			= LAB_WARM+2		; BASIC warm start vector jump high byte
    47
    48 				; *** moved from $DC-$E1 - J.Walke 2022/07/29 *****************************
    49 = 0003			NmiBase			= $03			; NMI handler enabled/setup/triggered flags
    50 										; bit	function
    51 										; ===	========
    52 										; 7	interrupt enabled
    53 										; 6	interrupt setup
    54 										; 5	interrupt happened
    55
    56 				;			= $04		; NMI handler addr low byte
    57 				;			= $05		; NMI handler addr high byte
    58 = 0006			IrqBase			= $06		; IRQ handler enabled/setup/triggered flags
    59 				;			= $07		; IRQ handler addr low byte
    60 				;			= $08		; IRQ handler addr high byte
    61
    62 				; *************************************************************************
    63
    64 = 000A			Usrjmp			= $0A		; USR function JMP address
    65 = 000B			Usrjpl			= Usrjmp+1	; USR function JMP vector low byte
    66 = 000C			Usrjph			= Usrjmp+2	; USR function JMP vector high byte
    67 = 000D			Nullct			= $0D		; nulls output after each line
    68 = 000E			TPos			= $0E		; BASIC terminal position byte
    69 = 000F			TWidth			= $0F		; BASIC terminal width byte
    70 = 0010			Iclim			= $10		; input column limit
    71 = 0011			Itempl			= $11		; temporary integer low byte
    72 = 0012			Itemph			= Itempl+1	; temporary integer high byte
    73
    74 = 0011			nums_1			= Itempl	; number to bin/hex string convert MSB
    75 = 0012			nums_2			= nums_1+1	; number to bin/hex string convert
    76 = 0013			nums_3			= nums_1+2	; number to bin/hex string convert LSB
    77
    78 				; *** free space **********************************************************
    79 				;			= $14		; *used by JC2 system
    80 				;			= $15		; *used by JC2 system
    81 				;			= $16		; *used by JC2 system
    82 				;			= $17		; *used by JC2 system
    83 				;			= $18		; *used by JC2 system
    84 				;			= $19		; *used by JC2 system 
    85 				; *************************************************************************
    86
    87 = 001A			Temp1			= $1A		; temporary byte for free use
    88
    89 = 001B			Srchc			= $1B		; search character
    90 = 001B			Temp3			= Srchc		; temp byte used in number routines
    91 = 001C			Scnquo			= $1C		; scan-between-quotes flag
    92 = 001C			Asrch			= Scnquo	; alt search character
    93
    94 = 001B			XOAw_l			= Srchc		; eXclusive OR, OR and AND word low byte
    95 = 001C			XOAw_h			= Scnquo	; eXclusive OR, OR and AND word high byte
    96
    97 = 001D			Ibptr			= $1D		; input buffer pointer
    98 = 001D			Dimcnt			= Ibptr		; # of dimensions
    99 = 001D			Tindx			= Ibptr		; token index
   100
   101 = 001E			Defdim			= $1E		; default DIM flag
   102 = 001F			Dtypef			= $1F		; data type flag, $FF=string, $00=numeric
   103 = 0020			Oquote			= $20		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
   104 = 0020			Gclctd			= $20		; garbage collected flag
   105 = 0021			Sufnxf			= $21		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   106 = 0022			Imode			= $22		; input mode flag, $00=INPUT, $80=READ
   107
   108 = 0023			Cflag			= $23		; comparison evaluation flag
   109
   110 = 0024			TabSiz			= $24		; TAB step size (was input flag)
   111
   112 = 0025			next_s			= $25		; next descriptor stack address
   113
   114 									; these two bytes form a word pointer to the item
   115 									; currently on top of the descriptor stack
   116
   117 = 0026			last_sl			= $26		; last descriptor stack address low byte
   118 = 0027			last_sh			= $27		; last descriptor stack address high byte (always $00)
   119
   120 = 0028			des_sk			= $28		; descriptor stack start address (temp strings)
   121
   122 				;			= $30		; End of descriptor stack
   123
   124 = 0031			ut1_pl			= $31		; utility pointer 1 low byte
   125 = 0032			ut1_ph			= ut1_pl+1	; utility pointer 1 high byte
   126 = 0033			ut2_pl			= $33		; utility pointer 2 low byte
   127 = 0034			ut2_ph			= ut2_pl+1	; utility pointer 2 high byte
   128
   129 = 0031			Temp_2			= ut1_pl	; temp byte for block move	
   130
   131 = 0035			FACt_1			= $35		; FAC temp mantissa1
   132 = 0036			FACt_2			= FACt_1+1	; FAC temp mantissa2
   133 = 0037			FACt_3			= FACt_2+1	; FAC temp mantissa3
   134
   135 = 0036			dims_l			= FACt_2	; array dimension size low byte
   136 = 0037			dims_h			= FACt_3	; array dimension size high byte
   137
   138 = 0038			TempB			= $38		; temp page 0 byte
   139
   140 = 0039			Smeml			= $39		; start of mem low byte		(Start-of-Basic)
   141 = 003A			Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
   142 = 003B			Svarl			= $3B		; start of vars low byte	(Start-of-Variables)
   143 = 003C			Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
   144 = 003D			Sarryl			= $3D		; var mem end low byte		(Start-of-Arrays)
   145 = 003E			Sarryh			= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
   146 = 003F			Earryl			= $3F		; array mem end low byte	(End-of-Arrays)
   147 = 0040			Earryh			= Earryl+1	; array mem end high byte	(End-of-Arrays)
   148 = 0041			Sstorl			= $41		; string storage low byte	(String storage (moving down))
   149 = 0042			Sstorh			= Sstorl+1	; string storage high byte	(String storage (moving down))
   150 = 0043			Sutill			= $43		; string utility ptr low byte
   151 = 0044			Sutilh			= Sutill+1	; string utility ptr high byte
   152 = 0045			Ememl			= $45		; end of mem low byte		(Limit-of-memory)
   153 = 0046			Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
   154 = 0047			Clinel			= $47		; current line low byte		(Basic line number)
   155 = 0048			Clineh			= Clinel+1	; current line high byte	(Basic line number)
   156 = 0049			Blinel			= $49		; break line low byte		(Previous Basic line number)
   157 = 004A			Blineh			= Blinel+1	; break line high byte		(Previous Basic line number)
   158
   159 = 004B			Cpntrl			= $4B		; continue pointer low byte
   160 = 004C			Cpntrh			= Cpntrl+1	; continue pointer high byte
   161
   162 = 004D			Dlinel			= $4D		; current DATA line low byte
   163 = 004E			Dlineh			= Dlinel+1	; current DATA line high byte
   164
   165 = 004F			Dptrl			= $4F		; DATA pointer low byte
   166 = 0050			Dptrh			= Dptrl+1	; DATA pointer high byte
   167
   168 = 0051			Rdptrl			= $51		; read pointer low byte
   169 = 0052			Rdptrh			= Rdptrl+1	; read pointer high byte
   170
   171 = 0053			Varnm1			= $53		; current var name 1st byte
   172 = 0054			Varnm2			= Varnm1+1	; current var name 2nd byte
   173
   174 = 0055			Cvaral			= $55		; current var address low byte
   175 = 0056			Cvarah			= Cvaral+1	; current var address high byte
   176
   177 = 0057			Frnxtl			= $57		; var pointer for FOR/NEXT low byte
   178 = 0058			Frnxth			= Frnxtl+1	; var pointer for FOR/NEXT high byte
   179
   180 = 0057			Tidx1			= Frnxtl	; temp line index
   181
   182 = 0057			Lvarpl			= Frnxtl	; let var pointer low byte
   183 = 0058			Lvarph			= Frnxth	; let var pointer high byte
   184
   185 = 0059			prstk			= $59		; precedence stacked flag
   186
   187 = 005B			comp_f			= $5B		; compare function flag, bits 0,1 and 2 used
   188 									; bit 2 set if >
   189 									; bit 1 set if =
   190 									; bit 0 set if <
   191
   192 = 005C			func_l			= $5C		; function pointer low byte
   193 = 005D			func_h			= func_l+1	; function pointer high byte
   194
   195 = 005C			garb_l			= func_l	; garbage collection working pointer low byte
   196 = 005D			garb_h			= func_h	; garbage collection working pointer high byte
   197
   198 = 005E			des_2l			= $5E		; string descriptor_2 pointer low byte
   199 = 005F			des_2h			= des_2l+1	; string descriptor_2 pointer high byte
   200
   201 = 0060			g_step			= $60		; garbage collect step size
   202
   203 = 0061			Fnxjmp			= $61		; jump vector for functions
   204 = 0062			Fnxjpl			= Fnxjmp+1	; functions jump vector low byte
   205 = 0063			Fnxjph			= Fnxjmp+2	; functions jump vector high byte
   206
   207 = 0062			g_indx			= Fnxjpl	; garbage collect temp index
   208 					
   209 = 0063			FAC2_r			= $63		; FAC2 rounding byte
   210
   211 = 0064			Adatal			= $64		; array data pointer low byte
   212 = 0065			Adatah			= Adatal+1	; array data pointer high  byte
   213
   214 = 0064			Nbendl			= Adatal	; new block end pointer low byte
   215 = 0065			Nbendh			= Adatah	; new block end pointer high  byte
   216
   217 = 0066			Obendl			= $66		; old block end pointer low byte
   218 = 0067			Obendh			= Obendl+1	; old block end pointer high  byte
   219
   220 = 0068			numexp			= $68		; string to float number exponent count
   221 = 0069			expcnt			= $69		; string to float exponent count
   222
   223 = 0068			numbit			= numexp	; bit count for array element calculations
   224
   225 = 006A			numdpf			= $6A		; string to float decimal point flag
   226 = 006B			expneg			= $6B		; string to float eval exponent -ve flag
   227
   228 = 006A			Astrtl			= numdpf	; array start pointer low byte
   229 = 006B			Astrth			= expneg	; array start pointer high  byte
   230
   231 = 006A			Histrl			= numdpf	; highest string low byte
   232 = 006B			Histrh			= expneg	; highest string high  byte
   233
   234 = 006A			Baslnl			= numdpf	; BASIC search line pointer low byte
   235 = 006B			Baslnh			= expneg	; BASIC search line pointer high  byte
   236
   237 = 006A			Fvar_l			= numdpf	; find/found variable pointer low byte
   238 = 006B			Fvar_h			= expneg	; find/found variable pointer high  byte
   239
   240 = 006A			Ostrtl			= numdpf	; old block start pointer low byte
   241 = 006B			Ostrth			= expneg	; old block start pointer high  byte
   242
   243 = 006A			Vrschl			= numdpf	; variable search pointer low byte
   244 = 006B			Vrschh			= expneg	; variable search pointer high  byte
   245
   246 = 006C			FAC1_e			= $6C		; FAC1 exponent
   247 = 006D			FAC1_1			= FAC1_e+1	; FAC1 mantissa1
   248 = 006E			FAC1_2			= FAC1_e+2	; FAC1 mantissa2
   249 = 006F			FAC1_3			= FAC1_e+3	; FAC1 mantissa3
   250 = 0070			FAC1_s			= FAC1_e+4	; FAC1 sign (b7)
   251
   252 = 006C			str_ln			= FAC1_e	; string length
   253 = 006D			str_pl			= FAC1_1	; string pointer low byte
   254 = 006E			str_ph			= FAC1_2	; string pointer high byte
   255
   256 = 006E			des_pl			= FAC1_2	; string descriptor pointer low byte
   257 = 006F			des_ph			= FAC1_3	; string descriptor pointer high byte
   258
   259 = 006F			mids_l			= FAC1_3	; MID$ string temp length byte
   260
   261 = 0071			negnum			= $71		; string to float eval -ve flag
   262 = 0071			numcon			= $71		; series evaluation constant count
   263
   264 = 0072			FAC1_o			= $72		; FAC1 overflow byte
   265
   266 = 0073			FAC2_e			= $73		; FAC2 exponent
   267 = 0074			FAC2_1			= FAC2_e+1	; FAC2 mantissa1
   268 = 0075			FAC2_2			= FAC2_e+2	; FAC2 mantissa2
   269 = 0076			FAC2_3			= FAC2_e+3	; FAC2 mantissa3
   270 = 0077			FAC2_s			= FAC2_e+4	; FAC2 sign (b7)
   271
   272 = 0078			FAC_sc			= $78		; FAC sign comparison, Acc#1 vs #2
   273 = 0079			FAC1_r			= $79		; FAC1 rounding byte
   274
   275 = 0078			ssptr_l			= FAC_sc	; string start pointer low byte
   276 = 0079			ssptr_h			= FAC1_r	; string start pointer high byte
   277
   278 = 0078			sdescr			= FAC_sc	; string descriptor pointer
   279
   280 = 007A			csidx			= $7A		; line crunch save index
   281 = 007A			Asptl			= csidx		; array size/pointer low byte
   282 = 007B			Aspth			= $7B		; array size/pointer high byte
   283
   284 = 007A			Btmpl			= Asptl		; BASIC pointer temp low byte
   285 = 007B			Btmph			= Aspth		; BASIC pointer temp low byte
   286
   287 = 007A			Cptrl			= Asptl		; BASIC pointer temp low byte
   288 = 007B			Cptrh			= Aspth		; BASIC pointer temp low byte
   289
   290 = 007A			Sendl			= Asptl		; BASIC pointer temp low byte
   291 = 007B			Sendh			= Aspth		; BASIC pointer temp low byte
   292
   293 = 007C			LAB_IGBY		= $7C		; get next BASIC byte subroutine
   294
   295 = 0082			LAB_GBYT		= $82		; get current BASIC byte subroutine
   296 = 0083			Bpntrl			= $83		; BASIC execute (get byte) pointer low byte
   297 = 0084			Bpntrh			= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   298
   299 				;			= $97		; end of get BASIC char subroutine
   300
   301 = 0098			Rbyte4			= $98		; extra PRNG byte
   302 = 0099			Rbyte1			= Rbyte4+1	; most significant PRNG byte
   303 = 009A			Rbyte2			= Rbyte4+2	; middle PRNG byte
   304 = 009B			Rbyte3			= Rbyte4+3	; least significant PRNG byte
   305
   306 = 009C			I2Cstat			= $9C		; BASIC I2C read byte or ACK/NACK bit
   307 = 009D			Decss			= $9D		; BASIC number to decimal string start LSB (moved from $EF)
   308 = 009E			Decssp1			= $9E		; BASIC number to decimal string start MSB (moved from $F0)
   309
   310 				; token values needed for BASIC
   311
   312 				; primary command tokens (can start a statement)
   313
   314 = 0080			TK_END		= $80			; END token
   315 = 0081			TK_FOR		= TK_END+1		; FOR token
   316 = 0082			TK_NEXT		= TK_FOR+1		; NEXT token
   317 = 0083			TK_DATA		= TK_NEXT+1		; DATA token
   318 = 0084			TK_INPUT	= TK_DATA+1		; INPUT token
   319 = 0085			TK_DIM		= TK_INPUT+1		; DIM token
   320 = 0086			TK_READ		= TK_DIM+1		; READ token
   321 = 0087			TK_LET		= TK_READ+1		; LET token
   322 = 0088			TK_DEC		= TK_LET+1		; DEC token
   323 = 0089			TK_GOTO		= TK_DEC+1		; GOTO token
   324 = 008A			TK_RUN		= TK_GOTO+1		; RUN token
   325 = 008B			TK_IF		= TK_RUN+1		; IF token
   326 = 008C			TK_RESTORE	= TK_IF+1		; RESTORE token
   327 = 008D			TK_GOSUB	= TK_RESTORE+1		; GOSUB token
   328 = 008E			TK_RETIRQ	= TK_GOSUB+1		; RETIRQ token
   329 = 008F			TK_RETNMI	= TK_RETIRQ+1		; RETNMI token
   330 = 0090			TK_RETURN	= TK_RETNMI+1		; RETURN token
   331 = 0091			TK_REM		= TK_RETURN+1		; REM token
   332 = 0092			TK_STOP		= TK_REM+1		; STOP token
   333 = 0093			TK_ON		= TK_STOP+1		; ON token
   334 = 0094			TK_NULL		= TK_ON+1		; NULL token
   335 = 0095			TK_INC		= TK_NULL+1		; INC token
   336 = 0096			TK_WAIT		= TK_INC+1		; WAIT token
   337 = 0097			TK_LOAD		= TK_WAIT+1		; LOAD token
   338 = 0098			TK_SAVE		= TK_LOAD+1		; SAVE token
   339 = 0099			TK_DEF		= TK_SAVE+1		; DEF token
   340 = 009A			TK_POKE		= TK_DEF+1		; POKE token
   341 = 009B			TK_DOKE		= TK_POKE+1		; DOKE token
   342 = 009C			TK_CALL		= TK_DOKE+1		; CALL token
   343 = 009D			TK_DO		= TK_CALL+1		; DO token
   344 = 009E			TK_LOOP		= TK_DO+1		; LOOP token
   345 = 009F			TK_PRINT	= TK_LOOP+1		; PRINT token
   346 = 00A0			TK_CONT		= TK_PRINT+1		; CONT token
   347 = 00A1			TK_LIST		= TK_CONT+1		; LIST token
   348 = 00A2			TK_CLEAR	= TK_LIST+1		; CLEAR token
   349 = 00A3			TK_NEW		= TK_CLEAR+1		; NEW token
   350 = 00A4			TK_WIDTH	= TK_NEW+1		; WIDTH token
   351 = 00A5			TK_GET		= TK_WIDTH+1		; GET token
   352 = 00A6			TK_SWAP		= TK_GET+1		; SWAP token
   353 = 00A7			TK_BITSET	= TK_SWAP+1		; BITSET token
   354 = 00A8			TK_BITCLR	= TK_BITSET+1		; BITCLR token
   355 = 00A9			TK_IRQ		= TK_BITCLR+1		; IRQ token
   356 = 00AA			TK_NMI		= TK_IRQ+1		; NMI token
   357 = 00AB			TK_BEEP		= TK_NMI+1		; BEEP token
   358 = 00AC			TK_PLIST    	= TK_BEEP+1		; PLIST token
   359 = 00AD			TK_HOME		= TK_PLIST+1		; HOME token
   360 = 00AE			TK_CLS		= TK_HOME+1		; CLS token
   361 = 00AF			TK_NORMAL	= TK_CLS+1		; NORMAL token
   362 = 00B0			TK_INVERSE	= TK_NORMAL+1		; INVERSE token
   363 = 00B1			TK_FLASH	= TK_INVERSE+1		; FLASH token
   364 = 00B2			TK_LOCATE	= TK_FLASH+1		; LOCATE token	
   365 = 00B3			TK_INNUM	= TK_LOCATE+1		; IN# token
   366 = 00B4			TK_PRNUM	= TK_INNUM+1		; PR# token
   367 = 00B5			TK_PORTIO	= TK_PRNUM+1		; PORTIO token
   368 = 00B6			TK_PORTOUT	= TK_PORTIO+1		; PORTOUT token
   369 = 00B7			TK_SCREEN	= TK_PORTOUT+1		; SCREEN token ###
   370 = 00B8			TK_PIXEL	= TK_SCREEN+1		; PIXEL token ###
   371 = 00B9			TK_LINE		= TK_PIXEL+1		; LINE token ###
   372 = 00BA			TK_OVAL		= TK_LINE+1		; OVAL token ###
   373 = 00BB			TK_RECT		= TK_OVAL+1		; RECT token ###
   374 = 00BC			TK_COLOR	= TK_RECT+1		; COLOR token ###
   375 = 00BD			TK_DELAY	= TK_COLOR+1		; DELAY token
   376 = 00BE			TK_I2COUT	= TK_DELAY+1		; I2Cout token
   377 = 00BF			TK_DOS		= TK_I2COUT+1		; DOS token
   378
   379 				; secondary command tokens, can't start a statement
   380
   381 = 00C0			TK_TAB		= TK_DOS+1		; TAB token
   382 = 00C1			TK_ELSE		= TK_TAB+1		; ELSE token
   383 = 00C2			TK_TO		= TK_ELSE+1		; TO token
   384 = 00C3			TK_FN		= TK_TO+1		; FN token
   385 = 00C4			TK_SPC		= TK_FN+1		; SPC token
   386 = 00C5			TK_THEN		= TK_SPC+1		; THEN token
   387 = 00C6			TK_NOT		= TK_THEN+1		; NOT token
   388 = 00C7			TK_STEP		= TK_NOT+1		; STEP token
   389 = 00C8			TK_UNTIL	= TK_STEP+1		; UNTIL token
   390 = 00C9			TK_WHILE	= TK_UNTIL+1		; WHILE token
   391 = 00CA			TK_OFF		= TK_WHILE+1		; OFF token
   392
   393 				; opperator tokens
   394
   395 = 00CB			TK_PLUS		= TK_OFF+1		; + token
   396 = 00CC			TK_MINUS	= TK_PLUS+1		; - token
   397 = 00CD			TK_MUL		= TK_MINUS+1		; * token
   398 = 00CE			TK_DIV		= TK_MUL+1		; / token
   399 = 00CF			TK_MOD		= TK_DIV+1		; MOD token ###
   400 = 00D0			TK_POWER	= TK_MOD+1		; ^ token
   401 = 00D1			TK_AND		= TK_POWER+1		; AND token
   402 = 00D2			TK_EOR		= TK_AND+1		; EOR token
   403 = 00D3			TK_OR		= TK_EOR+1		; OR token
   404 = 00D4			TK_RSHIFT	= TK_OR+1		; RSHIFT token
   405 = 00D5			TK_LSHIFT	= TK_RSHIFT+1		; LSHIFT token
   406 = 00D6			TK_GT		= TK_LSHIFT+1		; > token
   407 = 00D7			TK_EQUAL	= TK_GT+1		; = token
   408 = 00D8			TK_LT		= TK_EQUAL+1		; < token
   409
   410 				; functions tokens
   411
   412 = 00D9			TK_SGN		= TK_LT+1		; SGN token
   413 = 00DA			TK_INT		= TK_SGN+1		; INT token
   414 = 00DB			TK_ABS		= TK_INT+1		; ABS token
   415 = 00DC			TK_USR		= TK_ABS+1		; USR token
   416 = 00DD			TK_FRE		= TK_USR+1		; FRE token
   417 = 00DE			TK_POS		= TK_FRE+1		; POS token
   418 = 00DF			TK_SQR		= TK_POS+1		; SQR token
   419 = 00E0			TK_RND		= TK_SQR+1		; RND token
   420 = 00E1			TK_LOG		= TK_RND+1		; LOG token
   421 = 00E2			TK_EXP		= TK_LOG+1		; EXP token
   422 = 00E3			TK_COS		= TK_EXP+1		; COS token
   423 = 00E4			TK_SIN		= TK_COS+1		; SIN token
   424 = 00E5			TK_TAN		= TK_SIN+1		; TAN token
   425 = 00E6			TK_ATN		= TK_TAN+1		; ATN token
   426 = 00E7			TK_PEEK		= TK_ATN+1		; PEEK token
   427 = 00E8			TK_DEEK		= TK_PEEK+1		; DEEK token
   428 = 00E9			TK_SADD		= TK_DEEK+1		; SADD token
   429 = 00EA			TK_LEN		= TK_SADD+1		; LEN token
   430 = 00EB			TK_STRS		= TK_LEN+1		; STR$ token
   431 = 00EC			TK_VAL		= TK_STRS+1		; VAL token
   432 = 00ED			TK_ASC		= TK_VAL+1		; ASC token
   433 = 00EE			TK_UCASES	= TK_ASC+1		; UCASE$ token
   434 = 00EF			TK_LCASES	= TK_UCASES+1		; LCASE$ token
   435 = 00F0			TK_CHRS		= TK_LCASES+1		; CHR$ token
   436 = 00F1			TK_HEXS		= TK_CHRS+1		; HEX$ token
   437 = 00F2			TK_BINS		= TK_HEXS+1		; BIN$ token
   438 = 00F3			TK_BITTST	= TK_BINS+1		; BITTST token
   439 = 00F4			TK_MAX		= TK_BITTST+1		; MAX token
   440 = 00F5			TK_MIN		= TK_MAX+1		; MIN token
   441 = 00F6			TK_PI		= TK_MIN+1		; PI token
   442 = 00F7			TK_TWOPI	= TK_PI+1		; TWOPI token
   443 = 00F8			TK_VPTR		= TK_TWOPI+1		; VARPTR token
   444 = 00F9			TK_LEFTS	= TK_VPTR+1		; LEFT$ token
   445 = 00FA			TK_RIGHTS	= TK_LEFTS+1		; RIGHT$ token
   446 = 00FB			TK_MIDS		= TK_RIGHTS+1		; MID$ token
   447 = 00FC			TK_PORTIN	= TK_MIDS+1		; PORTIN token
   448 = 00FD			TK_I2CIN	= TK_PORTIN+1		; I2CIN token
   449 = 00FE			TK_RES5		= TK_I2CIN+1		; RESERVED ###
   450 = 00FF			TK_RES6		= TK_RES5+1		; RESERVED ###
   451
   452 				; offsets from a base of X or Y
   453 = 0000			PLUS_0		= $00			; X or Y plus 0
   454 = 0001			PLUS_1		= $01			; X or Y plus 1
   455 = 0002			PLUS_2		= $02			; X or Y plus 2
   456 = 0003			PLUS_3		= $03			; X or Y plus 3
   457
   458 = 0100			LAB_STAK	= $0100			; stack bottom, no offset
   459 = 01FE			LAB_SKFE	= LAB_STAK+$FE		; flushed stack address
   460 = 01FF			LAB_SKFF	= LAB_STAK+$FF		; flushed stack address
   461
   462 = 2001			Ram_base	= $2001			; start of user RAM (set as needed, should be page aligned)
   463 = 0010			Stack_floor	= 16			; bytes left free on stack for background interrupts
   464
   465 				; INPBUF moved to jc2_defines.inc 
   466
   467 				; Constants defined for I2Cin() and I2Cout functions
   468 = 0001			I2C_STA		= 1			; I2Cout Start command
   469 = 0000			I2C_STAT	= 0			; I2Cin return I2Cstat value
   470 = 0001			I2C_RD_ACK	= 1			; I2Cin Read + ACK
   471 = 0002			I2C_RD_NAK	= 2			; I2Cin Read + NACK + Stop
   472 = 0003			I2C_STO		= 3			; I2Cin Stop only
   473
   474 				; BASIC cold start entry point
   475 				; new page 2 initialisation, copy block to ccflag on
   476 B000			LAB_COLD
   477 B000 A0 04			LDY	#PG2_TABE-PG2_TABS-1
   478 										; byte count-1
   479 B002			LAB_2D13
   480 B002 B9 12 D3			LDA	PG2_TABS,Y			; get byte
   481 B005 99 68 18			STA	ccflag,Y			; store in page 2
   482 B008 88				DEY					; decrement count
   483 B009 10 F7			BPL	LAB_2D13			; loop if not done
   484
   485 B00B A2 FF			LDX	#$FF				; set byte
   486 B00D 86 48			STX	Clineh				; set current line high byte (set immediate mode)
   487 B00F 9A				TXS					; reset stack pointer
   488
   489 B010 A9 4C			LDA	#$4C				; code for JMP
   490 B012 85 61			STA	Fnxjmp				; save for jump vector for functions
   491
   492 				; copy block from LAB_2CEE to $00BC - $00D3
   493 B014 A2 1C			LDX	#StrTab-LAB_2CEE		; set byte count
   494 B016			LAB_2D4E
   495 B016 BD 16 D3			LDA	LAB_2CEE-1,X			; get byte from table
   496 B019 95 7B			STA	LAB_IGBY-1,X			; save byte in page zero
   497 B01B CA				DEX					; decrement count
   498 B01C D0 F8			BNE	LAB_2D4E			; loop if not all done
   499
   500 				; copy block from StrTab to $0000 - $0012
   501 B01E			LAB_GMEM
   502 B01E A2 12			LDX	#EndTab-StrTab-1; set byte count-1
   503 B020			TabLoop
   504 B020 BD 33 D3			LDA	StrTab,X			; get byte from table
   505 B023 95 00			STA	PLUS_0,X			; save byte in page zero
   506 B025 CA				DEX					; decrement count
   507 B026 10 F8			BPL	TabLoop				; loop if not all done
   508
   509 				; set-up start values
   510
   511 B028 A9 00			LDA	#$00				; clear A
   512 B02A 85 03			STA	NmiBase				; clear NMI handler enabled flag
   513 B02C 85 06			STA	IrqBase				; clear IRQ handler enabled flag
   514 B02E 85 72			STA	FAC1_o				; clear FAC1 overflow byte
   515 B030 85 27			STA	last_sh				; clear descriptor stack top item pointer high byte
   516
   517 B032 A9 0E			LDA	#$0E				; set default tab size
   518 B034 85 24			STA	TabSiz				; save it
   519 B036 A9 03			LDA	#$03				; set garbage collect step size for descriptor stack
   520 B038 85 60			STA	g_step				; save it
   521 B03A A2 28			LDX	#des_sk				; descriptor stack start
   522 B03C 86 25			STX	next_s				; set descriptor stack pointer
   523 B03E 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   524 				; #########################	
   525 B041 20 BB D1			JSR	CLEAR_BASE			; clear first two bytes of memory to avoid crash
   526 				; #########################	
   527 B044 A9 46			LDA	#<LAB_MSZM			; point to memory size message (low addr)
   528 B046 A0 D3			LDY	#>LAB_MSZM			; point to memory size message (high addr)
   529 B048 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   530 				;	JSR	LAB_INLN			; print '? ' and get BASIC input
   531 B04B 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   532 B04D 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   533 				;	JSR	LAB_GBYT			; get last byte back
   534
   535 				;	BNE	LAB_2DAA			; branch if not null (user typed something)
   536
   537 				;	LDY	#$00				; else clear Y
   538 										; character was null so get memory size the hard way
   539 										; we get here with Y=0 and Itempl/h = Ram_base
   540 B04F			LAB_2D93	; Disable destructive RAM-test, which did set all available memory to $AA
   541 B04F A9 00			LDA	#<RAM_TOP			; A = LSB of RAM_TOP
   542 B051 A0 B0			LDY	#>RAM_TOP			; Y = MSB of RAM_TOP
   543 				;	INC	Itempl				; increment temporary integer low byte
   544 				;	BNE	LAB_2D99			; branch if no overflow
   545 				;
   546 				;	INC	Itemph				; increment temporary integer high byte
   547 				;	LDA	Itemph				; get high byte
   548 				;	CMP	#>RAM_TOP			; compare with top of RAM+1
   549 				;	BEQ	LAB_2DB6			; branch if match (end of user RAM)
   550 				;
   551 				;LAB_2D99
   552 				;	LDA	#$55				; set test byte
   553 				;	STA	(Itempl),Y			; save via temporary integer
   554 				;	CMP	(Itempl),Y			; compare via temporary integer
   555 				;	BNE	LAB_2DB6			; branch if fail
   556 				;
   557 				;	ASL					; shift test byte left (now $AA)
   558 				;	STA	(Itempl),Y			; save via temporary integer
   559 				;	CMP	(Itempl),Y			; compare via temporary integer
   560 				;	BEQ	LAB_2D93			; if ok go do next byte
   561 				;
   562 				;	BNE	LAB_2DB6			; branch if fail
   563 				;
   564 				;LAB_2DAA
   565 				;	JSR	LAB_2887			; get FAC1 from string
   566 				;	LDA	FAC1_e				; get FAC1 exponent
   567 				;	CMP	#$98				; compare with exponent = 2^24
   568 				;	BCS	LAB_GMEM			; if too large go try again
   569 				;
   570 				;	JSR	LAB_F2FU			; save integer part of FAC1 in temporary integer
   571 				;						; (no range check)
   572 				;
   573 				;LAB_2DB6
   574 				;	LDA	Itempl				; get temporary integer low byte
   575 				;	LDY	Itemph				; get temporary integer high byte
   576 				;	CPY	#<Ram_base+1			; compare with start of RAM+$100 high byte
   577 				;	BCC	LAB_GMEM			; if too small go try again
   578 				;
   579 				;
   580 				; uncomment these lines if you want to check on the high limit of memory. Note if
   581 				; RAM_TOP is set too low then this will fail. default is ignore it and assume the
   582 				; users know what they're doing!
   583
   584 				;	CPY	#>RAM_TOP			; compare with top of RAM high byte
   585 				;	BCC	MEM_OK				; branch if < RAM top
   586
   587 				;	BNE	LAB_GMEM			; if too large go try again
   588 										; else was = so compare low bytes
   589 				;	CMP	#<RAM_TOP			; compare with top of RAM low byte
   590 				;	BEQ	MEM_OK				; branch if = RAM top
   591
   592 				;	BCS	LAB_GMEM			; if too large go try again
   593 				;MEM_OK
   594 B053 85 45			STA	Ememl				; set end of mem low byte
   595 B055 84 46			STY	Ememh				; set end of mem high byte
   596 B057 85 41			STA	Sstorl				; set bottom of string space low byte
   597 B059 84 42			STY	Sstorh				; set bottom of string space high byte
   598
   599 B05B A0 01			LDY	#<Ram_base			; set start addr low byte
   600 B05D A2 20			LDX	#>Ram_base			; set start addr high byte
   601 B05F 84 39			STY	Smeml				; save start of mem low byte
   602 B061 86 3A			STX	Smemh				; save start of mem high byte
   603
   604 				; this line is only needed if Ram_base is not $xx00
   605
   606 				;	LDY	#$00				; clear Y
   607 B063 98				TYA					; clear A
   608 B064 91 39			STA	(Smeml),Y			; clear first byte
   609 B066 E6 39			INC	Smeml				; increment start of mem low byte
   610
   611 				; these two lines are only needed if Ram_base is $xxFF
   612
   613 				;	BNE	LAB_2E05			; branch if no rollover
   614
   615 				;	INC	Smemh				; increment start of mem high byte
   616 B068			LAB_2E05
   617 B068 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   618 B06B 20 33 B3			JSR	LAB_1463			; do 'NEW' and 'CLEAR'
   619 B06E A5 45			LDA	Ememl				; get end of mem low byte
   620 B070 38				SEC					; set carry for subtract
   621 B071 E5 39			SBC	Smeml				; subtract start of mem low byte
   622 B073 AA				TAX					; copy to X
   623 B074 A5 46			LDA	Ememh				; get end of mem high byte
   624 B076 E5 3A			SBC	Smemh				; subtract start of mem high byte
   625 B078 20 6F CA			JSR	LAB_295E			; print XA as unsigned integer (bytes free)
   626 B07B A9 5B			LDA	#<LAB_SMSG			; point to sign-on message (low addr)
   627 B07D A0 D3			LDY	#>LAB_SMSG			; point to sign-on message (high addr)
   628 B07F 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   629 B082 A9 2C			LDA	#<LAB_1274			; warm start vector low byte
   630 B084 A0 B1			LDY	#>LAB_1274			; warm start vector high byte
   631 B086 85 01			STA	Wrmjpl				; save warm start vector low byte
   632 B088 84 02			STY	Wrmjph				; save warm start vector high byte
   633 B08A 6C 01 00			JMP	(Wrmjpl)			; go do warm start
   634
   635 				; open up space in memory
   636 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   637
   638 				; Nbendl,Nbendh - new block end address (A/Y)
   639 				; Obendl,Obendh - old block end address
   640 				; Ostrtl,Ostrth - old block start address
   641
   642 				; returns with ..
   643
   644 				; Nbendl,Nbendh - new block start address (high byte - $100)
   645 				; Obendl,Obendh - old block start address (high byte - $100)
   646 				; Ostrtl,Ostrth - old block start address (unchanged)
   647 B08D			LAB_11CF
   648 B08D 20 DA B0			JSR	LAB_121F			; check available memory, 'Out of memory' error if no room
   649 										; addr to check is in AY (low/high)
   650 B090 85 3F			STA	Earryl				; save new array mem end low byte
   651 B092 84 40			STY	Earryh				; save new array mem end high byte
   652
   653 				; open up space in memory
   654 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   655 				; don't set array end
   656 B094			LAB_11D6
   657 B094 38				SEC					; set carry for subtract
   658 B095 A5 66			LDA	Obendl				; get block end low byte
   659 B097 E5 6A			SBC	Ostrtl				; subtract block start low byte
   660 B099 A8				TAY					; copy MOD(block length/$100) byte to Y
   661 B09A A5 67			LDA	Obendh				; get block end high byte
   662 B09C E5 6B			SBC	Ostrth				; subtract block start high byte
   663 B09E AA				TAX					; copy block length high byte to X
   664 B09F E8				INX					; +1 to allow for count=0 exit
   665 B0A0 98				TYA					; copy block length low byte to A
   666 B0A1 F0 24			BEQ	LAB_120A			; branch if length low byte=0
   667
   668 										; block is (X-1)*256+Y bytes, do the Y bytes first
   669
   670 B0A3 38				SEC					; set carry for add + 1, two's complement
   671 B0A4 49 FF			EOR	#$FF				; invert low byte for subtract
   672 B0A6 65 66			ADC	Obendl				; add block end low byte
   673
   674 B0A8 85 66			STA	Obendl				; save corrected old block end low byte
   675 B0AA B0 03			BCS	LAB_11F3			; branch if no underflow
   676
   677 B0AC C6 67			DEC	Obendh				; else decrement block end high byte
   678 B0AE 38				SEC					; set carry for add + 1, two's complement
   679 B0AF			LAB_11F3
   680 B0AF 98				TYA					; get MOD(block length/$100) byte
   681 B0B0 49 FF			EOR	#$FF				; invert low byte for subtract
   682 B0B2 65 64			ADC	Nbendl				; add destination end low byte
   683 B0B4 85 64			STA	Nbendl				; save modified new block end low byte
   684 B0B6 B0 08			BCS	LAB_1203			; branch if no underflow
   685
   686 B0B8 C6 65			DEC	Nbendh				; else decrement block end high byte
   687 B0BA 90 04			BCC	LAB_1203			; branch always
   688
   689 B0BC			LAB_11FF
   690 B0BC B1 66			LDA	(Obendl),Y			; get byte from source
   691 B0BE 91 64			STA	(Nbendl),Y			; copy byte to destination
   692 B0C0			LAB_1203
   693 B0C0 88				DEY					; decrement index
   694 B0C1 D0 F9			BNE	LAB_11FF			; loop until Y=0
   695
   696 										; now do Y=0 indexed byte
   697 B0C3 B1 66			LDA	(Obendl),Y			; get byte from source
   698 B0C5 91 64			STA	(Nbendl),Y			; save byte to destination
   699 B0C7			LAB_120A
   700 B0C7 C6 67			DEC	Obendh				; decrement source pointer high byte
   701 B0C9 C6 65			DEC	Nbendh				; decrement destination pointer high byte
   702 B0CB CA				DEX					; decrement block count
   703 B0CC D0 F2			BNE	LAB_1203			; loop until count = $0
   704
   705 B0CE 60				RTS
   706
   707 				; check room on stack for A bytes
   708 				; stack too deep? do OM error
   709 B0CF			LAB_1212
   710 					.if	Stack_floor			; Stack floor protection patch
   711 B0CF 18				CLC					; prep ADC
   712 B0D0 69 10			ADC	#Stack_floor			; stack pointer lower limit before interrupts
   713 					.endif
   714 B0D2 85 38			STA	TempB				; save result in temp byte
   715 B0D4 BA				TSX					; copy stack
   716 B0D5 E4 38			CPX	TempB				; compare new 'limit' with stack
   717 B0D7 90 30			BCC	LAB_OMER			; if stack < limit do 'Out of memory' error then warm start
   718
   719 B0D9 60				RTS
   720
   721 				; check available memory, 'Out of memory' error if no room
   722 				; addr to check is in AY (low/high)
   723 B0DA			LAB_121F
   724 B0DA C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   725 B0DC 90 2A			BCC	LAB_124B			; if less then exit (is ok)
   726
   727 B0DE D0 04			BNE	LAB_1229			; skip next test if greater (tested <)
   728
   729 										; high byte was =, now do low byte
   730 B0E0 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   731 B0E2 90 24			BCC	LAB_124B			; if less then exit (is ok)
   732
   733 										; addr is > string storage ptr (oops!)
   734 B0E4			LAB_1229
   735 B0E4 48				PHA					; push addr low byte
   736 B0E5 A2 08			LDX	#$08				; set index to save Adatal to expneg inclusive
   737 B0E7 98				TYA					; copy addr high byte (to push on stack)
   738
   739 										; save misc numeric work area
   740 B0E8			LAB_122D
   741 B0E8 48				PHA					; push byte
   742 B0E9 B5 63			LDA	Adatal-1,X			; get byte from Adatal to expneg ( ,$00 not pushed)
   743 B0EB CA				DEX					; decrement index
   744 B0EC 10 FA			BPL	LAB_122D			; loop until all done
   745
   746 B0EE 20 CC C1			JSR	LAB_GARB			; garbage collection routine
   747
   748 										; restore misc numeric work area
   749 B0F1 A2 00			LDX	#$00				; clear the index to restore bytes
   750 B0F3			LAB_1238
   751 B0F3 68				PLA					; pop byte
   752 B0F4 95 64			STA	Adatal,X			; save byte to Adatal to expneg
   753 B0F6 E8				INX					; increment index
   754 B0F7 E0 08			CPX	#$08				; compare with end + 1
   755 B0F9 30 F8			BMI	LAB_1238			; loop if more to do
   756
   757 B0FB 68				PLA					; pop addr high byte
   758 B0FC A8				TAY					; copy back to Y
   759 B0FD 68				PLA					; pop addr low byte
   760 B0FE C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   761 B100 90 06			BCC	LAB_124B			; if less then exit (is ok)
   762
   763 B102 D0 05			BNE	LAB_OMER			; if greater do 'Out of memory' error then warm start
   764
   765 										; high byte was =, now do low byte
   766 B104 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   767 B106 B0 01			BCS	LAB_OMER			; if >= do 'Out of memory' error then warm start
   768
   769 										; ok exit, carry clear
   770 B108			LAB_124B
   771 B108 60				RTS
   772
   773 				; do 'Out of memory' error then warm start
   774 B109			LAB_OMER
   775 B109 A2 0C			LDX	#$0C				; error code $0C ('Out of memory' error)
   776
   777 				; do error #X, then warm start
   778 B10B			LAB_XERR
   779 B10B 20 CA D1			JSR	LAB_SYSBEEP
   780 B10E 20 70 B8			JSR	LAB_CRLF			; print CR/LF
   781
   782 B111 BD DE D9			LDA	LAB_BAER,X			; get error message pointer low byte
   783 B114 BC DF D9			LDY	LAB_BAER+1,X			; get error message pointer high byte
   784 B117 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   785
   786 B11A 20 6C B3			JSR	LAB_1491			; flush stack and clear continue flag
   787 B11D A9 1B			LDA	#<LAB_EMSG			; point to ' Error' low addr
   788 B11F A0 DB			LDY	#>LAB_EMSG			; point to ' Error' high addr
   789 B121			LAB_1269
   790 B121 20 B1 B8			JSR	LAB_18C3			; print null terminated string from memory
   791 B124 A4 48			LDY	Clineh				; get current line high byte
   792 B126 C8				INY					; increment it
   793 B127 F0 03			BEQ	LAB_1274			; go do warm start (was immediate mode)
   794
   795 										; else print line number
   796 B129 20 64 CA			JSR	LAB_2953			; print ' in line [LINE #]'
   797
   798 				; BASIC warm start entry point
   799 				; wait for Basic command
   800 B12C			LAB_1274
   801 										; clear ON IRQ/NMI bytes
   802 B12C A9 00			LDA	#$00				; clear A
   803 B12E 85 06			STA	IrqBase				; clear enabled byte
   804 B130 85 03			STA	NmiBase				; clear enabled byte
   805 B132 A9 2C			LDA	#<LAB_RMSG			; point to 'Ready' message low byte
   806 B134 A0 DB			LDY	#>LAB_RMSG			; point to 'Ready' message high byte
   807
   808 B136 20 B1 B8			JSR	LAB_18C3			; go do print string
   809
   810 				; wait for Basic command (no 'Ready')
   811 B139			LAB_127D
   812 B139 20 1F B2			JSR	LAB_1357			; call for BASIC input
   813 B13C			LAB_1280
   814 B13C 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   815 B13E 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   816 B140 20 82 00			JSR	LAB_GBYT			; scan memory
   817 B143 F0 F4			BEQ	LAB_127D			; loop while null
   818
   819 				; got to interpret input line now ..
   820 B145 A2 FF			LDX	#$FF				; current line to null value
   821 B147 86 48			STX	Clineh				; set current line high byte
   822 B149 90 06			BCC	LAB_1295			; branch if numeric character (handle new BASIC line)
   823
   824 										; no line number .. immediate mode
   825 B14B 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   826 B14E 4C D2 B4			JMP	LAB_15F6			; go scan and interpret code
   827
   828 				; handle new BASIC line
   829 B151			LAB_1295
   830 B151 20 33 B7			JSR	LAB_GFPN			; get fixed-point number into temp integer
   831 B154 20 50 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   832 B157 84 1D			STY	Ibptr				; save index pointer to end of crunched line
   833 B159 20 07 B3			JSR	LAB_SSLN			; search BASIC for temp integer line number
   834 B15C 90 44			BCC	LAB_12E6			; branch if not found
   835
   836 										; aroooogah! line # already exists! delete it
   837 B15E A0 01			LDY	#$01				; set index to next line pointer high byte
   838 B160 B1 6A			LDA	(Baslnl),Y			; get next line pointer high byte
   839 B162 85 32			STA	ut1_ph				; save it
   840 B164 A5 3B			LDA	Svarl				; get start of vars low byte
   841 B166 85 31			STA	ut1_pl				; save it
   842 B168 A5 6B			LDA	Baslnh				; get found line pointer high byte
   843 B16A 85 34			STA	ut2_ph				; save it
   844 B16C A5 6A			LDA	Baslnl				; get found line pointer low byte
   845 B16E 88				DEY					; decrement index
   846 B16F F1 6A			SBC	(Baslnl),Y			; subtract next line pointer low byte
   847 B171 18				CLC					; clear carry for add
   848 B172 65 3B			ADC	Svarl				; add start of vars low byte
   849 B174 85 3B			STA	Svarl				; save new start of vars low byte
   850 B176 85 33			STA	ut2_pl				; save destination pointer low byte
   851 B178 A5 3C			LDA	Svarh				; get start of vars high byte
   852 B17A 69 FF			ADC	#$FF				; -1 + carry
   853 B17C 85 3C			STA	Svarh				; save start of vars high byte
   854 B17E E5 6B			SBC	Baslnh				; subtract found line pointer high byte
   855 B180 AA				TAX					; copy to block count
   856 B181 38				SEC					; set carry for subtract
   857 B182 A5 6A			LDA	Baslnl				; get found line pointer low byte
   858 B184 E5 3B			SBC	Svarl				; subtract start of vars low byte
   859 B186 A8				TAY					; copy to bytes in first block count
   860 B187 B0 03			BCS	LAB_12D0			; branch if overflow
   861
   862 B189 E8				INX					; increment block count (correct for =0 loop exit)
   863 B18A C6 34			DEC	ut2_ph				; decrement destination high byte
   864 B18C			LAB_12D0
   865 B18C 18				CLC					; clear carry for add
   866 B18D 65 31			ADC	ut1_pl				; add source pointer low byte
   867 B18F 90 03			BCC	LAB_12D8			; branch if no overflow
   868
   869 B191 C6 32			DEC	ut1_ph				; else decrement source pointer high byte
   870 B193 18				CLC					; clear carry
   871
   872 										; close up memory to delete old line
   873 B194			LAB_12D8
   874 B194 B1 31			LDA	(ut1_pl),Y			; get byte from source
   875 B196 91 33			STA	(ut2_pl),Y			; copy to destination
   876 B198 C8				INY					; increment index
   877 B199 D0 F9			BNE	LAB_12D8			; while <> 0 do this block
   878
   879 B19B E6 32			INC	ut1_ph				; increment source pointer high byte
   880 B19D E6 34			INC	ut2_ph				; increment destination pointer high byte
   881 B19F CA				DEX					; decrement block count
   882 B1A0 D0 F2			BNE	LAB_12D8			; loop until all done
   883
   884 										; got new line in buffer and no existing same #
   885 B1A2			LAB_12E6
   886 B1A2 AD 7F 18			LDA	Ibuffs				; get byte from start of input buffer
   887 B1A5 F0 3F			BEQ	LAB_1319			; if null line just go flush stack/vars and exit
   888
   889 										; got new line and it isn't empty line
   890 B1A7 A5 45			LDA	Ememl				; get end of mem low byte
   891 B1A9 A4 46			LDY	Ememh				; get end of mem high byte
   892 B1AB 85 41			STA	Sstorl				; set bottom of string space low byte
   893 B1AD 84 42			STY	Sstorh				; set bottom of string space high byte
   894 B1AF A5 3B			LDA	Svarl				; get start of vars low byte	(end of BASIC)
   895 B1B1 85 66			STA	Obendl				; save old block end low byte
   896 B1B3 A4 3C			LDY	Svarh				; get start of vars high byte	(end of BASIC)
   897 B1B5 84 67			STY	Obendh				; save old block end high byte
   898 B1B7 65 1D			ADC	Ibptr				; add input buffer pointer	(also buffer length)
   899 B1B9 90 01			BCC	LAB_1301			; branch if no overflow from add
   900
   901 B1BB C8				INY					; else increment high byte
   902 B1BC			LAB_1301
   903 B1BC 85 64			STA	Nbendl				; save new block end low byte	(move to, low byte)
   904 B1BE 84 65			STY	Nbendh				; save new block end high byte
   905 B1C0 20 8D B0			JSR	LAB_11CF			; open up space in memory
   906 										; old start pointer Ostrtl,Ostrth set by the find line call
   907 B1C3 A5 3F			LDA	Earryl				; get array mem end low byte
   908 B1C5 A4 40			LDY	Earryh				; get array mem end high byte
   909 B1C7 85 3B			STA	Svarl				; save start of vars low byte
   910 B1C9 84 3C			STY	Svarh				; save start of vars high byte
   911 B1CB A4 1D			LDY	Ibptr				; get input buffer pointer	(also buffer length)
   912 B1CD 88				DEY					; adjust for loop type
   913 B1CE			LAB_1311
   914 B1CE B9 7B 18			LDA	Ibuffs-4,Y			; get byte from crunched line
   915 B1D1 91 6A			STA	(Baslnl),Y			; save it to program memory
   916 B1D3 88				DEY					; decrement count
   917 B1D4 C0 03			CPY	#$03				; compare with first byte-1
   918 B1D6 D0 F6			BNE	LAB_1311			; continue while count <> 3
   919
   920 B1D8 A5 12			LDA	Itemph				; get line # high byte
   921 B1DA 91 6A			STA	(Baslnl),Y			; save it to program memory
   922 B1DC 88				DEY					; decrement count
   923 B1DD A5 11			LDA	Itempl				; get line # low byte
   924 B1DF 91 6A			STA	(Baslnl),Y			; save it to program memory
   925 B1E1 88				DEY					; decrement count
   926 B1E2 A9 FF			LDA	#$FF				; set byte to allow chain rebuild. if you didn't set this
   927 										; byte then a zero already here would stop the chain rebuild
   928 										; as it would think it was the [EOT] marker.
   929 B1E4 91 6A			STA	(Baslnl),Y			; save it to program memory
   930
   931 B1E6			LAB_1319
   932 B1E6 20 48 B3			JSR	LAB_1477			; reset execution to start, clear vars and flush stack
   933 B1E9 A6 39			LDX	Smeml				; get start of mem low byte
   934 B1EB A5 3A			LDA	Smemh				; get start of mem high byte
   935 B1ED A0 01			LDY	#$01				; index to high byte of next line pointer
   936 B1EF			LAB_1325
   937 B1EF 86 31			STX	ut1_pl				; set line start pointer low byte
   938 B1F1 85 32			STA	ut1_ph				; set line start pointer high byte
   939 B1F3 B1 31			LDA	(ut1_pl),Y			; get it
   940 B1F5 F0 18			BEQ	LAB_133E			; exit if end of program
   941
   942 				; rebuild chaining of Basic lines
   943 B1F7 A0 04			LDY	#$04				; point to first code byte of line
   944 										; there is always 1 byte + [EOL] as null entries are deleted
   945 B1F9			LAB_1330
   946 B1F9 C8				INY					; next code byte
   947 B1FA B1 31			LDA	(ut1_pl),Y			; get byte
   948 B1FC D0 FB			BNE	LAB_1330			; loop if not [EOL]
   949
   950 B1FE 38				SEC					; set carry for add + 1
   951 B1FF 98				TYA					; copy end index
   952 B200 65 31			ADC	ut1_pl				; add to line start pointer low byte
   953 B202 AA				TAX					; copy to X
   954 B203 A0 00			LDY	#$00				; clear index, point to this line's next line pointer
   955 B205 91 31			STA	(ut1_pl),Y			; set next line pointer low byte
   956 B207 98				TYA					; clear A
   957 B208 65 32			ADC	ut1_ph				; add line start pointer high byte + carry
   958 B20A C8				INY					; increment index to high byte
   959 B20B 91 31			STA	(ut1_pl),Y			; save next line pointer low byte
   960 B20D 90 E0			BCC	LAB_1325			; go do next line, branch always, carry clear
   961
   962
   963 B20F			LAB_133E
   964 B20F 4C 39 B1			JMP	LAB_127D			; else we just wait for Basic command, no 'Ready'
   965
   966 				; print '? ' and get BASIC input
   967 B212			LAB_INLN
   968 B212 20 C9 B8			JSR	LAB_18E3			; print '?' character
   969 B215 20 C6 B8			JSR	LAB_18E0			; print ' '
   970 B218 D0 05			BNE	LAB_1357			; call for BASIC input and return
   971
   972 				; receive line from keyboard
   973 										; $08 as delete key (BACKSPACE on standard keyboard)
   974 B21A			LAB_134B
   975 B21A 20 CB B8			JSR	LAB_PRNA			; go print the character
   976 B21D CA				DEX					; decrement the buffer counter (delete)
   977 B21E 2C				.byte	$2C				; make LDX into BIT abs
   978
   979 				; call for BASIC input (main entry point)
   980 B21F			LAB_1357
   981 B21F A2 00			LDX	#$00			; clear BASIC line buffer pointer
   982 B221			LAB_1359
   983 B221 20 0C D3			JSR	V_INPT			; call scan input device
   984 B224 90 FB			BCC	LAB_1359		; loop if no byte
   985
   986 B226 F0 F9			BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   987
   988 B228 C9 07			CMP	#$07			; compare with [BELL]
   989 B22A F0 10			BEQ	LAB_1378		; branch if [BELL]
   990
   991 B22C C9 0D			CMP	#$0D			; compare with [CR]
   992 B22E F0 19			BEQ	LAB_1384		; do CR/LF exit if [CR]
   993
   994 B230 E0 00			CPX	#$00			; compare pointer with $00
   995 B232 D0 04			BNE	LAB_1374		; branch if not empty
   996
   997 				; next two lines ignore any non print character and [SPACE] if input buffer empty
   998 B234 C9 21			CMP	#$21			; compare with [SP]+1
   999 B236 90 E9			BCC	LAB_1359		; if < ignore character
  1000
  1001 B238			LAB_1374
  1002 B238 C9 08			CMP	#$08			; compare with [BACKSPACE] (delete last character)
  1003 B23A F0 DE			BEQ	LAB_134B		; go delete last character
  1004
  1005 B23C			LAB_1378
  1006 B23C E0 7F			CPX	#Ibuffe-Ibuffs		; compare character count with max
  1007 B23E B0 0C			BCS	LAB_138E		; skip store and do [BELL] if buffer full
  1008
  1009 B240 9D 7F 18			STA	Ibuffs,X		; else store in buffer
  1010 B243 E8				INX				; increment pointer
  1011 B244			LAB_137F
  1012 B244 20 CB B8			JSR	LAB_PRNA		; go print the character
  1013 B247 D0 D8			BNE	LAB_1359		; always loop for next character
  1014
  1015 B249			LAB_1384
  1016 B249 4C 67 B8			JMP	LAB_1866		; do CR/LF exit to BASIC
  1017
  1018 				; announce buffer full
  1019 B24C			LAB_138E
  1020 B24C A9 07			LDA	#$07			; [BELL] character into A
  1021 B24E D0 F4			BNE	LAB_137F		; go print the [BELL] but ignore input character
  1022 									; branch always
  1023
  1024 				; crunch keywords into Basic tokens
  1025 				; position independent buffer version ..
  1026 				; faster, dictionary search version ....
  1027 B250			LAB_13A6
  1028 B250 A0 FF			LDY	#$FF			; set save index (makes for easy math later)
  1029
  1030 B252 38				SEC				; set carry for subtract
  1031 B253 A5 83			LDA	Bpntrl			; get basic execute pointer low byte
  1032 B255 E9 7F			SBC	#<Ibuffs		; subtract input buffer start pointer
  1033 B257 AA				TAX				; copy result to X (index past line # if any)
  1034
  1035 B258 86 20			STX	Oquote			; clear open quote/DATA flag
  1036 B25A			LAB_13AC
  1037 B25A BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1038 B25D F0 62			BEQ	LAB_13EC		; if null save byte then exit
  1039
  1040 B25F C9 7B			CMP   	#'{'           		; convert lower to upper case
  1041 B261 B0 5E			BCS   	LAB_13EC       	 	; is above lower case
  1042 B263 C9 61			CMP   	#'a'
  1043 B265 90 02			BCC   	PATCH_LC       		; is below lower case
  1044 B267 29 DF			AND   	#$DF           		; mask lower case bit
  1045 				      
  1046 B269			PATCH_LC
  1047 B269 C9 5F			CMP	#'_'			; compare with '_'
  1048 B26B B0 54			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1049
  1050 B26D C9 3C			CMP	#'<'			; compare with '<'
  1051 B26F B0 0E			BCS	LAB_13CC		; if >= go crunch now
  1052
  1053 B271 C9 30			CMP	#'0'			; compare with '0'
  1054 B273 B0 4C			BCS	LAB_13EC		; if >= go save byte then continue crunching
  1055
  1056 B275 85 1C			STA	Scnquo			; save buffer byte as search character
  1057 B277 C9 22			CMP	#$22			; is it quote character?
  1058 B279 F0 68			BEQ	LAB_1410		; branch if so (copy quoted string)
  1059
  1060 B27B C9 2A			CMP	#'*'			; compare with '*'
  1061 B27D 90 42			BCC	LAB_13EC		; if < go save byte then continue crunching
  1062 									; else crunch now
  1063 B27F			LAB_13CC
  1064 B27F 24 20			BIT	Oquote			; get open quote/DATA token flag
  1065 B281 70 3E			BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
  1066 									; go save byte then continue crunching
  1067
  1068 B283 86 38			STX	TempB			; save buffer read index
  1069 B285 84 7A			STY	csidx			; copy buffer save index
  1070 B287 A0 61			LDY	#<TAB_1STC		; get keyword first character table low address
  1071 B289 84 33			STY	ut2_pl			; save pointer low byte
  1072 B28B A0 D5			LDY	#>TAB_1STC		; get keyword first character table high address
  1073 B28D 84 34			STY	ut2_ph			; save pointer high byte
  1074 B28F A0 00			LDY	#$00			; clear table pointer
  1075
  1076 B291			LAB_13D0
  1077 B291 D1 33			CMP	(ut2_pl),Y		; compare with keyword first character table byte
  1078 B293 F0 05			BEQ	LAB_13D1		; go do word_table_chr if match
  1079
  1080 B295 90 60			BCC   	PATCH_LC2		; if < keyword first character table byte go restore
  1081 									; Y and save to crunched
  1082
  1083 B297 C8				INY				; else increment pointer
  1084 B298 D0 F7			BNE	LAB_13D0		; and loop (branch always)
  1085
  1086 				; have matched first character of some keyword
  1087 B29A			LAB_13D1
  1088 B29A 98				TYA				; copy matching index
  1089 B29B 0A				ASL				; *2 (bytes per pointer)
  1090 B29C AA				TAX				; copy to new index
  1091 B29D BD 7F D5			LDA	TAB_CHRT,X		; get keyword table pointer low byte
  1092 B2A0 85 33			STA	ut2_pl			; save pointer low byte
  1093 B2A2 BD 80 D5			LDA	TAB_CHRT+1,X		; get keyword table pointer high byte
  1094 B2A5 85 34			STA	ut2_ph			; save pointer high byte
  1095
  1096 B2A7 A0 FF			LDY	#$FF			; clear table pointer (make -1 for start)
  1097
  1098 B2A9 A6 38			LDX	TempB			; restore buffer read index
  1099 B2AB			LAB_13D6
  1100 B2AB C8				INY				; next table byte
  1101 B2AC B1 33			LDA	(ut2_pl),Y		; get byte from table
  1102 B2AE			LAB_13D8
  1103 B2AE 30 0F			BMI	LAB_13EA		; all bytes matched so go save token
  1104
  1105 B2B0 E8				INX				; next buffer byte
  1106 B2B1 DD 7F 18			CMP	Ibuffs,X		; compare with byte from input buffer
  1107 B2B4 F0 F5			BEQ	LAB_13D6		; go compare next if match
  1108 				    
  1109 B2B6 09 20			ORA 	#$20                	; repeat with lower case
  1110 B2B8 DD 7F 18			CMP 	Ibuffs,X            	; compare with byte from input buffer
  1111 B2BB F0 EE			BEQ 	LAB_13D6            	; go compare next if match
  1112 					
  1113 B2BD D0 2B			BNE	LAB_1417		; branch if >< (not found keyword)
  1114
  1115 B2BF			LAB_13EA
  1116 B2BF A4 7A			LDY	csidx			; restore save index
  1117 									; save crunched to output
  1118 B2C1			LAB_13EC
  1119 B2C1 E8				INX				; increment buffer index (to next input byte)
  1120 B2C2 C8				INY				; increment save index (to next output byte)
  1121 B2C3 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1122 B2C6 C9 00			CMP	#$00			; set the flags, set carry
  1123 B2C8 F0 32			BEQ	LAB_142A		; do exit if was null [EOL]
  1124
  1125 									; A holds token or byte here
  1126 B2CA E9 3A			SBC	#':'			; subtract ':' (carry set by CMP #00)
  1127 B2CC F0 04			BEQ	LAB_13FF		; branch if it was ':' (is now $00)
  1128
  1129 									; A now holds token-$3A
  1130 B2CE C9 49			CMP	#TK_DATA-$3A		; compare with DATA token - $3A
  1131 B2D0 D0 02			BNE	LAB_1401		; branch if not DATA
  1132 									; token was : or DATA
  1133 B2D2			LAB_13FF
  1134 B2D2 85 20			STA	Oquote			; save token-$3A (clear for ':', TK_DATA-$3A for DATA)
  1135 B2D4			LAB_1401
  1136 B2D4 49 57			EOR	#TK_REM-$3A		; effectively subtract REM token offset
  1137 B2D6 D0 82			BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
  1138
  1139 B2D8 85 1C			STA	Asrch			; else was REM so set search for [EOL]
  1140 									; loop for REM, '...' etc.
  1141 B2DA			LAB_1408
  1142 B2DA BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
  1143 B2DD F0 E2			BEQ	LAB_13EC		; branch if null [EOL]
  1144
  1145 B2DF C5 1C			CMP	Asrch			; compare with stored character
  1146 B2E1 F0 DE			BEQ	LAB_13EC		; branch if match (end quote)
  1147
  1148 									; entry for copy string in quotes, don't crunch
  1149 B2E3			LAB_1410
  1150 B2E3 C8				INY				; increment buffer save index
  1151 B2E4 99 7F 18			STA	Ibuffs,Y		; save byte to output
  1152 B2E7 E8				INX				; increment buffer read index
  1153 B2E8 D0 F0			BNE	LAB_1408		; loop while <> 0 (should never be 0!)
  1154
  1155 									; not found keyword this go
  1156 B2EA			LAB_1417
  1157 B2EA A6 38			LDX	TempB			; compare has failed, restore buffer index (start byte!)
  1158
  1159 									; now find the end of this word in the table
  1160 B2EC			LAB_141B
  1161 B2EC B1 33			LDA	(ut2_pl),Y		; get table byte
  1162 B2EE 08				PHP				; save status
  1163 B2EF C8				INY				; increment table index
  1164 B2F0 28				PLP				; restore byte status
  1165 B2F1 10 F9			BPL	LAB_141B		; if not end of keyword go do next
  1166
  1167 B2F3 B1 33			LDA	(ut2_pl),Y		; get byte from keyword table
  1168 B2F5 D0 B7			BNE	LAB_13D8		; go test next word if not zero byte (end of table)
  1169
  1170 B2F7			PATCH_LC2
  1171 									; reached end of table with no match
  1172 B2F7 BD 7F 18			LDA	Ibuffs,X		; restore byte from input buffer
  1173 B2FA 10 C3			BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
  1174 									; go save byte in output and continue crunching
  1175
  1176 									; reached [EOL]
  1177 B2FC			LAB_142A
  1178 B2FC C8				INY				; increment pointer
  1179 B2FD C8				INY				; increment pointer (makes it next line pointer high byte)
  1180 B2FE 99 7F 18			STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
  1181 B301 C8				INY				; adjust for line copy
  1182 B302 C8				INY				; adjust for line copy
  1183 B303 C8				INY				; adjust for line copy
  1184 B304 C6 83			DEC	Bpntrl			; allow for increment (change if buffer starts at $xxFF)
  1185 B306 60				RTS
  1186
  1187 				; search Basic for temp integer line number from start of mem
  1188 B307			LAB_SSLN
  1189 B307 A5 39			LDA	Smeml			; get start of mem low byte
  1190 B309 A6 3A			LDX	Smemh			; get start of mem high byte
  1191
  1192 				; search Basic for temp integer line number from AX
  1193 				; returns carry set if found
  1194 				; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1195
  1196 				; old 541 new 507
  1197 B30B			LAB_SHLN
  1198 B30B A0 01			LDY	#$01			; set index
  1199 B30D 85 6A			STA	Baslnl			; save low byte as current
  1200 B30F 86 6B			STX	Baslnh			; save high byte as current
  1201 B311 B1 6A			LDA	(Baslnl),Y		; get pointer high byte from addr
  1202 B313 F0 1A			BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
  1203
  1204 B315 A0 03			LDY	#$03			; set index to line # high byte
  1205 B317 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1206 B319 88				DEY				; decrement index (point to low byte)
  1207 B31A C5 12			CMP	Itemph			; compare with temporary integer high byte
  1208 B31C D0 04			BNE	LAB_1455		; if <> skip low byte check
  1209
  1210 B31E B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1211 B320 C5 11			CMP	Itempl			; compare with temporary integer low byte
  1212 B322			LAB_1455
  1213 B322 B0 09			BCS	LAB_145E		; else if temp < this line, exit (passed line#)
  1214
  1215 B324			LAB_1456
  1216 B324 88				DEY				; decrement index to next line ptr high byte
  1217 B325 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1218 B327 AA				TAX				; copy to X
  1219 B328 88				DEY				; decrement index to next line ptr low byte
  1220 B329 B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1221 B32B 90 DE			BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
  1222 									; (carry always clear)
  1223
  1224 B32D			LAB_145E
  1225 B32D F0 01			BEQ	LAB_1460		; exit if temp = found line #, carry is set
  1226
  1227 B32F			LAB_145F
  1228 B32F 18				CLC				; clear found flag
  1229 B330			LAB_1460
  1230 B330 60				RTS
  1231
  1232 				; perform NEW
  1233 B331			LAB_NEW
  1234 B331 D0 FD			BNE	LAB_1460		; exit if not end of statement (to do syntax error)
  1235
  1236 B333			LAB_1463
  1237 B333 A9 00			LDA	#$00			; clear A
  1238 B335 A8				TAY				; clear Y
  1239 B336 91 39			STA	(Smeml),Y		; clear first line, next line pointer, low byte
  1240 B338 C8				INY				; increment index
  1241 B339 91 39			STA	(Smeml),Y		; clear first line, next line pointer, high byte
  1242 B33B 18				CLC				; clear carry
  1243 B33C A5 39			LDA	Smeml			; get start of mem low byte
  1244 B33E 69 02			ADC	#$02			; calculate end of BASIC low byte
  1245 B340 85 3B			STA	Svarl			; save start of vars low byte
  1246 B342 A5 3A			LDA	Smemh			; get start of mem high byte
  1247 B344 69 00			ADC	#$00			; add any carry
  1248 B346 85 3C			STA	Svarh			; save start of vars high byte
  1249
  1250 				; reset execution to start, clear vars and flush stack
  1251 B348			LAB_1477
  1252 B348 18				CLC				; clear carry
  1253 B349 A5 39			LDA	Smeml			; get start of mem low byte
  1254 B34B 69 FF			ADC	#$FF			; -1
  1255 B34D 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1256 B34F A5 3A			LDA	Smemh			; get start of mem high byte
  1257 B351 69 FF			ADC	#$FF			; -1+carry
  1258 B353 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1259
  1260 				; 'CLEAR' command gets here
  1261 B355			LAB_147A
  1262 B355 A5 45			LDA	Ememl			; get end of mem low byte
  1263 B357 A4 46			LDY	Ememh			; get end of mem high byte
  1264 B359 85 41			STA	Sstorl			; set bottom of string space low byte
  1265 B35B 84 42			STY	Sstorh			; set bottom of string space high byte
  1266 B35D A5 3B			LDA	Svarl			; get start of vars low byte
  1267 B35F A4 3C			LDY	Svarh			; get start of vars high byte
  1268 B361 85 3D			STA	Sarryl			; save var mem end low byte
  1269 B363 84 3E			STY	Sarryh			; save var mem end high byte
  1270 B365 85 3F			STA	Earryl			; save array mem end low byte
  1271 B367 84 40			STY	Earryh			; save array mem end high byte
  1272 B369 20 1D B5			JSR	LAB_161A		; perform RESTORE command
  1273
  1274 				; flush stack and clear continue flag
  1275 B36C			LAB_1491
  1276 B36C A2 28			LDX	#des_sk			; set descriptor stack pointer
  1277 B36E 86 25			STX	next_s			; save descriptor stack pointer
  1278 B370 68				PLA				; pull return address low byte
  1279 B371 AA				TAX				; copy return address low byte
  1280 B372 68				PLA				; pull return address high byte
  1281 B373 8E FE 01			STX	LAB_SKFE		; save to cleared stack
  1282 B376 8D FF 01			STA	LAB_SKFF		; save to cleared stack
  1283 B379 A2 FD			LDX	#$FD			; new stack pointer
  1284 B37B 9A				TXS				; reset stack
  1285 B37C A9 00			LDA	#$00			; clear byte
  1286 					;STA	Cpntrh			; clear continue pointer high byte (patched)
  1287 B37E 85 21			STA	Sufnxf			; clear subscript/FNX flag
  1288 B380			LAB_14A6
  1289 B380 60				RTS
  1290
  1291 				; perform CLEAR
  1292 B381			LAB_CLEAR
  1293 B381 F0 D2			BEQ	LAB_147A		; if no following token go do 'CLEAR'
  1294 									; else there was a following token (go do syntax error)
  1295 B383 60				RTS
  1296
  1297 				; perform LIST [n][-m]
  1298 				; bigger, faster version (a _lot_ faster)
  1299 B384			LAB_LIST
  1300 B384 90 06			BCC	LAB_14BD		; branch if next character numeric (LIST n..)
  1301
  1302 B386 F0 04			BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
  1303
  1304 B388 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1305 B38A D0 F4			BNE	LAB_14A6		; exit if not - (LIST -m)
  1306
  1307 									; LIST [[n][-m]]
  1308 									; this bit sets the n , if present, as the start and end
  1309 B38C			LAB_14BD
  1310 B38C 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1311 B38F 20 07 B3			JSR	LAB_SSLN		; search BASIC for temp integer line number
  1312 									; (pointer in Baslnl/Baslnh)
  1313 B392 20 82 00			JSR	LAB_GBYT		; scan memory
  1314 B395 F0 0C			BEQ	LAB_14D4		; branch if no more characters
  1315
  1316 									; this bit checks the - is present
  1317 B397 C9 CC			CMP	#TK_MINUS		; compare with token for -
  1318 B399 D0 95			BNE	LAB_1460		; return if not '-' (will be Syntax error)
  1319
  1320 									; LIST [n]-m
  1321 									; the - was there so set m as the end value
  1322 B39B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1323 B39E 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1324 B3A1 D0 8D			BNE	LAB_1460		; exit if not ok
  1325
  1326 B3A3			LAB_14D4
  1327 B3A3 A5 11			LDA	Itempl			; get temporary integer low byte
  1328 B3A5 05 12			ORA	Itemph			; OR temporary integer high byte
  1329 B3A7 D0 06			BNE	LAB_14E2		; branch if start set
  1330
  1331 B3A9 A9 FF			LDA	#$FF			; set for -1
  1332 B3AB 85 11			STA	Itempl			; set temporary integer low byte
  1333 B3AD 85 12			STA	Itemph			; set temporary integer high byte
  1334 B3AF			LAB_14E2
  1335 B3AF A0 01			LDY	#$01			; set index for line
  1336 B3B1 84 20			STY	Oquote			; clear open quote flag
  1337 B3B3 20 70 B8			JSR	LAB_CRLF		; print CR/LF
  1338 B3B6 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1339 									; pointer initially set by search at LAB_14BD
  1340 B3B8 F0 3E			BEQ	LAB_152B		; if null all done so exit
  1341 B3BA 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1342
  1343 B3BD C8				INY				; increment index for line
  1344 B3BE B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1345 B3C0 AA				TAX				; copy to X
  1346 B3C1 C8				INY				; increment index
  1347 B3C2 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1348 B3C4 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1349 B3C6 D0 04			BNE	LAB_14FF		; branch if no high byte match
  1350
  1351 B3C8 E4 11			CPX	Itempl			; compare with temporary integer low byte
  1352 B3CA F0 02			BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
  1353
  1354 B3CC			LAB_14FF				; else ..
  1355 B3CC B0 2A			BCS	LAB_152B		; if greater all done so exit
  1356
  1357 B3CE			LAB_1501
  1358 B3CE 84 57			STY	Tidx1			; save index for line
  1359 B3D0 20 6F CA			JSR	LAB_295E		; print XA as unsigned integer
  1360 B3D3 A9 20			LDA	#$20			; space is the next character
  1361 B3D5			LAB_1508
  1362 B3D5 A4 57			LDY	Tidx1			; get index for line
  1363 B3D7 29 7F			AND	#$7F			; mask top out bit of character
  1364 B3D9			LAB_150C
  1365 B3D9 20 CB B8			JSR	LAB_PRNA		; go print the character
  1366 B3DC C9 22			CMP	#$22			; was it ' character
  1367 B3DE D0 06			BNE	LAB_1519		; branch if not
  1368
  1369 									; we are either entering or leaving a pair of quotes
  1370 B3E0 A5 20			LDA	Oquote			; get open quote flag
  1371 B3E2 49 FF			EOR	#$FF			; toggle it
  1372 B3E4 85 20			STA	Oquote			; save it back
  1373 B3E6			LAB_1519
  1374 B3E6 C8				INY				; increment index
  1375 B3E7 B1 6A			LDA	(Baslnl),Y		; get next byte
  1376 B3E9 D0 0E			BNE	LAB_152E		; branch if not [EOL] (go print character)
  1377 B3EB A8				TAY				; else clear index
  1378 B3EC B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1379 B3EE AA				TAX				; copy to X
  1380 B3EF C8				INY				; increment index
  1381 B3F0 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1382 B3F2 86 6A			STX	Baslnl			; set pointer to line low byte
  1383 B3F4 85 6B			STA	Baslnh			; set pointer to line high byte
  1384 B3F6 D0 B7			BNE	LAB_14E2		; go do next line if not [EOT]
  1385 									; else ..
  1386 B3F8			LAB_152B
  1387 B3F8 60				RTS
  1388
  1389 B3F9			LAB_152E
  1390 B3F9 10 DE			BPL	LAB_150C		; just go print it if not token byte
  1391
  1392 									; else was token byte so uncrunch it (maybe)
  1393 B3FB 24 20			BIT	Oquote			; test the open quote flag
  1394 B3FD 30 DA			BMI	LAB_150C		; just go print character if open quote set
  1395
  1396 B3FF A2 D7			LDX	#>LAB_KEYT		; get table address high byte
  1397 B401 0A				ASL				; *2
  1398 B402 0A				ASL				; *4
  1399 B403 90 02			BCC	LAB_152F		; branch if no carry
  1400
  1401 B405 E8				INX				; else increment high byte
  1402 B406 18				CLC				; clear carry for add
  1403 B407			LAB_152F
  1404 B407 69 DE			ADC	#<LAB_KEYT		; add low byte
  1405 B409 90 01			BCC	LAB_1530		; branch if no carry
  1406
  1407 B40B E8				INX				; else increment high byte
  1408 B40C			LAB_1530
  1409 B40C 85 33			STA	ut2_pl			; save table pointer low byte
  1410 B40E 86 34			STX	ut2_ph			; save table pointer high byte
  1411 B410 84 57			STY	Tidx1			; save index for line
  1412 B412 A0 00			LDY	#$00			; clear index
  1413 B414 B1 33			LDA	(ut2_pl),Y		; get length
  1414 B416 AA				TAX				; copy length
  1415 B417 C8				INY				; increment index
  1416 B418 B1 33			LDA	(ut2_pl),Y		; get 1st character
  1417 B41A CA				DEX				; decrement length
  1418 B41B F0 B8			BEQ	LAB_1508		; if no more characters exit and print
  1419
  1420 B41D 20 CB B8			JSR	LAB_PRNA		; go print the character
  1421 B420 C8				INY				; increment index
  1422 B421 B1 33			LDA	(ut2_pl),Y		; get keyword address low byte
  1423 B423 48				PHA				; save it for now
  1424 B424 C8				INY				; increment index
  1425 B425 B1 33			LDA	(ut2_pl),Y		; get keyword address high byte
  1426 B427 A0 00			LDY	#$00
  1427 B429 85 34			STA	ut2_ph			; save keyword pointer high byte
  1428 B42B 68				PLA				; pull low byte
  1429 B42C 85 33			STA	ut2_pl			; save keyword pointer low byte
  1430 B42E			LAB_1540
  1431 B42E B1 33			LDA	(ut2_pl),Y		; get character
  1432 B430 CA				DEX				; decrement character count
  1433 B431 F0 A2			BEQ	LAB_1508		; if last character exit and print
  1434
  1435 B433 20 CB B8			JSR	LAB_PRNA		; go print the character
  1436 B436 C8				INY				; increment index
  1437 B437 D0 F5			BNE	LAB_1540		; loop for next character
  1438
  1439 				; perform FOR
  1440 B439			LAB_FOR
  1441 B439 A9 80			LDA	#$80			; set FNX
  1442 B43B 85 21			STA	Sufnxf			; set subscript/FNX flag
  1443 B43D 20 92 B7			JSR	LAB_LET			; go do LET
  1444 B440 68				PLA				; pull return address
  1445 B441 68				PLA				; pull return address
  1446 B442 A9 10			LDA	#$10			; we need 16d bytes !
  1447 B444 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1448 B447 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1449 B44A 18				CLC				; clear carry for add
  1450 B44B 98				TYA				; copy index to A
  1451 B44C 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1452 B44E 48				PHA				; push onto stack
  1453 B44F A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1454 B451 69 00			ADC	#$00			; add carry
  1455 B453 48				PHA				; push onto stack
  1456 B454 A5 48			LDA	Clineh			; get current line high byte
  1457 B456 48				PHA				; push onto stack
  1458 B457 A5 47			LDA	Clinel			; get current line low byte
  1459 B459 48				PHA				; push onto stack
  1460 B45A A9 C2			LDA	#TK_TO			; get 'TO' token
  1461 B45C 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1462 B45F 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1463 B462 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1464 									; else do type mismatch
  1465 B465 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  1466 B467 09 7F			ORA	#$7F			; set all non sign bits
  1467 B469 25 6D			AND	FAC1_1			; and FAC1 mantissa1
  1468 B46B 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  1469 B46D A9 78			LDA	#<LAB_159F		; set return address low byte
  1470 B46F A0 B4			LDY	#>LAB_159F		; set return address high byte
  1471 B471 85 31			STA	ut1_pl			; save return address low byte
  1472 B473 84 32			STY	ut1_ph			; save return address high byte
  1473 B475 4C 61 BB			JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1474
  1475 B478			LAB_159F
  1476 B478 A9 F4			LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1477 B47A A0 D3			LDY	#>LAB_259C		; set 1 pointer high addr
  1478 B47C 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1479 B47F 20 82 00			JSR	LAB_GBYT		; scan memory
  1480 B482 C9 C7			CMP	#TK_STEP		; compare with STEP token
  1481 B484 D0 06			BNE	LAB_15B3		; jump if not 'STEP'
  1482
  1483 									;.was step so ..
  1484 B486 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1485 B489 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1486 									; else do type mismatch
  1487 B48C			LAB_15B3
  1488 B48C 20 D6 C8			JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1489 B48F 85 70			STA	FAC1_s			; set FAC1 sign (b7)
  1490 									; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1491 									; compare the FOR value and the TO value and return +1 if
  1492 									; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1493 									; here (+/-1) is then compared to that result and if they
  1494 									; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1495 									; the loop is done
  1496 B491 20 56 BB			JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1497 B494 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  1498 B496 48				PHA				; push on stack
  1499 B497 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  1500 B499 48				PHA				; push on stack
  1501 B49A A9 81			LDA	#TK_FOR			; get FOR token
  1502 B49C 48				PHA				; push on stack
  1503
  1504 				; interpreter inner loop
  1505 B49D			LAB_15C2
  1506 B49D 20 F3 B4			JSR	LAB_1629		; do CRTL-C check vector
  1507 B4A0 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1508 B4A2 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  1509
  1510 B4A4 A6 48			LDX	Clineh			; continue line is $FFxx for immediate mode
  1511 									; ($00xx for RUN from immediate mode)
  1512 B4A6 E8				INX				; increment it (now $00 if immediate mode)
  1513 					;BEQ	LAB_15D1		; branch if null (immediate mode) (patched)
  1514
  1515 B4A7 85 4B			STA	Cpntrl			; save continue pointer low byte
  1516 B4A9 84 4C			STY	Cpntrh			; save continue pointer high byte
  1517 B4AB			LAB_15D1
  1518 B4AB A0 00			LDY	#$00			; clear index
  1519 B4AD B1 83			LDA	(Bpntrl),Y		; get next byte
  1520 B4AF F0 07			BEQ	LAB_15DC		; branch if null [EOL]
  1521
  1522 B4B1 C9 3A			CMP	#':'			; compare with ':'
  1523 B4B3 F0 1D			BEQ	LAB_15F6		; branch if = (statement separator)
  1524
  1525 B4B5			LAB_15D9
  1526 B4B5 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  1527
  1528 									; have reached [EOL]
  1529 B4B8			LAB_15DC
  1530 B4B8 A0 02			LDY	#$02			; set index
  1531 B4BA B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  1532 B4BC 18				CLC				; clear carry for no 'BREAK' message
  1533 B4BD F0 50			BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1534 									; marker)
  1535
  1536 B4BF C8				INY				; increment index
  1537 B4C0 B1 83			LDA	(Bpntrl),Y		; get line # low byte
  1538 B4C2 85 47			STA	Clinel			; save current line low byte
  1539 B4C4 C8				INY				; increment index
  1540 B4C5 B1 83			LDA	(Bpntrl),Y		; get line # high byte
  1541 B4C7 85 48			STA	Clineh			; save current line high byte
  1542 B4C9 98				TYA				; A now = 4
  1543 B4CA 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1544 B4CC 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1545 B4CE 90 02			BCC	LAB_15F6		; branch if no overflow
  1546
  1547 B4D0 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1548 B4D2			LAB_15F6
  1549 B4D2 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1550
  1551 B4D5			LAB_15F9
  1552 B4D5 20 DB B4			JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
  1553
  1554 B4D8			LAB_15FC
  1555 B4D8 4C 9D B4			JMP	LAB_15C2		; loop
  1556
  1557 				; interpret BASIC code from (Bpntrl)
  1558 B4DB			LAB_15FF
  1559 B4DB F0 4E			BEQ	LAB_1628		; exit if zero [EOL]
  1560
  1561 B4DD			LAB_1602
  1562 B4DD 0A				ASL				; *2 bytes per vector and normalise token
  1563 B4DE B0 03			BCS	LAB_1609		; branch if was token
  1564
  1565 B4E0 4C 92 B7			JMP	LAB_LET			; else go do implied LET
  1566
  1567 B4E3			LAB_1609
  1568 B4E3 C9 80			CMP	#(TK_TAB-$80)*2		; compare normalised token * 2 with TAB
  1569 B4E5 B0 CE			BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  1570 									; only tokens before TAB can start a line
  1571 B4E7 A8				TAY				; copy to index
  1572 B4E8 B9 1C D4			LDA	LAB_CTBL+1,Y		; get vector high byte
  1573 B4EB 48				PHA				; onto stack
  1574 B4EC B9 1B D4			LDA	LAB_CTBL,Y		; get vector low byte
  1575 B4EF 48				PHA				; onto stack
  1576 B4F0 4C 7C 00			JMP	LAB_IGBY		; jump to increment and scan memory
  1577 									; then 'return' to vector
  1578
  1579 				; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1580 				; key press is detected.
  1581 B4F3			LAB_1629
  1582 B4F3 6C 6B 18			JMP	(VEC_CC)		; ctrl c check vector
  1583
  1584 				; if there was a key press it gets back here ..
  1585 B4F6			LAB_1636
  1586 B4F6 C9 03			CMP	#$03			; compare with CTRL-C
  1587
  1588 				; perform STOP
  1589 B4F8			LAB_STOP
  1590 B4F8 B0 01			BCS	LAB_163B		; branch if token follows STOP
  1591 									; else just END
  1592 				; END
  1593 B4FA			LAB_END
  1594 B4FA 18				CLC				; clear the carry, indicate a normal program end
  1595 B4FB			LAB_163B
  1596 B4FB D0 61			BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1597
  1598 B4FD A5 84			LDA	Bpntrh			; get the BASIC execute pointer high byte
  1599 					;EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1600 					;BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1601 									; (can't continue in immediate mode)
  1602
  1603 									; else ..
  1604 					;EOR	#>Ibuffs		; correct the bits (patched 3 lines)
  1605 B4FF A4 83			LDY	Bpntrl			; get BASIC execute pointer low byte
  1606 B501 84 4B			STY	Cpntrl			; save continue pointer low byte
  1607 B503 85 4C			STA	Cpntrh			; save continue pointer high byte
  1608 B505			LAB_1647
  1609 B505 A5 47			LDA	Clinel			; get current line low byte
  1610 B507 A4 48			LDY	Clineh			; get current line high byte
  1611 B509 85 49			STA	Blinel			; save break line low byte
  1612 B50B 84 4A			STY	Blineh			; save break line high byte
  1613 B50D			LAB_164F
  1614 B50D 68				PLA				; pull return address low
  1615 B50E 68				PLA				; pull return address high
  1616 B50F			LAB_1651
  1617 B50F 90 07			BCC	LAB_165E		; if was program end just do warm start
  1618
  1619 									; else ..
  1620 B511 A9 13			LDA	#<LAB_BMSG		; point to 'Break' low byte
  1621 B513 A0 DB			LDY	#>LAB_BMSG		; point to 'Break' high byte
  1622 B515 4C 21 B1			JMP	LAB_1269		; print 'Break' and do warm start
  1623
  1624 B518			LAB_165E
  1625 B518 4C 2C B1			JMP	LAB_1274		; go do warm start
  1626
  1627 				; perform RESTORE
  1628 B51B			LAB_RESTORE
  1629 B51B D0 0F			BNE	LAB_RESTOREn		; branch if next character not null (RESTORE n)
  1630
  1631 B51D			LAB_161A
  1632 B51D 38				SEC				; set carry for subtract
  1633 B51E A5 39			LDA	Smeml			; get start of mem low byte
  1634 B520 E9 01			SBC	#$01			; -1
  1635 B522 A4 3A			LDY	Smemh			; get start of mem high byte
  1636 B524 B0 01			BCS	LAB_1624		; branch if no underflow
  1637
  1638 B526			LAB_uflow
  1639 B526 88				DEY				; else decrement high byte
  1640 B527			LAB_1624
  1641 B527 85 4F			STA	Dptrl			; save DATA pointer low byte
  1642 B529 84 50			STY	Dptrh			; save DATA pointer high byte
  1643 B52B			LAB_1628
  1644 B52B 60				RTS
  1645
  1646 									; is RESTORE n
  1647 B52C			LAB_RESTOREn
  1648 B52C 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1649 B52F 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  1650 B532 A5 48			LDA	Clineh			; get current line high byte
  1651 B534 C5 12			CMP	Itemph			; compare with temporary integer high byte
  1652 B536 B0 0B			BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1653
  1654 B538 98				TYA				; else copy line index to A
  1655 B539 38				SEC				; set carry (+1)
  1656 B53A 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1657 B53C A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1658 B53E 90 07			BCC	LAB_go_search		; branch if no overflow to high byte
  1659
  1660 B540 E8				INX				; increment high byte
  1661 B541 B0 04			BCS	LAB_go_search		; branch always (can never be carry clear)
  1662
  1663 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1664 B543			LAB_reset_search
  1665 B543 A5 39			LDA	Smeml			; get start of mem low byte
  1666 B545 A6 3A			LDX	Smemh			; get start of mem high byte
  1667
  1668 				; search for line # in temp (Itempl/Itemph) from (AX)
  1669 B547			LAB_go_search
  1670
  1671 B547 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1672 B54A B0 03			BCS	LAB_line_found		; if carry set go set pointer
  1673
  1674 B54C 4C 4D B6			JMP	LAB_16F7		; else go do 'Undefined statement' error
  1675
  1676 B54F			LAB_line_found
  1677 									; carry already set for subtract
  1678 B54F A5 6A			LDA	Baslnl			; get pointer low byte
  1679 B551 E9 01			SBC	#$01			; -1
  1680 B553 A4 6B			LDY	Baslnh			; get pointer high byte
  1681 B555 B0 D0			BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1682
  1683 B557 90 CD			BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1684 									; return (branch always)
  1685
  1686 				; perform NULL
  1687 B559			LAB_NULL
  1688 B559 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  1689 B55C 86 0D			STX	Nullct			; save new NULL count
  1690 B55E			LAB_167A
  1691 B55E 60				RTS
  1692
  1693 				; perform CONT
  1694 B55F			LAB_CONT
  1695 B55F D0 FD			BNE	LAB_167A		; if following byte exit to do syntax error
  1696
  1697 B561 A4 4C			LDY	Cpntrh			; get continue pointer high byte
  1698 B563 C0 18			CPY   	#>Ibuffs          	; *** fix p2: test direct mode 
  1699 B565 D0 05			BNE	LAB_166C		; go do continue if we can
  1700
  1701 B567 A2 1E			LDX	#$1E			; error code $1E ('Can't continue' error)
  1702 B569 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1703 									; we can continue so ..
  1704 B56C			LAB_166C
  1705 B56C A9 93			LDA	#TK_ON			; set token for ON
  1706 B56E 20 03 CF			JSR	LAB_IRQ			; set IRQ flags
  1707 B571 A9 93			LDA	#TK_ON			; set token for ON
  1708 B573 20 06 CF			JSR	LAB_NMI			; set NMI flags
  1709
  1710 B576 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  1711 B578 A5 4B			LDA	Cpntrl			; get continue pointer low byte
  1712 B57A 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1713 B57C A5 49			LDA	Blinel			; get break line low byte
  1714 B57E A4 4A			LDY	Blineh			; get break line high byte
  1715 B580 85 47			STA	Clinel			; set current line low byte
  1716 B582 84 48			STY	Clineh			; set current line high byte
  1717 B584 60				RTS
  1718
  1719 				; perform RUN
  1720 B585			LAB_RUN
  1721 B585 D0 03			BNE	LAB_1696		; branch if RUN n
  1722 B587 4C 48 B3			JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1723 									; return
  1724
  1725 				; does RUN n
  1726 B58A			LAB_1696
  1727 B58A 20 55 B3			JSR	LAB_147A		; go do 'CLEAR'
  1728 B58D F0 2E			BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1729
  1730 				; perform DO
  1731 B58F			LAB_DO
  1732 B58F A9 05			LDA	#$05			; need 5 bytes for DO
  1733 B591 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1734 B594 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1735 B596 48				PHA				; push on stack
  1736 B597 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1737 B599 48				PHA				; push on stack
  1738 B59A A5 48			LDA	Clineh			; get current line high byte
  1739 B59C 48				PHA				; push on stack
  1740 B59D A5 47			LDA	Clinel			; get current line low byte
  1741 B59F 48				PHA				; push on stack
  1742 B5A0 A9 9D			LDA	#TK_DO			; token for DO
  1743 B5A2 48				PHA				; push on stack
  1744 B5A3 20 82 00			JSR	LAB_GBYT		; scan memory
  1745 B5A6 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1746
  1747 				; perform GOSUB
  1748 B5A9			LAB_GOSUB
  1749 B5A9 A9 05			LDA	#$05			; need 5 bytes for GOSUB
  1750 B5AB 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  1751 B5AE A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1752 B5B0 48				PHA				; push on stack
  1753 B5B1 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1754 B5B3 48				PHA				; push on stack
  1755 B5B4 A5 48			LDA	Clineh			; get current line high byte
  1756 B5B6 48				PHA				; push on stack
  1757 B5B7 A5 47			LDA	Clinel			; get current line low byte
  1758 B5B9 48				PHA				; push on stack
  1759 B5BA A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  1760 B5BC 48				PHA				; push on stack
  1761 B5BD			LAB_16B0
  1762 B5BD 20 82 00			JSR	LAB_GBYT		; scan memory
  1763 B5C0 20 C6 B5			JSR	LAB_GOTO		; perform GOTO n
  1764 B5C3 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1765 									; (can't RTS, we used the stack!)
  1766
  1767 				; perform GOTO
  1768 B5C6			LAB_GOTO
  1769 B5C6 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1770 B5C9 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  1771 B5CC A5 48			LDA	Clineh			; get current line high byte
  1772 B5CE C5 12			CMP	Itemph			; compare with temporary integer high byte
  1773 B5D0 B0 0B			BCS	LAB_16D0		; branch if >= (start search from beginning)
  1774
  1775 B5D2 98				TYA				; else copy line index to A
  1776 B5D3 38				SEC				; set carry (+1)
  1777 B5D4 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1778 B5D6 A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1779 B5D8 90 07			BCC	LAB_16D4		; branch if no overflow to high byte
  1780
  1781 B5DA E8				INX				; increment high byte
  1782 B5DB B0 04			BCS	LAB_16D4		; branch always (can never be carry)
  1783
  1784 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1785 B5DD			LAB_16D0
  1786 B5DD A5 39			LDA	Smeml			; get start of mem low byte
  1787 B5DF A6 3A			LDX	Smemh			; get start of mem high byte
  1788
  1789 				; search for line # in temp (Itempl/Itemph) from (AX)
  1790 B5E1			LAB_16D4
  1791 B5E1 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1792 B5E4 90 67			BCC	LAB_16F7		; if carry clear go do 'Undefined statement' error
  1793 									; (unspecified statement)
  1794
  1795 									; carry already set for subtract
  1796 B5E6 A5 6A			LDA	Baslnl			; get pointer low byte
  1797 B5E8 E9 01			SBC	#$01			; -1
  1798 B5EA 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1799 B5EC A5 6B			LDA	Baslnh			; get pointer high byte
  1800 B5EE E9 00			SBC	#$00			; subtract carry
  1801 B5F0 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1802 B5F2			LAB_16E5
  1803 B5F2 60				RTS
  1804
  1805 B5F3			LAB_DONOK
  1806 B5F3 A2 22			LDX	#$22			; error code $22 ('LOOP without DO' error)
  1807 B5F5 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1808
  1809 				; perform LOOP
  1810 B5F8			LAB_LOOP
  1811 B5F8 A8				TAY				; save following token
  1812 B5F9 BA				TSX				; copy stack pointer
  1813 B5FA BD 03 01			LDA	LAB_STAK+3,X		; get token byte from stack
  1814 B5FD C9 9D			CMP	#TK_DO			; compare with DO token
  1815 B5FF D0 F2			BNE	LAB_DONOK		; branch if no matching DO
  1816
  1817 B601 E8				INX				; dump calling routine return address
  1818 B602 E8				INX				; dump calling routine return address
  1819 B603 9A				TXS				; correct stack
  1820 B604 98				TYA				; get saved following token back
  1821 B605 F0 20			BEQ	LoopAlways		; if no following token loop forever
  1822 									; (stack pointer in X)
  1823
  1824 B607 C9 3A			CMP	#':'			; could be ':'
  1825 B609 F0 1C			BEQ	LoopAlways		; if :... loop forever
  1826
  1827 B60B E9 C8			SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1828 B60D AA				TAX				; copy to X (if it was UNTIL then Y will be correct)
  1829 B60E F0 04			BEQ	DoRest			; branch if was UNTIL
  1830
  1831 B610 CA				DEX				; decrement result
  1832 B611 D0 62			BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1833 									; only if the token was WHILE will this fail
  1834
  1835 B613 CA				DEX				; set invert result byte
  1836 B614			DoRest
  1837 B614 86 58			STX	Frnxth			; save invert result byte
  1838 B616 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1839 B619 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  1840 B61C A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1841 B61E F0 02			BEQ	DoCmp			; if =0 go do straight compare
  1842
  1843 B620 A9 FF			LDA	#$FF			; else set all bits
  1844 B622			DoCmp
  1845 B622 BA				TSX				; copy stack pointer
  1846 B623 45 58			EOR	Frnxth			; EOR with invert byte
  1847 B625 D0 1A			BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1848
  1849 									; loop condition wasn't met so do it again
  1850 B627			LoopAlways
  1851 B627 BD 02 01			LDA	LAB_STAK+2,X		; get current line low byte
  1852 B62A 85 47			STA	Clinel			; save current line low byte
  1853 B62C BD 03 01			LDA	LAB_STAK+3,X		; get current line high byte
  1854 B62F 85 48			STA	Clineh			; save current line high byte
  1855 B631 BD 04 01			LDA	LAB_STAK+4,X		; get BASIC execute pointer low byte
  1856 B634 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1857 B636 BD 05 01			LDA	LAB_STAK+5,X		; get BASIC execute pointer high byte
  1858 B639 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1859 B63B 20 82 00			JSR	LAB_GBYT		; scan memory
  1860 B63E 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  1861
  1862 									; clear stack and back to interpreter loop
  1863 B641			LoopDone
  1864 B641 E8				INX				; dump DO token
  1865 B642 E8				INX				; dump current line low byte
  1866 B643 E8				INX				; dump current line high byte
  1867 B644 E8				INX				; dump BASIC execute pointer low byte
  1868 B645 E8				INX				; dump BASIC execute pointer high byte
  1869 B646 9A				TXS				; correct stack
  1870 B647 4C 67 B6			JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1871
  1872 				; do the return without gosub error
  1873 B64A			LAB_16F4
  1874 B64A A2 04			LDX	#$04			; error code $04 ('RETURN without GOSUB' error)
  1875 B64C 2C				.byte	$2C			; makes next line BIT LAB_0EA2
  1876
  1877 B64D			LAB_16F7				; do undefined statement error
  1878 B64D A2 0E			LDX	#$0E			; error code $0E ('Undefined statement' error)
  1879 B64F 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  1880
  1881 				; perform RETURN
  1882 B652			LAB_RETURN
  1883 B652 D0 9E			BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1884
  1885 B654			LAB_16E8
  1886 B654 68				PLA				; dump calling routine return address
  1887 B655 68				PLA				; dump calling routine return address
  1888 B656 68				PLA				; pull token
  1889 B657 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  1890 B659 D0 EF			BNE	LAB_16F4		; branch if no matching GOSUB
  1891
  1892 B65B			LAB_16FF
  1893 B65B 68				PLA				; pull current line low byte
  1894 B65C 85 47			STA	Clinel			; save current line low byte
  1895 B65E 68				PLA				; pull current line high byte
  1896 B65F 85 48			STA	Clineh			; save current line high byte
  1897 B661 68				PLA				; pull BASIC execute pointer low byte
  1898 B662 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1899 B664 68				PLA				; pull BASIC execute pointer high byte
  1900 B665 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1901
  1902 									; now do the DATA statement as we could be returning into
  1903 									; the middle of an ON <var> GOSUB n,m,p,q line
  1904 									; (the return address used by the DATA statement is the one
  1905 									; pushed before the GOSUB was executed!)
  1906
  1907 				; perform DATA
  1908 B667			LAB_DATA
  1909 B667 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1910 									; set BASIC execute pointer
  1911 B66A			LAB_170F
  1912 B66A 98				TYA				; copy index to A
  1913 B66B 18				CLC				; clear carry for add
  1914 B66C 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1915 B66E 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1916 B670 90 02			BCC	LAB_1719		; skip next if no carry
  1917
  1918 B672 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1919 B674			LAB_1719
  1920 B674 60				RTS
  1921
  1922 B675			LAB_16FC
  1923 B675 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  1924
  1925 				; scan for next BASIC statement ([:] or [EOL])
  1926 				; returns Y as index to [:] or [EOL]
  1927 B678			LAB_SNBS
  1928 B678 A2 3A			LDX	#':'			; set look for character = ':'
  1929 B67A 2C				.byte	$2C			; makes next line BIT $00A2
  1930
  1931 				; scan for next BASIC line
  1932 				; returns Y as index to [EOL]
  1933 B67B			LAB_SNBL
  1934 B67B A2 00			LDX	#$00			; set alt search character = [EOL]
  1935 B67D A0 00			LDY	#$00			; set search character = [EOL]
  1936 B67F 84 1C			STY	Asrch			; store search character
  1937 B681			LAB_1725
  1938 B681 8A				TXA				; get alt search character
  1939 B682 45 1C			EOR	Asrch			; toggle search character, effectively swap with $00
  1940 B684 85 1C			STA	Asrch			; save swapped search character
  1941 B686			LAB_172D
  1942 B686 B1 83			LDA	(Bpntrl),Y		; get next byte
  1943 B688 F0 EA			BEQ	LAB_1719		; exit if null [EOL]
  1944
  1945 B68A C5 1C			CMP	Asrch			; compare with search character
  1946 B68C F0 E6			BEQ	LAB_1719		; exit if found
  1947
  1948 B68E C8				INY				; increment index
  1949 B68F C9 22			CMP	#$22			; compare current character with open quote
  1950 B691 D0 F3			BNE	LAB_172D		; if not open quote go get next character
  1951
  1952 B693 F0 EC			BEQ	LAB_1725		; if found go swap search character for alt search character
  1953
  1954 				; perform IF
  1955 B695			LAB_IF
  1956 B695 20 BE BA			JSR	LAB_EVEX		; evaluate the expression
  1957 B698 20 82 00			JSR	LAB_GBYT		; scan memory
  1958 B69B C9 C5			CMP	#TK_THEN		; compare with THEN token
  1959 B69D F0 11			BEQ	LAB_174B		; if it was THEN go do IF
  1960
  1961 									; wasn't IF .. THEN so must be IF .. GOTO
  1962 B69F C9 89			CMP	#TK_GOTO		; compare with GOTO token
  1963 B6A1 D0 D2			BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  1964
  1965 B6A3 A6 83			LDX	Bpntrl			; save the basic pointer low byte
  1966 B6A5 A4 84			LDY	Bpntrh			; save the basic pointer high byte
  1967 B6A7 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1968 B6AA B0 C9			BCS	LAB_16FC		; if not numeric go do syntax error
  1969
  1970 B6AC 86 83			STX	Bpntrl			; restore the basic pointer low byte
  1971 B6AE 84 84			STY	Bpntrh			; restore the basic pointer high byte
  1972 B6B0			LAB_174B
  1973 B6B0 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1974 B6B2 F0 1E			BEQ	LAB_174E		; if the result was zero go look for an ELSE
  1975
  1976 B6B4 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  1977 B6B7 B0 03			BCS	LAB_174D		; if not numeric go do var or keyword
  1978
  1979 B6B9			LAB_174C
  1980 B6B9 4C C6 B5			JMP	LAB_GOTO		; else was numeric so do GOTO n
  1981
  1982 									; is var or keyword
  1983 B6BC			LAB_174D	; Patch: allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack
  1984 B6BC 68				PLA                     	; discard interpreter loop return address
  1985 B6BD 68				PLA                     	; so data structures are at the correct stack offset
  1986 B6BE 20 82 00			JSR   	LAB_GBYT          	; restore token or variable
  1987 B6C1 20 DB B4			JSR   	LAB_15FF          	; interpret BASIC code from (Bpntrl)
  1988
  1989 				; the IF was executed and there may be a following ELSE so the code needs to return
  1990 				; here to check and ignore the ELSE if present
  1991
  1992 B6C4 A0 00			LDY   	#$00              	; clear the index
  1993 B6C6 B1 83			LDA   	(Bpntrl),Y        	; get the next BASIC byte
  1994 B6C8 C9 C1			CMP   	#TK_ELSE          	; compare it with the token for ELSE
  1995 B6CA D0 03			BNE   	LAB_no_ELSE       	; no - continue on this line
  1996 B6CC 20 67 B6			JSR   	LAB_DATA          	; yes - skip the rest of the line
  1997
  1998 				; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1999 				; following ELSE will, correctly, cause a syntax error
  2000
  2001 B6CF			LAB_no_ELSE
  2002 B6CF 4C 9D B4			JMP 	LAB_15C2            	; return to the interpreter inner loop 
  2003 				;	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  2004 				;	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  2005 				;					; and return to this code to process any following code
  2006 				;
  2007 				;	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
  2008 				;					; but don't return here
  2009 				;
  2010 				;LAB_174G
  2011 				;	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2012 				;
  2013 				;; the IF was executed and there may be a following ELSE so the code needs to return
  2014 				;; here to check and ignore the ELSE if present
  2015 				;
  2016 				;	LDY	#$00			; clear the index
  2017 				;	LDA	(Bpntrl),Y		; get the next BASIC byte
  2018 				;	CMP	#TK_ELSE		; compare it with the token for ELSE
  2019 				;	BEQ	LAB_DATA		; if ELSE ignore the following statement
  2020 				;
  2021 				;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2022 				;; following ELSE will, correctly, cause a syntax error
  2023 				;
  2024 				;	RTS				; else return to the interpreter inner loop
  2025 				;
  2026 				; perform ELSE after IF
  2027 B6D2			LAB_174E
  2028 B6D2 A0 00			LDY	#$00			; clear the BASIC byte index
  2029 B6D4 A2 01			LDX	#$01			; clear the nesting depth
  2030 B6D6			LAB_1750
  2031 B6D6 C8				INY				; increment the BASIC byte index
  2032 B6D7 B1 83			LDA	(Bpntrl),Y		; get the next BASIC byte
  2033 B6D9 F0 0F			BEQ	LAB_1753		; if EOL go add the pointer and return
  2034
  2035 B6DB C9 8B			CMP	#TK_IF			; compare the byte with the token for IF
  2036 B6DD D0 03			BNE	LAB_1752		; if not IF token skip the depth increment
  2037
  2038 B6DF E8				INX				; else increment the nesting depth ..
  2039 B6E0 D0 F4			BNE	LAB_1750		; .. and continue looking
  2040
  2041 B6E2			LAB_1752
  2042 B6E2 C9 C1			CMP	#TK_ELSE		; compare the byte with the token for ELSE
  2043 B6E4 D0 F0			BNE	LAB_1750		; if not ELSE token continue looking
  2044
  2045 B6E6 CA				DEX				; was ELSE so decrement the nesting depth
  2046 B6E7 D0 ED			BNE	LAB_1750		; loop if still nested
  2047
  2048 B6E9 C8				INY				; increment the BASIC byte index past the ELSE
  2049
  2050 				; found the matching ELSE, now do <{n|statement}>
  2051 B6EA			LAB_1753
  2052 B6EA 98				TYA				; else copy line index to A
  2053 B6EB 18				CLC				; clear carry for add
  2054 B6EC 65 83			ADC	Bpntrl			; add the BASIC execute pointer low byte
  2055 B6EE 85 83			STA	Bpntrl			; save the BASIC execute pointer low byte
  2056 B6F0 90 02			BCC	LAB_1754		; branch if no overflow to high byte
  2057
  2058 B6F2 E6 84			INC	Bpntrh			; else increment the BASIC execute pointer high byte
  2059 B6F4			LAB_1754
  2060 B6F4 20 82 00			JSR	LAB_GBYT		; scan memory
  2061 B6F7 90 C0			BCC	LAB_174C		; if numeric do GOTO n
  2062 									; the code will return to the interpreter loop at the
  2063 									; tail end of the GOTO <n>
  2064
  2065 B6F9 4C DB B4			JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2066 									; the code will return to the interpreter loop at the
  2067 									; tail end of the <statement>
  2068
  2069 				; perform REM, skip (rest of) line
  2070 B6FC			LAB_REM
  2071 B6FC 20 7B B6			JSR	LAB_SNBL		; scan for next BASIC line
  2072 B6FF 4C 6A B6			JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  2073
  2074 B702			LAB_16FD
  2075 B702 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2076
  2077 				; perform ON
  2078 B705			LAB_ON
  2079 B705 C9 A9			CMP	#TK_IRQ			; was it IRQ token ?
  2080 B707 D0 03			BNE	LAB_NOIN		; if not go check NMI
  2081
  2082 B709 4C 27 CF			JMP	LAB_SIRQ		; else go set-up IRQ
  2083
  2084 B70C			LAB_NOIN
  2085 B70C C9 AA			CMP	#TK_NMI			; was it NMI token ?
  2086 B70E D0 03			BNE	LAB_NONM		; if not go do normal ON command
  2087
  2088 B710 4C 2B CF			JMP	LAB_SNMI		; else go set-up NMI
  2089
  2090 B713			LAB_NONM
  2091 B713 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  2092 B716 48				PHA				; push GOTO/GOSUB token
  2093 B717 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  2094 B719 F0 04			BEQ	LAB_176B		; branch if GOSUB
  2095
  2096 B71B C9 89			CMP	#TK_GOTO		; compare with GOTO token
  2097 B71D			LAB_1767
  2098 B71D D0 E3			BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  2099
  2100
  2101 				; next character was GOTO or GOSUB
  2102 B71F			LAB_176B
  2103 B71F C6 6F			DEC	FAC1_3			; decrement index (byte value)
  2104 B721 D0 04			BNE	LAB_1773		; branch if not zero
  2105
  2106 B723 68				PLA				; pull GOTO/GOSUB token
  2107 B724 4C DD B4			JMP	LAB_1602		; go execute it
  2108
  2109 B727			LAB_1773
  2110 B727 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2111 B72A 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  2112 									; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2113 									; just BNE LAB_176B for the loop. should be quicker ..
  2114 									; no we can't, what if we meet a colon or [EOL]?)
  2115 B72D C9 2C			CMP	#$2C			; compare next character with ','
  2116 B72F F0 EE			BEQ	LAB_176B		; loop if ','
  2117
  2118 B731			LAB_177E
  2119 B731 68				PLA				; else pull keyword token (run out of options)
  2120 									; also dump +/-1 pointer low byte and exit
  2121 B732			LAB_177F
  2122 B732 60				RTS
  2123
  2124 				; takes n * 106 + 11 cycles where n is the number of digits
  2125 				; get fixed-point number into temp integer
  2126 B733			LAB_GFPN
  2127 B733 A2 00			LDX	#$00			; clear reg
  2128 B735 86 11			STX	Itempl			; clear temporary integer low byte
  2129 B737			LAB_1785
  2130 B737 86 12			STX	Itemph			; save temporary integer high byte
  2131 B739 B0 F7			BCS	LAB_177F		; return if carry set, end of scan, character was
  2132 									; not 0-9
  2133
  2134 B73B E0 19			CPX	#$19			; compare high byte with $19
  2135 B73D A8				TAY				; ensure Zb = 0 if the branch is taken
  2136 B73E B0 DD			BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  2137 									; bit does *$0A, = 64000, compare at target will fail
  2138 									; and do syntax error
  2139
  2140 B740 E9 2F			SBC	#'0'-1			; subtract '0', $2F + carry, from byte
  2141 B742 A8				TAY				; copy binary digit
  2142 B743 A5 11			LDA	Itempl			; get temporary integer low byte
  2143 B745 0A				ASL				; *2 low byte
  2144 B746 26 12			ROL	Itemph			; *2 high byte
  2145 B748 0A				ASL				; *2 low byte
  2146 B749 26 12			ROL	Itemph			; *2 high byte, *4
  2147 B74B 65 11			ADC	Itempl			; + low byte, *5
  2148 B74D 85 11			STA	Itempl			; save it
  2149 B74F 8A				TXA				; get high byte copy to A
  2150 B750 65 12			ADC	Itemph			; + high byte, *5
  2151 B752 06 11			ASL	Itempl			; *2 low byte, *10d
  2152 B754 2A				ROL				; *2 high byte, *10d
  2153 B755 AA				TAX				; copy high byte back to X
  2154 B756 98				TYA				; get binary digit back
  2155 B757 65 11			ADC	Itempl			; add number low byte
  2156 B759 85 11			STA	Itempl			; save number low byte
  2157 B75B 90 01			BCC	LAB_17B3		; if no overflow to high byte get next character
  2158
  2159 B75D E8				INX				; else increment high byte
  2160 B75E			LAB_17B3
  2161 B75E 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2162 B761 4C 37 B7			JMP	LAB_1785		; loop for next character
  2163
  2164 				; perform DEC
  2165 B764			LAB_DEC
  2166 B764 A9 F8			LDA	#<LAB_2AFD		; set -1 pointer low byte
  2167 B766 2C				.byte	$2C			; BIT abs to skip the LDA below
  2168
  2169 				; perform INC
  2170 B767			LAB_INC
  2171 B767 A9 F4			LDA	#<LAB_259C		; set 1 pointer low byte
  2172 B769			LAB_17B5
  2173 B769 48				PHA				; save +/-1 pointer low byte
  2174 B76A			LAB_17B7
  2175 B76A 20 89 BD			JSR	LAB_GVAR		; get var address
  2176 B76D A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2177 B76F 30 1E			BMI	IncrErr			; exit if string
  2178
  2179 B771 85 57			STA	Lvarpl			; save var address low byte
  2180 B773 84 58			STY	Lvarph			; save var address high byte
  2181 B775 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  2182 B778 68				PLA				; get +/-1 pointer low byte
  2183 B779 48				PHA				; save +/-1 pointer low byte
  2184 B77A A0 D3			LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  2185 B77C 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  2186 B77F 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
  2187
  2188 B782 20 82 00			JSR	LAB_GBYT		; scan memory
  2189 B785 C9 2C			CMP	#','			; compare with ','
  2190 B787 D0 A8			BNE	LAB_177E		; exit if not ',' (either end or error)
  2191
  2192 									; was ',' so another INCR variable to do
  2193 B789 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2194 B78C 4C 6A B7			JMP	LAB_17B7		; go do next var
  2195
  2196 B78F			IncrErr
  2197 B78F 4C B9 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  2198
  2199 				; perform LET
  2200 B792			LAB_LET
  2201 B792 20 89 BD			JSR	LAB_GVAR		; get var address
  2202 B795 85 57			STA	Lvarpl			; save var address low byte
  2203 B797 84 58			STY	Lvarph			; save var address high byte
  2204 B799 A9 D7			LDA	#TK_EQUAL		; get = token
  2205 B79B 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2206 B79E A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  2207 B7A0 48				PHA				; push data type flag
  2208 B7A1 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2209 B7A4 68				PLA				; pop data type flag
  2210 B7A5 2A				ROL				; set carry if type = string
  2211 					; patch result of a string compare stores string pointer to variable
  2212 B7A6 20 B0 BA			JSR	LAB_CKTM		; type match check, keep C (expected type)
  2213 B7A9 B0 03			BCS	LAB_17D5		; branch if string
  2214
  2215 B7AB 4C 90 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2216
  2217 				; string LET
  2218 B7AE			LAB_17D5
  2219 B7AE A0 02			LDY	#$02			; set index to pointer high byte
  2220 B7B0 B1 6E			LDA	(des_pl),Y		; get string pointer high byte
  2221 B7B2 C5 42			CMP	Sstorh			; compare bottom of string space high byte
  2222 B7B4 90 17			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2223
  2224 B7B6 D0 07			BNE	LAB_17E6		; branch if >
  2225 									; else was equal so compare low bytes
  2226 B7B8 88				DEY				; decrement index
  2227 B7B9 B1 6E			LDA	(des_pl),Y		; get pointer low byte
  2228 B7BB C5 41			CMP	Sstorl			; compare bottom of string space low byte
  2229 B7BD 90 0E			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2230 									; pointer was >= to bottom of string space pointer
  2231 B7BF			LAB_17E6
  2232 B7BF A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2233 B7C1 C4 3C			CPY	Svarh			; compare start of vars high byte
  2234 B7C3 90 08			BCC	LAB_17F4		; branch if less (descriptor is on stack)
  2235
  2236 B7C5 D0 0D			BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  2237
  2238 									; else high bytes were equal so ..
  2239 B7C7 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2240 B7C9 C5 3B			CMP	Svarl			; compare start of vars low byte
  2241 B7CB B0 07			BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  2242
  2243 B7CD			LAB_17F4
  2244 B7CD A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2245 B7CF A4 6F			LDY	des_ph			; get descriptor pointer high byte
  2246 B7D1 4C EA B7			JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  2247
  2248 									; make space and copy string
  2249 B7D4			LAB_17FB
  2250 B7D4 A0 00			LDY	#$00			; index to length
  2251 B7D6 B1 6E			LDA	(des_pl),Y		; get string length
  2252 B7D8 20 1D C1			JSR	LAB_209C		; copy string
  2253 B7DB A5 5E			LDA	des_2l			; get descriptor pointer low byte
  2254 B7DD A4 5F			LDY	des_2h			; get descriptor pointer high byte
  2255 B7DF 85 78			STA	ssptr_l			; save descriptor pointer low byte
  2256 B7E1 84 79			STY	ssptr_h			; save descriptor pointer high byte
  2257 B7E3 20 FE C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  2258 B7E6 A9 6C			LDA	#<FAC1_e		; set descriptor pointer low byte
  2259 B7E8 A0 00			LDY	#>FAC1_e		; get descriptor pointer high byte
  2260
  2261 									; clean stack and assign value to string variable
  2262 B7EA			LAB_1811
  2263 B7EA 85 5E			STA	des_2l			; save descriptor_2 pointer low byte
  2264 B7EC 84 5F			STY	des_2h			; save descriptor_2 pointer high byte
  2265 B7EE 20 60 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  2266 B7F1 A0 00			LDY	#$00			; index to length
  2267 B7F3 B1 5E			LDA	(des_2l),Y		; get string length
  2268 B7F5 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2269 B7F7 C8				INY				; index to string pointer low byte
  2270 B7F8 B1 5E			LDA	(des_2l),Y		; get string pointer low byte
  2271 B7FA 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2272 B7FC C8				INY				; index to string pointer high byte
  2273 B7FD B1 5E			LDA	(des_2l),Y		; get string pointer high byte
  2274 B7FF 91 57			STA	(Lvarpl),Y		; copy to let string variable
  2275 B801 60				RTS
  2276
  2277 				; perform GET
  2278 B802			LAB_GET
  2279 B802 20 89 BD			JSR	LAB_GVAR		; get var address
  2280 B805 85 57			STA	Lvarpl			; save var address low byte
  2281 B807 84 58			STY	Lvarph			; save var address high byte
  2282 B809 20 EF CE			JSR	INGET			; get input byte
  2283 B80C A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2284 B80E 30 07			BMI	LAB_GETS		; go get string character
  2285
  2286 									; was numeric get
  2287 B810 A8				TAY				; copy character to Y
  2288 B811 20 51 C0			JSR	LAB_1FD0		; convert Y to byte in FAC1
  2289 B814 4C 90 C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2290
  2291 B817			LAB_GETS
  2292 B817 48				PHA				; save character
  2293 B818 A9 01			LDA	#$01			; string is single byte
  2294 B81A B0 01			BCS	LAB_IsByte		; branch if byte received
  2295
  2296 B81C 68				PLA				; string is null
  2297 B81D			LAB_IsByte
  2298 B81D 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  2299 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2300 B820 F0 05			BEQ	LAB_NoSt		; skip store if null string
  2301
  2302 B822 68				PLA				; get character back
  2303 B823 A0 00			LDY	#$00			; clear index
  2304 B825 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  2305 B827			LAB_NoSt
  2306 B827 20 72 C1			JSR	LAB_RTST		; check for space on descriptor stack then put address
  2307 									; and length on descriptor stack and update stack pointers
  2308
  2309 B82A 4C AE B7			JMP	LAB_17D5		; do string LET and return
  2310
  2311 				; perform PRINT
  2312 B82D			LAB_1829
  2313 B82D 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2314 B830			LAB_182C
  2315 B830 20 82 00			JSR	LAB_GBYT		; scan memory
  2316
  2317 				; PRINT
  2318 B833			LAB_PRINT
  2319 B833 F0 3B			BEQ	LAB_CRLF		; if nothing following just print CR/LF
  2320
  2321 B835			LAB_1831
  2322 B835 C9 C0			CMP	#TK_TAB			; compare with TAB( token
  2323 B837 F0 56			BEQ	LAB_18A2		; go do TAB/SPC
  2324
  2325 B839 C9 C4			CMP	#TK_SPC			; compare with SPC( token
  2326 B83B F0 52			BEQ	LAB_18A2		; go do TAB/SPC
  2327
  2328 B83D C9 2C			CMP	#','			; compare with ','
  2329 B83F F0 38			BEQ	LAB_188B		; go do move to next TAB mark
  2330
  2331 B841 C9 3B			CMP	#';'			; compare with ';'
  2332 B843 F0 66			BEQ	LAB_18BD		; if ';' continue with PRINT processing
  2333
  2334 B845 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2335 B848 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2336 B84A 30 E1			BMI	LAB_1829		; branch if string
  2337
  2338 B84C 20 82 CA			JSR	LAB_296E		; convert FAC1 to string
  2339 B84F 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2340 B852 A0 00			LDY	#$00			; clear index
  2341
  2342 				; don't check fit if terminal width byte is zero
  2343
  2344 B854 A5 0F			LDA	TWidth			; get terminal width byte
  2345 B856 F0 0A			BEQ	LAB_185E		; skip check if zero
  2346
  2347 B858 38				SEC				; set carry for subtract
  2348 B859 E5 0E			SBC	TPos			; subtract terminal position
  2349 B85B F1 6E			SBC	(des_pl),Y		; subtract string length
  2350 B85D B0 03			BCS	LAB_185E		; branch if less than terminal width
  2351
  2352 B85F 20 70 B8			JSR	LAB_CRLF		; else print CR/LF
  2353 B862			LAB_185E
  2354 B862 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2355 B865 F0 C9			BEQ	LAB_182C		; always go continue processing line
  2356
  2357 				; CR/LF return to BASIC from BASIC input handler
  2358 B867			LAB_1866
  2359 B867 A9 00			LDA	#$00			; clear byte
  2360 B869 9D 7F 18			STA	Ibuffs,X		; null terminate input
  2361 B86C A2 7F			LDX	#<Ibuffs		; set X to buffer start-1 low byte
  2362 B86E A0 18			LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  2363
  2364 				; print CR/LF
  2365 B870			LAB_CRLF
  2366 B870 A9 0D			LDA	#$0D			; load [CR]
  2367 B872 20 CB B8			JSR	LAB_PRNA		; go print the character
  2368 B875 A9 0A			LDA	#$0A			; load [LF]
  2369 B877 D0 52			BNE	LAB_PRNA		; go print the character and return, branch always
  2370
  2371 B879			LAB_188B
  2372 B879 A5 0E			LDA	TPos			; get terminal position
  2373 B87B C5 10			CMP	Iclim			; compare with input column limit
  2374 B87D 90 05			BCC	LAB_1897		; branch if less
  2375
  2376 B87F 20 70 B8			JSR	LAB_CRLF		; else print CR/LF (next line)
  2377 B882 D0 27			BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2378
  2379 B884			LAB_1897
  2380 B884 38				SEC				; set carry for subtract
  2381 B885			LAB_1898
  2382 B885 E5 24			SBC	TabSiz			; subtract TAB size
  2383 B887 B0 FC			BCS	LAB_1898		; loop if result was +ve
  2384
  2385 B889 49 FF			EOR	#$FF			; complement it
  2386 B88B 69 01			ADC	#$01			; +1 (twos complement)
  2387 B88D D0 12			BNE	LAB_18B6		; always print A spaces (result is never $00)
  2388 									; do TAB/SPC
  2389 B88F			LAB_18A2
  2390 B88F 48				PHA				; save token
  2391 B890 20 76 C4			JSR	LAB_SGBY		; scan and get byte parameter
  2392 B893 C9 29			CMP	#$29			; is next character )
  2393 B895 D0 7B			BNE	LAB_1910		; if not do syntax error then warm start
  2394
  2395 B897 68				PLA				; get token back
  2396 B898 C9 C0			CMP	#TK_TAB			; was it TAB ?
  2397 B89A D0 06			BNE	LAB_18B7		; if not go do SPC
  2398
  2399 									; calculate TAB offset
  2400 B89C 8A				TXA				; copy integer value to A
  2401 B89D E5 0E			SBC	TPos			; subtract terminal position
  2402 B89F 90 0A			BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  2403 									; print A spaces
  2404 B8A1			LAB_18B6
  2405 B8A1 AA				TAX				; copy result to X
  2406 B8A2			LAB_18B7
  2407 B8A2 8A				TXA				; set flags on size for SPC
  2408 B8A3 F0 06			BEQ	LAB_18BD		; branch if result was = $0, already here
  2409
  2410 									; print X spaces
  2411 B8A5			LAB_18BA
  2412 B8A5 20 C6 B8			JSR	LAB_18E0		; print ' '
  2413 B8A8 CA				DEX				; decrement count
  2414 B8A9 D0 FA			BNE	LAB_18BA		; loop if not all done
  2415
  2416 									; continue with PRINT processing
  2417 B8AB			LAB_18BD
  2418 B8AB 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2419 B8AE D0 85			BNE	LAB_1831		; if more to print go do it
  2420
  2421 B8B0 60				RTS
  2422
  2423 				; print null terminated string from memory
  2424 B8B1			LAB_18C3
  2425 B8B1 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2426
  2427 				; print string from Sutill/Sutilh
  2428 B8B4			LAB_18C6
  2429 B8B4 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2430 									; space returns with A = length, X=$71=pointer low byte,
  2431 									; Y=$72=pointer high byte
  2432 B8B7 A0 00			LDY	#$00			; reset index
  2433 B8B9 AA				TAX				; copy length to X
  2434 B8BA F0 49			BEQ	LAB_188C		; exit (RTS) if null string
  2435
  2436 B8BC			LAB_18CD
  2437
  2438 B8BC B1 31			LDA	(ut1_pl),Y		; get next byte
  2439 B8BE 20 CB B8			JSR	LAB_PRNA		; go print the character
  2440 B8C1 C8				INY				; increment index
  2441 B8C2 CA				DEX				; decrement count
  2442 B8C3 D0 F7			BNE	LAB_18CD		; loop if not done yet
  2443
  2444 B8C5 60				RTS
  2445
  2446 									; Print single format character
  2447 				; print ' '
  2448 B8C6			LAB_18E0
  2449 B8C6 A9 20			LDA	#$20			; load ' '
  2450 B8C8 2C				.byte	$2C			; change next line to BIT LAB_3FA9
  2451
  2452 				; print '?' character
  2453 B8C9			LAB_18E3
  2454 B8C9 A9 3F			LDA	#$3F			; load '?' character
  2455
  2456 				; print character in A
  2457 				; now includes the null handler
  2458 				; also includes infinite line length code
  2459 				; note! some routines expect this one to exit with Zb=0
  2460 B8CB			LAB_PRNA
  2461 B8CB C9 20			CMP	#' '			; compare with ' '
  2462 B8CD 90 19			BCC	LAB_18F9		; branch if less (non printing)
  2463
  2464 									; else printable character
  2465 B8CF 48				PHA				; save the character
  2466
  2467 				; don't check fit if terminal width byte is zero
  2468 B8D0 A5 0F			LDA	TWidth			; get terminal width
  2469 B8D2 D0 0A			BNE	LAB_18F0		; branch if not zero (not infinite length)
  2470
  2471 				; is 'infinite line' so check TAB position
  2472 B8D4 A5 0E			LDA	TPos			; get position
  2473 B8D6 E5 24			SBC	TabSiz			; subtract TAB size, carry set by CMP #$20 above
  2474 B8D8 D0 0B			BNE	LAB_18F7		; skip reset if different
  2475
  2476 B8DA 85 0E			STA	TPos			; else reset position
  2477 B8DC F0 07			BEQ	LAB_18F7		; go print character
  2478
  2479 B8DE			LAB_18F0
  2480 B8DE C5 0E			CMP	TPos			; compare with terminal character position
  2481 B8E0 D0 03			BNE	LAB_18F7		; branch if not at end of line
  2482
  2483 B8E2 20 70 B8			JSR	LAB_CRLF		; else print CR/LF
  2484 B8E5			LAB_18F7
  2485 B8E5 E6 0E			INC	TPos			; increment terminal position
  2486 B8E7 68				PLA				; get character back
  2487 B8E8			LAB_18F9
  2488 B8E8 20 0F D3			JSR	V_OUTP			; output byte via output vector
  2489 B8EB C9 0D			CMP	#$0D			; compare with [CR]
  2490 B8ED D0 14			BNE	LAB_188A		; branch if not [CR]
  2491
  2492 									; else print nullct nulls after the [CR]
  2493 B8EF 86 38			STX	TempB			; save buffer index
  2494 B8F1 A6 0D			LDX	Nullct			; get null count
  2495 B8F3 F0 0A			BEQ	LAB_1886		; branch if no nulls
  2496
  2497 B8F5 A9 00			LDA	#$00			; load [NULL]
  2498 B8F7			LAB_1880
  2499 B8F7 20 CB B8			JSR	LAB_PRNA		; go print the character
  2500 B8FA CA				DEX				; decrement count
  2501 B8FB D0 FA			BNE	LAB_1880		; loop if not all done
  2502
  2503 B8FD A9 0D			LDA	#$0D			; restore the character (and set the flags)
  2504 B8FF			LAB_1886
  2505 B8FF 86 0E			STX	TPos			; clear terminal position (X always = zero when we get here)
  2506 B901 A6 38			LDX	TempB			; restore buffer index
  2507 B903			LAB_188A
  2508 B903 29 FF			AND	#$FF			; set the flags
  2509 B905			LAB_188C
  2510 B905 60				RTS
  2511
  2512 				; handle bad input data
  2513 B906			LAB_1904
  2514 B906 A5 22			LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
  2515 B908 10 0B			BPL	LAB_1913		; branch if INPUT (go do redo)
  2516
  2517 B90A A5 4D			LDA	Dlinel			; get current DATA line low byte
  2518 B90C A4 4E			LDY	Dlineh			; get current DATA line high byte
  2519 B90E 85 47			STA	Clinel			; save current line low byte
  2520 B910 84 48			STY	Clineh			; save current line high byte
  2521 B912			LAB_1910
  2522 B912 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2523
  2524 									; mode was INPUT
  2525 B915			LAB_1913
  2526 B915 A9 47			LDA	#<LAB_REDO		; point to redo message (low addr)
  2527 B917 A0 DB			LDY	#>LAB_REDO		; point to redo message (high addr)
  2528 B919 20 B1 B8			JSR	LAB_18C3		; print null terminated string from memory
  2529 B91C A5 4B			LDA	Cpntrl			; get continue pointer low byte
  2530 B91E A4 4C			LDY	Cpntrh			; get continue pointer high byte
  2531 B920 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2532 B922 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  2533 B924 60				RTS
  2534
  2535 				; perform INPUT
  2536 B925			LAB_INPUT
  2537 B925 C9 22			CMP	#$22			; compare next byte with open quote
  2538 B927 D0 0B			BNE	LAB_1934		; branch if no prompt string
  2539
  2540 B929 20 9B BB			JSR	LAB_1BC1		; print '...' string
  2541 B92C A9 3B			LDA	#$3B			; load A with ';'
  2542 B92E 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2543 B931 20 B4 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2544
  2545 									; done with prompt, now get data
  2546 B934			LAB_1934
  2547 B934 20 55 C0			JSR	LAB_CKRN		; check not Direct, back here if ok
  2548 B937 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2549 B93A A9 00			LDA	#$00			; set mode = INPUT
  2550 B93C CD 7F 18			CMP	Ibuffs			; test first byte in buffer
  2551 B93F D0 09			BNE	LAB_1953		; branch if not null input
  2552
  2553 					; *** change p2: keep carry set to throw break message
  2554 					;CLC				; was null input so clear carry to exit program
  2555 B941 4C 05 B5			JMP	LAB_1647		; go do BREAK exit
  2556
  2557 				; perform READ
  2558 B944			LAB_READ
  2559 B944 A6 4F			LDX	Dptrl			; get DATA pointer low byte
  2560 B946 A4 50			LDY	Dptrh			; get DATA pointer high byte
  2561 B948 A9 80			LDA	#$80			; set mode = READ
  2562
  2563 B94A			LAB_1953
  2564 B94A 85 22			STA	Imode			; set input mode flag, $00=INPUT, $80=READ
  2565 B94C 86 51			STX	Rdptrl			; save READ pointer low byte
  2566 B94E 84 52			STY	Rdptrh			; save READ pointer high byte
  2567 									; READ or INPUT next variable from list
  2568 B950			LAB_195B
  2569 B950 20 89 BD			JSR	LAB_GVAR		; get (var) address
  2570 B953 85 57			STA	Lvarpl			; save address low byte
  2571 B955 84 58			STY	Lvarph			; save address high byte
  2572 B957 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2573 B959 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2574 B95B 85 11			STA	Itempl			; save as temporary integer low byte
  2575 B95D 84 12			STY	Itemph			; save as temporary integer high byte
  2576 B95F A6 51			LDX	Rdptrl			; get READ pointer low byte
  2577 B961 A4 52			LDY	Rdptrh			; get READ pointer high byte
  2578 B963 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2579 B965 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2580 B967 20 82 00			JSR	LAB_GBYT		; scan memory
  2581 B96A D0 11			BNE	LAB_1988		; branch if not null
  2582
  2583 									; pointer was to null entry
  2584 B96C 24 22			BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
  2585 B96E 30 65			BMI	LAB_19DD		; branch if READ
  2586
  2587 									; mode was INPUT
  2588 B970 20 C9 B8			JSR	LAB_18E3		; print '?' character (double ? for extended input)
  2589 B973 20 12 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2590 B976 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2591 B978 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2592 B97A			LAB_1985
  2593 B97A 20 82 00			JSR	LAB_GBYT		; scan memory
  2594 B97D			LAB_1988
  2595 B97D 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2596 B97F 10 24			BPL	LAB_19B0		; branch if numeric
  2597
  2598 									; else get string
  2599 B981 85 1B			STA	Srchc			; save search character
  2600 B983 C9 22			CMP	#$22			; was it ' ?
  2601 B985 F0 07			BEQ	LAB_1999		; branch if so
  2602
  2603 B987 A9 3A			LDA	#':'			; else search character is ':'
  2604 B989 85 1B			STA	Srchc			; set new search character
  2605 B98B A9 2C			LDA	#','			; other search character is ','
  2606 B98D 18				CLC				; clear carry for add
  2607 B98E			LAB_1999
  2608 B98E 85 1C			STA	Asrch			; set second search character
  2609 B990 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2610 B992 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2611
  2612 B994 69 00			ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2613 B996 90 01			BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2614
  2615 B998 C8				INY				; else increment high byte
  2616 B999			LAB_19A4
  2617 B999 20 35 C1			JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
  2618 B99C 20 BC C4			JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2619 B99F 20 AE B7			JSR	LAB_17D5		; go do string LET
  2620 B9A2 4C AB B9			JMP	LAB_19B6		; go check string terminator
  2621
  2622 									; get numeric INPUT
  2623 B9A5			LAB_19B0
  2624 B9A5 20 93 C9			JSR	LAB_2887		; get FAC1 from string
  2625 B9A8 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
  2626 B9AB			LAB_19B6
  2627 B9AB 20 82 00			JSR	LAB_GBYT		; scan memory
  2628 B9AE F0 0A			BEQ	LAB_19C5		; branch if null (last entry)
  2629
  2630 B9B0 C9 2C			CMP	#','			; else compare with ','
  2631 B9B2 F0 03			BEQ	LAB_19C2		; branch if ','
  2632
  2633 B9B4 4C 06 B9			JMP	LAB_1904		; else go handle bad input data
  2634
  2635 									; got good input data
  2636 B9B7			LAB_19C2
  2637 B9B7 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2638 B9BA			LAB_19C5
  2639 B9BA A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2640 B9BC A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2641 B9BE 85 51			STA	Rdptrl			; save for now
  2642 B9C0 84 52			STY	Rdptrh			; save for now
  2643 B9C2 A5 11			LDA	Itempl			; get temporary integer low byte (temp BASIC execute ptr)
  2644 B9C4 A4 12			LDY	Itemph			; get temporary integer high byte (temp BASIC execute ptr)
  2645 B9C6 85 83			STA	Bpntrl			; set BASIC execute pointer low byte
  2646 B9C8 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2647 B9CA 20 82 00			JSR	LAB_GBYT		; scan memory
  2648 B9CD F0 2C			BEQ	LAB_1A03		; if null go do extra ignored message
  2649
  2650 B9CF 20 DB BB			JSR	LAB_1C01		; else scan for ',' , else do syntax error then warm start
  2651 B9D2 4C 50 B9			JMP	LAB_195B		; go INPUT next variable from list
  2652
  2653 									; find next DATA statement or do 'Out of DATA' error
  2654 B9D5			LAB_19DD
  2655 B9D5 20 78 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2656 B9D8 C8				INY				; increment index
  2657 B9D9 AA				TAX				; copy character ([:] or [EOL])
  2658 B9DA D0 12			BNE	LAB_19F6		; branch if [:]
  2659
  2660 B9DC A2 06			LDX	#$06			; set for 'Out of DATA' error
  2661 B9DE C8				INY				; increment index, now points to next line pointer high byte
  2662 B9DF B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  2663 B9E1 F0 73			BEQ	LAB_1A54		; branch if end (eventually does error X)
  2664
  2665 B9E3 C8				INY				; increment index
  2666 B9E4 B1 83			LDA	(Bpntrl),Y		; get next line # low byte
  2667 B9E6 85 4D			STA	Dlinel			; save current DATA line low byte
  2668 B9E8 C8				INY				; increment index
  2669 B9E9 B1 83			LDA	(Bpntrl),Y		; get next line # high byte
  2670 B9EB C8				INY				; increment index
  2671 B9EC 85 4E			STA	Dlineh			; save current DATA line high byte
  2672 B9EE			LAB_19F6
  2673 B9EE B1 83			LDA	(Bpntrl),Y		; get byte
  2674 B9F0 C8				INY				; increment index
  2675 B9F1 AA				TAX				; copy to X
  2676 B9F2 20 6A B6			JSR	LAB_170F		; set BASIC execute pointer
  2677 B9F5 E0 83			CPX	#TK_DATA		; compare with 'DATA' token
  2678 B9F7 F0 81			BEQ	LAB_1985		; was 'DATA' so go do next READ
  2679
  2680 B9F9 D0 DA			BNE	LAB_19DD		; go find next statement if not 'DATA'
  2681
  2682 				; end of INPUT/READ routine
  2683 B9FB			LAB_1A03
  2684 B9FB A5 51			LDA	Rdptrl			; get temp READ pointer low byte
  2685 B9FD A4 52			LDY	Rdptrh			; get temp READ pointer high byte
  2686 B9FF A6 22			LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
  2687 BA01 10 03			BPL	LAB_1A0E		; branch if INPUT
  2688
  2689 BA03 4C 27 B5			JMP	LAB_1624		; save AY as DATA pointer and return
  2690
  2691 									; we were getting INPUT
  2692 BA06			LAB_1A0E
  2693 BA06 A0 00			LDY	#$00			; clear index
  2694 BA08 B1 51			LDA	(Rdptrl),Y		; get next byte
  2695 BA0A D0 01			BNE	LAB_1A1B		; error if not end of INPUT
  2696
  2697 BA0C 60				RTS
  2698
  2699 									; user typed too much
  2700 BA0D			LAB_1A1B
  2701 BA0D A9 36			LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2702 BA0F A0 DB			LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2703 BA11 4C B1 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  2704
  2705 				; search the stack for FOR activity
  2706 				; exit with z=1 if FOR else exit with z=0
  2707 BA14			LAB_11A1
  2708 BA14 BA				TSX				; copy stack pointer
  2709 BA15 E8				INX				; +1 pass return address
  2710 BA16 E8				INX				; +2 pass return address
  2711 BA17 E8				INX				; +3 pass calling routine return address
  2712 BA18 E8				INX				; +4 pass calling routine return address
  2713 BA19			LAB_11A6
  2714 BA19 BD 01 01			LDA	LAB_STAK+1,X		; get token byte from stack
  2715 BA1C C9 81			CMP	#TK_FOR			; is it FOR token
  2716 BA1E D0 21			BNE	LAB_11CE		; exit if not FOR token
  2717
  2718 									; was FOR token
  2719 BA20 A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  2720 BA22 D0 0A			BNE	LAB_11BB		; branch if not null
  2721
  2722 BA24 BD 02 01			LDA	LAB_STAK+2,X		; get FOR variable pointer low byte
  2723 BA27 85 57			STA	Frnxtl			; save var pointer for FOR/NEXT low byte
  2724 BA29 BD 03 01			LDA	LAB_STAK+3,X		; get FOR variable pointer high byte
  2725 BA2C 85 58			STA	Frnxth			; save var pointer for FOR/NEXT high byte
  2726 BA2E			LAB_11BB
  2727 BA2E DD 03 01			CMP	LAB_STAK+3,X		; compare var pointer with stacked var pointer (high byte)
  2728 BA31 D0 07			BNE	LAB_11C7		; branch if no match
  2729
  2730 BA33 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  2731 BA35 DD 02 01			CMP	LAB_STAK+2,X		; compare var pointer with stacked var pointer (low byte)
  2732 BA38 F0 07			BEQ	LAB_11CE		; exit if match found
  2733
  2734 BA3A			LAB_11C7
  2735 BA3A 8A				TXA				; copy index
  2736 BA3B 18				CLC				; clear carry for add
  2737 BA3C 69 10			ADC	#$10			; add FOR stack use size
  2738 BA3E AA				TAX				; copy back to index
  2739 BA3F D0 D8			BNE	LAB_11A6		; loop if not at start of stack
  2740
  2741 BA41			LAB_11CE
  2742 BA41 60				RTS
  2743
  2744 				; perform NEXT
  2745 BA42			LAB_NEXT
  2746 BA42 D0 04			BNE	LAB_1A46		; branch if NEXT var
  2747
  2748 BA44 A0 00			LDY	#$00			; else clear Y
  2749 BA46 F0 03			BEQ	LAB_1A49		; branch always (no variable to search for)
  2750
  2751 				; NEXT var
  2752 BA48			LAB_1A46
  2753 BA48 20 89 BD			JSR	LAB_GVAR		; get variable address
  2754 BA4B			LAB_1A49
  2755 BA4B 85 57			STA	Frnxtl			; store variable pointer low byte
  2756 BA4D 84 58			STY	Frnxth			; store variable pointer high byte
  2757 									; (both cleared if no variable defined)
  2758 BA4F 20 14 BA			JSR	LAB_11A1		; search the stack for FOR activity
  2759 BA52 F0 04			BEQ	LAB_1A56		; branch if found
  2760
  2761 BA54 A2 00			LDX	#$00			; else set error $00 ('NEXT without FOR' error)
  2762 BA56			LAB_1A54
  2763 BA56 F0 63			BEQ	LAB_1ABE		; do error #X, then warm start
  2764
  2765 BA58			LAB_1A56
  2766 BA58 9A				TXS				; set stack pointer, X set by search, dumps return addresses
  2767
  2768 BA59 8A				TXA				; copy stack pointer
  2769 BA5A 38				SEC				; set carry for subtract
  2770 BA5B E9 F7			SBC	#$F7			; point to TO var
  2771 BA5D 85 33			STA	ut2_pl			; save pointer to TO var for compare
  2772 BA5F 69 FB			ADC	#$FB			; point to STEP var
  2773
  2774 BA61 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2775 BA63 20 6A C8			JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
  2776 BA66 BA				TSX				; get stack pointer back
  2777 BA67 BD 08 01			LDA	LAB_STAK+8,X		; get step sign
  2778 BA6A 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  2779 BA6C A5 57			LDA	Frnxtl			; get FOR variable pointer low byte
  2780 BA6E A4 58			LDY	Frnxth			; get FOR variable pointer high byte
  2781 BA70 20 AB C5			JSR	LAB_246C		; add (FOR variable) to FAC1
  2782 BA73 20 90 C8			JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2783 BA76 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2784 BA78 20 06 C9			JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
  2785 BA7B BA				TSX				; get stack pointer back
  2786 BA7C DD 08 01			CMP	LAB_STAK+8,X		; compare step sign
  2787 BA7F F0 17			BEQ	LAB_1A9B		; branch if = (loop complete)
  2788
  2789 									; loop back and do it all again
  2790 BA81 BD 0D 01			LDA	LAB_STAK+$0D,X		; get FOR line low byte
  2791 BA84 85 47			STA	Clinel			; save current line low byte
  2792 BA86 BD 0E 01			LDA	LAB_STAK+$0E,X		; get FOR line high byte
  2793 BA89 85 48			STA	Clineh			; save current line high byte
  2794 BA8B BD 10 01			LDA	LAB_STAK+$10,X		; get BASIC execute pointer low byte
  2795 BA8E 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2796 BA90 BD 0F 01			LDA	LAB_STAK+$0F,X		; get BASIC execute pointer high byte
  2797 BA93 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  2798 BA95			LAB_1A98
  2799 BA95 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  2800
  2801 									; loop complete so carry on
  2802 BA98			LAB_1A9B
  2803 BA98 8A				TXA				; stack copy to A
  2804 BA99 69 0F			ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
  2805 BA9B AA				TAX				; copy back to index
  2806 BA9C 9A				TXS				; copy to stack pointer
  2807 BA9D 20 82 00			JSR	LAB_GBYT		; scan memory
  2808 BAA0 C9 2C			CMP	#','			; compare with ','
  2809 BAA2 D0 F1			BNE	LAB_1A98		; branch if not ',' (go do interpreter inner loop)
  2810
  2811 									; was ',' so another NEXT variable to do
  2812 BAA4 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  2813 BAA7 20 48 BA			JSR	LAB_1A46		; do NEXT (var)
  2814
  2815 				; evaluate expression and check is numeric, else do type mismatch
  2816 BAAA			LAB_EVNM
  2817 BAAA 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  2818
  2819 				; check if source is numeric, else do type mismatch
  2820 BAAD			LAB_CTNM
  2821 BAAD 18				CLC				; destination is numeric
  2822 BAAE 24				.byte	$24			; makes next line BIT $38
  2823
  2824 				; check if source is string, else do type mismatch
  2825 BAAF			LAB_CTST
  2826 BAAF 38				SEC				; required type is string
  2827
  2828 				; type match check, set C for string, clear C for numeric
  2829 BAB0			LAB_CKTM
  2830 BAB0 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2831 BAB2 30 03			BMI	LAB_1ABA		; branch if data type is string
  2832
  2833 									; else data type was numeric
  2834 BAB4 B0 03			BCS	LAB_1ABC		; if required type is string do type mismatch error
  2835 BAB6			LAB_1AB9
  2836 BAB6 60				RTS
  2837
  2838 									; data type was string, now check required type
  2839 BAB7			LAB_1ABA
  2840 BAB7 B0 FD			BCS	LAB_1AB9		; exit if required type is string
  2841
  2842 									; else do type mismatch error
  2843 BAB9			LAB_1ABC
  2844 BAB9 A2 18			LDX	#$18			; error code $18 ('Type mismatch' error)
  2845 BABB			LAB_1ABE
  2846 BABB 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  2847
  2848 				; evaluate expression
  2849 BABE			LAB_EVEX
  2850 BABE A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2851 BAC0 D0 02			BNE	LAB_1AC7		; skip next if not zero
  2852
  2853 BAC2 C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2854 BAC4			LAB_1AC7
  2855 BAC4 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2856
  2857 BAC6			LAB_EVEZ
  2858 BAC6 A9 00			LDA	#$00			; set null precedence (flag done)
  2859 BAC8			LAB_1ACC
  2860 BAC8 48				PHA				; push precedence byte
  2861 BAC9 A9 02			LDA	#$02			; 2 bytes
  2862 BACB 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  2863 BACE 20 AA BB			JSR	LAB_GVAL		; get value from line
  2864 BAD1 A9 00			LDA	#$00			; clear A
  2865 BAD3 85 5B			STA	comp_f			; clear compare function flag
  2866 BAD5			LAB_1ADB
  2867 BAD5 20 82 00			JSR	LAB_GBYT		; scan memory
  2868 BAD8			LAB_1ADE
  2869 BAD8 38				SEC				; set carry for subtract
  2870 BAD9 E9 D6			SBC	#TK_GT			; subtract token for > (lowest comparison function)
  2871 BADB 90 17			BCC	LAB_1AFA		; branch if < TK_GT
  2872
  2873 BADD C9 03			CMP	#$03			; compare with '>' to '<' tokens
  2874 BADF B0 13			BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2875
  2876 									; was token for > = or < (A = 0, 1 or 2)
  2877 BAE1 C9 01			CMP	#$01			; compare with token for =
  2878 BAE3 2A				ROL				; *2, b0 = carry (=1 if token was = or <)
  2879 									; (A = 0, 3 or 5)
  2880 BAE4 49 01			EOR	#$01			; toggle b0
  2881 									; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2882 BAE6 45 5B			EOR	comp_f			; EOR with compare function flag bits
  2883 BAE8 C5 5B			CMP	comp_f			; compare with compare function flag
  2884 BAEA 90 67			BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
  2885 									; was more than one <, = or >)
  2886
  2887 BAEC 85 5B			STA	comp_f			; save new compare function flag
  2888 BAEE 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2889 BAF1 4C D8 BA			JMP	LAB_1ADE		; go do next character
  2890
  2891 									; token is < '>' or > '<' tokens
  2892 BAF4			LAB_1AFA
  2893 BAF4 A6 5B			LDX	comp_f			; get compare function flag
  2894 BAF6 D0 2C			BNE	LAB_1B2A		; branch if compare function
  2895
  2896 BAF8 B0 79			BCS	LAB_1B78		; go do functions
  2897
  2898 									; else was <  TK_GT so is operator or lower
  2899 BAFA 69 0B			ADC	#TK_GT-TK_PLUS		; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2900 BAFC 90 75			BCC	LAB_1B78		; branch if < + operator
  2901
  2902 									; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2903 BAFE D0 07			BNE	LAB_1B0B		; branch if not + token
  2904
  2905 BB00 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2906 BB02 10 03			BPL	LAB_1B0B		; branch if not string
  2907
  2908 									; will only be $00 if type is string and token was +
  2909 BB04 4C C1 C2			JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
  2910 									; is in line, and return
  2911
  2912 BB07			LAB_1B0B
  2913 BB07 85 31			STA	ut1_pl			; save it
  2914 BB09 0A				ASL				; *2
  2915 BB0A 65 31			ADC	ut1_pl			; *3
  2916 BB0C A8				TAY				; copy to index
  2917 BB0D			LAB_1B13
  2918 BB0D 68				PLA				; pull previous precedence
  2919 BB0E D9 37 D5			CMP	LAB_OPPT,Y		; compare with precedence byte
  2920 BB11 B0 65			BCS	LAB_1B7D		; branch if A >=
  2921
  2922 BB13 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2923 BB16			LAB_1B1C
  2924 BB16 48				PHA				; save precedence
  2925 BB17			LAB_1B1D
  2926 BB17 20 3F BB			JSR	LAB_1B43		; get vector, execute function then continue evaluation
  2927 BB1A 68				PLA				; restore precedence
  2928 BB1B A4 59			LDY	prstk			; get precedence stacked flag
  2929 BB1D 10 19			BPL	LAB_1B3C		; branch if stacked values
  2930
  2931 BB1F AA				TAX				; copy precedence (set flags)
  2932 BB20 F0 76			BEQ	LAB_1B9D		; exit if done
  2933
  2934 BB22 D0 5D			BNE	LAB_1B86		; else pop FAC2 and return, branch always
  2935
  2936 BB24			LAB_1B2A
  2937 BB24 26 1F			ROL	Dtypef			; shift data type flag into Cb
  2938 BB26 8A				TXA				; copy compare function flag
  2939 BB27 85 1F			STA	Dtypef			; clear data type flag, X is 0xxx xxxx
  2940 BB29 2A				ROL				; shift data type into compare function byte b0
  2941 BB2A A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2942 BB2C D0 02			BNE	LAB_1B34		; branch if no underflow
  2943
  2944 BB2E C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2945 BB30			LAB_1B34
  2946 BB30 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2947 = 000D			TK_LT_PLUS	= TK_LT-TK_PLUS
  2948 BB32 A0 27			LDY	#TK_LT_PLUS*3		; set offset to last operator entry
  2949 BB34 85 5B			STA	comp_f			; save new compare function flag
  2950 BB36 D0 D5			BNE	LAB_1B13		; branch always
  2951
  2952 BB38			LAB_1B3C
  2953 BB38 D9 37 D5			CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  2954 BB3B B0 44			BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  2955
  2956 BB3D 90 D7			BCC	LAB_1B1C		; branch always
  2957
  2958 				;.get vector, execute function then continue evaluation
  2959 BB3F			LAB_1B43
  2960 BB3F B9 39 D5			LDA	LAB_OPPT+2,Y		; get function vector high byte
  2961 BB42 48				PHA				; onto stack
  2962 BB43 B9 38 D5			LDA	LAB_OPPT+1,Y		; get function vector low byte
  2963 BB46 48				PHA				; onto stack
  2964 									; now push sign, round FAC1 and put on stack
  2965 BB47 20 56 BB			JSR	LAB_1B5B		; function will return here, then the next RTS will call
  2966 									; the function
  2967 BB4A A5 5B			LDA	comp_f			; get compare function flag
  2968 BB4C 48				PHA				; push compare evaluation byte
  2969 BB4D B9 37 D5			LDA	LAB_OPPT,Y		; get precedence byte
  2970 BB50 4C C8 BA			JMP	LAB_1ACC		; continue evaluating expression
  2971
  2972 BB53			LAB_1B53
  2973 BB53 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  2974
  2975 				; push sign, round FAC1 and put on stack
  2976 BB56			LAB_1B5B
  2977 BB56 68				PLA				; get return addr low byte
  2978 BB57 85 31			STA	ut1_pl			; save it
  2979 BB59 E6 31			INC	ut1_pl			; increment it (was ret-1 pushed? yes!)
  2980 									; note! no check is made on the high byte! if the calling
  2981 									; routine assembles to a page edge then this all goes
  2982 									; horribly wrong !!!
  2983 BB5B 68				PLA				; get return addr high byte
  2984 BB5C 85 32			STA	ut1_ph			; save it
  2985 BB5E A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  2986 BB60 48				PHA				; push sign
  2987
  2988 				; round FAC1 and put on stack
  2989 BB61			LAB_1B66
  2990 BB61 20 C6 C8			JSR	LAB_27BA		; round FAC1
  2991 BB64 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  2992 BB66 48				PHA				; push on stack
  2993 BB67 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  2994 BB69 48				PHA				; push on stack
  2995 BB6A A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  2996 BB6C 48				PHA				; push on stack
  2997 BB6D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  2998 BB6F 48				PHA				; push on stack
  2999 BB70 6C 31 00			JMP	(ut1_pl)		; return, sort of
  3000
  3001 				; do functions
  3002 BB73			LAB_1B78
  3003 BB73 A0 FF			LDY	#$FF			; flag function
  3004 BB75 68				PLA				; pull precedence byte
  3005 BB76			LAB_1B7B
  3006 BB76 F0 20			BEQ	LAB_1B9D		; exit if done
  3007
  3008 BB78			LAB_1B7D
  3009 BB78 C9 64			CMP	#$64			; compare previous precedence with $64
  3010 BB7A F0 03			BEQ	LAB_1B84		; branch if was $64 (< function)
  3011
  3012 BB7C 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3013 BB7F			LAB_1B84
  3014 BB7F 84 59			STY	prstk			; save precedence stacked flag
  3015
  3016 									; pop FAC2 and return
  3017 BB81			LAB_1B86
  3018 BB81 68				PLA				; pop byte
  3019 BB82 4A				LSR				; shift out comparison evaluation lowest bit
  3020 BB83 85 23			STA	Cflag			; save comparison evaluation flag
  3021 BB85 68				PLA				; pop exponent
  3022 BB86 85 73			STA	FAC2_e			; save FAC2 exponent
  3023 BB88 68				PLA				; pop mantissa1
  3024 BB89 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3025 BB8B 68				PLA				; pop mantissa2
  3026 BB8C 85 75			STA	FAC2_2			; save FAC2 mantissa2
  3027 BB8E 68				PLA				; pop mantissa3
  3028 BB8F 85 76			STA	FAC2_3			; save FAC2 mantissa3
  3029 BB91 68				PLA				; pop sign
  3030 BB92 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  3031 BB94 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  3032 BB96 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  3033 BB98			LAB_1B9D
  3034 BB98 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3035 BB9A 60				RTS
  3036
  3037 				; print '...' string to string util area
  3038 BB9B			LAB_1BC1
  3039 BB9B A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  3040 BB9D A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  3041 BB9F 69 00			ADC	#$00			; add carry to low byte
  3042 BBA1 90 01			BCC	LAB_1BCA		; branch if no overflow
  3043
  3044 BBA3 C8				INY				; increment high byte
  3045 BBA4			LAB_1BCA
  3046 BBA4 20 2F C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  3047 BBA7 4C BC C4			JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  3048
  3049 				; get value from line
  3050 BBAA			LAB_GVAL
  3051 BBAA 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3052 BBAD B0 03			BCS	LAB_1BAC		; branch if not numeric character
  3053
  3054 									; else numeric string found (e.g. 123)
  3055 BBAF			LAB_1BA9
  3056 BBAF 4C 93 C9			JMP	LAB_2887		; get FAC1 from string and return
  3057
  3058 				; get value from line .. continued
  3059 									; wasn't a number so ..
  3060 BBB2			LAB_1BAC
  3061 BBB2 AA				TAX				; set the flags
  3062 BBB3 30 2F			BMI	LAB_1BD0		; if -ve go test token values
  3063
  3064 									; else it is either a string, number, variable or (<expr>)
  3065 BBB5 C9 24			CMP	#'$'			; compare with '$'
  3066 BBB7 F0 F6			BEQ	LAB_1BA9		; branch if '$', hex number
  3067
  3068 BBB9 C9 25			CMP	#'%'			; else compare with '%'
  3069 BBBB F0 F2			BEQ	LAB_1BA9		; branch if '%', binary number
  3070
  3071 BBBD C9 2E			CMP	#'.'			; compare with '.'
  3072 BBBF F0 EE			BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  3073
  3074 									; it wasn't any sort of number so ..
  3075 BBC1 C9 22			CMP	#$22			; compare with '
  3076 BBC3 F0 D6			BEQ	LAB_1BC1		; branch if open quote
  3077
  3078 									; wasn't any sort of number so ..
  3079
  3080 				; evaluate expression within parentheses
  3081 BBC5 C9 28			CMP	#'('			; compare with '('
  3082 BBC7 D0 4F			BNE	LAB_1C18		; if not '(' get (var), return value in FAC1 and $ flag
  3083
  3084 BBC9			LAB_1BF7
  3085 BBC9 20 C6 BA			JSR	LAB_EVEZ		; evaluate expression, no decrement
  3086
  3087 				; all the 'scan for' routines return the character after the sought character
  3088
  3089 				; scan for ')' , else do syntax error then warm start
  3090 BBCC			LAB_1BFB
  3091 BBCC A9 29			LDA	#$29			; load A with ')'
  3092
  3093 				; scan for CHR$(A) , else do syntax error then warm start
  3094 BBCE			LAB_SCCA
  3095 BBCE A0 00			LDY	#$00			; clear index
  3096 BBD0 D1 83			CMP	(Bpntrl),Y		; check next byte is = A
  3097 BBD2 D0 0B			BNE	LAB_SNER		; if not do syntax error then warm start
  3098
  3099 BBD4 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then return
  3100
  3101 				; scan for '(' , else do syntax error then warm start
  3102 BBD7			LAB_1BFE
  3103 BBD7 A9 28			LDA	#$28			; load A with '('
  3104 BBD9 D0 F3			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3105 									; (branch always)
  3106
  3107 				; scan for ',' , else do syntax error then warm start
  3108 BBDB			LAB_1C01
  3109 BBDB A9 2C			LDA	#$2C			; load A with ','
  3110 BBDD D0 EF			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3111 									; (branch always)
  3112
  3113 				; syntax error then warm start
  3114 BBDF			LAB_SNER
  3115 BBDF A2 02			LDX	#$02			; error code $02 ('Syntax' error)
  3116 BBE1 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3117
  3118 				; get value from line .. continued
  3119 				; do tokens
  3120 BBE4			LAB_1BD0
  3121 BBE4 C9 CC			CMP	#TK_MINUS		; compare with token for -
  3122 BBE6 F0 29			BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  3123
  3124 									; wasn't -n so ..
  3125 BBE8 C9 CB			CMP	#TK_PLUS		; compare with token for +
  3126 BBEA F0 BE			BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  3127
  3128 BBEC C9 C6			CMP	#TK_NOT		; compare with token for NOT
  3129 BBEE D0 13			BNE	LAB_1BE7		; branch if not token for NOT
  3130
  3131 									; was NOT token
  3132 = 000C			TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
  3133 BBF0 A0 24			LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  3134 BBF2 D0 1F			BNE	LAB_1C13		; do set-up for function then execute (branch always)
  3135
  3136 				; do = compare
  3137 BBF4			LAB_EQUAL
  3138 BBF4 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3139 BBF7 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3140 BBF9 49 FF			EOR	#$FF			; invert it
  3141 BBFB A8				TAY				; copy it
  3142 BBFC A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3143 BBFE 49 FF			EOR	#$FF			; invert it
  3144 BC00 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3145
  3146 				; get value from line .. continued
  3147 									; wasn't +, -, or NOT so ..
  3148 BC03			LAB_1BE7
  3149 BC03 C9 C3			CMP	#TK_FN			; compare with token for FN
  3150 BC05 D0 03			BNE	LAB_1BEE		; branch if not token for FN
  3151
  3152 BC07 4C 9F C0			JMP	LAB_201E		; go evaluate FNx
  3153
  3154 				; get value from line .. continued
  3155 									; wasn't +, -, NOT or FN so ..
  3156 BC0A			LAB_1BEE
  3157 BC0A E9 D9			SBC	#TK_SGN			; subtract with token for SGN
  3158 BC0C B0 1B			BCS	LAB_1C27		; if a function token go do it
  3159
  3160 BC0E 4C DF BB			JMP	LAB_SNER		; else do syntax error
  3161
  3162 				; set-up for functions
  3163 BC11			LAB_1C11
  3164 = 000B			TK_GT_PLUS	= TK_GT-TK_PLUS
  3165 BC11 A0 21			LDY	#TK_GT_PLUS*3		; set offset from base to > operator
  3166 BC13			LAB_1C13
  3167 BC13 68				PLA				; dump return address low byte
  3168 BC14 68				PLA				; dump return address high byte
  3169 BC15 4C 17 BB			JMP	LAB_1B1D		; execute function then continue evaluation
  3170
  3171 				; variable name set-up
  3172 				; get (var), return value in FAC_1 and $ flag
  3173 BC18			LAB_1C18
  3174 BC18 20 89 BD			JSR	LAB_GVAR		; get (var) address
  3175 BC1B 85 6E			STA	FAC1_2			; save address low byte in FAC1 mantissa2
  3176 BC1D 84 6F			STY	FAC1_3			; save address high byte in FAC1 mantissa3
  3177 BC1F A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  3178 BC21 30 03			BMI	LAB_1C25		; if string then return (does RTS)
  3179
  3180 BC23			LAB_1C24
  3181 BC23 4C 6A C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  3182
  3183 BC26			LAB_1C25	; patch string pointer high byte trashed when moved to stack
  3184 BC26 46 79			LSR   	FAC1_r            	; clear bit 7 (<$80) = do not round up
  3185 BC28 60				RTS
  3186
  3187 				; get value from line .. continued
  3188 				; only functions left so ..
  3189
  3190 				; set up function references
  3191
  3192 				; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3193 				; to process function calls. now the function vector is computed and pushed on the stack
  3194 				; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3195 				; is calculated and the routine called, if not this routine just does RTS. whichever
  3196 				; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3197 				; the function code
  3198
  3199 				; this also removes some less than elegant code that was used to bypass type checking
  3200 				; for functions that returned strings
  3201 BC29			LAB_1C27
  3202 BC29 0A				ASL				; *2 (2 bytes per function address)
  3203 BC2A A8				TAY				; copy to index
  3204
  3205 BC2B B9 EA D4			LDA	LAB_FTBM,Y		; get function jump vector high byte
  3206 BC2E 48				PHA				; push functions jump vector high byte
  3207 BC2F B9 E9 D4			LDA	LAB_FTBL,Y		; get function jump vector low byte
  3208 BC32 48				PHA				; push functions jump vector low byte
  3209
  3210 BC33 B9 9C D4			LDA	LAB_FTPM,Y		; get function pre process vector high byte
  3211 BC36 F0 05			BEQ	LAB_1C56		; skip pre process if null vector
  3212
  3213 BC38 48				PHA				; push functions pre process vector high byte
  3214 BC39 B9 9B D4			LDA	LAB_FTPL,Y		; get function pre process vector low byte
  3215 BC3C 48				PHA				; push functions pre process vector low byte
  3216
  3217 BC3D			LAB_1C56
  3218 BC3D 60				RTS				; do function, or pre process, call
  3219
  3220 				; process string expression in parenthesis
  3221 BC3E			LAB_PPFS
  3222 BC3E 20 C9 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3223 BC41 4C AF BA			JMP	LAB_CTST		; check if source is string then do function,
  3224 									; else do type mismatch
  3225
  3226 				; process numeric expression in parenthesis
  3227 BC44			LAB_PPFN
  3228 BC44 20 C9 BB			JSR	LAB_1BF7		; process expression in parenthesis
  3229 BC47 4C AD BA			JMP	LAB_CTNM		; check if source is numeric then do function,
  3230 									; else do type mismatch
  3231
  3232 				; set numeric data type and increment BASIC execute pointer
  3233 BC4A			LAB_PPBI
  3234 BC4A 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3235 BC4C 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then do function
  3236
  3237 				; process string for LEFT$, RIGHT$ or MID$
  3238 BC4F			LAB_LRMS
  3239 BC4F 20 C6 BA			JSR	LAB_EVEZ		; evaluate (should be string) expression
  3240 BC52 20 DB BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3241 BC55 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  3242
  3243 BC58 68				PLA				; get function jump vector low byte
  3244 BC59 AA				TAX				; save functions jump vector low byte
  3245 BC5A 68				PLA				; get function jump vector high byte
  3246 BC5B A8				TAY				; save functions jump vector high byte
  3247 BC5C A5 6F			LDA	des_ph			; get descriptor pointer high byte
  3248 BC5E 48				PHA				; push string pointer high byte
  3249 BC5F A5 6E			LDA	des_pl			; get descriptor pointer low byte
  3250 BC61 48				PHA				; push string pointer low byte
  3251 BC62 98				TYA				; get function jump vector high byte back
  3252 BC63 48				PHA				; save functions jump vector high byte
  3253 BC64 8A				TXA				; get function jump vector low byte back
  3254 BC65 48				PHA				; save functions jump vector low byte
  3255 BC66 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  3256 BC69 8A				TXA				; copy byte parameter to A
  3257 BC6A 60				RTS				; go do function
  3258
  3259 				; process numeric expression(s) for BIN$ or HEX$
  3260 BC6B			LAB_BHSS
  3261 BC6B 20 C6 BA			JSR	LAB_EVEZ		; process expression
  3262 BC6E 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3263 BC71 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3264 BC73 C9 98			CMP	#$98			; compare with exponent = 2^24
  3265 BC75 B0 20			BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  3266
  3267 BC77 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  3268 BC7A A2 02			LDX	#$02			; 3 bytes to do
  3269 BC7C			LAB_CFAC
  3270 BC7C B5 6D			LDA	FAC1_1,X		; get byte from FAC1
  3271 BC7E 95 11			STA	nums_1,X		; save byte to temp
  3272 BC80 CA				DEX				; decrement index
  3273 BC81 10 F9			BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  3274
  3275 BC83 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  3276 BC86 A2 00			LDX	#$00			; set default to no leading '0's
  3277 BC88 C9 29			CMP	#')'			; compare with close bracket
  3278 BC8A F0 0A			BEQ	LAB_1C54		; if ')' go do rest of function
  3279
  3280 BC8C 20 CB C4			JSR	LAB_SCGB		; scan for ',' and get byte
  3281 BC8F 20 82 00			JSR	LAB_GBYT		; get last byte back
  3282 BC92 C9 29			CMP	#')'			; is next character )
  3283 BC94 D0 01			BNE	LAB_BHER		; if not ')' go do error
  3284
  3285 BC96			LAB_1C54
  3286 BC96 60				RTS				; else do function
  3287
  3288 BC97			LAB_BHER
  3289 BC97 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  3290
  3291 				; perform EOR
  3292
  3293 				; added operator format is the same as AND or OR, precedence is the same as OR
  3294
  3295 				; this bit worked first time but it took a while to sort out the operator table
  3296 				; pointers and offsets afterwards!
  3297 BC9A			LAB_EOR
  3298 BC9A 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3299 BC9D 45 1B			EOR	XOAw_l			; EOR with expression 1 low byte
  3300 BC9F A8				TAY				; save in Y
  3301 BCA0 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3302 BCA2 45 1C			EOR	XOAw_h			; EOR with expression 1 high byte
  3303 BCA4 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3304
  3305 				; perform OR
  3306 BCA7			LAB_OR
  3307 BCA7 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3308 BCAA 05 1B			ORA	XOAw_l			; OR with expression 1 low byte
  3309 BCAC A8				TAY				; save in Y
  3310 BCAD A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3311 BCAF 05 1C			ORA	XOAw_h			; OR with expression 1 high byte
  3312 BCB1 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3313
  3314 				; perform AND
  3315 BCB4			LAB_AND
  3316 BCB4 20 C1 BC			JSR	GetFirst		; get first integer expression (no sign check)
  3317 BCB7 25 1B			AND	XOAw_l			; AND with expression 1 low byte
  3318 BCB9 A8				TAY				; save in Y
  3319 BCBA A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3320 BCBC 25 1C			AND	XOAw_h			; AND with expression 1 high byte
  3321 BCBE 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3322
  3323 				; get first value for OR, AND or EOR
  3324 BCC1			GetFirst
  3325 BCC1 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3326 BCC4 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3327 BCC6 85 1C			STA	XOAw_h			; save it
  3328 BCC8 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3329 BCCA 85 1B			STA	XOAw_l			; save it
  3330 BCCC 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3331 BCCF 20 85 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3332 BCD2 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3333 BCD4			LAB_1C95
  3334 BCD4 60				RTS
  3335
  3336 				; perform comparisons
  3337
  3338 				; do < compare
  3339 BCD5			LAB_LTHAN
  3340 BCD5 20 B0 BA			JSR	LAB_CKTM		; type match check, set C for string
  3341 BCD8 B0 13			BCS	LAB_1CAE		; branch if string
  3342 									; do numeric < compare
  3343 BCDA A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  3344 BCDC 09 7F			ORA	#$7F			; set all non sign bits
  3345 BCDE 25 74			AND	FAC2_1			; and FAC2 mantissa1 (AND in sign bit)
  3346 BCE0 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3347 BCE2 A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  3348 BCE4 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  3349 BCE6 20 04 C9			JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3350 BCE9 AA				TAX				; copy result
  3351 BCEA 4C 1E BD			JMP	LAB_1CE1		; go evaluate result
  3352 									; do string < compare
  3353 BCED			LAB_1CAE
  3354 BCED 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3355 BCEF C6 5B			DEC	comp_f			; clear < bit in compare function flag
  3356 BCF1 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3357 									; space returns with A = length, X=pointer low byte,
  3358 									; Y=pointer high byte
  3359 BCF4 85 6C			STA	str_ln			; save length
  3360 BCF6 86 6D			STX	str_pl			; save string pointer low byte
  3361 BCF8 84 6E			STY	str_ph			; save string pointer high byte
  3362 BCFA A5 75			LDA	FAC2_2			; get descriptor pointer low byte
  3363 BCFC A4 76			LDY	FAC2_3			; get descriptor pointer high byte
  3364 BCFE 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3365 									; returns with A = length, X=pointer low byte,
  3366 									; Y=pointer high byte
  3367 BD01 86 75			STX	FAC2_2			; save string pointer low byte
  3368 BD03 84 76			STY	FAC2_3			; save string pointer high byte
  3369 BD05 AA				TAX				; copy length
  3370 BD06 38				SEC				; set carry for subtract
  3371 BD07 E5 6C			SBC	str_ln			; subtract string 1 length
  3372 BD09 F0 08			BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3373
  3374 BD0B A9 01			LDA	#$01			; set str 1 length > string 2 length
  3375 BD0D 90 04			BCC	LAB_1CD6		; branch if so
  3376
  3377 BD0F A6 6C			LDX	str_ln			; get string 1 length
  3378 BD11 A9 FF			LDA	#$FF			; set str 1 length < string 2 length
  3379 BD13			LAB_1CD6
  3380 BD13 85 70			STA	FAC1_s			; save length compare
  3381 BD15 A0 FF			LDY	#$FF			; set index
  3382 BD17 E8				INX				; adjust for loop
  3383 BD18			LAB_1CDB
  3384 BD18 C8				INY				; increment index
  3385 BD19 CA				DEX				; decrement count
  3386 BD1A D0 07			BNE	LAB_1CE6		; branch if still bytes to do
  3387
  3388 BD1C A6 70			LDX	FAC1_s			; get length compare back
  3389 BD1E			LAB_1CE1
  3390 BD1E 30 0F			BMI	LAB_1CF2		; branch if str 1 < str 2
  3391
  3392 BD20 18				CLC				; flag str 1 <= str 2
  3393 BD21 90 0C			BCC	LAB_1CF2		; go evaluate result
  3394
  3395 BD23			LAB_1CE6
  3396 BD23 B1 75			LDA	(FAC2_2),Y		; get string 2 byte
  3397 BD25 D1 6D			CMP	(FAC1_1),Y		; compare with string 1 byte
  3398 BD27 F0 EF			BEQ	LAB_1CDB		; loop if bytes =
  3399
  3400 BD29 A2 FF			LDX	#$FF			; set str 1 < string 2
  3401 BD2B B0 02			BCS	LAB_1CF2		; branch if so
  3402
  3403 BD2D A2 01			LDX	#$01			;  set str 1 > string 2
  3404 BD2F			LAB_1CF2
  3405 BD2F E8				INX				; x = 0, 1 or 2
  3406 BD30 8A				TXA				; copy to A
  3407 BD31 2A				ROL				; *2 (1, 2 or 4)
  3408 BD32 25 23			AND	Cflag			; AND with comparison evaluation flag
  3409 BD34 F0 02			BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3410
  3411 BD36 A9 FF			LDA	#$FF			; else set result true
  3412 BD38			LAB_1CFB
  3413 BD38 4C E7 C8			JMP	LAB_27DB		; save A as integer byte and return
  3414
  3415 BD3B			LAB_1CFE
  3416 BD3B 20 DB BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3417
  3418 				; perform DIM
  3419 BD3E			LAB_DIM
  3420 BD3E AA				TAX				; copy 'DIM' flag to X
  3421 BD3F 20 8E BD			JSR	LAB_1D10		; search for variable
  3422 BD42 20 82 00			JSR	LAB_GBYT		; scan memory
  3423 BD45 D0 F4			BNE	LAB_1CFE		; scan for ',' and loop if not null
  3424
  3425 BD47 60				RTS
  3426
  3427 				; perform << (left shift)
  3428 BD48			LAB_LSHIFT
  3429 BD48 20 7E BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3430 BD4B A5 6E			LDA	FAC1_2			; get expression high byte
  3431 BD4D A6 38			LDX	TempB			; get shift count
  3432 BD4F F0 22			BEQ	NoShift			; branch if zero
  3433
  3434 BD51 E0 10			CPX	#$10			; compare bit count with 16d
  3435 BD53 B0 23			BCS	TooBig			; branch if >=
  3436
  3437 BD55			Ls_loop
  3438 BD55 06 6F			ASL	FAC1_3			; shift low byte
  3439 BD57 2A				ROL				; shift high byte
  3440 BD58 CA				DEX				; decrement bit count
  3441 BD59 D0 FA			BNE	Ls_loop			; loop if shift not complete
  3442
  3443 BD5B A4 6F			LDY	FAC1_3			; get expression low byte
  3444 BD5D 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3445
  3446 				; perform >> (right shift)
  3447 BD60			LAB_RSHIFT
  3448 BD60 20 7E BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3449 BD63 A5 6E			LDA	FAC1_2			; get expression high byte
  3450 BD65 A6 38			LDX	TempB			; get shift count
  3451 BD67 F0 0A			BEQ	NoShift			; branch if zero
  3452
  3453 BD69 E0 10			CPX	#$10			; compare bit count with 16d
  3454 BD6B B0 0B			BCS	TooBig			; branch if >=
  3455
  3456 BD6D			Rs_loop
  3457 BD6D 4A				LSR				; shift high byte
  3458 BD6E 66 6F			ROR	FAC1_3			; shift low byte
  3459 BD70 CA				DEX				; decrement bit count
  3460 BD71 D0 FA			BNE	Rs_loop			; loop if shift not complete
  3461
  3462 BD73			NoShift
  3463 BD73 A4 6F			LDY	FAC1_3			; get expression low byte
  3464 BD75 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3465
  3466 BD78			TooBig
  3467 BD78 A9 00			LDA	#$00			; clear high byte
  3468 BD7A A8				TAY				; copy to low byte
  3469 BD7B 4C 44 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3470
  3471 BD7E			GetPair
  3472 BD7E 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  3473 BD81 86 38			STX	TempB			; save it
  3474 BD83 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3475 BD86 4C 85 BE			JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3476
  3477 				; search for variable
  3478
  3479 				; return pointer to variable in Cvaral/Cvarah
  3480 BD89			LAB_GVAR
  3481 BD89 A2 00			LDX	#$00			; set DIM flag = $00
  3482 BD8B 20 82 00			JSR	LAB_GBYT		; scan memory (1st character)
  3483 BD8E			LAB_1D10
  3484 BD8E 86 1E			STX	Defdim			; save DIM flag
  3485 BD90			LAB_1D12
  3486 BD90 85 53			STA	Varnm1			; save 1st character
  3487 BD92 29 7F			AND	#$7F			; clear FN flag bit
  3488 BD94 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3489 BD97 B0 03			BCS	LAB_1D1F		; branch if ok
  3490
  3491 BD99 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  3492
  3493 									; was variable name so ..
  3494 BD9C			LAB_1D1F
  3495 BD9C A2 00			LDX	#$00			; clear 2nd character temp
  3496 BD9E 86 1F			STX	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3497 BDA0 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (2nd character)
  3498 BDA3 90 05			BCC	LAB_1D2D		; branch if character = '0'-'9' (ok)
  3499
  3500 									; 2nd character wasn't '0' to '9' so ..
  3501 BDA5 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3502 BDA8 90 0B			BCC	LAB_1D38		; branch if <'A' or >'Z' (go check if string)
  3503
  3504 BDAA			LAB_1D2D
  3505 BDAA AA				TAX				; copy 2nd character
  3506
  3507 									; ignore further (valid) characters in the variable name
  3508 BDAB			LAB_1D2E
  3509 BDAB 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (3rd character)
  3510 BDAE 90 FB			BCC	LAB_1D2E		; loop if character = '0'-'9' (ignore)
  3511
  3512 BDB0 20 FD BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3513 BDB3 B0 F6			BCS	LAB_1D2E		; loop if character = 'A'-'Z' (ignore)
  3514
  3515 									; check if string variable
  3516 BDB5			LAB_1D38
  3517 BDB5 C9 24			CMP	#'$'			; compare with '$'
  3518 BDB7 D0 0B			BNE	LAB_1D47		; branch if not string
  3519
  3520 				; to introduce a new variable type (% suffix for integers say) then this branch
  3521 				; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3522 									; type is string
  3523 BDB9 A9 FF			LDA	#$FF			; set data type = string
  3524 BDBB 85 1F			STA	Dtypef			; set data type flag, $FF=string, $00=numeric
  3525 BDBD 8A				TXA				; get 2nd character back
  3526 BDBE 09 80			ORA	#$80			; set top bit (indicate string var)
  3527 BDC0 AA				TAX				; copy back to 2nd character temp
  3528 BDC1 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3529
  3530 				; after we have determined the variable type we need to come back here to determine
  3531 				; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3532 BDC4			LAB_1D47				; gets here with character after var name in A
  3533 BDC4 86 54			STX	Varnm2			; save 2nd character
  3534 BDC6 05 21			ORA	Sufnxf			; or with subscript/FNX flag (or FN name)
  3535 BDC8 C9 28			CMP	#'('			; compare with '('
  3536 BDCA D0 03			BNE	LAB_1D53		; branch if not '('
  3537
  3538 BDCC 4C 97 BE			JMP	LAB_1E17		; go find, or make, array
  3539
  3540 				; either find or create var
  3541 				; var name (1st two characters only!) is in Varnm1,Varnm2
  3542 									; variable name wasn't var(... so look for plain var
  3543 BDCF			LAB_1D53
  3544 BDCF A9 00			LDA	#$00			; clear A
  3545 BDD1 85 21			STA	Sufnxf			; clear subscript/FNX flag
  3546 BDD3 A5 3B			LDA	Svarl			; get start of vars low byte
  3547 BDD5 A6 3C			LDX	Svarh			; get start of vars high byte
  3548 BDD7 A0 00			LDY	#$00			; clear index
  3549 BDD9			LAB_1D5D
  3550 BDD9 86 6B			STX	Vrschh			; save search address high byte
  3551 BDDB			LAB_1D5F
  3552 BDDB 85 6A			STA	Vrschl			; save search address low byte
  3553 BDDD E4 3E			CPX	Sarryh			; compare high address with var space end
  3554 BDDF D0 04			BNE	LAB_1D69		; skip next compare if <>
  3555
  3556 									; high addresses were = so compare low addresses
  3557 BDE1 C5 3D			CMP	Sarryl			; compare low address with var space end
  3558 BDE3 F0 2C			BEQ	LAB_1D8B		; if not found go make new var
  3559
  3560 BDE5			LAB_1D69
  3561 BDE5 A5 53			LDA	Varnm1			; get 1st character of var to find
  3562 BDE7 D1 6A			CMP	(Vrschl),Y		; compare with variable name 1st character
  3563 BDE9 D0 08			BNE	LAB_1D77		; branch if no match
  3564
  3565 									; 1st characters match so compare 2nd characters
  3566 BDEB A5 54			LDA	Varnm2			; get 2nd character of var to find
  3567 BDED C8				INY				; index to point to variable name 2nd character
  3568 BDEE D1 6A			CMP	(Vrschl),Y		; compare with variable name 2nd character
  3569 BDF0 F0 69			BEQ	LAB_1DD7		; branch if match (found var)
  3570
  3571 BDF2 88				DEY				; else decrement index (now = $00)
  3572 BDF3			LAB_1D77
  3573 BDF3 18				CLC				; clear carry for add
  3574 BDF4 A5 6A			LDA	Vrschl			; get search address low byte
  3575 BDF6 69 06			ADC	#$06			; +6 (offset to next var name)
  3576 BDF8 90 E1			BCC	LAB_1D5F		; loop if no overflow to high byte
  3577
  3578 BDFA E8				INX				; else increment high byte
  3579 BDFB D0 DC			BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3580
  3581 				; check byte, return C=0 if<'A' or >'Z' or 'a' to 'z'
  3582 BDFD			LAB_CASC
  3583 BDFD C9 61			CMP	#'a'			; compare with 'a'
  3584 BDFF B0 0A			BCS	LAB_1D83		; go check <'z'+1
  3585
  3586 				; check byte, return C=0 if<'A' or >'Z'
  3587 BE01			LAB_1D82
  3588 BE01 C9 41			CMP	#'A'			; compare with 'A'
  3589 BE03 90 05			BCC	LAB_1D8A		; exit if less
  3590
  3591 									; carry is set
  3592 BE05 E9 5B			SBC	#$5B			; subtract 'Z'+1
  3593 BE07 38				SEC				; set carry
  3594 BE08 E9 A5			SBC	#$A5			; subtract $A5 (restore byte)
  3595 									; carry clear if byte>$5A
  3596 BE0A			LAB_1D8A
  3597 BE0A 60				RTS
  3598
  3599 BE0B			LAB_1D83
  3600 BE0B E9 7B			SBC	#$7B			; subtract 'z'+1
  3601 BE0D 38				SEC				; set carry
  3602 BE0E E9 85			SBC	#$85			; subtract $85 (restore byte)
  3603 									; carry clear if byte>$7A
  3604 BE10 60				RTS
  3605
  3606 									; reached end of variable mem without match
  3607 									; .. so create new variable
  3608 BE11			LAB_1D8B
  3609 BE11 68				PLA				; pop return address low byte
  3610 BE12 48				PHA				; push return address low byte
  3611 = BC1A			LAB_1C18p2	= LAB_1C18+2
  3612 BE13 C9 1A			CMP	#<LAB_1C18p2		; compare with expected calling routine return low byte
  3613 BE15 D0 05			BNE	LAB_1D98		; if not get (var) go create new var
  3614
  3615 				; This will only drop through if the call was from LAB_1C18 and is only called
  3616 				; from there if it is searching for a variable from the RHS of a LET a=b statement
  3617 				; it prevents the creation of variables not assigned a value.
  3618
  3619 				; value returned by this is either numeric zero (exponent byte is $00) or null string
  3620 				; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3621
  3622 				; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3623
  3624 				; this is where you would put the undefined variable error call e.g.
  3625
  3626 				;					; variable doesn't exist so flag error
  3627 				;	LDX	#$24			; error code $24 ('undefined variable' error)
  3628 				;	JMP	LAB_XERR		; do error #X then warm start
  3629
  3630 				; the above code has been tested and works a treat! (it replaces the three code lines
  3631 				; below)
  3632 									; else return dummy null value
  3633 BE17 A9 F5			LDA	#<LAB_1D96		; low byte point to $00,$00
  3634 									; (uses part of misc constants table)
  3635 BE19 A0 D3			LDY	#>LAB_1D96		; high byte point to $00,$00
  3636 BE1B 60				RTS
  3637
  3638 				; create new numeric variable
  3639 BE1C			LAB_1D98
  3640 BE1C A5 3D			LDA	Sarryl			; get var mem end low byte
  3641 BE1E A4 3E			LDY	Sarryh			; get var mem end high byte
  3642 BE20 85 6A			STA	Ostrtl			; save old block start low byte
  3643 BE22 84 6B			STY	Ostrth			; save old block start high byte
  3644 BE24 A5 3F			LDA	Earryl			; get array mem end low byte
  3645 BE26 A4 40			LDY	Earryh			; get array mem end high byte
  3646 BE28 85 66			STA	Obendl			; save old block end low byte
  3647 BE2A 84 67			STY	Obendh			; save old block end high byte
  3648 BE2C 18				CLC				; clear carry for add
  3649 BE2D 69 06			ADC	#$06			; +6 (space for one var)
  3650 BE2F 90 01			BCC	LAB_1DAE		; branch if no overflow to high byte
  3651
  3652 BE31 C8				INY				; else increment high byte
  3653 BE32			LAB_1DAE
  3654 BE32 85 64			STA	Nbendl			; set new block end low byte
  3655 BE34 84 65			STY	Nbendh			; set new block end high byte
  3656 BE36 20 8D B0			JSR	LAB_11CF		; open up space in memory
  3657 BE39 A5 64			LDA	Nbendl			; get new start low byte
  3658 BE3B A4 65			LDY	Nbendh			; get new start high byte (-$100)
  3659 BE3D C8				INY				; correct high byte
  3660 BE3E 85 3D			STA	Sarryl			; save new var mem end low byte
  3661 BE40 84 3E			STY	Sarryh			; save new var mem end high byte
  3662 BE42 A0 00			LDY	#$00			; clear index
  3663 BE44 A5 53			LDA	Varnm1			; get var name 1st character
  3664 BE46 91 6A			STA	(Vrschl),Y		; save var name 1st character
  3665 BE48 C8				INY				; increment index
  3666 BE49 A5 54			LDA	Varnm2			; get var name 2nd character
  3667 BE4B 91 6A			STA	(Vrschl),Y		; save var name 2nd character
  3668 BE4D A9 00			LDA	#$00			; clear A
  3669 BE4F C8				INY				; increment index
  3670 BE50 91 6A			STA	(Vrschl),Y		; initialise var byte
  3671 BE52 C8				INY				; increment index
  3672 BE53 91 6A			STA	(Vrschl),Y		; initialise var byte
  3673 BE55 C8				INY				; increment index
  3674 BE56 91 6A			STA	(Vrschl),Y		; initialise var byte
  3675 BE58 C8				INY				; increment index
  3676 BE59 91 6A			STA	(Vrschl),Y		; initialise var byte
  3677
  3678 									; found a match for var ((Vrschl) = ptr)
  3679 BE5B			LAB_1DD7
  3680 BE5B A5 6A			LDA	Vrschl			; get var address low byte
  3681 BE5D 18				CLC				; clear carry for add
  3682 BE5E 69 02			ADC	#$02			; +2 (offset past var name bytes)
  3683 BE60 A4 6B			LDY	Vrschh			; get var address high byte
  3684 BE62 90 01			BCC	LAB_1DE1		; branch if no overflow from add
  3685
  3686 BE64 C8				INY				; else increment high byte
  3687 BE65			LAB_1DE1
  3688 BE65 85 55			STA	Cvaral			; save current var address low byte
  3689 BE67 84 56			STY	Cvarah			; save current var address high byte
  3690 BE69 60				RTS
  3691
  3692 				; set-up array pointer (Adatal/h) to first element in array
  3693 				; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3694 BE6A			LAB_1DE6
  3695 BE6A A5 1D			LDA	Dimcnt			; get # of dimensions (1, 2 or 3)
  3696 BE6C 0A				ASL				; *2 (also clears the carry !)
  3697 BE6D 69 05			ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3698 BE6F 65 6A			ADC	Astrtl			; add array start pointer low byte
  3699 BE71 A4 6B			LDY	Astrth			; get array pointer high byte
  3700 BE73 90 01			BCC	LAB_1DF2		; branch if no overflow
  3701
  3702 BE75 C8				INY				; else increment high byte
  3703 BE76			LAB_1DF2
  3704 BE76 85 64			STA	Adatal			; save array data pointer low byte
  3705 BE78 84 65			STY	Adatah			; save array data pointer high byte
  3706 BE7A 60				RTS
  3707
  3708 				; evaluate integer expression
  3709 BE7B			LAB_EVIN
  3710 BE7B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3711 BE7E 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3712 									; else do type mismatch
  3713
  3714 				; evaluate integer expression (no check)
  3715 BE81			LAB_EVPI
  3716 BE81 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  3717 BE83 30 0D			BMI	LAB_1E12		; do function call error if -ve
  3718
  3719 				; evaluate integer expression (no sign check)
  3720 BE85			LAB_EVIR
  3721 BE85 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3722 BE87 C9 90			CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3723 BE89 90 09			BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3724
  3725 BE8B A9 FC			LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3726 BE8D A0 D3			LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3727 BE8F 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  3728 BE92			LAB_1E12
  3729 BE92 D0 74			BNE	LAB_FCER		; if <> do function call error then warm start
  3730
  3731 BE94			LAB_1E14
  3732 BE94 4C 3D C9			JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  3733
  3734 				; find or make array
  3735 BE97			LAB_1E17
  3736 BE97 A5 1E			LDA	Defdim			; get DIM flag
  3737 BE99 48				PHA				; push it
  3738 BE9A A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  3739 BE9C 48				PHA				; push it
  3740 BE9D A0 00			LDY	#$00			; clear dimensions count
  3741
  3742 				; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3743 BE9F			LAB_1E1F
  3744 BE9F 98				TYA				; copy dimensions count
  3745 BEA0 48				PHA				; save it
  3746 BEA1 A5 54			LDA	Varnm2			; get array name 2nd byte
  3747 BEA3 48				PHA				; save it
  3748 BEA4 A5 53			LDA	Varnm1			; get array name 1st byte
  3749 BEA6 48				PHA				; save it
  3750 BEA7 20 7B BE			JSR	LAB_EVIN		; evaluate integer expression
  3751 BEAA 68				PLA				; pull array name 1st byte
  3752 BEAB 85 53			STA	Varnm1			; restore array name 1st byte
  3753 BEAD 68				PLA				; pull array name 2nd byte
  3754 BEAE 85 54			STA	Varnm2			; restore array name 2nd byte
  3755 BEB0 68				PLA				; pull dimensions count
  3756 BEB1 A8				TAY				; restore it
  3757 BEB2 BA				TSX				; copy stack pointer
  3758 BEB3 BD 02 01			LDA	LAB_STAK+2,X		; get DIM flag
  3759 BEB6 48				PHA				; push it
  3760 BEB7 BD 01 01			LDA	LAB_STAK+1,X		; get data type flag
  3761 BEBA 48				PHA				; push it
  3762 BEBB A5 6E			LDA	FAC1_2			; get this dimension size high byte
  3763 BEBD 9D 02 01			STA	LAB_STAK+2,X		; stack before flag bytes
  3764 BEC0 A5 6F			LDA	FAC1_3			; get this dimension size low byte
  3765 BEC2 9D 01 01			STA	LAB_STAK+1,X		; stack before flag bytes
  3766 BEC5 C8				INY				; increment dimensions count
  3767 BEC6 20 82 00			JSR	LAB_GBYT		; scan memory
  3768 BEC9 C9 2C			CMP	#','			; compare with ','
  3769 BECB F0 D2			BEQ	LAB_1E1F		; if found go do next dimension
  3770
  3771 BECD 84 1D			STY	Dimcnt			; store dimensions count
  3772 BECF 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  3773 BED2 68				PLA				; pull data type flag
  3774 BED3 85 1F			STA	Dtypef			; restore data type flag, $FF=string, $00=numeric
  3775 BED5 68				PLA				; pull DIM flag
  3776 BED6 85 1E			STA	Defdim			; restore DIM flag
  3777 BED8 A6 3D			LDX	Sarryl			; get array mem start low byte
  3778 BEDA A5 3E			LDA	Sarryh			; get array mem start high byte
  3779
  3780 				; now check to see if we are at the end of array memory (we would be if there were
  3781 				; no arrays).
  3782 BEDC			LAB_1E5C
  3783 BEDC 86 6A			STX	Astrtl			; save as array start pointer low byte
  3784 BEDE 85 6B			STA	Astrth			; save as array start pointer high byte
  3785 BEE0 C5 40			CMP	Earryh			; compare with array mem end high byte
  3786 BEE2 D0 04			BNE	LAB_1E68		; branch if not reached array mem end
  3787
  3788 BEE4 E4 3F			CPX	Earryl			; else compare with array mem end low byte
  3789 BEE6 F0 39			BEQ	LAB_1EA1		; go build array if not found
  3790
  3791 									; search for array
  3792 BEE8			LAB_1E68
  3793 BEE8 A0 00			LDY	#$00			; clear index
  3794 BEEA B1 6A			LDA	(Astrtl),Y		; get array name first byte
  3795 BEEC C8				INY				; increment index to second name byte
  3796 BEED C5 53			CMP	Varnm1			; compare with this array name first byte
  3797 BEEF D0 06			BNE	LAB_1E77		; branch if no match
  3798
  3799 BEF1 A5 54			LDA	Varnm2			; else get this array name second byte
  3800 BEF3 D1 6A			CMP	(Astrtl),Y		; compare with array name second byte
  3801 BEF5 F0 16			BEQ	LAB_1E8D		; array found so branch
  3802
  3803 									; no match
  3804 BEF7			LAB_1E77
  3805 BEF7 C8				INY				; increment index
  3806 BEF8 B1 6A			LDA	(Astrtl),Y		; get array size low byte
  3807 BEFA 18				CLC				; clear carry for add
  3808 BEFB 65 6A			ADC	Astrtl			; add array start pointer low byte
  3809 BEFD AA				TAX				; copy low byte to X
  3810 BEFE C8				INY				; increment index
  3811 BEFF B1 6A			LDA	(Astrtl),Y		; get array size high byte
  3812 BF01 65 6B			ADC	Astrth			; add array mem pointer high byte
  3813 BF03 90 D7			BCC	LAB_1E5C		; if no overflow go check next array
  3814
  3815 				; do array bounds error
  3816 BF05			LAB_1E85
  3817 BF05 A2 10			LDX	#$10			; error code $10 ('Array bounds' error)
  3818 BF07 2C				.byte	$2C			; makes next bit BIT LAB_08A2
  3819
  3820 				; do function call error
  3821 BF08			LAB_FCER
  3822 BF08 A2 08			LDX	#$08			; error code $08 ('Function call' error)
  3823 BF0A			LAB_1E8A
  3824 BF0A 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  3825
  3826 									; found array, are we trying to dimension it?
  3827 BF0D			LAB_1E8D
  3828 BF0D A2 12			LDX	#$12			; set error $12 ('Double dimension' error)
  3829 BF0F A5 1E			LDA	Defdim			; get DIM flag
  3830 BF11 D0 F7			BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3831 									; start
  3832
  3833 				; found the array and we're not dimensioning it so we must find an element in it
  3834 BF13 20 6A BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3835 									; (Astrtl,Astrth points to start of array)
  3836 BF16 A5 1D			LDA	Dimcnt			; get dimensions count
  3837 BF18 A0 04			LDY	#$04			; set index to array's # of dimensions
  3838 BF1A D1 6A			CMP	(Astrtl),Y		; compare with no of dimensions
  3839 BF1C D0 E7			BNE	LAB_1E85		; if wrong do array bounds error, could do 'Wrong
  3840 									; dimensions' error here .. if we want a different
  3841 									; error message
  3842
  3843 BF1E 4C A4 BF			JMP	LAB_1F28		; found array so go get element
  3844 									; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3845 									; Dimcnt and save it at (Astrtl),Y which is already the
  3846 									; same or we would have taken the BNE)
  3847
  3848 									; array not found, so build it
  3849 BF21			LAB_1EA1
  3850 BF21 20 6A BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3851 									; (Astrtl,Astrth points to start of array)
  3852 BF24 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3853 									; addr to check is in AY (low/high)
  3854 BF27 A0 00			LDY	#$00			; clear Y (don't need to clear A)
  3855 BF29 84 7B			STY	Aspth			; clear array data size high byte
  3856 BF2B A5 53			LDA	Varnm1			; get variable name 1st byte
  3857 BF2D 91 6A			STA	(Astrtl),Y		; save array name 1st byte
  3858 BF2F C8				INY				; increment index
  3859 BF30 A5 54			LDA	Varnm2			; get variable name 2nd byte
  3860 BF32 91 6A			STA	(Astrtl),Y		; save array name 2nd byte
  3861 BF34 A5 1D			LDA	Dimcnt			; get dimensions count
  3862 BF36 A0 04			LDY	#$04			; index to dimension count
  3863 BF38 84 7A			STY	Asptl			; set array data size low byte (four bytes per element)
  3864 BF3A 91 6A			STA	(Astrtl),Y		; set array's dimensions count
  3865
  3866 									; now calculate the size of the data space for the array
  3867 BF3C 18				CLC				; clear carry for add (clear on subsequent loops)
  3868 BF3D			LAB_1EC0
  3869 BF3D A2 0B			LDX	#$0B			; set default dimension value low byte
  3870 BF3F A9 00			LDA	#$00			; set default dimension value high byte
  3871 BF41 24 1E			BIT	Defdim			; test default DIM flag
  3872 BF43 50 07			BVC	LAB_1ED0		; branch if b6 of Defdim is clear
  3873
  3874 BF45 68				PLA				; else pull dimension value low byte
  3875 BF46 69 01			ADC	#$01			; +1 (allow for zeroeth element)
  3876 BF48 AA				TAX				; copy low byte to X
  3877 BF49 68				PLA				; pull dimension value high byte
  3878 BF4A 69 00			ADC	#$00			; add carry from low byte
  3879
  3880 BF4C			LAB_1ED0
  3881 BF4C C8				INY				; index to dimension value high byte
  3882 BF4D 91 6A			STA	(Astrtl),Y		; save dimension value high byte
  3883 BF4F C8				INY				; index to dimension value high byte
  3884 BF50 8A				TXA				; get dimension value low byte
  3885 BF51 91 6A			STA	(Astrtl),Y		; save dimension value low byte
  3886 BF53 20 F3 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3887 BF56 86 7A			STX	Asptl			; save array data size low byte
  3888 BF58 85 7B			STA	Aspth			; save array data size high byte
  3889 BF5A A4 31			LDY	ut1_pl			; restore index (saved by subroutine)
  3890 BF5C C6 1D			DEC	Dimcnt			; decrement dimensions count
  3891 BF5E D0 DD			BNE	LAB_1EC0		; loop while not = 0
  3892
  3893 BF60 65 65			ADC	Adatah			; add size high byte to first element high byte
  3894 									; (carry is always clear here)
  3895 BF62 B0 5D			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3896
  3897 BF64 85 65			STA	Adatah			; save end of array high byte
  3898 BF66 A8				TAY				; copy end high byte to Y
  3899 BF67 8A				TXA				; get array size low byte
  3900 BF68 65 64			ADC	Adatal			; add array start low byte
  3901 BF6A 90 03			BCC	LAB_1EF3		; branch if no carry
  3902
  3903 BF6C C8				INY				; else increment end of array high byte
  3904 BF6D F0 52			BEQ	LAB_1F45		; if overflow go do 'Out of memory' error
  3905
  3906 									; set-up mostly complete, now zero the array
  3907 BF6F			LAB_1EF3
  3908 BF6F 20 DA B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3909 									; addr to check is in AY (low/high)
  3910 BF72 85 3F			STA	Earryl			; save array mem end low byte
  3911 BF74 84 40			STY	Earryh			; save array mem end high byte
  3912 BF76 A9 00			LDA	#$00			; clear byte for array clear
  3913 BF78 E6 7B			INC	Aspth			; increment array size high byte (now block count)
  3914 BF7A A4 7A			LDY	Asptl			; get array size low byte (now index to block)
  3915 BF7C F0 05			BEQ	LAB_1F07		; branch if low byte = $00
  3916
  3917 BF7E			LAB_1F02
  3918 BF7E 88				DEY				; decrement index (do 0 to n-1)
  3919 BF7F 91 64			STA	(Adatal),Y		; zero byte
  3920 BF81 D0 FB			BNE	LAB_1F02		; loop until this block done
  3921
  3922 BF83			LAB_1F07
  3923 BF83 C6 65			DEC	Adatah			; decrement array pointer high byte
  3924 BF85 C6 7B			DEC	Aspth			; decrement block count high byte
  3925 BF87 D0 F5			BNE	LAB_1F02		; loop until all blocks done
  3926
  3927 BF89 E6 65			INC	Adatah			; correct for last loop
  3928 BF8B 38				SEC				; set carry for subtract
  3929 BF8C A0 02			LDY	#$02			; index to array size low byte
  3930 BF8E A5 3F			LDA	Earryl			; get array mem end low byte
  3931 BF90 E5 6A			SBC	Astrtl			; subtract array start low byte
  3932 BF92 91 6A			STA	(Astrtl),Y		; save array size low byte
  3933 BF94 C8				INY				; index to array size high byte
  3934 BF95 A5 40			LDA	Earryh			; get array mem end high byte
  3935 BF97 E5 6B			SBC	Astrth			; subtract array start high byte
  3936 BF99 91 6A			STA	(Astrtl),Y		; save array size high byte
  3937 BF9B A5 1E			LDA	Defdim			; get default DIM flag
  3938 BF9D D0 53			BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  3939
  3940 									; else, find element
  3941 BF9F C8				INY				; index to # of dimensions
  3942
  3943 BFA0			LAB_1F24
  3944 BFA0 B1 6A			LDA	(Astrtl),Y		; get array's dimension count
  3945 BFA2 85 1D			STA	Dimcnt			; save it
  3946
  3947 				; we have found, or built, the array. now we need to find the element
  3948 BFA4			LAB_1F28
  3949 BFA4 A9 00			LDA	#$00			; clear byte
  3950 BFA6 85 7A			STA	Asptl			; clear array data pointer low byte
  3951 BFA8			LAB_1F2C
  3952 BFA8 85 7B			STA	Aspth			; save array data pointer high byte
  3953 BFAA C8				INY				; increment index (point to array bound high byte)
  3954 BFAB 68				PLA				; pull array index low byte
  3955 BFAC AA				TAX				; copy to X
  3956 BFAD 85 6E			STA	FAC1_2			; save index low byte to FAC1 mantissa2
  3957 BFAF 68				PLA				; pull array index high byte
  3958 BFB0 85 6F			STA	FAC1_3			; save index high byte to FAC1 mantissa3
  3959 BFB2 D1 6A			CMP	(Astrtl),Y		; compare with array bound high byte
  3960 BFB4 90 0E			BCC	LAB_1F48		; branch if within bounds
  3961
  3962 BFB6 D0 06			BNE	LAB_1F42		; if outside bounds do array bounds error
  3963
  3964 									; else high byte was = so test low bytes
  3965 BFB8 C8				INY				; index to array bound low byte
  3966 BFB9 8A				TXA				; get array index low byte
  3967 BFBA D1 6A			CMP	(Astrtl),Y		; compare with array bound low byte
  3968 BFBC 90 07			BCC	LAB_1F49		; branch if within bounds
  3969
  3970 BFBE			LAB_1F42
  3971 BFBE 4C 05 BF			JMP	LAB_1E85		; else do array bounds error
  3972
  3973 BFC1			LAB_1F45
  3974 BFC1 4C 09 B1			JMP	LAB_OMER		; do 'Out of memory' error then warm start
  3975
  3976 BFC4			LAB_1F48
  3977 BFC4 C8				INY				; index to array bound low byte
  3978 BFC5			LAB_1F49
  3979 BFC5 A5 7B			LDA	Aspth			; get array data pointer high byte
  3980 BFC7 05 7A			ORA	Asptl			; OR with array data pointer low byte
  3981 BFC9 F0 0A			BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  3982
  3983 BFCB 20 F3 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3984 BFCE 8A				TXA				; get result low byte
  3985 BFCF 65 6E			ADC	FAC1_2			; add index low byte from FAC1 mantissa2
  3986 BFD1 AA				TAX				; save result low byte
  3987 BFD2 98				TYA				; get result high byte
  3988 BFD3 A4 31			LDY	ut1_pl			; restore index
  3989 BFD5			LAB_1F5A
  3990 BFD5 65 6F			ADC	FAC1_3			; add index high byte from FAC1 mantissa3
  3991 BFD7 86 7A			STX	Asptl			; save array data pointer low byte
  3992 BFD9 C6 1D			DEC	Dimcnt			; decrement dimensions count
  3993 BFDB D0 CB			BNE	LAB_1F2C		; loop if dimensions still to do
  3994
  3995 BFDD 06 7A			ASL	Asptl			; array data pointer low byte * 2
  3996 BFDF 2A				ROL				; array data pointer high byte * 2
  3997 BFE0 06 7A			ASL	Asptl			; array data pointer low byte * 4
  3998 BFE2 2A				ROL				; array data pointer high byte * 4
  3999 BFE3 A8				TAY				; copy high byte
  4000 BFE4 A5 7A			LDA	Asptl			; get low byte
  4001 BFE6 65 64			ADC	Adatal			; add array data start pointer low byte
  4002 BFE8 85 55			STA	Cvaral			; save as current var address low byte
  4003 BFEA 98				TYA				; get high byte back
  4004 BFEB 65 65			ADC	Adatah			; add array data start pointer high byte
  4005 BFED 85 56			STA	Cvarah			; save as current var address high byte
  4006 BFEF A8				TAY				; copy high byte to Y
  4007 BFF0 A5 55			LDA	Cvaral			; get current var address low byte
  4008 BFF2			LAB_1F7B
  4009 BFF2 60				RTS
  4010
  4011 				; does XY = (Astrtl),Y * (Asptl)
  4012 BFF3			LAB_1F7C
  4013 BFF3 84 31			STY	ut1_pl			; save index
  4014 BFF5 B1 6A			LDA	(Astrtl),Y		; get dimension size low byte
  4015 BFF7 85 36			STA	dims_l			; save dimension size low byte
  4016 BFF9 88				DEY				; decrement index
  4017 BFFA B1 6A			LDA	(Astrtl),Y		; get dimension size high byte
  4018 BFFC 85 37			STA	dims_h			; save dimension size high byte
  4019
  4020 BFFE A9 10			LDA	#$10			; count = $10 (16 bit multiply)
  4021 C000 85 68			STA	numbit			; save bit count
  4022 C002 A2 00			LDX	#$00			; clear result low byte
  4023 C004 A0 00			LDY	#$00			; clear result high byte
  4024 C006			LAB_1F8F
  4025 C006 8A				TXA				; get result low byte
  4026 C007 0A				ASL				; *2
  4027 C008 AA				TAX				; save result low byte
  4028 C009 98				TYA				; get result high byte
  4029 C00A 2A				ROL				; *2
  4030 C00B A8				TAY				; save result high byte
  4031 C00C B0 B3			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4032
  4033 C00E 06 7A			ASL	Asptl			; shift multiplier low byte
  4034 C010 26 7B			ROL	Aspth			; shift multiplier high byte
  4035 C012 90 0B			BCC	LAB_1FA8		; skip add if no carry
  4036
  4037 C014 18				CLC				; else clear carry for add
  4038 C015 8A				TXA				; get result low byte
  4039 C016 65 36			ADC	dims_l			; add dimension size low byte
  4040 C018 AA				TAX				; save result low byte
  4041 C019 98				TYA				; get result high byte
  4042 C01A 65 37			ADC	dims_h			; add dimension size high byte
  4043 C01C A8				TAY				; save result high byte
  4044 C01D B0 A2			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  4045
  4046 C01F			LAB_1FA8
  4047 C01F C6 68			DEC	numbit			; decrement bit count
  4048 C021 D0 E3			BNE	LAB_1F8F		; loop until all done
  4049
  4050 C023 60				RTS
  4051
  4052 				; perform FRE()
  4053 C024			LAB_FRE
  4054 C024 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  4055 C026 10 03			BPL	LAB_1FB4		; branch if numeric
  4056
  4057 C028 20 2B C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  4058 									; space returns with A = length, X=$71=pointer low byte,
  4059 									; Y=$72=pointer high byte
  4060
  4061 									; FRE(n) was numeric so do this
  4062 C02B			LAB_1FB4
  4063 C02B 20 CC C1			JSR	LAB_GARB		; go do garbage collection
  4064 C02E 38				SEC				; set carry for subtract
  4065 C02F A5 41			LDA	Sstorl			; get bottom of string space low byte
  4066 C031 E5 3F			SBC	Earryl			; subtract array mem end low byte
  4067 C033 A8				TAY				; copy result to Y
  4068 C034 A5 42			LDA	Sstorh			; get bottom of string space high byte
  4069 C036 E5 40			SBC	Earryh			; subtract array mem end high byte
  4070
  4071 				; save and convert unsigned integer AY to FAC1
  4072 C038			LAB_UAYFC
  4073 C038 46 1F			LSR	Dtypef            	; clear data type flag, $FF=string, $00=numeric
  4074 C03A 85 6D			STA	FAC1_1            	; save FAC1 mantissa1
  4075 C03C 84 6E			STY	FAC1_2            	; save FAC1 mantissa2
  4076 C03E A2 90			LDX	#$90              	; set exponent=2^16 (integer)
  4077 C040 38				SEC                     	; always positive
  4078 C041 4C F4 C8			JMP	LAB_STFA          	; set exp=X, clear FAC1_3, normalise and return 
  4079 				      
  4080 				; save and convert integer AY to FAC1
  4081 C044			LAB_AYFC
  4082 C044 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  4083 C046 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  4084 C048 84 6E			STY	FAC1_2			; save FAC1 mantissa2
  4085 C04A A2 90			LDX	#$90			; set exponent=2^16 (integer)
  4086 C04C 4C EF C8			JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
  4087
  4088 				; perform POS()
  4089 C04F			LAB_POS
  4090 C04F A4 0E			LDY	TPos			; get terminal position
  4091
  4092 				; convert Y to byte in FAC1
  4093 C051			LAB_1FD0
  4094 C051 A9 00			LDA	#$00			; clear high byte
  4095 C053 F0 EF			BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  4096
  4097 				; check not Direct (used by DEF and INPUT)
  4098 C055			LAB_CKRN
  4099 C055 A6 48			LDX	Clineh			; get current line high byte
  4100 C057 E8				INX				; increment it
  4101 C058 D0 98			BNE	LAB_1F7B		; return if can continue not direct mode
  4102
  4103 									; else do illegal direct error
  4104 C05A			LAB_1FD9
  4105 C05A A2 16			LDX	#$16			; error code $16 ('Illegal direct' error)
  4106 C05C			LAB_1FDB
  4107 C05C 4C 0B B1			JMP	LAB_XERR		; go do error #X, then warm start
  4108
  4109 				; perform DEF
  4110 C05F			LAB_DEF
  4111 C05F 20 90 C0			JSR	LAB_200B		; check FNx syntax
  4112 C062 85 5C			STA	func_l			; save function pointer low byte
  4113 C064 84 5D			STY	func_h			; save function pointer high byte
  4114 C066 20 55 C0			JSR	LAB_CKRN		; check not Direct (back here if ok)
  4115 C069 20 D7 BB			JSR	LAB_1BFE		; scan for '(' , else do syntax error then warm start
  4116 C06C A9 80			LDA	#$80			; set flag for FNx
  4117 C06E 85 21			STA	Sufnxf			; save subscript/FNx flag
  4118 C070 20 89 BD			JSR	LAB_GVAR		; get (var) address
  4119 C073 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4120 C076 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4121 C079 A9 D7			LDA	#TK_EQUAL		; get = token
  4122 C07B 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  4123 C07E A5 56			LDA	Cvarah			; get current var address high byte
  4124 C080 48				PHA				; push it
  4125 C081 A5 55			LDA	Cvaral			; get current var address low byte
  4126 C083 48				PHA				; push it
  4127 C084 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4128 C086 48				PHA				; push it
  4129 C087 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4130 C089 48				PHA				; push it
  4131 C08A 20 67 B6			JSR	LAB_DATA		; go perform DATA
  4132 C08D 4C FF C0			JMP	LAB_207A		; put execute pointer and variable pointer into function
  4133 									; and return
  4134
  4135 				; check FNx syntax
  4136 C090			LAB_200B
  4137 C090 A9 C3			LDA	#TK_FN			; get FN' token
  4138 C092 20 CE BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  4139 									; return character after A
  4140 C095 09 80			ORA	#$80			; set FN flag bit
  4141 C097 85 21			STA	Sufnxf			; save FN flag so array variable test fails
  4142 C099 20 90 BD			JSR	LAB_1D12		; search for FN variable
  4143 C09C 4C AD BA			JMP	LAB_CTNM		; check if source is numeric and return, else do type
  4144 									; mismatch
  4145 									; Evaluate FNx
  4146 C09F			LAB_201E
  4147 C09F 20 90 C0			JSR	LAB_200B		; check FNx syntax
  4148 C0A2 48				PHA				; push function pointer low byte
  4149 C0A3 98				TYA				; copy function pointer high byte
  4150 C0A4 48				PHA				; push function pointer high byte
  4151 C0A5 20 D7 BB			JSR	LAB_1BFE		; scan for '(', else do syntax error then warm start
  4152 C0A8 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  4153 C0AB 20 CC BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4154 C0AE 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4155 C0B1 68				PLA				; pop function pointer high byte
  4156 C0B2 85 5D			STA	func_h			; restore it
  4157 C0B4 68				PLA				; pop function pointer low byte
  4158 C0B5 85 5C			STA	func_l			; restore it
  4159 C0B7 A2 20			LDX	#$20			; error code $20 ('Undefined function' error)
  4160 C0B9 A0 03			LDY	#$03			; index to variable pointer high byte
  4161 C0BB B1 5C			LDA	(func_l),Y		; get variable pointer high byte
  4162 C0BD F0 9D			BEQ	LAB_1FDB		; if zero go do undefined function error
  4163
  4164 C0BF 85 56			STA	Cvarah			; save variable address high byte
  4165 C0C1 88				DEY				; index to variable address low byte
  4166 C0C2 B1 5C			LDA	(func_l),Y		; get variable address low byte
  4167 C0C4 85 55			STA	Cvaral			; save variable address low byte
  4168 C0C6 AA				TAX				; copy address low byte
  4169 									; now stack the function variable value before use
  4170 C0C7 C8				INY				; index to mantissa_3
  4171 C0C8			LAB_2043
  4172 C0C8 B1 55			LDA	(Cvaral),Y		; get byte from variable
  4173 C0CA 48				PHA				; stack it
  4174 C0CB 88				DEY				; decrement index
  4175 C0CC 10 FA			BPL	LAB_2043		; loop until variable stacked
  4176
  4177 C0CE A4 56			LDY	Cvarah			; get variable address high byte
  4178 C0D0 20 94 C8			JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  4179 									; (function variable), return Y=0, always
  4180 C0D3 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  4181 C0D5 48				PHA				; push it
  4182 C0D6 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  4183 C0D8 48				PHA				; push it
  4184 C0D9 B1 5C			LDA	(func_l),Y		; get function execute pointer low byte
  4185 C0DB 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  4186 C0DD C8				INY				; index to high byte
  4187 C0DE B1 5C			LDA	(func_l),Y		; get function execute pointer high byte
  4188 C0E0 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4189 C0E2 A5 56			LDA	Cvarah			; get variable address high byte
  4190 C0E4 48				PHA				; push it
  4191 C0E5 A5 55			LDA	Cvaral			; get variable address low byte
  4192 C0E7 48				PHA				; push it
  4193 C0E8 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4194 									; else do type mismatch
  4195 C0EB 68				PLA				; pull variable address low byte
  4196 C0EC 85 5C			STA	func_l			; save variable address low byte
  4197 C0EE 68				PLA				; pull variable address high byte
  4198 C0EF 85 5D			STA	func_h			; save variable address high byte
  4199 C0F1 20 82 00			JSR	LAB_GBYT		; scan memory
  4200 C0F4 F0 03			BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  4201
  4202 C0F6 4C DF BB			JMP	LAB_SNER		; else syntax error then warm start
  4203
  4204 				; restore Bpntrl,Bpntrh and function variable from stack
  4205 C0F9			LAB_2074
  4206 C0F9 68				PLA				; pull BASIC execute pointer low byte
  4207 C0FA 85 83			STA	Bpntrl			; restore BASIC execute pointer low byte
  4208 C0FC 68				PLA				; pull BASIC execute pointer high byte
  4209 C0FD 85 84			STA	Bpntrh			; restore BASIC execute pointer high byte
  4210
  4211 				; put execute pointer and variable pointer into function
  4212 C0FF			LAB_207A
  4213 C0FF A0 00			LDY	#$00			; clear index
  4214 C101 68				PLA				; pull BASIC execute pointer low byte
  4215 C102 91 5C			STA	(func_l),Y		; save to function
  4216 C104 C8				INY				; increment index
  4217 C105 68				PLA				; pull BASIC execute pointer high byte
  4218 C106 91 5C			STA	(func_l),Y		; save to function
  4219 C108 C8				INY				; increment index
  4220 C109 68				PLA				; pull current var address low byte
  4221 C10A 91 5C			STA	(func_l),Y		; save to function
  4222 C10C C8				INY				; increment index
  4223 C10D 68				PLA				; pull current var address high byte
  4224 C10E 91 5C			STA	(func_l),Y		; save to function
  4225 C110 60				RTS
  4226
  4227 				; perform STR$()
  4228 C111			LAB_STRS
  4229 C111 20 AD BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4230 C114 20 82 CA			JSR	LAB_296E		; convert FAC1 to string
  4231 C117 A9 9E			LDA	#<Decssp1		; set result string low pointer
  4232 C119 A0 00			LDY	#>Decssp1		; set result string high pointer
  4233 C11B F0 12			BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
  4234
  4235 				; Do string vector
  4236 				; copy des_pl/h to des_2l/h and make string space A bytes long
  4237 C11D			LAB_209C
  4238 C11D A6 6E			LDX	des_pl			; get descriptor pointer low byte
  4239 C11F A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4240 C121 86 5E			STX	des_2l			; save descriptor pointer low byte
  4241 C123 84 5F			STY	des_2h			; save descriptor pointer high byte
  4242
  4243 				; make string space A bytes long
  4244 				; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4245 C125			LAB_MSSP
  4246 C125 20 9A C1			JSR	LAB_2115		; make space in string memory for string A long
  4247 									; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4248 C128 86 6D			STX	str_pl			; save string pointer low byte
  4249 C12A 84 6E			STY	str_ph			; save string pointer high byte
  4250 C12C 85 6C			STA	str_ln			; save length
  4251 C12E 60				RTS
  4252
  4253 				; Scan, set up string
  4254 				; print ' terminated string to Sutill/Sutilh
  4255 C12F			LAB_20AE
  4256 C12F A2 22			LDX	#$22			; set terminator to '
  4257 C131 86 1B			STX	Srchc			; set search character (terminator 1)
  4258 C133 86 1C			STX	Asrch			; set terminator 2
  4259
  4260 				; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4261 				; source is AY
  4262 C135			LAB_20B4
  4263 C135 85 78			STA	ssptr_l			; store string start low byte
  4264 C137 84 79			STY	ssptr_h			; store string start high byte
  4265 C139 85 6D			STA	str_pl			; save string pointer low byte
  4266 C13B 84 6E			STY	str_ph			; save string pointer high byte
  4267 C13D A0 FF			LDY	#$FF			; set length to -1
  4268 C13F			LAB_20BE
  4269 C13F C8				INY				; increment length
  4270 C140 B1 78			LDA	(ssptr_l),Y		; get byte from string
  4271 C142 F0 0C			BEQ	LAB_20CF		; exit loop if null byte [EOS]
  4272
  4273 C144 C5 1B			CMP	Srchc			; compare with search character (terminator 1)
  4274 C146 F0 04			BEQ	LAB_20CB		; branch if terminator
  4275
  4276 C148 C5 1C			CMP	Asrch			; compare with terminator 2
  4277 C14A D0 F3			BNE	LAB_20BE		; loop if not terminator 2
  4278
  4279 C14C			LAB_20CB
  4280 C14C C9 22			CMP	#$22			; compare with '
  4281 C14E F0 01			BEQ	LAB_20D0		; branch if ' (carry set if = !)
  4282
  4283 C150			LAB_20CF
  4284 C150 18				CLC				; clear carry for add (only if [EOL] terminated string)
  4285 C151			LAB_20D0
  4286 C151 84 6C			STY	str_ln			; save length in FAC1 exponent
  4287 C153 98				TYA				; copy length to A
  4288 C154 65 78			ADC	ssptr_l			; add string start low byte
  4289 C156 85 7A			STA	Sendl			; save string end low byte
  4290 C158 A6 79			LDX	ssptr_h			; get string start high byte
  4291 C15A 90 01			BCC	LAB_20DC		; branch if no low byte overflow
  4292
  4293 C15C E8				INX				; else increment high byte
  4294 C15D			LAB_20DC				; RAM above code / Ibuff above EhBASIC patch V2
  4295 C15D 86 7B			STX	Sendh			; save string end high byte
  4296 C15F A5 79			LDA	ssptr_h			; get string start high byte
  4297 C161 F0 04			BEQ   	LAB_MVST          	; fix STR$() using page zero via LAB_296E
  4298 					
  4299 C163 C9 18			CMP   	#>Ibuffs          	; compare with location of input buffer page
  4300 C165 D0 0B			BNE   	LAB_RTST          	; branch if not in utility area
  4301 C167			LAB_MVST 
  4302 									; string in utility area, move to string memory
  4303 C167 98				TYA				; copy length to A
  4304 C168 20 1D C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4305 									; long
  4306 C16B A6 78			LDX	ssptr_l			; get string start low byte
  4307 C16D A4 79			LDY	ssptr_h			; get string start high byte
  4308 C16F 20 0C C3			JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
  4309
  4310 				; check for space on descriptor stack then ..
  4311 				; put string address and length on descriptor stack and update stack pointers
  4312 C172			LAB_RTST
  4313 C172 A6 25			LDX	next_s			; get string stack pointer
  4314 C174 E0 31			CPX	#des_sk+$09		; compare with max+1
  4315 C176 D0 05			BNE	LAB_20F8		; branch if space on string stack
  4316
  4317 									; else do string too complex error
  4318 C178 A2 1C			LDX	#$1C			; error code $1C ('String too complex' error)
  4319 C17A			LAB_20F5
  4320 C17A 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4321
  4322 				; put string address and length on descriptor stack and update stack pointers
  4323 C17D			LAB_20F8
  4324 C17D A5 6C			LDA	str_ln			; get string length
  4325 C17F 95 00			STA	PLUS_0,X		; put on string stack
  4326 C181 A5 6D			LDA	str_pl			; get string pointer low byte
  4327 C183 95 01			STA	PLUS_1,X		; put on string stack
  4328 C185 A5 6E			LDA	str_ph			; get string pointer high byte
  4329 C187 95 02			STA	PLUS_2,X		; put on string stack
  4330 C189 A0 00			LDY	#$00			; clear Y
  4331 C18B 86 6E			STX	des_pl			; save string descriptor pointer low byte
  4332 C18D 84 6F			STY	des_ph			; save string descriptor pointer high byte (always $00)
  4333 C18F 88				DEY				; Y = $FF
  4334 C190 84 1F			STY	Dtypef			; save data type flag, $FF=string
  4335 C192 86 26			STX	last_sl			; save old stack pointer (current top item)
  4336 C194 E8				INX				; update stack pointer
  4337 C195 E8				INX				; update stack pointer
  4338 C196 E8				INX				; update stack pointer
  4339 C197 86 25			STX	next_s			; save new top item value
  4340 C199 60				RTS
  4341
  4342 				; Build descriptor
  4343 				; make space in string memory for string A long
  4344 				; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4345 C19A			LAB_2115
  4346 C19A 46 20			LSR	Gclctd			; clear garbage collected flag (b7)
  4347 									; make space for string A long
  4348 C19C			LAB_2117
  4349 C19C 48				PHA				; save string length
  4350 C19D 49 FF			EOR	#$FF			; complement it
  4351 C19F 38				SEC				; set carry for subtract (twos comp add)
  4352 C1A0 65 41			ADC	Sstorl			; add bottom of string space low byte (subtract length)
  4353 C1A2 A4 42			LDY	Sstorh			; get bottom of string space high byte
  4354 C1A4 B0 01			BCS	LAB_2122		; skip decrement if no underflow
  4355
  4356 C1A6 88				DEY				; decrement bottom of string space high byte
  4357 C1A7			LAB_2122
  4358 C1A7 C4 40			CPY	Earryh			; compare with array mem end high byte
  4359 C1A9 90 11			BCC	LAB_2137		; do out of memory error if less
  4360
  4361 C1AB D0 04			BNE	LAB_212C		; if not = skip next test
  4362
  4363 C1AD C5 3F			CMP	Earryl			; compare with array mem end low byte
  4364 C1AF 90 0B			BCC	LAB_2137		; do out of memory error if less
  4365
  4366 C1B1			LAB_212C
  4367 C1B1 85 41			STA	Sstorl			; save bottom of string space low byte
  4368 C1B3 84 42			STY	Sstorh			; save bottom of string space high byte
  4369 C1B5 85 43			STA	Sutill			; save string utility ptr low byte
  4370 C1B7 84 44			STY	Sutilh			; save string utility ptr high byte
  4371 C1B9 AA				TAX				; copy low byte to X
  4372 C1BA 68				PLA				; get string length back
  4373 C1BB 60				RTS
  4374
  4375 C1BC			LAB_2137
  4376 C1BC A2 0C			LDX	#$0C			; error code $0C ('Out of memory' error)
  4377 C1BE A5 20			LDA	Gclctd			; get garbage collected flag
  4378 C1C0 30 B8			BMI	LAB_20F5		; if set then do error code X
  4379
  4380 C1C2 20 CC C1			JSR	LAB_GARB		; else go do garbage collection
  4381 C1C5 A9 80			LDA	#$80			; flag for garbage collected
  4382 C1C7 85 20			STA	Gclctd			; set garbage collected flag
  4383 C1C9 68				PLA				; pull length
  4384 C1CA D0 D0			BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4385
  4386 				; garbage collection routine
  4387 C1CC			LAB_GARB
  4388 C1CC A6 45			LDX	Ememl			; get end of mem low byte
  4389 C1CE A5 46			LDA	Ememh			; get end of mem high byte
  4390
  4391 				; re-run routine from last ending
  4392 C1D0			LAB_214B
  4393 C1D0 86 41			STX	Sstorl			; set string storage low byte
  4394 C1D2 85 42			STA	Sstorh			; set string storage high byte
  4395 C1D4 A0 00			LDY	#$00			; clear index
  4396 C1D6 84 5D			STY	garb_h			; clear working pointer high byte (flag no strings to move)
  4397 C1D8 A5 3F			LDA	Earryl			; get array mem end low byte
  4398 C1DA A6 40			LDX	Earryh			; get array mem end high byte
  4399 C1DC 85 6A			STA	Histrl			; save as highest string low byte
  4400 C1DE 86 6B			STX	Histrh			; save as highest string high byte
  4401 C1E0 A9 28			LDA	#des_sk			; set descriptor stack pointer
  4402 C1E2 85 31			STA	ut1_pl			; save descriptor stack pointer low byte
  4403 C1E4 84 32			STY	ut1_ph			; save descriptor stack pointer high byte ($00)
  4404 C1E6			LAB_2161
  4405 C1E6 C5 25			CMP	next_s			; compare with descriptor stack pointer
  4406 C1E8 F0 05			BEQ	LAB_216A		; branch if =
  4407
  4408 C1EA 20 50 C2			JSR	LAB_21D7		; go garbage collect descriptor stack
  4409 C1ED F0 F7			BEQ	LAB_2161		; loop always
  4410
  4411 									; done stacked strings, now do string vars
  4412 C1EF			LAB_216A
  4413 C1EF 06 60			ASL	g_step			; set step size = $06
  4414 C1F1 A5 3B			LDA	Svarl			; get start of vars low byte
  4415 C1F3 A6 3C			LDX	Svarh			; get start of vars high byte
  4416 C1F5 85 31			STA	ut1_pl			; save as pointer low byte
  4417 C1F7 86 32			STX	ut1_ph			; save as pointer high byte
  4418 C1F9			LAB_2176
  4419 C1F9 E4 3E			CPX	Sarryh			; compare start of arrays high byte
  4420 C1FB D0 04			BNE	LAB_217E		; branch if no high byte match
  4421
  4422 C1FD C5 3D			CMP	Sarryl			; else compare start of arrays low byte
  4423 C1FF F0 05			BEQ	LAB_2183		; branch if = var mem end
  4424
  4425 C201			LAB_217E
  4426 C201 20 4A C2			JSR	LAB_21D1		; go garbage collect strings
  4427 C204 F0 F3			BEQ	LAB_2176		; loop always
  4428
  4429 									; done string vars, now do string arrays
  4430 C206			LAB_2183
  4431 C206 85 64			STA	Nbendl			; save start of arrays low byte as working pointer
  4432 C208 86 65			STX	Nbendh			; save start of arrays high byte as working pointer
  4433 C20A A9 04			LDA	#$04			; set step size
  4434 C20C 85 60			STA	g_step			; save step size
  4435 C20E			LAB_218B
  4436 C20E A5 64			LDA	Nbendl			; get pointer low byte
  4437 C210 A6 65			LDX	Nbendh			; get pointer high byte
  4438 C212			LAB_218F
  4439 C212 E4 40			CPX	Earryh			; compare with array mem end high byte
  4440 C214 D0 04			BNE	LAB_219A		; branch if not at end
  4441
  4442 C216 C5 3F			CMP	Earryl			; else compare with array mem end low byte
  4443 C218 F0 75			BEQ	LAB_2216		; tidy up and exit if at end
  4444
  4445 C21A			LAB_219A
  4446 C21A 85 31			STA	ut1_pl			; save pointer low byte
  4447 C21C 86 32			STX	ut1_ph			; save pointer high byte
  4448 C21E A0 02			LDY	#$02			; set index
  4449 C220 B1 31			LDA	(ut1_pl),Y		; get array size low byte
  4450 C222 65 64			ADC	Nbendl			; add start of this array low byte
  4451 C224 85 64			STA	Nbendl			; save start of next array low byte
  4452 C226 C8				INY				; increment index
  4453 C227 B1 31			LDA	(ut1_pl),Y		; get array size high byte
  4454 C229 65 65			ADC	Nbendh			; add start of this array high byte
  4455 C22B 85 65			STA	Nbendh			; save start of next array high byte
  4456 C22D A0 01			LDY	#$01			; set index
  4457 C22F B1 31			LDA	(ut1_pl),Y		; get name second byte
  4458 C231 10 DB			BPL	LAB_218B		; skip if not string array
  4459
  4460 				; was string array so ..
  4461 C233 A0 04			LDY	#$04			; set index
  4462 C235 B1 31			LDA	(ut1_pl),Y		; get # of dimensions
  4463 C237 0A				ASL				; *2
  4464 C238 69 05			ADC	#$05			; +5 (array header size)
  4465 C23A 20 82 C2			JSR	LAB_2208		; go set up for first element
  4466 C23D			LAB_21C4
  4467 C23D E4 65			CPX	Nbendh			; compare with start of next array high byte
  4468 C23F D0 04			BNE	LAB_21CC		; branch if <> (go do this array)
  4469
  4470 C241 C5 64			CMP	Nbendl			; else compare element pointer low byte with next array
  4471 									; low byte
  4472 C243 F0 CD			BEQ	LAB_218F		; if equal then go do next array
  4473
  4474 C245			LAB_21CC
  4475 C245 20 50 C2			JSR	LAB_21D7		; go defrag array strings
  4476 C248 F0 F3			BEQ	LAB_21C4		; go do next array string (loop always)
  4477
  4478 				; defrag string variables
  4479 				; enter with XA = variable pointer
  4480 				; return with XA = next variable pointer
  4481 C24A			LAB_21D1
  4482 C24A C8				INY				; increment index (Y was $00)
  4483 C24B B1 31			LDA	(ut1_pl),Y		; get var name byte 2
  4484 C24D 10 30			BPL	LAB_2206		; if not string, step pointer to next var and return
  4485
  4486 C24F C8				INY				; else increment index
  4487 C250			LAB_21D7
  4488 C250 B1 31			LDA	(ut1_pl),Y		; get string length
  4489 C252 F0 2B			BEQ	LAB_2206		; if null, step pointer to next string and return
  4490
  4491 C254 C8				INY				; else increment index
  4492 C255 B1 31			LDA	(ut1_pl),Y		; get string pointer low byte
  4493 C257 AA				TAX				; copy to X
  4494 C258 C8				INY				; increment index
  4495 C259 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte
  4496 C25B C5 42			CMP	Sstorh			; compare bottom of string space high byte
  4497 C25D 90 06			BCC	LAB_21EC		; branch if less
  4498
  4499 C25F D0 1E			BNE	LAB_2206		; if greater, step pointer to next string and return
  4500
  4501 									; high bytes were = so compare low bytes
  4502 C261 E4 41			CPX	Sstorl			; compare bottom of string space low byte
  4503 C263 B0 1A			BCS	LAB_2206		; if >=, step pointer to next string and return
  4504
  4505 									; string pointer is < string storage pointer (pos in mem)
  4506 C265			LAB_21EC
  4507 C265 C5 6B			CMP	Histrh			; compare to highest string high byte
  4508 C267 90 17			BCC	LAB_2207		; if <, step pointer to next string and return
  4509
  4510 C269 D0 04			BNE	LAB_21F6		; if > update pointers, step to next and return
  4511
  4512 									; high bytes were = so compare low bytes
  4513 C26B E4 6A			CPX	Histrl			; compare to highest string low byte
  4514 C26D 90 11			BCC	LAB_2207		; if <, step pointer to next string and return
  4515
  4516 									; string is in string memory space
  4517 C26F			LAB_21F6
  4518 C26F 86 6A			STX	Histrl			; save as new highest string low byte
  4519 C271 85 6B			STA	Histrh			; save as new highest string high byte
  4520 C273 A5 31			LDA	ut1_pl			; get start of vars(descriptors) low byte
  4521 C275 A6 32			LDX	ut1_ph			; get start of vars(descriptors) high byte
  4522 C277 85 5C			STA	garb_l			; save as working pointer low byte
  4523 C279 86 5D			STX	garb_h			; save as working pointer high byte
  4524 C27B 88				DEY				; decrement index DIFFERS
  4525 C27C 88				DEY				; decrement index (should point to descriptor start)
  4526 C27D 84 62			STY	g_indx			; save index pointer
  4527
  4528 									; step pointer to next string
  4529 C27F			LAB_2206
  4530 C27F 18				CLC				; clear carry for add
  4531 C280			LAB_2207
  4532 C280 A5 60			LDA	g_step			; get step size
  4533 C282			LAB_2208
  4534 C282 65 31			ADC	ut1_pl			; add pointer low byte
  4535 C284 85 31			STA	ut1_pl			; save pointer low byte
  4536 C286 90 02			BCC	LAB_2211		; branch if no overflow
  4537
  4538 C288 E6 32			INC	ut1_ph			; else increment high byte
  4539 C28A			LAB_2211
  4540 C28A A6 32			LDX	ut1_ph			; get pointer high byte
  4541 C28C A0 00			LDY	#$00			; clear Y
  4542 C28E 60				RTS
  4543
  4544 				; search complete, now either exit or set-up and move string
  4545 C28F			LAB_2216
  4546 C28F C6 60			DEC	g_step			; decrement step size (now $03 for descriptor stack)
  4547 C291 A6 5D			LDX	garb_h			; get string to move high byte
  4548 C293 F0 F5			BEQ	LAB_2211		; exit if nothing to move
  4549
  4550 C295 A4 62			LDY	g_indx			; get index byte back (points to descriptor)
  4551 C297 18				CLC				; clear carry for add
  4552 C298 B1 5C			LDA	(garb_l),Y		; get string length
  4553 C29A 65 6A			ADC	Histrl			; add highest string low byte
  4554 C29C 85 66			STA	Obendl			; save old block end low pointer
  4555 C29E A5 6B			LDA	Histrh			; get highest string high byte
  4556 C2A0 69 00			ADC	#$00			; add any carry
  4557 C2A2 85 67			STA	Obendh			; save old block end high byte
  4558 C2A4 A5 41			LDA	Sstorl			; get bottom of string space low byte
  4559 C2A6 A6 42			LDX	Sstorh			; get bottom of string space high byte
  4560 C2A8 85 64			STA	Nbendl			; save new block end low byte
  4561 C2AA 86 65			STX	Nbendh			; save new block end high byte
  4562 C2AC 20 94 B0			JSR	LAB_11D6		; open up space in memory, don't set array end
  4563 C2AF A4 62			LDY	g_indx			; get index byte
  4564 C2B1 C8				INY				; point to descriptor low byte
  4565 C2B2 A5 64			LDA	Nbendl			; get string pointer low byte
  4566 C2B4 91 5C			STA	(garb_l),Y		; save new string pointer low byte
  4567 C2B6 AA				TAX				; copy string pointer low byte
  4568 C2B7 E6 65			INC	Nbendh			; correct high byte (move sets high byte -1)
  4569 C2B9 A5 65			LDA	Nbendh			; get new string pointer high byte
  4570 C2BB C8				INY				; point to descriptor high byte
  4571 C2BC 91 5C			STA	(garb_l),Y		; save new string pointer high byte
  4572 C2BE 4C D0 C1			JMP	LAB_214B		; re-run routine from last ending
  4573 									; (but don't collect this string)
  4574
  4575 				; concatenate
  4576 				; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4577 C2C1			LAB_224D
  4578 C2C1 A5 6F			LDA	des_ph			; get descriptor pointer high byte
  4579 C2C3 48				PHA				; put on stack
  4580 C2C4 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4581 C2C6 48				PHA				; put on stack
  4582 C2C7 20 AA BB			JSR	LAB_GVAL		; get value from line
  4583 C2CA 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4584 C2CD 68				PLA				; get descriptor pointer low byte back
  4585 C2CE 85 78			STA	ssptr_l			; set pointer low byte
  4586 C2D0 68				PLA				; get descriptor pointer high byte back
  4587 C2D1 85 79			STA	ssptr_h			; set pointer high byte
  4588 C2D3 A0 00			LDY	#$00			; clear index
  4589 C2D5 B1 78			LDA	(ssptr_l),Y		; get length_1 from descriptor
  4590 C2D7 18				CLC				; clear carry for add
  4591 C2D8 71 6E			ADC	(des_pl),Y		; add length_2
  4592 C2DA 90 05			BCC	LAB_226D		; branch if no overflow
  4593
  4594 C2DC A2 1A			LDX	#$1A			; else set error code $1A ('String too long' error)
  4595 C2DE 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  4596
  4597 C2E1			LAB_226D
  4598 C2E1 20 1D C1			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4599 									; long
  4600 C2E4 20 FE C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  4601 C2E7 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4602 C2E9 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4603 C2EB 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4604 									; returns with A = length, ut1_pl = pointer low byte,
  4605 									; ut1_ph = pointer high byte
  4606 C2EE 20 10 C3			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4607 C2F1 A5 78			LDA	ssptr_l			;.set descriptor pointer low byte
  4608 C2F3 A4 79			LDY	ssptr_h			;.set descriptor pointer high byte
  4609 C2F5 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4610 									; returns with A = length, X=ut1_pl=pointer low byte,
  4611 									; Y=ut1_ph=pointer high byte
  4612 C2F8 20 72 C1			JSR	LAB_RTST		; check for space on descriptor stack then put string
  4613 									; address and length on descriptor stack and update stack
  4614 									; pointers
  4615 C2FB 4C D5 BA			JMP	LAB_1ADB		;.continue evaluation
  4616
  4617 				; copy string from descriptor (sdescr) to (Sutill)
  4618 C2FE			LAB_228A
  4619 C2FE A0 00			LDY	#$00			; clear index
  4620 C300 B1 78			LDA	(sdescr),Y		; get string length
  4621 C302 48				PHA				; save on stack
  4622 C303 C8				INY				; increment index
  4623 C304 B1 78			LDA	(sdescr),Y		; get source string pointer low byte
  4624 C306 AA				TAX				; copy to X
  4625 C307 C8				INY				; increment index
  4626 C308 B1 78			LDA	(sdescr),Y		; get source string pointer high byte
  4627 C30A A8				TAY				; copy to Y
  4628 C30B 68				PLA				; get length back
  4629
  4630 				; store string A bytes long from YX to (Sutill)
  4631 C30C			LAB_2298
  4632 C30C 86 31			STX	ut1_pl			; save source string pointer low byte
  4633 C30E 84 32			STY	ut1_ph			; save source string pointer high byte
  4634
  4635 				; store string A bytes long from (ut1_pl) to (Sutill)
  4636 C310			LAB_229C
  4637 C310 AA				TAX				; copy length to index (don't count with Y)
  4638 C311 F0 14			BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4639
  4640 C313 A0 00			LDY	#$00			; zero pointer (copy forward)
  4641 C315			LAB_22A0
  4642 C315 B1 31			LDA	(ut1_pl),Y		; get source byte
  4643 C317 91 43			STA	(Sutill),Y		; save destination byte
  4644
  4645 C319 C8				INY				; increment index
  4646 C31A CA				DEX				; decrement counter
  4647 C31B D0 F8			BNE	LAB_22A0		; loop while <> 0
  4648
  4649 C31D 98				TYA				; restore length from Y
  4650 C31E			LAB_22A9
  4651 C31E 18				CLC				; clear carry for add
  4652 C31F 65 43			ADC	Sutill			; add string utility ptr low byte
  4653 C321 85 43			STA	Sutill			; save string utility ptr low byte
  4654 C323 90 02			BCC	LAB_22B2		; branch if no carry
  4655
  4656 C325 E6 44			INC	Sutilh			; else increment string utility ptr high byte
  4657 C327			LAB_22B2
  4658 C327 60				RTS
  4659
  4660 				; evaluate string
  4661 C328			LAB_EVST
  4662 C328 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4663
  4664 				; pop string off descriptor stack, or from top of string space
  4665 				; returns with A = length, X=pointer low byte, Y=pointer high byte
  4666 C32B			LAB_22B6
  4667 C32B A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4668 C32D A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4669
  4670 				; pop (YA) descriptor off stack or from top of string space
  4671 				; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4672 C32F			LAB_22BA
  4673 C32F 85 31			STA	ut1_pl			; save descriptor pointer low byte
  4674 C331 84 32			STY	ut1_ph			; save descriptor pointer high byte
  4675 C333 20 60 C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  4676 C336 08				PHP				; save status flags
  4677 C337 A0 00			LDY	#$00			; clear index
  4678 C339 B1 31			LDA	(ut1_pl),Y		; get length from string descriptor
  4679 C33B 48				PHA				; put on stack
  4680 C33C C8				INY				; increment index
  4681 C33D B1 31			LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
  4682 C33F AA				TAX				; copy to X
  4683 C340 C8				INY				; increment index
  4684 C341 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
  4685 C343 A8				TAY				; copy to Y
  4686 C344 68				PLA				; get string length back
  4687 C345 28				PLP				; restore status
  4688 C346 D0 13			BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
  4689
  4690 C348 C4 42			CPY	Sstorh			; compare bottom of string space high byte
  4691 C34A D0 0F			BNE	LAB_22E6		; branch if <>
  4692
  4693 C34C E4 41			CPX	Sstorl			; else compare bottom of string space low byte
  4694 C34E D0 0B			BNE	LAB_22E6		; branch if <>
  4695
  4696 C350 48				PHA				; save string length
  4697 C351 18				CLC				; clear carry for add
  4698 C352 65 41			ADC	Sstorl			; add bottom of string space low byte
  4699 C354 85 41			STA	Sstorl			; save bottom of string space low byte
  4700 C356 90 02			BCC	LAB_22E5		; skip increment if no overflow
  4701
  4702 C358 E6 42			INC	Sstorh			; increment bottom of string space high byte
  4703 C35A			LAB_22E5
  4704 C35A 68				PLA				; restore string length
  4705 C35B			LAB_22E6
  4706 C35B 86 31			STX	ut1_pl			; save string pointer low byte
  4707 C35D 84 32			STY	ut1_ph			; save string pointer high byte
  4708 C35F 60				RTS
  4709
  4710 				; clean descriptor stack, YA = pointer
  4711 				; checks if AY is on the descriptor stack, if so does a stack discard
  4712 C360			LAB_22EB
  4713 C360 C4 27			CPY	last_sh			; compare pointer high byte
  4714 C362 D0 0C			BNE	LAB_22FB		; exit if <>
  4715
  4716 C364 C5 26			CMP	last_sl			; compare pointer low byte
  4717 C366 D0 08			BNE	LAB_22FB		; exit if <>
  4718
  4719 C368 85 25			STA	next_s			; save descriptor stack pointer
  4720 C36A E9 03			SBC	#$03			; -3
  4721 C36C 85 26			STA	last_sl			; save low byte -3
  4722 C36E A0 00			LDY	#$00			; clear high byte
  4723 C370			LAB_22FB
  4724 C370 60				RTS
  4725
  4726 				; perform CHR$()
  4727 C371			LAB_CHRS
  4728 C371 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  4729 C374 8A				TXA				; copy to A
  4730 C375 48				PHA				; save character
  4731 C376 A9 01			LDA	#$01			; string is single byte
  4732 C378 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4733 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4734 C37B 68				PLA				; get character back
  4735 C37C A0 00			LDY	#$00			; clear index
  4736 C37E 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  4737 C380 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4738 									; address and length on descriptor stack and update stack
  4739 									; pointers
  4740
  4741 				; perform LEFT$()
  4742 C383			LAB_LEFT
  4743 C383 48				PHA				; push byte parameter
  4744 C384 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4745 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4746 C387 D1 5E			CMP	(des_2l),Y		; compare byte parameter with string length
  4747 C389 98				TYA				; clear A
  4748 C38A F0 09			BEQ	LAB_2316		; go do string copy (branch always)
  4749
  4750 				; perform RIGHT$()
  4751 C38C			LAB_RIGHT
  4752 C38C 48				PHA				; push byte parameter
  4753 C38D 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4754 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4755 C390 18				CLC				; clear carry for add-1
  4756 C391 F1 5E			SBC	(des_2l),Y		; subtract string length
  4757 C393 49 FF			EOR	#$FF			; invert it (A=LEN(expression$)-l)
  4758
  4759 C395			LAB_2316
  4760 C395 90 04			BCC	LAB_231C		; branch if string length > byte parameter
  4761
  4762 C397 B1 5E			LDA	(des_2l),Y		; else make parameter = length
  4763 C399 AA				TAX				; copy to byte parameter copy
  4764 C39A 98				TYA				; clear string start offset
  4765 C39B			LAB_231C
  4766 C39B 48				PHA				; save string start offset
  4767 C39C			LAB_231D
  4768 C39C 8A				TXA				; copy byte parameter (or string length if <)
  4769 C39D			LAB_231E
  4770 C39D 48				PHA				; save string length
  4771 C39E 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4772 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4773 C3A1 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4774 C3A3 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4775 C3A5 20 2F C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4776 									; returns with A = length, X=ut1_pl=pointer low byte,
  4777 									; Y=ut1_ph=pointer high byte
  4778 C3A8 68				PLA				; get string length back
  4779 C3A9 A8				TAY				; copy length to Y
  4780 C3AA 68				PLA				; get string start offset back
  4781 C3AB 18				CLC				; clear carry for add
  4782 C3AC 65 31			ADC	ut1_pl			; add start offset to string start pointer low byte
  4783 C3AE 85 31			STA	ut1_pl			; save string start pointer low byte
  4784 C3B0 90 02			BCC	LAB_2335		; branch if no overflow
  4785
  4786 C3B2 E6 32			INC	ut1_ph			; else increment string start pointer high byte
  4787 C3B4			LAB_2335
  4788 C3B4 98				TYA				; copy length to A
  4789 C3B5 20 10 C3			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4790 C3B8 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4791 									; address and length on descriptor stack and update stack
  4792 									; pointers
  4793
  4794 				; perform MID$()
  4795 C3BB			LAB_MIDS
  4796 C3BB 48				PHA				; push byte parameter
  4797 C3BC A9 FF			LDA	#$FF			; set default length = 255
  4798 C3BE 85 6F			STA	mids_l			; save default length
  4799 C3C0 20 82 00			JSR	LAB_GBYT		; scan memory
  4800 C3C3 C9 29			CMP	#')'			; compare with ')'
  4801 C3C5 F0 06			BEQ	LAB_2358		; branch if = ')' (skip second byte get)
  4802
  4803 C3C7 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4804 C3CA 20 79 C4			JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
  4805 C3CD			LAB_2358
  4806 C3CD 20 E4 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4807 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4808 C3D0 CA				DEX				; decrement start index
  4809 C3D1 8A				TXA				; copy to A
  4810 C3D2 48				PHA				; save string start offset
  4811 C3D3 18				CLC				; clear carry for sub-1
  4812 C3D4 A2 00			LDX	#$00			; clear output string length
  4813 C3D6 F1 5E			SBC	(des_2l),Y		; subtract string length
  4814 C3D8 B0 C2			BCS	LAB_231D		; if start>string length go do null string
  4815
  4816 C3DA 49 FF			EOR	#$FF			; complement -length
  4817 C3DC C5 6F			CMP	mids_l			; compare byte parameter
  4818 C3DE 90 BD			BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4819
  4820 C3E0 A5 6F			LDA	mids_l			; get length byte
  4821 C3E2 B0 B9			BCS	LAB_231E		; go do string copy (branch always)
  4822
  4823 				; pull string data and byte parameter from stack
  4824 				; return pointer in des_2l/h, byte in A (and X), Y=0
  4825 C3E4			LAB_236F
  4826 C3E4 20 CC BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4827 C3E7 68				PLA				; pull return address low byte (return address)
  4828 C3E8 85 62			STA	Fnxjpl			; save functions jump vector low byte
  4829 C3EA 68				PLA				; pull return address high byte (return address)
  4830 C3EB 85 63			STA	Fnxjph			; save functions jump vector high byte
  4831 C3ED 68				PLA				; pull byte parameter
  4832 C3EE AA				TAX				; copy byte parameter to X
  4833 C3EF 68				PLA				; pull string pointer low byte
  4834 C3F0 85 5E			STA	des_2l			; save it
  4835 C3F2 68				PLA				; pull string pointer high byte
  4836 C3F3 85 5F			STA	des_2h			; save it
  4837 C3F5 A0 00			LDY	#$00			; clear index
  4838 C3F7 8A				TXA				; copy byte parameter
  4839 C3F8 F0 79			BEQ	LAB_23A8		; if null do function call error then warm start
  4840
  4841 C3FA E6 62			INC	Fnxjpl			; increment function jump vector low byte
  4842 									; (JSR pushes return addr-1. this is all very nice
  4843 									; but will go tits up if either call is on a page
  4844 									; boundary!)
  4845 C3FC 6C 62 00			JMP	(Fnxjpl)		; in effect, RTS
  4846
  4847 				; perform LCASE$()
  4848 C3FF			LAB_LCASE
  4849 C3FF 20 28 C3			JSR	LAB_EVST		; evaluate string
  4850 C402 85 6C			STA	str_ln			; set string length
  4851 C404 A8				TAY				; copy length to Y
  4852 C405 F0 38			BEQ	NoString		; branch if null string
  4853
  4854 C407 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4855 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4856 C40A 86 6D			STX	str_pl			; save string pointer low byte
  4857 C40C 84 6E			STY	str_ph			; save string pointer high byte
  4858 C40E A8				TAY				; get string length back
  4859
  4860 C40F			LC_loop
  4861 C40F 88				DEY				; decrement index
  4862 C410 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4863 C412 20 01 BE			JSR	LAB_1D82		; is character 'A' to 'Z'
  4864 C415 90 02			BCC	NoUcase			; branch if not upper case alpha
  4865
  4866 C417 09 20			ORA	#$20			; convert upper to lower case
  4867 C419			NoUcase
  4868 C419 91 43			STA	(Sutill),Y		; save byte back to string
  4869 C41B 98				TYA				; test index
  4870 C41C D0 F1			BNE	LC_loop			; loop if not all done
  4871
  4872 C41E F0 1F			BEQ	NoString		; tidy up and exit, branch always
  4873
  4874 				; perform UCASE$()
  4875 C420			LAB_UCASE
  4876 C420 20 28 C3			JSR	LAB_EVST		; evaluate string
  4877 C423 85 6C			STA	str_ln			; set string length
  4878 C425 A8				TAY				; copy length to Y
  4879 C426 F0 17			BEQ	NoString		; branch if null string
  4880
  4881 C428 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4882 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4883 C42B 86 6D			STX	str_pl			; save string pointer low byte
  4884 C42D 84 6E			STY	str_ph			; save string pointer high byte
  4885 C42F A8				TAY				; get string length back
  4886
  4887 C430			UC_loop
  4888 C430 88				DEY				; decrement index
  4889 C431 B1 31			LDA	(ut1_pl),Y		; get byte from string
  4890 C433 20 FD BD			JSR	LAB_CASC		; is character 'a' to 'z' (or 'A' to 'Z')
  4891 C436 90 02			BCC	NoLcase			; branch if not alpha
  4892
  4893 C438 29 DF			AND	#$DF			; convert lower to upper case
  4894 C43A			NoLcase
  4895 C43A 91 43			STA	(Sutill),Y		; save byte back to string
  4896 C43C 98				TYA				; test index
  4897 C43D D0 F1			BNE	UC_loop			; loop if not all done
  4898
  4899 C43F			NoString
  4900 C43F 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4901 									; address and length on descriptor stack and update stack
  4902 									; pointers
  4903
  4904 				; perform SADD()
  4905 C442			LAB_SADD
  4906 C442 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4907 C445 20 89 BD			JSR	LAB_GVAR		; get var address
  4908
  4909 C448 20 CC BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4910 C44B 20 AF BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4911
  4912 C44E A0 02			LDY	#$02			; index to string pointer high byte
  4913 C450 B1 55			LDA	(Cvaral),Y		; get string pointer high byte
  4914 C452 AA				TAX				; copy string pointer high byte to X
  4915 C453 88				DEY				; index to string pointer low byte
  4916 C454 B1 55			LDA	(Cvaral),Y		; get string pointer low byte
  4917 C456 A8				TAY				; copy string pointer low byte to Y
  4918 C457 8A				TXA				; copy string pointer high byte to A
  4919 C458 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  4920
  4921 				; perform LEN()
  4922 C45B			LAB_LENS
  4923 C45B 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4924 C45E 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4925
  4926 				; evaluate string, get length in Y
  4927 C461			LAB_ESGL
  4928 C461 20 28 C3			JSR	LAB_EVST		; evaluate string
  4929 C464 A8				TAY				; copy length to Y
  4930 C465 60				RTS
  4931
  4932 				; perform ASC()
  4933 C466			LAB_ASC
  4934 C466 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4935 C469 F0 08			BEQ	LAB_23A8		; if null do function call error then warm start
  4936
  4937 C46B A0 00			LDY	#$00			; set index to first character
  4938 C46D B1 31			LDA	(ut1_pl),Y		; get byte
  4939 C46F A8				TAY				; copy to Y
  4940 C470 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4941
  4942 				; do function call error then warm start
  4943 C473			LAB_23A8
  4944 C473 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  4945
  4946 				; scan and get byte parameter
  4947 C476			LAB_SGBY
  4948 C476 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4949
  4950 				; get byte parameter
  4951 C479			LAB_GTBY
  4952 C479 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4953 									; else do type mismatch
  4954
  4955 				; evaluate byte expression, result in X
  4956 C47C			LAB_EVBY
  4957 C47C 20 81 BE			JSR	LAB_EVPI		; evaluate integer expression (no check)
  4958
  4959 C47F A4 6E			LDY	FAC1_2			; get FAC1 mantissa2
  4960 C481 D0 F0			BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  4961
  4962 C483 A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  4963 C485 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4964
  4965 				; perform VAL()
  4966 C488			LAB_VAL
  4967 C488 20 61 C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4968 C48B D0 03			BNE	LAB_23C5		; branch if not null string
  4969
  4970 									; string was null so set result = $00
  4971 C48D 4C 3D C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  4972
  4973 C490			LAB_23C5
  4974 C490 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  4975 C492 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  4976 C494 86 7A			STX	Btmpl			; save BASIC execute pointer low byte
  4977 C496 84 7B			STY	Btmph			; save BASIC execute pointer high byte
  4978 C498 A6 31			LDX	ut1_pl			; get string pointer low byte
  4979 C49A 86 83			STX	Bpntrl			; save as BASIC execute pointer low byte
  4980 C49C 18				CLC				; clear carry
  4981 C49D 65 31			ADC	ut1_pl			; add string length
  4982 C49F 85 33			STA	ut2_pl			; save string end low byte
  4983 C4A1 A5 32			LDA	ut1_ph			; get string pointer high byte
  4984 C4A3 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4985 C4A5 69 00			ADC	#$00			; add carry to high byte
  4986 C4A7 85 34			STA	ut2_ph			; save string end high byte
  4987 C4A9 A0 00			LDY	#$00			; set index to $00
  4988 C4AB B1 33			LDA	(ut2_pl),Y		; get string end +1 byte
  4989 C4AD 48				PHA				; push it
  4990 C4AE 98				TYA				; clear A
  4991 C4AF 91 33			STA	(ut2_pl),Y		; terminate string with $00
  4992 C4B1 20 82 00			JSR	LAB_GBYT		; scan memory
  4993 C4B4 20 93 C9			JSR	LAB_2887		; get FAC1 from string
  4994 C4B7 68				PLA				; restore string end +1 byte
  4995 C4B8 A0 00			LDY	#$00			; set index to zero
  4996 C4BA 91 33			STA	(ut2_pl),Y		; put string end byte back
  4997
  4998 				; restore BASIC execute pointer from temp (Btmpl/Btmph)
  4999 C4BC			LAB_23F3
  5000 C4BC A6 7A			LDX	Btmpl			; get BASIC execute pointer low byte back
  5001 C4BE A4 7B			LDY	Btmph			; get BASIC execute pointer high byte back
  5002 C4C0 86 83			STX	Bpntrl			; save BASIC execute pointer low byte
  5003 C4C2 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  5004 C4C4 60				RTS
  5005
  5006 				; get two parameters for POKE or WAIT
  5007 C4C5			LAB_GADB
  5008 C4C5 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5009 									; else do type mismatch
  5010 C4C8 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5011
  5012 				; scan for ',' and get byte, else do Syntax error then warm start
  5013 C4CB			LAB_SCGB
  5014 C4CB 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5015 C4CE A5 12			LDA	Itemph			; save temporary integer high byte
  5016 C4D0 48				PHA				; on stack
  5017 C4D1 A5 11			LDA	Itempl			; save temporary integer low byte
  5018 C4D3 48				PHA				; on stack
  5019 C4D4 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  5020 C4D7 68				PLA				; pull low byte
  5021 C4D8 85 11			STA	Itempl			; restore temporary integer low byte
  5022 C4DA 68				PLA				; pull high byte
  5023 C4DB 85 12			STA	Itemph			; restore temporary integer high byte
  5024 C4DD 60				RTS
  5025
  5026 				; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5027 				; -ve and converts it into a right truncated integer in Itempl and Itemph
  5028
  5029 				; save unsigned 16 bit integer part of FAC1 in temporary integer
  5030 C4DE			LAB_F2FX
  5031 C4DE A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5032 C4E0 C9 98			CMP	#$98			; compare with exponent = 2^24
  5033 C4E2 B0 8F			BCS	LAB_23A8		; if >= do function call error then warm start
  5034
  5035 C4E4			LAB_F2FU
  5036 C4E4 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5037 C4E7 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5038 C4E9 A4 6F			LDY	FAC1_3			; get FAC1 mantissa3
  5039 C4EB 84 11			STY	Itempl			; save temporary integer low byte
  5040 C4ED 85 12			STA	Itemph			; save temporary integer high byte
  5041 C4EF 60				RTS
  5042
  5043 				; perform PEEK()
  5044 C4F0			LAB_PEEK
  5045 C4F0 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5046 C4F3 A2 00			LDX	#$00			; clear index
  5047 C4F5 A1 11			LDA	(Itempl,X)		; get byte via temporary integer (addr)
  5048 C4F7 A8				TAY				; copy byte to Y
  5049 C4F8 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5050
  5051 				; perform POKE
  5052 C4FB			LAB_POKE
  5053 C4FB 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5054 C4FE 8A				TXA				; copy byte argument to A
  5055 C4FF A2 00			LDX	#$00			; clear index
  5056 C501 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  5057 C503 60				RTS
  5058
  5059 				; perform DEEK()
  5060 C504			LAB_DEEK
  5061 C504 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5062 C507 A2 00			LDX	#$00			; clear index
  5063 C509 A1 11			LDA	(Itempl,X)		; PEEK low byte
  5064 C50B A8				TAY				; copy to Y
  5065 C50C E6 11			INC	Itempl			; increment pointer low byte
  5066 C50E D0 02			BNE	Deekh			; skip high increment if no rollover
  5067
  5068 C510 E6 12			INC	Itemph			; increment pointer high byte
  5069 C512			Deekh
  5070 C512 A1 11			LDA	(Itempl,X)		; PEEK high byte
  5071 C514 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  5072
  5073 				; perform DOKE
  5074 C517			LAB_DOKE
  5075 C517 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5076 									; else do type mismatch
  5077 C51A 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5078
  5079 C51D 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  5080 C51F 85 58			STA	Frnxth			; save pointer high byte
  5081
  5082 C521 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5083 C524 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5084 									; else do type mismatch
  5085 C527 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5086
  5087 C52A 98				TYA				; copy value low byte (float to fixed returns word in AY)
  5088 C52B A2 00			LDX	#$00			; clear index
  5089 C52D 81 57			STA	(Frnxtl,X)		; POKE low byte
  5090 C52F E6 57			INC	Frnxtl			; increment pointer low byte
  5091 C531 D0 02			BNE	Dokeh			; skip high increment if no rollover
  5092
  5093 C533 E6 58			INC	Frnxth			; increment pointer high byte
  5094 C535			Dokeh
  5095 C535 A5 12			LDA	Itemph			; get value high byte
  5096 C537 81 57			STA	(Frnxtl,X)		; POKE high byte
  5097 C539 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5098
  5099 				; perform SWAP
  5100 C53C			LAB_SWAP
  5101 C53C 20 89 BD			JSR	LAB_GVAR		; get var1 address
  5102 C53F 85 57			STA	Lvarpl			; save var1 address low byte
  5103 C541 84 58			STY	Lvarph			; save var1 address high byte
  5104 C543 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  5105 C545 48				PHA				; save data type flag
  5106
  5107 C546 20 DB BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  5108 C549 20 89 BD			JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
  5109 C54C 68				PLA				; pull var1 data type flag
  5110 C54D 45 1F			EOR	Dtypef			; compare with var2 data type
  5111 C54F D0 10			BNE	SwapErr			; exit if not both the same type  (changed 2022/05/16 by Joerg Walke)
  5112
  5113 C551 A0 03			LDY	#$03			; four bytes to swap (either value or descriptor+1)
  5114 C553			SwapLp
  5115 C553 B1 57			LDA	(Lvarpl),Y		; get byte from var1
  5116 C555 AA				TAX				; save var1 byte
  5117 C556 B1 55			LDA	(Cvaral),Y		; get byte from var2
  5118 C558 91 57			STA	(Lvarpl),Y		; save byte to var1
  5119 C55A 8A				TXA				; restore var1 byte
  5120 C55B 91 55			STA	(Cvaral),Y		; save byte to var2
  5121 C55D 88				DEY				; decrement index
  5122 C55E 10 F3			BPL	SwapLp			; loop until done
  5123
  5124 C560 60				RTS
  5125
  5126 C561			SwapErr
  5127 C561 4C B9 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  5128
  5129 				; perform CALL
  5130 C564			LAB_CALL
  5131 C564 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5132 									; else do type mismatch
  5133 C567 20 DE C4			JSR	LAB_F2FX		; convert floating-to-fixed
  5134 C56A A9 C5			LDA	#>CallExit		; set return address high byte
  5135 C56C 48				PHA				; put on stack
  5136 C56D A9 72			LDA	#<CallExit-1		; set return address low byte
  5137 C56F 48				PHA				; put on stack
  5138 C570 6C 11 00			JMP	(Itempl)		; do indirect jump to user routine
  5139
  5140 				; if the called routine exits correctly then it will return to here. this will then get
  5141 				; the next byte for the interpreter and return
  5142
  5143 C573			CallExit
  5144 C573 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  5145
  5146 				; perform WAIT
  5147 C576			LAB_WAIT
  5148 C576 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5149 C579 86 57			STX	Frnxtl			; save byte
  5150 C57B A2 00			LDX	#$00			; clear mask
  5151 C57D 20 82 00			JSR	LAB_GBYT		; scan memory
  5152 C580 F0 03			BEQ	LAB_2441		; skip if no third argument
  5153
  5154 C582 20 CB C4			JSR	LAB_SCGB		; scan for ',' and get byte, else SN error then warm start
  5155 C585			LAB_2441
  5156 C585 86 58			STX	Frnxth			; save EOR argument
  5157 C587			LAB_2445
  5158 C587 B1 11			LDA	(Itempl),Y		; get byte via temporary integer (addr)
  5159 C589 45 58			EOR	Frnxth			; EOR with second argument (mask)
  5160 C58B 25 57			AND	Frnxtl			; AND with first argument (byte)
  5161 C58D F0 F8			BEQ	LAB_2445		; loop if result is zero
  5162
  5163 C58F			LAB_244D
  5164 C58F 60				RTS
  5165
  5166 				; perform subtraction, FAC1 from (AY)
  5167 C590			LAB_2455
  5168 C590 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5169
  5170 				; perform subtraction, FAC1 from FAC2
  5171
  5172 C593			LAB_SUBTRACT
  5173 C593 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5174 C595 49 FF			EOR	#$FF			; complement it
  5175 C597 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5176 C599 45 77			EOR	FAC2_s			; EOR with FAC2 sign (b7)
  5177 C59B 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5178 C59D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5179 C59F 4C AE C5			JMP	LAB_ADD			; go add FAC2 to FAC1
  5180
  5181 				; perform addition
  5182 C5A2			LAB_2467
  5183 C5A2 20 C7 C6			JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  5184 C5A5 90 4D			BCC	LAB_24A8		;.go subtract mantissas
  5185
  5186 				; add 0.5 to FAC1
  5187 C5A7			LAB_244E
  5188 C5A7 A9 FD			LDA	#<LAB_2A96		; set 0.5 pointer low byte
  5189 C5A9 A0 D3			LDY	#>LAB_2A96		; set 0.5 pointer high byte
  5190
  5191 				; add (AY) to FAC1
  5192 C5AB			LAB_246C
  5193 C5AB 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5194
  5195 				; add FAC2 to FAC1
  5196 C5AE			LAB_ADD
  5197 C5AE D0 10			BNE	LAB_2474		; branch if FAC1 was not zero
  5198
  5199 				; copy FAC2 to FAC1
  5200 C5B0			LAB_279B
  5201 C5B0 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  5202
  5203 				; save FAC1 sign and copy ABS(FAC2) to FAC1
  5204 C5B2			LAB_279D
  5205 C5B2 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5206 C5B4 A2 04			LDX	#$04			; 4 bytes to copy
  5207 C5B6			LAB_27A1
  5208 C5B6 B5 72			LDA	FAC1_o,X		; get byte from FAC2,X
  5209 C5B8 95 6B			STA	FAC1_e-1,X		; save byte at FAC1,X
  5210 C5BA CA				DEX				; decrement count
  5211 C5BB D0 F9			BNE	LAB_27A1		; loop if not all done
  5212
  5213 C5BD 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5214 C5BF 60				RTS
  5215 									; FAC1 is non zero
  5216 C5C0			LAB_2474
  5217 C5C0 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5218 C5C2 86 63			STX	FAC2_r			; save as FAC2 rounding byte
  5219 C5C4 A2 73			LDX	#FAC2_e			; set index to FAC2 exponent addr
  5220 C5C6 A5 73			LDA	FAC2_e			; get FAC2 exponent
  5221 C5C8			LAB_247C
  5222 C5C8 A8				TAY				; copy exponent
  5223 C5C9 F0 C4			BEQ	LAB_244D		; exit if zero
  5224
  5225 C5CB 38				SEC				; set carry for subtract
  5226 C5CC E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5227 C5CE F0 24			BEQ	LAB_24A8		; branch if = (go add mantissa)
  5228
  5229 C5D0 90 12			BCC	LAB_2498		; branch if <
  5230
  5231 									; FAC2>FAC1
  5232 C5D2 84 6C			STY	FAC1_e			; save FAC1 exponent
  5233 C5D4 A4 77			LDY	FAC2_s			; get FAC2 sign (b7)
  5234 C5D6 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5235 C5D8 49 FF			EOR	#$FF			; complement A
  5236 C5DA 69 00			ADC	#$00			; +1 (twos complement, carry is set)
  5237 C5DC A0 00			LDY	#$00			; clear Y
  5238 C5DE 84 63			STY	FAC2_r			; clear FAC2 rounding byte
  5239 C5E0 A2 6C			LDX	#FAC1_e			; set index to FAC1 exponent addr
  5240 C5E2 D0 04			BNE	LAB_249C		; branch always
  5241
  5242 C5E4			LAB_2498
  5243 C5E4 A0 00			LDY	#$00			; clear Y
  5244 C5E6 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5245 C5E8			LAB_249C
  5246 C5E8 C9 F9			CMP	#$F9			; compare exponent diff with $F9
  5247 C5EA 30 B6			BMI	LAB_2467		; branch if range $79-$F8
  5248
  5249 C5EC A8				TAY				; copy exponent difference to Y
  5250 C5ED A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5251 C5EF 56 01			LSR	PLUS_1,X		; shift FAC? mantissa1
  5252 C5F1 20 DE C6			JSR	LAB_2592		; shift FACX Y times right
  5253
  5254 									; exponents are equal now do mantissa subtract
  5255 C5F4			LAB_24A8
  5256 C5F4 24 78			BIT	FAC_sc			; test sign compare (FAC1 EOR FAC2)
  5257 C5F6 10 4C			BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  5258
  5259 C5F8 A0 6C			LDY	#FAC1_e			; set index to FAC1 exponent addr
  5260 C5FA E0 73			CPX	#FAC2_e			; compare X to FAC2 exponent addr
  5261 C5FC F0 02			BEQ	LAB_24B4		; branch if =
  5262
  5263 C5FE A0 73			LDY	#FAC2_e			; else set index to FAC2 exponent addr
  5264
  5265 									; subtract smaller from bigger (take sign of bigger)
  5266 C600			LAB_24B4
  5267 C600 38				SEC				; set carry for subtract
  5268 C601 49 FF			EOR	#$FF			; ones complement A
  5269 C603 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5270 C605 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5271 C607 B9 03 00			LDA	PLUS_3,Y		; get FACY mantissa3
  5272 C60A F5 03			SBC	PLUS_3,X		; subtract FACX mantissa3
  5273 C60C 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5274 C60E B9 02 00			LDA	PLUS_2,Y		; get FACY mantissa2
  5275 C611 F5 02			SBC	PLUS_2,X		; subtract FACX mantissa2
  5276 C613 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5277 C615 B9 01 00			LDA	PLUS_1,Y		; get FACY mantissa1
  5278 C618 F5 01			SBC	PLUS_1,X		; subtract FACX mantissa1
  5279 C61A 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5280
  5281 				; do ABS and normalise FAC1
  5282 C61C			LAB_24D0
  5283 C61C B0 03			BCS	LAB_24D5		; branch if number is +ve
  5284
  5285 C61E 20 83 C6			JSR	LAB_2537		; negate FAC1
  5286
  5287 				; normalise FAC1
  5288 C621			LAB_24D5
  5289 C621 A0 00			LDY	#$00			; clear Y
  5290 C623 98				TYA				; clear A
  5291 C624 18				CLC				; clear carry for add
  5292 C625			LAB_24D9
  5293 C625 A6 6D			LDX	FAC1_1			; get FAC1 mantissa1
  5294 C627 D0 3E			BNE	LAB_251B		; if not zero normalise FAC1
  5295
  5296 C629 A6 6E			LDX	FAC1_2			; get FAC1 mantissa2
  5297 C62B 86 6D			STX	FAC1_1			; save FAC1 mantissa1
  5298 C62D A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  5299 C62F 86 6E			STX	FAC1_2			; save FAC1 mantissa2
  5300 C631 A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5301 C633 86 6F			STX	FAC1_3			; save FAC1 mantissa3
  5302 C635 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5303 C637 69 08			ADC	#$08			; add x to exponent offset
  5304 C639 C9 18			CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5305 C63B D0 E8			BNE	LAB_24D9		; loop if not max
  5306
  5307 				; clear FAC1 exponent and sign
  5308 C63D			LAB_24F1
  5309 C63D A9 00			LDA	#$00			; clear A
  5310 C63F			LAB_24F3
  5311 C63F 85 6C			STA	FAC1_e			; set FAC1 exponent
  5312
  5313 				; save FAC1 sign
  5314 C641			LAB_24F5
  5315 C641 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5316 C643 60				RTS
  5317
  5318 				; add FAC2 mantissa to FAC1 mantissa
  5319 C644			LAB_24F8
  5320 C644 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5321 C646 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5322 C648 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5323 C64A 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5324 C64C 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5325 C64E A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5326 C650 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5327 C652 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5328 C654 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5329 C656 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5330 C658 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5331 C65A B0 1A			BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  5332
  5333 C65C 60				RTS				; else just exit
  5334
  5335 C65D			LAB_2511
  5336 C65D 69 01			ADC	#$01			; add 1 to exponent offset
  5337 C65F 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5338 C661 26 6F			ROL	FAC1_3			; shift FAC1 mantissa3
  5339 C663 26 6E			ROL	FAC1_2			; shift FAC1 mantissa2
  5340 C665 26 6D			ROL	FAC1_1			; shift FAC1 mantissa1
  5341
  5342 				; normalise FAC1
  5343 C667			LAB_251B
  5344 C667 10 F4			BPL	LAB_2511		; loop if not normalised
  5345
  5346 C669 38				SEC				; set carry for subtract
  5347 C66A E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5348 C66C B0 CF			BCS	LAB_24F1		; branch if underflow (set result = $0)
  5349
  5350 C66E 49 FF			EOR	#$FF			; complement exponent
  5351 C670 69 01			ADC	#$01			; +1 (twos complement)
  5352 C672 85 6C			STA	FAC1_e			; save FAC1 exponent
  5353 					
  5354 				; test and normalise FAC1 for C=0/1
  5355 C674			LAB_2528
  5356 C674 90 0C			BCC	LAB_2536		; exit if no overflow
  5357
  5358 				; normalise FAC1 for C=1
  5359 C676			LAB_252A
  5360 C676 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5361 C678 F0 36			BEQ	LAB_2564		; if zero do overflow error and warm start
  5362
  5363 C67A 66 6D			ROR	FAC1_1			; shift FAC1 mantissa1
  5364 C67C 66 6E			ROR	FAC1_2			; shift FAC1 mantissa2
  5365 C67E 66 6F			ROR	FAC1_3			; shift FAC1 mantissa3
  5366 C680 66 79			ROR	FAC1_r			; shift FAC1 rounding byte
  5367 C682			LAB_2536
  5368 C682 60				RTS
  5369
  5370 				; negate FAC1
  5371 C683			LAB_2537
  5372 C683 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5373 C685 49 FF			EOR	#$FF			; complement it
  5374 C687 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5375
  5376 				; twos complement FAC1 mantissa
  5377 C689			LAB_253D
  5378 C689 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5379 C68B 49 FF			EOR	#$FF			; complement it
  5380 C68D 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5381 C68F A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5382 C691 49 FF			EOR	#$FF			; complement it
  5383 C693 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5384 C695 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5385 C697 49 FF			EOR	#$FF			; complement it
  5386 C699 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5387 C69B A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5388 C69D 49 FF			EOR	#$FF			; complement it
  5389 C69F 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5390 C6A1 E6 79			INC	FAC1_r			; increment FAC1 rounding byte
  5391 C6A3 D0 0A			BNE	LAB_2563		; exit if no overflow
  5392
  5393 				; increment FAC1 mantissa
  5394 C6A5			LAB_2559
  5395 C6A5 E6 6F			INC	FAC1_3			; increment FAC1 mantissa3
  5396 C6A7 D0 06			BNE	LAB_2563		; finished if no rollover
  5397
  5398 C6A9 E6 6E			INC	FAC1_2			; increment FAC1 mantissa2
  5399 C6AB D0 02			BNE	LAB_2563		; finished if no rollover
  5400
  5401 C6AD E6 6D			INC	FAC1_1			; increment FAC1 mantissa1
  5402 C6AF			LAB_2563
  5403 C6AF 60				RTS
  5404
  5405 				; do overflow error (overflow exit)
  5406 C6B0			LAB_2564
  5407 C6B0 A2 0A			LDX	#$0A			; error code $0A ('Overflow' error)
  5408 C6B2 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5409
  5410 				; shift FCAtemp << A+8 times
  5411 C6B5			LAB_2569
  5412 C6B5 A2 34			LDX	#FACt_1-1		; set offset to FACtemp
  5413 C6B7			LAB_256B
  5414 C6B7 B4 03			LDY	PLUS_3,X		; get FACX mantissa3
  5415 C6B9 84 79			STY	FAC1_r			; save as FAC1 rounding byte
  5416 C6BB B4 02			LDY	PLUS_2,X		; get FACX mantissa2
  5417 C6BD 94 03			STY	PLUS_3,X		; save FACX mantissa3
  5418 C6BF B4 01			LDY	PLUS_1,X		; get FACX mantissa1
  5419 C6C1 94 02			STY	PLUS_2,X		; save FACX mantissa2
  5420 C6C3 A4 72			LDY	FAC1_o			; get FAC1 overflow byte
  5421 C6C5 94 01			STY	PLUS_1,X		; save FACX mantissa1
  5422
  5423 				; shift FACX -A times right (> 8 shifts)
  5424 C6C7			LAB_257B
  5425 C6C7 69 08			ADC	#$08			; add 8 to shift count
  5426 C6C9 30 EC			BMI	LAB_256B		; go do 8 shift if still -ve
  5427
  5428 C6CB F0 EA			BEQ	LAB_256B		; go do 8 shift if zero
  5429
  5430 C6CD E9 08			SBC	#$08			; else subtract 8 again
  5431 C6CF A8				TAY				; save count to Y
  5432 C6D0 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5433 C6D2 B0 12			BCS	LAB_259A		;.
  5434
  5435 C6D4			LAB_2588
  5436 C6D4 16 01			ASL	PLUS_1,X		; shift FACX mantissa1
  5437 C6D6 90 02			BCC	LAB_258E		; branch if +ve
  5438
  5439 C6D8 F6 01			INC	PLUS_1,X		; this sets b7 eventually
  5440 C6DA			LAB_258E
  5441 C6DA 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5442 C6DC 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5443
  5444 				; shift FACX Y times right
  5445 C6DE			LAB_2592
  5446 C6DE 76 02			ROR	PLUS_2,X		; shift FACX mantissa2
  5447 C6E0 76 03			ROR	PLUS_3,X		; shift FACX mantissa3
  5448 C6E2 6A				ROR				; shift FACX rounding byte
  5449 C6E3 C8				INY				; increment exponent diff
  5450 C6E4 D0 EE			BNE	LAB_2588		; branch if range adjust not complete
  5451
  5452 C6E6			LAB_259A
  5453 C6E6 18				CLC				; just clear it
  5454 C6E7 60				RTS
  5455
  5456 				; perform LOG()
  5457 C6E8			LAB_LOG
  5458 C6E8 20 D6 C8			JSR	LAB_27CA		; test sign and zero
  5459 C6EB F0 02			BEQ	LAB_25C4		; if zero do function call error then warm start
  5460
  5461 C6ED 10 03			BPL	LAB_25C7		; skip error if +ve
  5462
  5463 C6EF			LAB_25C4
  5464 C6EF 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start (-ve)
  5465
  5466 C6F2			LAB_25C7
  5467 C6F2 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5468 C6F4 E9 7F			SBC	#$7F			; normalise it
  5469 C6F6 48				PHA				; save it
  5470 C6F7 A9 80			LDA	#$80			; set exponent to zero
  5471 C6F9 85 6C			STA	FAC1_e			; save FAC1 exponent
  5472 C6FB A9 7D			LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5473 C6FD A0 D3			LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5474 C6FF 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5475 C702 A9 81			LDA	#<LAB_25B1		; set root2 pointer low byte
  5476 C704 A0 D3			LDY	#>LAB_25B1		; set root2 pointer high byte
  5477 C706 20 EE C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5478 C709 A9 F4			LDA	#<LAB_259C		; set 1 pointer low byte
  5479 C70B A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  5480 C70D 20 90 C5			JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5481 C710 A9 70			LDA	#<LAB_25A0		; set pointer low byte to counter
  5482 C712 A0 D3			LDY	#>LAB_25A0		; set pointer high byte to counter
  5483 C714 20 3E CC			JSR	LAB_2B6E		; ^2 then series evaluation
  5484 C717 A9 85			LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5485 C719 A0 D3			LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5486 C71B 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  5487 C71E 68				PLA				; restore FAC1 exponent
  5488 C71F 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  5489 C722 A9 89			LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5490 C724 A0 D3			LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5491
  5492 				; do convert AY, FCA1*(AY)
  5493 C726			LAB_25FB
  5494 C726 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5495 C729			LAB_MULTIPLY
  5496 C729 F0 4C			BEQ	LAB_264C		; exit if zero
  5497
  5498 C72B 20 9E C7			JSR	LAB_2673		; test and adjust accumulators
  5499 C72E A9 00			LDA	#$00			; clear A
  5500 C730 85 35			STA	FACt_1			; clear temp mantissa1
  5501 C732 85 36			STA	FACt_2			; clear temp mantissa2
  5502 C734 85 37			STA	FACt_3			; clear temp mantissa3
  5503 C736 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5504 C738 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5505 C73B A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5506 C73D 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5507 C740 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5508 C742 20 4D C7			JSR	LAB_2622		; go do shift/add FAC2
  5509 C745 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5510 C747 20 52 C7			JSR	LAB_2627		; go do shift/add FAC2
  5511 C74A 4C 5B C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5512
  5513 C74D			LAB_2622
  5514 C74D D0 03			BNE	LAB_2627		; branch if byte <> zero
  5515
  5516 C74F 4C B5 C6			JMP	LAB_2569		; shift FCAtemp << A+8 times
  5517
  5518 									; else do shift and add
  5519 C752			LAB_2627
  5520 C752 4A				LSR				; shift byte
  5521 C753 09 80			ORA	#$80			; set top bit (mark for 8 times)
  5522 C755			LAB_262A
  5523 C755 A8				TAY				; copy result
  5524 C756 90 13			BCC	LAB_2640		; skip next if bit was zero
  5525
  5526 C758 18				CLC				; clear carry for add
  5527 C759 A5 37			LDA	FACt_3			; get temp mantissa3
  5528 C75B 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5529 C75D 85 37			STA	FACt_3			; save temp mantissa3
  5530 C75F A5 36			LDA	FACt_2			; get temp mantissa2
  5531 C761 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5532 C763 85 36			STA	FACt_2			; save temp mantissa2
  5533 C765 A5 35			LDA	FACt_1			; get temp mantissa1
  5534 C767 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5535 C769 85 35			STA	FACt_1			; save temp mantissa1
  5536 C76B			LAB_2640
  5537 C76B 66 35			ROR	FACt_1			; shift temp mantissa1
  5538 C76D 66 36			ROR	FACt_2			; shift temp mantissa2
  5539 C76F 66 37			ROR	FACt_3			; shift temp mantissa3
  5540 C771 66 79			ROR	FAC1_r			; shift temp rounding byte
  5541 C773 98				TYA				; get byte back
  5542 C774 4A				LSR				; shift byte
  5543 C775 D0 DE			BNE	LAB_262A		; loop if all bits not done
  5544
  5545 C777			LAB_264C
  5546 C777 60				RTS
  5547
  5548 				; unpack memory (AY) into FAC2
  5549 C778			LAB_264D
  5550 C778 85 31			STA	ut1_pl			; save pointer low byte
  5551 C77A 84 32			STY	ut1_ph			; save pointer high byte
  5552 C77C A0 03			LDY	#$03			; 4 bytes to get (0-3)
  5553 C77E B1 31			LDA	(ut1_pl),Y		; get mantissa3
  5554 C780 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5555 C782 88				DEY				; decrement index
  5556 C783 B1 31			LDA	(ut1_pl),Y		; get mantissa2
  5557 C785 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5558 C787 88				DEY				; decrement index
  5559 C788 B1 31			LDA	(ut1_pl),Y		; get mantissa1+sign
  5560 C78A 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  5561 C78C 45 70			EOR	FAC1_s			; EOR with FAC1 sign (b7)
  5562 C78E 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5563 C790 A5 77			LDA	FAC2_s			; recover FAC2 sign (b7)
  5564 C792 09 80			ORA	#$80			; set 1xxx xxx (set normal bit)
  5565 C794 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5566 C796 88				DEY				; decrement index
  5567 C797 B1 31			LDA	(ut1_pl),Y		; get exponent byte
  5568 C799 85 73			STA	FAC2_e			; save FAC2 exponent
  5569 C79B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5570 C79D 60				RTS
  5571
  5572 				; test and adjust accumulators
  5573 C79E			LAB_2673
  5574 C79E A5 73			LDA	FAC2_e			; get FAC2 exponent
  5575 C7A0			LAB_2675
  5576 C7A0 F0 1D			BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5577
  5578 C7A2 18				CLC				; clear carry for add
  5579 C7A3 65 6C			ADC	FAC1_e			; add FAC1 exponent
  5580 C7A5 90 04			BCC	LAB_2680		; branch if sum of exponents <$0100
  5581
  5582 C7A7 30 31			BMI	LAB_269B		; do overflow error
  5583
  5584 C7A9 18				CLC				; clear carry for the add
  5585 C7AA 2C				.byte	$2C			; makes next line BIT $1410
  5586 C7AB			LAB_2680
  5587 C7AB 10 12			BPL	LAB_2696		; if +ve go handle underflow
  5588
  5589 C7AD 69 80			ADC	#$80			; adjust exponent
  5590 C7AF 85 6C			STA	FAC1_e			; save FAC1 exponent
  5591 C7B1 D0 03			BNE	LAB_268B		; branch if not zero
  5592
  5593 C7B3 4C 41 C6			JMP	LAB_24F5		; save FAC1 sign and return
  5594
  5595 C7B6			LAB_268B
  5596 C7B6 A5 78			LDA	FAC_sc			; get sign compare (FAC1 EOR FAC2)
  5597 C7B8 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5598 C7BA			LAB_268F
  5599 C7BA 60				RTS
  5600
  5601 				; handle overflow and underflow
  5602 C7BB			LAB_2690
  5603 C7BB A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5604 C7BD 10 1B			BPL	LAB_269B		; do overflow error
  5605
  5606 									; handle underflow
  5607 C7BF			LAB_2696
  5608 C7BF 68				PLA				; pop return address low byte
  5609 C7C0 68				PLA				; pop return address high byte
  5610 C7C1 4C 3D C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5611
  5612 				; multiply by 10
  5613 C7C4			LAB_269E
  5614 C7C4 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5615 C7C7 AA				TAX				; copy exponent (set the flags)
  5616 C7C8 F0 F0			BEQ	LAB_268F		; exit if zero
  5617
  5618 C7CA 18				CLC				; clear carry for add
  5619 C7CB 69 02			ADC	#$02			; add two to exponent (*4)
  5620 C7CD B0 0B			BCS	LAB_269B		; do overflow error if > $FF
  5621
  5622 C7CF A2 00			LDX	#$00			; clear byte
  5623 C7D1 86 78			STX	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  5624 C7D3 20 C8 C5			JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5625 C7D6 E6 6C			INC	FAC1_e			; increment FAC1 exponent (*10)
  5626 C7D8 D0 E0			BNE	LAB_268F		; if non zero just do RTS
  5627
  5628 C7DA			LAB_269B
  5629 C7DA 4C B0 C6			JMP	LAB_2564		; do overflow error and warm start
  5630
  5631 				; divide by 10
  5632 C7DD			LAB_26B9
  5633 C7DD 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5634 C7E0 A9 05			LDA	#<LAB_26B5		; set pointer to 10d low addr
  5635 C7E2 A0 D4			LDY	#>LAB_26B5		; set pointer to 10d high addr
  5636 C7E4 A2 00			LDX	#$00			; clear sign
  5637
  5638 				; divide by (AY) (X=sign)
  5639 C7E6			LAB_26C2
  5640 C7E6 86 78			STX	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5641 C7E8 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5642 C7EB 4C F1 C7			JMP	LAB_DIVIDE		; do FAC2/FAC1
  5643
  5644 									; Perform divide-by
  5645 				; convert AY and do (AY)/FAC1
  5646 C7EE			LAB_26CA
  5647 C7EE 20 78 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5648
  5649 				; Perform divide-into
  5650 C7F1			LAB_DIVIDE
  5651 C7F1 F0 63			BEQ	LAB_2737		; if zero go do /0 error
  5652
  5653 C7F3 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5654 C7F6 A9 00			LDA	#$00			; clear A
  5655 C7F8 38				SEC				; set carry for subtract
  5656 C7F9 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent (2s complement)
  5657 C7FB 85 6C			STA	FAC1_e			; save FAC1 exponent
  5658 C7FD 20 9E C7			JSR	LAB_2673		; test and adjust accumulators
  5659 C800 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5660 C802 F0 D6			BEQ	LAB_269B		; if zero do overflow error
  5661
  5662 C804 A2 FF			LDX	#$FF			; set index for pre increment
  5663 C806 A9 01			LDA	#$01			; set bit to flag byte save
  5664 C808			LAB_26E4
  5665 C808 A4 74			LDY	FAC2_1			; get FAC2 mantissa1
  5666 C80A C4 6D			CPY	FAC1_1			; compare FAC1 mantissa1
  5667 C80C D0 0A			BNE	LAB_26F4		; branch if <>
  5668
  5669 C80E A4 75			LDY	FAC2_2			; get FAC2 mantissa2
  5670 C810 C4 6E			CPY	FAC1_2			; compare FAC1 mantissa2
  5671 C812 D0 04			BNE	LAB_26F4		; branch if <>
  5672
  5673 C814 A4 76			LDY	FAC2_3			; get FAC2 mantissa3
  5674 C816 C4 6F			CPY	FAC1_3			; compare FAC1 mantissa3
  5675 C818			LAB_26F4
  5676 C818 08				PHP				; save FAC2-FAC1 compare status
  5677 C819 2A				ROL				; shift the result byte
  5678 C81A 90 0E			BCC	LAB_2702		; if no carry skip the byte save
  5679
  5680 C81C A0 01			LDY	#$01			; set bit to flag byte save
  5681 C81E E8				INX				; else increment the index to FACt
  5682 C81F E0 02			CPX	#$02			; compare with the index to FACt_3
  5683 C821 30 04			BMI	LAB_2701		; if not last byte just go save it
  5684
  5685 C823 D0 28			BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5686 									; return
  5687
  5688 C825 A0 40			LDY	#$40			; set bit to flag byte save for the rounding byte
  5689 C827			LAB_2701
  5690 C827 95 35			STA	FACt_1,X		; write result byte to FACt_1 + index
  5691 C829 98				TYA				; copy the next save byte flag
  5692 C82A			LAB_2702
  5693 C82A 28				PLP				; restore FAC2-FAC1 compare status
  5694 C82B 90 14			BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5695
  5696 C82D A8				TAY				; save FAC2-FAC1 compare status
  5697 C82E A5 76			LDA	FAC2_3			; get FAC2 mantissa3
  5698 C830 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5699 C832 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5700 C834 A5 75			LDA	FAC2_2			; get FAC2 mantissa2
  5701 C836 E5 6E			SBC	FAC1_2			; subtract FAC1 mantissa2
  5702 C838 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5703 C83A A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  5704 C83C E5 6D			SBC	FAC1_1			; subtract FAC1 mantissa1
  5705 C83E 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5706 C840 98				TYA				; restore FAC2-FAC1 compare status
  5707
  5708 									; FAC2 = FAC2*2
  5709 C841			LAB_2704
  5710 C841 06 76			ASL	FAC2_3			; shift FAC2 mantissa3
  5711 C843 26 75			ROL	FAC2_2			; shift FAC2 mantissa2
  5712 C845 26 74			ROL	FAC2_1			; shift FAC2 mantissa1
  5713 C847 B0 CF			BCS	LAB_26F4		; loop with no compare
  5714
  5715 C849 30 BD			BMI	LAB_26E4		; loop with compare
  5716
  5717 C84B 10 CB			BPL	LAB_26F4		; loop always with no compare
  5718
  5719 				; do A<<6, save as FAC1 rounding byte, normalise and return
  5720 C84D			LAB_272B
  5721 C84D 4A				LSR				; shift b1 - b0 ..
  5722 C84E 6A				ROR				; ..
  5723 C84F 6A				ROR				; .. to b7 - b6
  5724 C850 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5725 C852 28				PLP				; dump FAC2-FAC1 compare status
  5726 C853 4C 5B C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5727
  5728 				; do 'Divide by zero' error
  5729 C856			LAB_2737
  5730 C856 A2 14			LDX	#$14			; error code $14 ('Divide by zero' error)
  5731 C858 4C 0B B1			JMP	LAB_XERR		; do error #X, then warm start
  5732
  5733 				; copy temp to FAC1 and normalise
  5734 C85B			LAB_273C
  5735 C85B A5 35			LDA	FACt_1			; get temp mantissa1
  5736 C85D 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5737 C85F A5 36			LDA	FACt_2			; get temp mantissa2
  5738 C861 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5739 C863 A5 37			LDA	FACt_3			; get temp mantissa3
  5740 C865 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5741 C867 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  5742
  5743 				; unpack memory (AY) into FAC1
  5744 C86A			LAB_UFAC
  5745 C86A 85 31			STA	ut1_pl			; save pointer low byte
  5746 C86C 84 32			STY	ut1_ph			; save pointer high byte
  5747 C86E A0 03			LDY	#$03			; 4 bytes to do
  5748 C870 B1 31			LDA	(ut1_pl),Y		; get last byte
  5749 C872 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5750 C874 88				DEY				; decrement index
  5751 C875 B1 31			LDA	(ut1_pl),Y		; get last-1 byte
  5752 C877 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5753 C879 88				DEY				; decrement index
  5754 C87A B1 31			LDA	(ut1_pl),Y		; get second byte
  5755 C87C 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5756 C87E 09 80			ORA	#$80			; set 1xxx xxxx (add normal bit)
  5757 C880 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5758 C882 88				DEY				; decrement index
  5759 C883 B1 31			LDA	(ut1_pl),Y		; get first byte (exponent)
  5760 C885 85 6C			STA	FAC1_e			; save FAC1 exponent
  5761 C887 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5762 C889 60				RTS
  5763
  5764 				; pack FAC1 into Adatal
  5765 C88A			LAB_276E
  5766 C88A A2 64			LDX	#<Adatal		; set pointer low byte
  5767 C88C			LAB_2770
  5768 C88C A0 00			LDY	#>Adatal		; set pointer high byte
  5769 C88E F0 04			BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5770
  5771 				; pack FAC1 into (Lvarpl)
  5772 C890			LAB_PFAC
  5773 C890 A6 57			LDX	Lvarpl			; get destination pointer low byte
  5774 C892 A4 58			LDY	Lvarph			; get destination pointer high byte
  5775
  5776 				; pack FAC1 into (XY)
  5777 C894			LAB_2778
  5778 C894 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5779 C897 86 31			STX	ut1_pl			; save pointer low byte
  5780 C899 84 32			STY	ut1_ph			; save pointer high byte
  5781 C89B A0 03			LDY	#$03			; set index
  5782 C89D A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5783 C89F 91 31			STA	(ut1_pl),Y		; store in destination
  5784 C8A1 88				DEY				; decrement index
  5785 C8A2 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5786 C8A4 91 31			STA	(ut1_pl),Y		; store in destination
  5787 C8A6 88				DEY				; decrement index
  5788 C8A7 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5789 C8A9 09 7F			ORA	#$7F			; set bits x111 1111
  5790 C8AB 25 6D			AND	FAC1_1			; AND in FAC1 mantissa1
  5791 C8AD 91 31			STA	(ut1_pl),Y		; store in destination
  5792 C8AF 88				DEY				; decrement index
  5793 C8B0 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5794 C8B2 91 31			STA	(ut1_pl),Y		; store in destination
  5795 C8B4 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5796 C8B6 60				RTS
  5797
  5798 				; round and copy FAC1 to FAC2
  5799 C8B7			LAB_27AB
  5800 C8B7 20 C6 C8			JSR	LAB_27BA		; round FAC1
  5801
  5802 				; copy FAC1 to FAC2
  5803 C8BA			LAB_27AE
  5804 C8BA A2 05			LDX	#$05			; 5 bytes to copy
  5805 C8BC			LAB_27B0
  5806 C8BC B5 6B			LDA	FAC1_e-1,X		; get byte from FAC1,X
  5807 C8BE 95 72			STA	FAC1_o,X		; save byte at FAC2,X
  5808 C8C0 CA				DEX				; decrement count
  5809 C8C1 D0 F9			BNE	LAB_27B0		; loop if not all done
  5810
  5811 C8C3 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5812 C8C5			LAB_27B9
  5813 C8C5 60				RTS
  5814
  5815 				; round FAC1
  5816 C8C6			LAB_27BA
  5817 C8C6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5818 C8C8 F0 FB			BEQ	LAB_27B9		; exit if zero
  5819
  5820 C8CA 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5821 C8CC 90 F7			BCC	LAB_27B9		; exit if no overflow
  5822
  5823 				; round FAC1 (no check)
  5824 C8CE			LAB_27C2
  5825 C8CE 20 A5 C6			JSR	LAB_2559		; increment FAC1 mantissa
  5826 C8D1 D0 F2			BNE	LAB_27B9		; branch if no overflow
  5827
  5828 C8D3 4C 76 C6			JMP	LAB_252A		; normalise FAC1 for C=1 and return
  5829
  5830 				; get FAC1 sign
  5831 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5832 C8D6			LAB_27CA
  5833 C8D6 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5834 C8D8 F0 09			BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  5835
  5836 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5837 				; no = 0 check
  5838 C8DA			LAB_27CE
  5839 C8DA A5 70			LDA	FAC1_s			; else get FAC1 sign (b7)
  5840
  5841 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5842 				; no = 0 check, sign in A
  5843 C8DC			LAB_27D0
  5844 C8DC 2A				ROL				; move sign bit to carry
  5845 C8DD A9 FF			LDA	#$FF			; set byte for -ve result
  5846 C8DF B0 02			BCS	LAB_27D7		; return if sign was set (-ve)
  5847
  5848 C8E1 A9 01			LDA	#$01			; else set byte for +ve result
  5849 C8E3			LAB_27D7
  5850 C8E3 60				RTS
  5851
  5852 				; perform SGN()
  5853 C8E4			LAB_SGN
  5854 C8E4 20 D6 C8			JSR	LAB_27CA		; get FAC1 sign
  5855 									; return A=$FF/-ve A=$01/+ve
  5856 				; save A as integer byte
  5857 C8E7			LAB_27DB
  5858 C8E7 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5859 C8E9 A9 00			LDA	#$00			; clear A
  5860 C8EB 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5861 C8ED A2 88			LDX	#$88			; set exponent
  5862
  5863 				; set exp=X, clearFAC1 mantissa3 and normalise
  5864 C8EF			LAB_27E3
  5865 C8EF A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5866 C8F1 49 FF			EOR	#$FF			; complement it
  5867 C8F3 2A				ROL				; sign bit into carry
  5868
  5869 				; set exp=X, clearFAC1 mantissa3 and normalise
  5870 C8F4			LAB_STFA
  5871 C8F4 A9 00			LDA	#$00			; clear A
  5872 C8F6 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5873 C8F8 86 6C			STX	FAC1_e			; set FAC1 exponent
  5874 C8FA 85 79			STA	FAC1_r			; clear FAC1 rounding byte
  5875 C8FC 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  5876 C8FE 4C 1C C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5877
  5878 				; perform ABS()
  5879 C901			LAB_ABS
  5880 C901 46 70			LSR	FAC1_s			; clear FAC1 sign (put zero in b7)
  5881 C903 60				RTS
  5882
  5883 				; compare FAC1 with (AY)
  5884 				; returns A=$00 if FAC1 = (AY)
  5885 				; returns A=$01 if FAC1 > (AY)
  5886 				; returns A=$FF if FAC1 < (AY)
  5887 C904			LAB_27F8
  5888 C904 85 33			STA	ut2_pl			; save pointer low byte
  5889 C906			LAB_27FA
  5890 C906 84 34			STY	ut2_ph			; save pointer high byte
  5891 C908 A0 00			LDY	#$00			; clear index
  5892 C90A B1 33			LDA	(ut2_pl),Y		; get exponent
  5893 C90C C8				INY				; increment index
  5894 C90D AA				TAX				; copy (AY) exponent to X
  5895 C90E F0 C6			BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  5896 									; A=FF,C=1/-ve A=01,C=0/+ve
  5897
  5898 C910 B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5899 C912 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  5900 C914 30 C4			BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  5901 									; A=01,C=0/+ve and return
  5902
  5903 C916 E4 6C			CPX	FAC1_e			; compare (AY) exponent with FAC1 exponent
  5904 C918 D0 1A			BNE	LAB_2828		; branch if different
  5905
  5906 C91A B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5907 C91C 09 80			ORA	#$80			; normalise top bit
  5908 C91E C5 6D			CMP	FAC1_1			; compare with FAC1 mantissa1
  5909 C920 D0 12			BNE	LAB_2828		; branch if different
  5910
  5911 C922 C8				INY				; increment index
  5912 C923 B1 33			LDA	(ut2_pl),Y		; get mantissa2
  5913 C925 C5 6E			CMP	FAC1_2			; compare with FAC1 mantissa2
  5914 C927 D0 0B			BNE	LAB_2828		; branch if different
  5915
  5916 C929 C8				INY				; increment index
  5917 C92A A9 7F			LDA	#$7F			; set for 1/2 value rounding byte
  5918 C92C C5 79			CMP	FAC1_r			; compare with FAC1 rounding byte (set carry)
  5919 C92E B1 33			LDA	(ut2_pl),Y		; get mantissa3
  5920 C930 E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5921 C932 F0 28			BEQ	LAB_2850		; exit if mantissa3 equal
  5922
  5923 				; gets here if number <> FAC1
  5924 C934			LAB_2828
  5925 C934 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5926 C936 90 02			BCC	LAB_282E		; branch if FAC1 > (AY)
  5927
  5928 C938 49 FF			EOR	#$FF			; else toggle FAC1 sign
  5929 C93A			LAB_282E
  5930 C93A 4C DC C8			JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  5931
  5932 				; convert FAC1 floating-to-fixed
  5933 C93D			LAB_2831
  5934 C93D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5935 C93F F0 4A			BEQ	LAB_287F		; if zero go clear FAC1 and return
  5936
  5937 C941 38				SEC				; set carry for subtract
  5938 C942 E9 98			SBC	#$98			; subtract maximum integer range exponent
  5939 C944 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  5940 C946 10 09			BPL	LAB_2845		; branch if FAC1 +ve
  5941
  5942 									; FAC1 was -ve
  5943 C948 AA				TAX				; copy subtracted exponent
  5944 C949 A9 FF			LDA	#$FF			; overflow for -ve number
  5945 C94B 85 72			STA	FAC1_o			; set FAC1 overflow byte
  5946 C94D 20 89 C6			JSR	LAB_253D		; twos complement FAC1 mantissa
  5947 C950 8A				TXA				; restore subtracted exponent
  5948 C951			LAB_2845
  5949 C951 A2 6C			LDX	#FAC1_e			; set index to FAC1
  5950 C953 C9 F9			CMP	#$F9			; compare exponent result
  5951 C955 10 06			BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  5952
  5953 C957 20 C7 C6			JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  5954 C95A 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5955 C95C			LAB_2850
  5956 C95C 60				RTS
  5957
  5958 				; shift FAC1 A times right
  5959 C95D			LAB_2851
  5960 C95D A8				TAY				; copy shift count
  5961 C95E A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5962 C960 29 80			AND	#$80			; mask sign bit only (x000 0000)
  5963 C962 46 6D			LSR	FAC1_1			; shift FAC1 mantissa1
  5964 C964 05 6D			ORA	FAC1_1			; OR sign in b7 FAC1 mantissa1
  5965 C966 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5966 C968 20 DE C6			JSR	LAB_2592		; shift FAC1 Y times right
  5967 C96B 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5968 C96D 60				RTS
  5969
  5970 				; perform INT()
  5971 C96E			LAB_INT
  5972 C96E A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5973 C970 C9 98			CMP	#$98			; compare with max int
  5974 C972 B0 1E			BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  5975
  5976 C974 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5977 C977 84 79			STY	FAC1_r			; save FAC1 rounding byte
  5978 C979 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5979 C97B 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5980 C97D 49 80			EOR	#$80			; toggle FAC1 sign
  5981 C97F 2A				ROL				; shift into carry
  5982 C980 A9 98			LDA	#$98			; set new exponent
  5983 C982 85 6C			STA	FAC1_e			; save FAC1 exponent
  5984 C984 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5985 C986 85 1B			STA	Temp3			; save for EXP() function
  5986 C988 4C 1C C6			JMP	LAB_24D0		; do ABS and normalise FAC1
  5987
  5988 				; clear FAC1 and return
  5989 C98B			LAB_287F
  5990 C98B 85 6D			STA	FAC1_1			; clear FAC1 mantissa1
  5991 C98D 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5992 C98F 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5993 C991 A8				TAY				; clear Y
  5994 C992			LAB_2886
  5995 C992 60				RTS
  5996
  5997 				; get FAC1 from string
  5998 				; this routine now handles hex and binary values from strings
  5999 				; starting with '$' and '%' respectively
  6000 C993			LAB_2887
  6001 C993 A0 00			LDY	#$00			; clear Y
  6002 C995 84 1F			STY	Dtypef			; clear data type flag, $FF=string, $00=numeric
  6003 C997 A2 09			LDX	#$09			; set index
  6004 C999			LAB_288B
  6005 C999 94 68			STY	numexp,X		; clear byte
  6006 C99B CA				DEX				; decrement index
  6007 C99C 10 FB			BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
  6008
  6009 C99E 90 7F			BCC	LAB_28FE		; branch if 1st character numeric
  6010
  6011 				; get FAC1 from string .. first character wasn't numeric
  6012 C9A0 C9 2D			CMP	#'-'			; else compare with '-'
  6013 C9A2 D0 04			BNE	LAB_289A		; branch if not '-'
  6014
  6015 C9A4 86 71			STX	negnum			; set flag for -ve number (X = $FF)
  6016 C9A6 F0 04			BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  6017
  6018 				; get FAC1 from string .. first character wasn't numeric or -
  6019 C9A8			LAB_289A
  6020 C9A8 C9 2B			CMP	#'+'			; else compare with '+'
  6021 C9AA D0 05			BNE	LAB_289D		; branch if not '+' (go check for hex/bin)
  6022
  6023 				; was '+' or '-' to start, so get next character
  6024 C9AC			LAB_289C
  6025 C9AC 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6026 C9AF 90 6E			BCC	LAB_28FE		; branch if numeric character
  6027
  6028 				; code here for hex and binary numbers
  6029 C9B1			LAB_289D
  6030 C9B1 C9 24			CMP	#'$'			; else compare with '$'
  6031 C9B3 D0 03			BNE	LAB_NHEX		; branch if not '$'
  6032
  6033 C9B5 4C 5D CE			JMP	LAB_CHEX		; branch if '$'
  6034
  6035 C9B8			LAB_NHEX
  6036 C9B8 C9 25			CMP	#'%'			; else compare with '%'
  6037 C9BA D0 08			BNE	LAB_28A3		; branch if not '%' (continue original code)
  6038
  6039 C9BC 4C 8B CE			JMP	LAB_CBIN		; branch if '%'
  6040
  6041 C9BF			LAB_289E
  6042 C9BF 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  6043 C9C2			LAB_28A1
  6044 C9C2 90 5B			BCC	LAB_28FE		; branch if numeric character
  6045
  6046 				; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6047 C9C4			LAB_28A3
  6048 C9C4 C9 2E			CMP	#'.'			; else compare with '.'
  6049 C9C6 F0 2E			BEQ	LAB_28D5		; branch if '.'
  6050
  6051 				; get FAC1 from string .. character wasn't numeric, -, + or .
  6052 C9C8 C9 45			CMP	#'E'			; else compare with 'E'
  6053 C9CA D0 30			BNE	LAB_28DB		; branch if not 'E'
  6054
  6055 									; was 'E' so evaluate exponential part
  6056 C9CC 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6057 C9CF 90 17			BCC	LAB_28C7		; branch if numeric character
  6058
  6059 C9D1 C9 CC			CMP	#TK_MINUS		; else compare with token for -
  6060 C9D3 F0 0E			BEQ	LAB_28C2		; branch if token for -
  6061
  6062 C9D5 C9 2D			CMP	#'-'			; else compare with '-'
  6063 C9D7 F0 0A			BEQ	LAB_28C2		; branch if '-'
  6064
  6065 C9D9 C9 CB			CMP	#TK_PLUS		; else compare with token for +
  6066 C9DB F0 08			BEQ	LAB_28C4		; branch if token for +
  6067
  6068 C9DD C9 2B			CMP	#'+'			; else compare with '+'
  6069 C9DF F0 04			BEQ	LAB_28C4		; branch if '+'
  6070
  6071 C9E1 D0 07			BNE	LAB_28C9		; branch always
  6072
  6073 C9E3			LAB_28C2
  6074 C9E3 66 6B			ROR	expneg			; set exponent -ve flag (C, which=1, into b7)
  6075 C9E5			LAB_28C4
  6076 C9E5 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6077 C9E8			LAB_28C7
  6078 C9E8 90 5B			BCC	LAB_2925		; branch if numeric character
  6079
  6080 C9EA			LAB_28C9
  6081 C9EA 24 6B			BIT	expneg			; test exponent -ve flag
  6082 C9EC 10 0E			BPL	LAB_28DB		; if +ve go evaluate exponent
  6083
  6084 									; else do exponent = -exponent 
  6085 C9EE A9 00			LDA	#$00			; clear result
  6086 C9F0 38				SEC				; set carry for subtract
  6087 C9F1 E5 69			SBC	expcnt			; subtract exponent byte
  6088 C9F3 4C FE C9			JMP	LAB_28DD		; go evaluate exponent
  6089
  6090 C9F6			LAB_28D5
  6091 C9F6 66 6A			ROR	numdpf			; set decimal point flag
  6092 C9F8 24 6A			BIT	numdpf			; test decimal point flag
  6093 C9FA 50 C3			BVC	LAB_289E		; branch if only one decimal point so far
  6094
  6095 									; evaluate exponent
  6096 C9FC			LAB_28DB
  6097 C9FC A5 69			LDA	expcnt			; get exponent count byte
  6098 C9FE			LAB_28DD
  6099 C9FE 38				SEC				; set carry for subtract
  6100 C9FF E5 68			SBC	numexp			; subtract numerator exponent
  6101 CA01 85 69			STA	expcnt			; save exponent count byte
  6102 CA03 F0 12			BEQ	LAB_28F6		; branch if no adjustment
  6103
  6104 CA05 10 09			BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
  6105
  6106 									; else go do FAC1/10^(0-expcnt)
  6107 CA07			LAB_28E6
  6108 CA07 20 DD C7			JSR	LAB_26B9		; divide by 10
  6109 CA0A E6 69			INC	expcnt			; increment exponent count byte
  6110 CA0C D0 F9			BNE	LAB_28E6		; loop until all done
  6111
  6112 CA0E F0 07			BEQ	LAB_28F6		; branch always
  6113
  6114 CA10			LAB_28EF
  6115 CA10 20 C4 C7			JSR	LAB_269E		; multiply by 10
  6116 CA13 C6 69			DEC	expcnt			; decrement exponent count byte
  6117 CA15 D0 F9			BNE	LAB_28EF		; loop until all done
  6118
  6119 CA17			LAB_28F6
  6120 CA17 A5 71			LDA	negnum			; get -ve flag
  6121 CA19 30 01			BMI	LAB_28FB		; if -ve do - FAC1 and return
  6122
  6123 CA1B 60				RTS
  6124
  6125 				; do - FAC1 and return
  6126 CA1C			LAB_28FB
  6127 CA1C 4C E1 CB			JMP	LAB_GTHAN		; do - FAC1 and return
  6128
  6129 				; do unsigned FAC1*10+number
  6130 CA1F			LAB_28FE
  6131 CA1F 48				PHA				; save character
  6132 CA20 24 6A			BIT	numdpf			; test decimal point flag
  6133 CA22 10 02			BPL	LAB_2905		; skip exponent increment if not set
  6134
  6135 CA24 E6 68			INC	numexp			; else increment number exponent
  6136 CA26			LAB_2905
  6137 CA26 20 C4 C7			JSR	LAB_269E		; multiply FAC1 by 10
  6138 CA29 68				PLA				; restore character
  6139 CA2A 29 0F			AND	#$0F			; convert to binary
  6140 CA2C 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6141 CA2F 4C BF C9			JMP	LAB_289E		; go do next character
  6142
  6143 				; evaluate new ASCII digit
  6144 CA32			LAB_2912
  6145 CA32 48				PHA				; save digit
  6146 CA33 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6147 CA36 68				PLA				; restore digit
  6148 CA37 20 E7 C8			JSR	LAB_27DB		; save A as integer byte
  6149 CA3A A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6150 CA3C 45 70			EOR	FAC1_s			; toggle with FAC1 sign (b7)
  6151 CA3E 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6152 CA40 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6153 CA42 4C AE C5			JMP	LAB_ADD			; add FAC2 to FAC1 and return
  6154
  6155 				; evaluate next character of exponential part of number
  6156 CA45			LAB_2925
  6157 CA45 A5 69			LDA	expcnt			; get exponent count byte
  6158 CA47 C9 0A			CMP	#$0A			; compare with 10 decimal
  6159 CA49 90 09			BCC	LAB_2934		; branch if less
  6160
  6161 CA4B A9 64			LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  6162 CA4D 24 6B			BIT	expneg			; test exponent -ve flag
  6163 CA4F 30 0E			BMI	LAB_2942		; branch if -ve
  6164
  6165 CA51 4C B0 C6			JMP	LAB_2564		; else do overflow error
  6166
  6167 CA54			LAB_2934
  6168 CA54 0A				ASL				; * 2
  6169 CA55 0A				ASL				; * 4
  6170 CA56 65 69			ADC	expcnt			; * 5
  6171 CA58 0A				ASL				; * 10
  6172 CA59 A0 00			LDY	#$00			; set index
  6173 CA5B 71 83			ADC	(Bpntrl),Y		; add character (will be $30 too much!)
  6174 CA5D E9 2F			SBC	#'0'-1			; convert character to binary
  6175 CA5F			LAB_2942
  6176 CA5F 85 69			STA	expcnt			; save exponent count byte
  6177 CA61 4C E5 C9			JMP	LAB_28C4		; go get next character
  6178
  6179 				; print ' in line [LINE #]'
  6180 CA64			LAB_2953
  6181 CA64 A9 22			LDA	#<LAB_LMSG		; point to ' in line ' message low byte
  6182 CA66 A0 DB			LDY	#>LAB_LMSG		; point to ' in line ' message high byte
  6183 CA68 20 B1 B8			JSR	LAB_18C3		; print null terminated string from memory
  6184
  6185 									; print Basic line #
  6186 CA6B A5 48			LDA	Clineh			; get current line high byte
  6187 CA6D A6 47			LDX	Clinel			; get current line low byte
  6188
  6189 				; print XA as unsigned integer
  6190 CA6F			LAB_295E
  6191 CA6F 85 6D			STA	FAC1_1			; save low byte as FAC1 mantissa1
  6192 CA71 86 6E			STX	FAC1_2			; save high byte as FAC1 mantissa2
  6193 CA73 A2 90			LDX	#$90			; set exponent to 16d bits
  6194 CA75 38				SEC				; set integer is +ve flag
  6195 CA76 20 F4 C8			JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  6196 CA79 A0 00			LDY	#$00			; clear index
  6197 CA7B 98				TYA				; clear A
  6198 CA7C 20 8F CA			JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  6199 CA7F 4C B1 B8			JMP	LAB_18C3		; print null terminated string from memory and return
  6200
  6201 				; convert FAC1 to ASCII string result in (AY)
  6202 				; not any more, moved scratchpad to page 0
  6203 CA82			LAB_296E
  6204 CA82 A0 01			LDY	#$01			; set index = 1
  6205 CA84 A9 20			LDA	#$20			; character = ' ' (assume +ve)
  6206 CA86 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  6207 CA88 10 02			BPL	LAB_2978		; branch if +ve
  6208
  6209 CA8A A9 2D			LDA	#$2D			; else character = '-'
  6210 CA8C			LAB_2978
  6211 CA8C 99 9D 00			STA	Decss,Y			; save leading character (' ' or '-')
  6212 CA8F			LAB_297B
  6213 CA8F 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6214 CA91 84 7A			STY	Sendl			; save index
  6215 CA93 C8				INY				; increment index
  6216 CA94 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  6217 CA96 D0 05			BNE	LAB_2989		; branch if FAC1<>0
  6218
  6219 									; exponent was $00 so FAC1 is 0
  6220 CA98 A9 30			LDA	#'0'			; set character = '0'
  6221 CA9A 4C 9B CB			JMP	LAB_2A89		; save last character, [EOT] and exit
  6222
  6223 									; FAC1 is some non zero value
  6224 CA9D			LAB_2989
  6225 CA9D A9 00			LDA	#$00			; clear (number exponent count)
  6226 CA9F E0 81			CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  6227
  6228 CAA1 B0 09			BCS	LAB_299A		; branch if FAC1=>1
  6229
  6230 									; FAC1<1
  6231 CAA3 A9 95			LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  6232 CAA5 A0 D3			LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  6233 CAA7 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6234 CAAA A9 FA			LDA	#$FA			; set number exponent count (-6)
  6235 CAAC			LAB_299A
  6236 CAAC 85 68			STA	numexp			; save number exponent count
  6237 CAAE			LAB_299C
  6238 CAAE A9 91			LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  6239 CAB0 A0 D3			LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  6240 CAB2 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6241 CAB5 F0 1E			BEQ	LAB_29C3		; exit if FAC1 = (AY)
  6242
  6243 CAB7 10 12			BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  6244
  6245 									; FAC1 < (AY)
  6246 CAB9			LAB_29A7
  6247 CAB9 A9 8D			LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  6248 CABB A0 D3			LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  6249 CABD 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6250 CAC0 F0 02			BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  6251
  6252 CAC2 10 0E			BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  6253
  6254 									; FAC1 <= (AY)
  6255 CAC4			LAB_29B2
  6256 CAC4 20 C4 C7			JSR	LAB_269E		; multiply by 10
  6257 CAC7 C6 68			DEC	numexp			; decrement number exponent count
  6258 CAC9 D0 EE			BNE	LAB_29A7		; go test again (branch always)
  6259
  6260 CACB			LAB_29B9
  6261 CACB 20 DD C7			JSR	LAB_26B9		; divide by 10
  6262 CACE E6 68			INC	numexp			; increment number exponent count
  6263 CAD0 D0 DC			BNE	LAB_299C		; go test again (branch always)
  6264
  6265 				; now we have just the digits to do
  6266 CAD2			LAB_29C0
  6267 CAD2 20 A7 C5			JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  6268 CAD5			LAB_29C3
  6269 CAD5 20 3D C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6270 CAD8 A2 01			LDX	#$01			; set default digits before dp = 1
  6271 CADA A5 68			LDA	numexp			; get number exponent count
  6272 CADC 18				CLC				; clear carry for add
  6273 CADD 69 07			ADC	#$07			; up to 6 digits before point
  6274 CADF 30 09			BMI	LAB_29D8		; if -ve then 1 digit before dp
  6275
  6276 CAE1 C9 08			CMP	#$08			; A>=8 if n>=1E6
  6277 CAE3 B0 06			BCS	LAB_29D9		; branch if >= $08
  6278
  6279 									; carry is clear
  6280 CAE5 69 FF			ADC	#$FF			; take 1 from digit count
  6281 CAE7 AA				TAX				; copy to A
  6282 CAE8 A9 02			LDA	#$02			;.set exponent adjust
  6283 CAEA			LAB_29D8
  6284 CAEA 38				SEC				; set carry for subtract
  6285 CAEB			LAB_29D9
  6286 CAEB E9 02			SBC	#$02			; -2
  6287 CAED 85 69			STA	expcnt			;.save exponent adjust
  6288 CAEF 86 68			STX	numexp			; save digits before dp count
  6289 CAF1 8A				TXA				; copy to A
  6290 CAF2 F0 02			BEQ	LAB_29E4		; branch if no digits before dp
  6291
  6292 CAF4 10 13			BPL	LAB_29F7		; branch if digits before dp
  6293
  6294 CAF6			LAB_29E4
  6295 CAF6 A4 7A			LDY	Sendl			; get output string index
  6296 CAF8 A9 2E			LDA	#$2E			; character '.'
  6297 CAFA C8				INY				; increment index
  6298 CAFB 99 9D 00			STA	Decss,Y			; save to output string
  6299 CAFE 8A				TXA				;.
  6300 CAFF F0 06			BEQ	LAB_29F5		;.
  6301
  6302 CB01 A9 30			LDA	#'0'			; character '0'
  6303 CB03 C8				INY				; increment index
  6304 CB04 99 9D 00			STA	Decss,Y			; save to output string
  6305 CB07			LAB_29F5
  6306 CB07 84 7A			STY	Sendl			; save output string index
  6307 CB09			LAB_29F7
  6308 CB09 A0 00			LDY	#$00			; clear index (point to 100,000)
  6309 CB0B A2 80			LDX	#$80			; 
  6310 CB0D			LAB_29FB
  6311 CB0D A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  6312 CB0F 18				CLC				; clear carry for add
  6313 CB10 79 0B D4			ADC	LAB_2A9C,Y		; add -ve LSB
  6314 CB13 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  6315 CB15 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  6316 CB17 79 0A D4			ADC	LAB_2A9B,Y		; add -ve NMSB
  6317 CB1A 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  6318 CB1C A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  6319 CB1E 79 09 D4			ADC	LAB_2A9A,Y		; add -ve MSB
  6320 CB21 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  6321 CB23 E8				INX				; 
  6322 CB24 B0 04			BCS	LAB_2A18		; 
  6323
  6324 CB26 10 E5			BPL	LAB_29FB		; not -ve so try again
  6325
  6326 CB28 30 02			BMI	LAB_2A1A		; 
  6327
  6328 CB2A			LAB_2A18
  6329 CB2A 30 E1			BMI	LAB_29FB		; 
  6330
  6331 CB2C			LAB_2A1A
  6332 CB2C 8A				TXA				; 
  6333 CB2D 90 04			BCC	LAB_2A21		; 
  6334
  6335 CB2F 49 FF			EOR	#$FF			; 
  6336 CB31 69 0A			ADC	#$0A			; 
  6337 CB33			LAB_2A21
  6338 CB33 69 2F			ADC	#'0'-1			; add '0'-1 to result
  6339 CB35 C8				INY				; increment index ..
  6340 CB36 C8				INY				; .. to next less ..
  6341 CB37 C8				INY				; .. power of ten
  6342 CB38 84 55			STY	Cvaral			; save as current var address low byte
  6343 CB3A A4 7A			LDY	Sendl			; get output string index
  6344 CB3C C8				INY				; increment output string index
  6345 CB3D AA				TAX				; copy character to X
  6346 CB3E 29 7F			AND	#$7F			; mask out top bit
  6347 CB40 99 9D 00			STA	Decss,Y			; save to output string
  6348 CB43 C6 68			DEC	numexp			; decrement # of characters before the dp
  6349 CB45 D0 06			BNE	LAB_2A3B		; branch if still characters to do
  6350
  6351 									; else output the point
  6352 CB47 A9 2E			LDA	#$2E			; character '.'
  6353 CB49 C8				INY				; increment output string index
  6354 CB4A 99 9D 00			STA	Decss,Y			; save to output string
  6355 CB4D			LAB_2A3B
  6356 CB4D 84 7A			STY	Sendl			; save output string index
  6357 CB4F A4 55			LDY	Cvaral			; get current var address low byte
  6358 CB51 8A				TXA				; get character back
  6359 CB52 49 FF			EOR	#$FF			; 
  6360 CB54 29 80			AND	#$80			; 
  6361 CB56 AA				TAX				; 
  6362 CB57 C0 12			CPY	#$12			; compare index with max
  6363 CB59 D0 B2			BNE	LAB_29FB		; loop if not max
  6364
  6365 									; now remove trailing zeroes
  6366 CB5B A4 7A			LDY	Sendl			; get output string index
  6367 CB5D			LAB_2A4B
  6368 CB5D B9 9D 00			LDA	Decss,Y			; get character from output string
  6369 CB60 88				DEY				; decrement output string index
  6370 CB61 C9 30			CMP	#'0'			; compare with '0'
  6371 CB63 F0 F8			BEQ	LAB_2A4B		; loop until non '0' character found
  6372
  6373 CB65 C9 2E			CMP	#'.'			; compare with '.'
  6374 CB67 F0 01			BEQ	LAB_2A58		; branch if was dp
  6375
  6376 									; restore last character
  6377 CB69 C8				INY				; increment output string index
  6378 CB6A			LAB_2A58
  6379 CB6A A9 2B			LDA	#$2B			; character '+'
  6380 CB6C A6 69			LDX	expcnt			; get exponent count
  6381 CB6E F0 2E			BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6382
  6383 									; exponent isn't zero so write exponent
  6384 CB70 10 08			BPL	LAB_2A68		; branch if exponent count +ve
  6385
  6386 CB72 A9 00			LDA	#$00			; clear A
  6387 CB74 38				SEC				; set carry for subtract
  6388 CB75 E5 69			SBC	expcnt			; subtract exponent count adjust (convert -ve to +ve)
  6389 CB77 AA				TAX				; copy exponent count to X
  6390 CB78 A9 2D			LDA	#'-'			; character '-'
  6391 CB7A			LAB_2A68
  6392 CB7A 99 9F 00			STA	Decss+2,Y		; save to output string
  6393 CB7D A9 45			LDA	#$45			; character 'E'
  6394 CB7F 99 9E 00			STA	Decss+1,Y		; save exponent sign to output string
  6395 CB82 8A				TXA				; get exponent count back
  6396 CB83 A2 2F			LDX	#'0'-1			; one less than '0' character
  6397 CB85 38				SEC				; set carry for subtract
  6398 CB86			LAB_2A74
  6399 CB86 E8				INX				; increment 10's character
  6400 CB87 E9 0A			SBC	#$0A			;.subtract 10 from exponent count
  6401 CB89 B0 FB			BCS	LAB_2A74		; loop while still >= 0
  6402
  6403 CB8B 69 3A			ADC	#':'			; add character ':' ($30+$0A, result is 10 less that value)
  6404 CB8D 99 A1 00			STA	Decss+4,Y		; save to output string
  6405 CB90 8A				TXA				; copy 10's character
  6406 CB91 99 A0 00			STA	Decss+3,Y		; save to output string
  6407 CB94 A9 00			LDA	#$00			; set null terminator
  6408 CB96 99 A2 00			STA	Decss+5,Y		; save to output string
  6409 CB99 F0 08			BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6410
  6411 									; save last character, [EOT] and exit
  6412 CB9B			LAB_2A89
  6413 CB9B 99 9D 00			STA	Decss,Y			; save last character to output string
  6414
  6415 									; set null terminator and exit
  6416 CB9E			LAB_2A8C
  6417 CB9E A9 00			LDA	#$00			; set null terminator
  6418 CBA0 99 9E 00			STA	Decss+1,Y		; save after last character
  6419
  6420 									; set string pointer (AY) and exit
  6421 CBA3			LAB_2A91
  6422 CBA3 A9 9E			LDA	#<Decssp1		; set result string low pointer
  6423 CBA5 A0 00			LDY	#>Decssp1		; set result string high pointer
  6424 CBA7 60				RTS
  6425
  6426 				; perform power function
  6427 CBA8			LAB_POWER
  6428 CBA8 F0 42			BEQ	LAB_EXP			; go do  EXP()
  6429
  6430 CBAA A5 73			LDA	FAC2_e			; get FAC2 exponent
  6431 CBAC D0 03			BNE	LAB_2ABF		; branch if FAC2<>0
  6432
  6433 CBAE 4C 3F C6			JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6434
  6435 CBB1			LAB_2ABF
  6436 CBB1 A2 5C			LDX	#<func_l		; set destination pointer low byte
  6437 CBB3 A0 00			LDY	#>func_l		; set destination pointer high byte
  6438 CBB5 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6439 CBB8 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6440 CBBA 10 0F			BPL	LAB_2AD9		; branch if FAC2>0
  6441
  6442 									; else FAC2 is -ve and can only be raised to an
  6443 									; integer power which gives an x +j0 result
  6444 CBBC 20 6E C9			JSR	LAB_INT			; perform INT
  6445 CBBF A9 5C			LDA	#<func_l		; set source pointer low byte
  6446 CBC1 A0 00			LDY	#>func_l		; set source pointer high byte
  6447 CBC3 20 04 C9			JSR	LAB_27F8		; compare FAC1 with (AY)
  6448 CBC6 D0 03			BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6449 									; this will leave FAC1 -ve and cause a Function Call
  6450 									; error when LOG() is called
  6451
  6452 CBC8 98				TYA				; clear sign b7
  6453 CBC9 A4 1B			LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
  6454 									; for possible later negation, b0
  6455 CBCB			LAB_2AD9
  6456 CBCB 20 B2 C5			JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6457 CBCE 98				TYA				; copy sign back ..
  6458 CBCF 48				PHA				; .. and save it
  6459 CBD0 20 E8 C6			JSR	LAB_LOG			; do LOG(n)
  6460 CBD3 A9 5C			LDA	#<garb_l		; set pointer low byte
  6461 CBD5 A0 00			LDY	#>garb_l		; set pointer high byte
  6462 CBD7 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6463 CBDA 20 EC CB			JSR	LAB_EXP			; go do EXP(n)
  6464 CBDD 68				PLA				; pull sign from stack
  6465 CBDE 4A				LSR				; b0 is to be tested, shift to Cb
  6466 CBDF 90 0A			BCC	LAB_2AF9		; if no bit then exit
  6467
  6468 									; Perform negation
  6469 				; do - FAC1
  6470 CBE1			LAB_GTHAN
  6471 CBE1 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6472 CBE3 F0 06			BEQ	LAB_2AF9		; exit if FAC1_e = $00
  6473
  6474 CBE5 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6475 CBE7 49 FF			EOR	#$FF			; complement it
  6476 CBE9 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  6477 CBEB			LAB_2AF9
  6478 CBEB 60				RTS
  6479
  6480 				; perform EXP()	(x^e)
  6481 CBEC			LAB_EXP
  6482 CBEC A9 99			LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6483 CBEE A0 D3			LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6484 CBF0 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6485 CBF3 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  6486 CBF5 69 50			ADC	#$50			; +$50/$100
  6487 CBF7 90 03			BCC	LAB_2B2B		; skip rounding if no carry
  6488
  6489 CBF9 20 CE C8			JSR	LAB_27C2		; round FAC1 (no check)
  6490 CBFC			LAB_2B2B
  6491 CBFC 85 63			STA	FAC2_r			; save FAC2 rounding byte
  6492 CBFE 20 BA C8			JSR	LAB_27AE		; copy FAC1 to FAC2
  6493 CC01 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6494 CC03 C9 88			CMP	#$88			; compare with EXP limit (256d)
  6495 CC05 90 03			BCC	LAB_2B39		; branch if less
  6496
  6497 CC07			LAB_2B36
  6498 CC07 20 BB C7			JSR	LAB_2690		; handle overflow and underflow
  6499 CC0A			LAB_2B39
  6500 CC0A 20 6E C9			JSR	LAB_INT			; perform INT
  6501 CC0D A5 1B			LDA	Temp3			; get mantissa 3 from INT() function
  6502 CC0F 18				CLC				; clear carry for add
  6503 CC10 69 81			ADC	#$81			; normalise +1
  6504 CC12 F0 F3			BEQ	LAB_2B36		; if $00 go handle overflow
  6505
  6506 CC14 38				SEC				; set carry for subtract
  6507 CC15 E9 01			SBC	#$01			; now correct for exponent
  6508 CC17 48				PHA				; save FAC2 exponent
  6509
  6510 									; swap FAC1 and FAC2
  6511 CC18 A2 04			LDX	#$04			; 4 bytes to do
  6512 CC1A			LAB_2B49
  6513 CC1A B5 73			LDA	FAC2_e,X		; get FAC2,X
  6514 CC1C B4 6C			LDY	FAC1_e,X		; get FAC1,X
  6515 CC1E 95 6C			STA	FAC1_e,X		; save FAC1,X
  6516 CC20 94 73			STY	FAC2_e,X		; save FAC2,X
  6517 CC22 CA				DEX				; decrement count/index
  6518 CC23 10 F5			BPL	LAB_2B49		; loop if not all done
  6519
  6520 CC25 A5 63			LDA	FAC2_r			; get FAC2 rounding byte
  6521 CC27 85 79			STA	FAC1_r			; save as FAC1 rounding byte
  6522 CC29 20 93 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6523 CC2C 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6524 CC2F A9 9D			LDA	#<LAB_2AFE		; set counter pointer low byte
  6525 CC31 A0 D3			LDY	#>LAB_2AFE		; set counter pointer high byte
  6526 CC33 20 54 CC			JSR	LAB_2B84		; go do series evaluation
  6527 CC36 A9 00			LDA	#$00			; clear A
  6528 CC38 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6529 CC3A 68				PLA				;.get saved FAC2 exponent
  6530 CC3B 4C A0 C7			JMP	LAB_2675		; test and adjust accumulators and return
  6531
  6532 				; ^2 then series evaluation
  6533 CC3E			LAB_2B6E
  6534 CC3E 85 7A			STA	Cptrl			; save count pointer low byte
  6535 CC40 84 7B			STY	Cptrh			; save count pointer high byte
  6536 CC42 20 8A C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6537 CC45 A9 64			LDA	#<Adatal		; set pointer low byte (Y already $00)
  6538 CC47 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6539 CC4A 20 58 CC			JSR	LAB_2B88		; go do series evaluation
  6540 CC4D A9 64			LDA	#<Adatal		; pointer to original # low byte
  6541 CC4F A0 00			LDY	#>Adatal		; pointer to original # high byte
  6542 CC51 4C 26 C7			JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6543
  6544 				; series evaluation
  6545 CC54			LAB_2B84
  6546 CC54 85 7A			STA	Cptrl			; save count pointer low byte
  6547 CC56 84 7B			STY	Cptrh			; save count pointer high byte
  6548 CC58			LAB_2B88
  6549 CC58 A2 68			LDX	#<numexp		; set pointer low byte
  6550 CC5A 20 8C C8			JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
  6551 CC5D B1 7A			LDA	(Cptrl),Y		; get constants count
  6552 CC5F 85 71			STA	numcon			; save constants count
  6553 CC61 A4 7A			LDY	Cptrl			; get count pointer low byte
  6554 CC63 C8				INY				; increment it (now constants pointer)
  6555 CC64 98				TYA				; copy it
  6556 CC65 D0 02			BNE	LAB_2B97		; skip next if no overflow
  6557
  6558 CC67 E6 7B			INC	Cptrh			; else increment high byte
  6559 CC69			LAB_2B97
  6560 CC69 85 7A			STA	Cptrl			; save low byte
  6561 CC6B A4 7B			LDY	Cptrh			; get high byte
  6562 CC6D			LAB_2B9B
  6563 CC6D 20 26 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6564 CC70 A5 7A			LDA	Cptrl			; get constants pointer low byte
  6565 CC72 A4 7B			LDY	Cptrh			; get constants pointer high byte
  6566 CC74 18				CLC				; clear carry for add
  6567 CC75 69 04			ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6568 CC77 90 01			BCC	LAB_2BA8		; skip next if no overflow
  6569
  6570 CC79 C8				INY				; increment high byte
  6571 CC7A			LAB_2BA8
  6572 CC7A 85 7A			STA	Cptrl			; save pointer low byte
  6573 CC7C 84 7B			STY	Cptrh			; save pointer high byte
  6574 CC7E 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6575 CC81 A9 68			LDA	#<numexp		; set pointer low byte to partial @ numexp
  6576 CC83 A0 00			LDY	#>numexp		; set pointer high byte to partial @ numexp
  6577 CC85 C6 71			DEC	numcon			; decrement constants count
  6578 CC87 D0 E4			BNE	LAB_2B9B		; loop until all done
  6579
  6580 CC89 60				RTS
  6581
  6582 				; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6583 				; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6584 				; the Galois method and a sample of 65536 bytes produced gives the following values.
  6585
  6586 				; Entropy = 7.997442 bits per byte
  6587 				; Optimum compression would reduce these 65536 bytes by 0 percent
  6588
  6589 				; Chi square distribution for 65536 samples is 232.01, and
  6590 				; randomly would exceed this value 75.00 percent of the time
  6591
  6592 				; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6593 				; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6594 				; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6595 CC8A			LAB_RND
  6596 CC8A A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6597 CC8C F0 07			BEQ	NextPRN			; do next random # if zero
  6598
  6599 									; else get seed into random number store
  6600 CC8E A2 98			LDX	#Rbyte4			; set PRNG pointer low byte
  6601 CC90 A0 00			LDY	#$00			; set PRNG pointer high byte
  6602 CC92 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6603 CC95			NextPRN
  6604 CC95 A2 AF			LDX	#$AF			; set EOR byte
  6605 CC97 A0 13			LDY	#$13			; do this nineteen times
  6606 CC99			LoopPRN
  6607 CC99 06 99			ASL	Rbyte1			; shift PRNG most significant byte
  6608 CC9B 26 9A			ROL	Rbyte2			; shift PRNG middle byte
  6609 CC9D 26 9B			ROL	Rbyte3			; shift PRNG least significant byte
  6610 CC9F 26 98			ROL	Rbyte4			; shift PRNG extra byte
  6611 CCA1 90 05			BCC	Ninc1			; branch if bit 32 clear
  6612
  6613 CCA3 8A				TXA				; set EOR byte
  6614 CCA4 45 99			EOR	Rbyte1			; EOR PRNG extra byte
  6615 CCA6 85 99			STA	Rbyte1			; save new PRNG extra byte
  6616 CCA8			Ninc1
  6617 CCA8 88				DEY				; decrement loop count
  6618 CCA9 D0 EE			BNE	LoopPRN			; loop if not all done
  6619
  6620 CCAB A2 02			LDX	#$02			; three bytes to copy
  6621 CCAD			CopyPRNG
  6622 CCAD B5 99			LDA	Rbyte1,X		; get PRNG byte
  6623 CCAF 95 6D			STA	FAC1_1,X		; save FAC1 byte
  6624 CCB1 CA				DEX
  6625 CCB2 10 F9			BPL	CopyPRNG		; loop if not complete
  6626
  6627 CCB4 A9 80			LDA	#$80			; set the exponent
  6628 CCB6 85 6C			STA	FAC1_e			; save FAC1 exponent
  6629
  6630 CCB8 0A				ASL				; clear A
  6631 CCB9 85 70			STA	FAC1_s			; save FAC1 sign
  6632
  6633 CCBB 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  6634
  6635 				; perform COS()
  6636 CCBE			LAB_COS
  6637 CCBE A9 BA			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6638 CCC0 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6639 CCC2 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6640
  6641 				; perform SIN()
  6642 CCC5			LAB_SIN
  6643 CCC5 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6644 CCC8 A9 CF			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6645 CCCA A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6646 CCCC A6 77			LDX	FAC2_s			; get FAC2 sign (b7)
  6647 CCCE 20 E6 C7			JSR	LAB_26C2		; divide by (AY) (X=sign)
  6648 CCD1 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6649 CCD4 20 6E C9			JSR	LAB_INT			; perform INT
  6650 CCD7 A9 00			LDA	#$00			; clear byte
  6651 CCD9 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6652 CCDB 20 93 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6653 CCDE A9 01			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6654 CCE0 A0 D4			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6655 CCE2 20 90 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6656 CCE5 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6657 CCE7 48				PHA				; save FAC1 sign
  6658 CCE8 10 0D			BPL	LAB_2C35		; branch if +ve
  6659
  6660 									; FAC1 sign was -ve
  6661 CCEA 20 A7 C5			JSR	LAB_244E		; add 0.5 to FAC1
  6662 CCED A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6663 CCEF 30 09			BMI	LAB_2C38		; branch if -ve
  6664
  6665 CCF1 A5 23			LDA	Cflag			; get comparison evaluation flag
  6666 CCF3 49 FF			EOR	#$FF			; toggle flag
  6667 CCF5 85 23			STA	Cflag			; save comparison evaluation flag
  6668 CCF7			LAB_2C35
  6669 CCF7 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6670 CCFA			LAB_2C38
  6671 CCFA A9 01			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6672 CCFC A0 D4			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6673 CCFE 20 AB C5			JSR	LAB_246C		; add (AY) to FAC1
  6674 CD01 68				PLA				; restore FAC1 sign
  6675 CD02 10 03			BPL	LAB_2C45		; branch if was +ve
  6676
  6677 									; else correct FAC1
  6678 CD04 20 E1 CB			JSR	LAB_GTHAN		; do - FAC1
  6679 CD07			LAB_2C45
  6680 CD07 A9 BE			LDA	#<LAB_2C84		; set pointer low byte to counter
  6681 CD09 A0 D3			LDY	#>LAB_2C84		; set pointer high byte to counter
  6682 CD0B 4C 3E CC			JMP	LAB_2B6E		; ^2 then series evaluation and return
  6683
  6684 				; perform TAN()
  6685 CD0E			LAB_TAN
  6686 CD0E 20 8A C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6687 CD11 A9 00			LDA	#$00			; clear byte
  6688 CD13 85 23			STA	Cflag			; clear comparison evaluation flag
  6689 CD15 20 C5 CC			JSR	LAB_SIN			; go do SIN(n)
  6690 CD18 A2 5C			LDX	#<func_l		; set sin(n) pointer low byte
  6691 CD1A A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6692 CD1C 20 94 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6693 CD1F A9 64			LDA	#<Adatal		; set n pointer low addr
  6694 CD21 A0 00			LDY	#>Adatal		; set n pointer high addr
  6695 CD23 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6696 CD26 A9 00			LDA	#$00			; clear byte
  6697 CD28 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6698 CD2A A5 23			LDA	Cflag			; get comparison evaluation flag
  6699 CD2C 20 36 CD			JSR	LAB_2C74		; save flag and go do series evaluation
  6700
  6701 CD2F A9 5C			LDA	#<func_l		; set sin(n) pointer low byte
  6702 CD31 A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6703 CD33 4C EE C7			JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6704
  6705 CD36			LAB_2C74
  6706 CD36 48				PHA				; save comparison evaluation flag
  6707 CD37 4C F7 CC			JMP	LAB_2C35		; go do series evaluation
  6708
  6709 				; perform USR()
  6710 CD3A			LAB_USR
  6711 CD3A 20 0A 00			JSR	Usrjmp			; call user code
  6712 CD3D 4C CC BB			JMP	LAB_1BFB		; scan for ')', else do syntax error then warm start
  6713
  6714 				; perform ATN()
  6715 CD40			LAB_ATN
  6716 CD40 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6717 CD42 48				PHA				; save sign
  6718 CD43 10 03			BPL	LAB_2CA1		; branch if +ve
  6719
  6720 CD45 20 E1 CB			JSR	LAB_GTHAN		; else do - FAC1
  6721 CD48			LAB_2CA1
  6722 CD48 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6723 CD4A 48				PHA				; push exponent
  6724 CD4B C9 81			CMP	#$81			; compare with 1
  6725 CD4D 90 07			BCC	LAB_2CAF		; branch if FAC1<1
  6726
  6727 CD4F A9 F4			LDA	#<LAB_259C		; set 1 pointer low byte
  6728 CD51 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  6729 CD53 20 EE C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6730 CD56			LAB_2CAF
  6731 CD56 A9 D3			LDA	#<LAB_2CC9		; set pointer low byte to counter
  6732 CD58 A0 D3			LDY	#>LAB_2CC9		; set pointer high byte to counter
  6733 CD5A 20 3E CC			JSR	LAB_2B6E		; ^2 then series evaluation
  6734 CD5D 68				PLA				; restore old FAC1 exponent
  6735 CD5E C9 81			CMP	#$81			; compare with 1
  6736 CD60 90 07			BCC	LAB_2CC2		; branch if FAC1<1
  6737
  6738 CD62 A9 BA			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6739 CD64 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6740 CD66 20 90 C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6741 CD69			LAB_2CC2
  6742 CD69 68				PLA				; restore FAC1 sign
  6743 CD6A 10 16			BPL	LAB_2D04		; exit if was +ve
  6744
  6745 CD6C 4C E1 CB			JMP	LAB_GTHAN		; else do - FAC1 and return
  6746
  6747 				; perform BITSET
  6748 CD6F			LAB_BITSET
  6749 CD6F 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6750 CD72 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6751 CD74 B0 20			BCS	FCError			; branch if > 7
  6752
  6753 CD76 A9 00			LDA	#$00			; clear A
  6754 CD78 38				SEC				; set the carry
  6755 CD79			S_Bits
  6756 CD79 2A				ROL				; shift bit
  6757 CD7A CA				DEX				; decrement bit number
  6758 CD7B 10 FC			BPL	S_Bits			; loop if still +ve
  6759
  6760 CD7D E8				INX				; make X = $00
  6761 CD7E 01 11			ORA	(Itempl,X)		; or with byte via temporary integer (addr)
  6762 CD80 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6763 CD82			LAB_2D04
  6764 CD82 60				RTS
  6765
  6766 				; perform BITCLR
  6767 CD83			LAB_BITCLR
  6768 CD83 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6769 CD86 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6770 CD88 B0 0C			BCS	FCError			; branch if > 7
  6771
  6772 CD8A A9 FF			LDA	#$FF			; set A
  6773 CD8C			S_Bitc
  6774 CD8C 2A				ROL				; shift bit
  6775 CD8D CA				DEX				; decrement bit number
  6776 CD8E 10 FC			BPL	S_Bitc			; loop if still +ve
  6777
  6778 CD90 E8				INX				; make X = $00
  6779 CD91 21 11			AND	(Itempl,X)		; and with byte via temporary integer (addr)
  6780 CD93 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6781 CD95 60				RTS
  6782
  6783 CD96			FCError
  6784 CD96 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  6785
  6786 				; perform BITTST()
  6787 CD99			LAB_BTST
  6788 CD99 20 7C 00			JSR	LAB_IGBY		; increment BASIC pointer
  6789 CD9C 20 C5 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6790 CD9F E0 08			CPX	#$08			; only 0 to 7 are allowed
  6791 CDA1 B0 F3			BCS	FCError			; branch if > 7
  6792
  6793 CDA3 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  6794 CDA6 C9 29			CMP	#')'			; is next character ')'
  6795 CDA8 F0 03			BEQ	TST_OK			; if ')' go do rest of function
  6796
  6797 CDAA 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  6798
  6799 CDAD			TST_OK
  6800 CDAD 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6801 CDB0 A9 00			LDA	#$00			; clear A
  6802 CDB2 38				SEC				; set the carry
  6803 CDB3			T_Bits
  6804 CDB3 2A				ROL				; shift bit
  6805 CDB4 CA				DEX				; decrement bit number
  6806 CDB5 10 FC			BPL	T_Bits			; loop if still +ve
  6807
  6808 CDB7 E8				INX				; make X = $00
  6809 CDB8 21 11			AND	(Itempl,X)		; AND with byte via temporary integer (addr)
  6810 CDBA F0 02			BEQ	LAB_NOTT		; branch if zero (already correct)
  6811
  6812 CDBC A9 FF			LDA	#$FF			; set for -1 result
  6813 CDBE			LAB_NOTT
  6814 CDBE 4C E7 C8			JMP	LAB_27DB		; go do SGN tail
  6815
  6816 				; perform BIN$()
  6817 CDC1			LAB_BINS
  6818 CDC1 E0 19			CPX	#$19			; max + 1
  6819 CDC3 B0 48			BCS	BinFErr			; exit if too big ( > or = )
  6820
  6821 CDC5 86 38			STX	TempB			; save # of characters ($00 = leading zero remove)
  6822 CDC7 A9 18			LDA	#$18			; need A byte long space
  6823 CDC9 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long
  6824 CDCC A0 17			LDY	#$17			; set index
  6825 CDCE A2 18			LDX	#$18			; character count
  6826 CDD0			NextB1
  6827 CDD0 46 11			LSR	nums_1			; shift highest byte
  6828 CDD2 66 12			ROR	nums_2			; shift middle byte
  6829 CDD4 66 13			ROR	nums_3			; shift lowest byte bit 0 to carry
  6830 CDD6 8A				TXA				; load with '0'/2
  6831 CDD7 2A				ROL				; shift in carry
  6832 CDD8 91 6D			STA	(str_pl),Y		; save to temp string + index
  6833 CDDA 88				DEY				; decrement index
  6834 CDDB 10 F3			BPL	NextB1			; loop if not done
  6835
  6836 CDDD A5 38			LDA	TempB			; get # of characters
  6837 CDDF F0 0A			BEQ	EndBHS			; branch if truncate
  6838
  6839 CDE1 AA				TAX				; copy length to X
  6840 CDE2 38				SEC				; set carry for add !
  6841 CDE3 49 FF			EOR	#$FF			; 1's complement
  6842 CDE5 69 18			ADC	#$18			; add 24d
  6843 CDE7 F0 1C			BEQ	GoPr2			; if zero print whole string
  6844
  6845 CDE9 D0 0F			BNE	GoPr1			; else go make output string
  6846 					
  6847 				; this is the exit code and is also used by HEX$()
  6848 				; truncate string to remove leading '0's
  6849 CDEB			EndBHS
  6850 CDEB A8				TAY				; clear index (A=0, X=length here)
  6851 CDEC			NextB2
  6852 CDEC B1 6D			LDA	(str_pl),Y		; get character from string
  6853 CDEE C9 30			CMP	#'0'			; compare with '0'
  6854 CDF0 D0 07			BNE	GoPr			; if not '0' then go print string from here
  6855
  6856 CDF2 CA				DEX				; decrement character count
  6857 CDF3 F0 03			BEQ	GoPr3			; if zero then end of string so go print it
  6858
  6859 CDF5 C8				INY				; else increment index
  6860 CDF6 10 F4			BPL	NextB2			; loop always
  6861
  6862 				; make fixed length output string - ignore overflows!
  6863 CDF8			GoPr3
  6864 CDF8 E8				INX				; need at least 1 character
  6865 CDF9			GoPr
  6866 CDF9 98				TYA				; copy result
  6867 CDFA			GoPr1
  6868 CDFA 18				CLC				; clear carry for add
  6869 CDFB 65 6D			ADC	str_pl			; add low address
  6870 CDFD 85 6D			STA	str_pl			; save low address
  6871 CDFF A9 00			LDA	#$00			; do high byte
  6872 CE01 65 6E			ADC	str_ph			; add high address
  6873 CE03 85 6E			STA	str_ph			; save high address
  6874 CE05			GoPr2
  6875 CE05 86 6C			STX	str_ln			; X holds string length
  6876 CE07 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6877 CE0A 4C 72 C1			JMP	LAB_RTST		; check for space on descriptor stack then put address
  6878 									; and length on descriptor stack and update stack pointers
  6879
  6880 CE0D			BinFErr
  6881 CE0D 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  6882
  6883 				; perform HEX$()
  6884 CE10			LAB_HEXS
  6885 CE10 E0 07			CPX	#$07			; max + 1
  6886 CE12 B0 F9			BCS	BinFErr			; exit if too big ( > or = )
  6887
  6888 CE14 86 38			STX	TempB			; save # of characters
  6889
  6890 CE16 A9 06			LDA	#$06			; need 6 bytes for string
  6891 CE18 20 25 C1			JSR	LAB_MSSP		; make string space A bytes long
  6892 CE1B A0 05			LDY	#$05			; set string index
  6893
  6894 					; Disable decimal mode patch
  6895 					;SED				; need decimal mode for nibble convert
  6896 CE1D A5 13			LDA	nums_3			; get lowest byte
  6897 CE1F 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6898 CE22 A5 12			LDA	nums_2			; get middle byte
  6899 CE24 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6900 CE27 A5 11			LDA	nums_1			; get highest byte
  6901 CE29 20 3C CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6902 					;CLD				; back to binary
  6903
  6904 CE2C A2 06			LDX	#$06			; character count
  6905 CE2E A5 38			LDA	TempB			; get # of characters
  6906 CE30 F0 B9			BEQ	EndBHS			; branch if truncate
  6907
  6908 CE32 AA				TAX				; copy length to X
  6909 CE33 38				SEC				; set carry for add !
  6910 CE34 49 FF			EOR	#$FF			; 1's complement
  6911 CE36 69 06			ADC	#$06			; add 6d
  6912 CE38 F0 CB			BEQ	GoPr2			; if zero print whole string
  6913
  6914 CE3A D0 BE			BNE	GoPr1			; else go make output string (branch always)
  6915
  6916 				; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6917 CE3C			LAB_A2HX
  6918 CE3C AA				TAX				; save byte
  6919 CE3D 29 0F			AND	#$0F			; mask off top bits
  6920 CE3F 20 47 CE			JSR	LAB_AL2X		; convert low nibble to ASCII and output
  6921 CE42 8A				TXA				; get byte back
  6922 CE43 4A				LSR				; /2	shift high nibble to low nibble
  6923 CE44 4A				LSR				; /4
  6924 CE45 4A				LSR				; /8
  6925 CE46 4A				LSR				; /16
  6926 CE47			LAB_AL2X				; Disable decimal mode patch added
  6927 CE47 C9 0A			CMP	#$0A			; set carry for +1 if >9
  6928 CE49 90 02			BCC   	LAB_AL20          	; skip adjust if <= 9
  6929 CE4B 69 06			ADC   	#$06              	; adjust for A to F 
  6930 CE4D			LAB_AL20
  6931 CE4D 69 30			ADC	#'0'			; add ASCII '0'
  6932 CE4F 91 6D			STA	(str_pl),Y		; save to temp string
  6933 CE51 88				DEY				; decrement counter
  6934 CE52 60				RTS
  6935
  6936 CE53			LAB_NLTO
  6937 CE53 85 6C			STA	FAC1_e			; save FAC1 exponent
  6938 CE55 A9 00			LDA	#$00			; clear sign compare
  6939 CE57			LAB_MLTE
  6940 CE57 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6941 CE59 8A				TXA				; restore character
  6942 CE5A 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6943
  6944 				; gets here if the first character was '$' for hex
  6945 				; get hex number
  6946 CE5D			LAB_CHEX
  6947 CE5D 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6948 CE60 90 0A			BCC	LAB_ISHN		; branch if numeric character
  6949
  6950 CE62 09 20			ORA	#$20			; case convert, allow 'A' to 'F' and 'a' to 'f'
  6951 CE64 E9 61			SBC	#'a'			; subtract 'a' (carry set here)
  6952 CE66 C9 06			CMP	#$06			; compare normalised with $06 (max+1)
  6953 CE68 B0 2A			BCS	LAB_EXCH		; exit if >'f' or <'0'
  6954
  6955 CE6A 69 0A			ADC	#$0A			; convert to nibble
  6956 CE6C			LAB_ISHN
  6957 CE6C 29 0F			AND	#$0F			; convert to binary
  6958 CE6E AA				TAX				; save nibble
  6959 CE6F A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6960 CE71 F0 E4			BEQ	LAB_MLTE		; skip multiply if zero
  6961
  6962 CE73 69 04			ADC	#$04			; add four to exponent (*16 - carry clear here)
  6963 CE75 90 DC			BCC	LAB_NLTO		; if no overflow do evaluate digit
  6964
  6965 CE77			LAB_MLTO
  6966 CE77 4C B0 C6			JMP	LAB_2564		; do overflow error and warm start
  6967
  6968 CE7A			LAB_NXCH
  6969 CE7A AA				TAX				; save bit
  6970 CE7B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6971 CE7D F0 06			BEQ	LAB_MLBT		; skip multiply if zero
  6972
  6973 CE7F E6 6C			INC	FAC1_e			; increment FAC1 exponent (*2)
  6974 CE81 F0 F4			BEQ	LAB_MLTO		; do overflow error if = $00
  6975
  6976 CE83 A9 00			LDA	#$00			; clear sign compare
  6977 CE85			LAB_MLBT
  6978 CE85 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6979 CE87 8A				TXA				; restore bit
  6980 CE88 20 32 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6981
  6982 				; gets here if the first character was  '%' for binary
  6983 				; get binary number
  6984 CE8B			LAB_CBIN
  6985 CE8B 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6986 CE8E 49 30			EOR	#'0'			; convert '0' to 0 etc.
  6987 CE90 C9 02			CMP	#$02			; compare with max+1
  6988 CE92 90 E6			BCC	LAB_NXCH		; branch exit if < 2
  6989
  6990 CE94			LAB_EXCH
  6991 CE94 4C 17 CA			JMP	LAB_28F6		; evaluate -ve flag and return
  6992
  6993 				; ctrl-c check routine. includes limited 'life' byte save for INGET routine
  6994 				; now also the code that checks to see if an interrupt has occurred
  6995 CE97			CTRLC
  6996 CE97 AD 68 18			LDA	ccflag			; get [CTRL-C] check flag
  6997 CE9A D0 18			BNE	LAB_FBA2		; exit if inhibited
  6998
  6999 CE9C 20 0C D3			JSR	V_INPT			; scan input device
  7000 CE9F 90 0B			BCC	LAB_FBA0		; exit if buffer empty
  7001
  7002 CEA1 8D 69 18			STA	ccbyte			; save received byte
  7003 CEA4 A2 20			LDX	#$20			; 'life' timer for bytes
  7004 CEA6 8E 6A 18			STX	ccnull			; set countdown
  7005 CEA9 4C F6 B4			JMP	LAB_1636		; return to BASIC
  7006
  7007 CEAC			LAB_FBA0
  7008 CEAC AE 6A 18			LDX	ccnull			; get countdown byte
  7009 CEAF F0 03			BEQ	LAB_FBA2		; exit if finished
  7010
  7011 CEB1 CE 6A 18			DEC	ccnull			; else decrement countdown
  7012 CEB4			LAB_FBA2
  7013 CEB4 A2 03			LDX	#NmiBase		; set pointer to NMI values
  7014 CEB6 20 BF CE			JSR	LAB_CKIN		; go check interrupt
  7015 CEB9 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7016 CEBB 20 BF CE			JSR	LAB_CKIN		; go check interrupt
  7017 CEBE			LAB_CRTS
  7018 CEBE 60				RTS
  7019
  7020 				; check whichever interrupt is indexed by X
  7021 CEBF			LAB_CKIN
  7022 CEBF B5 00			LDA	PLUS_0,X		; get interrupt flag byte
  7023 CEC1 10 FB			BPL	LAB_CRTS		; branch if interrupt not enabled
  7024
  7025 				; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  7026 				; automatically enable the interrupt when we exit
  7027 CEC3 0A				ASL				; move happened bit to setup bit
  7028 CEC4 29 40			AND	#$40			; mask happened bits
  7029 CEC6 F0 F6			BEQ	LAB_CRTS		; if no interrupt then exit
  7030
  7031 CEC8 95 00			STA	PLUS_0,X		; save interrupt flag byte
  7032
  7033 CECA 8A				TXA				; copy index ..
  7034 CECB A8				TAY				; .. to Y
  7035
  7036 CECC 68				PLA				; dump return address low byte, call from CTRL-C
  7037 CECD 68				PLA				; dump return address high byte
  7038
  7039 CECE A9 05			LDA	#$05			; need 5 bytes for GOSUB
  7040 CED0 20 CF B0			JSR	LAB_1212		; check room on stack for A bytes
  7041 CED3 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  7042 CED5 48				PHA				; push on stack
  7043 CED6 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  7044 CED8 48				PHA				; push on stack
  7045 CED9 A5 48			LDA	Clineh			; get current line high byte
  7046 CEDB 48				PHA				; push on stack
  7047 CEDC A5 47			LDA	Clinel			; get current line low byte
  7048 CEDE 48				PHA				; push on stack
  7049 CEDF A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  7050 CEE1 48				PHA				; push on stack
  7051
  7052 CEE2 B9 01 00			LDA	PLUS_1,Y		; get interrupt code pointer low byte
  7053 CEE5 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  7054 CEE7 B9 02 00			LDA	PLUS_2,Y		; get interrupt code pointer high byte
  7055 CEEA 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  7056
  7057 CEEC 4C 9D B4			JMP	LAB_15C2		; go do interpreter inner loop
  7058 									; can't RTS, we used the stack! the RTS from the ctrl-c
  7059 									; check will be taken when the RETIRQ/RETNMI/RETURN is
  7060 									; executed at the end of the subroutine
  7061
  7062 				; get byte from input device, no waiting
  7063 				; returns with carry set if byte in A
  7064 CEEF			INGET
  7065 CEEF 20 0C D3			JSR	V_INPT			; call scan input device
  7066 CEF2 B0 09			BCS	LAB_FB95		; if byte go reset timer
  7067
  7068 CEF4 AD 6A 18			LDA	ccnull			; get countdown
  7069 CEF7 F0 09			BEQ	LAB_FB96		; exit if empty
  7070
  7071 CEF9 AD 69 18			LDA	ccbyte			; get last received byte
  7072 CEFC 38				SEC				; flag we got a byte
  7073 CEFD			LAB_FB95
  7074 CEFD A2 00			LDX	#$00			; clear X
  7075 CEFF 8E 6A 18			STX	ccnull			; clear timer because we got a byte
  7076 CF02			LAB_FB96
  7077 CF02 60				RTS
  7078
  7079 				; these routines only enable the interrupts if the set-up flag is set
  7080 				; if not they have no effect
  7081
  7082 				; perform IRQ {ON|OFF|CLEAR}
  7083 CF03			LAB_IRQ
  7084 CF03 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7085 CF05 2C				.byte	$2C			; make next line BIT abs.
  7086
  7087 				; perform NMI {ON|OFF|CLEAR}
  7088 CF06			LAB_NMI
  7089 CF06 A2 03			LDX	#NmiBase		; set pointer to NMI values
  7090 CF08 C9 93			CMP	#TK_ON			; compare with token for ON
  7091 CF0A F0 11			BEQ	LAB_INON		; go turn on interrupt
  7092
  7093 CF0C C9 CA			CMP	#TK_OFF			; compare with token for OFF
  7094 CF0E F0 07			BEQ	LAB_IOFF		; go turn off interrupt
  7095
  7096 CF10 49 A2			EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
  7097 CF12 F0 0E			BEQ	LAB_INEX		; go clear interrupt flags and return
  7098
  7099 CF14 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  7100
  7101 CF17			LAB_IOFF
  7102 CF17 A9 7F			LDA	#$7F			; clear A
  7103 CF19 35 00			AND	PLUS_0,X		; AND with interrupt setup flag
  7104 CF1B 10 05			BPL	LAB_INEX		; go clear interrupt enabled flag and return
  7105
  7106 CF1D			LAB_INON
  7107 CF1D B5 00			LDA	PLUS_0,X		; get interrupt setup flag
  7108 CF1F 0A				ASL				; Shift bit to enabled flag
  7109 CF20 15 00			ORA	PLUS_0,X		; OR with flag byte
  7110 CF22			LAB_INEX
  7111 CF22 95 00			STA	PLUS_0,X		; save interrupt flag byte
  7112 CF24 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer and return
  7113
  7114 				; these routines set up the pointers and flags for the interrupt routines
  7115 				; note that the interrupts are also enabled by these commands
  7116
  7117 				; perform ON IRQ
  7118 CF27			LAB_SIRQ
  7119 CF27 58				CLI				; enable interrupts
  7120 CF28 A2 06			LDX	#IrqBase		; set pointer to IRQ values
  7121 CF2A 2C				.byte	$2C			; make next line BIT abs.
  7122
  7123 				; perform ON NMI
  7124 CF2B			LAB_SNMI
  7125 CF2B A2 03			LDX	#NmiBase		; set pointer to NMI values
  7126
  7127 CF2D 86 38			STX	TempB			; save interrupt pointer
  7128 CF2F 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (past token)
  7129 CF32 20 33 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  7130 CF35 A5 39			LDA	Smeml			; get start of mem low byte
  7131 CF37 A6 3A			LDX	Smemh			; get start of mem high byte
  7132 CF39 20 0B B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  7133 CF3C B0 03			BCS	LAB_LFND		; if carry set go set-up interrupt
  7134
  7135 CF3E 4C 4D B6			JMP	LAB_16F7		; else go do 'Undefined statement' error and warm start
  7136
  7137 CF41			LAB_LFND
  7138 CF41 A6 38			LDX	TempB			; get interrupt pointer
  7139 CF43 A5 6A			LDA	Baslnl			; get pointer low byte
  7140 CF45 E9 01			SBC	#$01			; -1 (carry already set for subtract)
  7141 CF47 95 01			STA	PLUS_1,X		; save as interrupt pointer low byte
  7142 CF49 A5 6B			LDA	Baslnh			; get pointer high byte
  7143 CF4B E9 00			SBC	#$00			; subtract carry
  7144 CF4D 95 02			STA	PLUS_2,X		; save as interrupt pointer high byte
  7145
  7146 CF4F A9 C0			LDA	#$C0			; set interrupt enabled/setup bits
  7147 CF51 95 00			STA	PLUS_0,X		; set interrupt flags
  7148 CF53			LAB_IRTS
  7149 CF53 60				RTS
  7150
  7151 				; return from IRQ service, restores the enabled flag.
  7152
  7153 				; perform RETIRQ
  7154 CF54			LAB_RETIRQ
  7155 CF54 D0 FD			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7156
  7157 CF56 A5 06			LDA	IrqBase			; get interrupt flags
  7158 CF58 0A				ASL				; copy setup to enabled (b7)
  7159 CF59 05 06			ORA	IrqBase			; OR in setup flag
  7160 CF5B 85 06			STA	IrqBase			; save enabled flag
  7161 CF5D 4C 54 B6			JMP	LAB_16E8		; go do rest of RETURN
  7162
  7163 				; return from NMI service, restores the enabled flag.
  7164
  7165 				; perform RETNMI
  7166 CF60			LAB_RETNMI
  7167 CF60 D0 F1			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7168
  7169 CF62 A5 03			LDA	NmiBase			; get set-up flag
  7170 CF64 0A				ASL				; copy setup to enabled (b7)
  7171 CF65 05 03			ORA	NmiBase			; OR in setup flag
  7172 CF67 85 03			STA	NmiBase			; save enabled flag
  7173 CF69 4C 54 B6			JMP	LAB_16E8		; go do rest of RETURN
  7174
  7175 				; MAX() MIN() pre process
  7176 CF6C			LAB_MMPP
  7177 CF6C 20 C6 BA			JSR	LAB_EVEZ		; process expression
  7178 CF6F 4C AD BA			JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  7179
  7180 				; perform MAX()
  7181 CF72			LAB_MAX
  7182 CF72 20 A0 CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7183 									; pull FAC2 and compare with FAC1
  7184 CF75 10 FB			BPL	LAB_MAX			; branch if no swap to do
  7185
  7186 CF77 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7187 CF79 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7188 CF7B 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7189 CF7D 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7190 CF80 F0 F0			BEQ	LAB_MAX			; go do next (branch always)
  7191
  7192 				; perform MIN()
  7193 CF82			LAB_MIN
  7194 CF82 20 A0 CF			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7195 									; pull FAC2 and compare with FAC1
  7196 CF85 30 FB			BMI	LAB_MIN			; branch if no swap to do
  7197
  7198 CF87 F0 F9			BEQ	LAB_MIN			; branch if no swap to do
  7199
  7200 CF89 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  7201 CF8B 09 80			ORA	#$80			; set top bit (clear sign from compare)
  7202 CF8D 85 74			STA	FAC2_1			; save FAC2 mantissa1
  7203 CF8F 20 B0 C5			JSR	LAB_279B		; copy FAC2 to FAC1
  7204 CF92 F0 EE			BEQ	LAB_MIN			; go do next (branch always)
  7205
  7206 				; exit routine. don't bother returning to the loop code
  7207 				; check for correct exit, else so syntax error
  7208 CF94			LAB_MMEC
  7209 CF94 C9 29			CMP	#')'			; is it end of function?
  7210 CF96 D0 05			BNE	LAB_MMSE		; if not do MAX MIN syntax error
  7211
  7212 CF98 68				PLA				; dump return address low byte
  7213 CF99 68				PLA				; dump return address high byte
  7214 CF9A 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ')')
  7215
  7216 CF9D			LAB_MMSE
  7217 CF9D 4C DF BB			JMP	LAB_SNER		; do syntax error then warm start
  7218
  7219 				; check for next, evaluate and return or exit
  7220 				; this is the routine that does most of the work
  7221 CFA0			LAB_PHFA
  7222 CFA0 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  7223 CFA3 C9 2C			CMP	#','			; is there more ?
  7224 CFA5 D0 ED			BNE	LAB_MMEC		; if not go do end check
  7225
  7226 									; push FAC1
  7227 CFA7 20 C6 C8			JSR	LAB_27BA		; round FAC1
  7228 CFAA A5 70			LDA	FAC1_s			; get FAC1 sign
  7229 CFAC 09 7F			ORA	#$7F			; set all non sign bits
  7230 CFAE 25 6D			AND	FAC1_1			; AND FAC1 mantissa1 (AND in sign bit)
  7231 CFB0 48				PHA				; push on stack
  7232 CFB1 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  7233 CFB3 48				PHA				; push on stack
  7234 CFB4 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  7235 CFB6 48				PHA				; push on stack
  7236 CFB7 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  7237 CFB9 48				PHA				; push on stack
  7238
  7239 CFBA 20 7C 00			JSR	LAB_IGBY		; scan and get next BASIC byte (after ',')
  7240 CFBD 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7241 									; else do type mismatch
  7242
  7243 									; pop FAC2 (MAX/MIN expression so far)
  7244 CFC0 68				PLA				; pop exponent
  7245 CFC1 85 73			STA	FAC2_e			; save FAC2 exponent
  7246 CFC3 68				PLA				; pop mantissa3
  7247 CFC4 85 76			STA	FAC2_3			; save FAC2 mantissa3
  7248 CFC6 68				PLA				; pop mantissa1
  7249 CFC7 85 75			STA	FAC2_2			; save FAC2 mantissa2
  7250 CFC9 68				PLA				; pop sign/mantissa1
  7251 CFCA 85 74			STA	FAC2_1			; save FAC2 sign/mantissa1
  7252 CFCC 85 77			STA	FAC2_s			; save FAC2 sign
  7253
  7254 									; compare FAC1 with (packed) FAC2
  7255 CFCE A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  7256 CFD0 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  7257 CFD2 4C 04 C9			JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  7258 									; returns A=$00 if FAC1 = (AY)
  7259 									; returns A=$01 if FAC1 > (AY)
  7260 									; returns A=$FF if FAC1 < (AY)
  7261
  7262 				; perform WIDTH
  7263 CFD5			LAB_WDTH
  7264 CFD5 C9 2C			CMP	#','			; is next byte ','
  7265 CFD7 F0 1B			BEQ	LAB_TBSZ		; if so do tab size
  7266
  7267 CFD9 20 79 C4			JSR	LAB_GTBY		; get byte parameter
  7268 CFDC 8A				TXA				; copy width to A
  7269 CFDD F0 0A			BEQ	LAB_NSTT		; branch if set for infinite line
  7270
  7271 CFDF E0 10			CPX	#$10			; else make min width = 16d
  7272 CFE1 90 45			BCC	TabErr			; if less do function call error and exit
  7273
  7274 				; this next compare ensures that we can't exit WIDTH via an error leaving the
  7275 				; tab size greater than the line length.
  7276 CFE3 E4 24			CPX	TabSiz			; compare with tab size
  7277 CFE5 B0 02			BCS	LAB_NSTT		; branch if >= tab size
  7278
  7279 CFE7 86 24			STX	TabSiz			; else make tab size = terminal width
  7280 CFE9			LAB_NSTT
  7281 CFE9 86 0F			STX	TWidth			; set the terminal width
  7282 CFEB 20 82 00			JSR	LAB_GBYT		; get BASIC byte back
  7283 CFEE F0 1A			BEQ	WExit			; exit if no following
  7284
  7285 CFF0 C9 2C			CMP	#','			; else is it ','
  7286 CFF2 D0 A9			BNE	LAB_MMSE		; if not do syntax error
  7287
  7288 CFF4			LAB_TBSZ
  7289 CFF4 20 76 C4			JSR	LAB_SGBY		; scan and get byte parameter
  7290 CFF7 8A				TXA				; copy TAB size
  7291 CFF8 30 2E			BMI	TabErr			; if >127 do function call error and exit
  7292
  7293 CFFA E0 01			CPX	#$01			; compare with min-1
  7294 CFFC 90 2A			BCC	TabErr			; if <=1 do function call error and exit
  7295
  7296 CFFE A5 0F			LDA	TWidth			; set flags for width
  7297 D000 F0 06			BEQ	LAB_SVTB		; skip check if infinite line
  7298
  7299 D002 E4 0F			CPX	TWidth			; compare TAB with width
  7300 D004 F0 02			BEQ	LAB_SVTB		; ok if =
  7301
  7302 D006 B0 20			BCS	TabErr			; branch if too big
  7303
  7304 D008			LAB_SVTB
  7305 D008 86 24			STX	TabSiz			; save TAB size
  7306
  7307 				; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7308 				; position on a line that still has at least one whole tab width between it
  7309 				; and the end of the line.
  7310 D00A			WExit
  7311 D00A A5 0F			LDA	TWidth			; get width
  7312 D00C F0 06			BEQ	LAB_SULP		; branch if infinite line
  7313
  7314 D00E C5 24			CMP	TabSiz			; compare with tab size
  7315 D010 B0 03			BCS	LAB_WDLP		; branch if >= tab size
  7316
  7317 D012 85 24			STA	TabSiz			; else make tab size = terminal width
  7318 D014			LAB_SULP
  7319 D014 38				SEC				; set carry for subtract
  7320 D015			LAB_WDLP
  7321 D015 E5 24			SBC	TabSiz			; subtract tab size
  7322 D017 B0 FC			BCS	LAB_WDLP		; loop while no borrow
  7323
  7324 D019 65 24			ADC	TabSiz			; add tab size back
  7325 D01B 18				CLC				; clear carry for add
  7326 D01C 65 24			ADC	TabSiz			; add tab size back again
  7327 D01E 85 10			STA	Iclim			; save for now
  7328 D020 A5 0F			LDA	TWidth			; get width back
  7329 D022 38				SEC				; set carry for subtract
  7330 D023 E5 10			SBC	Iclim			; subtract remainder
  7331 D025 85 10			STA	Iclim			; save tab column limit
  7332 D027			LAB_NOSQ
  7333 D027 60				RTS
  7334
  7335 D028			TabErr
  7336 D028 4C 08 BF			JMP	LAB_FCER		; do function call error then warm start
  7337
  7338 				; perform SQR()
  7339 D02B			LAB_SQR
  7340 D02B A5 70			LDA	FAC1_s			; get FAC1 sign
  7341 D02D 30 F9			BMI	TabErr			; if -ve do function call error
  7342
  7343 D02F A5 6C			LDA	FAC1_e			; get exponent
  7344 D031 F0 F4			BEQ	LAB_NOSQ		; if zero just return
  7345
  7346 									; else do root
  7347 D033 20 B7 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  7348 D036 A9 00			LDA	#$00			; clear A
  7349
  7350 D038 85 37			STA	FACt_3			; clear remainder
  7351 D03A 85 36			STA	FACt_2			; ..
  7352 D03C 85 35			STA	FACt_1			; ..
  7353 D03E 85 38			STA	TempB			; ..
  7354
  7355 D040 85 6F			STA	FAC1_3			; clear root
  7356 D042 85 6E			STA	FAC1_2			; ..
  7357 D044 85 6D			STA	FAC1_1			; ..
  7358
  7359 D046 A2 18			LDX	#$18			; 24 pairs of bits to do
  7360 D048 A5 73			LDA	FAC2_e			; get exponent
  7361 D04A 4A				LSR				; check odd/even
  7362 D04B B0 0E			BCS	LAB_SQE2		; if odd only 1 shift first time
  7363
  7364 D04D			LAB_SQE1
  7365 D04D 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7366 D04F 26 75			ROL	FAC2_2			; ..
  7367 D051 26 74			ROL	FAC2_1			; ..
  7368 D053 26 37			ROL	FACt_3			; .. into remainder
  7369 D055 26 36			ROL	FACt_2			; ..
  7370 D057 26 35			ROL	FACt_1			; ..
  7371 D059 26 38			ROL	TempB			; .. never overflows
  7372 D05B			LAB_SQE2
  7373 D05B 06 76			ASL	FAC2_3			; shift highest bit of number ..
  7374 D05D 26 75			ROL	FAC2_2			; ..
  7375 D05F 26 74			ROL	FAC2_1			; ..
  7376 D061 26 37			ROL	FACt_3			; .. into remainder
  7377 D063 26 36			ROL	FACt_2			; ..
  7378 D065 26 35			ROL	FACt_1			; ..
  7379 D067 26 38			ROL	TempB			; .. never overflows
  7380
  7381 D069 06 6F			ASL	FAC1_3			; root = root * 2
  7382 D06B 26 6E			ROL	FAC1_2			; ..
  7383 D06D 26 6D			ROL	FAC1_1			; .. never overflows
  7384
  7385 D06F A5 6F			LDA	FAC1_3			; get root low byte
  7386 D071 2A				ROL				; *2
  7387 D072 85 1B			STA	Temp3			; save partial low byte
  7388 D074 A5 6E			LDA	FAC1_2			; get root low mid byte
  7389 D076 2A				ROL				; *2
  7390 D077 85 1C			STA	Temp3+1			; save partial low mid byte
  7391 D079 A5 6D			LDA	FAC1_1			; get root high mid byte
  7392 D07B 2A				ROL				; *2
  7393 D07C 85 1D			STA	Temp3+2			; save partial high mid byte
  7394 D07E A9 00			LDA	#$00			; get root high byte (always $00)
  7395 D080 2A				ROL				; *2
  7396 D081 85 1E			STA	Temp3+3			; save partial high byte
  7397
  7398 									; carry clear for subtract +1
  7399 D083 A5 37			LDA	FACt_3			; get remainder low byte
  7400 D085 E5 1B			SBC	Temp3			; subtract partial low byte
  7401 D087 85 1B			STA	Temp3			; save partial low byte
  7402
  7403 D089 A5 36			LDA	FACt_2			; get remainder low mid byte
  7404 D08B E5 1C			SBC	Temp3+1			; subtract partial low mid byte
  7405 D08D 85 1C			STA	Temp3+1			; save partial low mid byte
  7406
  7407 D08F A5 35			LDA	FACt_1			; get remainder high mid byte
  7408 D091 E5 1D			SBC	Temp3+2			; subtract partial high mid byte
  7409 D093 A8				TAY				; copy partial high mid byte
  7410
  7411 D094 A5 38			LDA	TempB			; get remainder high byte
  7412 D096 E5 1E			SBC	Temp3+3			; subtract partial high byte
  7413 D098 90 0E			BCC	LAB_SQNS		; skip sub if remainder smaller
  7414
  7415 D09A 85 38			STA	TempB			; save remainder high byte
  7416
  7417 D09C 84 35			STY	FACt_1			; save remainder high mid byte
  7418
  7419 D09E A5 1C			LDA	Temp3+1			; get remainder low mid byte
  7420 D0A0 85 36			STA	FACt_2			; save remainder low mid byte
  7421
  7422 D0A2 A5 1B			LDA	Temp3			; get partial low byte
  7423 D0A4 85 37			STA	FACt_3			; save remainder low byte
  7424
  7425 D0A6 E6 6F			INC	FAC1_3			; increment root low byte (never any rollover)
  7426 D0A8			LAB_SQNS
  7427 D0A8 CA				DEX				; decrement bit pair count
  7428 D0A9 D0 A2			BNE	LAB_SQE1		; loop if not all done
  7429
  7430 D0AB 38				SEC				; set carry for subtract
  7431 D0AC A5 73			LDA	FAC2_e			; get exponent
  7432 D0AE E9 80			SBC	#$80			; normalise
  7433 D0B0 6A				ROR				; /2 and re-bias to $80
  7434 D0B1 69 00			ADC	#$00			; add bit zero back in (allow for half shift)
  7435 D0B3 85 6C			STA	FAC1_e			; save it
  7436 D0B5 4C 21 C6			JMP	LAB_24D5		; normalise FAC1 and return
  7437
  7438 				; perform VARPTR()
  7439 D0B8			LAB_VARPTR
  7440 D0B8 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  7441 D0BB 20 89 BD			JSR	LAB_GVAR		; get var address
  7442 D0BE 20 CC BB			JSR	LAB_1BFB		; scan for ')" , else do syntax error then warm start
  7443 D0C1 A4 55			LDY	Cvaral			; get var address low byte
  7444 D0C3 A5 56			LDA	Cvarah			; get var address high byte
  7445 D0C5 4C 38 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  7446
  7447 				; perform PI
  7448 D0C8			LAB_PI
  7449 D0C8 A9 CF			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7450 D0CA A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7451 D0CC 20 6A C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  7452 D0CF C6 6C			DEC	FAC1_e			; make result = PI
  7453 D0D1 60				RTS
  7454
  7455 				; perform TWOPI
  7456 D0D2			LAB_TWOPI
  7457 D0D2 A9 CF			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7458 D0D4 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7459 D0D6 4C 6A C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
  7460 					
  7461 				; *****************************************
  7462 				; ** New Commands For Junior Computer 2 ***
  7463 				; *****************************************
  7464 D0D9			LAB_MOD
  7465 D0D9 60				RTS
  7466 				;	LDX	#$04
  7467 				;LAB_STO_FAC2
  7468 				;	LDA	FAC2_e,X
  7469 				;	PHA
  7470 				;	DEX
  7471 				;	BPL	LAB_STO_FAC2
  7472 D0DA A2 04			LDX	#$04
  7473 D0DC			LAB_STO_FAC1
  7474 D0DC B5 6C			LDA	FAC1_e,X
  7475 D0DE 48				PHA
  7476 D0DF CA				DEX
  7477 D0E0 10 FA			BPL	LAB_STO_FAC1
  7478
  7479 D0E2 20 F1 C7			JSR 	LAB_DIVIDE
  7480 D0E5 20 6E C9			JSR	LAB_INT
  7481
  7482 D0E8 20 BA C8			JSR	LAB_27AE
  7483 				;	LDX	#$00
  7484 				;	STX	FAC1_r
  7485 				;LAB_LOD_FAC2_1
  7486 				;	PLA
  7487 				;	STA	FAC1_e,X
  7488 				;	INX
  7489 				;	CPX	#$05
  7490 				;	BNE	LAB_LOD_FAC2_1
  7491
  7492 					;JSR	LAB_MULTIPLY
  7493 					
  7494 D0EB A2 00			LDX	#$00
  7495 D0ED			LAB_LOD_FAC2_2
  7496 D0ED 68				PLA
  7497 D0EE 95 6C			STA	FAC1_e,X
  7498 D0F0 E8				INX
  7499 D0F1 E0 05			CPX	#$05
  7500 D0F3 D0 F8			BNE	LAB_LOD_FAC2_2
  7501
  7502 					;JSR	LAB_SUBTRACT
  7503 D0F5 20 29 C7			JSR	LAB_MULTIPLY
  7504
  7505 D0F8 60				RTS
  7506
  7507 				; Call Device Command Routine *************
  7508 D0F9			CALL_CMD
  7509 D0F9 6C 6C 1A			JMP	(DEVCMD)		; current opened device command vector (Junior Computer 2)
  7510
  7511 				; Get Null Terminated String Parameter ****
  7512 D0FC			LAB_GETSTRPARM
  7513 D0FC 85 1A			STA	Temp1
  7514 D0FE 20 BE BA			JSR	LAB_EVEX		; evaluate expression
  7515 D101 A5 1F			LDA	Dtypef			; is it a string expression
  7516 D103 D0 03			BNE	LAB_GETSTR0		; yes, get string				
  7517 D105 20 B9 BA			JSR	LAB_1ABC		; no, throw type mismatch error
  7518 D108			LAB_GETSTR0
  7519 D108 A0 00			LDY	#$00			; set string index to 0
  7520 D10A			LAB_GETSTR1
  7521 D10A B1 78			LDA	(ssptr_l),Y		; load a string char
  7522 D10C F0 0B			BEQ	LAB_GETSTR2		; is it a NULL? yes, exit
  7523 D10E C9 22			CMP	#'"'			; is it a '"'?
  7524 D110 F0 03			BEQ	LAB_TERM		; yes, set string termination
  7525 D112 C8				INY				; increment string index
  7526 D113 D0 F5			BNE	LAB_GETSTR1		; and repeat loop
  7527 D115			LAB_TERM
  7528 D115 A9 00			LDA 	#$00			; store termination char
  7529 D117 91 78			STA 	(ssptr_l),Y		; at the end of the string
  7530 D119			LAB_GETSTR2
  7531 D119 A6 78			LDX	ssptr_l			; load string pointer low byte into X
  7532 D11B A4 79			LDY	ssptr_h			; load string pointer high byte into X
  7533 D11D A5 1A			LDA	Temp1
  7534 D11F 60				RTS
  7535
  7536 				; Get Device Parameters *******************
  7537 D120			LAB_GETDEVPARM
  7538 D120 20 79 C4			JSR	LAB_GTBY		; scan for byte value
  7539 D123 8A				TXA				; and set A to result
  7540 D124 F0 08			BEQ	LAB_DEV0		; device is 0, no more parameters needed
  7541 D126 85 1A			STA	Temp1			; save device number
  7542 D128 20 DB BB			JSR	LAB_1C01		; check for ','
  7543 D12B A5 1A			LDA	Temp1
  7544 D12D 60				RTS
  7545 D12E			LAB_DEV0
  7546 D12E 4C CE BB			JMP	LAB_SCCA		; check if more token, if so throw syntax error
  7547
  7548 				; Get Two Byte Parameters *****************
  7549 D131			LAB_GET2BYTEPARMS
  7550 					;JSR	LAB_EVBY		; evaluate byte expression, result in X
  7551 D131 20 79 C4			JSR	LAB_GTBY		; get first byte parameter into X
  7552 D134 86 1A			STX	Temp1			; and store it in temp var
  7553 D136 20 DB BB			JSR	LAB_1C01		; check for ',' else syntax error
  7554 D139 20 79 C4			JSR	LAB_GTBY		; get second byte parameter into X
  7555 D13C 8A				TXA
  7556 D13D A8				TAY				; and transfer it into Y
  7557 D13E A6 1A			LDX	Temp1			; restore first parameter into X
  7558 D140 60				RTS
  7559
  7560 				; get device number parameter *************
  7561 D141			LAB_GETDEVID
  7562 D141 20 79 C4			JSR	LAB_GTBY		; get byte parameter into X
  7563 D144 8A				TXA				; and transfer it into A
  7564 D145 09 10			ORA	#$10			; search for stdio devices
  7565 D147 60				RTS
  7566
  7567 				; Select GPIO Device **********************
  7568 D148			LAB_SEL_PORT
  7569 D148 E0 01			CPX	#$01
  7570 D14A D0 04			BNE	LAB_PORTA
  7571 D14C A0 00			LDY	#VIA_PORTB
  7572 D14E 18				CLC
  7573 D14F 60				RTS
  7574 D150			LAB_PORTA
  7575 D150 E0 02			CPX	#$02
  7576 D152 B0 02			BCS	LAB_I2C_ADR	
  7577 D154 A0 01			LDY	#VIA_PORTA
  7578 D156			LAB_I2C_ADR
  7579 D156 60				RTS
  7580
  7581 				; perform LOAD ****************************
  7582 D157			LAB_LOAD 
  7583 D157 D0 04			BNE	LOAD_DEV		; if no following token use device 0
  7584 D159 A9 00			LDA	#$00			; set device id = 0
  7585 D15B F0 03			BEQ	SET_LOADADR
  7586 D15D			LOAD_DEV
  7587 D15D 20 20 D1			JSR	LAB_GETDEVPARM		; get device id
  7588 D160			SET_LOADADR
  7589 D160 48				PHA
  7590 D161 A2 00			LDX	#$00
  7591 D163 86 CE			STX	FILE_PTR		; set load destination address low
  7592 D165 A2 20			LDX	#$20
  7593 D167 86 CF			STX	FILE_PTR+1		; set load destination address high
  7594 D169 09 20			ORA	#$20			; it's a storage device
  7595 D16B 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7596 D16E 68				PLA
  7597 D16F F0 03			BEQ	CALL_LOAD		; device id = 0?
  7598 D171 20 FC D0			JSR	LAB_GETSTRPARM		; no, get string parameter
  7599 D174			CALL_LOAD
  7600 D174 A9 20			LDA	#CMD_LOAD
  7601 D176 20 F9 D0			JSR	CALL_CMD		; call load command
  7602 D179 90 40			BCC	CLEAR_BASE		; load interrupted, exit
  7603 D17B AE 00 20			LDX	Ram_base-1
  7604 D17E 86 3B			STX	Svarl
  7605 D180 AE 01 20			LDX	Ram_base
  7606 D183 86 3C			STX	Svarh
  7607 D185 20 BB D1			JSR	CLEAR_BASE
  7608 D188 4C 55 B3			JMP	LAB_147A
  7609
  7610 				; perform SAVE ****************************
  7611 D18B			LAB_SAVE
  7612 D18B D0 04			BNE	SAVE_DEV		; if no following token use device 0
  7613 D18D A9 00			LDA	#$00			; set device id = 0
  7614 D18F F0 03			BEQ	SET_SAVEADR
  7615 D191			SAVE_DEV
  7616 D191 20 20 D1			JSR	LAB_GETDEVPARM		; get device id
  7617 D194			SET_SAVEADR
  7618 D194 48				PHA
  7619 D195 A2 00			LDX	#$00
  7620 D197 86 CE			STX	FILE_PTR		; Start of File pointer LSB
  7621 D199 A2 20			LDX	#$20
  7622 D19B 86 CF			STX	FILE_PTR+1		; Start of File pointer MSB
  7623 D19D A6 3B			LDX	Svarl
  7624 D19F 8E 00 20			STX	Ram_base-1
  7625 D1A2 86 CC			STX	END_PTR			; End-address File pointer LSB
  7626 D1A4 A6 3C			LDX	Svarh
  7627 D1A6 8E 01 20			STX	Ram_base
  7628 D1A9 86 CD			STX	END_PTR+1		; End-address File pointer MSB
  7629 D1AB 09 20			ORA	#$20			; Disk-devices
  7630 D1AD 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7631 D1B0 68				PLA
  7632 D1B1 F0 03			BEQ	CALL_SAVE
  7633 D1B3 20 FC D0			JSR	LAB_GETSTRPARM		; X,Y = Ptr to Filename
  7634 D1B6			CALL_SAVE
  7635 D1B6 A9 21			LDA	#CMD_SAVE
  7636 D1B8 20 F9 D0			JSR	CALL_CMD		; Device-driver Write
  7637 D1BB			CLEAR_BASE
  7638 D1BB A2 00			LDX	#$00
  7639 D1BD 8E 00 20			STX	Ram_base-1
  7640 D1C0 8E 01 20			STX	Ram_base
  7641 D1C3 60				RTS
  7642 					
  7643 				; 'BEEP' command **************************
  7644 D1C4			LAB_JC001
  7645 D1C4 6C 66 1A			JMP 	(STDBEEP)		; Jump to Junior Computer standard BEEP routine
  7646
  7647 				; perform BEEP ****************************
  7648 D1C7			LAB_BEEP
  7649 D1C7 F0 FB			BEQ 	LAB_JC001		; if no following token go do 'BEEP'
  7650 D1C9 60				RTS
  7651
  7652 D1CA			LAB_SYSBEEP
  7653 D1CA 48				PHA
  7654 D1CB 98				TYA
  7655 D1CC 48				PHA
  7656 D1CD 8A				TXA
  7657 D1CE 48				PHA
  7658 D1CF 20 C4 D1			JSR	LAB_JC001
  7659 D1D2 68				PLA
  7660 D1D3 AA				TAX
  7661 D1D4 68				PLA
  7662 D1D5 A8				TAY
  7663 D1D6 68				PLA
  7664 D1D7 60				RTS	
  7665 					
  7666 				; perform PLIST ***************************
  7667 				; #### TODO: save current output device and restore pointer after list command !!!!!!!
  7668 D1D8			LAB_PLIST
  7669 D1D8 48			    	PHA				; save token
  7670 D1D9 AD 76 1A		    	LDA	STDPRINTDEV		; get standard printer id
  7671 D1DC 20 18 E0			JSR	SET_STDOUTID		; and set it as standard output device
  7672 D1DF 68				PLA				; restore token
  7673 D1E0 20 84 B3			JSR 	LAB_LIST		; call list command
  7674 D1E3 AD 75 1A			LDA	STDOUTDEV		; get standard output device id
  7675 D1E6 20 18 E0			JSR	SET_STDOUTID		; and set it as standard output device
  7676 D1E9 60				RTS
  7677
  7678 				; perform DOS ****************************
  7679 D1EA			LAB_DOS					; If no DOS is loaded, this could hang the system!
  7680 D1EA 6C 0A 18			JMP 	(RETURN_VECT)		; Return to DOS through return vector
  7681
  7682 				; perform HOME ****************************
  7683 D1ED			LAB_HOME
  7684 D1ED A9 05			LDA	#CMD_HOME
  7685 D1EF 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard HOME routine
  7686
  7687 				; perform CLS *****************************
  7688 D1F2			LAB_CLS
  7689 D1F2 A9 07			LDA	#CMD_CLRSCRN
  7690 D1F4 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard CLS routine
  7691
  7692 				; perform NORMAL **************************
  7693 D1F7			LAB_NORMAL
  7694 D1F7 A9 02			LDA	#CMD_NORMAL
  7695 D1F9 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard NORMAL routine
  7696
  7697 				; perform INVERSE *************************
  7698 D1FC			LAB_INVERSE
  7699 D1FC A9 03			LDA	#CMD_INVERSE
  7700 D1FE 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard INVERSE routine
  7701
  7702 				; perform FLASH ***************************
  7703 D201			LAB_FLASH
  7704 D201 A9 04			LDA	#CMD_FLASH
  7705 D203 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard FLASH routine
  7706 					
  7707 				; perform LOCATE **************************
  7708 D206			LAB_LOCATE
  7709 D206 F0 36			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7710 D208 20 31 D1			JSR	LAB_GET2BYTEPARMS	; get two byte parameters into X and Y
  7711 D20B A9 08			LDA	#CMD_SETCURSOR
  7712 D20D 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard SETCURSOR routine
  7713
  7714 				; perform IN# *****************************
  7715 D210			LAB_INNUM
  7716 D210 F0 2C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7717 D212 20 41 D1			JSR	LAB_GETDEVID
  7718 D215 4C 2F E0			JMP	SET_STDINID		; Set Standard In Routine ID
  7719
  7720 				; perform PR# *****************************
  7721 D218			LAB_PRNUM
  7722 D218 F0 24			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7723 D21A 20 41 D1			JSR	LAB_GETDEVID
  7724 D21D 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device
  7725
  7726 				; perform PORTIO **************************
  7727 D220			LAB_PORTIO
  7728 D220 F0 1C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7729 D222 20 31 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters
  7730 D225 98				TYA
  7731 D226 20 48 D1			JSR	LAB_SEL_PORT		; get port
  7732 D229 B0 04			BCS	LAB_I2C_DEV
  7733 D22B C8				INY				; add 2 because we want to write DDR
  7734 D22C C8				INY
  7735 D22D 91 14			STA	(IOBASE),Y
  7736 D22F			LAB_I2C_DEV
  7737 D22F 60				RTS
  7738
  7739 				; perform PORTOUT *************************
  7740 D230			LAB_PORTOUT
  7741 D230 F0 0C			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7742 D232 20 31 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters
  7743 D235 98				TYA
  7744 D236 20 48 D1			JSR	LAB_SEL_PORT		; get port
  7745 D239 B0 06			BCS	LAB_WRITEI2C		; port id > 1 -> write to i2c port
  7746 D23B 91 14			STA	(IOBASE),Y
  7747 D23D 60				RTS
  7748
  7749 D23E			LAB_SYNTAX_ERR
  7750 D23E 4C DF BB			JMP	LAB_SNER		; throw syntax error and return
  7751
  7752 				; perform WRITEI2C ************************
  7753 D241			LAB_WRITEI2C
  7754 D241 85 1A			STA	Temp1			; save data byte to Temp1
  7755 D243 20 26 E3			JSR	I2C_START		; Send I2C Start Condition
  7756 D246 8A				TXA				; transfer device address into A
  7757 D247 20 66 E3			JSR	I2C_WRITE_DEV		; Write I2C Device, set write mode. C = 1 acknowledged
  7758 D24A A5 1A			LDA	Temp1			; restore data byte to A
  7759 D24C 20 67 E3			JSR	I2C_SEND		; Send a Byte to I2C Device, C = 1 acknowledged
  7760 D24F 20 35 E3			JSR	I2C_STOP		; Send I2C Stop Condition
  7761 D252 60				RTS
  7762
  7763 				; perform I2C write operations ************
  7764 D253			LAB_I2COUT
  7765 D253 F0 E9			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7766 D255 20 31 D1			JSR	LAB_GET2BYTEPARMS	; get two parameters: X=addr, Y=ctrl
  7767 D258 86 1A			STX	Temp1			; Temp1=X=addr/data byte
  7768 D25A 98				TYA				; A=ctrl byte
  7769 D25B C9 01			CMP	#I2C_STA		; I2C-start?
  7770 D25D D0 08			BNE	I2C_WR			; branch if not I2C-start
  7771 					
  7772 D25F 20 26 E3			JSR	I2C_START		; send start condition (affects A and Y)
  7773 D262 E0 00			CPX	#$00			; Is address byte 0?
  7774 D264 D0 01			BNE	I2C_WR			; branch if address byte > 0
  7775 D266 60				RTS				; otherwise, just return
  7776
  7777 D267 A5 1A		I2C_WR	LDA	Temp1			; restore data byte to A
  7778 D269 20 67 E3			JSR	I2C_SEND		; I2C-write: write byte
  7779 D26C 90 04			BCC	SET_NAK			; C=0: NACK, C=1: ACK, branch if NACK
  7780
  7781 D26E A9 00			LDA	#0			; return I2C ACK (0)
  7782 D270 F0 02			BEQ	SV_NAK			; branch always
  7783 D272 A9 01		SET_NAK	LDA	#1			; return I2C NACK (1)
  7784 D274 85 9C		SV_NAK	STA	I2Cstat			; save in I2C status
  7785 D276 60				RTS
  7786
  7787 				; perform I2C read operations ************
  7788 D277			LAB_I2CIN
  7789 D277 20 DE C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer (Itempl)
  7790 D27A A5 11			LDA	Itempl			; get byte via temporary integer
  7791 D27C C9 03			CMP	#I2C_STO		; I2C-stop command only?
  7792 D27E F0 17			BEQ	I2C_STOP_CMD		; branch if stop-command only
  7793
  7794 D280 C9 00			CMP	#I2C_STAT		; Return I2Cstat result?
  7795 D282 F0 16			BEQ	I2C_RD_X		; branch if I2Cstat return only
  7796
  7797 D284 20 9F E3			JSR	I2C_RCV			; I2C-read: receive byte 
  7798 D287 85 9C			STA	I2Cstat			; save received byte
  7799 D289 A5 11			LDA	Itempl			; get ctrl byte back
  7800 D28B C9 01			CMP	#I2C_RD_ACK		; Read followed by ACK?
  7801 D28D D0 05			BNE	RD_NAK			; branch if not an ACK
  7802 					
  7803 D28F 20 44 E3			JSR	I2C_ACK			; send ACK (more bytes to read) and return
  7804 D292 D0 06			BNE	I2C_RD_X		; branch always
  7805 					
  7806 D294 20 53 E3		RD_NAK	JSR	I2C_NACK		; send NACK (done reading)
  7807 D297			I2C_STOP_CMD
  7808 D297 20 35 E3			JSR	I2C_STOP		; send I2C-stop Command
  7809 D29A			I2C_RD_X
  7810 D29A A4 9C			LDY	I2Cstat			; load I2C-status byte in Y
  7811 D29C 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7812 					
  7813 				; perform PORTIN **************************
  7814 D29F			LAB_PORTIN
  7815 D29F 20 7C C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  7816 D2A2 20 48 D1			JSR	LAB_SEL_PORT		; get port
  7817 D2A5 B0 06			BCS	LAB_READI2C		; port id > 1 -> read from i2c port
  7818 D2A7 B1 14			LDA	(IOBASE),Y
  7819 D2A9 A8				TAY				; copy received byte into Y
  7820 D2AA 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7821
  7822 				; perform READI2C *************************
  7823 D2AD			LAB_READI2C
  7824 D2AD 20 26 E3			JSR	I2C_START		; Send I2C Start Condition
  7825 D2B0 8A				TXA				; transfer device address into A
  7826 D2B1 20 62 E3			JSR	I2C_READ_DEV		; Read I2C Device, set read mode. Return C = 1 acknowledged
  7827 D2B4 20 9F E3			JSR	 I2C_RCV		; Receive a Byte from I2C Device 
  7828 D2B7 85 1A			STA	Temp1
  7829 D2B9 20 35 E3			JSR	I2C_STOP		; Send I2C Stop Condition
  7830 D2BC A4 1A			LDY	Temp1			; load byte to Y
  7831 D2BE 4C 51 C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7832
  7833 				; perform DELAY *************************
  7834 D2C1			LAB_DELAY
  7835 D2C1 20 AA BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7836 									; else do type mismatch
  7837 D2C4 20 81 BE			JSR	LAB_EVPI		; evaluate positive integer expression
  7838 D2C7 A5 15			LDA	IOBASE+1
  7839 D2C9 F0 2F			BEQ	LAB_DELAY_OLD		; check if IO is available (needed for RAM based EhBasic only)
  7840 D2CB A0 0E			LDY	#VIA_IER		; select interrupt enable register
  7841 D2CD A9 7F			LDA	#$7F
  7842 D2CF 91 14			STA	(IOBASE),Y		; disable all VIA2 interrupts
  7843 D2D1			LAB_DELAY_LOOP
  7844 D2D1 A0 08			LDY	#VIA_T2CL		; select Timer2 lower byte register
  7845 D2D3 A9 E8			LDA	#$E8			; set Timer2
  7846 D2D5 91 14			STA	(IOBASE),Y		; store timer low value
  7847 D2D7 A9 03			LDA	#$03
  7848 D2D9 C8				INY				; select Timer2 higher byte register
  7849 D2DA 91 14			STA	(IOBASE),Y		; store timer high value and start timer
  7850 D2DC A0 0D			LDY	#VIA_IFR		; select interrupt flag register
  7851 D2DE A5 6E			LDA	FAC1_2
  7852 D2E0 D0 04			BNE	LAB_WAIT_TIMER
  7853 D2E2 A5 6F			LDA	FAC1_3
  7854 D2E4 F0 13			BEQ	LAB_DELAY_END
  7855 D2E6			LAB_WAIT_TIMER
  7856 D2E6 B1 14			LDA	(IOBASE),Y
  7857 D2E8 29 20			AND	#$20
  7858 D2EA F0 FA			BEQ	LAB_WAIT_TIMER
  7859 D2EC C6 6F			DEC	FAC1_3
  7860 D2EE A5 6F			LDA	FAC1_3
  7861 D2F0 C9 FF			CMP	#$FF
  7862 D2F2 D0 DD			BNE	LAB_DELAY_LOOP
  7863 D2F4 C6 6E			DEC	FAC1_2
  7864 D2F6 4C D1 D2			JMP	LAB_DELAY_LOOP
  7865 D2F9			LAB_DELAY_END
  7866 D2F9 60				RTS
  7867
  7868 D2FA			LAB_DELAY_OLD
  7869 D2FA A6 6E			LDX	FAC1_2
  7870 D2FC F0 FB			BEQ	LAB_DELAY_END
  7871 D2FE			LAB_SET_TIMER
  7872 D2FE A5 6F			LDA	FAC1_3
  7873 D300 20 4D E1			JSR	DELAY			; Delay routine
  7874 D303 A9 FF			LDA	#$FF
  7875 D305 85 6F			STA	FAC1_3
  7876 D307 CA				DEX
  7877 D308 D0 F4			BNE	LAB_SET_TIMER
  7878 D30A 60				RTS
  7879
  7880 				; *****************************************
  7881
  7882 D30B			LAB_SCREEN	
  7883 D30B			LAB_PIXEL
  7884 D30B			LAB_LINE	
  7885 D30B			LAB_OVAL
  7886 D30B			LAB_COLOR
  7887 D30B			LAB_RECT
  7888 							
  7889 D30B			LAB_RES5
  7890 D30B			LAB_RES6
  7891 D30B 60				RTS
  7892
  7893 				; **** end of new commands ****
  7894
  7895
  7896 				; system dependent i/o vectors
  7897 				; these are in RAM and are set by the monitor at start-up
  7898
  7899 D30C 6C 6E 1A		V_INPT	JMP	(STDIN)			; non halting scan input device vector (Junior Computer 2)
  7900 D30F 6C 70 1A		V_OUTP	JMP	(STDOUT)		; send byte to output device vector (Junior Computer 2)
  7901
  7902 				; The rest are tables messages and code for RAM
  7903
  7904 				; the rest of the code is tables and BASIC start-up code
  7905
  7906 D312			PG2_TABS
  7907 D312 00				.byte	$00			; ctrl-c flag		-	$00 = enabled
  7908 D313 00				.byte	$00			; ctrl-c byte		-	GET needs this
  7909 D314 00				.byte	$00			; ctrl-c byte timeout	-	GET needs this
  7910 D315 97 CE			.word	CTRLC			; ctrl c check vector
  7911 				;	.word	xxxx			; non halting key input	-	monitor to set this
  7912 				;	.word	xxxx			; output vector		-	monitor to set this
  7913 				;	.word	xxxx			; load vector		-	monitor to set this
  7914 				;	.word	xxxx			; save vector		-	monitor to set this
  7915 D317			PG2_TABE
  7916
  7917 				; character get subroutine for zero page
  7918
  7919 				; For a 1.8432MHz 6502 including the JSR and RTS
  7920 				; fastest (>=':')	=  29 cycles =  15.7uS
  7921 				; slowest (<':')	=  40 cycles =  21.7uS
  7922 				; space skip	= +21 cycles = +11.4uS
  7923 				; inc across page	=  +4 cycles =  +2.2uS
  7924
  7925 				; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7926 				; block is copied to it's destination, any non zero page address will do at assembly
  7927 				; time, to assemble a three byte instruction.
  7928
  7929 				; page 0 initialisation table from $BC
  7930 				; increment and scan memory
  7931 D317			LAB_2CEE
  7932 D317 E6 83			INC	Bpntrl			; increment BASIC execute pointer low byte
  7933 D319 D0 02			BNE	LAB_2CF4		; branch if no carry
  7934 									; else
  7935 D31B E6 84			INC	Bpntrh			; increment BASIC execute pointer high byte
  7936
  7937 				; page 0 initialisation table from $C2
  7938 				; scan memory
  7939 D31D			LAB_2CF4
  7940 D31D AD FF FF			LDA	$FFFF			; get byte to scan (addr set by call routine)
  7941 D320 C9 C1			CMP	#TK_ELSE		; compare with the token for ELSE
  7942 D322 F0 0E			BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
  7943
  7944 D324 C9 3A			CMP	#':'			; compare with ':'
  7945 D326 B0 0A			BCS	LAB_2D05		; exit if >= ':', not numeric, carry set
  7946
  7947 D328 C9 20			CMP	#' '			; compare with ' '
  7948 D32A F0 EB			BEQ	LAB_2CEE		; if ' ' go do next
  7949
  7950 D32C 38				SEC				; set carry for SBC
  7951 D32D E9 30			SBC	#'0'			; subtract '0'
  7952 D32F 38				SEC				; set carry for SBC
  7953 D330 E9 D0			SBC	#$D0			; subtract -'0'
  7954 									; clear carry if byte = '0'-'9'
  7955 D332			LAB_2D05
  7956 D332 60				RTS
  7957
  7958 				; page zero initialisation table $00-$12 inclusive
  7959 D333			StrTab
  7960 D333 4C				.byte	$4C			; JMP opcode
  7961 D334 00 B0			.word 	LAB_COLD		; initial warm start vector (cold start)
  7962
  7963 D336 00				.byte	$00			; these bytes are not used by BASIC
  7964 D337 00 00			.word	$0000			; 
  7965 D339 00 00			.word	$0000			; 
  7966 D33B 00 00			.word	$0000			; 
  7967
  7968 D33D 4C				.byte	$4C			; JMP opcode
  7969 D33E 08 BF			.word	LAB_FCER		; initial user function vector ('Function call' error)
  7970 D340 00				.byte	$00			; default NULL count
  7971 D341 00				.byte	$00			; clear terminal position
  7972 D342 00				.byte	$00			; default terminal width byte
  7973 D343 F2				.byte	$F2			; default limit for TAB = 14
  7974 D344 01 20			.word	Ram_base		; start of user RAM
  7975 D346			EndTab
  7976
  7977 D346			LAB_MSZM
  7978 D346 45 6E 68 61 6E 63 + 	.by	'Enhanced BASIC 2.27',$0A,$00
  7979 				;	.byte	$0D,$0A,'Memory size ',$00
  7980
  7981 D35B			LAB_SMSG
  7982 D35B 20 42 61 73 69 63 + 	.by	' Basic Bytes free',$0D,$0A,$0A,$00
  7983 				;	.byte	'Enhanced BASIC 2.25',$0A,$00
  7984
  7985 				; numeric constants and series
  7986
  7987 									; constants and series for LOG(n)
  7988 D370			LAB_25A0
  7989 D370 02				.byte	$02			; counter
  7990 D371 80 19 56 62			.byte	$80,$19,$56,$62		; 0.59898
  7991 D375 80 76 22 F3			.byte	$80,$76,$22,$F3		; 0.96147
  7992 				;##	.byte	$80,$76,$22,$F1		; 0.96147
  7993 D379 82 38 AA 40			.byte	$82,$38,$AA,$40		; 2.88539
  7994 				;##	.byte	$82,$38,$AA,$45		; 2.88539
  7995
  7996 D37D			LAB_25AD
  7997 D37D 80 35 04 F3			.byte	$80,$35,$04,$F3		; 0.70711	1/root 2
  7998 D381			LAB_25B1
  7999 D381 81 35 04 F3			.byte	$81,$35,$04,$F3		; 1.41421	root 2
  8000 D385			LAB_25B5
  8001 D385 80 80 00 00			.byte	$80,$80,$00,$00		; -0.5
  8002 D389			LAB_25B9
  8003 D389 80 31 72 18			.byte	$80,$31,$72,$18		; 0.69315	LOG(2)
  8004
  8005 									; numeric PRINT constants
  8006 D38D			LAB_2947
  8007 D38D 91 43 4F F8			.byte	$91,$43,$4F,$F8		; 99999.9375 (max value with at least one decimal)
  8008 D391			LAB_294B
  8009 D391 94 74 23 F7			.byte	$94,$74,$23,$F7		; 999999.4375 (max value before scientific notation)
  8010 D395			LAB_294F
  8011 D395 94 74 24 00			.byte	$94,$74,$24,$00		; 1000000
  8012
  8013 									; EXP(n) constants and series
  8014 D399			LAB_2AFA
  8015 D399 81 38 AA 3B			.byte	$81,$38,$AA,$3B		; 1.4427	(1/LOG base 2 e)
  8016 D39D			LAB_2AFE
  8017 D39D 06				.byte	$06			; counter
  8018 D39E 74 63 90 8C			.byte	$74,$63,$90,$8C		; 2.17023e-4
  8019 D3A2 77 23 0C AB			.byte	$77,$23,$0C,$AB		; 0.00124
  8020 D3A6 7A 1E 94 00			.byte	$7A,$1E,$94,$00		; 0.00968
  8021 D3AA 7C 63 42 80			.byte	$7C,$63,$42,$80		; 0.05548
  8022 D3AE 7E 75 FE D0			.byte	$7E,$75,$FE,$D0		; 0.24023
  8023 D3B2 80 31 72 15			.byte	$80,$31,$72,$15		; 0.69315
  8024 D3B6 81 00 00 00			.byte	$81,$00,$00,$00		; 1.00000
  8025
  8026 				;##	.byte	$07			; counter
  8027 				;##	.byte	$74,$94,$2E,$40		; -1/7! (-1/5040)
  8028 				;##	.byte	$77,$2E,$4F,$70		;  1/6! ( 1/720)
  8029 				;##	.byte	$7A,$88,$02,$6E		; -1/5! (-1/120)
  8030 				;##	.byte	$7C,$2A,$A0,$E6		;  1/4! ( 1/24)
  8031 				;##	.byte	$7E,$AA,$AA,$50		; -1/3! (-1/6)
  8032 				;##	.byte	$7F,$7F,$FF,$FF		;  1/2! ( 1/2)
  8033 				;##	.byte	$81,$80,$00,$00		; -1/1! (-1/1)
  8034 				;##	.byte	$81,$00,$00,$00		;  1/0! ( 1/1)
  8035
  8036 									; trigonometric constants and series
  8037 D3BA			LAB_2C78
  8038 D3BA 81 49 0F DB			.byte	$81,$49,$0F,$DB		; 1.570796371 (pi/2) as floating #
  8039 D3BE			LAB_2C84
  8040 D3BE 04				.byte	$04			; counter
  8041 D3BF 86 1E D7 FB			.byte	$86,$1E,$D7,$FB		; 39.7109
  8042 				;##	.byte	$86,$1E,$D7,$BA		; 39.7109
  8043 D3C3 87 99 26 65			.byte	$87,$99,$26,$65		;-76.575
  8044 				;##	.byte	$87,$99,$26,$64		;-76.575
  8045 D3C7 87 23 34 58			.byte	$87,$23,$34,$58		; 81.6022
  8046 D3CB 86 A5 5D E1			.byte	$86,$A5,$5D,$E1		;-41.3417
  8047 				;##	.byte	$86,$A5,$5D,$E0		;-41.3417
  8048 D3CF			LAB_2C7C
  8049 D3CF 83 49 0F DB			.byte	$83,$49,$0F,$DB		; 6.28319 (2*pi) as floating #
  8050 				;##	.byte	$83,$49,$0F,$DA		; 6.28319 (2*pi) as floating #
  8051
  8052 D3D3			LAB_2CC9
  8053 D3D3 08				.byte	$08			; counter
  8054 D3D4 78 3A C5 37			.byte	$78,$3A,$C5,$37		; 0.00285
  8055 D3D8 7B 83 A2 5C			.byte	$7B,$83,$A2,$5C		;-0.0160686
  8056 D3DC 7C 2E DD 4D			.byte	$7C,$2E,$DD,$4D		; 0.0426915
  8057 D3E0 7D 99 B0 1E			.byte	$7D,$99,$B0,$1E		;-0.0750429
  8058 D3E4 7D 59 ED 24			.byte	$7D,$59,$ED,$24		; 0.106409
  8059 D3E8 7E 91 72 00			.byte	$7E,$91,$72,$00		;-0.142036
  8060 D3EC 7E 4C B9 73			.byte	$7E,$4C,$B9,$73		; 0.199926
  8061 D3F0 7F AA AA 53			.byte	$7F,$AA,$AA,$53		;-0.333331
  8062
  8063 				;##	.byte	$08			; counter
  8064 				;##	.byte	$78,$3B,$D7,$4A		; 1/17
  8065 				;##	.byte	$7B,$84,$6E,$02		;-1/15
  8066 				;##	.byte	$7C,$2F,$C1,$FE		; 1/13
  8067 				;##	.byte	$7D,$9A,$31,$74		;-1/11
  8068 				;##	.byte	$7D,$5A,$3D,$84		; 1/9
  8069 				;##	.byte	$7E,$91,$7F,$C8		;-1/7
  8070 				;##	.byte	$7E,$4C,$BB,$E4		; 1/5
  8071 				;##	.byte	$7F,$AA,$AA,$6C		;-1/3
  8072
  8073 = D3F5			LAB_1D96	= *+1			; $00,$00 used for undefined variables
  8074 D3F4			LAB_259C
  8075 D3F4 81 00 00 00			.byte	$81,$00,$00,$00		; 1.000000, used for INC
  8076 D3F8			LAB_2AFD
  8077 D3F8 81 80 00 00			.byte	$81,$80,$00,$00		; -1.00000, used for DEC. must be on the same page as +1.00
  8078
  8079 									; misc constants
  8080 D3FC			LAB_1DF7
  8081 D3FC 90				.byte	$90			;-32768 (uses first three bytes from 0.5)
  8082 D3FD			LAB_2A96
  8083 D3FD 80 00 00 00			.byte	$80,$00,$00,$00		; 0.5
  8084 D401			LAB_2C80
  8085 D401 7F 00 00 00			.byte	$7F,$00,$00,$00		; 0.25
  8086 D405			LAB_26B5
  8087 D405 84 20 00 00			.byte	$84,$20,$00,$00		; 10.0000 divide by 10 constant
  8088
  8089 				; This table is used in converting numbers to ASCII.
  8090 D409			LAB_2A9A
  8091 = D40A			LAB_2A9B = LAB_2A9A+1
  8092 = D40B			LAB_2A9C = LAB_2A9B+1
  8093 D409 FE 79 60			.byte	$FE,$79,$60		; -100000
  8094 D40C 00 27 10			.byte	$00,$27,$10		; 10000
  8095 D40F FF FC 18			.byte	$FF,$FC,$18		; -1000
  8096 D412 00 00 64			.byte	$00,$00,$64		; 100
  8097 D415 FF FF F6			.byte	$FF,$FF,$F6		; -10
  8098 D418 00 00 01			.byte	$00,$00,$01		; 1
  8099
  8100 D41B			LAB_CTBL
  8101 D41B F9 B4			.word	LAB_END-1		; END
  8102 D41D 38 B4			.word	LAB_FOR-1		; FOR
  8103 D41F 41 BA			.word	LAB_NEXT-1		; NEXT
  8104 D421 66 B6			.word	LAB_DATA-1		; DATA
  8105 D423 24 B9			.word	LAB_INPUT-1		; INPUT
  8106 D425 3D BD			.word	LAB_DIM-1		; DIM
  8107 D427 43 B9			.word	LAB_READ-1		; READ
  8108 D429 91 B7			.word	LAB_LET-1		; LET
  8109 D42B 63 B7			.word	LAB_DEC-1		; DEC		new command
  8110 D42D C5 B5			.word	LAB_GOTO-1		; GOTO
  8111 D42F 84 B5			.word	LAB_RUN-1		; RUN
  8112 D431 94 B6			.word	LAB_IF-1		; IF
  8113 D433 1A B5			.word	LAB_RESTORE-1		; RESTORE	modified command
  8114 D435 A8 B5			.word	LAB_GOSUB-1		; GOSUB
  8115 D437 53 CF			.word	LAB_RETIRQ-1		; RETIRQ	new command
  8116 D439 5F CF			.word	LAB_RETNMI-1		; RETNMI	new command
  8117 D43B 51 B6			.word	LAB_RETURN-1		; RETURN
  8118 D43D FB B6			.word	LAB_REM-1		; REM
  8119 D43F F7 B4			.word	LAB_STOP-1		; STOP
  8120 D441 04 B7			.word	LAB_ON-1		; ON		modified command
  8121 D443 58 B5			.word	LAB_NULL-1		; NULL		modified command
  8122 D445 66 B7			.word	LAB_INC-1		; INC		new command
  8123 D447 75 C5			.word	LAB_WAIT-1		; WAIT
  8124 D449 56 D1			.word	LAB_LOAD-1		; LOAD
  8125 D44B 8A D1			.word	LAB_SAVE-1		; SAVE
  8126 D44D 5E C0			.word	LAB_DEF-1		; DEF
  8127 D44F FA C4			.word	LAB_POKE-1		; POKE
  8128 D451 16 C5			.word	LAB_DOKE-1		; DOKE		new command
  8129 D453 63 C5			.word	LAB_CALL-1		; CALL		new command
  8130 D455 8E B5			.word	LAB_DO-1		; DO		new command
  8131 D457 F7 B5			.word	LAB_LOOP-1		; LOOP		new command
  8132 D459 32 B8			.word	LAB_PRINT-1		; PRINT
  8133 D45B 5E B5			.word	LAB_CONT-1		; CONT
  8134 D45D 83 B3			.word	LAB_LIST-1		; LIST
  8135 D45F 80 B3			.word	LAB_CLEAR-1		; CLEAR
  8136 D461 30 B3			.word	LAB_NEW-1		; NEW
  8137 D463 D4 CF			.word	LAB_WDTH-1		; WIDTH		new command
  8138 D465 01 B8			.word	LAB_GET-1		; GET		new command
  8139 D467 3B C5			.word	LAB_SWAP-1		; SWAP		new command
  8140 D469 6E CD			.word	LAB_BITSET-1		; BITSET	new command
  8141 D46B 82 CD			.word	LAB_BITCLR-1		; BITCLR	new command
  8142 D46D 02 CF			.word	LAB_IRQ-1		; IRQ		new command
  8143 D46F 05 CF			.word	LAB_NMI-1		; NMI		new command
  8144 D471 C6 D1			.word	LAB_BEEP-1		; BEEP		new command (Junior Computer 2)
  8145 D473 D7 D1			.word	LAB_PLIST-1		; PLIST		new command (Junior Computer 2)
  8146 D475 EC D1			.word	LAB_HOME-1		; HOME		new command (Junior Computer 2)
  8147 D477 F1 D1			.word	LAB_CLS-1		; CLS		new command (Junior Computer 2)
  8148 D479 F6 D1			.word	LAB_NORMAL-1		; NORMAL	new command (Junior Computer 2)
  8149 D47B FB D1			.word	LAB_INVERSE-1		; INVERSE	new command (Junior Computer 2)
  8150 D47D 00 D2			.word	LAB_FLASH-1		; FLASH		new command (Junior Computer 2)
  8151 D47F 05 D2			.word	LAB_LOCATE-1		; LOCATE	new command (Junior Computer 2)
  8152 D481 0F D2			.word	LAB_INNUM-1		; IN#		new command (Junior Computer 2)
  8153 D483 17 D2			.word	LAB_PRNUM-1		; PR#		new command (Junior Computer 2)
  8154 D485 1F D2			.word	LAB_PORTIO-1		; PORTIO	new command (Junior Computer 2)
  8155 D487 2F D2			.word	LAB_PORTOUT-1		; PORTOUT	new command (Junior Computer 2)
  8156 D489 0A D3			.word	LAB_SCREEN-1		; SCREEN	new command (Junior Computer 2)	
  8157 D48B 0A D3			.word	LAB_PIXEL-1		; PIXEL		new command (Junior Computer 2)
  8158 D48D 0A D3			.word	LAB_LINE-1		; LINE		new command (Junior Computer 2)	
  8159 D48F 0A D3			.word	LAB_OVAL-1		; OVAL		new command (Junior Computer 2)	
  8160 D491 0A D3			.word	LAB_RECT-1		; RECT		new command (Junior Computer 2)	
  8161 D493 0A D3			.word	LAB_COLOR-1		; COLOR		new command (Junior Computer 2)	
  8162 D495 C0 D2			.word	LAB_DELAY-1		; DELAY		new command (Junior Computer 2)	
  8163 D497 52 D2			.word	LAB_I2COUT-1		; I2COUT	new command (Junior Computer 2)
  8164 D499 E9 D1			.word	LAB_DOS-1		; DOS		new command (Junior Computer 2)
  8165
  8166 				; function pre process routine table
  8167
  8168 D49B			LAB_FTPL
  8169 = D49C			LAB_FTPM	= LAB_FTPL+$01
  8170 D49B 43 BC			.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
  8171 D49D 43 BC			.word	LAB_PPFN-1		; INT(n)		"
  8172 D49F 43 BC			.word	LAB_PPFN-1		; ABS(n)		"
  8173 D4A1 C5 BA			.word	LAB_EVEZ-1		; USR(x)	process any expression
  8174 D4A3 C8 BB			.word	LAB_1BF7-1		; FRE(x)		"
  8175 D4A5 C8 BB			.word	LAB_1BF7-1		; POS(x)		"
  8176 D4A7 43 BC			.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
  8177 D4A9 43 BC			.word	LAB_PPFN-1		; RND(n)		"
  8178 D4AB 43 BC			.word	LAB_PPFN-1		; LOG(n)		"
  8179 D4AD 43 BC			.word	LAB_PPFN-1		; EXP(n)		"
  8180 D4AF 43 BC			.word	LAB_PPFN-1		; COS(n)		"
  8181 D4B1 43 BC			.word	LAB_PPFN-1		; SIN(n)		"
  8182 D4B3 43 BC			.word	LAB_PPFN-1		; TAN(n)		"
  8183 D4B5 43 BC			.word	LAB_PPFN-1		; ATN(n)		"
  8184 D4B7 43 BC			.word	LAB_PPFN-1		; PEEK(n)		"
  8185 D4B9 43 BC			.word	LAB_PPFN-1		; DEEK(n)		"
  8186 D4BB 00 00			.word	$0000			; SADD()	none
  8187 D4BD 3D BC			.word	LAB_PPFS-1		; LEN($)	process string expression in ()
  8188 D4BF 43 BC			.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
  8189 D4C1 3D BC			.word	LAB_PPFS-1		; VAL($)	process string expression in ()
  8190 D4C3 3D BC			.word	LAB_PPFS-1		; ASC($)		"
  8191 D4C5 3D BC			.word	LAB_PPFS-1		; UCASE$($)		"
  8192 D4C7 3D BC			.word	LAB_PPFS-1		; LCASE$($)		"
  8193 D4C9 43 BC			.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
  8194 D4CB 6A BC			.word	LAB_BHSS-1		; HEX$(n)		"
  8195 D4CD 6A BC			.word	LAB_BHSS-1		; BIN$(n)		"
  8196 D4CF 00 00			.word	$0000			; BITTST()	none
  8197 D4D1 6B CF			.word	LAB_MMPP-1		; MAX()		process numeric expression
  8198 D4D3 6B CF			.word	LAB_MMPP-1		; MIN()		"
  8199 D4D5 49 BC			.word	LAB_PPBI-1		; PI		advance pointer
  8200 D4D7 49 BC			.word	LAB_PPBI-1		; TWOPI		"
  8201 D4D9 00 00			.word	$0000			; VARPTR()	none
  8202 D4DB 4E BC			.word	LAB_LRMS-1		; LEFT$()	process string expression
  8203 D4DD 4E BC			.word	LAB_LRMS-1		; RIGHT$()		"
  8204 D4DF 4E BC			.word	LAB_LRMS-1		; MID$()		"
  8205 D4E1 43 BC			.word	LAB_PPFN-1		; PORTIN(n)	process string expression in ()
  8206 D4E3 43 BC			.word	LAB_PPFN-1		; I2CIN(n)	process string expression in ()
  8207 D4E5 00 00			.word	$0000			; RESERVED	none TEMP
  8208 D4E7 00 00			.word	$0000			; RESERVED	none TEMP
  8209
  8210 				; action addresses for functions
  8211 D4E9			LAB_FTBL
  8212 = D4EA			LAB_FTBM	= LAB_FTBL+$01
  8213 D4E9 E3 C8			.word	LAB_SGN-1		; SGN()
  8214 D4EB 6D C9			.word	LAB_INT-1		; INT()
  8215 D4ED 00 C9			.word	LAB_ABS-1		; ABS()
  8216 D4EF 39 CD			.word	LAB_USR-1		; USR()
  8217 D4F1 23 C0			.word	LAB_FRE-1		; FRE()
  8218 D4F3 4E C0			.word	LAB_POS-1		; POS()
  8219 D4F5 2A D0			.word	LAB_SQR-1		; SQR()
  8220 D4F7 89 CC			.word	LAB_RND-1		; RND()		modified function
  8221 D4F9 E7 C6			.word	LAB_LOG-1		; LOG()
  8222 D4FB EB CB			.word	LAB_EXP-1		; EXP()
  8223 D4FD BD CC			.word	LAB_COS-1		; COS()
  8224 D4FF C4 CC			.word	LAB_SIN-1		; SIN()
  8225 D501 0D CD			.word	LAB_TAN-1		; TAN()
  8226 D503 3F CD			.word	LAB_ATN-1		; ATN()
  8227 D505 EF C4			.word	LAB_PEEK-1		; PEEK()
  8228 D507 03 C5			.word	LAB_DEEK-1		; DEEK()	new function
  8229 D509 41 C4			.word	LAB_SADD-1		; SADD()	new function
  8230 D50B 5A C4			.word	LAB_LENS-1		; LEN()
  8231 D50D 10 C1			.word	LAB_STRS-1		; STR$()
  8232 D50F 87 C4			.word	LAB_VAL-1		; VAL()
  8233 D511 65 C4			.word	LAB_ASC-1		; ASC()
  8234 D513 1F C4			.word	LAB_UCASE-1		; UCASE$()	new function
  8235 D515 FE C3			.word	LAB_LCASE-1		; LCASE$()	new function
  8236 D517 70 C3			.word	LAB_CHRS-1		; CHR$()
  8237 D519 0F CE			.word	LAB_HEXS-1		; HEX$()	new function
  8238 D51B C0 CD			.word	LAB_BINS-1		; BIN$()	new function
  8239 D51D 98 CD			.word	LAB_BTST-1		; BITTST()	new function
  8240 D51F 71 CF			.word	LAB_MAX-1		; MAX()		new function
  8241 D521 81 CF			.word	LAB_MIN-1		; MIN()		new function
  8242 D523 C7 D0			.word	LAB_PI-1		; PI		new function
  8243 D525 D1 D0			.word	LAB_TWOPI-1		; TWOPI		new function
  8244 D527 B7 D0			.word	LAB_VARPTR-1		; VARPTR()	new function
  8245 D529 82 C3			.word	LAB_LEFT-1		; LEFT$()
  8246 D52B 8B C3			.word	LAB_RIGHT-1		; RIGHT$()
  8247 D52D BA C3			.word	LAB_MIDS-1		; MID$()
  8248 D52F 9E D2			.word	LAB_PORTIN-1		; PORTIN	new function (Junior Computer 2)
  8249 D531 76 D2			.word	LAB_I2CIN-1		; I2CIN()	new function (Junior Computer 2)		
  8250 D533 0A D3			.word	LAB_RES5-1		; RESERVED	new function (Junior Computer 2)
  8251 D535 0A D3			.word	LAB_RES6-1		; RESERVED	new function (Junior Computer 2)
  8252
  8253 				; hierarchy and action addresses for operator
  8254 D537			LAB_OPPT
  8255 D537 79				.byte	$79			; +
  8256 D538 AD C5			.word	LAB_ADD-1
  8257 D53A 79				.byte	$79			; -
  8258 D53B 92 C5			.word	LAB_SUBTRACT-1
  8259 D53D 7B				.byte	$7B			; *
  8260 D53E 28 C7			.word	LAB_MULTIPLY-1
  8261 D540 7B				.byte	$7B			; /
  8262 D541 F0 C7			.word	LAB_DIVIDE-1
  8263 D543 7B				.byte	$7B			; MOD		new operator (Junior Computer 2)
  8264 D544 D8 D0			.word	LAB_MOD-1
  8265 D546 7F				.byte	$7F			; ^
  8266 D547 A7 CB			.word	LAB_POWER-1
  8267 D549 50				.byte	$50			; AND
  8268 D54A B3 BC			.word	LAB_AND-1
  8269 D54C 46				.byte	$46			; EOR		new operator
  8270 D54D 99 BC			.word	LAB_EOR-1
  8271 D54F 46				.byte	$46			; OR
  8272 D550 A6 BC			.word	LAB_OR-1
  8273 D552 56				.byte	$56			; >>		new operator
  8274 D553 5F BD			.word	LAB_RSHIFT-1
  8275 D555 56				.byte	$56			; <<		new operator
  8276 D556 47 BD			.word	LAB_LSHIFT-1
  8277 D558 7D				.byte	$7D			; >
  8278 D559 E0 CB			.word	LAB_GTHAN-1
  8279 D55B 5A				.byte	$5A			; =
  8280 D55C F3 BB			.word	LAB_EQUAL-1
  8281 D55E 64				.byte	$64			; <
  8282 D55F D4 BC			.word	LAB_LTHAN-1
  8283
  8284 				; keywords start with ..
  8285 				; this is the first character table and must be in alphabetic order
  8286 D561			TAB_1STC
  8287 D561 2A				.byte	'*'
  8288 D562 2B				.byte	'+'
  8289 D563 2D				.byte	'-'
  8290 D564 2F				.byte	'/'
  8291 D565 3C				.byte	'<'
  8292 D566 3D				.byte	'='
  8293 D567 3E				.byte	'>'
  8294 D568 3F				.byte	'?'
  8295 D569 41				.byte	'A'
  8296 D56A 42				.byte	'B'
  8297 D56B 43				.byte	'C'
  8298 D56C 44				.byte	'D'
  8299 D56D 45				.byte	'E'
  8300 D56E 46				.byte	'F'
  8301 D56F 47				.byte	'G'
  8302 D570 48				.byte	'H'
  8303 D571 49				.byte	'I'
  8304 D572 4C				.byte	'L'
  8305 D573 4D				.byte	'M'
  8306 D574 4E				.byte	'N'
  8307 D575 4F				.byte	'O'
  8308 D576 50				.byte	'P'
  8309 D577 52				.byte	'R'
  8310 D578 53				.byte	'S'
  8311 D579 54				.byte	'T'
  8312 D57A 55				.byte	'U'
  8313 D57B 56				.byte	'V'
  8314 D57C 57				.byte	'W'
  8315 D57D 5E				.byte	'^'
  8316 D57E 00				.byte	$00			; table terminator
  8317
  8318 				; pointers to keyword tables
  8319
  8320 D57F			TAB_CHRT
  8321 D57F B9 D5			.word	TAB_STAR		; table for '*'
  8322 D581 BB D5			.word	TAB_PLUS		; table for '+'
  8323 D583 BD D5			.word	TAB_MNUS		; table for '-'
  8324 D585 BF D5			.word	TAB_SLAS		; table for '/'
  8325 D587 C1 D5			.word	TAB_LESS		; table for '<'
  8326 D589 C5 D5			.word	TAB_EQUL		; table for '='
  8327 D58B C7 D5			.word	TAB_MORE		; table for '>'
  8328 D58D CB D5			.word	TAB_QEST		; table for '?'
  8329 D58F CD D5			.word	TAB_ASCA		; table for 'A'
  8330 D591 DD D5			.word	TAB_ASCB		; table for 'B'
  8331 D593 FA D5			.word	TAB_ASCC		; table for 'C'
  8332 D595 19 D6			.word	TAB_ASCD		; table for 'D'
  8333 D597 3A D6			.word	TAB_ASCE		; table for 'E'
  8334 D599 49 D6			.word	TAB_ASCF		; table for 'F'
  8335 D59B 58 D6			.word	TAB_ASCG		; table for 'G'
  8336 D59D 65 D6			.word	TAB_ASCH		; table for 'H'
  8337 D59F 6F D6			.word	TAB_ASCI		; table for 'I'
  8338 D5A1 97 D6			.word	TAB_ASCL		; table for 'L'
  8339 D5A3 C6 D6			.word	TAB_ASCM		; table for 'M'
  8340 D5A5 D9 D6			.word	TAB_ASCN		; table for 'N'
  8341 D5A7 F1 D6			.word	TAB_ASCO		; table for 'O'
  8342 D5A9 FD D6			.word	TAB_ASCP		; table for 'P'
  8343 D5AB 2E D7			.word	TAB_ASCR		; table for 'R'
  8344 D5AD 6B D7			.word	TAB_ASCS		; table for 'S'
  8345 D5AF 9C D7			.word	TAB_ASCT		; table for 'T'
  8346 D5B1 B0 D7			.word	TAB_ASCU		; table for 'U'
  8347 D5B3 C1 D7			.word	TAB_ASCV		; table for 'V'
  8348 D5B5 CD D7			.word	TAB_ASCW		; table for 'W'
  8349 D5B7 DC D7			.word	TAB_POWR		; table for '^'
  8350
  8351 				; tables for each start character, note if a longer keyword with the same start
  8352 				; letters as a shorter one exists then it must come first, else the list is in
  8353 				; alphabetical order as follows ..
  8354
  8355 				; [keyword,token
  8356 				; [keyword,token]]
  8357 				; end marker (#$00)
  8358
  8359 D5B9			TAB_STAR
  8360 D5B9 CD 00			.byte TK_MUL,$00		; *
  8361 D5BB			TAB_PLUS
  8362 D5BB CB 00			.byte TK_PLUS,$00		; +
  8363 D5BD			TAB_MNUS
  8364 D5BD CC 00			.byte TK_MINUS,$00		; -
  8365 D5BF			TAB_SLAS
  8366 D5BF CE 00			.byte TK_DIV,$00		; /
  8367 D5C1			TAB_LESS
  8368 D5C1			LBB_LSHIFT
  8369 D5C1 3C D5			.byte	'<',TK_LSHIFT		; <<	note - '<<' must come before '<'
  8370 D5C3 D8				.byte 	TK_LT			; <
  8371 D5C4 00				.byte	$00
  8372 D5C5			TAB_EQUL
  8373 D5C5 D7 00			.byte 	TK_EQUAL,$00		; =
  8374 D5C7			TAB_MORE
  8375 D5C7			LBB_RSHIFT
  8376 D5C7 3E D4			.byte	'>',TK_RSHIFT		; >>	note - '>>' must come before '>'
  8377 D5C9 D6				.byte 	TK_GT			; >
  8378 D5CA 00				.byte	$00
  8379 D5CB			TAB_QEST
  8380 D5CB 9F 00			.byte 	TK_PRINT,$00		; ?
  8381 D5CD			TAB_ASCA
  8382 D5CD			LBB_ABS
  8383 D5CD 42 53 28 DB			.byte	'BS(',TK_ABS		; ABS(
  8384 D5D1			LBB_AND
  8385 D5D1 4E 44 D1			.byte	'ND',TK_AND		; AND
  8386 D5D4			LBB_ASC
  8387 D5D4 53 43 28 ED			.byte	'SC(',TK_ASC		; ASC(
  8388 D5D8			LBB_ATN
  8389 D5D8 54 4E 28 E6			.byte	'TN(',TK_ATN		; ATN(
  8390 D5DC 00				.byte	$00
  8391 D5DD			TAB_ASCB
  8392 D5DD			LBB_BEEP
  8393 D5DD 45 45 50 AB			.byte	'EEP',TK_BEEP		; BEEP
  8394 D5E1			LBB_BINS
  8395 D5E1 49 4E 24 28 F2		.byte	'IN$(',TK_BINS		; BIN$(
  8396 D5E6			LBB_BITCLR
  8397 D5E6 49 54 43 4C 52 A8		.byte	'ITCLR',TK_BITCLR	; BITCLR
  8398 D5EC			LBB_BITSET
  8399 D5EC 49 54 53 45 54 A7		.byte	'ITSET',TK_BITSET	; BITSET
  8400 D5F2			LBB_BITTST
  8401 D5F2 49 54 54 53 54 28 + 	.byte	'ITTST(',TK_BITTST  	; BITTST(
  8402 D5F9 00				.byte	$00
  8403 D5FA			TAB_ASCC
  8404 D5FA			LBB_CALL
  8405 D5FA 41 4C 4C 9C			.byte	'ALL',TK_CALL		; CALL
  8406 D5FE			LBB_CHRS
  8407 D5FE 48 52 24 28 F0		.byte	'HR$(',TK_CHRS		; CHR$(
  8408 D603			LBB_CLEAR
  8409 D603 4C 45 41 52 A2		.byte	'LEAR',TK_CLEAR		; CLEAR
  8410 D608			LBB_CLS
  8411 D608 4C 53 AE		    	.byte   'LS',TK_CLS 		; CLS
  8412 D60B			LBB_COLOR
  8413 D60B 4F 4C 4F 52 BC		.byte	'OLOR',TK_COLOR		; COLOR
  8414 D610			LBB_CONT
  8415 D610 4F 4E 54 A0			.byte	'ONT',TK_CONT		; CONT
  8416 D614			LBB_COS
  8417 D614 4F 53 28 E3			.byte	'OS(',TK_COS		; COS(
  8418 D618 00				.byte	$00
  8419 D619			TAB_ASCD
  8420 D619			LBB_DATA
  8421 D619 41 54 41 83			.byte	'ATA',TK_DATA		; DATA
  8422 D61D			LBB_DEC
  8423 D61D 45 43 88			.byte	'EC',TK_DEC		; DEC
  8424 D620			LBB_DEEK
  8425 D620 45 45 4B 28 E8		.byte	'EEK(',TK_DEEK		; DEEK(
  8426 D625			LBB_DEF
  8427 D625 45 46 99			.byte	'EF',TK_DEF		; DEF
  8428 D628			LBB_DELAY
  8429 D628 45 4C 41 59 BD		.byte	'ELAY',TK_DELAY		; DELAY
  8430 D62D			LBB_DIM
  8431 D62D 49 4D 85			.byte	'IM',TK_DIM		; DIM
  8432 D630			LBB_DOKE
  8433 D630 4F 4B 45 9B			.byte	'OKE',TK_DOKE		; DOKE
  8434 D634			LBB_DOS
  8435 D634 4F 53 BF			.byte	'OS',TK_DOS		; DOS note - 'DOS' must come before 'DO'
  8436 D637			LBB_DO
  8437 D637 4F 9D			.byte	'O',TK_DO		; DO
  8438 D639 00				.byte	$00
  8439 D63A			TAB_ASCE
  8440 D63A			LBB_ELSE
  8441 D63A 4C 53 45 C1			.byte	'LSE',TK_ELSE		; ELSE
  8442 D63E			LBB_END
  8443 D63E 4E 44 80			.byte	'ND',TK_END		; END
  8444 D641			LBB_EOR
  8445 D641 4F 52 D2			.byte	'OR',TK_EOR		; EOR
  8446 D644			LBB_EXP
  8447 D644 58 50 28 E2			.byte	'XP(',TK_EXP		; EXP(
  8448 D648 00				.byte	$00
  8449 D649			TAB_ASCF
  8450 D649			LBB_FLASH
  8451 D649 4C 41 53 48 B1	    	.byte   'LASH',TK_FLASH 	; FLASH
  8452 D64E			LBB_FN
  8453 D64E 4E C3			.byte	'N',TK_FN		; FN
  8454 D650			LBB_FOR
  8455 D650 4F 52 81			.byte	'OR',TK_FOR		; FOR
  8456 D653			LBB_FRE
  8457 D653 52 45 28 DD			.byte	'RE(',TK_FRE		; FRE(
  8458 D657 00				.byte	$00
  8459 D658			TAB_ASCG
  8460 D658			LBB_GET
  8461 D658 45 54 A5			.byte	'ET',TK_GET		; GET
  8462 D65B			LBB_GOSUB
  8463 D65B 4F 53 55 42 8D		.byte	'OSUB',TK_GOSUB		; GOSUB
  8464 D660			LBB_GOTO
  8465 D660 4F 54 4F 89			.byte	'OTO',TK_GOTO		; GOTO
  8466 D664 00				.byte	$00
  8467 D665			TAB_ASCH
  8468 D665			LBB_HEXS
  8469 D665 45 58 24 28 F1		.byte	'EX$(',TK_HEXS		; HEX$(
  8470 D66A			LBB_HOME
  8471 D66A 4F 4D 45 AD		    	.byte   'OME',TK_HOME 		; HOME
  8472 D66E 00				.byte	$00
  8473 D66F			TAB_ASCI
  8474 D66F			LBB_I2CIN
  8475 D66F 32 43 69 6E 28 FD		.byte	'2Cin(',TK_I2CIN	; I2Cin
  8476 D675			LBB_I2COUT
  8477 D675 32 43 6F 75 74 BE		.byte	'2Cout',TK_I2COUT	; I2Cout
  8478 D67B			LBB_IF
  8479 D67B 46 8B			.byte	'F',TK_IF		; IF
  8480 D67D			LBB_INNUM
  8481 D67D 4E 23 B3			.byte	'N#',TK_INNUM		; IN#
  8482 D680			LBB_INC
  8483 D680 4E 43 95			.byte	'NC',TK_INC		; INC
  8484 D683			LBB_INPUT
  8485 D683 4E 50 55 54 84		.byte	'NPUT',TK_INPUT		; INPUT
  8486 D688			LBB_INT
  8487 D688 4E 54 28 DA			.byte	'NT(',TK_INT		; INT(
  8488 D68C			LBB_INVERSE
  8489 D68C 4E 56 45 52 53 45 +     	.byte   'NVERSE',TK_INVERSE 	; INVERSE
  8490 D693			LBB_IRQ
  8491 D693 52 51 A9			.byte	'RQ',TK_IRQ		; IRQ
  8492 D696 00				.byte	$00
  8493 D697			TAB_ASCL
  8494 D697			LBB_LCASES
  8495 D697 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_LCASES
  8496 									; LCASE$(
  8497 D69E			LBB_LEFTS
  8498 D69E 45 46 54 24 28 F9		.byte	'EFT$(',TK_LEFTS	; LEFT$(
  8499 D6A4			LBB_LEN
  8500 D6A4 45 4E 28 EA			.byte	'EN(',TK_LEN		; LEN(
  8501 D6A8			LBB_LET
  8502 D6A8 45 54 87			.byte	'ET',TK_LET		; LET
  8503 D6AB			LBB_LINE
  8504 D6AB 49 4E 45 B9			.byte	'INE',TK_LINE		; LINE
  8505 D6AF			LBB_LIST
  8506 D6AF 49 53 54 A1			.byte	'IST',TK_LIST		; LIST
  8507 D6B3			LBB_LOAD
  8508 D6B3 4F 41 44 97			.byte	'OAD',TK_LOAD		; LOAD
  8509 D6B7			LBB_LOCATE
  8510 D6B7 4F 43 41 54 45 B2	    	.byte   'OCATE',TK_LOCATE 	; LOCATE
  8511 D6BD			LBB_LOG
  8512 D6BD 4F 47 28 E1			.byte	'OG(',TK_LOG		; LOG(
  8513 D6C1			LBB_LOOP
  8514 D6C1 4F 4F 50 9E			.byte	'OOP',TK_LOOP		; LOOP
  8515 D6C5 00				.byte	$00
  8516 D6C6			TAB_ASCM
  8517 D6C6			LBB_MAX
  8518 D6C6 41 58 28 F4			.byte	'AX(',TK_MAX		; MAX(
  8519 D6CA			LBB_MIDS
  8520 D6CA 49 44 24 28 FB		.byte	'ID$(',TK_MIDS		; MID$(
  8521 D6CF			LBB_MIN
  8522 D6CF 49 4E 28 F5			.byte	'IN(',TK_MIN		; MIN(
  8523 D6D3			LBB_MOD
  8524 D6D3 4F 44 5F 23 CF		.byte	'OD_#',TK_MOD		; MOD
  8525 D6D8 00				.byte	$00
  8526 D6D9			TAB_ASCN
  8527 D6D9			LBB_NEW
  8528 D6D9 45 57 A3			.byte	'EW',TK_NEW		; NEW
  8529 D6DC			LBB_NEXT
  8530 D6DC 45 58 54 82			.byte	'EXT',TK_NEXT		; NEXT
  8531 D6E0			LBB_NMI
  8532 D6E0 4D 49 AA			.byte	'MI',TK_NMI		; NMI
  8533 D6E3			LBB_NOT
  8534 D6E3 4F 54 C6			.byte	'OT',TK_NOT		; NOT
  8535 D6E6			LBB_NORMAL
  8536 D6E6 4F 52 4D 41 4C AF	    	.byte   'ORMAL',TK_NORMAL 	; NORMAL
  8537 D6EC			LBB_NULL
  8538 D6EC 55 4C 4C 94			.byte	'ULL',TK_NULL		; NULL
  8539 D6F0 00				.byte	$00
  8540 D6F1			TAB_ASCO
  8541 D6F1			LBB_OFF
  8542 D6F1 46 46 CA			.byte	'FF',TK_OFF		; OFF
  8543 D6F4			LBB_ON
  8544 D6F4 4E 93			.byte	'N',TK_ON		; ON
  8545 D6F6			LBB_OR
  8546 D6F6 52 D3			.byte	'R',TK_OR		; OR
  8547 D6F8			LBB_OVAL
  8548 D6F8 56 41 4C BA			.byte	'VAL',TK_OVAL		; OVAL
  8549 D6FC 00				.byte	$00
  8550 D6FD			TAB_ASCP
  8551 D6FD			LBB_PEEK
  8552 D6FD 45 45 4B 28 E7		.byte	'EEK(',TK_PEEK		; PEEK(
  8553 D702			LBB_PIXEL
  8554 D702 49 58 45 4C B8		.byte	'IXEL',TK_PIXEL		; PIXEL
  8555 D707			LBB_PI
  8556 D707 49 F6			.byte	'I',TK_PI		; PI
  8557 D709			LBB_PLIST
  8558 D709 4C 49 53 54 AC	    .byte   	'LIST',TK_PLIST 	; PLIST
  8559 D70E			LBB_POKE
  8560 D70E 4F 4B 45 9A			.byte	'OKE',TK_POKE		; POKE
  8561 D712			LBB_PORTIO
  8562 D712 4F 52 54 49 4F B5		.byte	'ORTIO',TK_PORTIO	; PORTIO
  8563 D718			LBB_PORTIN
  8564 D718 4F 52 54 28 FC		.byte	'ORT(',TK_PORTIN	; PORT IN
  8565 D71D			LBB_PORTOUT
  8566 D71D 4F 52 54 B6			.byte	'ORT',TK_PORTOUT	; PORT OUT
  8567 D721			LBB_POS
  8568 D721 4F 53 28 DE			.byte	'OS(',TK_POS		; POS(
  8569 D725			LBB_PRNUM
  8570 D725 52 23 B4			.byte	'R#',TK_PRNUM		; PR#
  8571 D728			LBB_PRINT
  8572 D728 52 49 4E 54 9F		.byte	'RINT',TK_PRINT		; PRINT
  8573 D72D 00				.byte	$00
  8574 D72E			TAB_ASCR
  8575 D72E			LBB_READ
  8576 D72E 45 41 44 86			.byte	'EAD',TK_READ		; READ
  8577 D732			LBB_RECT
  8578 D732 45 43 54 BB			.byte	'ECT',TK_RECT		; RECT
  8579 D736			LBB_REM
  8580 D736 45 4D 91			.byte	'EM',TK_REM		; REM
  8581 D739			LBB_RESTORE
  8582 D739 45 53 54 4F 52 45 + 	.byte	'ESTORE',TK_RESTORE
  8583 									; RESTORE
  8584 D740			LBB_RETIRQ
  8585 D740 45 54 49 52 51 8E		.byte	'ETIRQ',TK_RETIRQ	; RETIRQ
  8586 D746			LBB_RETNMI
  8587 D746 45 54 4E 4D 49 8F		.byte	'ETNMI',TK_RETNMI	; RETNMI
  8588 D74C			LBB_RES5
  8589 D74C 45 53 35 28 FE		.byte	'ES5(',TK_RES5		; RES5
  8590 D751			LBB_RES6
  8591 D751 45 53 36 28 FF		.byte	'ES6(',TK_RES6		; RES6
  8592 D756			LBB_RETURN
  8593 D756 45 54 55 52 4E 90		.byte	'ETURN',TK_RETURN	; RETURN
  8594 D75C			LBB_RIGHTS
  8595 D75C 49 47 48 54 24 28 + 	.byte	'IGHT$(',TK_RIGHTS
  8596 									; RIGHT$(
  8597 D763			LBB_RND
  8598 D763 4E 44 28 E0			.byte	'ND(',TK_RND		; RND(
  8599 D767			LBB_RUN
  8600 D767 55 4E 8A			.byte	'UN',TK_RUN		; RUN
  8601 D76A 00				.byte	$00
  8602 D76B			TAB_ASCS
  8603 D76B			LBB_SADD
  8604 D76B 41 44 44 28 E9		.byte	'ADD(',TK_SADD		; SADD(
  8605 D770			LBB_SAVE
  8606 D770 41 56 45 98			.byte	'AVE',TK_SAVE		; SAVE
  8607 D774			LBB_SCREEN
  8608 D774 43 52 45 45 4E B7		.byte	'CREEN',TK_SCREEN	; SCREEN
  8609 D77A			LBB_SGN
  8610 D77A 47 4E 28 D9			.byte	'GN(',TK_SGN		; SGN(
  8611 D77E			LBB_SIN
  8612 D77E 49 4E 28 E4			.byte	'IN(',TK_SIN		; SIN(
  8613 D782			LBB_SPC
  8614 D782 50 43 28 C4			.byte	'PC(',TK_SPC		; SPC(
  8615 D786			LBB_SQR
  8616 D786 51 52 28 DF			.byte	'QR(',TK_SQR		; SQR(
  8617 D78A			LBB_STEP
  8618 D78A 54 45 50 C7			.byte	'TEP',TK_STEP		; STEP
  8619 D78E			LBB_STOP
  8620 D78E 54 4F 50 92			.byte	'TOP',TK_STOP		; STOP
  8621 D792			LBB_STRS
  8622 D792 54 52 24 28 EB		.byte	'TR$(',TK_STRS		; STR$(
  8623 D797			LBB_SWAP
  8624 D797 57 41 50 A6			.byte	'WAP',TK_SWAP		; SWAP
  8625 D79B 00				.byte	$00
  8626 D79C			TAB_ASCT
  8627 D79C			LBB_TAB
  8628 D79C 41 42 28 C0			.byte	'AB(',TK_TAB		; TAB(
  8629 D7A0			LBB_TAN
  8630 D7A0 41 4E 28 E5			.byte	'AN(',TK_TAN		; TAN(
  8631 D7A4			LBB_THEN
  8632 D7A4 48 45 4E C5			.byte	'HEN',TK_THEN		; THEN
  8633 D7A8			LBB_TO
  8634 D7A8 4F C2			.byte	'O',TK_TO		; TO
  8635 D7AA			LBB_TWOPI
  8636 D7AA 57 4F 50 49 F7		.byte	'WOPI',TK_TWOPI		; TWOPI
  8637 D7AF 00				.byte	$00
  8638 D7B0			TAB_ASCU
  8639 D7B0			LBB_UCASES
  8640 D7B0 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_UCASES
  8641 									; UCASE$(
  8642 D7B7			LBB_UNTIL
  8643 D7B7 4E 54 49 4C C8		.byte	'NTIL',TK_UNTIL		; UNTIL
  8644 D7BC			LBB_USR
  8645 D7BC 53 52 28 DC			.byte	'SR(',TK_USR		; USR(
  8646 D7C0 00				.byte	$00
  8647 D7C1			TAB_ASCV
  8648 D7C1			LBB_VAL
  8649 D7C1 41 4C 28 EC			.byte	'AL(',TK_VAL		; VAL(
  8650 D7C5			LBB_VPTR
  8651 D7C5 41 52 50 54 52 28 + 	.byte	'ARPTR(',TK_VPTR	; VARPTR(
  8652 D7CC 00				.byte	$00
  8653 D7CD			TAB_ASCW
  8654 D7CD			LBB_WAIT
  8655 D7CD 41 49 54 96			.byte	'AIT',TK_WAIT		; WAIT
  8656 D7D1			LBB_WHILE
  8657 D7D1 48 49 4C 45 C9		.byte	'HILE',TK_WHILE		; WHILE
  8658 D7D6			LBB_WIDTH
  8659 D7D6 49 44 54 48 A4		.byte	'IDTH',TK_WIDTH		; WIDTH
  8660 D7DB 00				.byte	$00
  8661 D7DC			TAB_POWR
  8662 D7DC D0 00			.byte	TK_POWER,$00		; ^
  8663
  8664 				; new decode table for LIST
  8665 				; Table is ..
  8666 				; byte - keyword length, keyword first character
  8667 				; word - pointer to rest of keyword from dictionary
  8668
  8669 				; note if length is 1 then the pointer is ignored
  8670 D7DE			LAB_KEYT
  8671 D7DE 03 45			.byte	3,'E'
  8672 D7E0 3E D6			.word	LBB_END			; END
  8673 D7E2 03 46			.byte	3,'F'
  8674 D7E4 50 D6			.word	LBB_FOR			; FOR
  8675 D7E6 04 4E			.byte	4,'N'
  8676 D7E8 DC D6			.word	LBB_NEXT		; NEXT
  8677 D7EA 04 44			.byte	4,'D'
  8678 D7EC 19 D6			.word	LBB_DATA		; DATA
  8679 D7EE 05 49			.byte	5,'I'
  8680 D7F0 83 D6			.word	LBB_INPUT		; INPUT
  8681 D7F2 03 44			.byte	3,'D'
  8682 D7F4 2D D6			.word	LBB_DIM			; DIM
  8683 D7F6 04 52			.byte	4,'R'
  8684 D7F8 2E D7			.word	LBB_READ		; READ
  8685 D7FA 03 4C			.byte	3,'L'
  8686 D7FC A8 D6			.word	LBB_LET			; LET
  8687 D7FE 03 44			.byte	3,'D'
  8688 D800 1D D6			.word	LBB_DEC			; DEC
  8689 D802 04 47			.byte	4,'G'
  8690 D804 60 D6			.word	LBB_GOTO		; GOTO
  8691 D806 03 52			.byte	3,'R'
  8692 D808 67 D7			.word	LBB_RUN			; RUN
  8693 D80A 02 49			.byte	2,'I'
  8694 D80C 7B D6			.word	LBB_IF			; IF
  8695 D80E 07 52			.byte	7,'R'
  8696 D810 39 D7			.word	LBB_RESTORE		; RESTORE
  8697 D812 05 47			.byte	5,'G'
  8698 D814 5B D6			.word	LBB_GOSUB		; GOSUB
  8699 D816 06 52			.byte	6,'R'
  8700 D818 40 D7			.word	LBB_RETIRQ		; RETIRQ
  8701 D81A 06 52			.byte	6,'R'
  8702 D81C 46 D7			.word	LBB_RETNMI		; RETNMI
  8703 D81E 06 52			.byte	6,'R'
  8704 D820 56 D7			.word	LBB_RETURN		; RETURN
  8705 D822 03 52			.byte	3,'R'
  8706 D824 36 D7			.word	LBB_REM			; REM
  8707 D826 04 53			.byte	4,'S'
  8708 D828 8E D7			.word	LBB_STOP		; STOP
  8709 D82A 02 4F			.byte	2,'O'
  8710 D82C F4 D6			.word	LBB_ON			; ON
  8711 D82E 04 4E			.byte	4,'N'
  8712 D830 EC D6			.word	LBB_NULL		; NULL
  8713 D832 03 49			.byte	3,'I'
  8714 D834 80 D6			.word	LBB_INC			; INC
  8715 D836 04 57			.byte	4,'W'
  8716 D838 CD D7			.word	LBB_WAIT		; WAIT
  8717 D83A 04 4C			.byte	4,'L'
  8718 D83C B3 D6			.word	LBB_LOAD		; LOAD
  8719 D83E 04 53			.byte	4,'S'
  8720 D840 70 D7			.word	LBB_SAVE		; SAVE
  8721 D842 03 44			.byte	3,'D'
  8722 D844 25 D6			.word	LBB_DEF			; DEF
  8723 D846 04 50			.byte	4,'P'
  8724 D848 0E D7			.word	LBB_POKE		; POKE
  8725 D84A 04 44			.byte	4,'D'
  8726 D84C 30 D6			.word	LBB_DOKE		; DOKE
  8727 D84E 04 43			.byte	4,'C'
  8728 D850 FA D5			.word	LBB_CALL		; CALL
  8729 D852 02 44			.byte	2,'D'
  8730 D854 37 D6			.word	LBB_DO			; DO
  8731 D856 04 4C			.byte	4,'L'
  8732 D858 C1 D6			.word	LBB_LOOP		; LOOP
  8733 D85A 05 50			.byte	5,'P'
  8734 D85C 28 D7			.word	LBB_PRINT		; PRINT
  8735 D85E 04 43			.byte	4,'C'
  8736 D860 10 D6			.word	LBB_CONT		; CONT
  8737 D862 04 4C			.byte	4,'L'
  8738 D864 AF D6			.word	LBB_LIST		; LIST
  8739 D866 05 43			.byte	5,'C'
  8740 D868 03 D6			.word	LBB_CLEAR		; CLEAR
  8741 D86A 03 4E			.byte	3,'N'
  8742 D86C D9 D6			.word	LBB_NEW			; NEW
  8743 D86E 05 57			.byte	5,'W'
  8744 D870 D6 D7			.word	LBB_WIDTH		; WIDTH
  8745 D872 03 47			.byte	3,'G'
  8746 D874 58 D6			.word	LBB_GET			; GET
  8747 D876 04 53			.byte	4,'S'
  8748 D878 97 D7			.word	LBB_SWAP		; SWAP
  8749 D87A 06 42			.byte	6,'B'
  8750 D87C EC D5			.word	LBB_BITSET		; BITSET
  8751 D87E 06 42			.byte	6,'B'
  8752 D880 E6 D5			.word	LBB_BITCLR		; BITCLR
  8753 D882 03 49			.byte	3,'I'
  8754 D884 93 D6			.word	LBB_IRQ			; IRQ
  8755 D886 03 4E			.byte	3,'N'
  8756 D888 E0 D6			.word	LBB_NMI			; NMI
  8757 D88A 04 42			.byte	4,'B'
  8758 D88C DD D5			.word	LBB_BEEP		; BEEP
  8759 D88E 05 50			.byte	5,'P'
  8760 D890 09 D7			.word	LBB_PLIST		; PLIST
  8761 D892 04 48			.byte	4,'H'
  8762 D894 6A D6			.word	LBB_HOME		; HOME
  8763 D896 03 43			.byte	3,'C'
  8764 D898 08 D6			.word	LBB_CLS			; CLS
  8765 D89A 06 4E			.byte	6,'N'
  8766 D89C E6 D6			.word	LBB_NORMAL		; NORMAL
  8767 D89E 07 49			.byte	7,'I'
  8768 D8A0 8C D6			.word	LBB_INVERSE		; INVERSE
  8769 D8A2 05 46			.byte	5,'F'
  8770 D8A4 49 D6			.word	LBB_FLASH		; FLASH
  8771 D8A6 06 4C			.byte	6,'L'
  8772 D8A8 B7 D6			.word	LBB_LOCATE		; LOCATE
  8773 D8AA 03 49			.byte	3,'I'
  8774 D8AC 7D D6			.word	LBB_INNUM		; IN#
  8775 D8AE 03 50			.byte	3,'P'
  8776 D8B0 25 D7			.word	LBB_PRNUM		; PR#
  8777
  8778 D8B2 06 50			.byte	6,'P'
  8779 D8B4 12 D7			.word	LBB_PORTIO		; PORTIO
  8780 D8B6 04 50			.byte	4,'P'
  8781 D8B8 1D D7			.word	LBB_PORTOUT		; PORTOUT
  8782 D8BA 06 53			.byte	6,'S'
  8783 D8BC 74 D7			.word	LBB_SCREEN		; SCREEN
  8784 D8BE 05 50			.byte	5,'P'
  8785 D8C0 02 D7			.word	LBB_PIXEL		; PIXEL
  8786 D8C2 04 4C			.byte	4,'L'
  8787 D8C4 AB D6			.word	LBB_LINE		; LINE
  8788 D8C6 04 4F			.byte	4,'O'
  8789 D8C8 F8 D6			.word	LBB_OVAL		; OVAL
  8790 D8CA 04 52			.byte	4,'R'
  8791 D8CC 32 D7			.word	LBB_RECT		; RECT
  8792 D8CE 05 43			.byte	5,'C'
  8793 D8D0 0B D6			.word	LBB_COLOR		; COLOR
  8794 D8D2 05 44			.byte	5,'D'
  8795 D8D4 28 D6			.word	LBB_DELAY		; DELAY	
  8796 D8D6 06 49			.byte	6,'I'
  8797 D8D8 75 D6			.word	LBB_I2COUT		; I2COUT
  8798 D8DA 03 44			.byte	3,'D'
  8799 D8DC 34 D6			.word	LBB_DOS			; DOS
  8800
  8801 				; secondary commands (can't start a statement)
  8802 D8DE 04 54			.byte	4,'T'
  8803 D8E0 9C D7			.word	LBB_TAB			; TAB
  8804 D8E2 04 45			.byte	4,'E'
  8805 D8E4 3A D6			.word	LBB_ELSE		; ELSE
  8806 D8E6 02 54			.byte	2,'T'
  8807 D8E8 A8 D7			.word	LBB_TO			; TO
  8808 D8EA 02 46			.byte	2,'F'
  8809 D8EC 4E D6			.word	LBB_FN			; FN
  8810 D8EE 04 53			.byte	4,'S'
  8811 D8F0 82 D7			.word	LBB_SPC			; SPC
  8812 D8F2 04 54			.byte	4,'T'
  8813 D8F4 A4 D7			.word	LBB_THEN		; THEN
  8814 D8F6 03 4E			.byte	3,'N'
  8815 D8F8 E3 D6			.word	LBB_NOT			; NOT
  8816 D8FA 04 53			.byte	4,'S'
  8817 D8FC 8A D7			.word	LBB_STEP		; STEP
  8818 D8FE 05 55			.byte	5,'U'
  8819 D900 B7 D7			.word	LBB_UNTIL		; UNTIL
  8820 D902 05 57			.byte	5,'W'
  8821 D904 D1 D7			.word	LBB_WHILE		; WHILE
  8822 D906 03 4F			.byte	3,'O'
  8823 D908 F1 D6			.word	LBB_OFF			; OFF
  8824
  8825 				; opperators
  8826 D90A 01 2B			.byte	1,'+'
  8827 D90C 00 00			.word	$0000			; +
  8828 D90E 01 2D			.byte	1,'-'
  8829 D910 00 00			.word	$0000			; -
  8830 D912 01 2A			.byte	1,'*'
  8831 D914 00 00			.word	$0000			; *
  8832 D916 01 2F			.byte	1,'/'
  8833 D918 00 00			.word	$0000			; /
  8834 D91A 05 4D			.byte	5,'M'
  8835 D91C D3 D6			.word	LBB_MOD			; MOD
  8836 D91E 01 5E			.byte	1,'^'
  8837 D920 00 00			.word	$0000			; ^
  8838 D922 03 41			.byte	3,'A'
  8839 D924 D1 D5			.word	LBB_AND			; AND
  8840 D926 03 45			.byte	3,'E'
  8841 D928 41 D6			.word	LBB_EOR			; EOR
  8842 D92A 02 4F			.byte	2,'O'
  8843 D92C F6 D6			.word	LBB_OR			; OR
  8844 D92E 02 3E			.byte	2,'>'
  8845 D930 C7 D5			.word	LBB_RSHIFT		; >>
  8846 D932 02 3C			.byte	2,'<'
  8847 D934 C1 D5			.word	LBB_LSHIFT		; <<
  8848 D936 01 3E			.byte	1,'>'
  8849 D938 00 00			.word	$0000			; >
  8850 D93A 01 3D			.byte	1,'='
  8851 D93C 00 00			.word	$0000			; =
  8852 D93E 01 3C			.byte	1,'<'
  8853 D940 00 00			.word	$0000			; <
  8854
  8855 				; functions
  8856 D942 04 53			.byte	4,'S'			;
  8857 D944 7A D7			.word	LBB_SGN			; SGN
  8858 D946 04 49			.byte	4,'I'			;
  8859 D948 88 D6			.word	LBB_INT			; INT
  8860 D94A 04 41			.byte	4,'A'			;
  8861 D94C CD D5			.word	LBB_ABS			; ABS
  8862 D94E 04 55			.byte	4,'U'			;
  8863 D950 BC D7			.word	LBB_USR			; USR
  8864 D952 04 46			.byte	4,'F'			;
  8865 D954 53 D6			.word	LBB_FRE			; FRE
  8866 D956 04 50			.byte	4,'P'			;
  8867 D958 21 D7			.word	LBB_POS			; POS
  8868 D95A 04 53			.byte	4,'S'			;
  8869 D95C 86 D7			.word	LBB_SQR			; SQR
  8870 D95E 04 52			.byte	4,'R'			;
  8871 D960 63 D7			.word	LBB_RND			; RND
  8872 D962 04 4C			.byte	4,'L'			;
  8873 D964 BD D6			.word	LBB_LOG			; LOG
  8874 D966 04 45			.byte	4,'E'			;
  8875 D968 44 D6			.word	LBB_EXP			; EXP
  8876 D96A 04 43			.byte	4,'C'			;
  8877 D96C 14 D6			.word	LBB_COS			; COS
  8878 D96E 04 53			.byte	4,'S'			;
  8879 D970 7E D7			.word	LBB_SIN			; SIN
  8880 D972 04 54			.byte	4,'T'			;
  8881 D974 A0 D7			.word	LBB_TAN			; TAN
  8882 D976 04 41			.byte	4,'A'			;
  8883 D978 D8 D5			.word	LBB_ATN			; ATN
  8884 D97A 05 50			.byte	5,'P'			;
  8885 D97C FD D6			.word	LBB_PEEK		; PEEK
  8886 D97E 05 44			.byte	5,'D'			;
  8887 D980 20 D6			.word	LBB_DEEK		; DEEK
  8888 D982 05 53			.byte	5,'S'			;
  8889 D984 6B D7			.word	LBB_SADD		; SADD
  8890 D986 04 4C			.byte	4,'L'			;
  8891 D988 A4 D6			.word	LBB_LEN			; LEN
  8892 D98A 05 53			.byte	5,'S'			;
  8893 D98C 92 D7			.word	LBB_STRS		; STR$
  8894 D98E 04 56			.byte	4,'V'			;
  8895 D990 C1 D7			.word	LBB_VAL			; VAL
  8896 D992 04 41			.byte	4,'A'			;
  8897 D994 D4 D5			.word	LBB_ASC			; ASC
  8898 D996 07 55			.byte	7,'U'			;
  8899 D998 B0 D7			.word	LBB_UCASES		; UCASE$
  8900 D99A 07 4C			.byte	7,'L'			;
  8901 D99C 97 D6			.word	LBB_LCASES		; LCASE$
  8902 D99E 05 43			.byte	5,'C'			;
  8903 D9A0 FE D5			.word	LBB_CHRS		; CHR$
  8904 D9A2 05 48			.byte	5,'H'			;
  8905 D9A4 65 D6			.word	LBB_HEXS		; HEX$
  8906 D9A6 05 42			.byte	5,'B'			;
  8907 D9A8 E1 D5			.word	LBB_BINS		; BIN$
  8908 D9AA 07 42			.byte	7,'B'			;
  8909 D9AC F2 D5			.word	LBB_BITTST		; BITTST
  8910 D9AE 04 4D			.byte	4,'M'			;
  8911 D9B0 C6 D6			.word	LBB_MAX			; MAX
  8912 D9B2 04 4D			.byte	4,'M'			;
  8913 D9B4 CF D6			.word	LBB_MIN			; MIN
  8914 D9B6 02 50			.byte	2,'P'			;
  8915 D9B8 07 D7			.word	LBB_PI			; PI
  8916 D9BA 05 54			.byte	5,'T'			;
  8917 D9BC AA D7			.word	LBB_TWOPI		; TWOPI
  8918 D9BE 07 56			.byte	7,'V'			;
  8919 D9C0 C5 D7			.word	LBB_VPTR		; VARPTR
  8920 D9C2 06 4C			.byte	6,'L'			;
  8921 D9C4 9E D6			.word	LBB_LEFTS		; LEFT$
  8922 D9C6 07 52			.byte	7,'R'			;
  8923 D9C8 5C D7			.word	LBB_RIGHTS		; RIGHT$
  8924 D9CA 05 4D			.byte	5,'M'			;
  8925 D9CC CA D6			.word	LBB_MIDS		; MID$
  8926 D9CE 05 50			.byte	5,'P'			;
  8927 D9D0 18 D7			.word	LBB_PORTIN		; PORTIN
  8928 D9D2 06 49			.byte	6,'I'			;
  8929 D9D4 6F D6			.word	LBB_I2CIN		; I2CIN
  8930 D9D6 05 52			.byte	5,'R'			;
  8931 D9D8 4C D7			.word	LBB_RES5		; RESERVED
  8932 D9DA 05 52			.byte	5,'R'			;
  8933 D9DC 51 D7			.word	LBB_RES6		; RESERVED
  8934
  8935 				; BASIC messages, mostly error messages
  8936 D9DE			LAB_BAER
  8937 D9DE 02 DA			.word	ERR_NF			;$00 NEXT without FOR
  8938 D9E0 13 DA			.word	ERR_SN			;$02 syntax
  8939 D9E2 1A DA			.word	ERR_RG			;$04 RETURN without GOSUB
  8940 D9E4 2F DA			.word	ERR_OD			;$06 out of data
  8941 D9E6 3B DA			.word	ERR_FC			;$08 function call
  8942 D9E8 49 DA			.word	ERR_OV			;$0A overflow
  8943 D9EA 52 DA			.word	ERR_OM			;$0C out of memory
  8944 D9EC 60 DA			.word	ERR_US			;$0E undefined statement
  8945 D9EE 74 DA			.word	ERR_BS			;$10 array bounds
  8946 D9F0 81 DA			.word	ERR_DD			;$12 double dimension array
  8947 D9F2 92 DA			.word	ERR_D0			;$14 divide by 0
  8948 D9F4 A1 DA			.word	ERR_ID			;$16 illegal direct
  8949 D9F6 B0 DA			.word	ERR_TM			;$18 type mismatch
  8950 D9F8 BE DA			.word	ERR_LS			;$1A long string
  8951 D9FA CE DA			.word	ERR_ST			;$1C string too complex
  8952 D9FC E1 DA			.word	ERR_CN			;$1E continue error
  8953 D9FE F0 DA			.word	ERR_UF			;$20 undefined function
  8954 DA00 03 DB			.word 	ERR_LD			;$22 LOOP without DO
  8955
  8956 				; I may implement these two errors to force definition of variables and
  8957 				; dimensioning of arrays before use.
  8958
  8959 				;	.word ERR_UV		;$24 undefined variable
  8960
  8961 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8962
  8963 				;	.word ERR_UA		;$26 undimensioned array
  8964 DA02 4E 45 58 54 20 77 + ERR_NF	.by	'NEXT without FOR',$00
  8965 DA13 53 79 6E 74 61 78 + ERR_SN	.by	'Syntax',$00
  8966 DA1A 52 45 54 55 52 4E + ERR_RG	.by	'RETURN without GOSUB',$00
  8967 DA2F 4F 75 74 20 6F 66 + ERR_OD	.by	'Out of DATA',$00
  8968 DA3B 46 75 6E 63 74 69 + ERR_FC	.by	'Function call',$00
  8969 DA49 4F 76 65 72 66 6C + ERR_OV	.by	'Overflow',$00
  8970 DA52 4F 75 74 20 6F 66 + ERR_OM	.by	'Out of memory',$00
  8971 DA60 55 6E 64 65 66 69 + ERR_US	.by	'Undefined statement',$00
  8972 DA74 41 72 72 61 79 20 + ERR_BS	.by	'Array bounds',$00
  8973 DA81 44 6F 75 62 6C 65 + ERR_DD	.by	'Double dimension',$00
  8974 DA92 44 69 76 69 64 65 + ERR_D0	.by	'Divide by zero',$00
  8975 DAA1 49 6C 6C 65 67 61 + ERR_ID	.by	'Illegal direct',$00
  8976 DAB0 54 79 70 65 20 6D + ERR_TM	.by	'Type mismatch',$00
  8977 DABE 53 74 72 69 6E 67 + ERR_LS	.by	'String too long',$00
  8978 DACE 53 74 72 69 6E 67 + ERR_ST	.by	'String too complex',$00
  8979 DAE1 43 61 6E 27 74 20 + ERR_CN	.by	'Can' $27 't continue',$00
  8980 DAF0 55 6E 64 65 66 69 + ERR_UF	.by	'Undefined function',$00
  8981 DB03 4C 4F 4F 50 20 77 + ERR_LD	.by	'LOOP without DO',$00
  8982
  8983 				;ERR_UV	.byte	'Undefined variable',$00
  8984
  8985 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8986
  8987 				;ERR_UA	.byte	'Undimensioned array',$00
  8988 DB13 0D 0A 42 72 65 61 + LAB_BMSG	.byte	$0D,$0A,'Break',$00
  8989 DB1B 20 45 72 72 6F 72 + LAB_EMSG	.byte	' Error',$00
  8990 DB22 20 69 6E 20 6C 69 + LAB_LMSG	.byte	' in line ',$00
  8991 DB2C 0D 0A 52 65 61 64 + LAB_RMSG	.byte	$0D,$0A,'Ready',$0D,$0A,$00
  8992
  8993 DB36 20 45 78 74 72 61 + LAB_IMSG	.byte	' Extra ignored',$0D,$0A,$00
  8994 DB47 20 52 65 64 6F 20 + LAB_REDO	.byte	' Redo from start',$0D,$0A,$00
  8995
  8996 DB5A			AA_end_basic
    35 						
    36 DB5A					ORG	$DFD8
    37 				;----------------------------------------------------------------------------
    38 				; This function enables BIOS-ROM at $E000-$FFFF and disables the RAM behind it.
    39 				;----------------------------------------------------------------------------
    40 DFD8 AD 00 17		BIOS2ROM	LDA	MMU		; MMU-register
    41 DFDB 09 01				ORA	#BIOS_EN	; 1 = enable BIOS ROM
    42 DFDD 8D 00 17				STA	MMU		; Activate BIOS ROM
    43 DFE0 60					RTS			; return
    44 						
    45 				;----------------------------------------------------------------------------
    46 				; This function Enables BIOS-RAM at $E000-$FFFF and disables BIOS-ROM.
    47 				;----------------------------------------------------------------------------
    48 DFE1 AD 00 17		BIOS2RAM	LDA	MMU		; MMU-register
    49 DFE4 29 FE				AND	#~BIOS_EN	; 0 = enable BIOS RAM, disable ROM
    50 DFE6 8D 00 17				STA	MMU		; Activate BIOS RAM
    51 DFE9 60					RTS			; return
    52
    53 DFEA					ORG 	$DFF0
    54 DFF0 42			LANGKEY		.byte	'B'
    55 DFF1 28 42 29 61 73 69 + LANGNAME 	.by	'(B)asic' $00
    56
    57 DFF9					ORG 	$E000       		; start address of BIOS (8K)
    58 E000					icl 	"jc2_bios.asm"
Source: jc2_bios.asm
     1 				; ******************************************************************************
     2 				; Junior Computer ][ BIOS Version 1.2.0 by Joerg Walke
     3 				;
     4 				; first implementation 28.12.2021
     5 				; updated 16.11.2024 by Joerg Walke
     6 				;
     7 				; Assembled With A65
     8 				;
     9 				; 20.03.2023 A bug in the disassembler code was fixed by the German Classic 
    10 				; Computing forum user jet2bue. See version history
    11 				;
    12 				; 01.08.2023 A bug in SD_WR_BLK was fixed. The bug was found by German Classic 
    13 				; Computing forum user Dietrich Lausberg. See version history
    14 				;
    15 				; 29.04.2024 SPI & IRQ optimization by Dietrich Lausberg
    16 				;
    17 				; 26.05.24 Changes in Fast SPI by Dietrich Lausberg
    18 				;
    19 				; 21.04.24 Integration with CF-IDE drivers into 1 32K eprom
    20 				; ******************************************************************************
    21
    22 E000 4C 3F E4		MON_COLD_START	JMP  	MAINSTART	; jump to monitor cold start
    23 E003 4C 3E E6		MON_WARM_START	JMP	MONINP		; jump to monitor warm start
    24
    25 				; **** Switch BASIC To RAM Page (B000..DFFF) ***********************************
    26 				; ******************************************************************************
    27 E006 20 8F FD		SWITCH_TO_RAM	JSR	BAS2RAM		; Set MMU bit 7 to 0, enable BASIC RAM
    28 E009 60					RTS			; return
    29
    30 				; **** Switch BASIC To ROM Page (B000..DFFF) ***********************************
    31 				; ******************************************************************************
    32 E00A 20 98 FD		SWITCH_TO_ROM	JSR	BAS2ROM		; Set MMU bit 7 to 1, enable BASIC ROM
    33 E00D EA			SWITCH		NOP			; maintain compatibility with v1.1.4
    34 E00E 60					RTS
    35
    36 				; **** Set Standard In/Out Routine ID ******************************************
    37 				; Input: A - ID Of Standard IO Device
    38 				; ******************************************************************************
    39 E00F 20 BE F7		SET_STDIOID	JSR	DEV_OPEN
    40
    41 				; **** Set Standard In/Out Routine *********************************************
    42 				; Input: X - Low Byte Of Standard Device Descriptor
    43 				;	 Y - High Byte Of Standard Device Descriptor
    44 				; ******************************************************************************
    45 E012 20 32 E0		SET_STDIO	JSR	SET_STDIN
    46 E015 4C 1F E0				JMP	SET_STDOUT0
    47
    48 				; **** Set Standard Out Routine ID *********************************************
    49 				; Input: A - ID Of Standard Output Device
    50 				; ******************************************************************************
    51 E018 20 BE F7		SET_STDOUTID	JSR	DEV_OPEN
    52
    53 				; **** Set Standard Out Routine ************************************************
    54 				; Input: X - Low Byte Of Standard Out Device Descriptor
    55 				;	 Y - High Byte Of Standard Out Device Descriptor
    56 				; ******************************************************************************
    57 E01B 86 DE		SET_STDOUT	STX	PDEVL
    58 E01D 84 DF				STY	PDEVH
    59 E01F A0 04		SET_STDOUT0	LDY	#$04
    60 E021 A2 00				LDX	#$00
    61 E023 B1 DE		SET_STDOUT1	LDA	(PDEV),Y
    62 E025 9D 70 1A				STA	STDOUT,X
    63 E028 C8					INY
    64 E029 E8					INX
    65 E02A E0 04				CPX	#$04
    66 E02C D0 F5				BNE	SET_STDOUT1
    67 E02E 60					RTS
    68
    69 				; **** Set Standard In Routine ID **********************************************
    70 				; Input: A - ID Of Standard Input Device
    71 				; ******************************************************************************
    72 E02F 20 BE F7		SET_STDINID	JSR	DEV_OPEN
    73
    74 				; **** Set Standard In Routine *************************************************
    75 				; Input: X - Low Byte Of Standard In Device Descriptor
    76 				;	 Y - High Byte Of Standard In Device Descriptor
    77 				; ******************************************************************************
    78 E032 86 DE		SET_STDIN	STX	PDEVL
    79 E034 84 DF				STY	PDEVH
    80 E036 A0 02				LDY	#$02
    81 E038 B1 DE				LDA	(PDEV),Y
    82 E03A 8D 6E 1A				STA	STDIN
    83 E03D C8					INY
    84 E03E B1 DE				LDA	(PDEV),Y
    85 E040 8D 6F 1A				STA	STDIN+1
    86 E043 60			         	RTS
    87
    88 				; **** Write Binary Routine ****************************************************
    89 				; Input: A - Output Byte to Standard Out
    90 				; ******************************************************************************
    91 E044 6C 70 1A		BOUT		JMP	(STDOUT)
    92
    93 				; **** Read Character Routine **************************************************
    94 				; Output: A - character read from standard in
    95 				; ******************************************************************************
    96 E047 20 4D E0		CIN		JSR	CGET		; call standard in. Character available?
    97 E04A 90 FB				BCC	CIN		; no, repeat
    98 E04C 60					RTS
    99
   100 				; **** Get Character (no wait) Routine *****************************************
   101 				; Output: A - character read from standard in
   102 				;         C - 1 char get, 0 no char get
   103 				; ******************************************************************************
   104 E04D 4C D4 E1		CGET            JMP     CHAR_GET
   105
   106 				; **** Write LF Character Routine **********************************************
   107 				; ******************************************************************************
   108 E050 A9 0A		LFOUT		LDA  	#LF        	; write a LF
   109 									; fall through to COUT
   110
   111 				; **** Write Character Routine *************************************************
   112 				; Input: A - character to write
   113 				; ******************************************************************************
   114 E052 20 44 E0		COUT 		JSR     BOUT
   115 E055 C9 0D		                CMP  	#CR        	; character was a CR?
   116 E057 F0 F7				BEQ  	LFOUT      	; yes, also write LF
   117 E059 60					RTS
   118
   119 				; **** Write CR/LF To Terminal *************************************************
   120 				; ******************************************************************************
   121 E05A A9 0D		CROUT		LDA	#CR		; write a CR
   122 E05C D0 F4				BNE	COUT
   123
   124 				; **** Write Single Space Char To Terminal *************************************
   125 				; ******************************************************************************
   126 E05E A9 20		SPCOUT		LDA	#$20		; write a Space char
   127 E060 D0 E2				BNE	BOUT
   128
   129 				; **** Read String Routine *****************************************************
   130 				; Output:  (PSTRL, PSTRH) - pointer to CR terminated string data
   131 				; ******************************************************************************
   132 E062 A2 02		STRIN           LDX  	#$02		; initialize character index
   133 E064 CA			BACKSPACE       DEX
   134 E065 F0 FB				BEQ  	STRIN		; if line empty, restart
   135 E067 20 47 E0		NEXTCHR         JSR  	CIN        	; get next character from input buffer
   136 E06A 9D 00 14				STA  	STRBUF,X   	; store character in string buffer
   137 E06D C9 0D				CMP  	#CR		; is it a CR?
   138 E06F F0 0F		                BEQ  	ENDSTRIN	; yes, exit
   139 E071 20 52 E0		                JSR  	COUT		; echo character
   140 E074 C9 08				CMP  	#BS        	; backspace key?
   141 E076 F0 EC				BEQ  	BACKSPACE  	; yes
   142 E078 E8			                INX             	; advance string index
   143 E079 D0 EC		                BNE  	NEXTCHR    	; more then 255 characters? No, read next char
   144 E07B A9 0D		                LDA  	#CR        	; yes, auto new line and stop reading
   145 E07D 9D 00 14				STA  	STRBUF,X   	; store CR in string buffer
   146 E080 4C 52 E0		ENDSTRIN        JMP  	COUT       	; send CR
   147
   148 				; **** Write String Routine ****************************************************
   149 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   150 				; ******************************************************************************
   151 E083 A0 00		STROUT		LDY  	#$00       	; index y is 0
   152
   153 				; **** Write String From Index Routine *****************************************
   154 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   155 				;	  Y              - start index into string data
   156 				; ******************************************************************************
   157 E085 B1 EA		WRSTR		LDA  	(PSTR),Y   	; load char at string pos y
   158 E087 F0 07				BEQ  	ENDSTROUT  	; exit, if NULL char
   159 E089 20 52 E0				JSR  	COUT       	; write character
   160 E08C C8					INY             	; next index
   161 E08D 4C 85 E0				JMP  	WRSTR
   162 E090 60			ENDSTROUT	RTS
   163
   164 				; **** Print A Byte In Hexadecimal *********************************************
   165 				; Input: A - data byte to print in hex
   166 				; ******************************************************************************
   167 E091 48			HEXOUT          PHA             	; save A for lower hex digit
   168 E092 4A			                LSR  	
   169 E093 4A			                LSR  	
   170 E094 4A			                LSR  	
   171 E095 4A			                LSR  	
   172 E096 20 9A E0		                JSR  	HEXDIG		; write upper hex digit
   173 E099 68			                PLA             	; write lower hex digit
   174 									; fall through to HEXDIG
   175
   176 				; **** Print A Single Hexadecimal Digit ****************************************
   177 				; Input: A - data nibble in Bit 0-3 to print in hex
   178 				; ******************************************************************************
   179 E09A 29 0F		HEXDIG          AND     #$0F    	; mask lower digit
   180 E09C 09 30		                ORA     #'0'    	; add 48
   181 E09E C9 3A		                CMP     #'9'+1  	; decimal digit?
   182 E0A0 90 02		                BCC     PRHEX   	; yes, print it
   183 E0A2 69 06		                ADC     #6      	; add offset for letter digit
   184 E0A4 4C 44 E0		PRHEX		JMP     BOUT
   185
   186 				; **** Print A Byte As Decimal Number ******************************************
   187 				; Input: A - number 00..FF (0..255)
   188 				; ******************************************************************************
   189 E0A7 20 BD E0		NUMOUT		JSR	DEC2STR
   190 E0AA A2 02				LDX	#2
   191 E0AC B5 F8		NEXTNUMOUT	LDA	DIG0,X
   192 E0AE 20 44 E0				JSR	BOUT
   193 E0B1 CA					DEX
   194 E0B2 10 F8				BPL	NEXTNUMOUT
   195 E0B4 60					RTS
   196
   197 				; **** Clear Screen Routine ****************************************************
   198 				; ******************************************************************************
   199 E0B5 A9 07		CLRSCRN		LDA	#CMD_CLRSCRN
   200
   201 				; **** Call Standard Print Command Routine *************************************
   202 				; Input : A - command byte
   203 				;         X - command data byte low
   204 				;         Y - command data byte high
   205 				; ******************************************************************************
   206 E0B7 6C 72 1A		CMDPRINT	JMP	(STDCMD)
   207
   208 				; **** Call Opened Device Command Routine **************************************
   209 				; Input : A - command byte
   210 				;         X - command data byte low
   211 				;         Y - command data byte high
   212 				; ******************************************************************************
   213 E0BA 6C 6C 1A		CMDDEV		JMP	(DEVCMD)
   214
   215 				; **** Convert a Byte To Decimal String ****************************************
   216 				; Input:  A - number 00..FF (0..255)
   217 				; Output; DIG0 (10^0), DIG1 (10^1), DIG2 (10^2)
   218 				; ******************************************************************************
   219 E0BD A2 30		DEC2STR		LDX	#48
   220 E0BF 86 F8				STX	DIG0		; initialize digit counter 0 to '0'
   221 E0C1 86 F9				STX	DIG1		; initialize digit counter 1 to '0'
   222 E0C3 86 FA				STX	DIG2		; initialize digit counter 2 to '0'
   223 E0C5 C9 64		GETDIG2		CMP	#100		; is A >= 100?
   224 E0C7 90 06				BCC	GETDIG1		; no, convert next digit
   225 E0C9 E9 64				SBC	#100		; yes, subract 100 from A
   226 E0CB E6 FA				INC	DIG2		; and increment digit counter 2
   227 E0CD D0 F6				BNE	GETDIG2		; branch always
   228 E0CF C9 0A		GETDIG1		CMP	#10		; is A >= 10?
   229 E0D1 90 06				BCC	GETDIG0		; no, convert next digit
   230 E0D3 E9 0A				SBC	#10		; yes, subract 10 from A
   231 E0D5 E6 F9				INC	DIG1		; and increment digit counter 1
   232 E0D7 D0 F6				BNE	GETDIG1		; branch always
   233 E0D9 65 F8		GETDIG0		ADC	DIG0		; add digit counter 0 to remainder in A
   234 E0DB 85 F8				STA	DIG0		; and store it back to digit counter 0
   235 E0DD 60					RTS
   236
   237 				; **** Print Tab Routine *******************************************************
   238 				; Input: A - number of space characters to print
   239 				; ******************************************************************************
   240 E0DE 85 FC		TAB		STA  	TEMP
   241 E0E0 A9 20				LDA  	#SPC		; load SPC char
   242 E0E2 20 52 E0		PRINTTAB	JSR  	COUT		; write SPC
   243 E0E5 C6 FC				DEC   	TEMP
   244 E0E7 D0 F9		                BNE   	PRINTTAB   	; all spaces written? No, repeat
   245 E0E9 60					RTS
   246
   247 				; **** Read Hex Number From Input String ***************************************
   248 				; Input:  Y - current input string position to read from
   249 				; Output: (NUML, NUMH) - last 8 digits of read hex number
   250 				; ******************************************************************************
   251 E0EA A2 00		HEXINPUT	LDX   	#$00
   252 E0EC 86 F8				STX   	NUML       	; clear input value
   253 E0EE 86 F9				STX   	NUMH
   254 E0F0 B9 00 14		NEXTDIGIT       LDA   	STRBUF,Y   	; get next input char
   255 E0F3 C9 30				CMP   	#'0'
   256 E0F5 90 21				BCC   	NOTHEX     	; char < '0'? Yes, no hex digit
   257 E0F7 C9 3A				CMP   	#':'
   258 E0F9 90 0C				BCC   	NUMDIGIT   	; char is in '0'..'9'
   259 E0FB 29 DF				AND   	#$DF	 	; uppercase chars only
   260 E0FD C9 41		HEXDIGIT	CMP   	#'A'
   261 E0FF 90 17				BCC   	NOTHEX     	; char < 'A'? Yes, no hex digit
   262 E101 C9 47				CMP   	#'G'
   263 E103 B0 13				BCS   	NOTHEX     	; char > 'F'? Yes, no hex digit
   264 E105 E9 36				SBC   	#'A'-11	 	; char 'A'..'F' to value 10..16
   265 E107 0A			NUMDIGIT        ASL   	
   266 E108 0A					ASL   	
   267 E109 0A					ASL   	
   268 E10A 0A					ASL   			; digit shifted to upper nibble
   269 E10B A2 04				LDX   	#$04      	; load shift loop counter
   270 E10D 0A			SHIFT		ASL   			; shift msb in C
   271 E10E 26 F8				ROL   	NUML
   272 E110 26 F9				ROL   	NUMH
   273 E112 CA					DEX
   274 E113 D0 F8				BNE   	SHIFT	 	; 4 times shifted? No, repeat
   275 E115 C8					INY		 	; increment string index
   276 E116 D0 D8				BNE   	NEXTDIGIT	; branch always
   277 E118 60			NOTHEX		RTS
   278
   279 				; **** Read String From Input Buffer *******************************************
   280 				; Input:  Y - current input string position to read from
   281 				; Output: C = 1, string found C = 0, string not found
   282 				;         PSTRL = low byte of string pointer
   283 				;	  PSTRH = high byte of string pointer
   284 				; ******************************************************************************
   285 E119 18			STRINPUT	CLC
   286 E11A B9 00 14		NEXTSTRCHAR	LDA  	STRBUF,Y   	; get next input char
   287 E11D C8					INY
   288 E11E C9 20				CMP  	#' '
   289 E120 F0 F8				BEQ  	NEXTSTRCHAR 	; ignore spaces
   290 E122 C9 0D				CMP  	#CR
   291 E124 F0 19				BEQ  	ENDSTRING 	; end of input line, no filename found
   292 E126 C9 22				CMP	#'"'
   293 E128 D0 15				BNE	ENDSTRING
   294 E12A A2 00				LDX	#$00
   295 E12C 38					SEC
   296 E12D B9 00 14		READSTRING	LDA  	STRBUF,Y   	; get next input char
   297 E130 C9 0D				CMP	#CR
   298 E132 F0 0B				BEQ	ENDSTRING
   299 E134 C9 22				CMP	#'"'
   300 E136 F0 07				BEQ	ENDSTRING
   301 E138 9D 00 15				STA	RBUFF,X		; char to buffer
   302 E13B C8					INY
   303 E13C E8					INX
   304 E13D D0 EE				BNE	READSTRING	; read next char of filename
   305 E13F A9 00		ENDSTRING	LDA	#$00
   306 E141 9D 00 15				STA	RBUFF,X		; terminate filename string with NULL
   307
   308 				; **** Set String Pointer To Read Buffer ***************************************
   309 				; Output: X - low byte of string pointer
   310 				;	  Y - high byte of string pointer
   311 				; ******************************************************************************
   312
   313 E144 A2 00		SETSTRBUFF	LDX	#< RBUFF	; set string pointer to filename buffer
   314 E146 A0 15				LDY	#> RBUFF
   315 E148 86 EA		SETSTRBUFF0	STX	PSTRL
   316 E14A 84 EB				STY	PSTRH
   317 E14C 60					RTS
   318
   319 				; **** Delay Routine ***********************************************************
   320 				; Input: A - milliseconds to wait
   321 				; ******************************************************************************
   322 E14D 8D 97 1A		DELAY           STA  	CNTD
   323 E150 D0 04				BNE	LOOPDELAY
   324
   325 				; **** Short Delay Routine *****************************************************
   326 				; Input: A - microseconds to wait
   327 				; ******************************************************************************
   328 E152 A8			SHORTDELAY	TAY
   329 E153 8C 94 1A		SHORTDELAY1	STY  	CNTA		; set counter
   330 E156 2C 9F 1A		LOOPDELAY	BIT  	CNTIRQ		; check if counter reached 0
   331 E159 10 FB				BPL  	LOOPDELAY	; no, check again
   332 E15B 60					RTS
   333
   334 				; **** Check ESC Routine *******************************************************
   335 				; Output: C = 1 ESC pressed, 0 ESC not pressed
   336 				; Beep if ESC pressed
   337 				; ******************************************************************************
   338 E15C 20 4D E0		CHKESC		JSR     CGET            ; key pressed?
   339 E15F 90 05				BCC	NOTESC		; no
   340 E161 C9 1B				CMP     #ESC		; ESC pressed?
   341 E163 F0 02				BEQ	BEEP		; yes, exit and beep.
   342 E165 18					CLC			; no, clear carry flag
   343 E166 60			NOTESC		RTS
   344
   345 				; **** System Beep Routine *****************************************************
   346 				; ******************************************************************************
   347 E167 6C 66 1A		BEEP		JMP	(STDBEEP)	; call standard BEEP routine
   348
   349 				; **** Simple Beep Routine *****************************************************
   350 				; ******************************************************************************
   351 E16A AD 83 1A		DOBEEP		LDA	PBDD		; save port b data direction register
   352 E16D 48					PHA
   353 E16E A2 60				LDX     #$60		; repeat 60 times
   354 E170 A9 21				LDA     #$21
   355 E172 A8					TAY
   356 E173 8D 83 1A				STA     PBDD		; turn speaker on
   357 E176 8C 82 1A		BEEPLOOP	STY     PBD		; set PB0 high
   358 E179 A9 01				LDA     #$01
   359 E17B 20 4D E1				JSR     DELAY		; delay of ~1ms
   360 E17E 88					DEY
   361 E17F 8C 82 1A				STY	PBD		; set PB0 low
   362 E182 A9 01				LDA	#$01
   363 E184 20 4D E1				JSR	DELAY		; delay of ~1ms
   364 E187 A0 21				LDY	#$21
   365 E189 CA					DEX
   366 E18A D0 EA				BNE	BEEPLOOP	; not finished, repeat
   367 E18C 68					PLA
   368 E18D 8D 83 1A				STA	PBDD		; restore port b data direction register
   369 E190 38					SEC
   370 E191 60					RTS
   371
   372 				; ******************************************************************************
   373 				; REAL TIME CLOCK ROUTINES ALIASES
   374 				; ******************************************************************************
   375
   376 				; **** Print Date And Time *****************************************************
   377
   378 				; ******************************************************************************
   379
   380 E192 4C F9 EB		PRINT_DATETIME	JMP	PRINTDATETIME
   381
   382 				; **** Print Time *************************************************************
   383
   384 				; ******************************************************************************
   385
   386 E195 4C 05 EC		PRINT_TIME	JMP	PRINTTIME
   387
   388 				; **** Print Date **************************************************************
   389
   390 				; ******************************************************************************
   391
   392 E198 4C 2B EC		PRINT_DATE	JMP	PRINTDATE
   393
   394 				; **** Print Date Including Day Of Week ****************************************
   395
   396 				; ******************************************************************************
   397
   398 E19B 4C 17 EC		PRINT_FULLDATE	JMP	PRINTFULLDATE
   399
   400 				; **** Set Date And Time *******************************************************
   401
   402 				; ******************************************************************************
   403
   404 E19E 4C 59 EB		SET_DATETIME	JMP	SETDATETIME
   405
   406 				; **** Set Time ****************************************************************
   407
   408 				; ******************************************************************************
   409
   410 E1A1 4C 86 EB		SET_TIME	JMP	SETTIME
   411
   412 				; **** Set Date ****************************************************************
   413
   414 				; ******************************************************************************
   415
   416 E1A4 4C 5C EB		SET_DATE	JMP	SETDATE
   417
   418 				; **** Add Storage Device ******************************************************
   419
   420 				; Input:   X - device descriptor pointer low
   421 				;          Y - device descriptor pointer high
   422 				; Output - C = 1 Success, C = 0 Error
   423 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
   424
   425 				; ******************************************************************************
   426
   427 E1A7 4C 6F F7		ADD_DEVICE	JMP	DEV_ADD
   428
   429 				; **** Open Device For Read/Write **********************************************
   430
   431 				; Input:  A - device id
   432 				; Output: C = 1 Success, C = 0 Error
   433 				;         X - device descriptor pointer low
   434 				;         Y - device descriptor pointer high
   435
   436 				; ******************************************************************************
   437
   438 E1AA 4C BE F7		OPEN_DEVICE	JMP	DEV_OPEN
   439
   440 				; **** Reset Standard I/O To First Screen Device *******************************
   441
   442 				; ******************************************************************************
   443
   444 E1AD AD 74 1A		RESET_STDIO	LDA	STDINDEV	; open base In device
   445 E1B0 20 2F E0				JSR	SET_STDINID	; and set it as standard input
   446 E1B3 AD 75 1A				LDA	STDOUTDEV	; open base Out device
   447 E1B6 4C 18 E0				JMP	SET_STDOUTID	; and set it as standard output
   448
   449 				; **** Read Joystick Port ******************************************************
   450
   451 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   452 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   453 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   454 				;         C = 0 - No joystick port available; C = 1 - Joystickport available
   455
   456 				; ******************************************************************************
   457
   458 E1B9 4C 15 F7		READ_JOYSTICK   JMP     READ_JOY_PORT
   459
   460 				; **** Decode Joystick Data ****************************************************
   461
   462 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   463 				;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   464 				;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   465
   466 				; ******************************************************************************
   467
   468 E1BC 4C 1D F7		DECODE_JOYSTICK JMP     DECODE_JOY_PORT
   469
   470 				; **** Mute All Sound Chip Channels ********************************************
   471
   472 				; ******************************************************************************
   473
   474 E1BF 4C D0 E3		SOUND_MUTE_ALL  JMP     SOUND_MUTEALL
   475
   476 				; **** Mute A Sound Chip Channel ***********************************************
   477
   478 				; Input: A - Channel # (0..3)
   479
   480 				; ******************************************************************************
   481
   482 E1C2 4C DA E3		SOUND_MUTE_CHAN JMP     SOUND_MUTE
   483
   484 				; **** Set Attenuation For A Sound Chip Channel ********************************
   485
   486 				; Input: A - Channel # (0..3)
   487 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
   488
   489 				; ******************************************************************************
   490
   491 E1C5 4C DC E3		SOUND_SET_ATN   JMP     SOUND_SETATN
   492
   493 				; **** Set Periodic Noise ******************************************************
   494
   495 				; Input: X - Noise Shift Rate
   496
   497 				; ******************************************************************************
   498
   499 E1C8 4C EA E3		SOUND_P_NOISE   JMP     SOUND_PNOISE
   500
   501 				; **** Set White Noise *********************************************************
   502
   503 				; Input: X - Noise Shift Rate
   504
   505 				; ******************************************************************************
   506
   507 E1CB 4C EE E3		SOUND_W_NOISE   JMP     SOUND_WNOISE
   508
   509 				; **** Set Noise ***************************************************************
   510
   511 				; Input: A - 0 = Periodic Noise  1 = White Noise
   512 				;	 X - Noise Shift Rate
   513
   514 				; ******************************************************************************
   515
   516 E1CE 4C F0 E3		SOUND_SET_NOISE JMP     SOUND_SETNOISE
   517
   518 				; **** Set Sound Frequency in HZ ***********************************************
   519
   520 				; Input: A - Channel (0..2)
   521 				;	 X - Frequency Low Bits 7..0
   522 				;	 Y - Frequency High Bits 9..8
   523
   524 				; ******************************************************************************
   525
   526 E1D1 4C FB E3		SOUND_SET_FREQ  JMP     SOUND_SETFREQ
   527
   528 				; ******************************************************************************
   529 				; INTERNAL
   530 				; ******************************************************************************
   531
   532 				; **** Extended Read-Character Handler *****************************************
   533
   534 E1D4 20 DF E1		CHAR_GET        JSR     READ_STD_IN
   535 E1D7 90 03		                BCC     NO_CHAR_GET
   536 E1D9 6C 24 1A		                JMP     (KEY_HANDLER)
   537 E1DC 6C 26 1A		NO_CHAR_GET     JMP     (NKEY_HANDLER)
   538 E1DF 6C 6E 1A		READ_STD_IN     JMP	(STDIN)
   539
   540 				; ******************************************************************************
   541 				; TTY DEVICE DRIVER
   542 				; ******************************************************************************
   543
   544 				; **** Terminal Command Routine ************************************************
   545
   546 				; Input : A - command byte
   547 				;         X - command data byte low
   548 				;         Y - command data byte high
   549
   550 				; ******************************************************************************
   551
   552 E1E2 C9 09		TTY_CMD		CMP	#9
   553 E1E4 B0 13				BCS	END_TTY_CMD
   554 E1E6 84 FD				STY	YSAV
   555 E1E8 0A					ASL	
   556 E1E9 A8					TAY
   557 E1EA B9 FA E1				LDA	TTY_CMD_TABLE,Y
   558 E1ED 85 EA				STA	PSTRL
   559 E1EF B9 FB E1				LDA	TTY_CMD_TABLE+1,Y
   560 E1F2 85 EB				STA	PSTRH
   561 E1F4 A4 FD				LDY	YSAV
   562 E1F6 6C EA 00				JMP     (PSTR)
   563 E1F9 60			END_TTY_CMD	RTS
   564
   565 E1FA 0C E2 3A E2 3E E2 + TTY_CMD_TABLE	.word	TTY_INIT,TTY_IDENTIFY,TTY_NORMAL,TTY_INVERSE,TTY_FLASH
   566 E204 4A E2 4E E2 57 E2 + 		.word	TTY_HOME,TTY_CLRLINE,TTY_CLRSCRN,TTY_SETCURSOR
   567
   568 				; **** Initialize TTY Device ***************************************************
   569
   570 				; ******************************************************************************
   571
   572 E20C A9 00		TTY_INIT	LDA  	#$00
   573 E20E 85 E0				STA  	BAUDRATE   	; initialize baud rate variable
   574 E210 A9 0B				LDA  	#$0B       	; set ACIA to
   575 E212 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   576 E215 A2 19				LDX  	#$19		; start with 1 stop bit, 8 data bits, 2400 bps as the current baud rate
   577 E217 8E 03 16		NEXTBAUD	STX  	CTRL_REG	; set the baud rate
   578 E21A 20 3A E2				JSR  	TTY_IDENTIFY	; send identify string to terminal
   579 E21D A9 28				LDA  	#40
   580 E21F 20 4D E1				JSR  	DELAY		; wait for ~64ms
   581 E222 AD 01 16				LDA  	STAT_REG
   582 E225 29 08				AND  	#$08		; ACIA input register full?
   583 E227 F0 0B				BEQ  	NOESC	 	; no, go on
   584 E229 AD 00 16				LDA  	DATA_REG    	; read data register from ACIA
   585 E22C C9 1B				CMP  	#ESC	 	; is it a ESC char
   586 E22E D0 04				BNE  	NOESC	 	; no, go on
   587 E230 86 E0				STX  	BAUDRATE    	; and store it
   588 E232 A2 1F				LDX  	#$1F	 	; detection finished
   589 E234 E8			NOESC           INX  			; try next baud rate
   590 E235 E0 20				CPX  	#$20
   591 E237 90 DE				BCC  	NEXTBAUD   	; tried all baud rates?
   592 E239 60					RTS
   593
   594 				; **** Identify TTY Device *****************************************************
   595
   596 				; ******************************************************************************
   597
   598 E23A A0 09		TTY_IDENTIFY    LDY  	#ESCGID-STRINGP	; load sequence index
   599 E23C D0 1B				BNE  	PRINTESC   	; jump always
   600
   601 				; **** Set Normal Text *********************************************************
   602
   603 				; ******************************************************************************
   604
   605 E23E A0 0C		TTY_NORMAL      LDY  	#ESCNORM-STRINGP; load sequence index
   606 E240 D0 17				BNE  	PRINTESC   	; jump always
   607
   608 				; **** Set Inverse Text ********************************************************
   609
   610 				; ******************************************************************************
   611
   612 E242 A0 0E		TTY_INVERSE     LDY  	#ESCINV-STRINGP ; load sequence index
   613 E244 D0 13				BNE  	PRINTESC   	; jump always
   614
   615 				; **** Set Blinking Text *******************************************************
   616
   617 				; ******************************************************************************
   618
   619 E246 A0 11		TTY_FLASH       LDY  	#ESCBLNK-STRINGP; load sequence index
   620 E248 D0 0F				BNE  	PRINTESC   	; jump always
   621
   622 				; **** Set Cursor To Home Position *********************************************
   623
   624 				; ******************************************************************************
   625
   626 E24A A0 04		TTY_HOME        LDY  	#ESCHOME-STRINGP; load sequence index
   627 E24C D0 0B				BNE  	PRINTESC   	; jump always
   628
   629 				; **** Clear Line **************************************************************
   630
   631 				; ******************************************************************************
   632
   633 E24E A9 0D		TTY_CLRLINE     LDA	#$0D
   634 E250 20 44 E0				JSR	BOUT
   635 E253 A0 06				LDY  	#ESCCLL-STRINGP	; load sequence index
   636 E255 D0 02				BNE  	PRINTESC   	; jump always
   637
   638 				; **** Clear Screen And Set Cursor To Home Position ****************************
   639
   640 				; ******************************************************************************
   641
   642 E257 A0 00		TTY_CLRSCRN     LDY  	#ESCCLS-STRINGP	; load sequence index
   643 									; fall through to PRINTESC
   644
   645 				; **** VT100 ESC Sequence Loader ***********************************************
   646
   647 				; ******************************************************************************
   648
   649 E259 20 62 E2		PRINTESC        JSR	TTY_ESCCODE
   650 E25C 20 43 E5				JSR	LOADSTRING
   651 E25F 4C 85 E0				JMP  	WRSTR
   652
   653 				; **** VT100 ESC Start Code ****************************************************
   654
   655 				; ******************************************************************************
   656
   657 E262 A9 1B		TTY_ESCCODE	LDA	#$1B
   658 E264 20 44 E0				JSR	BOUT
   659 E267 A9 5B				LDA	#'['
   660 E269 4C 44 E0				JMP	BOUT
   661
   662 				; **** Set Cursor Location *****************************************************
   663
   664 				; Input: X - x position of cursor.  Y - y position of cursor
   665
   666 				; ******************************************************************************
   667
   668 E26C 8A			TTY_SETCURSOR	TXA
   669 E26D 48					PHA
   670 E26E 20 62 E2				JSR	TTY_ESCCODE
   671 E271 98					TYA
   672 E272 20 A7 E0				JSR	NUMOUT
   673 E275 A9 3B				LDA	#';'
   674 E277 20 44 E0				JSR	BOUT
   675 E27A 68					PLA
   676 E27B 20 A7 E0				JSR	NUMOUT
   677 E27E A9 48				LDA	#'H'
   678 E280 4C 44 E0				JMP	BOUT
   679
   680 				; ******************************************************************************
   681 				; LOW LEVEL REAL TIME CLOCK CODE
   682 				; ******************************************************************************
   683
   684 				; **** Set Day Of Week *********************************************************
   685
   686 				; Input: A - Day Of Week 1 (MON) - 7 (SUN)
   687
   688 				; ******************************************************************************
   689
   690 E283 85 F3		WRITEDOW	STA	ACC
   691 E285 A9 03				LDA	#$03
   692 E287 20 13 E3				JSR	SETRTCADR
   693 E28A A5 F3				LDA	ACC
   694 E28C 20 67 E3				JSR	I2C_SEND	; set day of week
   695 E28F 4C 35 E3				JMP	I2C_STOP
   696
   697 				; **** Get Day Of Week *********************************************************
   698
   699 				; Output: A - Day Of Week 1 (MON) - 7 (SUN)
   700
   701 				; ******************************************************************************
   702
   703 E292 A9 03		READDOW		LDA	#$03
   704 E294 20 E6 E2				JSR	READCLOCK
   705 E297 98					TYA
   706 E298 60					RTS
   707
   708 				; **** Write Time **************************************************************
   709
   710 				; Input: A - HOUR 	in BCD ($00-$23)
   711 				;	 X - MINUTE 	in BCD ($00-$59)
   712 				;	 Y - SECOND	in BCD ($00-$59)
   713
   714 				; ******************************************************************************
   715
   716 E299 85 F3		WRITETIME	STA	ACC
   717 E29B 86 F5				STX	XREG
   718 E29D 84 F4				STY	YREG
   719 E29F A9 00		WRITETIME2	LDA	#$00		; start at register 0
   720 E2A1 20 C9 E2				JSR	WRITECLOCK	; write time bytes to clock registers
   721 E2A4 A9 08				LDA	#$08		; set address pointer to ram
   722 E2A6 20 13 E3				JSR	SETRTCADR
   723 E2A9 A9 65				LDA	#$65		; time set mark
   724 E2AB 20 67 E3				JSR	I2C_SEND
   725 E2AE 4C 35 E3				JMP	I2C_STOP
   726
   727 				; **** Write Date **************************************************************
   728
   729 				; Input: A - YEAR 	in BCD ($00-$99)
   730 				;	 X - MONTH 	in BCD ($01-$12)
   731 				;	 Y - DAY	in BCD ($01-$31)
   732
   733 				; ******************************************************************************
   734
   735 E2B1 85 F3		WRITEDATE	STA	ACC
   736 E2B3 86 F5				STX	XREG
   737 E2B5 84 F4				STY	YREG
   738 E2B7 A9 04		WRITEDATE2	LDA	#$04		; start at register 4
   739 E2B9 20 C9 E2				JSR	WRITECLOCK	; write date bytes to clock register
   740 E2BC A9 09				LDA	#$09		; set address pointer to ram
   741 E2BE 20 13 E3				JSR	SETRTCADR
   742 E2C1 A9 02				LDA	#$02		; date set mark
   743 E2C3 20 67 E3				JSR	I2C_SEND
   744 E2C6 4C 35 E3				JMP	I2C_STOP
   745
   746 				; **** Write Data To Clock *****************************************************
   747
   748 				; ******************************************************************************
   749
   750 E2C9 20 13 E3		WRITECLOCK	JSR	SETRTCADR
   751 E2CC A5 F4				LDA	YREG
   752 E2CE 20 67 E3				JSR	I2C_SEND	; set second or day
   753 E2D1 A5 F5				LDA	XREG
   754 E2D3 20 67 E3				JSR	I2C_SEND	; set minute or month
   755 E2D6 A5 F3				LDA	ACC
   756 E2D8 20 67 E3				JSR	I2C_SEND	; set hour or year
   757 E2DB 4C 35 E3				JMP	I2C_STOP
   758
   759 				; **** Read Time ***************************************************************
   760
   761 				; Output: A - HOUR 	in BCD ($00-$23)
   762 				;	  X - MINUTE 	in BCD ($00-$59)
   763 				;	  Y - SECOND	in BCD ($00-$59)
   764
   765 				; ******************************************************************************
   766
   767 E2DE A9 00		READTIME	LDA	#$00
   768 E2E0 F0 04				BEQ	READCLOCK
   769
   770 				; **** Read Date ***************************************************************
   771
   772 				; Output: A - YEAR 	in BCD ($00-$99)
   773 				; 	  X - MONTH 	in BCD ($01-$12)
   774 				; 	  Y - DAY	in BCD ($01-$31)
   775
   776
   777 				; ******************************************************************************
   778
   779 E2E2 A9 04		READDATE	LDA	#$04
   780 E2E4 D0 00				BNE	READCLOCK
   781
   782 				; **** Read Data From Clock ****************************************************
   783
   784 				; ******************************************************************************
   785
   786 E2E6 20 13 E3		READCLOCK	JSR	SETRTCADR	; set read pointer
   787 E2E9 20 26 E3				JSR	I2C_START	; send start condition
   788 E2EC A9 68				LDA	#I2C_RTC_ADR	; the I2C address
   789 E2EE 20 62 E3				JSR	I2C_READ_DEV	; send device id and set read mode
   790 E2F1 20 9F E3				JSR	I2C_RCV		; receive first data byte
   791 E2F4 85 F4				STA	YREG		; and store it
   792 E2F6 20 44 E3				JSR	I2C_ACK		; send acknowlege
   793 E2F9 20 9F E3				JSR	I2C_RCV		; receive second data byte
   794 E2FC 85 F5				STA	XREG		; and store it
   795 E2FE 20 44 E3				JSR	I2C_ACK		; send acknowlege
   796 E301 20 9F E3				JSR	I2C_RCV		; receive third data byte
   797 E304 85 F3				STA	ACC		; and store it
   798 E306 20 53 E3				JSR	I2C_NACK	; no more data
   799 E309 20 35 E3				JSR	I2C_STOP	; stop communication
   800 E30C A5 F3				LDA	ACC		; load third data byte into A
   801 E30E A6 F5				LDX	XREG		; load second data byte into X
   802 E310 A4 F4				LDY	YREG		; load first data byte into Y
   803 E312 60					RTS
   804
   805 				; **** Set RTC Address Read/Write Pointer **************************************
   806
   807 				; Input: A - Register Address
   808
   809 				; ******************************************************************************
   810
   811 E313 48			SETRTCADR	PHA			; save register address onto stack
   812 E314 20 26 E3				JSR	I2C_START	; send start condition
   813 E317 A9 68				LDA	#I2C_RTC_ADR	; the I2C device address
   814 E319 20 66 E3				JSR	I2C_WRITE_DEV	; send device address and write bit
   815 E31C 68					PLA			; restore register address
   816 E31D 4C 67 E3				JMP	I2C_SEND	; send register address
   817
   818 				; ******************************************************************************
   819 				; START OF DATA INPUT/OUTPUT CODE
   820 				; ******************************************************************************
   821
   822 				; ******************************************************************************
   823 				; START OF VIA1 INPUT/OUTPUT CODE
   824 				; ******************************************************************************
   825
   826 				; **** Write To VIA1 Register **************************************************
   827
   828 				; Input:  Y - Destination Register index (VIA_PORTA,VIA_DDRA...)
   829 				;	  A - Data to be written into the Register
   830
   831 				; ******************************************************************************
   832
   833 E320 91 14		WRITE_VIA	STA	(IOBASE),Y
   834 E322 60					RTS
   835
   836 				; **** Read From VIA1 Register *************************************************
   837
   838 				; Input:  Y - Source Register index (VIA_PORTA,VIA_DDRA...)
   839 				; Output: A - Read Data from the Register
   840
   841 				; ******************************************************************************
   842
   843 E323 B1 14		READ_VIA	LDA	(IOBASE),Y
   844 E325 60					RTS
   845
   846
   847 				; ******************************************************************************
   848 				; START OF I2C CODE
   849 				; ******************************************************************************
   850
   851 				; **** Send I2C Start Condition ************************************************
   852
   853 				; ******************************************************************************
   854
   855 E326 A0 12		I2C_START	LDY	#DDRB
   856 E328 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   857 E32A 91 14				STA	(IOBASE),Y
   858 E32C A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   859 E32E 91 14				STA	(IOBASE),Y
   860 E330 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   861 E332 91 14				STA	(IOBASE),Y
   862 E334 60					RTS
   863
   864 				; **** Send I2C Stop Condition *************************************************
   865
   866 				; ******************************************************************************
   867
   868 E335 A0 12		I2C_STOP	LDY	#DDRB
   869 E337 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   870 E339 91 14				STA	(IOBASE),Y
   871 E33B A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   872 E33D 91 14				STA	(IOBASE),Y
   873 E33F A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   874 E341 91 14				STA	(IOBASE),Y
   875 E343 60					RTS
   876
   877 				; **** Send I2C Acknowledged ***************************************************
   878
   879 				; ******************************************************************************
   880
   881 E344 A0 12		I2C_ACK		LDY	#DDRB
   882 E346 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   883 E348 91 14				STA	(IOBASE),Y
   884 E34A A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   885 E34C 91 14				STA	(IOBASE),Y
   886 E34E A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   887 E350 91 14				STA	(IOBASE),Y
   888 E352 60					RTS
   889
   890 				; **** Send I2C Not Acknowledged ***********************************************
   891
   892 				; ******************************************************************************
   893
   894 E353 A0 12		I2C_NACK	LDY	#DDRB
   895 E355 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   896 E357 91 14				STA	(IOBASE),Y
   897 E359 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   898 E35B 91 14				STA	(IOBASE),Y
   899 E35D A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   900 E35F 91 14				STA	(IOBASE),Y
   901 E361 60					RTS
   902
   903 				; **** Read I2C Device *********************************************************
   904
   905 				; Input:  A - Device Address
   906 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   907
   908 				; ******************************************************************************
   909
   910 E362 38			I2C_READ_DEV	SEC			; set carry flag
   911 E363 2A					ROL			; shift device address one bit left and rotate C in LSB. LSB = 1 = read
   912 E364 D0 01				BNE	I2C_SEND	; and send it
   913
   914 				; **** Write I2C Device ********************************************************
   915
   916 				; Input:  A - Device Address
   917 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   918
   919 				; ******************************************************************************
   920
   921 E366 0A			I2C_WRITE_DEV	ASL			; shift device address one bit left. LSB is now 0 = write
   922 									; directly fallthrough to I2C_SEND
   923
   924 				; **** Send a Byte to I2C Device ***********************************************
   925
   926 				; Input:  A - Data Byte
   927 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   928
   929 				; ******************************************************************************
   930
   931 E367 85 E0		I2C_SEND	STA	I2C_DATA
   932 E369 A2 08				LDX	#$08		; send 8 bits
   933 E36B A0 12				LDY	#DDRB
   934 E36D 06 E0		SENDLOOP	ASL	I2C_DATA	; get next bit into C flag
   935 E36F B0 04				BCS	MSENDH		; is it a 1 bit?
   936 E371 A9 DF				LDA	#%11011111	; no, SDA = 0; SCL = 0
   937 E373 D0 02				BNE	SETBIT		; branch always
   938 E375 A9 5F		MSENDH		LDA	#%01011111	; yes, SDA = 1; SCL = 0
   939 E377 91 14		SETBIT		STA	(IOBASE),Y
   940 E379 29 FE				AND	#%11111110	; SDA = X; SCL = 1
   941 E37B 91 14				STA	(IOBASE),Y
   942 E37D 09 01				ORA	#%00000001	; SDA = X, SCL = 0
   943 E37F 91 14				STA	(IOBASE),Y
   944 E381 CA					DEX
   945 E382 D0 E9				BNE	SENDLOOP
   946
   947 E384 A0 12		I2C_ACK?	LDY	#DDRB
   948
   949 E386 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   950 E388 91 14				STA	(IOBASE),Y
   951
   952 E38A A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   953 E38C 91 14				STA	(IOBASE),Y
   954 E38E A0 10				LDY	#PORTB
   955 E390 B1 14				LDA	(IOBASE),Y	; get SDA
   956 E392 10 03				BPL	ISACK		; SDA = 1 ?
   957 E394 18					CLC			; no, not acknowledeged
   958 E395 90 01				BCC	CLKDOWN
   959 E397 38			ISACK		SEC			; yes, acknowledeged
   960 E398 A0 12		CLKDOWN		LDY	#DDRB
   961 E39A A9 5F				LDA	#%01011111	; SCL = 0
   962 E39C 91 14				STA	(IOBASE),Y
   963 E39E 60					RTS
   964
   965 				; **** Receive a Byte from I2C Device ******************************************
   966
   967 				; Output: A - Data Byte
   968
   969 				; ******************************************************************************
   970
   971 E39F A2 09		I2C_RCV		LDX	#$09
   972 E3A1 A0 12		RCVLOOP		LDY	#DDRB
   973 E3A3 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   974 E3A5 91 14				STA	(IOBASE),Y
   975 E3A7 CA					DEX
   976 E3A8 F0 0E				BEQ	RCVEND		; all eight bits received?
   977 E3AA A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   978 E3AC 91 14				STA	(IOBASE),Y
   979 E3AE A0 10				LDY	#PORTB
   980 E3B0 B1 14				LDA	(IOBASE),Y	; get SDA
   981 E3B2 0A					ASL			; and shift it into C
   982 E3B3 26 E0				ROL	I2C_DATA	; shift byte buffer one bit left. C goes into LSB
   983 E3B5 4C A1 E3				JMP	RCVLOOP
   984 E3B8 A5 E0		RCVEND		LDA	I2C_DATA	; load data into A
   985 E3BA 60					RTS
   986
   987 				; ******************************************************************************
   988 				; START OF SOUND GENERATOR CODE
   989 				; ******************************************************************************
   990
   991 				; **** Send A Command Byte To The Sound Chip ***********************************
   992
   993 				; Input: A - Data Byte
   994
   995 				; ******************************************************************************
   996
   997 E3BB 84 FD		SOUND_SENDBYTE	STY	YSAV		; save current Y register
   998 E3BD A0 11				LDY	#PORTA
   999 E3BF 91 14				STA	(IOBASE),Y	; set data
  1000 E3C1 A0 10				LDY	#PORTB
  1001 E3C3 A9 FD				LDA	#%11111101	; Set sound WE low
  1002 E3C5 25 E4				AND	VIA_STATUS
  1003 E3C7 91 14				STA	(IOBASE),Y	; enable sound data write
  1004 E3C9 A5 E4				LDA	VIA_STATUS	; set sound WE high
  1005 E3CB 91 14				STA	(IOBASE),Y	; disable sound data write
  1006 E3CD A4 FD				LDY	YSAV		; restore Y register
  1007 E3CF 60					RTS
  1008
  1009 				; **** Mute All Sound Chip Channels ********************************************
  1010
  1011 				; ******************************************************************************
  1012
  1013 E3D0 A0 03		SOUND_MUTEALL	LDY	#$03		; channels 0..3 to mute
  1014 E3D2 98			NEXTCHANNEL	TYA
  1015 E3D3 20 DA E3				JSR	SOUND_MUTE	; mute current channel
  1016 E3D6 88					DEY			; next channel
  1017 E3D7 10 F9				BPL	NEXTCHANNEL	; loop if not all four channels done
  1018 E3D9 60					RTS
  1019
  1020 				; **** Mute A Sound Chip Channel ***********************************************
  1021
  1022 				; Input: A - Channel # (0..3)
  1023
  1024 				; ******************************************************************************
  1025
  1026 E3DA A2 0F		SOUND_MUTE	LDX	#$0F		; set attenuation level to maximum
  1027 									; fall through to set attenuation level
  1028
  1029 				; **** Set Attenuation For A Sound Chip Channel ********************************
  1030
  1031 				; Input: A - Channel # (0..3)
  1032 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
  1033
  1034 				; ******************************************************************************
  1035
  1036 E3DC 86 FC		SOUND_SETATN	STX	TEMP		; store attenuation level in TEMP variable
  1037 E3DE 18					CLC			; clear carry flag
  1038 E3DF 6A					ROR			; and rotate channel number to bit 5 and 6
  1039 E3E0 6A					ROR	
  1040 E3E1 6A					ROR	
  1041 E3E2 6A					ROR	
  1042 E3E3 05 FC				ORA	TEMP		; combine channel number with attenuation value
  1043 E3E5 09 90				ORA	#$90		; and also set bit 7 and 4
  1044 E3E7 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1045
  1046 				; **** Set Periodic Noise ******************************************************
  1047
  1048 				; Input: X - Noise Shift Rate
  1049
  1050 				; ******************************************************************************
  1051
  1052 E3EA A9 00		SOUND_PNOISE	LDA	#$00
  1053 E3EC F0 04				BEQ	SET_NOISE
  1054
  1055 				; **** Set White Noise *********************************************************
  1056
  1057 				; Input: X - Noise Shift Rate
  1058
  1059 				; ******************************************************************************
  1060
  1061 E3EE A9 01		SOUND_WNOISE	LDA	#$01
  1062
  1063 				; **** Set Noise ***************************************************************
  1064
  1065 				; Input: A - 0 = Periodic Noise  1 = White Noise
  1066 				;	 X - Noise Shift Rate
  1067
  1068 				; ******************************************************************************
  1069
  1070 E3F0 0A			SOUND_SETNOISE	ASL	
  1071 E3F1 0A					ASL	
  1072 E3F2 86 FC		SET_NOISE	STX	TEMP
  1073 E3F4 05 FC				ORA	TEMP
  1074 E3F6 09 F0				ORA	#$F0
  1075 E3F8 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1076
  1077 				; **** Set Sound Frequency in HZ ***********************************************
  1078
  1079 				; Input: A - Channel (0..2)
  1080 				;	 X - Frequency Low Bits 7..0
  1081 				;	 Y - Frequency High Bits 9..8
  1082
  1083 				; *****************************************************************************
  1084
  1085 E3FB 18			SOUND_SETFREQ	CLC			; clear carry flag
  1086 E3FC 6A					ROR			; and rotate channel number to bit 5 and 6
  1087 E3FD 6A					ROR	
  1088 E3FE 6A					ROR	
  1089 E3FF 6A					ROR	
  1090 E400 09 80				ORA	#$80		; set high bit
  1091 E402 85 FC				STA	TEMP		; and store it in TEMP variable
  1092 E404 8A					TXA			; load frequency low bits into A
  1093 E405 29 0F				AND	#$0F		; we first want to send the lower 4 bits
  1094 E407 05 FC				ORA	TEMP		; combined it with the channel number
  1095 E409 20 BB E3				JSR	SOUND_SENDBYTE	; send complete first command byte to the sound chip
  1096 E40C 98					TYA			; load frequency high bits into A
  1097 E40D 86 FC				STX	TEMP		; store frequency low bits to TEMP variable
  1098 E40F A2 04				LDX	#$04		; we need four bits shifted
  1099 E411 06 FC		LOOP_NXT	ASL	TEMP		; shift highest bit of low frequency to Carry flag
  1100 E413 2A					ROL			; and shift it into the high frequency bits
  1101 E414 CA					DEX			; decrement counter
  1102 E415 D0 FA				BNE	LOOP_NXT	; do we need more shifts?
  1103 E417 4C BB E3				JMP	SOUND_SENDBYTE	; send complete second command byte to the sound chip
  1104
  1105 				; ******************************************************************************
  1106 				; ***************************** MAIN MONITOR ***********************************
  1107 				; ******************************************************************************
  1108
  1109 				; **** Auto Terminal And Baud Rate Detection Routine ***************************
  1110
  1111 				; ******************************************************************************
  1112
  1113 E41A A2 2D		INITVECT        LDX	#< NMI		; set NMI service routine
  1114 E41C A0 F3		                LDY	#> NMI
  1115 E41E 8E 7A 1A				STX	NMIVECT
  1116 E421 8C 7B 1A				STY	NMIVECT+1
  1117 E424 20 49 ED				JSR     SETIRQVECT      ; set IRQ service routine
  1118 E427 A2 18				LDX	#<  IRQ
  1119 E429 A0 F3				LDY	#> IRQ
  1120 E42B 20 49 ED				JSR	SETIRQVECT
  1121 E42E 8E 7C 1A				STX	IRQUSR
  1122 E431 8C 7D 1A				STY	IRQUSR+1
  1123 E434 A2 2F				LDX	#<  BREAK	; set BRK service routine
  1124 E436 A0 F3				LDY	#> BREAK
  1125 E438 8E 78 1A				STX	BRKUSR
  1126 E43B 8C 79 1A		                STY	BRKUSR+1
  1127 E43E 60			                RTS
  1128
  1129 E43F 78			MAINSTART       SEI			; disable Interrupts
  1130 E440 A2 FF		                LDX     #$FF
  1131 E442 9A					TXS			; initialize stack pointer
  1132 E443 D8					CLD			; set binary mode
  1133
  1134 E444 A9 4F		                LDA     #< _HANDLER_  ; low address to empty event handler (RTS)
  1135 E446 8D 24 1A		                STA     KEY_HANDLER     ; init character input handler low address
  1136 E449 8D 26 1A		                STA     NKEY_HANDLER    ; init no character input handler low address
  1137 E44C A9 F8		                LDA     #> _HANDLER_ ; high address to empty event handler (RTS)
  1138 E44E 8D 25 1A		                STA     KEY_HANDLER+1   ; init character input handler high address
  1139 E451 8D 27 1A		                STA     NKEY_HANDLER+1  ; init no character input handler high address
  1140
  1141 E454 20 1A E4		                JSR     INITVECT
  1142
  1143 E457 A2 03		INITRESET       LDX     #< MON_WARM_START
  1144 E459 A0 E0				LDY     #> MON_WARM_START
  1145 E45B 20 F1 EC				JSR	SET_RETURN_VECT		; set entry point for monitor warm start
  1146 E45E EA					NOP				; maintain compatibility with v1.1.4
  1147
  1148 E45F A9 80				LDA     #$80
  1149 E461 20 4D E1				JSR  	DELAY		; wait for ~128ms after reset
  1150 E464 20 6A EC				JSR	INITIO		; find and initialize IO cards
  1151 E467 20 4D E1		VTDETECT	JSR  	DELAY		; wait for ~128ms after reset
  1152 E46A 8D 01 16				STA  	STAT_REG   	; reset ACIA
  1153
  1154 				; ******************************************************************************
  1155 				; Set Fixed Baud Rate Patch
  1156 				; ******************************************************************************
  1157
  1158 E46D A9 3E				LDA	#$3E
  1159 E46F 8D 83 1A				STA	PBDD
  1160 E472 A9 06				LDA	#$06		; set keyboard decoder Q4 to low
  1161 E474 8D 82 1A				STA	PBD		; write value to RIOT port B
  1162 E477 AD F9 FF				LDA	$FFF9		; load standard baud rate value
  1163 E47A 85 E0				STA	BAUDRATE	; and store it in detected baud rate variable
  1164 E47C A9 0B				LDA  	#$0B       	; set ACIA to
  1165 E47E 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
  1166 E481 AD 82 1A				LDA	PBD		; read RIOT port B
  1167 E484 A2 0F				LDX	#$0F		; set all keyboard decoder outputs to high
  1168 E486 8E 82 1A				STX	PBD		; write value to RIOT port B
  1169 E489 6A					ROR			; rotate bit 0 into Carry
  1170 E48A 90 05				BCC	INIT		; if Carry = 0 then skip autodetection
  1171
  1172 				; ******************************************************************************
  1173
  1174 E48C A9 00				LDA	#CMD_INIT
  1175 E48E 20 B7 E0				JSR	CMDPRINT	; try to detect connected terminal
  1176
  1177 				; **** Main Initialization Routine *********************************************
  1178
  1179 				; ******************************************************************************
  1180
  1181 E491 20 67 E1		INIT            JSR     BEEP		; give some feedback
  1182 E494 A5 E0				LDA  	BAUDRATE   	; load selected baud rate
  1183 E496 D0 1A				BNE     SETBAUDRATE	; terminal detected or fixed baud rate?
  1184 E498 AD F9 FF				LDA	$FFF9		; no, load standard baud rate value
  1185 E49B 8D 03 16				STA  	CTRL_REG	; set baud rate
  1186 E49E A5 C9				LDA     DEVID
  1187 E4A0 C9 10				CMP     #TTY1_ID        ; is TTY still the standard output device?
  1188 E4A2 D0 03				BNE     SET_CRTDEV      ; no, CRT controller is installed. Continue initialization
  1189 E4A4 4C 55 E7				JMP  	JCRESET		; TTY ist still sdtoutdev, but not connected. Jump to junior monitor
  1190
  1191 E4A7 8D 75 1A		SET_CRTDEV      STA     STDOUTDEV       ; make CRT controller the standard output device
  1192 E4AA 20 18 E0		                JSR     SET_STDOUTID
  1193 E4AD A9 00		                LDA	#CMD_INIT
  1194 E4AF 20 B7 E0				JSR	CMDPRINT	; initialize standard output device
  1195
  1196 E4B2 8D 03 16		SETBAUDRATE     STA  	CTRL_REG	; set detected baud rate
  1197
  1198 E4B5 58					CLI			; enable interrupts
  1199
  1200 				; **** Main Program Loop *******************************************************
  1201
  1202 				; ******************************************************************************
  1203
  1204 E4B6 20 4D E0		MAIN		JSR	CGET		; clear input buffer
  1205 E4B9 20 40 E5				JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1206 E4BC A9 1F				LDA  	#$1F
  1207 E4BE 20 DE E0				JSR  	TAB		; send some space chars to center title
  1208 E4C1 A0 14		        	LDY  	#TITLE-STRINGP 	; load title string
  1209 E4C3 20 85 E0				JSR  	WRSTR		; and write it
  1210 E4C6 20 16 F9				JSR     INIT_CFC	; init. CFC-driver
  1211
  1212 E4C9 A5 15		CHK_IO_CARD     LDA	IOBASEH		; language card available?
  1213 E4CB F0 21				BEQ	TRY_BOOT	; no, try to boot from CF-device
  1214 						
  1215 E4CD A0 57				LDY	#IOCARD-STRINGP ; load detect message
  1216 E4CF 20 85 E0				JSR	WRSTR		; and write it
  1217 E4D2 A5 15				LDA	IOBASEH
  1218 E4D4 20 91 E0				JSR	HEXOUT
  1219 E4D7 A9 00				LDA	#$00
  1220 E4D9 20 91 E0				JSR	HEXOUT
  1221 E4DC AD 74 1A				LDA	STDINDEV
  1222 E4DF C9 13				CMP	#KEYBD1_ID	; is ASCII keyboard the standard input device?
  1223 E4E1 D0 08				BNE	SHOW_CLOCK 	; no, show clock
  1224 						
  1225 E4E3 A0 6E				LDY	#KBDSTR-STRINGP	; yes, load detect message
  1226 E4E5 20 85 E0				JSR	WRSTR		; and write it
  1227 E4E8 20 10 F4				JSR	SETPPORTIN
  1228 E4EB 20 34 EB		SHOW_CLOCK	JSR	CLOCKSTART	; call clock
  1229
  1230 E4EE 20 B8 F6		TRY_BOOT        JSR     SYS_BOOT        ; try to boot from CF or SD device
  1231 E4F1 90 03		                BCC     NO_BOOT_DEV     ; no boot device found, show menu
  1232 						
  1233 E4F3 4C 00 06		                JMP     BLOCK_BUF       ; jump to boot code in Volume-ID with C=1
  1234
  1235 E4F6 A5 15		NO_BOOT_DEV     LDA	IOBASEH		; language card available?
  1236 E4F8 F0 43				BEQ	SHOWMON		; no, just start monitor
  1237
  1238 E4FA A9 00				LDA	#$00
  1239 E4FC A0 1B		                LDY	#ACR		; select auxilary control register
  1240 E4FE 91 14				STA	(IOBASE),Y	; disable shift operation
  1241 E500 20 43 E5		                JSR     LOADSTRING
  1242 E503 A0 89				LDY	#SPACE-STRINGP
  1243 E505 20 85 E0				JSR	WRSTR		; write spacer lines
  1244 E508 A9 1E				LDA	#$1E		; send some space chars to center menu
  1245 E50A 20 DE E0				JSR  	TAB
  1246 E50D A0 8E				LDY	#MENU-STRINGP   ; load menu string
  1247 E50F 20 85 E0				JSR	WRSTR		; and write it
  1248 E512 A2 F1				LDX	#< LANGNAME	; load language name
  1249 E514 A0 DF				LDY	#> LANGNAME
  1250 E516 20 82 F6				JSR	SPRINT		; and write it
  1251 E519 A9 20				LDA	#SPC
  1252 E51B 20 52 E0				JSR	COUT
  1253 E51E A9 3F				LDA	#'?'
  1254 E520 20 52 E0				JSR	COUT
  1255 E523 20 47 E0		MLOOP		JSR  	CIN		; main menu loop
  1256 E526 29 DF		        	AND  	#$DF		; convert the input to uppercase char
  1257 E528 C9 4D		        	CMP  	#'M'		; (M)onitor choosen?
  1258 E52A D0 03				BNE	MNEXT1
  1259
  1260 E52C 4C 33 E6		STARTMON	JMP  	MONITOR		; yes, start monitor
  1261 E52F CD F0 DF		MNEXT1		CMP	LANGKEY		; compare with language key char
  1262 E532 D0 06				BNE	MNEXT
  1263
  1264 E534 20 B5 E0				JSR  	CLRSCRN    	; clear screen
  1265 E537 4C 00 B0				JMP	$B000		; jump to language start
  1266 E53A 4C 23 E5		MNEXT		JMP  	MLOOP		; no valid input choosen, try again
  1267 E53D 4C 3B E6		SHOWMON		JMP	MONRESET
  1268
  1269 				; Load String Pointer **********************************************************
  1270
  1271 E540 20 B5 E0		CLRLOADSTR      JSR     CLRSCRN
  1272 E543 A9 72		LOADSTRING	LDA  	#< STRINGP 	; load string pointer 1
  1273 E545 85 EA				STA  	PSTRL
  1274 E547 A9 E7				LDA  	#> STRINGP
  1275 E549 85 EB				STA  	PSTRH
  1276 E54B 60					RTS
  1277 						
  1278 E54C A9 62		LOADSTRING2	LDA  	#< STRINGP2 	; load string pointer 2
  1279 E54E 85 EA				STA  	PSTRL
  1280 E550 A9 E8				LDA  	#> STRINGP2
  1281 E552 85 EB				STA  	PSTRH
  1282 E554 60					RTS
  1283
  1284 E555 A9 10		WRITE_IO_INFO   LDA     #$10
  1285 E557 8D 00 1A				STA     IO_INFO
  1286 E55A A5 17		CHK_IO_0	LDA     FGCBASEH        ; controller card 0 available?
  1287 E55C F0 06				BEQ     CHK_IO_1        ; no, check next card
  1288 E55E 8D 01 1A				STA     IO_INFO+1
  1289 E561 20 6F E5				JSR     CALL_INFO
  1290 E564 A5 19		CHK_IO_1        LDA     CARD3BASEH      ; controller card 1 available?
  1291 E566 F0 06		                BEQ     IO_INFO_END     ; no, exit
  1292 						
  1293 E568 8D 01 1A		                STA     IO_INFO+1
  1294 E56B 20 6F E5				JSR     CALL_INFO
  1295 E56E 60			IO_INFO_END	RTS
  1296
  1297 E56F 6C 00 1A		CALL_INFO       JMP     (IO_INFO)
  1298
  1299 				; ******************************************************************************
  1300 				; MONITOR COMMAND EXECUTOR ROUTINES
  1301 				; ******************************************************************************
  1302
  1303 				; print command ****************************************************************
  1304
  1305 E572 84 FD		PRINTOUT	STY	YSAV		; save y register
  1306 E574 AD 76 1A				LDA	STDPRINTDEV	; get standard printer
  1307 E577 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1308 E57A A4 FD				LDY	YSAV		; restore y register
  1309 E57C C8					INY
  1310 E57D B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1311 E580 29 DF				AND  	#$DF		; uppercase chars only
  1312 E582 C9 44				CMP  	#'D'		; print mem dump?
  1313 E584 F0 06				BEQ	PRINTDUMP
  1314 E586 20 AC E8				JSR	DISASSEM
  1315 E589 4C 94 E5				JMP	ENDINP
  1316 E58C 20 C7 E6		PRINTDUMP	JSR	MEMDUMP		; print memory dump
  1317 E58F 90 03				BCC	ENDINP 		; normal termination?
  1318 E591 20 67 E1				JSR	BEEP		; no, ESC pressed. Beep
  1319 E594 20 5A E0		ENDINP		JSR	CROUT		; send CR/LF to print last line
  1320 E597 AD 75 1A				LDA	STDOUTDEV	; get standard output device
  1321 E59A 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1322 E59D 4C 3E E6				JMP	MONINP		; get next command line
  1323
  1324 				; XMODEM load/save command *****************************************************
  1325
  1326 E5A0 CA			XMODEM		DEX			; check read/write mode
  1327 E5A1 F0 09				BEQ	XMODEML		; read mode?
  1328 E5A3 A5 FF				LDA	MODE		; no, test if valid address mode
  1329 E5A5 F0 6A				BEQ	NOTVALID	; not valid, get next input
  1330 E5A7 20 06 F1				JSR	XModemSnd	; call xmodem send
  1331 E5AA F0 03				BEQ	XMODEME
  1332 E5AC 20 15 F0		XMODEML		JSR	XModemRcv	; yes, call xmodem receive
  1333 E5AF 4C 3E E6		XMODEME		JMP	MONINP		; get next command line
  1334
  1335 				; parallel load/save command ***************************************************
  1336
  1337 E5B2 CA			PARALLEL	DEX			; check read/write mode
  1338 E5B3 F0 0A				BEQ	PARALLELL	; read mode?
  1339 E5B5 A5 FF				LDA	MODE		; no, test if valid address mode
  1340 E5B7 F0 58				BEQ	NOTVALID	; not valid, get next input
  1341 E5B9 20 03 18				JSR	PPORTSAVE	; call save pport ### not implemented yet
  1342 E5BC 4C 3E E6				JMP	MONINP
  1343 E5BF 20 00 18		PARALLELL	JSR	PPORTLOAD	; call load pport ### not implemented yet
  1344 E5C2 4C 3E E6				JMP	MONINP		; get next command line
  1345
  1346 				; tape load/save command *******************************************************
  1347
  1348 E5C5 C8			TAPE		INY
  1349 E5C6 CA					DEX			; check read/write mode
  1350 E5C7 F0 08				BEQ	TAPEL		; read mode?
  1351 E5C9 A5 FF				LDA	MODE		; no, test if valid address mode
  1352 E5CB F0 44				BEQ	NOTVALID	; not valid, get next input
  1353 E5CD A9 21				LDA	#CMD_SAVE	; set save to tape command
  1354 E5CF D0 02				BNE	OPENTAPE
  1355 E5D1 A9 20		TAPEL		LDA	#CMD_LOAD	; set load from tape command
  1356 E5D3 48			OPENTAPE	PHA			; save command to stack
  1357 E5D4 A9 21				LDA	#TAPE1_ID	; open tape1 device
  1358 E5D6 84 FD				STY	YSAV		; save y register
  1359 E5D8 20 BE F7				JSR	DEV_OPEN	; open tape device
  1360 E5DB A4 FD				LDY	YSAV		; restore y register
  1361 E5DD 20 19 E1				JSR	STRINPUT	; check for filename
  1362 E5E0 68					PLA			; restore command
  1363 E5E1 20 BA E0				JSR	CMDDEV		; and send it to opened device
  1364 E5E4 4C 3E E6				JMP	MONINP		; get next command line
  1365
  1366 				; load/save command ************************************************************
  1367
  1368 E5E7 A5 FF		LOADSAVE	LDA	MODE		; check address mode
  1369 E5E9 0A					ASL	
  1370 E5EA 30 06				BMI	CHKNEXTCMD	; mode = $C0 (block mode)?
  1371 E5EC A9 FF				LDA	#$FF		; no, set end address to $ffff
  1372 E5EE 85 F8				STA	NUML
  1373 E5F0 85 F9				STA	NUMH
  1374 E5F2 C8			CHKNEXTCMD	INY
  1375 E5F3 B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1376 E5F6 29 DF				AND  	#$DF		; uppercase chars only
  1377 E5F8 C9 4D				CMP  	#'M'		; load/save via xmodem
  1378 E5FA F0 A4				BEQ  	XMODEM
  1379 E5FC C9 50				CMP  	#'P'		; load/save via parallel port
  1380 E5FE F0 B2				BEQ  	PARALLEL
  1381 E600 C9 54				CMP  	#'T'		; load/save via tape
  1382 E602 F0 C1				BEQ  	TAPE
  1383 E604 C9 30				CMP	#'0'
  1384 E606 B0 09				BCS	NOTVALID
  1385 E608 CA					DEX			; check load/save mode
  1386 E609 D0 06				BNE	NOTVALID	; if save mode, just get next input char
  1387 E60B 20 AC E8				JSR	DISASSEM	; last command was L, so call disassembler
  1388 E60E 4C 3E E6				JMP	MONINP		; we are finnished, get next input line
  1389 E611 A9 00		NOTVALID	LDA	#$00		; no valid command, so restore registers
  1390 E613 AA					TAX
  1391 E614 4C A1 E6				JMP  	SETMODE2   	; and get next input char
  1392
  1393 				; save command *****************************************************************
  1394
  1395 E617 E8			SAVE		INX
  1396
  1397 				; load command *****************************************************************
  1398
  1399 E618 E8			LOAD		INX
  1400 E619 4C E7 E5				JMP	LOADSAVE
  1401
  1402 				; print command ****************************************************************
  1403
  1404 E61C 4C 72 E5		PRINT		JMP	PRINTOUT
  1405
  1406 				; call a program ***************************************************************
  1407
  1408 E61F 20 36 E7		RUN		JSR	PRADDRESS
  1409 E622 A9 52				LDA	#'R'		; print R to signal run mode
  1410 E624 20 52 E0				JSR	COUT
  1411 E627 20 5A E0				JSR	CROUT
  1412 E62A 20 30 E6				JSR     EXECPROG
  1413 E62D 4C 3E E6				JMP  	MONINP		; jump back from program call
  1414 E630 6C FA 00		EXECPROG	JMP  	(ADRL)     	; jump to program address; execute program
  1415
  1416 				; **** Start Of Hex Monitor ****************************************************
  1417
  1418 				; ******************************************************************************
  1419 E633 20 40 E5		MONITOR 	JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1420 E636 A0 9A				LDY  	#MONSTR-STRINGP
  1421 E638 20 85 E0		        	JSR  	WRSTR		; show monitor title
  1422 E63B 20 10 F4		MONRESET	JSR	SETPPORTIN	; initialize RIOT
  1423 E63E 20 5A E0		MONINP		JSR  	CROUT
  1424 E641 A9 2A				LDA  	#PROMPT
  1425 E643 20 52 E0				JSR  	COUT		; show monitor prompt
  1426 E646 20 62 E0				JSR  	STRIN      	; read input string
  1427 E649 A0 00				LDY  	#$00       	; reset string index
  1428 E64B 98					TYA			; mode = 0 (none)
  1429
  1430 E64C AA			MONINIT		TAX
  1431 E64D 85 FF		SETADRMODE	STA  	MODE
  1432 E64F C8			SKIPCMDCHR      INY			; increment string index
  1433 E650 B9 00 14		NEXTCMDCHR	LDA  	STRBUF,Y   	; get next input char
  1434 E653 C9 0D				CMP  	#CR
  1435 E655 F0 52				BEQ  	ENDCMD 		; end of input line, return to reader routine
  1436 E657 C9 20				CMP  	#' '
  1437 E659 F0 F4				BEQ  	SKIPCMDCHR 	; ignore spaces
  1438 E65B C9 2E				CMP  	#'.'
  1439 E65D F0 46				BEQ  	SETBLKMODE 	; block mode
  1440 E65F C9 3A				CMP	#':'
  1441 E661 F0 EA				BEQ	SETADRMODE
  1442 E663 29 DF				AND  	#$DF		; uppercase chars only
  1443 E665 C9 4C				CMP  	#'L'		; LOAD/LIST command
  1444 E667 F0 AF				BEQ	LOAD 		; load or list data
  1445 E669 C9 53				CMP  	#'S'		; SAVE command
  1446 E66B F0 AA				BEQ	SAVE		; save data
  1447 E66D C9 50				CMP	#'P'		; PRINT command
  1448 E66F F0 AB				BEQ	PRINT		; print data
  1449 E671 C9 47				CMP  	#'G'		; GO command
  1450 E673 F0 AA				BEQ  	RUN		; call program
  1451 E675 C9 4D				CMP  	#'M'		; JUNIOR MONITOR command
  1452 E677 D0 03				BNE  	NEXTCMD
  1453 E679 4C 55 E7				JMP	JCRESET		; execute original junior computer monitor
  1454 E67C C9 51		NEXTCMD		CMP  	#'Q'		; QUIT command
  1455 E67E F0 30				BEQ  	MONEND		; exit monitor program
  1456 E680 A5 FF				LDA	MODE		; test if list command pending
  1457 E682 30 3C				BMI	DUMP		; if mode = $80, dump last line
  1458 E684 84 FD				STY  	YSAV		; save Y
  1459 E686 20 EA E0				JSR  	HEXINPUT   	; read hex number
  1460 E689 C4 FD			 	CPY  	YSAV		; min 1 hex digit entered?
  1461 E68B F0 C2				BEQ  	SKIPCMDCHR     	; no, read next command
  1462 E68D A5 FF				LDA  	MODE
  1463 E68F D0 0A				BNE	SETMODE
  1464 E691 A5 F8		STOREADR	LDA  	NUML       	; yes, copy input value to last address
  1465 E693 85 FA		                STA  	ADRL
  1466 E695 A5 F9		                LDA  	NUMH
  1467 E697 85 FB		                STA  	ADRH
  1468 E699 A9 00				LDA	#$00		; line list mode
  1469 E69B C9 3A		SETMODE		CMP	#':'		; is it store mode?
  1470 E69D F0 14				BEQ	STOREDATA	; yes, store data
  1471 E69F 09 80				ORA	#$80
  1472 E6A1 85 FF		SETMODE2	STA	MODE
  1473 E6A3 D0 AB				BNE	NEXTCMDCHR	; branch always
  1474 E6A5 A9 40		SETBLKMODE	LDA	#$40		; set block list mode
  1475 E6A7 D0 A4				BNE	SETADRMODE
  1476 E6A9 A5 FF		ENDCMD		LDA	MODE		; test if list command pending
  1477 E6AB 30 13				BMI	DUMP		; yes, dump last line
  1478 E6AD 4C 3E E6		CMDEND		JMP	MONINP		; read next command line
  1479 E6B0 6C 0A 18		MONEND		JMP     (RETURN_VECT)   ; return to monitor caller
  1480
  1481 				; store data *******************************************************************
  1482
  1483 E6B3 A5 F8		STOREDATA	LDA  	NUML       	; load lower byte of number
  1484 E6B5 81 FA		                STA  	(ADRL,X)   	; store current store address (X=0)
  1485 E6B7 E6 FA		                INC  	ADRL       	; increment lower store index.
  1486 E6B9 D0 02		                BNE  	NEXTITEM    	; no overflow
  1487 E6BB E6 FB		                INC  	ADRH       	; add carry to upper store index
  1488 E6BD 4C 50 E6		NEXTITEM        JMP  	NEXTCMDCHR    	; get next command string
  1489
  1490 				; call memory dump *************************************************************
  1491
  1492 E6C0 20 C7 E6		DUMP		JSR	MEMDUMP
  1493 E6C3 90 8B				BCC	NEXTCMDCHR   	; get next input
  1494 E6C5 B0 E6				BCS	CMDEND		; yes, stop printing memory dump
  1495
  1496 				; print memory dump ************************************************************
  1497
  1498 E6C7 A2 00		MEMDUMP		LDX	#$00
  1499 E6C9 86 FE				STX  	PDBCNT		; printed data byte count = 0
  1500 E6CB 20 5C E1				JSR	CHKESC		; ESC pressed?
  1501 E6CE 90 01				BCC	PRADR		; no, go on dumping
  1502 E6D0 60					RTS			; yes, exit leaving carry flag set
  1503 E6D1 20 36 E7		PRADR		JSR	PRADDRESS	; print current address
  1504
  1505 				; print current data byte ******************************************************
  1506
  1507 E6D4 20 5E E0		PRDATA		JSR  	SPCOUT		; print space
  1508 E6D7 A1 FA		                LDA  	(ADRL,X)   	; get data from address (X=0)
  1509 E6D9 20 91 E0		                JSR  	HEXOUT     	; print data in hex format
  1510 E6DC E6 FE				INC  	PDBCNT     	; increment data counter
  1511
  1512 				; examine next address *********************************************************
  1513
  1514 E6DE 20 4C E7		ADRNEXT		JSR	CMPADDR		; see if there's more to print
  1515 E6E1 B0 18		                BCS  	FINISHED?  	; no more data to output
  1516
  1517 E6E3 20 7F E9				JSR	INCADR          ; increment list index
  1518 E6E6 A5 FE		DIVCHK          LDA  	PDBCNT
  1519 E6E8 C9 08				CMP  	#$08
  1520 E6EA D0 03				BNE  	MOD16CHK	; do we need a divider?
  1521 E6EC 20 5E E0				JSR  	SPCOUT		; yes, print single SPC as block divider
  1522 E6EF A5 FA		MOD16CHK	LDA  	ADRL       	; if address MOD 16 = 0 start new line
  1523 E6F1 29 0F		                AND  	#$0F
  1524 E6F3 D0 DF				BNE  	PRDATA
  1525 E6F5 20 07 E7				JSR  	PRASCII
  1526 E6F8 4C C7 E6				JMP  	MEMDUMP		; print next line
  1527
  1528 				; check if line print completed ************************************************
  1529
  1530 E6FB A5 FF		FINISHED?	LDA  	MODE		; examine last mode
  1531 E6FD 86 FF				STX  	MODE       	; set mode 0
  1532 E6FF 0A					ASL			; mode = $D0?
  1533 E700 10 03				BPL  	ENDDUMP		; no, get next input
  1534 E702 20 07 E7				JSR  	PRASCII		; yes, we are not finished, print ASCII output for last address
  1535 E705 18			ENDDUMP		CLC			; normal exit, so clear carry flag
  1536 E706 60					RTS
  1537
  1538 				; print a column with ASCII representation of data *****************************
  1539
  1540 E707 84 FD		PRASCII         STY  	YSAV       	; store Y
  1541 E709 38					SEC			; no carry to subtract
  1542 E70A A9 34				LDA  	#52		; max tabs
  1543 E70C E5 FE				SBC  	PDBCNT		; calc tab count to print ASCII column
  1544 E70E E5 FE				SBC  	PDBCNT		; tab = 52-3*printed_data_bytes_count
  1545 E710 E5 FE				SBC  	PDBCNT
  1546 E712 A4 FE				LDY  	PDBCNT
  1547 E714 C0 09				CPY  	#9		; more than 8 bytes viewed?
  1548 E716 B0 02				BCS  	NOADJUST	; no
  1549 E718 69 01				ADC  	#1		; yes, adjust by one char for block divider
  1550 E71A 20 DE E0		NOADJUST	JSR  	TAB		; print tab spaces
  1551
  1552 E71D A0 00				LDY  	#$00
  1553 E71F B1 E6		NEXTASC		LDA  	(ASCL),Y   	; get data from address
  1554 E721 C9 7F				CMP	#$7F
  1555 E723 B0 04				BCS  	NOASC      	; char >= ASCII 127? yes, print '.'
  1556 E725 C9 20				CMP  	#' '
  1557 E727 B0 02				BCS  	ASCOUT		; printable character?
  1558 E729 A9 2E		NOASC		LDA  	#'.'       	; no, print '.'
  1559 E72B 20 52 E0		ASCOUT		JSR  	COUT
  1560 E72E C8					INY
  1561 E72F C4 FE				CPY  	PDBCNT
  1562 E731 D0 EC				BNE  	NEXTASC
  1563 E733 A4 FD				LDY  	YSAV       	; restore Y
  1564 E735 60					RTS
  1565
  1566 				; Prompt new line with current address *****************************************
  1567
  1568 				;*******************************************************************************
  1569
  1570 E736 20 5A E0		PRADDRESS	JSR  	CROUT
  1571 E739 A5 FB				LDA  	ADRH
  1572 E73B 85 E7		                STA  	ASCH		; store current print address high-order byte
  1573 E73D 20 91 E0				JSR  	HEXOUT		; print high-order byte of address
  1574 E740 A5 FA		                LDA  	ADRL
  1575 E742 85 E6				STA  	ASCL		; store current print address low-order byte
  1576 E744 20 91 E0		                JSR  	HEXOUT		; print low-order byte of address
  1577 E747 A9 2D				LDA  	#ADIV      	; print '-'
  1578 E749 4C 52 E0		                JMP  	COUT
  1579
  1580 				; Compare if start address ADR is greater end address NUM **********************
  1581
  1582 				;*******************************************************************************
  1583
  1584 E74C A5 FA		CMPADDR		LDA  	ADRL       	; see if there's more to print
  1585 E74E C5 F8		                CMP  	NUML
  1586 E750 A5 FB		                LDA  	ADRH
  1587 E752 E5 F9		                SBC  	NUMH
  1588 E754 60					RTS
  1589
  1590 				; Jump to original Junior Computer reset vector ********************************
  1591
  1592 				;*******************************************************************************
  1593 E755 A9 06		JCRESET		LDA	#$06			; set PB5 = L (WRITE)
  1594 E757 8D 82 1A				STA	PBD
  1595 E75A 78					SEI
  1596 E75B 20 1A E4				JSR     INITVECT
  1597 E75E 20 CC EF		                JSR     TAPEIRQ_OFF
  1598 E761 58					CLI
  1599 E762 4C 1D 1C				JMP	MONITOR_BLOCK.RESET	; jump to Junior Computer reset routine
  1600
  1601 				; ******************************************************************************
  1602 				; String Data Section
  1603 				; ******************************************************************************
  1604
  1605 E765 00 00 00 00		MAGIC0		.byte	$00,$00,$00,$00                 ; Removed by Emile
  1606 E769 18 90 00 90		MAGIC1          .byte   $18,$90,$00,$90                 ; clc bcc 00 bcc
  1607
  1608 E76D 50 53 41 59 58	PSSTR		.by	'PSAYX'				; processor status string
  1609
  1610 E772			STRINGP							; *** string base pointer ***
  1611 E772 32 4A 1B 5B		ESCCLS  	.byte   $32,$4A,$1B,$5B                 ; VT100 clear screen sequence
  1612 E776 48 00		ESCHOME        	.byte   $48,$00                 	; VT100 cursor home sequence
  1613 E778 32 4B 00		ESCCLL        	.byte   $32,$4B,$00         		; VT100 clear line sequence
  1614 E77B 30 63 00		ESCGID		.byte   $30,$63,$00	        	; VT100 get ID sequence
  1615 E77E 6D 00		ESCNORM		.byte   $6D,$00	        		; VT100 set normal text mode
  1616 E780 37 6D 00		ESCINV		.byte   $37,$6D,$00	        	; VT100 set inverse text mode
  1617 E783 35 6D 00		ESCBLNK		.byte   $35,$6D,$00	        	; VT100 set blinking text mode
  1618
  1619 E786 4A 75 6E 69 6F 72 + TITLE		.by   	'Junior Computer ][' CR,CR,CR
  1620 E79B 20 42 49 4F 53 20 + 		.by   	' BIOS Version '
  1621 E7A9 31 2E 32 2E 32 0D	        	.byte   VERMAIN,$2E,VERPSUB,$2E,VERSSUB,CR
  1622 E7AF 20 32 30 32 30 2F +         	.by   	' 2020/25 by Joerg Walke' CR CR $00
  1623 E7C9 20 49 4F 2F 4C 61 + IOCARD		.by	' IO/Language-Card at $' $00
  1624 E7E0 0D 20 41 53 43 49 + KBDSTR		.by	CR ' ASCII Keyboard connected' $00
  1625 E7FB 0D 0D 0D 0D 00	SPACE    	.byte  	CR, CR, CR, CR, $00
  1626 E800 28 4D 29 6F 6E 69 + MENU		.by   	'(M)onitor  ' $00
  1627 E80C 0D 48 65 78 20 4D + MONSTR		.by	CR 'Hex Monitor' CR $00
  1628
  1629 E81A 0D 0D 20 44 61 74 + DT_NOT_SET	.by	CR CR ' Date/Time not set' CR $00
  1630 E830 0D 20 44 61 74 65 + DATEINPUT	.by	CR ' Date: DD' DATEDIV 'MM' DATEDIV 'YY'
  1631 E840 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1632 E849 0D 20 54 69 6D 65 + TIMEINPUT	.by	CR ' Time: HH' TIMEDIV 'MM' TIMEDIV 'SS'
  1633 E859 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1634
  1635 E862			STRINGP2
  1636 E862 4D 6F 6E 00		DAYS		.by	'Mon' $00
  1637 E866 54 75 65 00				.by	'Tue' $00
  1638 E86A 57 65 64 00				.by	'Wed' $00
  1639 E86E 54 68 75 00				.by	'Thu' $00
  1640 E872 46 72 69 00				.by	'Fri' $00
  1641 E876 53 61 74 00				.by	'Sat' $00
  1642 E87A 53 75 6E 00				.by	'Sun' $00
  1643 E87E 4A 43 4F 53		OSID            .by    'JCOS'
  1644 E882 0D 20 42 6F 6F 74 + BOOTDEV         .by    CR ' Booting from ' $00
  1645 E892 0D 20 4E 6F 20 42 + NOBOOTDEV       .by    CR ' No Boot Disk ' $00
  1646 E8A2 43 46 43 31 00	CFCDEV          .by    'CFC1' $00
  1647 E8A7 53 44 43 31 00	SDCDEV          .by    'SDC1' $00
  1648
  1649 				; ******************************************************************************
  1650 				; START OF DISASSEMBLER
  1651 				; ******************************************************************************
  1652
  1653 E8AC A5 FF		DISASSEM	LDA	MODE
  1654 E8AE 0A					ASL	
  1655 E8AF 10 0E				BPL	SHOW1PAGE	; mode <> $C0 (block mode)?
  1656 E8B1 20 5C E1		NEXTLINE1	JSR     CHKESC          ; ESC pressed?
  1657 E8B4 B0 14				BCS	ENDDISASSEM	; yes, quit disassembling
  1658 E8B6 20 CB E8		NEXTOP		JSR	LOADOPCODE	; load current opcode
  1659 E8B9 20 4C E7		MORE?		JSR	CMPADDR		; see if there's more to print
  1660 E8BC 90 F3		                BCC  	NEXTLINE1  	; no more data to output
  1661 E8BE 60					RTS
  1662 E8BF A9 17		SHOW1PAGE	LDA	#23		; show 23 disassembled lines
  1663 E8C1 85 E1				STA	LINECNT
  1664 E8C3 20 CB E8		NEXTLINE2	JSR	LOADOPCODE	; load current opcode
  1665 E8C6 C6 E1				DEC	LINECNT
  1666 E8C8 D0 F9				BNE	NEXTLINE2	; more lines to show?
  1667 E8CA 60			ENDDISASSEM	RTS			; no, jump back to monitor
  1668
  1669 				; load next opcode
  1670
  1671 E8CB 20 36 E7		LOADOPCODE	JSR	PRADDRESS	; print current address
  1672 E8CE A0 00				LDY	#$00
  1673 E8D0 B1 FA				LDA	(ADRL),Y	; load opcode
  1674 E8D2 A8					TAY			; store opcode in Y
  1675 E8D3 29 03				AND	#$03
  1676 E8D5 C9 03				CMP	#$03		; is it a unused opcode?
  1677 E8D7 D0 05				BNE	DECODE  	; no, decode it
  1678 E8D9 A0 02				LDY	#$02		; Y points to unused opcode $02 to print '???'
  1679 E8DB 98					TYA			; and we also need it in A
  1680 E8DC D0 09				BNE	DECODEMNEM	; branch always
  1681
  1682 				; decode opcode index into compressed opcode instruction table
  1683
  1684 E8DE 98			DECODE		TYA			; reload opcode into A
  1685 E8DF 4A					LSR			; every fourth column in the opcode table is a (opcode) gap
  1686 E8E0 4A					LSR			; so we have to adjust the index because these columns are
  1687 									; stripped off in our indirect index table
  1688 E8E1 85 FC				STA	TEMP		; store number of bytes to subtract
  1689 E8E3 98					TYA			; reload opcode again
  1690 E8E4 38					SEC
  1691 E8E5 E5 FC				SBC	TEMP		; and subtract value in TEMP from the original opcode.
  1692 E8E7 84 E0		DECODEMNEM	STY	OPCODE		; store opcode
  1693 E8E9 A8					TAY			; Y holds now the actual index to the stripped opcode table
  1694 E8EA B9 74 EA				LDA	OPCODES,Y	; load packed mnemonic_index/instr._bytes from opcode table
  1695 E8ED A8					TAY			; and save to Y
  1696 E8EE 29 03				AND	#$03		; the lower two bits are the number of instruction bytes
  1697 E8F0 85 E3				STA	IBYTES		; store it in IBYTES var
  1698 E8F2 98					TYA			; reload packed index
  1699 E8F3 4A					LSR			; and strip the lower two bits off
  1700 E8F4 4A					LSR	
  1701 E8F5 A8					TAY			; Y holds now the index to the mnemonics table
  1702 E8F6 B9 3B EA				LDA   	MNEMONICSH,Y    ; load first packed byte of mnemonic string
  1703 E8F9 85 E7				STA   	ASCH            ; and store it as left byte of mnemonic
  1704 E8FB B9 02 EA				LDA   	MNEMONICSL,Y    ; load second packed byte of mnemonic string
  1705 E8FE 85 E6				STA   	ASCL            ; and store it as right byte of mnemonic
  1706 E900 20 AB E9				JSR	SHOWHEX		; first print out all instruction bytes as hex numbers
  1707 E903 A2 03				LDX   	#$03		; we have to unpack three chars
  1708 E905 A9 00		NEXTMCHR        LDA   	#$00		; clear A
  1709 E907 A0 05				LDY   	#$05            ; shift 5 bits into A
  1710 E909 06 E6		NEXTSHIFT       ASL   	ASCL           	; MSBit of ASCL in C
  1711 E90B 26 E7				ROL   	ASCH		; C in LSBit of ASCH and MSBit of ASCH in C
  1712 E90D 2A					ROL   			; C in A
  1713 E90E 88					DEY
  1714 E90F D0 F8				BNE   	NEXTSHIFT
  1715 E911 69 3F				ADC   	#'?'		; add offset to result, to make it an ASCII char
  1716 E913 20 52 E0				JSR     COUT		; print one character of mnemonic
  1717 E916 CA					DEX
  1718 E917 D0 EC				BNE     NEXTMCHR	; more chars to decode?
  1719 E919 A9 02				LDA	#$02		; print two space chars
  1720 E91B 20 DE E0				JSR	TAB
  1721
  1722 				; decode address mode and print left part of mode string ('#', '(' or 'A')
  1723
  1724 E91E A2 A0				LDX     #$A0            ; default address mode is implied
  1725 E920 A0 FF				LDY	#$FF
  1726 E922 C8			NEXTMASK	INY
  1727 E923 C0 0F				CPY	#$0F		; all masks tested?
  1728 E925 F0 0D				BEQ	ENDMASK		; yes, finish. Address mode is implied
  1729 E927 B9 C5 E9				LDA	ADRMODEM,Y	; load mask
  1730 E92A 25 E0				AND	OPCODE		; mask opcode
  1731 E92C D9 D4 E9				CMP	ADRMODEC,Y	; is it the mask result?
  1732 E92F D0 F1				BNE	NEXTMASK	; no, try next mask
  1733 E931 BE E3 E9				LDX	ADRMODER,Y	; yes, load the resulting address mode
  1734 E934 86 E2		ENDMASK		STX	ADRMODE		; save address mode
  1735 E936 8A					TXA			; address mode is in A
  1736 E937 29 0F				AND	#$0F		; A holds left mode string index
  1737 E939 A8					TAY
  1738 E93A B9 F2 E9				LDA	ADRMSTRL,Y      ; load left mode string
  1739 E93D F0 03				BEQ	PRINTVAL	; is it a NULL char? Then there is nothing to print
  1740 E93F 20 52 E0				JSR	COUT		; else print character
  1741
  1742 				; print either one or two operand value bytes
  1743
  1744 E942 20 7F E9		PRINTVAL	JSR	INCADR		; increment current address
  1745 E945 A6 E3				LDX	IBYTES		; load number of instruction bytes
  1746 E947 CA					DEX			; more than one IBs?
  1747 E948 F0 3B				BEQ	ENDINC		; no, just finish
  1748 E94A A9 24				LDA	#'$'		; yes, print operant value
  1749 E94C 20 52 E0				JSR	COUT		; first print out '$' as hex number indicator
  1750 E94F A0 01				LDY	#$01
  1751 E951 CA					DEX			; more than two IBs?
  1752 E952 F0 05				BEQ	HEX1		; no, just print one byte
  1753 E954 B1 FA				LDA	(ADRL),Y	; load high byte
  1754 E956 20 91 E0				JSR	HEXOUT		; and print it as hex number
  1755 E959 88			HEX1		DEY
  1756 E95A B1 FA				LDA	(ADRL),Y	; load low byte
  1757 E95C A6 E2				LDX	ADRMODE
  1758 E95E E0 A4				CPX	#$A4		; is it a branch opcode?
  1759 E960 F0 24				BEQ	CALCADR		; yes, calculate branch destination address
  1760 E962 20 91 E0				JSR	HEXOUT		; no, print byte as hex number
  1761
  1762 				; print right part of mode string. (',X', ',Y', ',X)', '),Y' or ')' )
  1763
  1764 E965 8A					TXA			; load address mode in A
  1765 E966 4A					LSR			; upper nibble is index to right address mode string
  1766 E967 4A					LSR			; so we have to shift it right by four bits
  1767 E968 4A					LSR	
  1768 E969 4A					LSR	
  1769 E96A A8					TAY
  1770 E96B B9 F7 E9		NEXTAMCHR	LDA	ADRMSTRR,Y	; load one char of right mode string
  1771 E96E F0 06				BEQ     ENDMODE		; if a NULL char then we are finished
  1772 E970 20 52 E0				JSR	COUT		; else print char
  1773 E973 C8					INY
  1774 E974 D0 F5				BNE	NEXTAMCHR	; branch always
  1775
  1776 				; finish current instruction
  1777
  1778 E976 A5 E3		ENDMODE		LDA	IBYTES		; how many address increments left?
  1779 E978 C9 03				CMP	#$03
  1780 E97A D0 03				BNE	INCADR		; just one?
  1781 E97C 20 7F E9				JSR	INCADR		; no, two increments needed
  1782
  1783 				; increment current address
  1784
  1785 E97F E6 FA		INCADR  	INC  	ADRL    	; increment current address
  1786 E981 D0 02		        	BNE  	ENDINC  	; no carry!
  1787 E983 E6 FB		        	INC  	ADRH
  1788 E985 60			ENDINC		RTS			; end of disassembly
  1789
  1790 				; calculate destination address for branch instructions
  1791
  1792 E986 38			CALCADR		SEC
  1793 E987 A8					TAY			; transfer A to Y for sign test
  1794 E988 10 10				BPL	ADDOFS		; is the branch offset positiv?
  1795 E98A 49 FF				EOR	#$FF		; no, subtract offset from current address
  1796 E98C 85 E8				STA	STOL
  1797 E98E A5 FA				LDA	ADRL
  1798 E990 E5 E8				SBC	STOL		; subtract branch offset from LSB current address
  1799 E992 A8					TAY			; store low byte of address to Y
  1800 E993 A5 FB				LDA	ADRH
  1801 E995 E9 00				SBC	#$00		; substract carry from MSB of address
  1802 E997 4C A1 E9				JMP	PRINTOFFS
  1803 E99A 65 FA		ADDOFS		ADC	ADRL		; add branch offset to LSB of current address
  1804 E99C A8					TAY			; store low byte of address to Y
  1805 E99D A5 FB				LDA	ADRH
  1806 E99F 69 00				ADC	#$00		; add carry to MSB of address
  1807 E9A1 20 91 E0		PRINTOFFS	JSR	HEXOUT		; print high byte of branch address
  1808 E9A4 98					TYA
  1809 E9A5 20 91 E0				JSR	HEXOUT		; print low byte of branch address
  1810 E9A8 4C 7F E9				JMP	INCADR		; and increment current address by one
  1811
  1812 				; show instruction bytes as hex values and trailing variable number of space chars
  1813
  1814 E9AB A0 00		SHOWHEX		LDY	#$00
  1815 E9AD 20 5E E0		NEXTBYTE	JSR	SPCOUT		; print leading space char
  1816 E9B0 B1 FA				LDA	(ADRL),Y	; load data byte
  1817 E9B2 20 91 E0				JSR	HEXOUT		; and print it
  1818 E9B5 C8					INY
  1819 E9B6 C4 E3				CPY	IBYTES		; all data bytes printed?
  1820 E9B8 D0 F3				BNE	NEXTBYTE	; no, print next byte
  1821 E9BA A9 0C				LDA	#$0C		; tab size is 12
  1822 E9BC 38					SEC
  1823 E9BD E9 03		CALCTAB		SBC	#$03		; reduce tab space by 3 for every data byte
  1824 E9BF 88					DEY
  1825 E9C0 D0 FB				BNE	CALCTAB		; all data bytes considered?
  1826 E9C2 4C DE E0				JMP	TAB
  1827
  1828 				; Address Mode Decode Tables ***************************************************
  1829
  1830 				; Mask, Mask Result and Mode tables. If Opcode and Mask = Mask Result then Mode
  1831 				; each Mode holds two indices (4 bits R | 4 bits L) to the mode string parts
  1832
  1833 				; ******************************************************************************
  1834
  1835 E9C5 FF FF FF 1F 1F 1F + ADRMODEM	.byte	$FF,$FF,$FF,$1F,$1F,$1F,$1F,$1F,$9F,$9F,$1C,$1C,$DF,$1C,$1C ; mask bits
  1836
  1837 E9D4 6C A2 BE 01 09 10 + ADRMODEC	.byte	$6C,$A2,$BE,$01,$09,$10,$11,$19,$0A,$80,$04,$0C,$96,$14,$1C ; mask result bits
  1838
  1839 E9E3 52 A1 80 32 A1 A4 + ADRMODER	.byte	$52,$A1,$80,$32,$A1,$A4,$72,$80,$A3,$A1,$A0,$A0,$80,$00,$00 ; packed mode bits
  1840
  1841 				; Address Mode Strings *********************************************************
  1842
  1843 E9F2 00 23 28 41 00	ADRMSTRL	.byte	$00,$23,$28,$41,$00
  1844 						;	 0   #   (   A   0
  1845
  1846 E9F7 2C 58 00 2C 58 29 + ADRMSTRR	.byte	$2C,$58,$00,$2C,$58,$29,$00,$29,$2C,$59,$00
  1847 						;	 ,   X   0   ,   X   )   0   )   ,   Y   0
  1848
  1849 				; Mnemonics Table **************************************************************
  1850
  1851 				; three characters packed in two bytes. Each character uses 5 bits, last bit is
  1852 				; unused
  1853
  1854 				; ******************************************************************************
  1855
  1856 				; low bytes of table
  1857
  1858 EA02 48 CA 1A 08 28 A4 + MNEMONICSL	.byte	$48, $CA, $1A, $08, $28, $A4, $AA, $94
  1859 EA0A CC 5A D8 C8 E8 48 +      		.byte	$CC, $5A, $D8, $C8, $E8, $48, $4A, $54
  1860 EA12 6E A2 72 74 88 B2 +      		.byte	$6E, $A2, $72, $74, $88, $B2, $B4, $26
  1861 EA1A C8 F2 F4 A2 26 44 +      		.byte	$C8, $F2, $F4, $A2, $26, $44, $72, $74
  1862 EA22 26 22 C4 44 62 44 +      		.byte	$26, $22, $C4, $44, $62, $44, $62, $1A
  1863 EA2A 26 54 68 C8 88 8A +      		.byte	$26, $54, $68, $C8, $88, $8A, $94, $44
  1864 EA32 72 74 B2 B4 32 44 +      		.byte	$72, $74, $B2, $B4, $32, $44, $68, $84, $00
  1865
  1866 				; high bytes of table
  1867
  1868 EA3B 11 13 15 19 19 19 + MNEMONICSH	.byte	$11, $13, $15, $19, $19, $19, $1A, $1B
  1869 EA43 1B 1C 1C 1D 1D 23 +      		.byte	$1B, $1C, $1C, $1D, $1D, $23, $23, $23
  1870 EA4B 23 23 24 24 29 29 +      		.byte	$23, $23, $24, $24, $29, $29, $29, $34
  1871 EA53 53 53 53 5B 5D 69 +      		.byte	$53, $53, $53, $5B, $5D, $69, $69, $69
  1872 EA5B 6D 7C 84 8A 8A 8B +      		.byte	$6D, $7C, $84, $8A, $8A, $8B, $8B, $9C
  1873 EA63 9C 9D 9D A0 A1 A1 +      		.byte	$9C, $9D, $9D, $A0, $A1, $A1, $A1, $A5
  1874 EA6B A5 A5 A8 A8 AD AE +      		.byte	$A5, $A5, $A8, $A8, $AD, $AE, $AE, $AE, $00
  1875
  1876 				; Compressed Opcode Table ******************************************************
  1877
  1878 				; each byte holds a 6 bit index to the mnemonic table and 2 bits instruction
  1879 				; byte count
  1880 				; empty opcode table columns (3,7,B,F) are stripped out
  1881
  1882 				; ******************************************************************************
  1883
  1884 EA74 29 8A E1 E1 8A 0A + OPCODES         .byte	$29, $8A, $E1, $E1, $8A, $0A, $91, $8A, $09, $E1, $8B, $0B
  1885 EA80 26 8A E1 E1 8A 0A +      		.byte	$26, $8A, $E1, $E1, $8A, $0A, $35, $8B, $E1, $E1, $8B, $0B
  1886 EA8C 73 06 E1 1A 06 9E +      		.byte	$73, $06, $E1, $1A, $06, $9E, $99, $06, $9D, $1B, $07, $9F
  1887 EA98 1E 06 E1 E1 06 9E +      		.byte	$1E, $06, $E1, $E1, $06, $9E, $B1, $07, $E1, $E1, $07, $9F
  1888 EAA4 A5 5E E1 E1 5E 82 +      		.byte	$A5, $5E, $E1, $E1, $5E, $82, $8D, $5E, $81, $6F, $5F, $83
  1889 EAB0 2E 5E E1 E1 5E 82 +      		.byte	$2E, $5E, $E1, $E1, $5E, $82, $3D, $5F, $E1, $E1, $5F, $83
  1890 EABC A9 02 E1 E1 02 A2 +      		.byte	$A9, $02, $E1, $E1, $02, $A2, $95, $02, $A1, $6F, $03, $A3
  1891 EAC8 32 02 E1 E1 02 A2 +      		.byte	$32, $02, $E1, $E1, $02, $A2, $B9, $03, $E1, $E1, $03, $A3
  1892 EAD4 E1 BE E1 C6 BE C2 +      		.byte	$E1, $BE, $E1, $C6, $BE, $C2, $59, $E1, $D5, $C7, $BF, $C3
  1893 EAE0 0E BE E1 C6 BE C2 +      		.byte	$0E, $BE, $E1, $C6, $BE, $C2, $DD, $BF, $D9, $E1, $BF, $E1
  1894 EAEC 7E 76 7A 7E 76 7A +      		.byte	$7E, $76, $7A, $7E, $76, $7A, $CD, $76, $C9, $7F, $77, $7B
  1895 EAF8 12 76 E1 7E 76 7A +      		.byte	$12, $76, $E1, $7E, $76, $7A, $41, $77, $D1, $7F, $77, $7B
  1896 EB04 4E 46 E1 4E 46 52 +      		.byte	$4E, $46, $E1, $4E, $46, $52, $69, $46, $55, $4F, $47, $53
  1897 EB10 22 46 E1 E1 46 52 +      		.byte	$22, $46, $E1, $E1, $46, $52, $39, $47, $E1, $E1, $47, $53
  1898 EB1C 4A AE E1 4A AE 62 +      		.byte	$4A, $AE, $E1, $4A, $AE, $62, $65, $AE, $85, $4B, $AF, $63
  1899 EB28 16 AE E1 E1 AE 62 +      		.byte	$16, $AE, $E1, $E1, $AE, $62, $B5, $AF, $E1, $E1, $AF, $63
  1900
  1901 				; ******************************************************************************
  1902 				; START OF HIGH LEVEL REAL TIME CLOCK CODE
  1903 				; ******************************************************************************
  1904
  1905 				; **** Check If Date/Time Is Set And Show Date/Time ****************************
  1906
  1907 EB34 20 43 EB		CLOCKSTART	JSR	CHECKDATETIME
  1908 EB37 20 5A E0				JSR	CROUT
  1909 EB3A 20 5A E0				JSR	CROUT
  1910 EB3D 20 5E E0				JSR	SPCOUT
  1911 EB40 4C F9 EB				JMP	PRINTDATETIME
  1912
  1913 				; **** Check If Date/Time Is Set ***********************************************
  1914
  1915 				; ******************************************************************************
  1916
  1917 EB43 A9 08		CHECKDATETIME	LDA	#$08
  1918 EB45 20 E6 E2				JSR	READCLOCK
  1919 EB48 C0 65				CPY	#$65
  1920 EB4A D0 05				BNE	DATETIMELOST
  1921 EB4C E0 02				CPX	#$02
  1922 EB4E D0 01				BNE	DATETIMELOST
  1923 EB50 60					RTS
  1924
  1925 EB51 20 43 E5		DATETIMELOST	JSR	LOADSTRING
  1926 EB54 A0 A8				LDY	#DT_NOT_SET-STRINGP
  1927 EB56 20 85 E0				JSR	WRSTR
  1928
  1929 EB59 20 86 EB		SETDATETIME	JSR	SETTIME
  1930
  1931 EB5C 20 43 E5		SETDATE		JSR	LOADSTRING
  1932 EB5F A9 2E				LDA	#'.'
  1933 EB61 85 F2				STA	DIVCHAR
  1934 EB63 A0 BE				LDY	#DATEINPUT-STRINGP
  1935 EB65 20 85 E0				JSR	WRSTR
  1936 EB68 A0 31				LDY	#$31
  1937 EB6A 20 B0 EB				JSR	GETDIGIT
  1938 EB6D 85 F4				STA	YREG
  1939 EB6F 20 49 EC				JSR	PRINTDIVCHAR
  1940 EB72 A0 12				LDY	#$12
  1941 EB74 20 B0 EB				JSR	GETDIGIT
  1942 EB77 85 F5				STA	XREG
  1943 EB79 20 49 EC				JSR	PRINTDIVCHAR
  1944 EB7C A0 99				LDY	#$99
  1945 EB7E 20 B0 EB				JSR	GETDIGIT
  1946 EB81 85 F3				STA	ACC
  1947 EB83 4C B7 E2				JMP	WRITEDATE2
  1948
  1949 EB86 20 43 E5		SETTIME		JSR	LOADSTRING
  1950 EB89 A9 3A				LDA	#':'
  1951 EB8B 85 F2				STA	DIVCHAR
  1952 EB8D A0 D7				LDY	#TIMEINPUT-STRINGP
  1953 EB8F 20 85 E0				JSR	WRSTR
  1954 EB92 A0 23				LDY	#$23
  1955 EB94 20 B0 EB				JSR	GETDIGIT
  1956 EB97 85 F3				STA	ACC
  1957 EB99 20 49 EC				JSR	PRINTDIVCHAR
  1958 EB9C A0 59				LDY	#$59
  1959 EB9E 20 B0 EB				JSR	GETDIGIT
  1960 EBA1 85 F5				STA	XREG
  1961 EBA3 20 49 EC				JSR	PRINTDIVCHAR
  1962 EBA6 A0 59				LDY	#$59
  1963 EBA8 20 B0 EB				JSR	GETDIGIT
  1964 EBAB 85 F4				STA	YREG
  1965 EBAD 4C 9F E2				JMP	WRITETIME2
  1966
  1967 EBB0 C8			GETDIGIT	INY
  1968 EBB1 84 FD				STY	YSAV
  1969 EBB3 20 EA EB		GETDIGIT1	JSR	NUMINPUT
  1970 EBB6 90 FB				BCC	GETDIGIT1
  1971 EBB8 AA					TAX
  1972 EBB9 E9 30				SBC	#48
  1973 EBBB 0A					ASL	
  1974 EBBC 0A					ASL	
  1975 EBBD 0A					ASL	
  1976 EBBE 0A					ASL	
  1977 EBBF C5 FD				CMP	YSAV
  1978 EBC1 B0 F0				BCS	GETDIGIT1
  1979 EBC3 85 FC				STA	TEMP
  1980 EBC5 8A					TXA
  1981 EBC6 20 52 E0				JSR	COUT
  1982 EBC9 20 EA EB		GETDIGIT2	JSR	NUMINPUT
  1983 EBCC 90 FB				BCC	GETDIGIT2
  1984 EBCE AA					TAX
  1985 EBCF E9 30				SBC	#48
  1986 EBD1 05 FC				ORA	TEMP
  1987 EBD3 C5 FD				CMP	YSAV
  1988 EBD5 B0 F2				BCS	GETDIGIT2
  1989 EBD7 85 FC				STA	TEMP
  1990 EBD9 A9 2E				LDA	#'.'
  1991 EBDB C5 F2				CMP	DIVCHAR
  1992 EBDD D0 04				BNE	GETDIGITEND
  1993 EBDF A5 FC				LDA	TEMP
  1994 EBE1 F0 E6				BEQ	GETDIGIT2
  1995 EBE3 8A			GETDIGITEND	TXA
  1996 EBE4 20 52 E0				JSR	COUT
  1997 EBE7 A5 FC				LDA	TEMP
  1998 EBE9 60					RTS
  1999
  2000
  2001 EBEA 20 47 E0		NUMINPUT	JSR	CIN
  2002 EBED C9 30				CMP	#'0'
  2003 EBEF 90 04				BCC	NOTNUM
  2004 EBF1 C9 3A				CMP	#':'
  2005 EBF3 90 02				BCC	ISNUM
  2006 EBF5 18			NOTNUM		CLC
  2007 EBF6 60					RTS
  2008 EBF7 38			ISNUM		SEC
  2009 EBF8 60					RTS
  2010
  2011 				; **** Print Date And Time *****************************************************
  2012
  2013 				; ******************************************************************************
  2014
  2015 EBF9 20 2B EC		PRINTDATETIME	JSR	PRINTDATE	; print current date	; PRINTFULLDATE
  2016 EBFC 20 5E E0				JSR	SPCOUT
  2017 EBFF 20 05 EC				JSR	PRINTTIME	; print current time
  2018 EC02 4C 5A E0				JMP	CROUT
  2019
  2020 				; **** Print Time **************************************************************
  2021
  2022 				; ******************************************************************************
  2023
  2024 EC05 A9 3A		PRINTTIME	LDA	#':'
  2025 EC07 85 F2				STA	DIVCHAR
  2026 EC09 20 DE E2				JSR	READTIME
  2027 EC0C 20 46 EC				JSR	PRINTDIGIT
  2028 EC0F 8A					TXA
  2029 EC10 20 46 EC				JSR	PRINTDIGIT
  2030 EC13 98					TYA
  2031 EC14 4C 91 E0				JMP	HEXOUT
  2032
  2033 				; **** Print Date And Day Of Week **********************************************
  2034
  2035 				; ******************************************************************************
  2036
  2037 EC17 20 92 E2		PRINTFULLDATE	JSR	READDOW
  2038 EC1A 0A					ASL	
  2039 EC1B 0A					ASL	
  2040 EC1C A8					TAY
  2041 EC1D A9 5E				LDA  	#< (DAYS-4)
  2042 EC1F 85 EA				STA  	PSTRL
  2043 EC21 A9 E8				LDA  	#> (DAYS-4)
  2044 EC23 85 EB				STA  	PSTRH
  2045 EC25 20 85 E0				JSR	WRSTR
  2046 EC28 20 5E E0				JSR	SPCOUT
  2047
  2048 				; **** Print Date **************************************************************
  2049
  2050 				; ******************************************************************************
  2051
  2052 EC2B A9 2E		PRINTDATE	LDA	#DATEDIV	; load divider char
  2053 EC2D 85 F2				STA	DIVCHAR
  2054 EC2F 20 E2 E2				JSR	READDATE	; read current date
  2055 EC32 85 FC				STA	TEMP		; store year value in TEMP
  2056 EC34 98					TYA
  2057 EC35 20 46 EC				JSR	PRINTDIGIT	; print day
  2058 EC38 8A					TXA
  2059 EC39 20 46 EC				JSR	PRINTDIGIT	; print month
  2060 EC3C A9 20				LDA	#CENTURY
  2061 EC3E 20 91 E0				JSR	HEXOUT		; print century
  2062 EC41 A5 FC				LDA	TEMP
  2063 EC43 4C 91 E0				JMP	HEXOUT		; print year
  2064
  2065 EC46 20 91 E0		PRINTDIGIT	JSR	HEXOUT		; print digit
  2066 EC49 A5 F2		PRINTDIVCHAR	LDA	DIVCHAR		; print divider char
  2067 EC4B 4C 52 E0				JMP	COUT
  2068
  2069 				; ******************************************************************************
  2070 				; START OF LOW LEVEL ROUTINES
  2071 				; ******************************************************************************
  2072
  2073 				; **** Print Processor Status **************************************************
  2074
  2075 				; ******************************************************************************
  2076
  2077 EC4E 20 36 E7		PRSTATUS	JSR	PRADDRESS	; print current program counter
  2078 EC51 A2 04				LDX	#$04
  2079 EC53 20 5E E0		NXTREG		JSR	SPCOUT		; print space char
  2080 EC56 BD 6D E7				LDA	PSSTR,X		; load register label
  2081 EC59 20 52 E0				JSR	COUT		; and print it
  2082 EC5C A9 3D				LDA	#'='
  2083 EC5E 20 52 E0				JSR	COUT		; print =
  2084 EC61 B5 F1				LDA	PREG,X
  2085 EC63 20 91 E0				JSR	HEXOUT
  2086 EC66 CA					DEX
  2087 EC67 10 EA				BPL	NXTREG
  2088 EC69 60					RTS
  2089
  2090 				; **** Initialize IO Devices ***************************************************
  2091
  2092 				; ******************************************************************************
  2093
  2094 EC6A A9 00		INITIO          LDA     #$00
  2095 EC6C A2 06		                LDX     #$06
  2096 EC6E 95 14		INITIO1         STA     IOBASE,X        ; clear K2,K3 and K4 base address pointers
  2097 EC70 CA			                DEX
  2098 EC71 D0 FB		                BNE     INITIO1
  2099
  2100 EC73 20 64 F7		                JSR     DEV_INIT        ; initialize driver list
  2101 EC76 A2 88		SET_TTY_DEV     LDX     #<  TTY_DEV
  2102 EC78 A0 F9		                LDY     #> TTY_DEV
  2103 EC7A 20 6F F7		                JSR     DEV_ADD         ; add terminal driver
  2104 EC7D 8D 74 1A				STA	STDINDEV        ; and initially set TTY as standard IO
  2105 EC80 8D 75 1A				STA	STDOUTDEV
  2106 EC83 85 C9				STA     DEVID
  2107
  2108 EC85 A2 A8		SET_XMODEM_DEV  LDX     #<  XMODEM_DEV
  2109 EC87 A0 F9		                LDY     #> XMODEM_DEV
  2110 EC89 20 6F F7		                JSR     DEV_ADD         ; add xmodem driver
  2111
  2112 EC8C A2 90		SET_PRINTER_DEV LDX     #<  PPRINT_DEV
  2113 EC8E A0 F9		                LDY     #> PPRINT_DEV
  2114 EC90 20 6F F7		                JSR     DEV_ADD         ; add parallel printer driver
  2115 EC93 8D 76 1A		                STA	STDPRINTDEV     ; and initially set parallel port printer as standard printer
  2116
  2117 EC96 20 A9 EC				JSR     DETECT_IO       ; detect IO cards
  2118
  2119 				; TEMP #### future: Set std beep only if no language card found
  2120
  2121 EC99 A9 6A		INIT_BEEP	LDA	#< DOBEEP	; load low byte of address of system beep
  2122 EC9B 8D 66 1A				STA	STDBEEP
  2123 EC9E A9 E1				LDA	#> DOBEEP	; load high byte of address of system beep
  2124 ECA0 8D 67 1A				STA	STDBEEP+1
  2125
  2126 ECA3 4C AD E1		                JMP     RESET_STDIO     ; reset to standard IO devices
  2127
  2128 ECA6 6C FA 00		IO_INITIALIZE   JMP     (ADRL)
  2129
  2130 				; **** Scan Bus And Detect IO Cards ********************************************
  2131 				;
  2132 				; ******************************************************************************
  2133
  2134 ECA9 A9 FB		DETECT_IO       LDA     #$FB
  2135 ECAB 85 FA		                STA     ADRL            ; set pointer to init routine
  2136 ECAD A9 07		                LDA     #$07
  2137 ECAF 85 FB		                STA     ADRH
  2138 ECB1 A9 03		                LDA     #$03            ; search on three slot base addresses
  2139 ECB3 85 FE		                STA     PDBCNT
  2140 ECB5 18			DETECT_LOOP     CLC
  2141 ECB6 A5 FB		                LDA     ADRH
  2142 ECB8 AA			                TAX
  2143 ECB9 E8			                INX                     ; X holds slot base address high byte
  2144 ECBA 69 04		                ADC     #$04
  2145 ECBC 85 FB		                STA     ADRH            ; set high byte to init routine
  2146 ECBE A0 03		                LDY	#$03            ; test byte string in card ROM against magic number
  2147 ECC0 B9 69 E7		COMP_LOOP	LDA	MAGIC1,Y        ; get one byte of magic number
  2148 ECC3 D1 FA				CMP	(ADRL),Y        ; and compare it with ROM content.
  2149 ECC5 D0 06				BNE	NO_MATCH        ; byte does not match, exit inner detection loop
  2150 ECC7 88					DEY                     ; byte matched magic number, try next one
  2151 ECC8 10 F6				BPL	COMP_LOOP       ; more bytes to compare?
  2152 ECCA 20 A6 EC				JSR     IO_INITIALIZE   ; IO card detected. Call init routine
  2153 ECCD C6 FE		NO_MATCH        DEC     PDBCNT
  2154 ECCF D0 E4		                BNE     DETECT_LOOP     ; try next card base address
  2155 				                                        ; fall through to IO/Language Card detection
  2156
  2157 				; **** Try To Detect IO/Language Card ******************************************
  2158 				;
  2159 				; ******************************************************************************
  2160
  2161 ECD1 A9 00		DETECT_IOL_CARD	LDA	#$00
  2162 ECD3 85 14				STA	IOBASEL		; set low byte of IO base pointer to $00
  2163 ECD5 A9 08				LDA	#$08		; try 1st IO-card at $0800
  2164 ECD7 85 15				STA	IOBASEH		; set high byte of IO base pointer to $00
  2165 						
  2166 ECD9 A0 12		DETECT_LP	LDY	#DDRB		; input & output regs are the same
  2167 ECDB 91 14				STA	(IOBASE),Y
  2168 ECDD 84 FA				STY	ADRL		; reset databus
  2169 ECDF D1 14				CMP	(IOBASE),Y	; Match only if 6522 VIA is present
  2170 ECE1 F0 1C				BEQ	STOREBASE	; branch if a card is found
  2171 						
  2172 ECE3 18					CLC
  2173 ECE4 69 04				ADC	#4		; next IO base-address
  2174 ECE6 85 15				STA	IOBASEH		; next card-address
  2175 ECE8 C9 14				CMP	#$14
  2176 ECEA 90 ED				BCC	DETECT_LP	; branch if MSB base-address < $14
  2177 						
  2178 ECEC A9 00				LDA	#0
  2179 ECEE 85 15				STA	IOBASEH		; 0 = no card found
  2180 ECF0 60			NOCARD          RTS                     ; no card found
  2181
  2182 				;----------------------------------------------------------------------------------		
  2183 				; This routine sets the return vector that is used by both Monitor and boot.sys.
  2184 				;----------------------------------------------------------------------------------		
  2185 ECF1 8E 0A 18		SET_RETURN_VECT	STX     RETURN_VECT     	; set entry point for monitor warm start
  2186 ECF4 8C 0B 18		                STY     RETURN_VECT+1
  2187 ECF7 60					RTS
  2188
  2189 ECF8					ORG	$ECFF		; maintain compatibility with v1.1.4
  2190 						
  2191 ECFF 85 15		STOREBASE	STA	IOBASEH		; card found, set high byte of base pointer.
  2192
  2193 				; **** Initialize The IO/Language Card *****************************************
  2194
  2195 				; ******************************************************************************
  2196
  2197 ED01 AD 74 1A		INIT_IOCARD     LDA     STDINDEV
  2198 ED04 C9 10		                CMP     #TTY1_ID
  2199 ED06 D0 03		                BNE     INIT_VIA        ; is standard input device still TTY?
  2200 ED08 20 BD F3		                JSR	DETECT_ASCIIKBD	; yes, check if ASCII keyboard available, else skip it
  2201 ED0B A0 10		INIT_VIA	LDY	#PORTB
  2202 ED0D A9 4E				LDA	#%01001110	; SDA=0,/CAS_MOT=1,CAS_SENSE=0,CAS_WR=0,/SPI_LOAD=1,SPI_CS=1,/SND_WE=1,SCL=0
  2203 ED0F 85 E4				STA	VIA_STATUS	; store current PortB output status
  2204 ED11 91 14				STA	(IOBASE),Y	; set SDA as input to pull it high, set SCL as input to pull it high
  2205 ED13 A0 12				LDY	#DDRB		; initialize data direction of port B
  2206 ED15 A9 5E				LDA	#%01011110	; SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
  2207 ED17 91 14				STA	(IOBASE),Y
  2208 ED19 A0 13				LDY	#DDRA		; initialize data direction of port A
  2209 ED1B A9 FF				LDA	#$FF		; all pins of port A are outputs
  2210 ED1D 91 14				STA	(IOBASE),Y
  2211 ED1F 20 D0 E3				JSR	SOUND_MUTEALL	; mute sound output
  2212 ED22 20 26 F4		INIT_SDCARD     JSR     SPI_INIT        ; initialize SPI
  2213 ED25 A2 B8		                LDX     #<  SDC_DEV
  2214 ED27 A0 F9		                LDY     #> SDC_DEV
  2215 ED29 20 6F F7		                JSR     DEV_ADD         ; add sd-card driver
  2216 ED2C A9 00		INIT_TAPE       LDA	#$00
  2217 ED2E A0 1B		                LDY	#ACR		; select auxilary control register
  2218 ED30 91 14				STA	(IOBASE),Y	; set one shot timer mode
  2219 ED32 85 E5		                STA	KEY_SENSE	; reset tape sense line status
  2220 ED34 A0 1C				LDY	#PCR		; select peripheral control register
  2221 ED36 91 14				STA	(IOBASE),Y	; set interrupt on falling edge of CA1
  2222 						;LDY	#IER		; select interrupt enable register
  2223 ED38 20 DF EF				JSR	TAPERW_OFF	; turn tape read/write mode off
  2224 ED3B 20 99 EF				JSR	RESET_TIMER2	; set Timer2 to 1/60 second
  2225 ED3E A2 B0		                LDX     #<  TAPE_DEV
  2226 ED40 A0 F9		                LDY     #> TAPE_DEV
  2227 ED42 20 6F F7		                JSR     DEV_ADD         ; add tape driver
  2228 ED45 A2 63				LDX	#<  TAPEIRQ 	; set low address of clock interrupt routine
  2229 ED47 A0 EF				LDY	#> TAPEIRQ   ; set low address of clock interrupt routine
  2230 ED49 8E 7E 1A		SETIRQVECT	STX	IRQVECT
  2231 ED4C 8C 7F 1A				STY	IRQVECT+1
  2232 ED4F 60					RTS
  2233
  2234 				; ******************************************************************************
  2235 				; START OF TAPE READ/WRITE ROUTINES
  2236 				; ******************************************************************************
  2237
  2238 ED50 4C ED ED		TAPEESC		JMP	BREAKSYNC
  2239
  2240 				; *** Tape Load Routine ********************************************************
  2241
  2242 				; ******************************************************************************
  2243
  2244 ED53 20 E7 EF		TAPELOAD	JSR	PREPFILENAME
  2245 ED56 20 81 F2				JSR	TAPE_PLAY_MSG	; print PLAY message
  2246 ED59 20 85 F2				JSR	TAPE_ESC_MSG
  2247 ED5C 20 5C E1		WAITPLAY	JSR	CHKESC		; <ESC> key pressed?
  2248 ED5F B0 EF				BCS	TAPEESC		; yes -> exit
  2249 ED61 A5 E5				LDA	KEY_SENSE	; check sense line status
  2250 ED63 D0 F7				BNE	WAITPLAY	; if <> 0, wait until datasette key pressed down
  2251 ED65 20 D7 EF				JSR	TAPERW_ON	; turn off key clock interrupt and turn on bit read interrupt
  2252 ED68 20 72 F2		STARTLOAD	JSR	TAPE_LOAD_MSG	; print LOAD message
  2253 ED6B 20 B6 EF				JSR	MOTOR_ON	; and turn motor on
  2254 ED6E A9 01		STARTSYNC	LDA	#$01		; we are in sync mode
  2255 ED70 85 ED				STA	BITCNT		; so initialize bit counter to just one bit
  2256 ED72 A0 10		WAITBIT		LDY	#PORTB		; set index to Port B
  2257 ED74 B1 14				LDA	(IOBASE),Y	; load port B
  2258 ED76 29 20				AND	#$20		; test tape sense line at PB5
  2259 ED78 D0 73				BNE	BREAKSYNC	; if sense line is high, PLAY key is no longer down -> exit.
  2260 ED7A A5 ED		READSYNC	LDA	BITCNT		; bit counter reached 0 ?
  2261 ED7C D0 F4				BNE	WAITBIT		; no, wait for more bits
  2262 ED7E A5 DD				LDA	OUTBYTE		; yes, load current byte into A
  2263 ED80 C9 2E				CMP	#SYNCMARK	; is it a valid sync mark?
  2264 ED82 D0 EA				BNE	STARTSYNC	; no, resync
  2265 ED84 A2 00				LDX	#$00
  2266 ED86 86 E3				STX	IBYTES		; yes, reset sync block counter
  2267 ED88 20 60 EE		GETBYTE?	JSR	BYTE_IN		; read next full byte
  2268 ED8B A5 DD				LDA	OUTBYTE		; and load it into A
  2269 ED8D C9 2E				CMP	#SYNCMARK	; still a sync mark?
  2270 ED8F D0 0B				BNE	SYNCEND?	; no, check if end of sync
  2271 ED91 E8					INX			; yes, increment sync mark counter
  2272 ED92 D0 F4				BNE	GETBYTE?	; 256 sync marks read? no read more
  2273 ED94 20 52 E0				JSR	COUT		; yes, print '.'
  2274 ED97 E6 E3				INC	IBYTES		; increment sync block counter
  2275 ED99 4C 88 ED				JMP	GETBYTE?	; and read next byte
  2276 ED9C A5 E3		SYNCEND?	LDA	IBYTES
  2277 ED9E F0 CE				BEQ	STARTSYNC	; at least one sync block read? no resync
  2278 EDA0 20 F9 ED				JSR	READHEADER	; yes, read header. C = 0 if no header mark is found. X returns 0
  2279 EDA3 90 C9				BCC	STARTSYNC	; no header mark found or names not equal. resync
  2280 EDA5 86 E2				STX	BLKNO		; BLKNO = 0
  2281 EDA7 86 DC				STX	CHECKSUM	; CHECKSUM = 0
  2282 EDA9 A5 DD		NEXTBLK		LDA	OUTBYTE		; load current block number into A
  2283 EDAB C5 E2				CMP	BLKNO		; is it the expected number?
  2284 EDAD D0 44				BNE	ERRLOAD		; no, error.
  2285 EDAF 20 60 EE		NEXTDATA	JSR	BYTE_IN		; yes, read next data byte
  2286 EDB2 A5 DD				LDA	OUTBYTE		; and load it into A
  2287 EDB4 A0 00				LDY	#$00
  2288 EDB6 91 FA				STA	(ADRL),Y	; store read data byte to destination address
  2289 EDB8 45 DC				EOR	CHECKSUM	; XOR it with checksum
  2290 EDBA 85 DC				STA	CHECKSUM	; and write result back to checksum
  2291 EDBC 20 4C E7				JSR	CMPADDR		; see if there's more to load
  2292 EDBF B0 17		                BCS  	ENDLDDATA  	; no, finish loading
  2293 EDC1 20 7F E9				JSR	INCADR		; yes, increment current destination address
  2294 EDC4 E8					INX
  2295 EDC5 D0 E8				BNE	NEXTDATA	; and read next byte
  2296 EDC7 20 60 EE				JSR	BYTE_IN		; read checksum
  2297 EDCA A5 DD				LDA	OUTBYTE		; and load it int A
  2298 EDCC C5 DC				CMP	CHECKSUM	; compare expected check sum with calculated checksum
  2299 EDCE D0 23				BNE	ERRLOAD		; if checksum incorrect, exit with error
  2300 EDD0 20 60 EE				JSR	BYTE_IN		; read next block number
  2301 EDD3 E6 E2				INC	BLKNO		; increment internal block counter
  2302 EDD5 4C A9 ED				JMP	NEXTBLK		; read next block
  2303 EDD8 20 60 EE		ENDLDDATA	JSR	BYTE_IN		; read last checksum
  2304 EDDB A5 DD				LDA	OUTBYTE		; and load it int A
  2305 EDDD C5 DC				CMP	CHECKSUM	; compare expected check sum with calculated checksum
  2306 EDDF D0 12				BNE	ERRLOAD		; if checksum incorrect, exit with error
  2307 EDE1 20 5F F2				JSR	TAPE_OK_MSG	; print OK message
  2308 EDE4 20 DF EF		ENDLOAD		JSR	TAPERW_OFF	; return to clock interrupt
  2309 EDE7 4C C1 EF				JMP	MOTOR_OFF	; and turn motor off
  2310
  2311 EDEA 68			BREAKREAD	PLA			; clean up stack
  2312 EDEB 68					PLA
  2313 EDEC 68					PLA
  2314 EDED 20 69 F2		BREAKSYNC	JSR	TAPE_BREAK_MSG	; print BREAK message
  2315 EDF0 4C E4 ED				JMP	ENDLOAD		; and exit
  2316
  2317 EDF3 20 64 F2		ERRLOAD		JSR	TAPE_ERR_MSG	; print error message
  2318 EDF6 4C E4 ED				JMP	ENDLOAD		; end exit
  2319
  2320 				; *** Read Tape Header Routine *************************************************
  2321
  2322 				; ******************************************************************************
  2323
  2324 EDF9 A5 DD		READHEADER	LDA	OUTBYTE		; load current byte
  2325 EDFB C9 A1				CMP	#ADDRMARK	; is it a address mark?
  2326 EDFD D0 5A				BNE	NOHDRMARK	; no, exit
  2327 EDFF A0 00				LDY	#$00		; set string counter to 0
  2328 EE01 84 E1				STY	EQUFLAG		; clear character compare flag
  2329 EE03 A2 06				LDX	#$06		; 6 bytes (start address, end address, reserved) to read
  2330 EE05 20 60 EE		READADDR	JSR	BYTE_IN		; read new address byte
  2331 EE08 A5 DD				LDA	OUTBYTE		; and load it into A
  2332 EE0A 95 F5				STA	NUML-3,X	; store it to pinter location
  2333 EE0C B9 FB F2				LDA	TAPEFND,Y	; load one char of "found" message
  2334 EE0F 20 52 E0				JSR	COUT		; and print it
  2335 EE12 C8					INY			; increment message pointer
  2336 EE13 CA					DEX			; decrement byte read counter
  2337 EE14 D0 EF				BNE	READADDR	; more address bytes to read?
  2338 EE16 20 60 EE				JSR	BYTE_IN		; read next byte
  2339 EE19 A5 DD				LDA	OUTBYTE		; and load it into A
  2340 EE1B C9 A0				CMP	#NAMEMARK	; is it a name mark?
  2341 EE1D D0 22				BNE	READFIRSTBYTE	; no, read first data byte
  2342 EE1F A0 00				LDY	#$00		; reset name string pointer
  2343 EE21 20 60 EE		READNAME	JSR	BYTE_IN		; read name char
  2344 EE24 A5 DD				LDA	OUTBYTE		; load it into A
  2345 EE26 85 E3				STA	IBYTES 		; and save value
  2346 EE28 C9 1F				CMP	#FILEMARK	; is it the file mark?
  2347 EE2A F0 15				BEQ	READFIRSTBYTE	; yes, read first data byte
  2348 EE2C 90 2D				BCC	MARKERROR 	; is character < spac char? yes show error
  2349 EE2E 20 52 E0				JSR	COUT		; no, print current name char
  2350 EE31 B9 00 15				LDA	RBUFF,Y		; load compare char
  2351 EE34 C9 2A				CMP	#'*'		; is it a '*'?
  2352 EE36 F0 E9				BEQ	READNAME	; yes, skip compare
  2353 EE38 C8					INY
  2354 EE39 45 E3				EOR	IBYTES		; is char of search name equal current name?
  2355 EE3B F0 E4				BEQ	READNAME	; yes, read next char
  2356 EE3D 85 E1				STA	EQUFLAG		; no, mark name as not equal
  2357 EE3F D0 E0				BNE	READNAME	; and read next char
  2358
  2359 EE41 A5 E1		READFIRSTBYTE	LDA	EQUFLAG		; is search name equal current name?
  2360 EE43 D0 11				BNE	NAMENEQ		; no, we need to skip the file
  2361 EE45 B9 00 15				LDA	RBUFF,Y
  2362 EE48 C9 2A				CMP	#'*'		; was last char in search name a '*'?
  2363 EE4A F0 05				BEQ	NAMEEQU		; yes, name is equal
  2364 EE4C B9 00 15				LDA	RBUFF,Y		; no, is search name length equal current name length?
  2365 EE4F D0 05				BNE	NAMENEQ		; no, we need to skip the file
  2366 EE51 20 60 EE		NAMEEQU		JSR	BYTE_IN		; yes, read first data Byte
  2367 EE54 38					SEC			; header OK, so set carry flag
  2368 EE55 60					RTS
  2369
  2370 EE56 20 76 F2		NAMENEQ		JSR	TAPE_SKIP_MSG	; print skip message
  2371 EE59 18			NOHDRMARK	CLC			; header not OK, so clear carry flag
  2372 EE5A 60					RTS
  2373
  2374 EE5B 68			MARKERROR	PLA			; clear return address
  2375 EE5C 68					PLA
  2376 EE5D 4C F3 ED				JMP	ERRLOAD		; and jump to error routine
  2377
  2378 				; *** Tape Byte Read Routine ***************************************************
  2379
  2380 				; ******************************************************************************
  2381
  2382 EE60 98			BYTE_IN		TYA			; save Y register
  2383 EE61 48					PHA
  2384 EE62 A0 10				LDY	#PORTB		; select port B register
  2385 EE64 B1 14		READBIT		LDA	(IOBASE),Y	; read port B Bits
  2386 EE66 29 20				AND	#$20		; test tape sense line at PB5
  2387 EE68 D0 80				BNE	BREAKREAD	; play key is no longer down, stop reading
  2388 EE6A A5 ED				LDA	BITCNT		; load bit counter
  2389 EE6C D0 F6				BNE	READBIT		; check again until bit counter = 0
  2390 EE6E A9 08				LDA	#$08
  2391 EE70 85 ED				STA	BITCNT		; reset bit counter
  2392 EE72 68			ENDBYTE_IN	PLA			; yes, restore Y register
  2393 EE73 A8					TAY
  2394 EE74 60					RTS
  2395
  2396 				; *** Tape Save Routine ********************************************************
  2397
  2398 				; ******************************************************************************
  2399
  2400 EE75 20 E7 EF		TAPESAVE	JSR	PREPFILENAME
  2401 EE78 20 7A F2				JSR	TAPE_REC_MSG	; Print press record message
  2402 EE7B 20 85 F2				JSR	TAPE_ESC_MSG
  2403 EE7E 20 5C E1		WAITRECORD	JSR	CHKESC		; <ESC> key pressed?
  2404 EE81 B0 64				BCS	BREAKSAVE	; yes -> exit
  2405 EE83 A5 E5				LDA	KEY_SENSE	; Check if any Datasette key is pressed
  2406 EE85 D0 F7				BNE	WAITRECORD	; No, repeat check
  2407 EE87 20 6E F2				JSR	TAPE_SAVE_MSG	; Print save message
  2408 EE8A 78					SEI			; Yes, disable interrupts
  2409 EE8B 20 83 E0				JSR	STROUT		; Print file name
  2410 EE8E A9 FF				LDA	#$FF
  2411 EE90 8D 94 1A				STA  	CNTA		; Initialize timer value
  2412 EE93 A9 06				LDA	#$06		; Write 6x256 Byte blocks of sync marks
  2413 EE95 20 ED EE				JSR	WRITESYNC	; Write sync marks
  2414 EE98 20 03 EF				JSR	WRITEHEADER	; Write tape header
  2415 EE9B A9 1F				LDA	#FILEMARK
  2416 EE9D 20 22 EF				JSR	BYTE_OUT	; Write file mark
  2417 EEA0 A9 00				LDA	#$00
  2418 EEA2 85 DC				STA	CHECKSUM	; Initialize XOR data checksum
  2419 EEA4 85 E2				STA	BLKNO		; Initialize block numbers
  2420 EEA6 AA					TAX			; Initialize Byte counter
  2421 EEA7 20 22 EF		NEXTBLOCK	JSR	BYTE_OUT	; Write block number to tape
  2422 EEAA A0 10		WRNXTBYTE	LDY	#PORTB
  2423 EEAC B1 14				LDA	(IOBASE),Y	; Read Port B
  2424 EEAE 29 20				AND	#$20		; Test tape sense line at PB5
  2425 EEB0 D0 35				BNE	BREAKSAVE	; No Datasette key pressed. Stop saving
  2426 EEB2 A0 00				LDY	#$00
  2427 EEB4 B1 FA				LDA	(ADRL),Y	; Load current data Byte
  2428 EEB6 A8					TAY			; Save data to Y register
  2429 EEB7 45 DC				EOR	CHECKSUM	; XOR data with checksum
  2430 EEB9 85 DC				STA	CHECKSUM
  2431 EEBB 98					TYA			; Reload data into Accumulator
  2432 EEBC 20 22 EF				JSR	BYTE_OUT	; Write data Byte to tape
  2433 EEBF 20 4C E7				JSR	CMPADDR		; See if there's more to copy
  2434 EEC2 B0 12		                BCS  	ENDDATA  	; No more data to copy
  2435 EEC4 20 7F E9				JSR	INCADR		; Increment current save address
  2436 EEC7 E8					INX			; Increment Byte counter
  2437 EEC8 D0 E0				BNE	WRNXTBYTE	; If less than 256 Bytes written, then write next data Byte
  2438 EECA A5 DC		ENDBLOCK	LDA	CHECKSUM	; Else...
  2439 EECC 20 22 EF				JSR	BYTE_OUT	; Write checksum at the end of block
  2440 EECF E6 E2				INC	BLKNO		; Increment block number
  2441 EED1 A5 E2				LDA	BLKNO
  2442 EED3 4C A7 EE				JMP	NEXTBLOCK	; Write next block
  2443 EED6 A5 DC		ENDDATA		LDA	CHECKSUM
  2444 EED8 20 22 EF				JSR	BYTE_OUT	; Write checksum at end of block
  2445 EEDB A9 03				LDA	#$03
  2446 EEDD 20 22 EF				JSR	BYTE_OUT	; Write End-Of-Text mark
  2447 EEE0 20 5F F2				JSR	TAPE_OK_MSG	; Print OK message
  2448 EEE3 58			ENDSAVE		CLI			; Reenable interrupts
  2449 EEE4 4C C1 EF				JMP	MOTOR_OFF	; Stop motor
  2450
  2451 				; ******************************************************************************
  2452
  2453 EEE7 20 69 F2		BREAKSAVE	JSR	TAPE_BREAK_MSG	; Print Break message
  2454 EEEA 4C E3 EE				JMP	ENDSAVE
  2455
  2456 				; **** Write Synchronization Bytes To Tape *************************************
  2457
  2458 				; ******************************************************************************
  2459
  2460 EEED 85 E9		WRITESYNC	STA	STOH
  2461 EEEF A9 00				LDA	#$00
  2462 EEF1 85 E8				STA	STOL
  2463 EEF3 A9 2E				LDA	#SYNCMARK	; Load sync mark
  2464 EEF5 85 DD				STA	OUTBYTE		; and store it to output variable
  2465 EEF7 20 24 EF		PLOOP		JSR	WRITEBYTE	; Write sync mark
  2466 EEFA C6 E8				DEC	STOL		; Decrement loop counter
  2467 EEFC D0 F9				BNE	PLOOP		; Repeat loop if counter low byte > 0
  2468 EEFE C6 E9				DEC	STOH		; Overflow, decrement counter high byte
  2469 EF00 D0 F5				BNE	PLOOP		; Repeat loop if counter high byte > 0
  2470 EF02 60			ENDPREAMBLE	RTS
  2471
  2472 				; **** Write File Header To Tape ***********************************************
  2473
  2474 				; ******************************************************************************
  2475
  2476 EF03 A2 06		WRITEHEADER	LDX	#$06
  2477 EF05 A9 A1				LDA	#ADDRMARK	; load address mark
  2478 EF07 20 22 EF		WRITEADDR	JSR	BYTE_OUT	; write to tape
  2479 EF0A B5 F5				LDA	NUML-3,X	; load address byte
  2480 EF0C CA					DEX
  2481 EF0D 10 F8				BPL	WRITEADDR	; all address fields written? no repeat
  2482 EF0F A9 A0				LDA	#NAMEMARK	; yes, load name mark
  2483 EF11 20 22 EF				JSR	BYTE_OUT	; and write it to tape
  2484 EF14 A0 00				LDY	#$00		; index to first filename char
  2485 EF16 B9 00 15		WRNXTCHAR	LDA	RBUFF,Y		; load filename char
  2486 EF19 F0 06				BEQ	ENDHEADER	; is it a NULL? yes -> exit
  2487 EF1B 20 22 EF				JSR	BYTE_OUT	; no write filename char to tape
  2488 EF1E C8					INY			; increment index to next filename char
  2489 EF1F D0 F5				BNE	WRNXTCHAR	; and write it
  2490 EF21 60			ENDHEADER	RTS
  2491
  2492 				; **** Write Tape Byte Routine *************************************************
  2493
  2494 				; ******************************************************************************
  2495
  2496 EF22 85 DD		BYTE_OUT	STA	OUTBYTE		; save output byte
  2497 EF24 8A			WRITEBYTE	TXA			; save X register
  2498 EF25 48					PHA
  2499 EF26 98					TYA			; save Y register
  2500 EF27 48					PHA
  2501 EF28 2C 9F 1A		WAIT_BIT1	BIT  	CNTIRQ		; timer counted to zero
  2502 EF2B 10 FB				BPL  	WAIT_BIT1	; no, repeat test
  2503 EF2D A2 08				LDX	#8		; initialize bit counter
  2504 EF2F A0 10		NEXT_BIT	LDY	#PORTB
  2505 EF31 A9 10				LDA	#%00010000	; set CAS_WR output HIGH
  2506 EF33 05 E4				ORA	VIA_STATUS	; get old output status and set CAS_WR Pin
  2507 EF35 91 14				STA	(IOBASE),Y
  2508 EF37 26 DD				ROL	OUTBYTE		; rotate next output bit to carry flag
  2509 EF39 90 04				BCC	SET_SHORT	; if carry = 0 then write short pulse
  2510 EF3B A0 BE		SET_LONG	LDY	#LPTIME		; else write long pulse
  2511 EF3D D0 02				BNE	WRITE_BIT
  2512 EF3F A0 3C		SET_SHORT	LDY	#SPTIME		; set short pulse value
  2513 EF41 84 FD		WRITE_BIT	STY	YSAV		; save pulse width value for low phase
  2514 EF43 20 53 E1				JSR	SHORTDELAY1	; high phase delay
  2515 EF46 A0 10				LDY	#PORTB		; index to port B
  2516 EF48 A9 EF				LDA	#%11101111	; set CAS_WR output LOW
  2517 EF4A 25 E4				AND	VIA_STATUS	; get old output status and clear CAS_WR pin
  2518 EF4C 91 14				STA	(IOBASE),Y
  2519 EF4E A4 FD				LDY	YSAV		; restore delay value for low phase of pulse
  2520 EF50 CA					DEX
  2521 EF51 F0 06				BEQ	ENDWRITE	; all bits done? yes, exit routine
  2522 EF53 20 53 E1				JSR	SHORTDELAY1	; low phase delay
  2523 EF56 4C 2F EF				JMP	NEXT_BIT	; continue bit send loop
  2524 EF59 8C 94 1A		ENDWRITE	STY  	CNTA		; set timer for final low phase
  2525 EF5C 26 DD				ROL	OUTBYTE		; rotate one bit to restore old Byte value
  2526 EF5E 68					PLA
  2527 EF5F A8					TAY			; restore Y register
  2528 EF60 68					PLA
  2529 EF61 AA					TAX			; restore X register
  2530 EF62 60					RTS
  2531
  2532 				; **** VIA2 IRQ Routine ********************************************************
  2533
  2534 				; ******************************************************************************
  2535
  2536 EF63 48			TAPEIRQ		PHA			; save accumulator
  2537 EF64 98					TYA
  2538 EF65 48					PHA			; save Y register
  2539 EF66 A0 1D				LDY	#IFR		; select interrupt flag register
  2540 EF68 B1 14				LDA	(IOBASE),Y
  2541 EF6A 10 27				BPL	NOTAPEIRQ	; check if it was a VIA2 interrupt
  2542 EF6C 29 02				AND	#$02		; yes, CA1 interrupt occured?
  2543 EF6E F0 13				BEQ	CHECKKEY	; no, check key status
  2544 EF70 C6 ED		CHECKBIT	DEC	BITCNT		; decrement bit counter
  2545 EF72 A0 11				LDY	#PORTA
  2546 EF74 B1 14				LDA	(IOBASE),Y	; clear CA1 interrupt flag
  2547 EF76 AD 9F 1A				LDA	CNTIRQ		; load timer IRQ status
  2548 EF79 0A					ASL			; and shift it into the carry flag
  2549 EF7A 26 DD				ROL	OUTBYTE		; save carry as current bit value
  2550 EF7C A9 31				LDA	#RPTIME
  2551 EF7E 8D 95 1A				STA	CNTB		; set timer to Read-Point-Time
  2552 EF81 D0 0C				BNE	ENDTAPEIRQ	; and exit IRQ routine
  2553 EF83 20 A5 EF		CHECKKEY	JSR	CHECK_KEYSIG	; check tape sense line
  2554 EF86 20 99 EF				JSR	RESET_TIMER2	; reset Timer2 and interrupt flags
  2555 EF89 A5 DA				LDA     TICKCNT         ; load the tick counter
  2556 EF8B F0 02				BEQ     ENDTAPEIRQ      ; is it 0?
  2557 EF8D C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  2558 EF8F 68			ENDTAPEIRQ	PLA
  2559 EF90 A8					TAY			; restore Y register
  2560 EF91 68					PLA			; restore accumulator
  2561 EF92 40					RTI
  2562
  2563 EF93 68			NOTAPEIRQ	PLA
  2564 EF94 A8					TAY			; restore Y register
  2565 EF95 68				        PLA			; restore accumulator
  2566 EF96 4C 18 F3		USRIRQ		JMP	IRQ		; call user interrupt routine
  2567
  2568 				; **** Reset Timer2 Routine ****************************************************
  2569
  2570 				; ******************************************************************************
  2571
  2572 EF99 A0 18		RESET_TIMER2	LDY	#T2CL		; select Timer2 lower byte register
  2573 EF9B A9 4B				LDA	#$4B		; reset Timer2
  2574 EF9D 91 14				STA	(IOBASE),Y	; store timer low value
  2575 EF9F A9 41				LDA	#$41
  2576 EFA1 C8					INY			; select Timer2 higher byte register
  2577 EFA2 91 14				STA	(IOBASE),Y	; store timer high value
  2578 EFA4 60					RTS
  2579
  2580 				; **** Check Tape Sense Line Routine *******************************************
  2581
  2582 				; ******************************************************************************
  2583
  2584 EFA5 A0 10		CHECK_KEYSIG	LDY	#PORTB
  2585 EFA7 B1 14				LDA	(IOBASE),Y
  2586 EFA9 29 20				AND	#$20		; test tape sense line at PB5
  2587 EFAB C5 E5				CMP	KEY_SENSE	; is it different to old tape sense line status?
  2588 EFAD F0 06				BEQ	ENDCHECK	; no, just return
  2589 EFAF 85 E5		 		STA	KEY_SENSE	; yes, save new state value
  2590 EFB1 B0 0E				BCS	MOTOR_OFF
  2591 EFB3 90 01				BCC	MOTOR_ON
  2592 EFB5 60			ENDCHECK	RTS
  2593
  2594 				; **** Turn Tape Drive Motor On ************************************************
  2595
  2596 				; ******************************************************************************
  2597
  2598 EFB6 A0 10		MOTOR_ON	LDY	#PORTB
  2599 EFB8 A9 BF				LDA	#%10111111	; set CAS_MOT line low
  2600 EFBA 25 E4				AND	VIA_STATUS
  2601 EFBC 85 E4				STA	VIA_STATUS
  2602 EFBE 91 14				STA	(IOBASE),Y
  2603 EFC0 60					RTS
  2604
  2605 				; **** Turn Tape Drive Motor Off ***********************************************
  2606
  2607 				; ******************************************************************************
  2608
  2609 EFC1 A0 10		MOTOR_OFF	LDY	#PORTB
  2610 EFC3 A9 40				LDA	#%01000000	; set CAS_MOT line high
  2611 EFC5 05 E4				ORA	VIA_STATUS
  2612 EFC7 85 E4				STA	VIA_STATUS
  2613 EFC9 91 14				STA	(IOBASE),Y
  2614 EFCB 60					RTS
  2615
  2616 				; **** Tape IRQ Off ************************************************************
  2617
  2618 				; ******************************************************************************
  2619
  2620 EFCC A0 1E		TAPEIRQ_OFF     LDY	#IER		; select interrupt enable register
  2621 EFCE A5 15		                LDA     IOBASEH
  2622 EFD0 F0 04		                BEQ     TAPEIRQ_OFF1    ; IO card available? No, just exit
  2623 EFD2 A9 7F				LDA	#$7F
  2624 EFD4 91 14				STA	(IOBASE),Y	; disable all VIA2 interrupts
  2625 EFD6 60			TAPEIRQ_OFF1	RTS
  2626
  2627 				; **** Turn Tape Read/Write Mode On ********************************************
  2628
  2629 				; ******************************************************************************
  2630
  2631 EFD7 20 CC EF		TAPERW_ON	JSR	TAPEIRQ_OFF
  2632 EFDA A9 82				LDA	#$82
  2633 EFDC 91 14				STA	(IOBASE),Y	; set interrupt for CA1
  2634 EFDE 60					RTS
  2635
  2636 				; **** Turn Tape Read/Write Mode Off *******************************************
  2637
  2638 				; ******************************************************************************
  2639
  2640 EFDF 20 CC EF		TAPERW_OFF	JSR	TAPEIRQ_OFF
  2641 EFE2 A9 A0				LDA	#$A0
  2642 EFE4 91 14				STA	(IOBASE),Y	; set interrupt for Timer2
  2643 EFE6 60					RTS
  2644
  2645 				; **** Prepare Filename ********************************************************
  2646
  2647 				; Input: X - low byte of string pointer
  2648 				;	 Y - high byte of string pointer
  2649
  2650 				; ******************************************************************************
  2651
  2652 EFE7 20 48 E1		PREPFILENAME	JSR	SETSTRBUFF0
  2653 EFEA A0 00				LDY	#$00
  2654 EFEC A2 00				LDX	#$00
  2655 EFEE B1 EA		NEXTFNCHAR	LDA  	(PSTR),Y   	; get next input char
  2656 EFF0 F0 11				BEQ	ENDFILENAME
  2657 EFF2 C9 61				CMP	#'a'		; char < 'a'?
  2658 EFF4 90 06				BCC	COPYNAME	; no, just copy char to buffer
  2659 EFF6 C9 7B				CMP	#'{'		; char > 'z'?
  2660 EFF8 B0 02				BCS	COPYNAME	; no, just copy char to buffer
  2661 EFFA 29 DF				AND	#$DF		; convert to upper case char
  2662 EFFC 9D 00 15		COPYNAME	STA	RBUFF,X		; char to buffer
  2663 EFFF C8					INY
  2664 F000 E8					INX
  2665 F001 D0 EB				BNE	NEXTFNCHAR	; read next char of filename
  2666 F003 E0 00		ENDFILENAME	CPX	#$00
  2667 F005 D0 07				BNE	ENDPREP		; is X = 0? no -> exit
  2668 F007 A9 2A				LDA	#'*'		; yes, empty string.
  2669 F009 9D 00 15				STA	RBUFF,X		; make it "*"
  2670 F00C E8					INX
  2671 F00D 98					TYA
  2672 F00E 9D 00 15		ENDPREP		STA	RBUFF,X		; terminate string with NULL
  2673 F011 20 44 E1				JSR	SETSTRBUFF	;
  2674 F014 60					RTS
  2675
  2676 				; ******************************************************************************
  2677 				; START OF XMODEM CODE
  2678 				; ******************************************************************************
  2679 				;
  2680 				; XMODEM/CRC Sender/Receiver for the 6502
  2681 				;
  2682 				; By Daryl Rictor Aug 2002
  2683 				;
  2684 				; A simple file transfer program to allow transfers between the SBC and a
  2685 				; console device utilizing the x-modem/CRC transfer protocol.
  2686 				;
  2687 				;*******************************************************************************
  2688 				; This implementation of XMODEM/CRC does NOT conform strictly to the
  2689 				; XMODEM protocol standard in that it (1) does not accurately time character
  2690 				; reception or (2) fall back to the Checksum mode.
  2691
  2692 				; (1) For timing, it uses a crude timing loop to provide approximate
  2693 				; delays.  These have been calibrated against a 1MHz CPU clock.  I have
  2694 				; found that CPU clock speed of up to 5MHz also work but may not in
  2695 				; every case.  Windows HyperTerminal worked quite well at both speeds!
  2696 				;
  2697 				; (2) Most modern terminal programs support XMODEM/CRC which can detect a
  2698 				; wider range of transmission errors so the fallback to the simple checksum
  2699 				; calculation was not implemented to save space.
  2700 				;*******************************************************************************
  2701 				;
  2702 				; Files transferred via XMODEM-CRC will have the load address contained in
  2703 				; the first two bytes in little-endian format:
  2704 				;  FIRST BLOCK
  2705 				;     offset(0) = lo(load start address),
  2706 				;     offset(1) = hi(load start address)
  2707 				;     offset(2) = data byte (0)
  2708 				;     offset(n) = data byte (n-2)
  2709 				;
  2710 				; Subsequent blocks
  2711 				;     offset(n) = data byte (n)
  2712 				;
  2713 				; One note, XMODEM send 128 byte blocks.  If the block of memory that
  2714 				; you wish to save is smaller than the 128 byte block boundary, then
  2715 				; the last block will be padded with zeros.  Upon reloading, the
  2716 				; data will be written back to the original location.  In addition, the
  2717 				; padded zeros WILL also be written into RAM, which could overwrite other
  2718 				; data.
  2719 				;
  2720 				;*******************************************************************************
  2721 				;
  2722 				; Code extensions 2022 by Joerg Walke
  2723 				;
  2724 				; Included: CAN command in addition to ESC to cancel sending and receiving data.
  2725 				; Included: EOT command to signal end of transmition.
  2726 				; Included: address range for received data, to override the start address in
  2727 				;           the first data block and to prevent overwriting of data by
  2728 				;	    trailing zeros.
  2729
  2730 				; XMODEM Receive Routine *******************************************************
  2731
  2732 F015 20 39 F2		XModemRcv       JSR     PrintXStart
  2733 F018 85 E0				STA	BLKEND		; set flag to false
  2734 F01A A9 01		                LDA     #$01
  2735 F01C 85 E2		                STA     BLKNO           ; set block # to 1
  2736 F01E 85 E1		                STA	BFLAG           ; set flag to get address from block 1
  2737 F020 A9 43		StartRcv        LDA     #'C'            ; "C" start with CRC mode
  2738 F022 20 65 F3		                JSR     SOUT	     	; send it
  2739 F025 A9 FF		                LDA     #$FF
  2740 F027 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2741 F029 A9 00		                LDA     #$00
  2742 F02B 85 DC		                STA     CRCL
  2743 F02D 85 DD		                STA     CRCH            ; init CRC value
  2744 F02F 20 E2 F1		                JSR     GetByte         ; wait for input
  2745 F032 B0 0C				BCS     GotByte         ; byte received, process it
  2746 F034 4C 20 F0				JMP     StartRcv
  2747 F037 A9 FF		StartBlk        LDA     #$FF
  2748 F039 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2749 F03B 20 E2 F1		                JSR     GetByte         ; get first byte of block
  2750 F03E 90 F7		                BCC     StartBlk        ; timed out, keep waiting...
  2751 F040 C9 1B		GotByte         CMP     #ESC            ; quitting?
  2752 F042 F0 04		                BEQ     GotESC          ; yes
  2753 F044 C9 18				CMP	#CAN		; cancel?
  2754 F046 D0 03				BNE     GotByte1	; no
  2755 F048 4C 41 F2		GotESC          JMP     PrintXErr       ; print error and return
  2756 F04B C9 01		GotByte1        CMP     #SOH            ; start of block?
  2757 F04D F0 07		                BEQ     BegBlk          ; yes
  2758 F04F C9 04		                CMP     #EOT            ;
  2759 F051 D0 45		                BNE     BadCRC          ; Not SOH or EOT, so flush buffer & send NAK
  2760 F053 4C FB F0		                JMP     RDone           ; EOT - all done!
  2761 F056 A2 00		BegBlk          LDX     #$00
  2762 F058 A9 FF		GetBlk          LDA     #$FF            ; 3 sec window to receive characters
  2763 F05A 85 DF		                STA     RETRYH
  2764 F05C 20 CF F1		GetBlk1         JSR     GetData         ; get next character
  2765 F05F 90 37		                BCC     BadCRC          ; chr rcv error, flush and send NAK
  2766 F061 9D 00 15		GetBlk2         STA     RBUFF,x         ; good char, save it in the rcv buffer
  2767 F064 E8			                INX                     ; inc buffer pointer
  2768 F065 E0 84		                CPX     #$84            ; <01> <FE> <128 bytes> <CRCH> <CRCL>
  2769 F067 D0 EF		                BNE     GetBlk          ; get 132 characters
  2770 F069 A2 00		                LDX     #$00
  2771 F06B BD 00 15		                LDA     RBUFF,x         ; get block # from buffer
  2772 F06E C5 E2		                CMP     BLKNO           ; compare to expected block #
  2773 F070 F0 06		                BEQ     GoodBlk1        ; matched!
  2774 F072 20 41 F2		                jsr     PrintXErr       ; Unexpected block number - abort
  2775 F075 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2776 F078 49 FF		GoodBlk1        EOR     #$FF            ; 1's comp of block #
  2777 F07A E8			                INX                     ;
  2778 F07B DD 00 15		                CMP     RBUFF,x         ; compare with expected 1's comp of block #
  2779 F07E F0 06		                BEQ     GoodBlk2        ; matched!
  2780 F080 20 41 F2		                JSR     PrintXErr       ; Unexpected block number - abort
  2781 F083 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2782 F086 20 19 F2		GoodBlk2        JSR     CalcCRC         ; calc CRC
  2783 F089 B9 00 15		                LDA     RBUFF,y         ; get hi CRC from buffer
  2784 F08C C5 DD		                CMP     CRCH            ; compare to calculated hi CRC
  2785 F08E D0 08		                BNE     BadCRC          ; bad crc, send NAK
  2786 F090 C8			                INY                     ;
  2787 F091 B9 00 15		                LDA     RBUFF,y         ; get lo CRC from buffer
  2788 F094 C5 DC		                CMP     CRCL            ; compare to calculated lo CRC
  2789 F096 F0 0B		                BEQ     GoodCRC         ; good CRC
  2790 F098 20 0F F2		BadCRC          JSR     Flush           ; flush the input port
  2791 F09B A9 15		                LDA     #NAK            ;
  2792 F09D 20 65 F3		                JSR     SOUT            ; send NAK to resend block
  2793 F0A0 4C 37 F0		                JMP     StartBlk        ; start over, get the block again
  2794 F0A3 A2 02		GoodCRC         LDX     #$02            ;
  2795 F0A5 A5 E2		                LDA     BLKNO           ; get the block number
  2796 F0A7 C9 01		                CMP     #$01            ; 1st block?
  2797 F0A9 D0 21		                BNE     CopyBlk         ; no, copy all 128 bytes
  2798 F0AB A5 E1		                LDA     BFLAG           ; is it really block 1, not block 257, 513 etc.
  2799 F0AD F0 1D		                BEQ     CopyBlk         ; no, copy all 128 bytes
  2800 F0AF A5 FF				LDA     MODE		; address mode = 0?
  2801 F0B1 F0 03				BEQ	READADR         ; yes, read start address from data stream
  2802 F0B3 E8			                INX
  2803 F0B4 D0 0B				BNE     READDATA	; branch always
  2804 F0B6 BD 00 15		READADR         LDA     RBUFF,x         ; get target address from 1st 2 bytes of blk 1
  2805 F0B9 85 FA				STA     ADRL            ; save lo address
  2806 F0BB E8			                INX
  2807 F0BC BD 00 15		                LDA     RBUFF,x         ; get hi address
  2808 F0BF 85 FB		                STA     ADRH            ; save it
  2809 F0C1 A5 FA		READDATA        LDA	ADRL
  2810 F0C3 85 E8				STA	STOL		; save start address low byte
  2811 F0C5 A5 FB				LDA	ADRH
  2812 F0C7 85 E9				STA	STOH		; save start address high byte
  2813 F0C9 E8					INX                     ; point to first byte of data
  2814 F0CA C6 E1		                DEC     BFLAG           ; set the flag so we won't get another address
  2815 F0CC A0 00		CopyBlk         LDY     #$00            ; set offset to zero
  2816 F0CE A5 E0		CopyBlk3        LDA     BLKEND		; block end flag set?
  2817 F0D0 D0 14				BNE     CopyBlk5	; yes, skip reading data
  2818 F0D2 BD 00 15				LDA     RBUFF,x         ; get data byte from buffer
  2819 F0D5 91 E8				STA     (STOL),y        ; save to target
  2820 F0D7 38					SEC
  2821 F0D8 A5 F8		                LDA     NUML
  2822 F0DA E5 E8		                SBC     STOL            ; are we at the last address?
  2823 F0DC D0 08		                BNE     CopyBlk5  	; no, inc pointer and continue
  2824 F0DE A5 F9		                LDA     NUMH
  2825 F0E0 E5 E9		                SBC     STOH
  2826 F0E2 D0 02		                BNE     CopyBlk5
  2827 F0E4 E6 E0		                INC     BLKEND		; yes, set last byte flag
  2828 F0E6 E6 E8		CopyBlk5	INC     STOL            ; point to next address
  2829 F0E8 D0 02		                BNE     CopyBlk4        ; did it step over page boundary?
  2830 F0EA E6 E9		                INC     STOH            ; adjust high address for page crossing
  2831 F0EC E8			CopyBlk4        INX                     ; point to next data byte
  2832 F0ED E0 82		                CPX     #$82            ; is it the last byte
  2833 F0EF D0 DD		                BNE     CopyBlk3        ; no, get the next one
  2834 F0F1 E6 E2		IncBlk          INC     BLKNO           ; done.  Inc the block #
  2835 F0F3 A9 06		                LDA     #ACK            ; send ACK
  2836 F0F5 20 65 F3		                JSR     SOUT
  2837 F0F8 4C 37 F0		                JMP     StartBlk        ; get next block
  2838 F0FB A9 06		RDone           LDA     #ACK            ; last block, send ACK and exit.
  2839 F0FD 20 65 F3		                JSR     SOUT
  2840 F100 20 0F F2		                JSR     Flush           ; get leftover characters, if any
  2841 F103 4C 49 F2		                JMP     PrintXSucc
  2842
  2843 				; XMODEM Send Routine **********************************************************
  2844
  2845 F106 20 39 F2		XModemSnd       JSR     PrintXStart
  2846 F109 85 E3				STA     ERRCNT          ; error counter set to 0
  2847 F10B 85 E0				STA     BLKEND          ; set flag to false
  2848 F10D A9 01				LDA     #$01
  2849 F10F 85 E2		                STA     BLKNO           ; set block # to 1
  2850 F111 A9 FF		Wait4CRC        LDA     #$FF            ; 3 seconds
  2851 F113 85 DF		                STA     RETRYH
  2852 F115 20 E2 F1		                JSR     GetByte
  2853 F118 90 F7		                BCC     Wait4CRC        ; wait for something to come in...
  2854 F11A C9 43		                CMP     #'C'            ; is it the "C" to start a CRC xfer?
  2855 F11C F0 0B		                BEQ     SetStoAddr      ; yes
  2856 F11E C9 1B		                CMP     #ESC            ; is it a cancel? <Esc> Key
  2857 F120 F0 04		                BEQ     DoCancel        ; No, wait for another character
  2858 F122 C9 18				CMP     #CAN            ; is it a cancel?
  2859 F124 D0 EB		                BNE     Wait4CRC        ; No, wait for another character
  2860 F126 4C C6 F1		DoCancel        JMP     PrtAbort        ; Print abort msg and exit
  2861 F129 A9 01		SetStoAddr	LDA     #$01            ; manually load blk number
  2862 F12B 8D 00 15		                STA     RBUFF           ; into 1st byte
  2863 F12E A9 FE		                LDA     #$FE            ; load 1's comp of block #
  2864 F130 8D 01 15		                STA     RBUFF+1         ; into 2nd byte
  2865 F133 A5 FA		                LDA     ADRL            ; load low byte of start address
  2866 F135 8D 02 15		                STA     RBUFF+2         ; into 3rd byte
  2867 F138 A5 FB		                LDA     ADRH            ; load hi byte of start address
  2868 F13A 8D 03 15		                STA     RBUFF+3         ; into 4th byte
  2869 F13D A2 04				LDX     #$04            ; preload X to receive buffer
  2870 F13F A0 00				LDY     #$00            ; init data block offset to 0
  2871 F141 F0 17		                BEQ     LdBuff1         ; jump into buffer load routine
  2872 F143 A5 E0		LdBuffer        LDA     BLKEND          ; was the last block sent?
  2873 F145 F0 03		                BEQ     LdBuff0         ; no, send the next one
  2874 F147 4C CC F1		                JMP     SDone           ; yes, we're done
  2875 F14A A2 02		LdBuff0         LDX     #$02            ; init pointers
  2876 F14C A0 00		                LDY     #$00
  2877 F14E E6 E2		                INC     BLKNO           ; inc block counter
  2878 F150 A5 E2		                LDA     BLKNO
  2879 F152 8D 00 15		                STA     RBUFF           ; save in 1st byte of buffer
  2880 F155 49 FF		                EOR     #$FF
  2881 F157 8D 01 15		                STA     RBUFF+1         ; save 1's comp of blkno next
  2882 F15A B1 FA		LdBuff1         LDA     (ADRL),y        ; save 128 bytes of data
  2883 F15C 9D 00 15		                STA     RBUFF,x
  2884 F15F 38			LdBuff2         SEC
  2885 F160 A5 F8		                LDA     NUML
  2886 F162 E5 FA		                SBC     ADRL            ; are we at the last address?
  2887 F164 D0 14		                BNE     LdBuff4         ; no, inc pointer and continue
  2888 F166 A5 F9		                LDA     NUMH
  2889 F168 E5 FB		                SBC     ADRH
  2890 F16A D0 0E		                BNE     LdBuff4
  2891 F16C E6 E0		                INC     BLKEND          ; yes, set last byte flag
  2892 F16E E8			LdBuff3         INX
  2893 F16F E0 82		                CPX     #$82            ; are we at the end of the 128 byte block?
  2894 F171 F0 12		                BEQ     SCalcCRC        ; yes, calc CRC
  2895 F173 A9 00		                LDA     #$00            ; fill rest of 128 bytes with $00
  2896 F175 9D 00 15		                STA     RBUFF,x
  2897 F178 F0 F4		                BEQ     LdBuff3         ; branch always
  2898 F17A E6 FA		LdBuff4         INC     ADRL            ; inc address pointer
  2899 F17C D0 02		                BNE     LdBuff5
  2900 F17E E6 FB		                INC     ADRH
  2901 F180 E8			LdBuff5         INX
  2902 F181 E0 82		                CPX     #$82            ; last byte in block?
  2903 F183 D0 D5		                BNE     LdBuff1         ; no, get the next
  2904 F185 20 19 F2		SCalcCRC        JSR     CalcCRC
  2905 F188 A5 DD		                LDA     CRCH            ; save hi byte of CRC to buffer
  2906 F18A 99 00 15		                STA     RBUFF,y
  2907 F18D C8			                INY
  2908 F18E A5 DC		                LDA     CRCL            ; save lo byte of CRC to buffer
  2909 F190 99 00 15		                STA     RBUFF,y
  2910 F193 A2 00		Resend          LDX     #$00
  2911 F195 A9 01		                LDA     #SOH
  2912 F197 20 65 F3		                JSR     SOUT            ; send SOH
  2913 F19A BD 00 15		SendBlk         LDA     RBUFF,x         ; send 132 bytes in buffer to the console
  2914 F19D 20 65 F3		                JSR     SOUT
  2915 F1A0 E8			                INX
  2916 F1A1 E0 84		                CPX     #$84            ; last byte?
  2917 F1A3 D0 F5		                BNE     SendBlk         ; no, get next
  2918 F1A5 A9 FF		                LDA     #$FF            ; yes, set 3 second delay
  2919 F1A7 85 DF		                STA     RETRYH          ; and
  2920 F1A9 20 E2 F1		                JSR     GetByte         ; wait for ACK/NACK
  2921 F1AC 90 10		                BCC     SetError        ; no char received after 3 seconds, resend
  2922 F1AE C9 06		                CMP     #ACK            ; char received... is it:
  2923 F1B0 F0 91		                BEQ     LdBuffer        ; ACK, send next block
  2924 F1B2 C9 15		                CMP     #NAK
  2925 F1B4 F0 08		                BEQ     SetError        ; NAK, inc errors and resend
  2926 F1B6 C9 1B		                CMP     #ESC
  2927 F1B8 F0 0C		                BEQ     PrtAbort        ; ESC pressed to abort
  2928 F1BA C9 18				CMP	#CAN
  2929 F1BC F0 08				BEQ     PrtAbort	; CANCEL send
  2930 									; fall through to error counter
  2931 F1BE E6 E3		SetError        INC     ERRCNT          ; inc error counter
  2932 F1C0 A5 E3		                LDA     ERRCNT
  2933 F1C2 C9 0A		                CMP     #$0A            ; are there 10 errors? (Xmodem spec for failure)
  2934 F1C4 D0 CD		                BNE     Resend          ; no, resend block
  2935
  2936 F1C6 20 0F F2		PrtAbort        JSR     Flush           ; yes, too many errors, flush buffer,
  2937 F1C9 4C 41 F2		                JMP     PrintXErr       ; print error msg and exit
  2938 F1CC 4C 49 F2		SDone           JMP     PrintXSucc   	; All Done..Print msg and exit
  2939
  2940 				; Get Data From Serial Port ****************************************************
  2941
  2942 F1CF A9 00		GetData		LDA     #$00            ; wait for chr input and cycle timing loop
  2943 F1D1 85 DE		                STA     RETRYL          ; set low value of timing loop
  2944 F1D3 20 75 F3		LoopGetData     JSR     SIN        	; get chr from serial port, don't wait
  2945 F1D6 B0 09		                BCS     EndGetData      ; got one, so exit
  2946 F1D8 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2947 F1DA D0 F7		                BNE     LoopGetData
  2948 F1DC C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2949 F1DE D0 F3		                BNE     LoopGetData     ; look for character again
  2950 F1E0 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2951 F1E1 60			EndGetData      RTS                     ; with character in A
  2952
  2953 				; Get Byte From Serial Port. Check if ESC pressed ******************************
  2954
  2955 F1E2 A9 00		GetByte		LDA     #$00            ; wait for chr input and cycle timing loop
  2956 F1E4 85 DE		                STA     RETRYL          ; set low value of timing loop
  2957 F1E6 A9 75		LoopGetByte     LDA     #< SIN        ; check low byte of serial in address
  2958 F1E8 CD 6E 1A				CMP	STDIN	        ; is Low(stdin) = Low(SIN)?
  2959 F1EB D0 07		                BNE     GetChar         ; no, use standard Get Char Routine
  2960 F1ED A9 F3		                LDA     #> SIN       ; yes, check high byte of serial in address
  2961 F1EF CD 6F 1A		                CMP     STDIN+1         ; is High(stdin) = High(SIN)?
  2962 F1F2 F0 0C		                BEQ	ReadByte	; yes, just read input stream
  2963 F1F4 20 4D E0		GetChar		JSR	CGET
  2964 F1F7 90 07				BCC	ReadByte
  2965 F1F9 C9 1B				CMP	#ESC
  2966 F1FB D0 03				BNE	ReadByte
  2967 F1FD 38					SEC
  2968 F1FE B0 0E				BCS	EndGetByte
  2969 				;		JSR	CHKESC		; no, check stdin if ESC key pressed
  2970 				;		BCC	ReadByte	; no ESC pressed, read data byte from serial port
  2971 				;		LDA	#ESC
  2972 				;		BNE     EndGetByte      ; ESC pressed, so exit
  2973 F200 20 75 F3		ReadByte	JSR     SIN        	; get chr from serial port, don't wait
  2974 F203 B0 09		                BCS     EndGetByte      ; got one, so exit
  2975 F205 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2976 F207 D0 DD		                BNE     LoopGetByte
  2977 F209 C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2978 F20B D0 D9		                BNE     LoopGetByte     ; look for character again
  2979 F20D 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2980 F20E 60			EndGetByte      RTS                     ; with character in A
  2981
  2982 				; Empty Buffer *****************************************************************
  2983
  2984 F20F A9 1C		Flush           LDA     #$1C            ; flush receive buffer
  2985 F211 85 DF		                STA     RETRYH          ; flush until empty for ~1/4 sec.
  2986 F213 20 CF F1		Flush1          JSR     GetData         ; read the port
  2987 F216 B0 F7		                BCS     Flush           ; if char received, wait for another
  2988 F218 60			                RTS
  2989
  2990 				; Calculate CRC ****************************************************************
  2991
  2992 F219 A9 00		CalcCRC		LDA	#$00		; calculate the CRC for the 128 bytes
  2993 F21B 85 DC				STA	CRCL
  2994 F21D 85 DD				STA	CRCH
  2995 F21F A0 02				LDY	#$02
  2996 F221 B9 00 15		CalcCRC1	LDA	RBUFF,y
  2997 F224 45 DD				EOR 	CRCH 		; Quick CRC computation with lookup tables
  2998 F226 AA			       		TAX		 	; updates the two bytes at crc & crc+1
  2999 F227 A5 DC		       		LDA 	CRCL		; with the byte send in the "A" register
  3000 F229 5D 00 FB		       		EOR 	CRCHI,x
  3001 F22C 85 DD		       		STA 	CRCH
  3002 F22E BD 00 FA		      	 	LDA 	CRCLO,x
  3003 F231 85 DC		       		STA 	CRCL
  3004 F233 C8					INY
  3005 F234 C0 82				CPY	#$82		; done yet?
  3006 F236 D0 E9				BNE	CalcCRC1	; no, get next
  3007 F238 60					RTS			; y=82 on exit
  3008
  3009 				; Print XModem Messages ********************************************************
  3010
  3011 F239 78			PrintXStart     SEI			; disable interrupts during XModem transfer
  3012 F23A 20 0F F2				JSR	Flush		; clear buffer
  3013 F23D A0 00				LDY     #$00		; load start message
  3014 F23F F0 0C				BEQ	PrintXMsg
  3015
  3016 F241 20 67 E1		PrintXErr       JSR	BEEP
  3017 F244 A0 28		PrintXError	LDY     #(ERRX-MSGX)	; load error message
  3018 F246 18					CLC
  3019 F247 D0 03				BNE     PrintXEnd
  3020
  3021 F249 A0 39		PrintXSucc      LDY     #(SUCCX-MSGX)	; load success message
  3022 F24B 38					SEC
  3023 F24C 58			PrintXEnd	CLI			; enable interrupts
  3024
  3025 F24D A9 00		PrintXMsg	LDA     #$00
  3026 F24F 2A					ROL			; save carry
  3027 F250 48					PHA
  3028 F251 B9 89 F2		PrintXMsg1	LDA  	MSGX,Y   	; load char at string pos y
  3029 F254 F0 06				BEQ  	EndXMsg  	; exit, if NULL char
  3030 F256 20 52 E0				JSR  	COUT       	; write character
  3031 F259 C8					INY             	; next index
  3032 F25A D0 F5				BNE  	PrintXMsg1
  3033 F25C 68			EndXMsg		PLA
  3034 F25D 4A					LSR			; restore carry and leave A = 0
  3035 F25E 60					RTS
  3036
  3037 				; Tape Messages ****************************************************************
  3038
  3039 F25F 38			TAPE_OK_MSG	SEC
  3040 F260 A0 3C				LDY	#(TAPEOK-MSGX)
  3041 F262 D0 E9				BNE	PrintXMsg
  3042
  3043 F264 18			TAPE_ERR_MSG	CLC
  3044 F265 A0 80				LDY	#(TAPELDERR-MSGX)
  3045 F267 D0 E4				BNE	PrintXMsg
  3046
  3047 F269 18			TAPE_BREAK_MSG	CLC
  3048 F26A A0 78				LDY	#(TAPEBRK-MSGX)
  3049 F26C D0 DF				BNE	PrintXMsg
  3050
  3051 F26E A0 57		TAPE_SAVE_MSG	LDY	#(TAPESAV-MSGX)
  3052 F270 D0 DB				BNE	PrintXMsg
  3053
  3054 F272 A0 69		TAPE_LOAD_MSG	LDY	#(TAPELOD-MSGX)
  3055 F274 D0 D7				BNE	PrintXMsg
  3056
  3057 F276 A0 60		TAPE_SKIP_MSG	LDY	#(TAPESKIP-MSGX)
  3058 F278 D0 D3				BNE	PrintXMsg
  3059
  3060 F27A 20 81 F2		TAPE_REC_MSG	JSR	TAPE_PLAY_MSG
  3061 F27D A0 4D				LDY	#(TAPEREC-MSGX)
  3062 F27F D0 CC				BNE	PrintXMsg
  3063
  3064 F281 A0 41		TAPE_PLAY_MSG	LDY	#(TAPEPLAY-MSGX)
  3065 F283 D0 C8				BNE	PrintXMsg
  3066
  3067 F285 A0 14		TAPE_ESC_MSG	LDY	#(ESCX-MSGX)
  3068 F287 D0 C4				BNE	PrintXMsg
  3069
  3070 				; ******************************************************************************
  3071 				; String Data Section
  3072 				; ******************************************************************************
  3073
  3074 F289 0D			MSGX            .byte      CR
  3075 F28A 42 65 67 69 6E 20 + 		.by	'Begin data transfer'
  3076 F29D 2C 20 3C 45 53 43 + ESCX		.by	', <ESC> to cancel. '
  3077 F2B0 00					.byte     	$00
  3078 F2B1 0D			ERRX		.byte	CR
  3079 F2B2 54 72 61 6E 73 66 + 		.by	'Transfer Error'
  3080 F2C0 0D 00				.byte      CR,$00
  3081 F2C2 04 04 04		SUCCX           .byte	EOT,EOT,EOT
  3082
  3083 F2C5 0D			TAPEOK		.byte	CR
  3084 F2C6 4F 4B				.by 	'OK'
  3085 F2C8 0D 00				.byte  	CR,$00
  3086 F2CA 0D			TAPEPLAY	.byte	CR
  3087 F2CB 50 72 65 73 73 20 + 		.by	'Press PLAY'
  3088 F2D5 00					.byte	$00
  3089 F2D6 20 26 20 52 45 43 + TAPEREC		.by	' & RECORD'
  3090 F2DF 00					.byte	$00
  3091 F2E0 0D			TAPESAV		.byte	CR
  3092 F2E1 73 61 76 69 6E 67 + 		.by	'saving '
  3093 F2E8 00					.byte	$00
  3094 F2E9 2C 20 73 6B 69 70 + TAPESKIP	.by	', skipped'
  3095 F2F2 0D			TAPELOD		.byte	CR
  3096 F2F3 6C 6F 61 64 69 6E + 		.by	'loading'
  3097 F2FA 00					.byte	$00
  3098 F2FB 66 6F 75 6E 64 20	TAPEFND		.by	'found '
  3099 F301 0D			TAPEBRK		.byte	CR
  3100 F302 42 72 65 61 6B			.by	'Break'
  3101 F307 0D 00				.byte	CR,$00
  3102 F309 0D			TAPELDERR	.byte	CR
  3103 F30A 4C 6F 61 64 20 45 + 		.by	'Load Error'
  3104 F314 0D 00				.byte	CR,$00
  3105 F316 2A			TAPEANYNAME	.by	"*"
  3106 F317 00					.byte	$00
  3107
  3108 				; **** IRQ, NMI and BREAK Service Routines *************************************
  3109
  3110 				; ******************************************************************************
  3111
  3112 F318 8D 77 1A		IRQ		STA	STOACC		; save current accumulator
  3113 F31B 68					PLA			; get current processor status in A
  3114 F31C 48					PHA			; and push it back to stack
  3115 F31D 29 10				AND	#$10		; mask break flag
  3116 F31F D0 06				BNE	USRBREAK	; if break flag set, jump to user break handler
  3117 F321 AD 77 1A				LDA	STOACC
  3118 F324 6C 7C 1A				JMP	(IRQUSR)	; else jump to clock IRQ routine
  3119
  3120 F327 AD 77 1A		USRBREAK	LDA	STOACC
  3121 F32A 6C 78 1A				JMP	(BRKUSR)
  3122
  3123 F32D 85 F3		NMI		STA	ACC		; save current accumulator
  3124
  3125 F32F			BREAK					; default IRQUSR & BRKUSR entry
  3126 F32F 68					PLA			; get current processor status in A
  3127 F330 85 F1				STA	PREG		; save it
  3128 F332 48					PHA			; and push it back to stack
  3129 F333 86 F5				STX	XREG		; save x-register
  3130 F335 84 F4				STY	YREG		; save y-register
  3131 F337 20 AD E1				JSR	RESET_STDIO	; always reset to standard I/O
  3132 F33A 28					PLP			; get last processor status
  3133 F33B 68					PLA			; get last program counter low byte
  3134 F33C 85 EF				STA	PCL		; and store it
  3135 F33E 85 FA				STA	ADRL
  3136 F340 68					PLA			; get last program counter high byte
  3137 F341 85 F0				STA	PCH		; and store it
  3138 F343 85 FB				STA	ADRH
  3139 F345 BA					TSX			; get current stack pointer
  3140 F346 86 F2				STX	SPUSER		; and store it
  3141 F348 D8					CLD			; set binary mode
  3142 F349 20 67 E1				JSR	BEEP		; error beep
  3143 F34C 20 4E EC				JSR	PRSTATUS	; print user program status
  3144 F34F A2 FF				LDX     #$FF
  3145 F351 9A					TXS			; initialize stack pointer
  3146 F352 58					CLI			; enable interrupts
  3147 F353 4C 3B E6				JMP	MONRESET	; and return to monitor
  3148
  3149 				; **** Try To Read Magic Number ************************************************
  3150
  3151 				; ******************************************************************************
  3152
  3153 F356 A2 04		GETMAGIC	LDX	#$04
  3154 F358 BD 64 E7		MAGICLOOP	LDA	MAGIC0-1,X
  3155 F35B DD FB DF				CMP	$DFFB,X
  3156 F35E D0 03				BNE	NOMAGIC
  3157 F360 CA					DEX
  3158 F361 D0 F5				BNE	MAGICLOOP
  3159 F363 8A			NOMAGIC		TXA
  3160 F364 60			NOSTDPROC	RTS
  3161
  3162 				; **** Write To Serial Routine *************************************************
  3163
  3164 				; Input: A - Output Byte to RS232
  3165
  3166 				; ******************************************************************************
  3167
  3168 F365			SOUT
  3169 F365 08			SERIALOUT	PHP			; save processor status
  3170 F366 78					SEI			; disable interrupts
  3171 F367 48					PHA			; save character
  3172 F368 A9 10				LDA  	#$10
  3173 F36A 2C 01 16		EMPTY?		BIT  	STAT_REG	; ACIA output register empty?
  3174 F36D F0 FB				BEQ  	EMPTY?		; no, check again.
  3175 F36F 68					PLA			; restore character
  3176 F370 8D 00 16				STA  	DATA_REG   	; write character to ACIA
  3177 F373 28					PLP			; restore processor status
  3178 F374 60					RTS
  3179
  3180 				; **** Read From Serial Routine ************************************************
  3181
  3182 				; Output: A - Input Byte from RS232
  3183 				;         C - 1 char get, 0 no char get
  3184
  3185 				; ******************************************************************************
  3186
  3187 F375			SIN
  3188 F375 18			SERIALIN	CLC              	; set to no chr present
  3189 F376 AD 01 16				LDA	STAT_REG
  3190 F379 29 08				AND	#$08		; ACIA input register full?
  3191 F37B F0 04				BEQ	SERIALEND	; no, just exit
  3192 F37D AD 00 16				LDA	DATA_REG	; yes, read character
  3193 F380 38					SEC		 	; and set C = 1, char present
  3194 F381 60			SERIALEND	RTS
  3195
  3196 				; **** Read From ASCII Keyboard Routine ****************************************
  3197
  3198 				; Output: A - Input Byte from Keyboard
  3199 				;         C - 1 char get, 0 no char get
  3200
  3201 				; ******************************************************************************
  3202
  3203 F382 AD 81 1A		ASCIIKBD	LDA	PADD		; are we in read mode?
  3204 F385 F0 03				BEQ	READMODE	; yes, check if data available
  3205 F387 20 10 F4				JSR	SETPPORTIN	; no, first set parallel port as an input
  3206 F38A 18			READMODE	CLC			; set to no char present
  3207 F38B 2C 85 1A				BIT	WRDC		; test PA7 (DATA_AVAIL)
  3208 F38E 50 09				BVC	NODATA		; no new data, just exit with C = 0
  3209 F390 AD 85 1A				LDA	WRDC		; clear PA7 flag
  3210 F393 AD 80 1A				LDA	PAD		; load keyboard ASCII code from port A
  3211 F396 29 7F				AND	#%01111111	; clear MSB
  3212 F398 38			DATA_AVAIL	SEC			; and set C = 1, char present
  3213 F399 60			NODATA		RTS
  3214
  3215 				; **** PS2 Keyboard Driver Routine *********************************************
  3216
  3217 				; Output: A - Input Byte from Keyboard
  3218 				;         C - 1 char get, 0 no char get
  3219
  3220 				; ******************************************************************************
  3221
  3222 F39A 18			PS2KBD          CLC                     ; set to no char present
  3223 F39B 84 F1		                STY     PREG            ; save current Y register
  3224 F39D A0 0E		                LDY     #PIA_PORTC
  3225 F39F B1 16		                LDA     (FGCBASE),Y     ; load data from Port C
  3226 F3A1 29 20		                AND     #$20            ; and check Strobe line
  3227 F3A3 F0 15		                BEQ     PS2_NODATA      ; no data received, just exit with C = 0
  3228 F3A5 A0 0C		                LDY     #PIA_PORTA
  3229 F3A7 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  3230 F3A9 D0 0E		                BNE     PS2_DATA_AVAIL
  3231 F3AB A0 0E		                LDY     #PIA_PORTC      ; NULL Byte received, check for second byte
  3232 F3AD B1 16		PS2_CHECK       LDA     (FGCBASE),Y     ; load data from Port C
  3233 F3AF 29 20		                AND     #$20            ; and check Strobe line
  3234 F3B1 F0 FA		                BEQ     PS2_CHECK       ; no data received, repeat
  3235 F3B3 A0 0C		                LDY     #PIA_PORTA
  3236 F3B5 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  3237 F3B7 09 80		                ORA     #$80            ; set bit 7
  3238 F3B9 38			PS2_DATA_AVAIL  SEC			; and set C = 1, char present
  3239 F3BA A4 F1		PS2_NODATA      LDY     PREG            ; restore Y register
  3240 F3BC 60			                RTS
  3241
  3242 				; **** Detect ASCII Keyboard Routine *******************************************
  3243
  3244 				; ******************************************************************************
  3245
  3246 F3BD 20 10 F4		DETECT_ASCIIKBD JSR	SETPPORTIN	; set parallel port as an input
  3247 F3C0 AD 80 1A				LDA	PAD		; read parallel port
  3248 F3C3 C9 FF				CMP	#$FF		; is there anything connected?
  3249 F3C5 F0 0A				BEQ	NOKBD		; no, just exit
  3250 F3C7 A2 98		                LDX     #<  KEYBD_DEV
  3251 F3C9 A0 F9		                LDY     #> KEYBD_DEV
  3252 F3CB 20 6F F7		                JSR     DEV_ADD         ; add ASCII keyboard driver
  3253 F3CE 8D 74 1A				STA	STDINDEV	; make it the standard input device
  3254 F3D1 60			NOKBD		RTS
  3255
  3256 				; **** Write To Parallel Port Routine ******************************************
  3257
  3258 				; Input: A - Output Byte to parallel port
  3259
  3260 				; ******************************************************************************
  3261
  3262 F3D2 48			PPORTOUT	PHA			; save character
  3263 F3D3 A9 BE				LDA	#$BE		; initialize handshake line I/O on port b
  3264 F3D5 CD 83 1A				CMP	PBDD		; already initialized?
  3265 F3D8 F0 03				BEQ	SETHSK		; yes, just set output values
  3266 F3DA 8D 83 1A				STA	PBDD		; no, PB7 = /strobe, PB6 = busy, PB5 = r/w, PB0 = speaker off
  3267 F3DD A9 86		SETHSK		LDA	#$86		; set handshake lines to their initial values
  3268 F3DF 8D 82 1A				STA	PBD		; r/w = L, strobe = H, PB1,PB2 = H -> hex-kbd disabled; speaker = H
  3269 F3E2 A9 FF				LDA	#$FF		; all port A lines are outputs
  3270 F3E4 8D 81 1A				STA	PADD
  3271 F3E7 68					PLA			; reload character in A
  3272 F3E8 48					PHA
  3273 F3E9 8D 80 1A				STA	PAD		; set output data
  3274 F3EC 2C 82 1A		PPORTBSY?	BIT	PBD		; bussy line is high?
  3275 F3EF 70 FB				BVS	PPORTBSY?	; yes, check bussy line again
  3276 F3F1 A9 06				LDA	#$06		; generate strobe pulse
  3277 F3F3 8D 82 1A				STA	PBD		; set strobe line low
  3278 F3F6 A9 86				LDA	#$86
  3279 F3F8 8D 82 1A				STA	PBD		; set strobe line high
  3280 F3FB 68					PLA			; restore character
  3281 F3FC 60					RTS
  3282
  3283 				; **** Read From Parallel Port Routine *****************************************
  3284
  3285 				; Output: A - Input Byte from parallel port
  3286 				;         C - 1 char get, 0 no char get
  3287
  3288 				; ******************************************************************************
  3289
  3290 F3FD 20 10 F4		PPORTIN		JSR	SETPPORTIN	; set parallel port as input
  3291 F400 18					CLC
  3292 F401 2C 82 1A				BIT	PBD		; check if /STROBE = 0
  3293 F404 30 09				BMI	NOSTROBE	; no, just exit with C = 0
  3294 F406 2C 82 1A		STROBE?		BIT	PBD		; yes, wait for strobe to come high again
  3295 F409 30 FB				BMI	STROBE?
  3296 F40B AD 80 1A				LDA	PAD		; load data from port A
  3297 F40E 38					SEC			; and set C = 1, data present
  3298 F40F 60			NOSTROBE	RTS
  3299
  3300 				; **** Switch Parallel Port To Data Input **************************************
  3301
  3302 				; ******************************************************************************
  3303
  3304 F410 A9 00		SETPPORTIN	LDA	#$00		; initialize port A as input
  3305 F412 8D 81 1A				STA	PADD
  3306 F415 A9 3E				LDA	#$3E		; initialize port B bits for read operation
  3307 F417 8D 83 1A				STA	PBDD
  3308 F41A A9 26				LDA	#$26		; set PB5 = H (READ)
  3309 F41C 8D 82 1A				STA	PBD
  3310 F41F 8D 85 1A				STA	WRDC		; set PA7 raising edge detection, no interrupt
  3311 F422 AD 85 1A				LDA	WRDC		; clear interrupt flag
  3312 F425 60					RTS
  3313
  3314 				; ******************************************************************************
  3315 				; SPI Driver
  3316 				; ******************************************************************************
  3317
  3318 				; ******************************************************************************
  3319 				; Initialize SPI Interface
  3320 				; ******************************************************************************
  3321
  3322 F426			SPI_INIT					;fall trough to SPI_SLOW
  3323
  3324 				; ******************************************************************************
  3325 				; Set SPI to Slow Mode (250KHz)
  3326 				; ******************************************************************************
  3327
  3328 F426 A9 04		SPI_SLOW        LDA	#$04
  3329 F428 A0 1B				LDY	#ACR
  3330 F42A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under T2 control"
  3331 F42C A9 00				LDA	#$00			; reset Timer2
  3332 F42E A0 18				LDY	#T2CL
  3333 F430 91 14				STA	(IOBASE),Y		; store timer low value
  3334 F432 20 61 F4				JSR	SPI_RESET		; flush shift register
  3335 F435 60					RTS				; Clock is set to 250 kHz
  3336 						
  3337 				; ******************************************************************************
  3338 				; Set SPI to Fast Mode (500KHz)
  3339 				; ******************************************************************************
  3340
  3341 F436 A9 08		SPI_FAST	LDA	#$08
  3342 F438 A0 1B				LDY	#ACR
  3343 F43A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under phi2 control"
  3344 F43C 60					RTS				; Clock is set to 500 kHz
  3345
  3346 				; ******************************************************************************
  3347 				; Write a Single Byte to the SPI Interface
  3348 				;
  3349 				; Input: A = Byte to Send
  3350 				; ******************************************************************************
  3351
  3352 F43D 84 FD		SPI_WRITE	STY	YSAV
  3353 F43F A0 11				LDY	#PORTA
  3354 F441 91 14				STA	(IOBASE),Y		; output data to shift register
  3355 F443 A0 1D				LDY	#IFR
  3356 F445 A9 04		SPI_WRITE1	LDA	#$04			; set bit mask for data available flag
  3357 F447 31 14				AND	(IOBASE),Y		; shift register full?
  3358 F449 F0 FA				BEQ	SPI_WRITE1		; no, check again
  3359 F44B A0 10				LDY	#PORTB
  3360 F44D A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3361 F44F 91 14				STA	(IOBASE),Y		; load data into shift register
  3362 F451 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3363 F453 91 14				STA	(IOBASE),Y		; data is now in shift register
  3364 F455 D0 0A				BNE	SPI_RESET               ; branch always
  3365
  3366 				; ******************************************************************************
  3367 				; Read a Single Byte from the SPI Interface
  3368 				;
  3369 				; Output: A = Received Byte
  3370 				; ******************************************************************************
  3371
  3372 F457 84 FD		SPI_READ	STY	YSAV
  3373 F459 A0 1D				LDY	#IFR
  3374 F45B A9 04		SPI_READ1	LDA	#$04			; set bit mask for data available flag
  3375 F45D 31 14				AND	(IOBASE),Y		; shift register full?
  3376 F45F F0 FA				BEQ	SPI_READ1		; no, check again
  3377 F461 A0 1A		SPI_RESET	LDY	#SR
  3378 F463 B1 14				LDA	(IOBASE),Y		; start next shifting, clear data available flag
  3379 F465 A4 FD				LDY	YSAV
  3380 F467 60					RTS
  3381
  3382 				; ******************************************************************************
  3383 				; SD-Card Driver Routines
  3384 				; ******************************************************************************
  3385
  3386 				; ******************************************************************************
  3387 				; Initialize SD-Card
  3388 				; Output: C = 1 Init OK, C = 0 Error
  3389 				; ******************************************************************************
  3390
  3391 F468 78			SD_INIT		SEI                             ; disable interrupts
  3392 F469 A9 00		                LDA	#$00
  3393 F46B 85 DB				STA	SD_TYPE
  3394 F46D 20 E1 F5				JSR	SD_RESET		; reset SD-Card
  3395 F470 C9 01				CMP	#$01			; SD-Card present?
  3396 F472 D0 57				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3397 F474 20 D0 F4				JSR	SD_GET_VERS		; get SD-Card version
  3398 F477 C9 05				CMP	#$05			; seems to be a version 1 card
  3399 F479 F0 08				BEQ	INIT_SD0		; so just try to initialize it
  3400 F47B C9 AA				CMP	#$AA			; version 2 cards should response with $(01)AA
  3401 F47D D0 4C				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3402 F47F A9 40				LDA	#$40			; try ACMD41($40000000) init (SD Ver. 2+)
  3403 F481 D0 02				BNE	INIT_SD1
  3404 F483 A9 00		INIT_SD0	LDA	#$00			; try ACMD41($00000000) init (SD Ver. 1)
  3405 F485 20 F3 F4		INIT_SD1	JSR	SD_CLEAR_CMD		; prepare for new command
  3406 F488 85 DF				STA	SD_PB3
  3407 F48A A9 77		INIT_SD2	LDA	#CMD55			; send prefix CMD55 (application cmd)
  3408 F48C 20 02 F5				JSR	SD_SEND_CMD
  3409 F48F C9 01				CMP	#$01
  3410 F491 D0 38				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3411 F493 A9 69				LDA	#ACMD41			; send ACMD41 (initialize)
  3412 F495 20 02 F5				JSR	SD_SEND_CMD
  3413 F498 F0 06				BEQ	INIT_SD3		; response = 0 means card waked up,
  3414 F49A C9 01				CMP	#$01			; card still idle?
  3415 F49C F0 EC				BEQ	INIT_SD2		; yes, try again
  3416 F49E D0 2B				BNE	SDC_NOT_FOUND		; no, invalid response, no usable card found
  3417 F4A0 A5 DF		INIT_SD3	LDA	SD_PB3			; Ver. 2+ Card?
  3418 F4A2 F0 13				BEQ	INIT_SD4		; no, just set block size
  3419 F4A4 20 F3 F4				JSR	SD_CLEAR_CMD		; prepare for new command
  3420 F4A7 A9 7A				LDA	#CMD58			; send CMD58 (get OCR)
  3421 F4A9 20 02 F5				JSR	SD_SEND_CMD
  3422 F4AC D0 1D				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3423 F4AE 20 E5 F4				JSR	SD_WAIT_RESP3		; wait for OCR response
  3424 F4B1 A5 DF				LDA	SD_PB3			; Test Bit 30
  3425 F4B3 29 40				AND	#$40			; 1 if SDHC/SDXC card, 0 else
  3426 F4B5 85 DB				STA	SD_TYPE			; set type $00 Byte mode, $40 LBA mode
  3427 F4B7 20 F3 F4		INIT_SD4	JSR	SD_CLEAR_CMD		; prepare for new command
  3428 F4BA A9 02				LDA	#$02			; set blocksize to 512 byte
  3429 F4BC 85 E1				STA	SD_PB1
  3430 F4BE A9 50				LDA	#CMD16			; send CMD16 (set block size)
  3431 F4C0 20 02 F5				JSR	SD_SEND_CMD
  3432 F4C3 D0 06				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  3433 F4C5 20 36 F4				JSR	SPI_FAST		; and switch to SPI fast mode (500kHz)
  3434 F4C8 58					CLI                             ; reenable interrupts
  3435 F4C9 38					SEC				; everything gone well, set carry
  3436 F4CA 60					RTS
  3437 F4CB A9 80		SDC_NOT_FOUND	LDA	#$80
  3438 F4CD 58			                CLI                             ; reenable interrupts
  3439 F4CE 18					CLC				; something went wrong, clear carry
  3440 F4CF 60					RTS				; to signal error
  3441
  3442 				; ******************************************************************************
  3443 				; Get SD-Card Version
  3444 				; ******************************************************************************
  3445
  3446 F4D0 A9 01		SD_GET_VERS	LDA	#$01			; set parameter byte 1
  3447 F4D2 85 E1				STA	SD_PB1
  3448 F4D4 A9 AA				LDA	#$AA			; set parameter byte 0
  3449 F4D6 85 E2				STA	SD_PB0
  3450 F4D8 A9 87				LDA	#$87			; set crc
  3451 F4DA 85 E3				STA	SD_CRC
  3452 F4DC A9 48				LDA	#CMD8			; send CMD8($000001AA) (get version)
  3453 F4DE 20 02 F5				JSR	SD_SEND_CMD		; response should be $01
  3454 F4E1 C9 01				CMP	#$01			; SD-Card present?
  3455 F4E3 D0 0D				BNE	END_GET_VERS		; no, exit with result <> $01
  3456 										; yes, fall through to sd_wait_resp
  3457
  3458 				; ******************************************************************************
  3459 				; Wait for a 32 Bit Command R3 Response from SD-Card
  3460 				; ******************************************************************************
  3461
  3462 F4E5 A0 00		SD_WAIT_RESP3	LDY	#$00
  3463 F4E7 20 13 F5		READ_RESP3	JSR	SD_WAIT_RESP		; yes, receive 4 response bytes
  3464 F4EA 99 DF 00				STA	SD_PB3,Y		; store response bytes in PB0..3
  3465 F4ED C8					INY
  3466 F4EE C0 04				CPY	#$04
  3467 F4F0 D0 F5				BNE	READ_RESP3
  3468 F4F2 60			END_GET_VERS	RTS
  3469
  3470 				; ******************************************************************************
  3471 				; Clear SD-Card Command Parameters
  3472 				; ******************************************************************************
  3473
  3474 F4F3 A9 00		SD_CLEAR_CMD	LDA	#$00
  3475 F4F5 A0 04				LDY	#$04			; 4 parameter bytes to clear
  3476 F4F7 99 DE 00		NEXT_PARAM	STA	SD_CMD,Y		; clear parameter byte
  3477 F4FA 88					DEY
  3478 F4FB D0 FA				BNE	NEXT_PARAM		; more to clear?
  3479 F4FD A9 FF				LDA	#$FF
  3480 F4FF 85 E3				STA	SD_CRC			; no, finally set CRC byte to $FF
  3481 F501 60					RTS
  3482
  3483 				; ******************************************************************************
  3484 				; Send Command to SD-Card
  3485 				; Input: A = Command Index
  3486 				; ******************************************************************************
  3487
  3488 F502 85 DE		SD_SEND_CMD	STA	SD_CMD
  3489 F504 20 57 F4				JSR	SPI_READ		; send one dummy
  3490 F507 A2 00				LDX	#$00
  3491 F509 B5 DE		SEND_BYTE	LDA	SD_CMD,X		; get one command byte
  3492 F50B 20 3D F4				JSR	SPI_WRITE		; and send it
  3493 F50E E8					INX
  3494 F50F E0 06				CPX	#$06			; all 6 cmd bytes send?
  3495 F511 D0 F6				BNE	SEND_BYTE		; no, send more bytes
  3496 										; yes, fall through to sd_wait_resp
  3497
  3498 				; ******************************************************************************
  3499 				; Wait for a 8 Bit Command R1 Response from SD-Card
  3500 				; Output: A = Response Byte
  3501 				; ******************************************************************************
  3502
  3503 F513 A2 08		SD_WAIT_RESP	LDX	#$08			; wait for max 8 cycles
  3504 F515 20 57 F4		READ_RESP1	JSR	SPI_READ		; receive data
  3505 F518 C9 FF				CMP	#$FF			; is it a $FF?
  3506 F51A D0 03				BNE	RESPONSE		; no, card did response
  3507 F51C CA					DEX				; yes, try again
  3508 F51D D0 F6				BNE	READ_RESP1		; check for timeout
  3509 F51F AA			RESPONSE	TAX
  3510 F520 8A					TXA				; set proper status flags for A
  3511 F521 60					RTS
  3512
  3513 				; ******************************************************************************
  3514 				; Wait for a Special Token Response from SD-Card
  3515 				; Input:  A = Token Byte
  3516 				; Output: A = Response Byte
  3517 				; ******************************************************************************
  3518
  3519 F522 85 FC		SD_WAIT_TOKEN	STA	TEMP			; store token into TEMP variable
  3520 F524 A0 FF				LDY	#$FF			; load low byte of time out counter
  3521 F526 A2 0A				LDX	#$0A			; load high byte of time out counter
  3522 F528 20 57 F4		WAIT_RESP	JSR	SPI_READ		; read byte from SPI
  3523 F52B 88					DEY				; decrement wait counter
  3524 F52C D0 03				BNE	WAIT_RESP0
  3525 F52E CA					DEX
  3526 F52F F0 04				BEQ	WAIT_RESP_END		; wait counter is 0 -> time out
  3527 F531 C5 FC		WAIT_RESP0	CMP	TEMP			; did we read the token we are waiting for?
  3528 F533 D0 F3				BNE	WAIT_RESP		; no, read next byte
  3529 F535 60			WAIT_RESP_END	RTS
  3530
  3531 				; ******************************************************************************
  3532 				; Read Single Data Block to Std. Block Buffer
  3533 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3534 				; Output: C = 0 Error, C = 1 Read OK
  3535 				;	  A = Error Code
  3536 				; ******************************************************************************
  3537
  3538 F536 20 8B F6		SD_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3539 F539 F0 06				BEQ	SD_RD_BLK
  3540
  3541 				; ******************************************************************************
  3542 				; Read Single Data Block from Logical Address to Std. Block Buffer
  3543 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3544 				; Output: C = 0 Error, C = 1 Data OK
  3545 				;	  A = Error Code
  3546 				; ******************************************************************************
  3547
  3548 F53B 20 8B F6		SD_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3549 										; fall through to sd_rd_lblk
  3550
  3551 				; ******************************************************************************
  3552 				; Read Single Data Block from Logical Address
  3553 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3554 				;	  BLKBUF,BLKBUFH = 16 Bit Destination Address
  3555 				; Output: C = 0 Error, C = 1 Data OK
  3556 				;	  A = Error Code
  3557 				; ******************************************************************************
  3558
  3559 F53E 20 94 F6		SD_RD_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3560 										; fall through to sd_rd_blk
  3561
  3562 				; ******************************************************************************
  3563 				; Read Single Data Block
  3564 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3565 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
  3566 				; Output: C = 0 Error, C = 1 Read OK
  3567 				;	  A = Error Code
  3568 				; ******************************************************************************
  3569
  3570 F541 A9 51		SD_RD_BLK	LDA	#CMD17			; send CMD17 (blk read)
  3571 F543 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3572 F546 20 22 F5				JSR	SD_WAIT_TOKEN		; wait for data token $FE
  3573 F549 C9 FE				CMP	#$FE			; is card ready for block read?
  3574 F54B 18					CLC
  3575 F54C D0 1F				BNE	SD_RD_END		; did not receive data token, exit with C = 0
  3576 F54E A2 01				LDX	#$01			; initialize page counter
  3577 F550 A0 00				LDY	#$00			; initialize byte counter
  3578 F552 84 FD		SD_RD_BLK0	STY	YSAV			; read a byte
  3579 F554 A0 1A				LDY 	#SR
  3580 F556 B1 14				LDA	(IOBASE),Y
  3581 F558 A4 FD				LDY	YSAV
  3582 F55A 91 DC				STA	(BLKBUF),Y		; and store it into the block buffer
  3583 F55C C8					INY				; increment destination pointer
  3584 F55D D0 F3				BNE	SD_RD_BLK0		; pointer overflow? No, read next byte
  3585 F55F E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3586 F561 CA					DEX
  3587 F562 10 EE				BPL	SD_RD_BLK0		; two pages read? no, read next byte
  3588 F564 20 57 F4		SD_RD_BLK1	JSR	SPI_READ		; yes, read 3 more bytes (CRC H, CRC L, dummy)
  3589 F567 C8					INY
  3590 F568 C0 03				CPY	#$03			; all 3 bytes read?
  3591 F56A D0 F8				BNE	SD_RD_BLK1		; no, read next byte
  3592 F56C 38					SEC				; yes, all data read, set C = 1
  3593 F56D 60			SD_RD_END	RTS
  3594
  3595 				; ******************************************************************************
  3596 				; Write Single Data Block from Std. Block Buffer
  3597 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Destination Address
  3598 				; Output: C = 0 Error, C = 1 Read OK
  3599 				;	  A = Error Code
  3600 				; ******************************************************************************
  3601
  3602 F56E 20 8B F6		SD_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3603 F571 F0 06				BEQ	SD_WR_BLK
  3604
  3605 				; ******************************************************************************
  3606 				; Write Single Data Block from Std. Block Buffer to Logical Address
  3607 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3608 				; Output: C = 0 Error, C = 1 Data OK
  3609 				;	  A = Error Code
  3610 				; ******************************************************************************
  3611
  3612 F573 20 8B F6		SD_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3613 										; fall through to sd_rd_lblk
  3614
  3615 				; ******************************************************************************
  3616 				; Write Single Data Block to Logical Address
  3617 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3618 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3619 				; Output: C = 0 Error, C = 1 Data OK
  3620 				;	  A = Error Code
  3621 				; ******************************************************************************
  3622
  3623 F576 20 94 F6		SD_WR_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3624 										; fall through to sd_rd_blk
  3625
  3626 				; ******************************************************************************
  3627 				; Write Single Data Block
  3628 				; Input:  SD_PB3..SD_PB0 = 32 Bit CommandBlock Destination Address
  3629 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3630 				; Output: C = 0 Error, C = 1 Write OK
  3631 				;	  A = Error Code
  3632 				; ******************************************************************************
  3633
  3634 F579 A9 58		SD_WR_BLK	LDA	#CMD24			; send CMD24 (blk write)
  3635 F57B 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3636 F57E 20 3D F4				JSR	SPI_WRITE		; write data token
  3637 F581 A2 01				LDX	#1			; initialize page counter
  3638 F583 86 FD				STX	YSAV
  3639 F585 CA					DEX				; initialize byte counter
  3640 F586 8A			SD_WR_BLK0	TXA
  3641 F587 A8					TAY
  3642 F588 B1 DC				LDA	(BLKBUF),Y		; read next byte from buffer
  3643 F58A A0 11				LDY	#PORTA			; and write it to the card
  3644 F58C 91 14				STA	(IOBASE),Y		; output data to shift register
  3645 F58E 88					DEY				; set for PORTB
  3646 F58F A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3647 F591 91 14				STA	(IOBASE),Y		; load data into shift register
  3648 F593 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3649 F595 91 14				STA	(IOBASE),Y		; data is now in shift register
  3650 F597 A0 1A				LDY 	#SR
  3651 F599 B1 14				LDA	(IOBASE),Y		; and start clk'ing
  3652 F59B E8					INX				; increment source pointer
  3653 F59C D0 E8				BNE	SD_WR_BLK0		; pointer overflow? No, write next byte
  3654 F59E E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3655 F5A0 C6 FD				DEC	YSAV
  3656 F5A2 10 E2				BPL	SD_WR_BLK0		; two pages written? no, write next byte
  3657 F5A4 20 57 F4				JSR	SPI_READ		; yes, send a (dummy) CRC ($FFFF)
  3658 F5A7 20 57 F4				JSR	SPI_READ
  3659 F5AA 20 57 F4				JSR	SPI_READ		; read one dummy byte
  3660 F5AD 20 57 F4				JSR	SPI_READ		; read response byte
  3661 F5B0 48			                PHA                             ; and save it onto the stack
  3662 F5B1 20 57 F4		SD_WR_BUSY?	JSR	SPI_READ		; read next byte
  3663 F5B4 C9 00				CMP	#0
  3664 F5B6 F0 F9				BEQ	SD_WR_BUSY?		; check if busy ($00)
  3665 F5B8 68					PLA
  3666 F5B9 29 1F				AND	#$1F			; mask result bits
  3667 F5BB C9 05				CMP	#$05			; data accepted?
  3668 F5BD 18					CLC
  3669 F5BE D0 01				BNE	SD_WR_END		; no, exit with C = 0
  3670 F5C0 38					SEC				; yes, exit with C = 1
  3671 F5C1 60			SD_WR_END	RTS
  3672
  3673 				; ******************************************************************************
  3674 				; Send Block Read or Write Command
  3675 				; Input :  A = Command (CMD17,CMD24)
  3676 				; Output : A = Data Token
  3677 				; ******************************************************************************
  3678
  3679 F5C2 20 02 F5		SD_SEND_BLK_CMD	JSR	SD_SEND_CMD
  3680 F5C5 D0 03				BNE	SD_RESP_ERR		; response <> 0 check error type
  3681 F5C7 A9 FE				LDA	#DATA_TOKEN
  3682 F5C9 60					RTS
  3683
  3684 				; ******************************************************************************
  3685 				; Check Error
  3686 				; ******************************************************************************
  3687
  3688 F5CA 29 01		SD_RESP_ERR	AND	#$01			; is card in idle mode?
  3689 F5CC F0 0B				BEQ	SD_DISK_RW		; no, print error
  3690 F5CE 20 26 F4				JSR	SPI_SLOW		; set SPI slow mode
  3691 F5D1 20 68 F4				JSR	SD_INIT			; yes, maybe card changed, reset
  3692 F5D4 B0 07				BCS	SD_DISK_CHNG
  3693 F5D6 A9 80		SD_NO_DISK	LDA	#$80
  3694 F5D8 60					RTS
  3695 F5D9 A9 81		SD_DISK_RW	LDA	#$81
  3696 F5DB 18					CLC
  3697 F5DC 60					RTS
  3698 F5DD A9 82		SD_DISK_CHNG	LDA	#$82
  3699 F5DF 18					CLC
  3700 F5E0 60					RTS
  3701
  3702 				; ******************************************************************************
  3703 				; Reset SD-Card
  3704 				; ******************************************************************************
  3705
  3706 F5E1 20 F3 F4		SD_RESET	JSR	SD_CLEAR_CMD		; clear command parameters
  3707 F5E4 A9 95				LDA	#$95
  3708 F5E6 85 E3				STA	SD_CRC			; and set crc to $95 for CMD0
  3709 F5E8 20 FF F5				JSR	SD_PREPARE		; send dummy sequence to SD-Card
  3710 F5EB D0 0A				BNE	RESET_SDC		; is MISO line high?
  3711 F5ED A9 40				LDA	#CMD0			; no, send CMD0 (reset) to SD-Card
  3712 F5EF 20 02 F5				JSR	SD_SEND_CMD
  3713 F5F2 20 FF F5				JSR	SD_PREPARE		; send init dummy sequence again
  3714 F5F5 F0 05				BEQ	END_SD_RESET		; MISO still low? Exit with A = $FF
  3715 F5F7 A9 40		RESET_SDC	LDA	#CMD0			; send CMD0 (reset) to SD-Card
  3716 F5F9 4C 02 F5				JMP	SD_SEND_CMD		; response should be $01
  3717
  3718 F5FC A9 FF		END_SD_RESET	LDA	#$FF			; reset failed
  3719 F5FE 60					RTS
  3720
  3721 				; **** Prepare SD-Card for Communication ***************************************
  3722 				;
  3723 				; ******************************************************************************
  3724
  3725 F5FF 20 26 F4		SD_PREPARE	JSR	SPI_SLOW		; set SPI slow mode
  3726 F602 A0 10				LDY	#PORTB			; initialize VIA Port B
  3727 F604 A9 4E				LDA	#$4E			; set /SPI_CS = H and /SPI_LOAD = H
  3728 F606 91 14				STA	(IOBASE),Y
  3729 F608 A2 0A				LDX	#10			; first send 80 clocks to SD-Card
  3730 F60A 20 57 F4		SEND_CLOCK	JSR	SPI_READ		; send 8 clock cycles
  3731 F60D CA					DEX
  3732 F60E D0 FA				BNE	SEND_CLOCK		; send more clock cycles
  3733 F610 AA					TAX
  3734 F611 A0 1D				LDY	#IFR
  3735 F613 A9 04		SD_PREPARE1	LDA	#$04
  3736 F615 31 14				AND	(IOBASE),Y
  3737 F617 F0 FA				BEQ	SD_PREPARE1
  3738 F619 A0 10				LDY	#PORTB
  3739 F61B A9 4A				LDA	#$4A			; set /SPI_CS = L and /SPI_LOAD = H
  3740 F61D 91 14				STA	(IOBASE),Y
  3741 F61F 8A					TXA				; set proper status flags
  3742 F620 60			SD_END		RTS
  3743
  3744 				; **** SD-Card Boot Routine ****************************************************
  3745 				;
  3746 				; ******************************************************************************
  3747 F621 20 F3 F4		SD_BOOT         JSR	SD_CLEAR_CMD
  3748 F624 20 36 F5				JSR	SD_RD_BLK_BUF           ; read MBR
  3749 F627 90 F7		                BCC     SD_END                  ; error reading MBR. Exit
  3750
  3751 F629 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3752 F62C 90 F2				BCC	SD_END			; branch if error
  3753 						
  3754 F62E A0 45				LDY     #SDCDEV-STRINGP2        ; load pointer to device name
  3755 F630 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3756 					
  3757 				;----------------------------------------------------------------------------------		
  3758 				; This routine is the same for both the CF and SD cards. It does the following:
  3759 				; - Load the MBR (sector 0) and does check for $55 $AA and $65 $02
  3760 				; - It runs the boot-menu routine in the MBR
  3761 				; - It loads the begin-LBA of the selected partition
  3762 				; - It loads the Volume ID (first sector) of the partition
  3763 				; Exit: C=0: Error, C=1: OK
  3764 				;----------------------------------------------------------------------------------		
  3765 F633 20 EE F6		LOAD_RUN_PART   JSR     SYS_MBR_ID              ; check boot block ID tag
  3766 F636 90 E8		                BCC     SD_END                  ; error, wrong ID. Exit
  3767 F638 AD BC 07		                LDA     PART0-2                 ; check if partition ID1 is $65
  3768 F63B C9 65		                CMP     #$65
  3769 F63D D0 20		                BNE     LOAD_PART0              ; no, just load partition 0
  3770 F63F AD BD 07		                LDA     PART0-1                 ; check if partition ID2 is $02
  3771 F642 C9 02		                CMP     #$02
  3772 F644 D0 19		                BNE     LOAD_PART0              ; no, just load partition 0
  3773 F646 20 00 06		                JSR     MBR                     ; partition ID $65 $02 found. Call MBR code
  3774 F649 D0 02		                BNE     LOAD_PART1              ; is boot menu result 1,2,3, or 4 ?
  3775 F64B 18			                CLC                             ; no, ESC pressed or no valid partition found
  3776 F64C 60			LRP_END         RTS                             ; abort booting from SD-Card
  3777
  3778 F64D CA			LOAD_PART1      DEX                             ; set result to 0,1,2 or 3
  3779 F64E 8A			                TXA                             ; transfer result to Accu
  3780 F64F A8			                TAY                             ; and to Y-Register
  3781 F650 0A			                ASL                            ; multiply result by 16
  3782 F651 0A			                ASL     
  3783 F652 0A			                ASL     
  3784 F653 0A			                ASL     
  3785 F654 09 08		                ORA     #$08                    ; and add 8
  3786 F656 AA			                TAX                             ; move partition table index into X
  3787 F657 98			                TYA
  3788 F658 18			                CLC
  3789 F659 69 31		                ADC     #49                     ; convert partition number to ASCII char (+1)
  3790 F65B 85 EE		                STA     PSAV                    ; and store it to PSAV
  3791 F65D D0 0B		                BNE     LOAD_PART               ; branch always
  3792 F65F A2 08		LOAD_PART0      LDX     #$08                    ; for partition 0 the table index is 8
  3793 F661 A9 31		                LDA     #'1'                    ; partition 0 number as ASCII char (+1)
  3794 F663 85 EE		                STA     PSAV                    ; store it in PSAV
  3795 F665 AD BE 07		                LDA     PART0                   ; read boot indicator
  3796 F668 F0 75		                BEQ     SYS_MSG_ERR             ; if $00 then exit
  3797 F66A A0 08		LOAD_PART       LDY     #$08
  3798 F66C BD C6 07		SD_BOOT1        LDA     PART0_RS,X              ; load partition start and length
  3799 F66F 99 00 04		                STA     BOOT_PART,Y             ; and save it to boot device descriptor
  3800 F672 CA			                DEX
  3801 F673 88			                DEY
  3802 F674 10 F6		                BPL     SD_BOOT1
  3803 F676 A2 00		                LDX	#< BOOT_PART            ; read partition boot blk ptr
  3804 F678 A0 04				LDY	#> BOOT_PART
  3805 F67A 20 E7 F6				JSR     SYS_LD_BOOTBLK          ; load partition boot block
  3806 F67D 90 CD		                BCC     LRP_END                 ; block not found. Exit
  3807 F67F 4C 00 F7		                JMP     SYS_CHECK_OS            ; check OS OEM string C=0: wrong OEM string. And return
  3808 						
  3809 				;----------------------------------------------------------------------------
  3810 				; This routine prints a string to the terminal: A=LSB, Y=MSB
  3811 				;----------------------------------------------------------------------------
  3812 F682 86 CA		SPRINT		STX 	PRSTR	    	; LSB of text-pointer
  3813 F684 84 CB				STY 	PRSTR+1	    	; MSB of text-pointer
  3814 F686 20 4D FE				JSR 	SPROUT	    	; BIOS print string routine
  3815 F689 60					RTS
  3816 F68A EA					NOP			; maintain v1.1.4 compatibility
  3817 						
  3818 				; ******************************************************************************
  3819 				; Initialize Block Buffer Pointer, it must return with A = 0.
  3820 				; ******************************************************************************
  3821
  3822 F68B A9 06		INIT_BLKBUF	LDA	#> BLOCK_BUF         ; set pointer to standard block buffer
  3823 F68D 85 DD				STA	BLKBUFH
  3824 F68F A9 00				LDA	#$00
  3825 F691 85 DC				STA	BLKBUF
  3826 F693 60					RTS
  3827
  3828 				; ******************************************************************************
  3829 				; Load Logical Block Address into SD-card Command Address.
  3830 				; Swap Endian and Shift Bits if Desired
  3831 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
  3832 				; Output: ADR in SD_PB3..SD_PB0
  3833 				; ******************************************************************************
  3834
  3835 F694 86 E6		LOAD_LBA_SD	STX	PLBAL
  3836 F696 84 E7				STY	PLBAH
  3837 F698 A2 04				LDX	#$04
  3838 F69A A0 00				LDY	#$00
  3839 F69C A5 DB				LDA	SD_TYPE
  3840 F69E D0 0F				BNE	BLK_MODE
  3841 F6A0 18					CLC
  3842 F6A1 98					TYA
  3843 F6A2 95 DE		                STA	SD_CMD,X
  3844 F6A4 CA					DEX
  3845 F6A5 B1 E6		BIT_MODE	LDA	(PLBA),Y
  3846 F6A7 2A					ROL	
  3847 F6A8 95 DE		                STA	SD_CMD,X
  3848 F6AA C8					INY
  3849 F6AB CA					DEX
  3850 F6AC D0 F7				BNE	BIT_MODE
  3851 F6AE 60					RTS
  3852 F6AF B1 E6		BLK_MODE	LDA	(PLBA),Y
  3853 F6B1 95 DE				STA	SD_CMD,X
  3854 F6B3 C8					INY
  3855 F6B4 CA					DEX
  3856 F6B5 D0 F8				BNE	BLK_MODE
  3857 F6B7 60					RTS
  3858
  3859 				; ******************************************************************************
  3860 				; Boot Routines
  3861 				; ******************************************************************************
  3862
  3863 				; **** Main Boot Routine *******************************************************
  3864 				;
  3865 				; Find first bootable device
  3866 				; Output : C = 0 No Boot Device Found
  3867 				;          C = 1 Boot Device Found. Boot Code at $0600 Available
  3868 				;
  3869 				; ******************************************************************************
  3870
  3871 F6B8 A0 20		SYS_BOOT        LDY     #STORAGE_DEV            ; boot from storage device only
  3872 F6BA 84 F4		SYS_BOOT1       STY     YREG
  3873 F6BC 98			                TYA
  3874 F6BD 20 BE F7		                JSR     DEV_OPEN                ; open device descriptor
  3875 F6C0 90 0E		                BCC     SYS_BOOT2               ; device not found, try next one
  3876 F6C2 A9 00		                LDA     #CMD_INIT
  3877 F6C4 20 BA E0		                JSR     CMDDEV                  ; initialize device
  3878 F6C7 90 07		                BCC     SYS_BOOT2               ; could not initialize, try next one
  3879 F6C9 A9 24		                LDA     #CMD_BOOT
  3880 F6CB 20 BA E0		                JSR     CMDDEV                  ; can we boot from device?
  3881 F6CE B0 11		                BCS     SYS_BOOT_END            ; yes, exit
  3882 F6D0 A4 F4		SYS_BOOT2       LDY     YREG                    ; no, try next device
  3883 F6D2 C8			                INY
  3884 F6D3 C0 2F		                CPY     #$2F                    ; all devices checked?
  3885 F6D5 D0 E3		                BNE     SYS_BOOT1               ; no, try next one
  3886 F6D7 A0 30		                LDY     #NOBOOTDEV-STRINGP2     ; yes, no boot device found
  3887
  3888 				; ***** Show System Message ****************************************************
  3889 				;
  3890 				; Input:  Y - Index To Message String
  3891 				; Output: C = 0
  3892 				;
  3893 				; ******************************************************************************
  3894
  3895 F6D9 20 4C E5		SYS_MSG         JSR     LOADSTRING2
  3896 F6DC 20 85 E0		                JSR  	WRSTR                   ; show error message
  3897 F6DF 18			SYS_MSG_ERR     CLC
  3898 F6E0 60			SYS_MSG_END     RTS
  3899
  3900 				; ***** Finalize Boot Procedure ************************************************
  3901
  3902 F6E1 A9 B0		SYS_BOOT_END    LDA     #$B0                    ; boot block could be loaded
  3903 F6E3 8D 00 06		                STA     $0600                   ; modify jump opcode in boot block into BCS
  3904 F6E6 60			                RTS
  3905
  3906 				; ***** Load Boot Block From Device ********************************************
  3907 				;
  3908 				; Input:  X - Pointer to Boot Block Low Address
  3909 				;         Y - Pointer to Boot Block High Address
  3910 				; Output: C = 0 No Boot Block Found
  3911 				;         C = 1 Boot Block Loaded at $0600
  3912 				;
  3913 				; ******************************************************************************
  3914
  3915 F6E7 A9 25		SYS_LD_BOOTBLK  LDA     #CMD_READ_BUF
  3916 F6E9 20 BA E0		                JSR     CMDDEV                   ; load master boot block
  3917 F6EC 90 10		                BCC     SYS_TAG_ERR
  3918
  3919 				; ***** Check Boot Block ID Tag ($55 $AA) **************************************
  3920 				;
  3921 				; Output: C = 0 No Boot Block Tag Found
  3922 				;         C = 1 Boot Block Tag Found
  3923 				;
  3924 				; ******************************************************************************
  3925
  3926 F6EE AD FE 07		SYS_MBR_ID      LDA     BOOTBLK_TAG             ; check boot block ID tag
  3927 F6F1 C9 55		                CMP     #$55
  3928 F6F3 D0 09		                BNE     SYS_TAG_ERR
  3929 F6F5 AD FF 07		                LDA     BOOTBLK_TAG+1
  3930 F6F8 C9 AA		                CMP     #$AA
  3931 F6FA D0 02		                BNE     SYS_TAG_ERR
  3932 F6FC 38			                SEC
  3933 F6FD 60			                RTS
  3934 F6FE 18			SYS_TAG_ERR     CLC
  3935 F6FF 60			                RTS
  3936
  3937 				; ***** Check OS OEM String ****************************************************
  3938 				;
  3939 				; Output: C = 0 OS OEM String Not Found
  3940 				;         C = 1 OS OEM String Found
  3941 				;
  3942 				; ******************************************************************************
  3943
  3944 F700 A2 04		SYS_CHECK_OS    LDX     #04                     ; check four characters of OEM string
  3945 F702 BD 7D E8		SYS_ID_LOOP     LDA     OSID-1,X
  3946 F705 DD 02 06		                CMP     BLOCK_BUF+2,X
  3947 F708 18			                CLC
  3948 F709 D0 09		                BNE     SYS_CHECK_END           ; wrong OEM string
  3949 F70B CA			                DEX
  3950 F70C D0 F4		                BNE     SYS_ID_LOOP             ; more charactrs to check
  3951 F70E A0 20		                LDY     #BOOTDEV-STRINGP2
  3952 F710 20 D9 F6		SYS_BOOTMSG     JSR     SYS_MSG                 ; write boot message
  3953 F713 38			                SEC
  3954 F714 60			SYS_CHECK_END   RTS
  3955
  3956 				; ******************************************************************************
  3957 				; Miscellanious Routines
  3958 				; ******************************************************************************
  3959
  3960 				; **** Read Joystick Port ******************************************************
  3961
  3962 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
  3963 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
  3964 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
  3965
  3966 				; ******************************************************************************
  3967
  3968 F715 A5 17		READ_JOY_PORT   LDA     FGCBASEH
  3969 F717 F0 47		                BEQ     NO_JOY_PORT             ; check if Floppy-/Graphisc-Controller installed
  3970 F719 A0 0D		                LDY     #PIA_PORTB
  3971 F71B B1 16		                LDA     (FGCBASE),Y             ; yes, read joystick port
  3972 F71D A2 00		DECODE_JOY_PORT LDX     #$00                    ; preset x position to CENTER
  3973 F71F A0 00		                LDY     #$00                    ; preset y position to CENTER
  3974 F721 86 FC		                STX     TEMP                    ; clear temp value
  3975 F723 4A			JP_UP           LSR                             ; get /UP flag
  3976 F724 B0 06		                BCS     JP_DOWN                 ; not set, check DOWN position
  3977 F726 A0 FF		                LDY     #$FF                    ; set y position to -1 (UP)
  3978 F728 4A			                LSR                             ; skip DOWN bit
  3979 F729 4C 31 F7		                JMP     JP_LEFT                 ; and test x position
  3980 F72C 4A			JP_DOWN         LSR                             ; get /DOWN flag
  3981 F72D B0 02		                BCS     JP_LEFT                 ; not set, test x position
  3982 F72F A0 01		                LDY     #$01                    ; set y position to 1 (DOWN)
  3983 F731 4A			JP_LEFT         LSR                             ; get /LEFT flag
  3984 F732 B0 06		                BCS     JP_RIGHT                ; not set, check RIGHT position
  3985 F734 A2 FF		                LDX     #$FF                    ; set x position to -1 (UP)
  3986 F736 4A			                LSR                             ; skip RIGHT bit
  3987 F737 4C 3F F7		                JMP     JP_BUTTON3              ; and test button 3
  3988 F73A 4A			JP_RIGHT        LSR                             ; get /RIGHT flag
  3989 F73B B0 02		                BCS     JP_BUTTON3              ; not set, test button 3
  3990 F73D A2 01		                LDX     #$01                    ; set x position to 1 (RIGHT)
  3991 F73F 4A			JP_BUTTON3      LSR                             ; get /BUTTON3 flag
  3992 F740 B0 06		                BCS     JP_BUTTON1              ; not set, test button 1
  3993 F742 48			                PHA                             ; save joystick port value
  3994 F743 A9 04		                LDA     #$04
  3995 F745 85 FC		                STA     TEMP                    ; set bit 2 of temp button result
  3996 F747 68			                PLA                             ; restore joystick port value
  3997 F748 4A			JP_BUTTON1      LSR                             ; get /BUTTON1 flag
  3998 F749 B0 08		                BCS     JP_BUTTON2              ; not set, test button 2
  3999 F74B 48			                PHA                             ; save joystick port value
  4000 F74C A9 01		                LDA     #$01
  4001 F74E 05 FC		                ORA     TEMP
  4002 F750 85 FC		                STA     TEMP                    ; set bit 0 of temp button result
  4003 F752 68			                PLA                             ; restore joystick port value
  4004 F753 4A			JP_BUTTON2      LSR                             ; get /BUTTON2 flag
  4005 F754 B0 06		                BCS     END_JOY_PORT            ; not set, exit
  4006 F756 A9 02		                LDA     #$02
  4007 F758 05 FC		                ORA     TEMP
  4008 F75A 85 FC		                STA     TEMP                    ; set bit 1 of temp button result
  4009 F75C A5 FC		END_JOY_PORT    LDA     TEMP                    ; load temp button result into A
  4010 F75E 38			                SEC                             ; data valid
  4011 F75F 60			                RTS
  4012 F760 AA			NO_JOY_PORT     TAX                             ; no joystick port available, clear X
  4013 F761 A8			                TAY                             ; and Y
  4014 F762 18			                CLC                             ; no joystick port available, data invalid
  4015 F763 60			                RTS
  4016
  4017 				; ******************************************************************************
  4018 				; Device Driver Routines
  4019 				; ******************************************************************************
  4020
  4021 				; **** Initialize Device Driver List *******************************************
  4022 				;
  4023 				; ******************************************************************************
  4024
  4025 F764 A0 3E		DEV_INIT	LDY	#$3E                    ; clear entire list
  4026 F766 A9 00		                LDA     #$00                    ; and fill it with zeros
  4027 F768 99 28 1A		DEV_INIT1       STA     DEVLIST,Y
  4028 F76B 88			                DEY
  4029 F76C 10 FA				BPL	DEV_INIT1
  4030 F76E 60			END_DEV_INIT	RTS
  4031
  4032 				; **** Add Device Driver *******************************************************
  4033 				;
  4034 				; Input  - X : Driver Descriptor Address Low Byte
  4035 				;          Y : Driver Descriptor Address High Byte
  4036 				; Output - C = 1 Success, C = 0 Error
  4037 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
  4038 				;
  4039 				; ******************************************************************************
  4040 F76F 86 DE		DEV_ADD		STX	PDEVL			; LSB of device driver descriptor
  4041 F771 84 DF				STY	PDEVH			; MSB of device driver descriptor
  4042 F773 A0 00				LDY	#$00
  4043 F775 B1 DE				LDA	(PDEV),Y                ; load device ID into A
  4044 F777 85 FC				STA     TEMP			; TEMP = Device ID
  4045 F779 20 B2 F7		                JSR     DEV_CHECK		; Check device ID
  4046 F77C 90 2F		                BCC     END_DEV_ADD		; Exit if device ID error
  4047 						
  4048 F77E 4A			                LSR     			; A = Device ID again
  4049 F77F 29 0F		                AND     #$0F			; Get ID-nr from Device ID
  4050 F781 C9 0F		                CMP     #$0F			; Device 15 ?
  4051 F783 D0 14		                BNE     ADD_DEV			; branch if not full yet
  4052 						
  4053 F785 98			FIND_FREE_DEV   TYA				; A now contains 2 * Device ID = $5E			
  4054 F786 29 E0		                AND     #$E0			; A = $50
  4055 F788 A8			                TAY				; Y = $50
  4056 F789 A2 00		                LDX     #$00			; init. X
  4057 F78B B9 08 1A		FIND_NEXT_DEV   LDA     DEVLIST-$20,Y		; Check if Device List entry is empty
  4058 F78E F0 0A		                BEQ     ADD_DEV1		; branch if it is empty
  4059 						
  4060 F790 C8			                INY				; Next entry in Device List
  4061 F791 C8			                INY
  4062 F792 E8			                INX				; Next device
  4063 F793 E0 0F		                CPX     #$0F			; 15 device entries checked?
  4064 F795 90 F4		                BCC     FIND_NEXT_DEV		; branch if not at end of list yet
  4065 						
  4066 F797 18			                CLC				; error
  4067 F798 60			                RTS				; return
  4068 						
  4069 F799 AA			ADD_DEV         TAX				; X = nr. of Device ID
  4070 F79A A5 DE		ADD_DEV1        LDA     PDEVL			; LSB of device driver descriptor
  4071 F79C 99 08 1A		                STA     DEVLIST-$20,Y		; Start of device driver list in RIOT memory
  4072 F79F A5 DF		                LDA     PDEVH			; MSB of device driver descriptor
  4073 F7A1 99 09 1A		                STA     DEVLIST-$1F,Y		;
  4074 F7A4 A5 FC		                LDA     TEMP			; Get Device ID back
  4075 F7A6 29 F0		                AND     #$F0			; A = $20
  4076 F7A8 86 FC		                STX     TEMP			; Temp = nr. of Device ID
  4077 F7AA 05 FC		                ORA     TEMP			; Original Device ID again
  4078 F7AC 38			                SEC				; No error
  4079 F7AD 60			END_DEV_ADD     RTS				; Return
  4080
  4081 F7AE A2 FF		DEV_ERR         LDX     #$FF			; Error, unknown Device Type
  4082 F7B0 18			                CLC
  4083 F7B1 60			               	RTS
  4084
  4085 				;----------------------------------------------------------------------
  4086 				; This functions checks if the Device ID is correct
  4087 				;----------------------------------------------------------------------
  4088 F7B2 C9 30		DEV_CHECK       CMP     #STORAGE_DEV+$10	; Not too many devices?
  4089 F7B4 B0 F8				BCS     DEV_ERR			; branch if so
  4090 						
  4091 F7B6 C9 10				CMP     #COM_DEV		; Device ID too small?
  4092 F7B8 90 F4		                BCC     DEV_ERR			; branch if so
  4093 						
  4094 F7BA 0A			                ASL     			; Why?
  4095 F7BB A8			                TAY				; y = ID * 2
  4096 F7BC 38			                SEC				; No error
  4097 F7BD 60			                RTS				; return
  4098
  4099 				; **** Open Device Driver ******************************************************
  4100 				;
  4101 				; Input  - A : Device ID
  4102 				; Output - C = 1 Success, C = 0 Error
  4103 				;          X : Descriptor Address Low Byte
  4104 				;          Y : Descriptor Address High Byte
  4105 				;
  4106 				; ******************************************************************************
  4107 F7BE 20 B2 F7		DEV_OPEN        JSR     DEV_CHECK		; Check Device ID
  4108 F7C1 90 26		                BCC     END_DEV_OPEN		; exit if ID error
  4109 						
  4110 F7C3 B9 08 1A		                LDA     DEVLIST-$20,Y		; DEVLIST = $1A28, Y=2*Device ID, $1A48 ???
  4111 F7C6 D0 02		                BNE     DEV_OPEN1		
  4112 						
  4113 F7C8 A9 80		                LDA	#< NULL_DEV   		; no device found use NULL device
  4114 F7CA 85 DE		DEV_OPEN1       STA     PDEVL
  4115 F7CC B9 09 1A		                LDA     DEVLIST-$1F,Y		; Get MSB
  4116 F7CF D0 02		                BNE     DEV_OPEN2
  4117 						
  4118 F7D1 A9 F9		                LDA	#> NULL_DEV  		; no device found use NULL device
  4119 F7D3 85 DF		DEV_OPEN2       STA     PDEVH
  4120 F7D5 A0 02				LDY	#$02
  4121 F7D7 A2 00				LDX	#$00
  4122 F7D9 B1 DE		DEV_OPEN3	LDA	(PDEV),Y		; Start Input vector LSB
  4123 F7DB 9D 68 1A				STA	DEVIN,X			
  4124 F7DE C8					INY
  4125 F7DF E8					INX
  4126 F7E0 E0 06				CPX	#$06			; Copy Input, Output & Command vector
  4127 F7E2 D0 F5				BNE	DEV_OPEN3		; branch if not done yet
  4128 						
  4129 F7E4 A6 DE				LDX	PDEVL			; X = LSB of Descriptor Address
  4130 F7E6 A4 DF				LDY	PDEVH			; Y = MSB of Descriptor Address
  4131 F7E8 38					SEC				; No error
  4132 F7E9 60			END_DEV_OPEN    RTS				; Return
  4133
  4134 				; ******************************************************************************
  4135 				; Standard Driver Command Routines
  4136 				; ******************************************************************************
  4137
  4138 				; ******************************************************************************
  4139 				; XModem Command Interpreter
  4140 				; ******************************************************************************
  4141
  4142 F7EA C9 20		XMODEM_CMD	CMP	#CMD_LOAD
  4143 F7EC D0 03				BNE	XM_SAVE
  4144 F7EE 4C 15 F0				JMP	XModemRcv
  4145 F7F1 C9 21		XM_SAVE  	CMP	#CMD_SAVE
  4146 F7F3 D0 45				BNE     COM_CMD
  4147 F7F5 4C 06 F1				JMP	XModemSnd
  4148
  4149 				; ******************************************************************************
  4150 				; Tape Device Command Interpreter
  4151 				; ******************************************************************************
  4152
  4153 F7F8 C9 20		TAPE_CMD	CMP	#CMD_LOAD
  4154 F7FA D0 03				BNE	TP_SAVE
  4155 F7FC 4C 53 ED				JMP	TAPELOAD
  4156 F7FF C9 21		TP_SAVE 	CMP	#CMD_SAVE
  4157 F801 D0 37				BNE     COM_CMD
  4158 F803 4C 75 EE				JMP	TAPESAVE
  4159
  4160 				; ******************************************************************************
  4161 				; XSD_Card Command Interpreter
  4162 				; ******************************************************************************
  4163
  4164 F806 C9 00		SDC_CMD         CMP     #CMD_INIT
  4165 F808 D0 03		                BNE     SDC_READ
  4166 F80A 4C 68 F4		                JMP     SD_INIT
  4167 F80D C9 22		SDC_READ        CMP     #CMD_READ
  4168 F80F D0 03		                BNE     SDC_WRITE
  4169 F811 4C 3E F5		                JMP     SD_RD_LBLK
  4170 F814 C9 23		SDC_WRITE       CMP     #CMD_WRITE
  4171 F816 D0 03		                BNE     SDC_RD_BUF
  4172 F818 4C 76 F5		                JMP     SD_WR_LBLK
  4173 F81B C9 25		SDC_RD_BUF      CMP     #CMD_READ_BUF
  4174 F81D D0 03		                BNE     SDC_WR_BUF
  4175 F81F 4C 3B F5		                JMP     SD_RD_LBLK_BUF
  4176 F822 C9 26		SDC_WR_BUF      CMP     #CMD_WRITE_BUF
  4177 F824 D0 03		                BNE     SDC_SETADR
  4178 F826 4C 73 F5		                JMP     SD_WR_LBLK_BUF
  4179 F829 C9 10		SDC_SETADR      CMP     #CMD_SETSTARTADR
  4180 F82B D0 06		                BNE     SDC_BOOT
  4181 F82D 86 DC		                STX     BLKBUFL
  4182 F82F 84 DD		                STY     BLKBUFH
  4183 F831 38			                SEC
  4184 F832 60			                RTS
  4185 F833 C9 24		SDC_BOOT        CMP     #CMD_BOOT
  4186 F835 D0 17		                BNE     _EMPTY_
  4187 F837 4C 21 F6		                JMP     SD_BOOT
  4188
  4189 				; ******************************************************************************
  4190 				; Common Command Interpreter
  4191 				; ******************************************************************************
  4192
  4193 F83A C9 10		COM_CMD	        CMP	#CMD_SETSTARTADR
  4194 F83C D0 06				BNE     COM_SETENDADR
  4195 F83E 86 FA				STX	ADRL
  4196 F840 84 FB				STY	ADRH
  4197 F842 38					SEC
  4198 F843 60					RTS
  4199 F844 C9 11		COM_SETENDADR	CMP	#CMD_SETENDADR
  4200 F846 D0 06		                BNE     _EMPTY_
  4201 F848 86 F8				STX	NUML
  4202 F84A 84 F9				STY	NUMH
  4203 F84C 38					SEC
  4204 F84D 60					RTS
  4205
  4206 				; EMPTY Command Handler ********************************************************
  4207 F84E 18			_EMPTY_         CLC
  4208 F84F 60			_HANDLER_       RTS
  4209
  4210 				; Command Handler For Floppy Drive 2 *******************************************
  4211 F850 09 80		FGC_FDC_CMD2    ORA     #$80            ; set bit 7 of command byte (drive 2 operation)
  4212 F852 4C 17 10		                JMP     FGC_FDC_CMD     ; call command handler
  4213
  4214 				;----------------------------------------------------------------------------
  4215 				; This routine contains the entry routines for the CF-card routines
  4216 				;----------------------------------------------------------------------------
  4217 F855 C9 00		CFC_CMD         CMP     #CMD_INIT
  4218 F857 D0 03		                BNE     CFC_READ
  4219 F859 4C 8D F8		                JMP     CF_INIT		; Init. CF-card with HW-reset
  4220 F85C C9 22		CFC_READ        CMP     #CMD_READ
  4221 F85E D0 03		                BNE     CFC_WRITE
  4222 F860 4C BF FC		                JMP     CF_RD_LBLK	; used a lot in boot.sys and mkboot.sys
  4223 F863 C9 23		CFC_WRITE       CMP     #CMD_WRITE
  4224 F865 D0 03		                BNE     CFC_RD_BUF
  4225 F867 4C FA FC		                JMP     CF_WR_LBLK
  4226 F86A C9 25		CFC_RD_BUF      CMP     #CMD_READ_BUF
  4227 F86C D0 03		                BNE     CFC_WR_BUF
  4228 F86E 4C BC FC		                JMP     CF_RD_LBLK_BUF
  4229 F871 C9 26		CFC_WR_BUF      CMP     #CMD_WRITE_BUF
  4230 F873 D0 03		                BNE     CFC_LOAD
  4231 F875 4C F7 FC		                JMP     CF_WR_LBLK_BUF
  4232 F878 C9 20		CFC_LOAD	CMP	#CMD_LOAD
  4233 F87A D0 03				BNE	CFC_SAVE
  4234 F87C 6C 06 18				JMP	(CF_LOAD_VEC)	; Filled in by boot.sys
  4235 F87F C9 21		CFC_SAVE	CMP	#CMD_SAVE
  4236 F881 D0 03				BNE	CFC_BOOT
  4237 F883 6C 08 18				JMP	(CF_SAVE_VEC)	; Filled in by boot.sys
  4238 F886 C9 24		CFC_BOOT        CMP     #CMD_BOOT
  4239 F888 D0 C4		                BNE     _EMPTY_
  4240 F88A 4C 04 F9		                JMP     CF_BOOT
  4241
  4242 				; ******************************************************************************
  4243 				; CF-Card Driver Routines
  4244 				; ******************************************************************************
  4245 				;----------------------------------------------------------------------------
  4246 				; Command: CMD_INIT, Initialize CF-Card
  4247 				; Output : C = 1 Init OK, C = 0 Error
  4248 				;----------------------------------------------------------------------------
  4249 F88D A9 00		CF_INIT		LDA #$00		; Reset command
  4250 F88F 8D 88 0C		                STA CFREG8		; HW reset command
  4251 F892 A9 01				LDA #1
  4252 F894 85 D7				STA RSTACT		; 1 = Reset pending
  4253 F896 20 B5 F8				JSR CFWAIT
  4254 F899 B0 03				BCS INITOK		; branch if CF-card init OK
  4255 						
  4256 F89B A9 80		CF_ERR		LDA #$80
  4257 F89D 60					RTS			; return if error (C=0)
  4258 						
  4259 F89E A9 E0		INITOK		LDA #$E0		; LBA3=0, Master, Mode=LBA
  4260 F8A0 8D 86 0C				STA CFREG6
  4261 F8A3 A9 01				LDA #$01		; 8-bit transfers
  4262 F8A5 8D 81 0C				STA CFREG1
  4263 F8A8 A9 EF				LDA #$EF		; Set feature command
  4264 F8AA 8D 87 0C				STA CFREG7		; CF command register
  4265 F8AD 20 B5 F8				JSR CFWAIT		; Wait and return
  4266 F8B0 90 E9				BCC CF_ERR		; branch if Error
  4267 						
  4268 F8B2 4C 00 FC				JMP CF_INFO		; Print CF-Card Info, returns with C=1 (OK)
  4269
  4270 				;----------------------------------------------------------------------------
  4271 				; This routine waits until the CF-card is ready.
  4272 				;----------------------------------------------------------------------------
  4273 F8B5 A9 00		CFWAIT		LDA #0
  4274 F8B7 85 D6				STA MSEC		; msec counter
  4275 F8B9 A5 D7		CFWLP		LDA RSTACT		; 1 = Reset pending
  4276 F8BB F0 05				BEQ NO_DLY10		; branch if no 10 msec. delay needed
  4277 						
  4278 F8BD A9 0A				LDA #10			; delay = 10 msec.
  4279 F8BF 20 4D E1				JSR DELAY		; delay 10 msec.
  4280 F8C2 E6 D6		NO_DLY10	INC MSEC		; msec-counter
  4281 F8C4 A5 D6				LDA MSEC
  4282 F8C6 F0 2D				BEQ CFWLPTO		; branch after 2550 msec. and no reset
  4283 						
  4284 F8C8 AD 87 0C				LDA CFREG7		; read status register
  4285 F8CB 29 80				AND #$80		; check busy flag
  4286 F8CD D0 EA				BNE CFWLP		; branch if BSY flag is still set
  4287 						
  4288 						; Busy flag cleared
  4289 F8CF AD 87 0C				LDA CFREG7		; read status register
  4290 F8D2 29 50				AND #$50		; check for RDY and DSC flags
  4291 F8D4 C9 50				CMP #$50		; BSY and DSC flags both set?
  4292 F8D6 D0 E1				BNE CFWLP		; branch if RDY and DSC not both set
  4293
  4294 F8D8 A5 D7				LDA RSTACT		; 1 = Reset pending
  4295 F8DA F0 17				BEQ PRENDOK		; branch if no Reset pending
  4296 						
  4297 F8DC A9 00				LDA #0
  4298 F8DE 85 D7				STA RSTACT		; Reset no longer pending
  4299 F8E0 A2 32				LDX #<TXT_RSTOK     	; Print Reset OK + msec
  4300 F8E2 A0 F9				LDY #>TXT_RSTOK
  4301 F8E4 20 82 F6				JSR SPRINT	    	; print
  4302 F8E7 A5 D6				LDA MSEC		; #msec. * 10
  4303 F8E9 20 A7 E0				JSR NUMOUT		; Print decimal number
  4304 F8EC A2 3F				LDX #<TXT_MSEC     	; Print msec
  4305 F8EE A0 F9				LDY #>TXT_MSEC
  4306 F8F0 20 82 F6				JSR SPRINT	    	; print
  4307 F8F3 38			PRENDOK		SEC			; C=1, no error
  4308 F8F4 60					RTS			; return if BSY=0 and RDY=DSC=1
  4309 					
  4310 F8F5 A2 48		CFWLPTO		LDX #<TXT_HWERR     	; Print HW error
  4311 F8F7 A0 F9				LDY #>TXT_HWERR
  4312 F8F9 20 82 F6				JSR SPRINT	    	; print		
  4313 F8FC AD 87 0C				LDA CFREG7		; Status register
  4314 F8FF 20 91 E0				JSR HEXOUT		; Print and return
  4315 F902 18					CLC			; C=0, error
  4316 F903 60			CF_END		RTS			; return
  4317
  4318 				;-------------------------------------------------------------------------------
  4319 				; CF-Card Boot Routine
  4320 				;-------------------------------------------------------------------------------
  4321 F904 20 78 FC		CF_BOOT         JSR	INIT_LBA		; CFLBA0..CFLBA3 = 0 (MBR) and load into CF-card
  4322 F907 20 B7 FC				JSR	CF_RD_BLK_BUF		; Read MBR and store in BLOCK_BUF ($0600)
  4323 F90A 90 F7				BCC     CF_END                  ; error reading MBR. Exit
  4324 						
  4325 F90C 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  4326 F90F 90 F2				BCC	CF_END			; branch if error
  4327 						
  4328 F911 A0 40				LDY     #CFCDEV-STRINGP2        ; load pointer to device name
  4329 F913 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  4330
  4331 				;-------------------------------------------------------------------------------
  4332 				; Init CFC-card, this is called from within MAIN loop.
  4333 				; The first instruction comes from the beginning of the MAIN routine and 
  4334 				; ensures that addresses do not change in a new firmware version
  4335 				;-------------------------------------------------------------------------------
  4336 F916 20 55 E5		INIT_CFC	JSR     WRITE_IO_INFO		; instruction from MAIN routine
  4337 F919 20 A1 FD				JSR	CHECK_ROMS		; Check ROM checksum
  4338 F91C A2 D0				LDX     #<CFC_DEV
  4339 F91E A0 F9		                LDY     #>CFC_DEV
  4340 F920 4C 6F F7		                JMP     DEV_ADD         	; add CF-card driver and return
  4341
  4342 				;----------------------------------------------------------------------------------		
  4343 				; This routine is the same for both the CF and SD cards. It displays the device ID
  4344 				;----------------------------------------------------------------------------------		
  4345 F923 20 D9 F6		DISP_DVC        JSR     SYS_MSG                 ; print device name to screen
  4346 F926 A9 5F		                LDA     #'_'
  4347 F928 20 52 E0		                JSR     COUT
  4348 F92B A5 EE		                LDA     PSAV                    ; add partition number to name (_1.._4)
  4349 F92D 20 52 E0		                JSR     COUT
  4350 F930 38			                SEC                             ; normal boot, set carry flag
  4351 F931 60			                RTS
  4352
  4353 F932 0D 20 43 46 20 52 + TXT_RSTOK       .by     CR ' CF Reset: ' $00
  4354 F93F 30 20 6D 73 65 63 + TXT_MSEC	.by	'0 msec.' CR $00
  4355 F948 4E 6F 20 43 46 20 + TXT_HWERR       .by     'No CF Reset, Status=$' $00
  4356
  4357 				; **** VPU IRQ Routine *********************************************************
  4358 				; ******************************************************************************
  4359 F95E			                ORG     $F960
  4360
  4361 F960 48			VPU_IRQ         PHA
  4362 F961 A9 00		                LDA     #VPU_STAT0
  4363 F963 8D 09 10		                STA     VPU_PORT1
  4364 F966 A9 8F		                LDA     #VPU_REG15
  4365 F968 8D 09 10		                STA     VPU_PORT1
  4366 F96B AD 09 10		                LDA     VPU_PORT1       ; is it a line interrupt?
  4367 F96E 10 08		                BPL     NO_VPU_IRQ      ; no, exit
  4368 F970 A5 DA		                LDA     TICKCNT         ; yes, load the tick counter
  4369 F972 F0 02				BEQ     IRQ_END         ; is it 0?
  4370 F974 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  4371 F976 68			IRQ_END         PLA
  4372 F977 40			                RTI
  4373 F978 68			NO_VPU_IRQ	PLA			; restore accumulator
  4374 F979 4C 18 F3				JMP	IRQ		; call user interrupt routine
  4375
  4376 				; ******************************************************************************
  4377 				; Standard Driver Descriptors
  4378 				; ******************************************************************************
  4379
  4380 F97C			                ORG     $FA00-16*8
  4381
  4382 F980 00 00		NULL_DEV	.byte	NULL_ID, $00     ; Null Device Driver Descriptor
  4383 F982 4E F8				.word	_EMPTY_
  4384 F984 4E F8				.word	_EMPTY_
  4385 F986 4E F8				.word	_EMPTY_
  4386
  4387 F988 10 00		TTY_DEV		.byte	TTY1_ID, $00     ; Terminal Driver Descriptor
  4388 F98A 75 F3				.word	SERIALIN
  4389 F98C 65 F3				.word	SERIALOUT
  4390 F98E E2 E1				.word	TTY_CMD
  4391
  4392 F990 11 00		PPRINT_DEV	.byte	PRINTER1_ID, $00 ; Parallel Printer Driver Descriptor
  4393 F992 4E F8				.word	_EMPTY_
  4394 F994 D2 F3				.word	PPORTOUT
  4395 F996 4E F8				.word	_EMPTY_
  4396
  4397 F998 13 00		KEYBD_DEV       .byte	KEYBD1_ID, $00   ; ASCII Keyboard Driver Descriptor
  4398 F99A 82 F3				.word	ASCIIKBD
  4399 F99C 4E F8				.word	_EMPTY_
  4400 F99E 4E F8				.word	_EMPTY_
  4401
  4402 F9A0 15 00		VDP_DEV         .byte	VDP1_ID, $00     ; Video Display Processor Driver Descriptor
  4403 F9A2 9A F3				.word   PS2KBD
  4404 F9A4 27 10		                .word   FGC_VPU_OUT
  4405 F9A6 1F 10				.word   FGC_VPU_CMD
  4406
  4407 F9A8 20 00		XMODEM_DEV	.byte	XMODEM1_ID, $00  ; XModem Device Driver Descriptor
  4408 F9AA 75 F3				.word	SERIALIN
  4409 F9AC 65 F3				.word	SERIALOUT
  4410 F9AE EA F7				.word	XMODEM_CMD
  4411
  4412 F9B0 21 00		TAPE_DEV	.byte	TAPE1_ID, $00    ; Tape Device Driver Descriptor
  4413 F9B2 4E F8				.word	_EMPTY_
  4414 F9B4 4E F8				.word	_EMPTY_
  4415 F9B6 F8 F7				.word	TAPE_CMD
  4416
  4417 F9B8 24 00		SDC_DEV	        .byte	SDC1_ID, $00     ; SD-Card Driver Descriptor
  4418 F9BA 4E F8				.word	_EMPTY_
  4419 F9BC 4E F8				.word	_EMPTY_
  4420 F9BE 06 F8				.word   SDC_CMD
  4421
  4422 F9C0 22 00		FDD1_DEV	.byte	FDD1_ID, $00     ; Floppy Disk Drive 1 Driver Descriptor
  4423 F9C2 4E F8				.word	_EMPTY_
  4424 F9C4 4E F8				.word	_EMPTY_
  4425 F9C6 17 10				.word   FGC_FDC_CMD
  4426
  4427 F9C8 23 00		FDD2_DEV	.byte	FDD2_ID, $00     ; Floppy Disk Drive 2 Driver Descriptor
  4428 F9CA 4E F8				.word	_EMPTY_
  4429 F9CC 4E F8				.word	_EMPTY_
  4430 F9CE 50 F8				.word   FGC_FDC_CMD2
  4431
  4432 F9D0 25 00		CFC_DEV	        .byte	HDD1_ID, $00     ; CF-Card Driver Descriptor
  4433 F9D2 4E F8				.word	_EMPTY_
  4434 F9D4 4E F8				.word	_EMPTY_
  4435 F9D6 55 F8				.word   CFC_CMD		 ; CF-card driver descriptor
  4436
  4437 				; ******************************************************************************
  4438 				; Low Byte CRC Lookup Table (XMODEM)
  4439 				; ******************************************************************************
  4440
  4441 F9D8			                ORG 	$FA00
  4442 FA00			CRCLO
  4443 FA00 00 21 42 63 84 A5 +  		.byte 	$00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
  4444 FA10 31 10 73 52 B5 94 +  		.byte 	$31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
  4445 FA20 62 43 20 01 E6 C7 +  		.byte 	$62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
  4446 FA30 53 72 11 30 D7 F6 +  		.byte 	$53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
  4447 FA40 C4 E5 86 A7 40 61 +  		.byte 	$C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
  4448 FA50 F5 D4 B7 96 71 50 +  		.byte 	$F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
  4449 FA60 A6 87 E4 C5 22 03 +  		.byte 	$A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
  4450 FA70 97 B6 D5 F4 13 32 +  		.byte 	$97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
  4451 FA80 88 A9 CA EB 0C 2D +  		.byte 	$88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
  4452 FA90 B9 98 FB DA 3D 1C +  		.byte 	$B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
  4453 FAA0 EA CB A8 89 6E 4F +  		.byte 	$EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
  4454 FAB0 DB FA 99 B8 5F 7E +  		.byte 	$DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
  4455 FAC0 4C 6D 0E 2F C8 E9 +  		.byte 	$4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
  4456 FAD0 7D 5C 3F 1E F9 D8 +  		.byte 	$7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
  4457 FAE0 2E 0F 6C 4D AA 8B +  		.byte 	$2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
  4458 FAF0 1F 3E 5D 7C 9B BA +  		.byte 	$1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
  4459
  4460 				; ******************************************************************************
  4461 				; Hi Byte CRC Lookup Table (XMODEM)
  4462 				; ******************************************************************************
  4463
  4464 FB00			                ORG 	$FB00
  4465 FB00			CRCHI
  4466 FB00 00 10 20 30 40 50 +  		.byte 	$00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
  4467 FB10 12 02 32 22 52 42 +  		.byte 	$12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
  4468 FB20 24 34 04 14 64 74 +  		.byte 	$24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
  4469 FB30 36 26 16 06 76 66 +  		.byte 	$36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
  4470 FB40 48 58 68 78 08 18 +  		.byte 	$48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
  4471 FB50 5A 4A 7A 6A 1A 0A +  		.byte 	$5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
  4472 FB60 6C 7C 4C 5C 2C 3C +  		.byte 	$6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
  4473 FB70 7E 6E 5E 4E 3E 2E +  		.byte 	$7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
  4474 FB80 91 81 B1 A1 D1 C1 +  		.byte 	$91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
  4475 FB90 83 93 A3 B3 C3 D3 +  		.byte 	$83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
  4476 FBA0 B5 A5 95 85 F5 E5 +  		.byte 	$B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
  4477 FBB0 A7 B7 87 97 E7 F7 +  		.byte 	$A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
  4478 FBC0 D9 C9 F9 E9 99 89 +  		.byte 	$D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
  4479 FBD0 CB DB EB FB 8B 9B +  		.byte 	$CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
  4480 FBE0 FD ED DD CD BD AD +  		.byte 	$FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
  4481 FBF0 EF FF CF DF AF BF +  		.byte 	$EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
    59
    60 FC00					ORG	$FC00			; start address of CF-IDE and MMU routines
    61 FC00					icl	"jc2_cf_ide.asm"	; cf-ide and MMU routines
Source: jc2_cf_ide.asm
     1 				;---------------------------------------------------------------------------
     2 				; JC2 CF-IDE Device Driver & MMU related functions.
     3 				; This program adds the necessary files for the CF-IDE Interface and the
     4 				; MMU related routines. 
     5 				;---------------------------------------------------------------------------
     6
     7 				;----------------------------------------------------------------------------
     8 				; This routine reads CF information and prints it.
     9 				;----------------------------------------------------------------------------
    10 FC00 20 B5 F8		CF_INFO		JSR CFWAIT	    	; Wait until CF-card ready
    11 FC03 A9 EC				LDA #$EC	    	; Drive ID command
    12 FC05 8D 87 0C				STA CFREG7		; CF command register
    13 FC08 20 8B F6				JSR INIT_BLKBUF		; Init. buffer-pointer
    14 FC0B 20 D1 FC				JSR CF_RD_INFO		; Read 512 bytes (= CF_RD_BLK without the Read 1 sector commands)
    15
    16 				; Print serial number
    17 FC0E A2 2D				LDX #<TXT_SER     	; Print Serial text
    18 FC10 A0 FD				LDY #>TXT_SER
    19 FC12 20 82 F6				JSR SPRINT	    	; print
    20 FC15 A9 14				LDA #<(BLOCK_BUF+20)
    21 FC17 85 DC				STA BLKBUF
    22 FC19 A9 06				LDA #>(BLOCK_BUF+20)
    23 FC1B 85 DD				STA BLKBUF+1
    24 FC1D A2 14				LDX #20			; len = 20
    25 FC1F 20 4F FC				JSR PRTRSN		; Print serial-number info
    26
    27 				; Print Firmware revision
    28 FC22 A2 39				LDX #<TXT_FW     	; Print Firmware text
    29 FC24 A0 FD				LDY #>TXT_FW
    30 FC26 20 82 F6				JSR SPRINT	    	; print
    31 FC29 A9 2E				LDA #<(BLOCK_BUF+46)
    32 FC2B 85 DC				STA BLKBUF
    33 FC2D A9 06				LDA #>(BLOCK_BUF+46)
    34 FC2F 85 DD				STA BLKBUF+1
    35 FC31 A2 08				LDX #8			; len = 8
    36 FC33 20 4F FC				JSR PRTRSN		; Print firmware info
    37
    38 				; Print Model number
    39 FC36 A2 46				LDX #<TXT_MOD     	; Print Model number text
    40 FC38 A0 FD				LDY #>TXT_MOD
    41 FC3A 20 82 F6				JSR SPRINT	    	; print
    42 FC3D A9 36				LDA #<(BLOCK_BUF+54)
    43 FC3F 85 DC				STA BLKBUF
    44 FC41 A9 06				LDA #>(BLOCK_BUF+54)
    45 FC43 85 DD				STA BLKBUF+1
    46 FC45 A2 28				LDX #40			; len = 40
    47 FC47 20 4F FC				JSR PRTRSN		; Print firmware info
    48 FC4A 20 5A E0				JSR CROUT		; Print CR
    49 FC4D 38					SEC			; C=1 (no error)
    50 FC4E 60					RTS
    51
    52 				;----------------------------------------------------------------------------
    53 				; This routine print a Big-Endian string of N characters, skipping all spaces.
    54 				; BUFPTR: points to begin of buffer to print
    55 				; X     : #bytes to print
    56 				;----------------------------------------------------------------------------
    57 FC4F A0 01		PRTRSN		LDY #1			; start at MSB
    58 FC51 B1 DC		PRTRSN1		LDA (BLKBUF),Y		; get MSB 		
    59 FC53 C9 20				CMP #' '		; skip if space
    60 FC55 F0 03				BEQ PRSNLP2		; branch if space
    61
    62 FC57 20 6C FC				JSR COUTXY		; output MSB to screen
    63 FC5A 88			PRSNLP2		DEY			; LSB now
    64 FC5B CA					DEX			; #bytes to print
    65 FC5C B1 DC				LDA (BLKBUF),Y		
    66 FC5E C9 20				CMP #' '		; skip if space
    67 FC60 F0 03				BEQ PRSNLP3		; branch if space
    68
    69 FC62 20 6C FC				JSR COUTXY		; output LSB to screen
    70 FC65 C8			PRSNLP3		INY			; 
    71 FC66 C8					INY			; points to next LSB
    72 FC67 C8					INY			; points to next MSB
    73 FC68 CA					DEX			; #bytes to print
    74 FC69 D0 E6				BNE PRTRSN1		; branch if more to print
    75 						
    76 FC6B 60					RTS			; return
    77
    78 				;----------------------------------------------------------------------------
    79 				; This routine calls COUT while preserving the values of X and Y
    80 				;----------------------------------------------------------------------------
    81 FC6C 86 D8		COUTXY		STX SAVEX		; Save X	
    82 FC6E 84 D9				STY SAVEY		; Save Y
    83 FC70 20 52 E0				JSR COUT		; Print char.
    84 FC73 A4 D9				LDY SAVEY		; Get Y back
    85 FC75 A6 D8				LDX SAVEX		; Get X back
    86 FC77 60					RTS			; return
    87
    88 				;----------------------------------------------------------------------------
    89 				; This routine sets the LBA for the CF-card to 0 (the MBR) and loads it
    90 				; into the CF-card.
    91 				;----------------------------------------------------------------------------
    92 FC78 A9 00		INIT_LBA	LDA #0
    93 FC7A 85 D2				STA CFLBA0	    	; LBA 0 (LSB)
    94 FC7C 85 D3				STA CFLBA1
    95 FC7E 85 D4				STA CFLBA2
    96 FC80 85 D5				STA CFLBA3		; LBA 3 (MSB)
    97 FC82 4C 9E FC				JMP LOAD_CFLBA		; Load into CF-card and return
    98
    99 				;----------------------------------------------------------------------------
   100 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   101 				; Input :  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
   102 				; Output: LBA in CFLBA3..CFLBA0
   103 				;----------------------------------------------------------------------------
   104 FC85 86 E6		LOAD_LBA_CF	STX PLBA		; Store pointer
   105 FC87 84 E7				STY PLBA+1
   106 FC89 A0 00				LDY #0
   107 FC8B B1 E6				LDA (PLBA),Y		; LBA 0 (LSB)
   108 FC8D 85 D2				STA CFLBA0
   109 FC8F C8					INY
   110 FC90 B1 E6				LDA (PLBA),Y		; LBA 1
   111 FC92 85 D3				STA CFLBA1
   112 FC94 C8					INY
   113 FC95 B1 E6				LDA (PLBA),Y		; LBA 2
   114 FC97 85 D4				STA CFLBA2
   115 FC99 C8					INY
   116 FC9A B1 E6				LDA (PLBA),Y		; LBA 3 (MSB)
   117 FC9C 85 D5				STA CFLBA3
   118 						;JMP LOAD_CFLBA		; Load into CF-card and return
   119
   120 				;----------------------------------------------------------------------------
   121 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   122 				; Input : CFLBA3..CFLBA0
   123 				; Output: -
   124 				;----------------------------------------------------------------------------
   125 FC9E A5 D2		LOAD_CFLBA	LDA CFLBA0		; CFLBA0 -> CFREG3
   126 FCA0 8D 83 0C				STA CFREG3		; 
   127 FCA3 A5 D3				LDA CFLBA1		; CFLBA1 -> CFREG4
   128 FCA5 8D 84 0C				STA CFREG4
   129 FCA8 A5 D4				LDA CFLBA2		; CFLBA2 -> CFREG5
   130 FCAA 8D 85 0C				STA CFREG5
   131 FCAD A5 D5				LDA CFLBA3		; CFLBA3 -> CFREG6
   132 FCAF 29 0F				AND #$0F		; Filter out LBA bits
   133 FCB1 09 E0				ORA #$E0		; Mode LBA, master dev
   134 FCB3 8D 86 0C				STA CFREG6		; Store in CFREG6
   135 FCB6 60					RTS
   136 						
   137 				;----------------------------------------------------------------------------
   138 				; Command: None, Read Single Data Block to Std. Block Buffer
   139 				; Input  : CFLBA3..CFLBA0 = 32 Bit Command Block Source Address. 
   140 				;          NOTE: These have to loaded prior to calling this function!!!
   141 				; Output : C = 0 Error, C = 1 Read OK
   142 				;	   A = Error Code
   143 				;----------------------------------------------------------------------------
   144 FCB7 20 8B F6		CF_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   145 FCBA F0 06				BEQ	CF_RD_BLK		; branch always
   146
   147 				;----------------------------------------------------------------------------
   148 				; Command: CMD_READ_BUF, Read Single Data Block from Logical Address to Std. Block Buffer
   149 				; Input  :  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   150 				; Output :  C   = 0 Error, C = 1 Data OK
   151 				;	    A   = Error Code
   152 				;----------------------------------------------------------------------------
   153 FCBC 20 8B F6		CF_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   154 										; fall through to CF_RD_LBLK
   155
   156 				;----------------------------------------------------------------------------
   157 				; Command: CMD_READ, Read Single Data Block from Logical Address
   158 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   159 				;	   BLKBUF,BLKBUFH = 16 Bit Destination Address
   160 				; Output : C = 0 Error, C = 1 Data OK
   161 				;	   A = Error Code
   162 				;----------------------------------------------------------------------------
   163 FCBF 20 85 FC		CF_RD_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   164 										; fall through to CF_RD_BLK
   165
   166 				;----------------------------------------------------------------------------
   167 				; Read Single Data Block
   168 				; Input:  CFLBA3..CFLBA0 = 32 Bit LBA Address
   169 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
   170 				; Output: C = 0 Error, C = 1 Read OK
   171 				;	  A = Error Code
   172 				;----------------------------------------------------------------------------
   173 FCC2 A9 01		CF_RD_BLK	LDA 	#$01
   174 FCC4 8D 82 0C				STA 	CFREG2			; Read one Sector
   175 FCC7 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   176 FCCA 90 24				BCC 	CF_RD_END		; branch on error
   177
   178 FCCC A9 20				LDA 	#$20			; Read Sector Command
   179 FCCE 8D 87 0C				STA 	CFREG7			; CF command register
   180 FCD1 A2 01		CF_RD_INFO	LDX	#$01			; initialize page counter
   181 FCD3 A0 00				LDY	#$00			; initialize byte counter
   182 FCD5 20 B5 F8		CF_RD_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   183 FCD8 90 16				BCC	CF_RD_END		; Exit on CF-card error
   184
   185 FCDA AD 87 0C				LDA 	CFREG7			; CF status register
   186 FCDD 29 08				AND 	#$08			; Filter out DRQ
   187 FCDF F0 0F				BEQ 	CF_RD_END		; branch if DRQ is no longer set
   188
   189 FCE1 AD 80 0C				LDA 	CFREG0			; read data-bytes
   190 FCE4 91 DC				STA 	(BLKBUF),Y		; store in buffer
   191 FCE6 C8					INY				; next byte
   192 FCE7 D0 EC				BNE 	CF_RD_BLK0		; branch if more bytes to read
   193
   194 FCE9 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   195 FCEB CA					DEX
   196 FCEC 10 E7				BPL	CF_RD_BLK0		; two pages read? no, read next byte
   197 						
   198 FCEE 38					SEC				; yes, all data read, set C = 1 (no error)
   199 FCEF 60					RTS
   200 FCF0 18			CF_RD_END	CLC				; C=0 (error), DRQ reset should not happen
   201 FCF1 60					RTS
   202
   203 				;----------------------------------------------------------------------------
   204 				; Command: None, Write Single Data Block from Std. Block Buffer
   205 				; Input  : CFLBA3..CFLBA0 = 32 Bit LBA Address to write to
   206 				;          NOTE: These have to loaded prior to calling this function!!!
   207 				; Output : C = 0 Error, C = 1 Read OK
   208 				;	   A = Error Code
   209 				;----------------------------------------------------------------------------
   210 FCF2 20 8B F6		CF_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   211 FCF5 F0 06				BEQ	CF_WR_BLK		; branch always
   212
   213 				;----------------------------------------------------------------------------
   214 				; Command: WRITE_BUF, Write Single Data Block from Std. Block Buffer to Logical Address
   215 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   216 				; Output : C = 0 Error, C = 1 Data OK
   217 				;	   A = Error Code
   218 				;----------------------------------------------------------------------------
   219 FCF7 20 8B F6		CF_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   220 										; fall through to CR_WR_LBLK
   221
   222 				;----------------------------------------------------------------------------
   223 				; Command: CMD_WRITE, Write Single Data Block to Logical Address
   224 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   225 				;	   BLKBUF,BLKBUFH = 16 Bit Source Address
   226 				; Output : C = 0 Error, C = 1 Data OK
   227 				;	   A = Error Code
   228 				;----------------------------------------------------------------------------
   229 FCFA 20 85 FC		CF_WR_LBLK	JSR	LOAD_LBA_CF		; Load LBA into CF-card
   230 										; fall through to CF_WR_BLK
   231
   232 				;----------------------------------------------------------------------------
   233 				; Write Single Data Block
   234 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   235 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
   236 				; Output: C = 0 Error, C = 1 Write OK
   237 				;	  A = Error Code
   238 				;----------------------------------------------------------------------------
   239 FCFD A9 01		CF_WR_BLK	LDA 	#$01
   240 FCFF 8D 82 0C				STA 	CFREG2			; Read one Sector
   241 FD02 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   242 FD05 90 24				BCC 	CF_WR_END		; branch on error
   243
   244 FD07 A9 30				LDA 	#$30			; Write Sector Command
   245 FD09 8D 87 0C				STA 	CFREG7			; CF command register
   246 FD0C A2 01		CF_WR_INFO	LDX	#$01			; initialize page counter
   247 FD0E A0 00				LDY	#$00			; initialize byte counter
   248 FD10 20 B5 F8		CF_WR_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   249 FD13 90 16				BCC	CF_WR_END		; Exit on CF-card error
   250
   251 FD15 AD 87 0C				LDA 	CFREG7			; CF status register
   252 FD18 29 08				AND 	#$08			; Filter out DRQ
   253 FD1A F0 0F				BEQ 	CF_WR_END		; branch if DRQ is no longer set
   254
   255 FD1C B1 DC				LDA 	(BLKBUF),Y		; read from buffer
   256 FD1E 8D 80 0C				STA 	CFREG0			; Write to CF-card
   257 FD21 C8					INY				; next byte
   258 FD22 D0 EC				BNE 	CF_WR_BLK0		; branch if more bytes to write
   259
   260 FD24 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   261 FD26 CA					DEX
   262 FD27 10 E7				BPL	CF_WR_BLK0		; two pages read? no, read next byte
   263 						
   264 FD29 38					SEC				; yes, all data read, set C = 1 (no error)
   265 FD2A 60					RTS
   266 						
   267 FD2B 18			CF_WR_END	CLC				; C=0 (error), DRQ reset should not happen
   268 FD2C 60					RTS
   269
   270 				;----------------------------------------------------------------------------
   271 				; Text-strings needed for Printing
   272 				;----------------------------------------------------------------------------
   273 FD2D 20 20 20 53 65 72 + TXT_SER		.by        '   Serial: ' $00
   274 FD39 0D 20 46 69 72 6D + TXT_FW		.by     CR ' Firmware: ' $00
   275 FD46 0D 20 20 20 20 4D + TXT_MOD		.by     CR '    Model: ' $00
   276
   277 				;----------------------------------------------------------------------------
   278 				; This function enables a RAM-bank at $4000-$7FFF.
   279 				; Input: X: the RAM-bank number to enable [0..28]. A RAM-bank starts at 4,
   280 				;           so 0..3 disables the RAM-banks and enables main-memory
   281 				;----------------------------------------------------------------------------
   282 FD53 AD 00 17		SET_RAMBANK	LDA	MMU		; Get MMU register
   283 FD56 29 83				AND	#$83		; Set RAM-bank bits 6..2 to 0
   284 FD58 8D 00 17				STA	MMU		; Update MMU register
   285 FD5B 8A					TXA			; A is now RAM-bank number
   286 FD5C C9 1D				CMP	#29		; RAM-bank 28 is the highest nr
   287 FD5E B0 04				BCS	SET_RAMB0	; branch if >= 29
   288 FD60 C9 04				CMP	#4		; <= 28, now check for >= 4
   289 FD62 B0 02				BCS	RAMBVLD		; branch if >= 4
   290 						
   291 FD64 A9 00		SET_RAMB0	LDA	#0		; set to no RAM-bank (main-memory)
   292 FD66 0A			RAMBVLD		ASL
   293 FD67 0A					ASL			; nr now in RAM-bank bits 6..2
   294 FD68 0D 00 17				ORA	MMU		; add to MMU-register
   295 FD6B 8D 00 17				STA	MMU		; Enable RAM-bank
   296 FD6E 60					RTS			; return
   297 						
   298 				;----------------------------------------------------------------------------
   299 				; This function returns the currently active RAM-bank at $4000-$7FFF.
   300 				; Output: A: the active RAM-bank number [4..28] or 0 if no RAM-bank is selected.
   301 				;----------------------------------------------------------------------------
   302 FD6F AD 00 17		GET_RAMBANK	LDA	MMU		; MMU-register
   303 FD72 29 7C				AND	#$7C		; Only RAM-bank bits
   304 FD74 4A					LSR
   305 FD75 4A					LSR			; Now in bits 4..0
   306 FD76 C9 04				CMP	#4		; Is it 4 or more?
   307 FD78 B0 02				BCS	RAMBX		; branch if >= 4, RAM-bank selected
   308 						
   309 FD7A A9 00				LDA	#0		; RAM-bank 0..3 => main memory
   310 FD7C 60			RAMBX		RTS			; return		
   311 						
   312 				;----------------------------------------------------------------------------
   313 				; This function enables Monitor-ROM at $1C00-$1FFF and disables the RAM behind it.
   314 				;----------------------------------------------------------------------------
   315 FD7D AD 00 17		MON2ROM		LDA	MMU		; MMU-register
   316 FD80 09 02				ORA	#MON_EN		; 1 = enable Monitor ROM
   317 FD82 8D 00 17				STA	MMU		; Activate Monitor ROM
   318 FD85 60					RTS			; return
   319 						
   320 				;----------------------------------------------------------------------------
   321 				; This function Enables Monitor-RAM at $1C00-$1FFF and disables Monitor-ROM.
   322 				;----------------------------------------------------------------------------
   323 FD86 AD 00 17		MON2RAM		LDA	MMU		; MMU-register
   324 FD89 29 FD				AND	#~MON_EN	; 0 = enable Monitor RAM, disable ROM
   325 FD8B 8D 00 17				STA	MMU		; Activate Monitor RAM
   326 FD8E 60					RTS			; return
   327
   328 				;----------------------------------------------------------------------------------		
   329 				; This routine disables the BASIC ROM and enables the RAM behind it.
   330 				;----------------------------------------------------------------------------------		
   331 FD8F AD 00 17		BAS2RAM		LDA	MMU			; MMU register		
   332 FD92 29 7F				AND 	#~BAS_EN		; Set bit to 0, disable BASIC		   
   333 FD94 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   334 FD97 60					RTS				; return
   335
   336 				;----------------------------------------------------------------------------------		
   337 				; This routine enables the BASIC ROM and disables the RAM behind it.
   338 				;----------------------------------------------------------------------------------		
   339 FD98 AD 00 17		BAS2ROM		LDA	MMU			; MMU register		
   340 FD9B 09 80				ORA 	#BAS_EN			; Set bit to 0, disable BASIC		   
   341 FD9D 8D 00 17				STA 	MMU	   		; disable BIOS ROM, enable RAM behind it
   342 FDA0 60					RTS				; return
   343
   344 				;----------------------------------------------------------------------------
   345 				; Check both ROMs: 
   346 				; 1) Monitor ROM at $1C00-$1FFF
   347 				; 2) BASIC + BIOS ROM at $B000-$FFF0
   348 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   349 				;        X: LSB of end-Address
   350 				;        Y: MSB of end-Address
   351 				;----------------------------------------------------------------------------
   352 FDA1 A9 1C		CHECK_ROMS	LDA	#$1C		; MSB of $1C00
   353 FDA3 A2 00				LDX	#$00		; LSB of $1FFF+1 (end-address)
   354 FDA5 A0 20				LDY	#$20		; MSB of $1FFF+1 (end-address)
   355 FDA7 20 B9 FD				JSR	CHECK_ROM_STRT	; Check Monitor ROM Checksum
   356 FDAA A9 B0				LDA	#$B0		; MSB of $B000
   357 FDAC A2 00				LDX	#$00		; LSB of $DFFF+1 (end-address)
   358 FDAE A0 E0				LDY	#$E0		; MSB of $DFFF+1 (end-address)
   359 FDB0 20 B9 FD				JSR	CHECK_ROM_STRT	; Check BASIC ROM Checksum
   360 FDB3 A9 E0				LDA	#$E0		; MSB of $B000
   361 FDB5 A2 F0				LDX	#$F0		; LSB of $FFF0 (end-address)
   362 FDB7 A0 FF				LDY	#$FF		; MSB of $FFF0 (end-address)
   363 						;JMP 	CHECK_ROM_STRT	; Check BIOS ROM checksum and return
   364 						
   365 				;----------------------------------------------------------------------------
   366 				; This routine is the entry-point for the ROM checksum routines.
   367 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   368 				;        X: LSB of end-Address
   369 				;        Y: MSB of end-Address
   370 				;----------------------------------------------------------------------------
   371 FDB9 86 CC		CHECK_ROM_STRT	STX	END_PTR		; LSB of end-address
   372 FDBB 84 CD				STY	END_PTR+1	; MSB of end-address
   373 FDBD A2 00				LDX	#0
   374 FDBF 86 D0				STX 	ROM_CS		; Init ROM checksum
   375 FDC1 86 D1				STX 	ROM_CS+1
   376 FDC3 86 CE				STX	ROM_PTR		; LSB of begin-address
   377 FDC5 85 CF				STA	ROM_PTR+1	; MSB of begin-address
   378 FDC7 C9 1C				CMP	#$1C		; Monitor ROM?
   379 FDC9 F0 10				BEQ	MON_CHK_ROM	; branch if Monitor ROM
   380 						
   381 FDCB C9 B0				CMP	#$B0		; BASIC ROM?
   382 FDCD F0 06				BEQ	BAS_CHK_ROM	; branch if BASIC ROM
   383
   384 FDCF A2 6E				LDX	#<TXT_ROM	; BIOS ROM
   385 FDD1 A0 FE				LDY	#>TXT_ROM
   386 FDD3 D0 0A				BNE 	PR_CHKROM_TXT	; branch always
   387 						
   388 FDD5 A2 64		BAS_CHK_ROM	LDX	#<TXT_BAS	; BASIC ROM
   389 FDD7 A0 FE				LDY	#>TXT_BAS
   390 FDD9 D0 04				BNE 	PR_CHKROM_TXT	; branch always
   391
   392 FDDB A2 5A		MON_CHK_ROM	LDX	#<TXT_MON	; Monitor ROM
   393 FDDD A0 FE				LDY	#>TXT_MON
   394 FDDF 20 82 F6		PR_CHKROM_TXT	JSR	SPRINT
   395 FDE2 A2 78				LDX	#<TXT_CS	; Print ' KB ROM '
   396 FDE4 A0 FE				LDY	#>TXT_CS
   397 FDE6 20 82 F6				JSR	SPRINT
   398 FDE9 A0 00				LDY	#0
   399 						;JMP	ROM_LP1		; fall-through to ROM_LP1
   400
   401 				;----------------------------------------------------------------------------
   402 				; This routine calculates the checksum of the entire ROM area from 
   403 				; ROM_PTR to END_PTR.
   404 				;----------------------------------------------------------------------------
   405 FDEB B1 CE		ROM_LP1		LDA 	(ROM_PTR),Y	; get byte from ROM
   406 FDED					ADCAW	ROM_CS		; ROM_CS = ROM_CS + A
Macro: ADCAW [Source: jc2_defines.inc]
     1 FDED 18					CLC
     2 FDEE 65 D0				ADC	ROM_CS
     3 FDF0 85 D0				STA	ROM_CS
     4 FDF2 A5 D1				LDA	ROM_CS+1
     5 FDF4 69 00				ADC	#0
     6 FDF6 85 D1				STA	ROM_CS+1
Source: jc2_cf_ide.asm
   407 FDF8 C8					INY			; next byte
   408 FDF9 D0 02				BNE	ROM_CHK_END	; branch if not on a new page
   409 						
   410 FDFB E6 CF				INC 	ROM_PTR+1	; MSB, next page
   411 FDFD A5 CF		ROM_CHK_END	LDA	ROM_PTR+1	; Current ROM address MSB
   412 FDFF C5 CD				CMP	END_PTR+1	; MSB of end-address
   413 FE01 D0 E8				BNE	ROM_LP1		; branch if not done yet
   414 						
   415 FE03 C4 CC				CPY	END_PTR		; End-address?
   416 FE05 D0 E4				BNE	ROM_LP1		; branch if not at end-address yet
   417 						
   418 FE07 A5 CD				LDA	END_PTR+1
   419 FE09 C9 FF				CMP	#$FF		; BIOS ROM?
   420 FE0B D0 10				BNE	ROM_CHK2	; branch if not BIOS ROM
   421 						
   422 FE0D A5 D1 CD F9 FF D0 + 		CPW	ROM_CS ROM_CS16	; Compare 2 words BIOS checksum
   423 FE19 D0 2B				BNE	ROM_CS_ERR	; branch if not the same
   424 FE1B F0 22				BEQ	ROM_CS_OK	; branch if the same
   425
   426 FE1D C9 E0		ROM_CHK2	CMP	#$E0		; BASIC ROM?
   427 FE1F D0 10				BNE	MON_ROM_CMP	; branch if Monitor ROM
   428 						
   429 FE21 A5 D1 CD F7 FF D0 + 		CPW	ROM_CS BAS_CS16	; Compare 2 words BASIC checksum
   430 FE2D D0 17				BNE	ROM_CS_ERR	; branch if not the same
   431 FE2F F0 0E				BEQ	ROM_CS_OK	; branch if the same
   432 						
   433 FE31 A5 D1 CD F5 FF D0 + MON_ROM_CMP	CPW	ROM_CS MON_CS16	; Compare 2 words Monitor checksum
   434 FE3D D0 07				BNE	ROM_CS_ERR	; branch if not the same
   435
   436 FE3F A2 81		ROM_CS_OK	LDX	#<TXT_CS_OK	; Print 'OKE'
   437 FE41 A0 FE				LDY	#>TXT_CS_OK
   438 FE43 4C 82 F6				JMP	SPRINT		; Print and return
   439 FE46 A2 85		ROM_CS_ERR	LDX	#<TXT_CS_ERR	; Print 'Error'
   440 FE48 A0 FE				LDY	#>TXT_CS_ERR
   441 FE4A 4C 82 F6				JMP	SPRINT		; Print and return
   442
   443 				;----------------------------------------------------------------------------
   444 				; This routine prints a string to the terminal: X=LSB, Y=MSB.
   445 				; In order not to interfere with the BIOS STROUT / WRSTR with PSTR, a copy
   446 				; of these routines is made with SPRINT and SPROUT.
   447 				;----------------------------------------------------------------------------
   448 FE4D A0 00		SPROUT		LDY  	#$00       	; index y is 0
   449 FE4F B1 CA		SPROUTLP	LDA  	(PRSTR),Y   	; load char at string pos y
   450 FE51 F0 06				BEQ  	ENDSPROUT  	; exit, if NULL char
   451 						
   452 FE53 20 52 E0				JSR  	COUT       	; write character
   453 FE56 C8					INY             	; next index
   454 FE57 D0 F6				BNE  	SPROUTLP	; branch always
   455 						
   456 FE59 60			ENDSPROUT	RTS			; return
   457
   458 FE5A 20 4A 43 2D 4D 4F + TXT_MON		.by	' JC-MON 1' $00
   459 FE64 20 42 41 53 49 43 + TXT_BAS		.by	' BASIC 12' $00
   460 FE6E 20 42 49 4F 53 20 + TXT_ROM		.by	' BIOS   8' $00
   461 FE78 20 4B 42 20 52 4F + TXT_CS		.by	' KB ROM ' $00
   462 FE81 4F 4B 0D 00		TXT_CS_OK	.by	'OK' CR $00
   463 FE85 45 72 72 6F 72 0D + TXT_CS_ERR	.by	'Error' CR $00		
   464 						
   465
   466 						
    62 						
    63 				;----------------------------------------------------------------------------
    64 				;       VECTORS AT THE END OF THE ROM AREA
    65 				;----------------------------------------------------------------------------
    66 FE8C					ORG	$FFEE
    67 FFEE 6C 7A 1A		NMI_JMP_VEC    	JMP     (NMIVECT)		; Jump to a user selectable NMI vector (moved from Monitor $1F2F)
    68 FFF1 6C 7E 1A		IRQ_JMP_VEC    	JMP     (IRQVECT)		; Jump to a user selectable IRQ vector (moved from Monitor $1F32)
    69 FFF4 00 00		MON_CS16	.word	$000			;  1 KB Monitor ROM checksum
    70 FFF6 00 00		BAS_CS16	.word	$000			; 12 KB BASIC ROM checksum
    71 FFF8 00 00		ROM_CS16	.word	$000			;  8 KB BIOS ROM checksum
    72 FFFA EE FF		NMI_VECTOR	.word	NMI_JMP_VEC		; This was $1F2F in Junior Computer Monitor program
    73 FFFC 00 E0		RESET_VECTOR	.word  	MON_COLD_START		; $E000 (was $1C1D in Junior Computer Monitor program)
    74 FFFE F1 FF		IRQ_BRK_VECTOR	.word	IRQ_JMP_VEC		; This was $1F32 in Junior Computer Monitor program
    75
    76 						END
