mads 2.1.7 build 33 (1 Aug 24)
Source: jc2_main.asm
     1 				; ------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS Version 1.2.5 by Emile, v1.1.4 and earlier versions by Joerg Walke
     3 				;
     4 				; 21-04-25: v1.2.0 Emile, Integration into 1 eprom
     5 				; 08-05-25: v1.2.1 -Basic update (v2.22 patches + I2COUT, I2CIN and DOS commands)
     6 				;                  -CF_LOAD_VEC/CF_SAVE_VEC added, RETURN_VECT moved to $180A 
     7 				;                  -Address corrections to maintain V1.1.4 compatibility (broken in V1.2.0)
     8 				; 19-05-25: v1.2.2 -ZP addresses reorganised to avoid conflicts between Basic, BIOS & boot.sys.
     9 				;		   -NMI & IRQ JMP vectors moved from Monitor to here to prepare for Monitor ROM switching
    10 				; 24-05-25: v1.2.3 Bug-fix Basic LOAD command.
    11 				; 20-07-25: v1.2.4 - TAPE routines removed and DETECT_IOL updated
    12 				;                  - Basic: SOUND added and PORTIO/PORTOUT/PORTIN updated with new IO2 and main-board
    13 				;                  - MCP23017 routines added
    14 				; 12-08-25: v1.2.5 - *.inc file in separate inc dir. so they can also be used in other projects.
    15 				;                  - Bug-fix CFWAIT, CF_RD_BLK and CF_WR_BLK routines
    16 				; ------------------------------------------------------------------------------
    17 = 0031			VERMAIN   	EQU     '1'    			; BIOS main version
    18 = 0032			VERPSUB    	EQU     '2'    			; BIOS primary sub version
    19 = 0035			VERSSUB		EQU	'5'			; BIOS secondary sub version
    20
    21 				        	OPT h-                          ; no DOS file-header
    22 				        	OPT f+                          ; save as single block
    23
    24 				        	icl 	"jc2_defines.inc"  	; all address defines for the JC-II
Source: jc2_defines.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor ADDRESS DEFINES
     3 				;------------------------------------------------------------------------------
     4
     5 				;------------------------------------------------------------------------------
     6 				; $00 - $FF, Zero-Page Address Defines
     7 				; - Addresses from $00 up to $9C are in use by BASIC
     8 				; - Addresses from $A0 up to $AF are in use by DOS and boot.sys
     9 				;------------------------------------------------------------------------------ 
    10 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
    11 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    12 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    13
    14 = 0003			FREE1		EQU	$03		; Not in use
    15
    16 				; ------------------------------------------------------
    17 				; BASIC variables: $04 to $13, see jc2_basic_zp_vars.inc
    18 				; ------------------------------------------------------
    19
    20 				; Card Base Addresses **********************************************************
    21 = 0014			IOBASE		EQU	$14		; pointer to IO card base
    22 = 0014			IOBASEL		EQU	$14		; always $00
    23 = 0015			IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
    24 = 0016			FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
    25 = 0016			FGCBASEL	EQU	$16		; always $00
    26 = 0017			FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always be K4 = $10
    27 = 0018			CARD3BASE	EQU	$18		; reserved (controller base)
    28 = 0018			CARD3BASEL	EQU	$18		; always $00
    29 = 0019			CARD3BASEH	EQU	$19		; K2 = $08, K3 = $0C, K4 = $10
    30
    31 				; -------------------------------------------------------
    32 				; BASIC variables: $1A to $97, see jc2_basic_zp_vars.inc
    33 				; -------------------------------------------------------
    34 						ICL "jc2_basic_zp_vars.inc"	; JC2 BASIC variables
Source: jc2_basic_zp_vars.inc
     1 				;-------------------------------------------------
     2 				; JC2 BASIC Zero-Page variables.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------
     5
     6 = 0004			Decss			= $04		; BASIC number to decimal string start LSB (moved from $EF)
     7 = 0005			Decssp1			= $05		; BASIC number to decimal string start MSB (moved from $F0)
     8 									; $06..$09 also reserved for Decss
     9 									
    10 = 000A			Usrjmp			= $0A		; USR function JMP address
    11 = 000B			Usrjpl			= Usrjmp+1	; USR function JMP vector low byte
    12 = 000C			Usrjph			= Usrjmp+2	; USR function JMP vector high byte
    13 = 000D			Nullct			= $0D		; nulls output after each line
    14 = 000E			TPos			= $0E		; BASIC terminal position byte
    15 = 000F			TWidth			= $0F		; BASIC terminal width byte
    16 = 0010			Iclim			= $10		; input column limit
    17 = 0011			Itempl			= $11		; temporary integer low byte
    18 = 0012			Itemph			= Itempl+1	; temporary integer high byte
    19
    20 = 0011			nums_1			= Itempl	; number to bin/hex string convert MSB
    21 = 0012			nums_2			= nums_1+1	; number to bin/hex string convert
    22 = 0013			nums_3			= nums_1+2	; number to bin/hex string convert LSB
    23
    24 				; *** free space **********************************************************
    25 				;			= $14		; *used by JC2 system
    26 				;			= $15		; *used by JC2 system
    27 				;			= $16		; *used by JC2 system
    28 				;			= $17		; *used by JC2 system
    29 				;			= $18		; *used by JC2 system
    30 				;			= $19		; *used by JC2 system 
    31 				; *************************************************************************
    32
    33 = 001A			Temp1			= $1A		; temporary byte for free use
    34
    35 = 001B			Srchc			= $1B		; search character
    36 = 001B			Temp3			= Srchc		; temp byte used in number routines
    37 = 001C			Scnquo			= $1C		; scan-between-quotes flag
    38 = 001C			Asrch			= Scnquo	; alt search character
    39
    40 = 001B			XOAw_l			= Srchc		; eXclusive OR, OR and AND word low byte
    41 = 001C			XOAw_h			= Scnquo	; eXclusive OR, OR and AND word high byte
    42
    43 = 001D			Ibptr			= $1D		; input buffer pointer
    44 = 001D			Dimcnt			= Ibptr		; # of dimensions
    45
    46 = 001E			Defdim			= $1E		; default DIM flag
    47 = 001F			Dtypef			= $1F		; data type flag, $FF=string, $00=numeric
    48 = 0020			Oquote			= $20		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
    49 = 0020			Gclctd			= $20		; garbage collected flag
    50 = 0021			Sufnxf			= $21		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    51 = 0022			Imode			= $22		; input mode flag, $00=INPUT, $80=READ
    52
    53 = 0023			Cflag			= $23		; comparison evaluation flag
    54
    55 = 0024			TabSiz			= $24		; TAB step size (was input flag)
    56
    57 = 0025			next_s			= $25		; next descriptor stack address
    58
    59 									; these two bytes form a word pointer to the item
    60 									; currently on top of the descriptor stack
    61
    62 = 0026			last_sl			= $26		; last descriptor stack address low byte
    63 = 0027			last_sh			= $27		; last descriptor stack address high byte (always $00)
    64
    65 = 0028			des_sk			= $28		; descriptor stack start address (temp strings)
    66
    67 				;			= $30		; End of descriptor stack
    68
    69 = 0031			ut1_pl			= $31		; utility pointer 1 low byte
    70 = 0032			ut1_ph			= ut1_pl+1	; utility pointer 1 high byte
    71 = 0033			ut2_pl			= $33		; utility pointer 2 low byte
    72 = 0034			ut2_ph			= ut2_pl+1	; utility pointer 2 high byte
    73
    74 = 0035			FACt_1			= $35		; FAC temp mantissa1
    75 = 0036			FACt_2			= FACt_1+1	; FAC temp mantissa2
    76 = 0037			FACt_3			= FACt_2+1	; FAC temp mantissa3
    77
    78 = 0036			dims_l			= FACt_2	; array dimension size low byte
    79 = 0037			dims_h			= FACt_3	; array dimension size high byte
    80
    81 = 0038			TempB			= $38		; temp page 0 byte
    82
    83 = 0039			Smeml			= $39		; start of mem low byte		(Start-of-Basic)
    84 = 003A			Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
    85 = 003B			Svarl			= $3B		; start of vars low byte	(Start-of-Variables)
    86 = 003C			Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
    87 = 003D			Sarryl			= $3D		; var mem end low byte		(Start-of-Arrays)
    88 = 003E			Sarryh			= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
    89 = 003F			Earryl			= $3F		; array mem end low byte	(End-of-Arrays)
    90 = 0040			Earryh			= Earryl+1	; array mem end high byte	(End-of-Arrays)
    91 = 0041			Sstorl			= $41		; string storage low byte	(String storage (moving down))
    92 = 0042			Sstorh			= Sstorl+1	; string storage high byte	(String storage (moving down))
    93 = 0043			Sutill			= $43		; string utility ptr low byte
    94 = 0044			Sutilh			= Sutill+1	; string utility ptr high byte
    95 = 0045			Ememl			= $45		; end of mem low byte		(Limit-of-memory)
    96 = 0046			Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
    97 = 0047			Clinel			= $47		; current line low byte		(Basic line number)
    98 = 0048			Clineh			= Clinel+1	; current line high byte	(Basic line number)
    99 = 0049			Blinel			= $49		; break line low byte		(Previous Basic line number)
   100 = 004A			Blineh			= Blinel+1	; break line high byte		(Previous Basic line number)
   101
   102 = 004B			Cpntrl			= $4B		; continue pointer low byte
   103 = 004C			Cpntrh			= Cpntrl+1	; continue pointer high byte
   104
   105 = 004D			Dlinel			= $4D		; current DATA line low byte
   106 = 004E			Dlineh			= Dlinel+1	; current DATA line high byte
   107
   108 = 004F			Dptrl			= $4F		; DATA pointer low byte
   109 = 0050			Dptrh			= Dptrl+1	; DATA pointer high byte
   110
   111 = 0051			Rdptrl			= $51		; read pointer low byte
   112 = 0052			Rdptrh			= Rdptrl+1	; read pointer high byte
   113
   114 = 0053			Varnm1			= $53		; current var name 1st byte
   115 = 0054			Varnm2			= Varnm1+1	; current var name 2nd byte
   116
   117 = 0055			Cvaral			= $55		; current var address low byte
   118 = 0056			Cvarah			= Cvaral+1	; current var address high byte
   119
   120 = 0057			Frnxtl			= $57		; var pointer for FOR/NEXT low byte
   121 = 0058			Frnxth			= Frnxtl+1	; var pointer for FOR/NEXT high byte
   122
   123 = 0057			Tidx1			= Frnxtl	; temp line index
   124
   125 = 0057			Lvarpl			= Frnxtl	; let var pointer low byte
   126 = 0058			Lvarph			= Frnxth	; let var pointer high byte
   127
   128 = 0059			prstk			= $59		; precedence stacked flag
   129
   130 = 005B			comp_f			= $5B		; compare function flag, bits 0,1 and 2 used
   131 									; bit 2 set if >
   132 									; bit 1 set if =
   133 									; bit 0 set if <
   134
   135 = 005C			func_l			= $5C		; function pointer low byte
   136 = 005D			func_h			= func_l+1	; function pointer high byte
   137
   138 = 005C			garb_l			= func_l	; garbage collection working pointer low byte
   139 = 005D			garb_h			= func_h	; garbage collection working pointer high byte
   140
   141 = 005E			des_2l			= $5E		; string descriptor_2 pointer low byte
   142 = 005F			des_2h			= des_2l+1	; string descriptor_2 pointer high byte
   143
   144 = 0060			g_step			= $60		; garbage collect step size
   145
   146 = 0061			Fnxjmp			= $61		; jump vector for functions
   147 = 0062			Fnxjpl			= Fnxjmp+1	; functions jump vector low byte
   148 = 0063			Fnxjph			= Fnxjmp+2	; functions jump vector high byte
   149
   150 = 0062			g_indx			= Fnxjpl	; garbage collect temp index
   151 					
   152 = 0063			FAC2_r			= $63		; FAC2 rounding byte
   153
   154 = 0064			Adatal			= $64		; array data pointer low byte
   155 = 0065			Adatah			= Adatal+1	; array data pointer high  byte
   156
   157 = 0064			Nbendl			= Adatal	; new block end pointer low byte
   158 = 0065			Nbendh			= Adatah	; new block end pointer high  byte
   159
   160 = 0066			Obendl			= $66		; old block end pointer low byte
   161 = 0067			Obendh			= Obendl+1	; old block end pointer high  byte
   162
   163 = 0068			numexp			= $68		; string to float number exponent count
   164 = 0069			expcnt			= $69		; string to float exponent count
   165
   166 = 0068			numbit			= numexp	; bit count for array element calculations
   167
   168 = 006A			numdpf			= $6A		; string to float decimal point flag
   169 = 006B			expneg			= $6B		; string to float eval exponent -ve flag
   170
   171 = 006A			Astrtl			= numdpf	; array start pointer low byte
   172 = 006B			Astrth			= expneg	; array start pointer high  byte
   173
   174 = 006A			Histrl			= numdpf	; highest string low byte
   175 = 006B			Histrh			= expneg	; highest string high  byte
   176
   177 = 006A			Baslnl			= numdpf	; BASIC search line pointer low byte
   178 = 006B			Baslnh			= expneg	; BASIC search line pointer high  byte
   179
   180 = 006A			Fvar_l			= numdpf	; find/found variable pointer low byte
   181 = 006B			Fvar_h			= expneg	; find/found variable pointer high  byte
   182
   183 = 006A			Ostrtl			= numdpf	; old block start pointer low byte
   184 = 006B			Ostrth			= expneg	; old block start pointer high  byte
   185
   186 = 006A			Vrschl			= numdpf	; variable search pointer low byte
   187 = 006B			Vrschh			= expneg	; variable search pointer high  byte
   188
   189 = 006C			FAC1_e			= $6C		; FAC1 exponent
   190 = 006D			FAC1_1			= FAC1_e+1	; FAC1 mantissa1
   191 = 006E			FAC1_2			= FAC1_e+2	; FAC1 mantissa2
   192 = 006F			FAC1_3			= FAC1_e+3	; FAC1 mantissa3
   193 = 0070			FAC1_s			= FAC1_e+4	; FAC1 sign (b7)
   194
   195 = 006C			str_ln			= FAC1_e	; string length
   196 = 006D			str_pl			= FAC1_1	; string pointer low byte
   197 = 006E			str_ph			= FAC1_2	; string pointer high byte
   198
   199 = 006E			des_pl			= FAC1_2	; string descriptor pointer low byte
   200 = 006F			des_ph			= FAC1_3	; string descriptor pointer high byte
   201
   202 = 006F			mids_l			= FAC1_3	; MID$ string temp length byte
   203
   204 = 0071			negnum			= $71		; string to float eval -ve flag
   205 = 0071			numcon			= $71		; series evaluation constant count
   206
   207 = 0072			FAC1_o			= $72		; FAC1 overflow byte
   208
   209 = 0073			FAC2_e			= $73		; FAC2 exponent
   210 = 0074			FAC2_1			= FAC2_e+1	; FAC2 mantissa1
   211 = 0075			FAC2_2			= FAC2_e+2	; FAC2 mantissa2
   212 = 0076			FAC2_3			= FAC2_e+3	; FAC2 mantissa3
   213 = 0077			FAC2_s			= FAC2_e+4	; FAC2 sign (b7)
   214
   215 = 0078			FAC_sc			= $78		; FAC sign comparison, Acc#1 vs #2
   216 = 0079			FAC1_r			= $79		; FAC1 rounding byte
   217
   218 = 0078			ssptr_l			= FAC_sc	; string start pointer low byte
   219 = 0079			ssptr_h			= FAC1_r	; string start pointer high byte
   220
   221 = 0078			sdescr			= FAC_sc	; string descriptor pointer
   222
   223 = 007A			csidx			= $7A		; line crunch save index
   224 = 007A			Asptl			= csidx		; array size/pointer low byte
   225 = 007B			Aspth			= $7B		; array size/pointer high byte
   226
   227 = 007A			Btmpl			= Asptl		; BASIC pointer temp low byte
   228 = 007B			Btmph			= Aspth		; BASIC pointer temp low byte
   229
   230 = 007A			Cptrl			= Asptl		; BASIC pointer temp low byte
   231 = 007B			Cptrh			= Aspth		; BASIC pointer temp low byte
   232
   233 = 007A			Sendl			= Asptl		; BASIC pointer temp low byte
   234 = 007B			Sendh			= Aspth		; BASIC pointer temp low byte
   235
   236 = 007C			LAB_IGBY		= $7C		; get next BASIC byte subroutine
   237
   238 = 0082			LAB_GBYT		= $82		; get current BASIC byte subroutine
   239 = 0083			Bpntrl			= $83		; BASIC execute (get byte) pointer low byte
   240 = 0084			Bpntrh			= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   241
   242 				;			= $97		; end of get BASIC char subroutine
   243
   244 				; Rbyte4,1,2,3 are moved to $1860 to free up ZP-use
   245 				; I2Cstat is moved to $180F
    35
    36 				; ------------------------------------------------
    37 				; DOS variables: $A0 to $A6, see boot.sys files
    38 				; ------------------------------------------------
    39 = 00A0			ZP_DOS          EQU     $A0		; Reserved for DOS and boot.sys
    40 = 00A0			CURR_DIR_ENTRY  EQU     ZP_DOS+$00      ; $A0..$A1 (16 bit) - pointer to current addressed directory entry
    41 = 00A2			MASK            EQU     ZP_DOS+$02	; $A2 Mask for FAT table
    42 = 00A3			BCNT            EQU     ZP_DOS+$03      ; $A3 Block Counter
    43 = 00A4			NCNT            EQU     ZP_DOS+$04	; $A4
    44 = 00A5			SCNT            EQU     ZP_DOS+$05	; $A5 Sector counter within a cluster
    45 = 00A6			RES             EQU     ZP_DOS+$06	; $A6
    46
    47 				; ------------------------------------------------
    48 				; FGC variables: $A8 to $BB, see FGC .asm files
    49 				; ------------------------------------------------
    50 = 00A8			ZP_FGC          EQU     $A8             ; Zero Page Base Address
    51 = 00A8			VPUMODE         EQU     ZP_FGC+$00      ; current VPU mode
    52 = 00A9			MAX_X           EQU     ZP_FGC+$01      ; max characters per line
    53 = 00AA			CURSOR_TICKS    EQU     ZP_FGC+$02      ; blink frequency in ticks (1/60 sec or 1/50 sec)
    54 = 00AB			CURSOR          EQU     ZP_FGC+$03      ; character under the cursor
    55 = 00AC			BUFFSIZE        EQU     ZP_FGC+$04      ; actual scroll buffer size
    56 = 00AD			PAGECNT         EQU     ZP_FGC+$05      ; page buffer counter
    57 = 00AE			TXTCOLOR        EQU     ZP_FGC+$06
    58 = 00AF			COLOR           EQU     ZP_FGC+$07
    59 = 00B2			POS_X           EQU     ZP_FGC+$0A      ; cursor X position (2-bytes)
    60 = 00B4			POS_Y           EQU     ZP_FGC+$0C      ; cursor Y position
    61 = 00B5			ADR_CHAR        EQU     ZP_FGC+$0D 	; 2-byte pointer
    62 = 00B7			FGC_ADR         EQU     ZP_FGC+$0F
    63 = 00B7			FGC_ADRL        EQU	ZP_FGC+$0F   	; last address Low
    64 = 00B8			FGC_ADRH      	EQU   	ZP_FGC+$10  	; last address High
    65 = 00B9			FGC_XREG        EQU     ZP_FGC+$11      ; current saved X register
    66 = 00BA			FGC_YREG        EQU     ZP_FGC+$12      ; current saved Y register
    67 = 00BB			VARSAV          EQU     ZP_FGC+$13      ; saved variable
    68
    69 				; ------------------------------------------------
    70 				; BIOS variables: $C0 to $FF
    71 				; ------------------------------------------------
    72 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    73 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    74 = 00C9			DEVID		EQU	$C9		; 1-byte temp device id (moved from $03 to avoid Basic collision)
    75 = 00CA			PRSTR		EQU	$CA		; 2-bytes replacement for PSTR
    76 = 00CC			END_PTR		EQU	$CC		; ROM end-pointer (2 bytes), also used by boot.sys
    77 = 00CE			ROM_PTR		EQU	$CE		; ROM pointer (2 bytes)
    78 = 00D0			ROM_CS		EQU	$D0		; ROM checksum counter (2 bytes)
    79 = 00D2			CFLBA0          EQU     $D2		; CF-card LBA 0 [0:7]
    80 = 00D3			CFLBA1          EQU     $D3		; CF-card LBA 1 [8:15]
    81 = 00D4			CFLBA2          EQU     $D4		; CF-card LBA 2 [16:23]
    82 = 00D5			CFLBA3          EQU     $D5		; CF-card LBA 3 [24:27]
    83 = 00D6			MSEC		EQU	$D6		; msec time-out counter
    84 = 00D7			RSTACT		EQU	$D7		; 1 = Reset Pending
    85 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register
    86 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register
    87 = 00DA			TICKCNT         EQU     $DA             ; current tick counter
    88 = 00DB			SD_TYPE		EQU	$DB		; SD Card Type: $00 Byte mode, $40 LBA mode
    89 = 00DC			BLKBUF		EQU	$DC             ; pointer to block buffer
    90 = 00DC			BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
    91 = 00DC			CRCL      	EQU   	$DC      	; XModem CRC lo byte
    92 = 00DD			BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
    93 = 00DD			CRCH      	EQU   	$DD     	; XModem CRC hi byte
    94 = 00DE			SD_CMD		EQU	$DE		; SD-Card CMD Byte
    95 = 00DE			RETRYL    	EQU   	$DE      	; XModem retry counter lo byte
    96 = 00DE			PDEV		EQU	$DE		; device descriptor pointer
    97 = 00DE			PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
    98 = 00DF			SD_PB3      	EQU   	$DF   		; SD-Card Parameter Byte 3
    99 = 00DF			RETRYH    	EQU   	$DF      	; XModem retry counter hi byte
   100 = 00DF			PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
   101
   102 = 00E0			SD_PB2		EQU   	$E0   		; SD-Card Parameter Byte 2
   103 = 00E0			BAUDRATE  	EQU   	$E0    		; ACIA current baud rate
   104 = 00E0			OPCODE		EQU	$E0		; DISASSEM current opcode
   105 = 00E0			I2C_DATA	EQU	$E0		; I2C current I2C data byte
   106 = 00E0			BLKEND      	EQU     $E0		; XModem block end flag
   107 = 00E1			KEY     	EQU     $E1   		; MON 1-byte Editor 
   108 = 00E1			SD_PB1      	EQU   	$E1   		; SD-Card Parameter Byte 1
   109 = 00E1			LINECNT		EQU	$E1		; DISASSEM number of disassembled lines
   110 = 00E1			BFLAG     	EQU   	$E1      	; XModem block flag
   111 = 00E2			BEGADR  	EQU     $E2   		; MON 2-byte Editor Begin Address Pointer
   112 = 00E2			SD_PB0		EQU	$E2   		; SD-Card Parameter Byte 0
   113 = 00E2			ADRMODE		EQU	$E2		; DISASSEM addressing mode
   114 = 00E2			BLKNO     	EQU   	$E2      	; XModem block number
   115 = 00E3			SD_CRC		EQU	$E3   		; SD-Card CRC Byte
   116 = 00E3			IBYTES		EQU	$E3		; DISASSEM instruction byte count
   117 = 00E3			ERRCNT    	EQU   	$E3      	; XModem error counter 10 is the limit
   118 = 00E4			ENDADR  	EQU     $E4   		; MON 2-byte Editor End Address Pointer
   119 = 00E4			VIA_STATUS 	EQU	$E4 		; VIA2 current VIA2 PortB output status
   120
   121 = 00E6			CURADR  	EQU     $E6   		; MON 2-byte Editor Current Address Pointer
   122 = 00E6			ASCL	  	EQU   	$E6     	; MON ASCII list start address low
   123 = 00E6			PLBA		EQU	$E6		; LBA pointer
   124 = 00E6			PLBAL		EQU	$E6		; LBA pointer low byte
   125 = 00E7			ASCH      	EQU   	$E7     	; MON ASCII list start address high
   126 = 00E7			PLBAH		EQU	$E7		; LBA pointer high byte
   127 = 00E8			CENDADR 	EQU     $E8   		; MON 2-byte Editor Current End Address Pointer
   128 = 00E8			STOL      	EQU   	$E8     	; MON store address Low
   129 = 00E9			STOH      	EQU   	$E9     	; MON store address High
   130 = 00EA			MOVADR  	EQU     $EA   		; MON 2-byte Editor 
   131 = 00EA			PSTR      	EQU   	$EA      	; ACIA output string Pointer
   132 = 00EA			PSTRL     	EQU   	$EA      	; ACIA lower address byte of output string pointer
   133 = 00EB			PSTRH     	EQU   	$EB      	; ACIA upper address byte of output string pointer
   134 = 00EC			TABLEA  	EQU     $EC   		; MON 2-byte Editor 
   135 = 00EC			WBUF      	EQU   	$EC      	; ACIA character output buffer
   136
   137 = 00EE			LABELS  	EQU     $EE   		; MON 1-byte Editor 
   138 = 00EE			PSAV            EQU     $EE		; Saved Partition Number in ASCII
   139 = 00EF			PCL		EQU	$EF		; CPU program counter Low
   140
   141 = 00F0			PCH		EQU	$F0		; CPU program counter High
   142 = 00F1			PREG		EQU	$F1		; CPU processor status register
   143 = 00F2			SPUSER		EQU	$F2		; CPU stack pointer
   144 = 00F2			DIVCHAR		EQU	$F2             ; CLOCK current divider char (. or / for date : for time)
   145 = 00F3			ACC		EQU	$F3		; CPU accumulator
   146 = 00F4			YREG		EQU	$F4		; CPU y-register
   147 = 00F5			XREG		EQU	$F5		; CPU x-register
   148 = 00F6			BYTES   	EQU     $F6   		; MON 1-byte Number of bytes to be displayed
   149 = 00F7			COUNT   	EQU     $F7   		; MON 1-byte
   150 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
   151 = 00F8			NUML      	EQU   	$F8     	; MON low number byte
   152 = 00F8			INL     	EQU     $F8   		; MON 1-byte hex display buffer
   153 = 00F9			INH     	EQU     $F9   		; MON 1-byte hex display buffer
   154 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
   155 = 00F9			NUMH	  	EQU   	$F9	 	; MON high number byte
   156 = 00FA			POINT   	EQU     $FA   		; MON 2-byte
   157 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
   158 = 00FA			ADRL      	EQU   	$FA     	; MON last address Low
   159 = 00FB			ADRH      	EQU   	$FB     	; MON last address High
   160 = 00FC			TEMP      	EQU   	$FC     	; MON temp storage
   161 = 00FD			TEMPX   	EQU     $FD   		; MON 1-byte temp. data-buffer
   162 = 00FD			YSAV      	EQU   	$FD     	; MON Y register storage
   163 = 00FE			NIBBLE  	EQU     $FE   		; MON 1-byte temp. data-buffer
   164 = 00FE			PDBCNT    	EQU   	$FE     	; MON number of printed data bytes
   165 = 00FF			MODE      	EQU   	$FF     	; MON current edit mode
   166
   167 				;------------------------------------------------------------------------------
   168 				; Junior Computer ][ BIOS & Monitor ADDRESS DEFINES
   169 				; $0100 - $01FF is reserved for the 6502 Stack
   170 				;------------------------------------------------------------------------------ 
   171
   172 				;----------------------------------------------------------------------------
   173 				; Block Device / Tables and Buffer Addresses
   174 				;----------------------------------------------------------------------------
   175 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
   176 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
   177 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
   178
   179 				; Current Volume Descriptor (32 Bytes) -----------------------------------------
   180 				; The BOOT routine in BIOS has already loaded the MBR into $0600, loaded the
   181 				; Volume-ID sector into $0400 and did set (most of) these variables.
   182 				; ------------------------------------------------------------------------------
   183 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor, used by boot.sys and mkbootcf
   184 = 0400			BOOT_PART       EQU     CURR_VOLUME     	; Boot Medium Descriptor: used by bios and mkbootcf
   185 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   186 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   187 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   188 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte or Partition Number in ASCII if harddisk
   189 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   190 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   191 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   192 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   193 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   194 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   195 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   196 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   197 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   198 = 0420			CURR_CLUSTER    EQU     CURR_VOLUME+$20         ; 4 Bytes - current addressed cluster in boot.sys
   199 = 0424			CURR_FAT_BLK    EQU     CURR_VOLUME+$24         ; 4 Bytes - current loaded FAT LBA in boot.sys
   200 = 0428			D_SUBDIR_NAME	EQU	CURR_VOLUME+$28		; ? Bytes - Name of entire path (root dir is \)
   201
   202 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices, used by boot.sys
   203
   204 = 0600			FAT_BUF		EQU	$0600           	; Buffer for FAT32 sector
   205 = 0600			BLOCK_BUF	EQU	$0600			; 1st sector of boot.sys is also stored here
   206 = 0600			MBR             EQU     BLOCK_BUF      		; Master Boot Block Code, contains a BNE to boot-code
   207 = 07BE			PART0		EQU	MBR + $01BE		; Partition 0 start
   208 = 07C6			PART0_RS	EQU	PART0 + 8 		; Partition 0 relative sector field
   209 = 07CE			PART0_SIZE	EQU	PART0 + 16		; Partition 0 sector size field
   210 = 07FE			BOOTBLK_TAG     EQU     MBR + $01FE           	; Address of Boot Block Tag ($55 $AA)
   211
   212 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   213 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   214
   215 				; IO Base Addresses ---------------------------------------------------------
   216 				;----------------------------------------------------------------------------
   217 = 0800			K2		EQU	$0800		; Base address of IO select K2
   218 = 0C00			K3		EQU	$0C00		; Base address of IO select K3 = IO2-card
   219 = 1000			K4		EQU	$1000		; Base address of IO select K4 = FGC-card
   220
   221 				;----------------------------------------------------------------------------
   222 				; CF-IDE Hardware Registers (on stand-alone card or IO2-board)
   223 				;----------------------------------------------------------------------------
   224 = 0C80			CFBASE		EQU 	K3 + $80	; Base card-address for CF card
   225 = 0C80			CFREG0		EQU	CFBASE+0	; Data port
   226 = 0C81			CFREG1		EQU	CFBASE+1	; Read: error-code, write: feature
   227 = 0C82			CFREG2		EQU	CFBASE+2	; Number of sectors to transfer
   228 = 0C83			CFREG3		EQU	CFBASE+3	; Sector address LBA 0 [0:7] (LSB)
   229 = 0C84			CFREG4		EQU	CFBASE+4	; Sector address LBA 1 [8:15]
   230 = 0C85			CFREG5		EQU	CFBASE+5	; Sector address LBA 2 [16:23]
   231 = 0C86			CFREG6		EQU	CFBASE+6	; Sector address LBA 3 [24:27] (MSB)
   232 = 0C87			CFREG7		EQU	CFBASE+7	; Read: Status, Write: Command
   233 = 0C88			CFREG8		EQU	CFBASE+8	; A write with 0x00 is a HW reset
   234
   235 				;----------------------------------------------------------------------------
   236 				; FGC / VIDEO Card Hardware Registers
   237 				;----------------------------------------------------------------------------
   238 = 1000			FGC_BASE        EQU     K4		; K4 base-address (fixed)
   239 = 1006			FGC_START_CONF  EQU     FGC_BASE+$06  	; prepare for DIP Switch reading
   240 = 1007			FGC_END_CONF    EQU     FGC_BASE+$07  	; read keyboard layout from DIP Switch settings
   241 = 1008			VPU_BASE        EQU     FGC_BASE+$08  	; VPU Register Base
   242 = 1008			VPU_PORT0       EQU     VPU_BASE      	; Data Port
   243 = 1009			VPU_PORT1       EQU     VPU_BASE+1    	; Control Port
   244 = 100A			VPU_PORT2       EQU     VPU_BASE+2    	; Color Pallete Port
   245 = 100B			VPU_PORT3       EQU     VPU_BASE+3    	; Indirect Register Port
   246 = 100C			PPI_PORTA       EQU     FGC_BASE+$0C  	; PIA Port A register
   247 = 100E			PPI_PORTC       EQU     FGC_BASE+$0E  	; PIA Port C
   248 = 100F			PPI_CONTROL     EQU     FGC_BASE+$0F  	; PIA Control register
   249
   250 = 1010			FGC_INFO        EQU     FGC_BASE+$10
   251 = 1013			FGC_SET_PAGE    EQU     FGC_BASE+$13
   252 = 1017			FGC_FDC_CMD     EQU     FGC_BASE+$17
   253 = 101F			FGC_VPU_CMD     EQU     FGC_BASE+$1F
   254 = 1027			FGC_VPU_OUT     EQU     FGC_BASE+$27
   255
   256 				; Buffers **********************************************************************
   257 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400
   258 = 1500			RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
   259
   260 				; ACIA Registers ***************************************************************
   261 = 1600			DATA_REG  	EQU   	$1600    	; ACIA Data Register
   262 = 1601			STAT_REG  	EQU   	$1601    	; ACIA Status Register
   263 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
   264 = 1603			CTRL_REG  	EQU   	$1603    	; ACIA Control Register
   265
   266 				; ATF1504 Memory Management Unit (MMU) Register ********************************
   267 = 1700			MMU		EQU	$1700		; MMU Register
   268
   269 				;------------------------------------------------------------------------------
   270 				; $1800 - $19FF 512 Bytes, previously unused, on JC2 v4.1 this has become RAM.
   271 				;------------------------------------------------------------------------------
   272 = 1800			PPORTLOAD	EQU	$1800		; jump location for test code
   273 = 1803			PPORTSAVE	EQU	$1803		; jump location for test code
   274 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
   275 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
   276 = 180A			RETURN_VECT     EQU     $180A           ; 2-byte return vector to monitor caller (moved from $01 to avoid Basic collision)
   277 = 180C			I2Cstat		EQU	$180C		; BASIC I2C read byte or ACK/NACK bit (moved from Basic $9C) 
   278 = 180D			KBD_LANG        EQU     $180D         	; Current selected keyboard language for FGC-card
   279 = 180E			FLOPPY_TYPE     EQU     $180E     	; floppy type settings for FGC-card
   280
   281 = 1810			NEXTINDEX       EQU     $1810		; command index
   282 = 1811			TERM_CHAR       EQU     $1811
   283 = 1812			F_ATTRIBS       EQU     $1812
   284 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
   285 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
   286 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
   287 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
   288 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
   289 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
   290 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
   291 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
   292 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
   293 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
   294 = 1828			DBG_PRINT	EQU	$1828		; 1 = Print debug info
   295
   296 				; INPBUF is the BASIC Input Buffer. It is defined from $1868 - $18FF
   297 				; Rbytes are moved from Basic $98..$9B to free up ZP-space
   298 = 1860			Rbyte4		EQU	$1860		; extra PRNG byte
   299 = 1861			Rbyte1		EQU	$1861		; most significant PRNG byte
   300 = 1862			Rbyte2		EQU	$1862		; middle PRNG byte
   301 = 1863			Rbyte3		EQU	$1863		; least significant PRNG byte
   302
   303 = 1868			INPBUF	  	EQU 	$1868		; change input buffer to last 151 bytes in page
   304 = 1868			ccflag		EQU	INPBUF		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   305 = 1869			ccbyte		EQU 	ccflag+1	; BASIC CTRL-C byte
   306 = 186A			ccnull		EQU 	ccbyte+1	; BASIC CTRL-C byte timeout
   307 = 186B			VEC_CC		EQU 	ccnull+1	; ctrl c check vector
   308
   309 				; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   310 = 187F			Ibuffs		EQU 	VEC_CC+$14	; start of input buffer after IRQ/NMI code
   311 = 18FE			Ibuffe		EQU 	Ibuffs+$7F	; end of input buffer
   312
   313 				;------------------------------------------------------------------------------
   314 				; $1A00 - $1AFF 256 Bytes, RIOT RAM area
   315 				;------------------------------------------------------------------------------
   316 = 1A00			IO_INFO         EQU     $1A00           ; Initialization info call for IO card
   317
   318 = 1A24			KEY_HANDLER     EQU     $1A24           ; character input handler
   319 = 1A26			NKEY_HANDLER    EQU     $1A26           ; no character input handler
   320 = 1A28			DEVLIST		EQU	$1A28		; start of device driver list
   321
   322 = 1A66			STDBEEP		EQU	$1A66		; current standard beep routine
   323 = 1A68			DEVIN		EQU	$1A68		; current opened device input routine
   324 = 1A6A			DEVOUT		EQU	$1A6A		; current opened device output routine
   325 = 1A6C			DEVCMD		EQU	$1A6C		; current opened device command routine
   326 = 1A6E			STDIN		EQU	$1A6E		; current standard input routine
   327 = 1A70			STDOUT		EQU	$1A70		; current standard output routine
   328 = 1A72			STDCMD		EQU	$1A72		; current standard command routine
   329 = 1A74			STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   330 = 1A75			STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   331 = 1A76			STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   332 = 1A77			STOACC		EQU	$1A77		; last accumulator before interrupt
   333
   334 				; Interrupt Vectors ************************************************************
   335 = 1A78			BRKUSR		EQU	$1A78		; address of user BREAK vector
   336 = 1A7A			NMIVECT		EQU     $1A7A           ; address of NMI vector
   337 = 1A7C			IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   338 = 1A7E			IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
   339
   340 				; Port Register ****************************************************************
   341 = 1A80			PAD		EQU     $1A80		; Port A Data Register
   342 = 1A81			PADD		EQU	$1A81		; Port A Data Direction Register
   343 = 1A82			PBD		EQU	$1A82		; Port B Data Register
   344 = 1A83			PBDD		EQU	$1A83		; Port B Data Direction Register
   345
   346 = 1A85			WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
   347 									; Read = get Edge Control Interrupt Register
   348
   349 				; Timer Register ***************************************************************
   350 = 1A94			CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   351 = 1A95			CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   352 = 1A96			CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   353 = 1A97			CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
   354 = 1A9F			CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
   355
   356 				;------------------------------------------------------------------------------
   357 				; $1B00 - $1BFF 256 Bytes, previously unused, on JC2 v4.1 this has become RAM.
   358 				;------------------------------------------------------------------------------
   359
   360 				;------------------------------------------------------------------------------
   361 				; $1C00 - $1FFF 1 KB, Monitor RAM area.
   362 				;------------------------------------------------------------------------------
   363 = 1C00			FILE_BUFF	EQU	$1C00		; 512 byte file buffer for .exe/.com/.bas in Monitor RAM
   364
   365 = 4000			BOOT_CODE       EQU 	$4000		; boot.sys address of 1st sector, used by mkboot and boot.sys
    25 						icl	"jc2_constants.inc"	; all JC-II related constants 
Source: jc2_constants.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor CONSTANTS
     3 				;------------------------------------------------------------------------------ 
     4
     5 				; PIA Register Indices *********************************************************
     6 = 000C			PIA_PORTA       EQU     $0C             ; Port A input/output register
     7 = 000D			PIA_PORTB       EQU     $0D             ; Port B input/output register
     8 = 000E			PIA_PORTC       EQU     $0E             ; Port C input/output register
     9 = 000F			PIA_CONTROL     EQU     $0F             ; Control/Setup register
    10
    11 				; Memory Management Unit (MMU) Register Indices ********************************
    12 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    13 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    14 = 0080			BAS_EN		EQU	$80		; PORTB bit 7: 1 = enable BASIC at $B000
    15
    16 				; MCP23017 I2C GPIO constants
    17 = 0040			MCP23017_I2C_0	EQU	$40		; I2C address of 1st MCP23017 on IO2 board
    18 = 0042			MCP23017_I2C_1	EQU	$42		; I2C address of 2nd MCP23017 on IO2 board
    19 = 0044			MCP23017_I2C_2	EQU	$44		; I2C address of 3rd MCP23017 on IO2 board
    20 = 0000			IODIRA		EQU	$00		; IO Direction register Port A (1=input, 0=output)
    21 = 0001			IODIRB		EQU	$01		; IO Direction register Port B (1=input, 0=output)
    22 = 0012			GPIOA		EQU	$12		; IO Port A, read and write
    23 = 0013			GPIOB		EQU	$13		; IO Port B, read and write
    24
    25 = 0068			I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
    26
    27 				; VIA 1 Register Indices ********************************************************
    28 = 0000			VIA_PORTB     	EQU  	$00  		; Port B input/output register
    29 = 0001			VIA_PORTA     	EQU  	$01  		; Port A input/output register
    30 = 0002			VIA_DDRB   	EQU  	$02		; Port B data direction register
    31 = 0003			VIA_DDRA   	EQU  	$03		; Port A data direction register
    32 = 0004			VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
    33 = 0005			VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
    34 = 0006			VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
    35 = 0007			VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
    36 = 0008			VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
    37 = 0009			VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
    38 = 000A			VIA_SR     	EQU  	$0A		; Shift register
    39 = 000B			VIA_ACR    	EQU  	$0B		; Auxilary control register
    40 = 000C			VIA_PCR    	EQU  	$0C		; Periheral control register
    41 = 000D			VIA_IFR    	EQU  	$0D		; Interrupt flag register
    42 = 000E			VIA_IER    	EQU  	$0E		; Interrupt enable register
    43 = 000F			VIA_PANOHS 	EQU  	$0F
    44
    45 				; VIA 2 Register Indices (IO2 board: SD-card, sound, etc.) *************************
    46 = 0010			PORTB     	EQU  	$10  		; Port B input/output register
    47 = 0011			PORTA     	EQU  	$11  		; Port A input/output register
    48 = 0012			DDRB   		EQU  	$12		; Port B data direction register
    49 = 0013			DDRA   		EQU  	$13		; Port A data direction register
    50 = 0014			T1CL   		EQU  	$14		; Timer 1 counter low byte register
    51 = 0015			T1CH   		EQU  	$15		; Timer 1 counter high byte register
    52 = 0016			T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
    53 = 0017			T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
    54 = 0018			T2CL   		EQU  	$18		; Timer 2 counter low byte register
    55 = 0019			T2CH   		EQU  	$19		; Timer 2 counter high byte register
    56 = 001A			SR     		EQU  	$1A		; Shift register
    57 = 001B			ACR    		EQU  	$1B		; Auxilary control register
    58 = 001C			PCR    		EQU  	$1C		; Peripheral control register
    59 = 001D			IFR    		EQU  	$1D		; Interrupt flag register
    60 = 001E			IER    		EQU  	$1E		; Interrupt enable register
    61 = 001F			PANOHS 		EQU  	$1F
    62
    63 = 0020			CENTURY		EQU	$20		; the 20th century. change to travel in time
    64 = 002E			DATEDIV		EQU	'.'		; divider char for date string
    65 = 003A			TIMEDIV		EQU	':'		; divider char for time string
    66 = 002A			MON_PROMPT    	EQU     '*'    		; prompt character for Monitor
    67 = 002D			ADIV      	EQU     '-'    		; address divider
    68
    69 = 005C			BSLASH          EQU     '\'             ; Backslash ASCII Code
    70 = 002F			FSLASH		EQU     '/'             ; Forward slash ASCII Code
    71 = 002E			DOT             EQU     '.'             ; Dot ASCII Code
    72 = 003A			COLON           EQU     ':'             ; Colon ASCII Code
    73 = 002C			COMMA           EQU     ','             ; Comma ASCII Code
    74 = 002D			MINUS           EQU     '-'             ; Minus ASCII Code
    75 = 005F			ULINE           EQU     '_'             ; Underline ASCII Code
    76
    77 				; Interchangeable Chars ********************************************************
    78 = 003E			DOS_PROMPT      EQU     '>'             ; Command Line Prompt Char
    79 = 002E			NUM_SEP         EQU     DOT	        ; Thousand Seperator Char
    80 = 005C			PATH_SEP        EQU     BSLASH          ; Path Separator Char
    81 = 002F			OPT_SEP         EQU     FSLASH          ; Option Prefix Char
    82
    83 = 0001			CRSR            EQU     $01             ; Cursor
    84 = 0001			SOH       	EQU     $01    		; start of header
    85 = 0004			EOT       	EQU     $04    		; end of text
    86 = 0006			ACK       	EQU     $06    		; acknowledged
    87 = 0008			BS        	EQU     $08    		; backspace key
    88 = 0009			TAB             EQU     $09             ; Horizontal Tab
    89 = 000B			UP              EQU     $0B             ; Up Arrow
    90 = 000D			CR        	EQU     $0D    		; carriage return
    91 = 000A			LF	  	EQU     $0A    		; line feed
    92 = 0015			RIGHT           EQU     $15             ; Right Arrow
    93 = 0015			NAK       	EQU     $15    		; not acknowledged
    94 = 0018			CAN		EQU     $18		; Cancel
    95 = 001B			ESC       	EQU     $1B    		; ESC
    96 = 0020			SPC		EQU     $20		; space char
    97 = 007F			DEL             EQU     $7F             ; Delete
    98
    99 				; Tape Reader/Writer Constants *************************************************
   100 = 0031			RPTIME		EQU	49		; read point time   49x8uS     = 392uS
   101
   102 				; Device Driver Constants ******************************************************
   103 = 0081			KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
   104
   105 = 0010			COM_DEV	        EQU	$10             ; COM devices base ID
   106 = 0020			STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
   107
   108 = 0000			NULL_ID		EQU	$00             ; the NULL device
   109
   110 = 0010			TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
   111 = 0011			PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
   112 = 0012			PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
   113 = 0013			KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
   114 = 0014			KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
   115 = 0015			VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
   116
   117 = 0020			XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
   118 = 0021			TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
   119 = 0022			FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
   120 = 0023			FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
   121 = 0024			SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
   122 = 0025			HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID (CF-card)
   123 = 0026			HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
   124
   125 				; Device Command Constants *****************************************************
   126 = 0000			CMD_INIT	EQU	0               ; Init device
   127 = 0001			CMD_IDENTIFY	EQU	1               ; Identify device
   128 = 0002			CMD_NORMAL	EQU	2               ; Set normal text
   129 = 0003			CMD_INVERSE	EQU	3               ; Set inverse text
   130 = 0004			CMD_FLASH	EQU	4               ; Set blinking text
   131 = 0005			CMD_HOME	EQU	5               ; Set cursor to home position
   132 = 0006			CMD_CLRLINE	EQU	6               ; Clear line at cursor
   133 = 0007			CMD_CLRSCRN	EQU	7               ; Clear screen
   134 = 0008			CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   135
   136 = 0010			CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   137 = 0011			CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
   138
   139 = 0020			CMD_LOAD	EQU	32              ; Load data byte from device
   140 = 0021			CMD_SAVE	EQU	33              ; Save data byte to device
   141 = 0022			CMD_READ	EQU	34              ; Read data block from device
   142 = 0023			CMD_WRITE	EQU	35              ; Write data block to device
   143 = 0024			CMD_BOOT        EQU     36              ; Boot from device
   144 = 0025			CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   145 = 0026			CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
   146
   147 				; File Attributes **************************************************************
   148 = 0001			FA_READONLY     EQU     $01            	; file is read only
   149 = 0002			FA_HIDDEN       EQU     $02            	; file is hidden
   150 = 0004			FA_SYSTEM       EQU     $04            	; file is a system file
   151 = 0008			FA_LABEL        EQU     $08            	; file is a volume label
   152 = 0010			FA_DIRECTORY    EQU     $10            	; file is a directory
   153 = 0020			FA_ARCHIVE      EQU     $20            	; file is modified
   154 = 0040			FA_RESERVED1    EQU     $40
   155 = 0080			FA_LINK         EQU     $80            	; file is a link
   156
   157 				; SD Command Constants *********************************************************
   158 = 0040			CMD0		EQU	$40		; Reset SD-Card
   159 = 0041			CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   160 = 0048			CMD8		EQU	CMD0 + 8	; Check voltage range
   161 = 004D			CMD13		EQU	CMD0 + 13	;
   162 = 0050			CMD16		EQU	CMD0 + 16	; Change block size
   163 = 0051			CMD17		EQU	CMD0 + 17	; Read single block
   164 = 0058			CMD24		EQU	CMD0 + 24	; Write single block
   165 = 0077			CMD55		EQU	CMD0 + 55	; Application command prefix
   166 = 007A			CMD58		EQU	CMD0 + 58	; Get OCR
   167 = 0069			ACMD41		EQU	CMD0 + 41	; Initialize SDC
   168
   169 = 00FE			DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
   170
   171 				; FAT Types ********************************************************************
   172 = 0002			FAT12_Type      EQU     $02
   173 = 0001			FAT16_Type      EQU     $01
   174 = 0000			FAT32_Type      EQU     $00
   175
   176 				; Directory Descriptor (32 Bytes) **********************************************
   177 				; Index of fields in a directory entry
   178 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   179 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   180 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   181 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   182 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   183 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   184 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   185 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   186 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   187 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   188 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   189
   190 				; FGC VPU Constants ************************************************************
   191
   192 				; Mode Registers
   193 = 0080			VPU_REG0        EQU     $80           ; Mode Register 0
   194 = 0081			VPU_REG1        EQU     VPU_REG0+1    ; Mode Register 1
   195 = 0088			VPU_REG8        EQU     VPU_REG0+8    ; Mode Register 2
   196 = 0089			VPU_REG9        EQU     VPU_REG0+9    ; Mode Register 3
   197
   198 				; Table Base Address Registers
   199 = 0082			VPU_REG2        EQU     VPU_REG0+2    ; Pattern name table base address register
   200 = 0083			VPU_REG3        EQU     VPU_REG0+3    ; Color table base address register low
   201 = 008A			VPU_REG10       EQU     VPU_REG0+10   ; Color table base address register high
   202 = 0084			VPU_REG4        EQU     VPU_REG0+4    ; Pattern generator table base address register
   203 = 0085			VPU_REG5        EQU     VPU_REG0+5    ; Sprite attribute table base address register low
   204 = 008B			VPU_REG11       EQU     VPU_REG0+11   ; Sprite attribute table base address register high
   205 = 0086			VPU_REG6        EQU     VPU_REG0+6    ; Sprite pattern generator table base address register
   206
   207 				; Color Registers
   208
   209 = 0087			VPU_REG7        EQU     VPU_REG0+7    ; Text color/Back drop color register
   210 = 008C			VPU_REG12       EQU     VPU_REG0+12   ; Text blink color/Back blink color register
   211 = 008D			VPU_REG13       EQU     VPU_REG0+13   ; Blinking period register
   212 = 0094			VPU_REG20       EQU     VPU_REG0+20   ; Color burst register 1
   213 = 0095			VPU_REG21       EQU     VPU_REG0+21   ; Color burst register 2
   214 = 0096			VPU_REG22       EQU     VPU_REG0+22   ; Color burst register 3
   215
   216 				; Display Registers
   217
   218 = 0092			VPU_REG18       EQU     VPU_REG0+18   ; Display adjust register
   219 = 0097			VPU_REG23       EQU     VPU_REG0+23   ; Display offset register
   220 = 0093			VPU_REG19       EQU     VPU_REG0+19   ; Interrupt line register
   221
   222 				; Access Registers
   223
   224 = 008E			VPU_REG14       EQU     VPU_REG0+14   ; VRAM Access base address register
   225 = 008F			VPU_REG15       EQU     VPU_REG0+15   ; Status register pointer
   226 = 0090			VPU_REG16       EQU     VPU_REG0+16   ; Color pallete address register
   227 = 0091			VPU_REG17       EQU     VPU_REG0+17   ; Control register pointer
   228
   229 				; Command Registers
   230
   231 = 00A0			VPU_REG32       EQU     VPU_REG0+32   ; Source X low register
   232 = 00A1			VPU_REG33       EQU     VPU_REG0+33   ; Source X high register
   233 = 00A2			VPU_REG34       EQU     VPU_REG0+34   ; Source Y low register
   234 = 00A3			VPU_REG35       EQU     VPU_REG0+35   ; Source Y high register
   235
   236 = 00A4			VPU_REG36       EQU     VPU_REG0+36   ; Destination X low register
   237 = 00A5			VPU_REG37       EQU     VPU_REG0+37   ; Destination X high register
   238 = 00A6			VPU_REG38       EQU     VPU_REG0+38   ; Destination Y low register
   239 = 00A7			VPU_REG39       EQU     VPU_REG0+39   ; Destination Y high register
   240
   241 = 00A8			VPU_REG40       EQU     VPU_REG0+40   ; Number of dots X low register
   242 = 00A9			VPU_REG41       EQU     VPU_REG0+41   ; Number of dots X high register
   243 = 00AA			VPU_REG42       EQU     VPU_REG0+42   ; Number of dots Y low register
   244 = 00AB			VPU_REG43       EQU     VPU_REG0+43   ; Number of dots Y high register
   245
   246 = 00AC			VPU_REG44       EQU     VPU_REG0+44   ; Color register
   247 = 00AD			VPU_REG45       EQU     VPU_REG0+45   ; Argument register
   248 = 00AE			VPU_REG46       EQU     VPU_REG0+46   ; Command register
   249
   250 				; Status Registers
   251
   252 = 0000			VPU_STAT0       EQU     0             ; Status register 0
   253 = 0001			VPU_STAT1       EQU     1             ; Status register 1
   254 = 0002			VPU_STAT2       EQU     2             ; Status register 2
   255 = 0003			VPU_STAT3       EQU     3             ; Status register 3
   256 = 0004			VPU_STAT4       EQU     4             ; Status register 4
   257 = 0005			VPU_STAT5       EQU     5             ; Status register 5
   258 = 0006			VPU_STAT6       EQU     6             ; Status register 6
   259 = 0007			VPU_STAT7       EQU     7             ; Status register 7
   260 = 0008			VPU_STAT8       EQU     8             ; Status register 8
   261 = 0009			VPU_STAT9       EQU     9             ; Status register 9
   262
   263 				; Basic Mode Settings
   264
   265 = 0000			VPU_MODE_REG0   EQU     $00           ; DG = 0, IE2 = 0, IE1 = 0, M3..5 = xxx
   266 = 0042			VPU_MODE_REG1   EQU     $42           ; BL = 1, IE0 = 0, M1..2 = xx, SI = 1, MA = 0,
   267 = 000A			VPU_MODE_REG2   EQU     $0A           ; MS = 0, LP = 0, CB = 0, VR = 1, SPD = 1, BW = 0
   268 = 0002			VPU_MODE_REG3   EQU     $02           ; LN = 0, S1 = 0, S0 = 0, IL = 0, E = 0,NT = 1, DC = 0
   269
   270 = 0010			VPU_MODE0       EQU     $10
   271 = 0012			VPU_MODE1       EQU     $12
   272 = 0003			VPU_MODE4       EQU     $03
   273 = 0004			VPU_MODE5       EQU     $04
   274 = 0005			VPU_MODE6       EQU     $05
   275 = 0007			VPU_MODE7       EQU     $07
   276
   277 						
    26 						icl	"jc2_macros.inc"	; JC-2 macro's for the MADS-assembler
Source: jc2_macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTRM	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	PHX					; Push X-register
    88 					TXA
    89 					PHA
    90 				.endm
    91
    92 				.macro	PLX					; Pull X-register
    93 					PLA
    94 					TAX
    95 				.endm
    96
    97 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    98 					LDX	#:n-1
    99 				lp	MVA	:src,X :dst,X-
   100 					BPL	lp
   101 				.endm
   102 					
   103 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
   104 					LDY	#:n-1
   105 				lp	MVA	:src,Y :dst,Y-
   106 					BPL	lp
   107 				.endm
   108
   109 				; Macros used for printing a cluster nr, which consists of 2 words
   110 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   111 						LDA	(:c),Y
   112 					ift :0>1	; st also given?
   113 						STA	:st
   114 					eif	
   115 						JSR	HEXOUT			; changes Y!
   116 				.endm		
   117
   118 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   119 						LDY	#:indx+1		; Print MSB of word
   120 					ift :0>2	; stor also given?	
   121 						PRCLB	:curr_dir :stor+1
   122 					els	
   123 						PRCLB	:curr_dir
   124 					eif
   125 						LDY	#:indx			; Print LSB of word
   126 					ift :0>2	; stor also given?	
   127 						PRCLB	:curr_dir :stor
   128 					els	
   129 						PRCLB	:curr_dir
   130 					eif
   131 				.endm
   132
   133 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   134 					ift :b2>7
   135 						ERT "Only bits 7-0 allowed"
   136 					els
   137 						LDA	:b1
   138 						AND	#(1 << :b2)
   139 						BEQ	:lbl1
   140 					eif
   141 				.endm
   142 					
   143 				; ----------------------------------------------
   144 				; Compare + Branch Macros
   145 				; ----------------------------------------------
   146 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   147 						CMP	:b1
   148 						BEQ	:lbl
   149 				.endm		; A is now not equal to b1
   150 					
   151 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   152 						CMP	:b1
   153 						BNE	:lbl
   154 				.endm		; A is now equal to b1
   155
   156 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   157 				CMP.CC	.macro ' '	b1 lbl
   158 						CMP	:b1			; 
   159 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   160 				.endm		; C is now 1 (A-b1 is >= 0)
   161
   162 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   163 				CMP.CS	.macro ' '	b1 lbl
   164 						CMP	:b1			; 
   165 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   166 				.endm		; C is now 0 (A-b1 is < 0)
   167
   168 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   169 						CPX	:b1
   170 						BEQ	:lbl
   171 				.endm		; X is now not equal to b1
   172 					
   173 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   174 						CPX	:b1
   175 						BNE	:lbl
   176 				.endm		; X is now equal to b1
   177
   178 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   179 				CPX.CC	.macro ' '	b1 lbl
   180 						CPX	:b1			; 
   181 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   182 				.endm		; C is now 1 (X-b1 is >= 0)
   183
   184 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   185 				CPX.CS	.macro ' '	b1 lbl
   186 						CPX	:b1			; 
   187 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   188 				.endm		; C is now 0 (X-b1 is < 0)
   189
   190 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   191 						CPY	:b1
   192 						BEQ	:lbl
   193 				.endm		; Y is now not equal to b1
   194 					
   195 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   196 						CPY	:b1
   197 						BNE	:lbl
   198 				.endm		; Y is now equal to b1
   199
   200 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   201 				CPY.CC	.macro ' '	b1 lbl
   202 						CPY	:b1			; 
   203 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   204 				.endm		; C is now 1 (Y-b1 is >= 0)
   205
   206 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   207 				CPY.CS	.macro ' '	b1 lbl
   208 						CPY	:b1			; 
   209 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   210 				.endm		; C is now 0 (Y-b1 is < 0)
   211
   212 				; ----------------------------------------------
   213 				; Increment/Decrement + Branch Macros
   214 				; ----------------------------------------------
   215 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   216 						DEC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   221 						DEC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   226 						INC	:b1
   227 						BEQ	:lbl
   228 				.endm
   229
   230 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   231 						INC	:b1
   232 						BNE	:lbl
   233 				.endm
   234
   235 				; ----------------------------------------------
   236 				DEX.NE	.macro 	lbl				; DEX + BNE
   237 						DEX
   238 						BNE	:lbl
   239 				.endm
   240
   241 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   242 						DEX
   243 						BEQ	:lbl
   244 				.endm
   245
   246 				DEX.PL	.macro 	lbl				; DEX + BPL 
   247 						DEX
   248 						BPL	:lbl
   249 				.endm
   250
   251 				DEX.MI	.macro 	lbl				; DEX + BMI
   252 						DEX
   253 						BMI	:lbl
   254 				.endm
   255
   256 				DEX.CC	.macro 	lbl				; DEX + BCC 
   257 						DEX
   258 						BCC	:lbl
   259 				.endm
   260
   261 				DEX.CS	.macro 	lbl				; DEX + BCS
   262 						DEX
   263 						BCS	:lbl
   264 				.endm
   265
   266 				; ----------------------------------------------
   267 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   268 						DEY
   269 						BEQ	:lbl
   270 				.endm
   271
   272 				DEY.NE	.macro 	lbl				; DEY + BNE
   273 						DEY
   274 						BNE	:lbl
   275 				.endm
   276
   277 				DEY.PL	.macro 	lbl				; DEY + BPL 
   278 						DEY
   279 						BPL	:lbl
   280 				.endm
   281
   282 				DEY.MI	.macro 	lbl				; DEY + BMI
   283 						DEY
   284 						BMI	:lbl
   285 				.endm
   286
   287 				DEY.CC	.macro 	lbl				; DEY + BCC 
   288 						DEY
   289 						BCC	:lbl
   290 				.endm
   291
   292 				DEY.CS	.macro 	lbl				; DEY + BCS
   293 						DEY
   294 						BCS	:lbl
   295 				.endm
   296 				; ----------------------------------------------
   297
   298 				; ----------------------------------------------
   299 				; LOAD/STORE + Branch Macros
   300 				; ----------------------------------------------
   301 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   302 						LDA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   307 						LDA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   312 						STA	:b1
   313 						BEQ	:lbl
   314 				.endm
   315
   316 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   317 						STA	:b1
   318 						BNE	:lbl
   319 				.endm
   320
   321 				; ----------------------------------------------
   322 				; AND/OR + Branch Macros
   323 				; ----------------------------------------------
   324 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   325 					ift :0>2	; LDA + AND + BEQ	
   326 						LDA	:p1
   327 						AND	:p2
   328 						BEQ	:p3
   329 					els		; AND + BEQ
   330 						AND	:p1
   331 						BEQ	:p2
   332 					eif
   333 				.endm
   334
   335 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   336 					ift :0>2	; LDA + AND + BNE	
   337 						LDA	:p1
   338 						AND	:p2
   339 						BNE	:p3
   340 					els		; AND + BNE
   341 						AND	:p1
   342 						BNE	:p2
   343 					eif
   344 				.endm
   345
   346 				.macro		ADCAW			; Add A to word and store in word
   347 						CLC
   348 						ADC	:1
   349 						STA	:1
   350 						LDA	:1+1
   351 						ADC	#0
   352 						STA	:1+1
   353 				.endm
    27
    28 						ORG	$8000
    29 8000 FF					.byte	$FF			; Fill entire eprom
    30 						
    31 8001					ORG	$9C00			; start address of 1K Monitor in 32K combined EPROM
    32 				;-------------------------------------------------------------------------------------------------------
    33 1C00			MONITOR_BLOCK	.local, $1C00
    34 				;-------------------------------------------------------------------------------------------------------
    35 1C00					icl 	"jc2_mon.asm"		; Monitor source-file
Source: jc2_mon.asm
     1 				;-------------------------------------------------------------------------------------------------------
     2 				; SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER
     3 				;
     4 				; Written by: A. NACHTMANN
     5 				; Date      :  7 FEB. 1980
     6 				;
     7 				; The features of Junior's monitor program are:
     8 				; - Hex address data display (entry via RST)
     9 				; - Hex editor (start address is $1CB5)
    10 				; - Hex assembler (start address is $1F51)
    11 				;----------------------------------------------------------------------------
    12 				; Original code restored and adapted for the 
    13 				; TASM (Telemark Assembler) by : A.J. Prosman, October 26, 2019
    14 				; MADS (MAD-Assembler) by : E. v.d. Logt,      December 2024
    15 				;----------------------------------------------------------------------------
    16
    17 				;       Beginners may load these locations
    18 				;       $1C00 for step by step modus and BRK command
    19
    20 				;----------------------------------------------------------------------------
    21 				;        JUNIOR'S MAIN ROUTINES
    22 				;----------------------------------------------------------------------------
    23 1C00 85 F3		SAVE    STA     ACC         ; Save ACCU
    24 1C02 68			        PLA                 ; Get current P-Register
    25 1C03 85 F1		        STA     PREG        ; Save P-Register
    26
    27 1C05 68			SAVEA   PLA                 ; Get current PCL
    28 1C06 85 EF		        STA	PCL         ; Save current PCL
    29 1C08 85 FA		        STA     POINT       ; PCL to display buffer
    30 1C0A 68			        PLA                 ; Get current PCH
    31 1C0B 85 F0		        STA     PCH         ; Save current PCH
    32 1C0D 85 FB		        STA     POINT+1     ; PCH to display buffer
    33
    34 1C0F 84 F4		SAVEB   STY     YREG        ; Save current Y-Register
    35 1C11 86 F5		        STX     XREG        ; Save current X-Register 
    36 1C13 BA			        TSX                 ; Get current SP
    37 1C14 86 F2		        STX     SPUSER      ; Save current SP
    38 1C16 A2 01		        LDX     #$01        ; Set AD-Mode
    39 1C18 86 FF		        STX     MODE
    40 1C1A 4C 33 1C		        JMP     START
    41
    42 				; RESET vector 6502
    43 1C1D A9 3F		RESET   LDA     #$3F        ; PB5---PB0
    44 1C1F 8D 83 1A		        STA     PBDD        ; IS output
    45 1C22 A9 04		        LDA     #$04        ; Reset P-Register
    46 1C24 85 F1		        STA     PREG
    47 1C26 A9 03		        LDA     #$03
    48 1C28 85 FF		        STA     MODE        ; Set AD-Mode
    49 1C2A 85 F6		        STA     BYTES       ; Display POINT, INH
    50 1C2C A2 FF		        LDX     #$FF
    51 1C2E 9A			        TXS 
    52 1C2F 86 F2		        STX     SPUSER
    53 1C31 D8			        CLD 
    54 1C32 78			        SEI 
    55
    56 1C33 20 88 1D		START   JSR     SCAND       ; Display data specified by POINT
    57 1C36 D0 FB		        BNE     START       ; Wait until key is released
    58
    59 1C38 20 88 1D		STARA   JSR     SCAND       ; Display data specified by point
    60 1C3B F0 FB		        BEQ     STARA       ;  Any key pressed
    61 1C3D 20 88 1D		        JSR     SCAND       ;  Debounce key
    62 1C40 F0 F6		        BEQ     STARA       ; Any key still pressed
    63 1C42 20 F9 1D		        JSR     GETKEY      ; If Yes, decode key, return with key in ACC
    64
    65 1C45 C9 13		GOEXEC  CMP     #$13        ; GO-Key ?
    66 1C47 D0 13		        BNE     ADMODE
    67 1C49 A6 F2		        LDX     SPUSER      ; Get current SP
    68 1C4B 9A			        TXS 
    69 1C4C A5 FB		        LDA     POINT+1     ; Start execution at POINT
    70 1C4E 48			        PHA 
    71 1C4F A5 FA		        LDA     POINT
    72 1C51 48			        PHA 
    73 1C52 A5 F1		        LDA     PREG        ; Restore current P register
    74 1C54 48			        PHA 
    75 1C55 A6 F5		        LDX     XREG
    76 1C57 A4 F4		        LDY     YREG
    77 1C59 A5 F3		        LDA     ACC
    78 1C5B 40			        RTI                 ; Execute program
    79
    80 1C5C C9 10		ADMODE  CMP     #$10        ; AD-Key ?
    81 1C5E D0 06		        BNE     DAMODE
    82 1C60 A9 03		        LDA     #$03        ; Set AD-Mode
    83 1C62 85 FF		        STA     MODE
    84 1C64 D0 14		        BNE     STEPA       ; Always
    85 				        
    86 1C66 C9 11		DAMODE  CMP     #$11        ; DA-Key ?
    87 1C68 D0 06		        BNE     STEP
    88 1C6A A9 00		        LDA     #$00        ; Set DA-Mode
    89 1C6C 85 FF		        STA     MODE
    90 1C6E F0 0A		        BEQ     STEPA
    91
    92 1C70 C9 12		STEP    CMP     #$12        ; PLUS-Key ?
    93 1C72 D0 09		        BNE     PCKEY
    94 1C74 E6 FA		        INC     POINT
    95 1C76 D0 02		        BNE     STEPA
    96 1C78 E6 FB		        INC     POINT+1
    97
    98 1C7A 4C 33 1C		STEPA   JMP     START
    99
   100 1C7D C9 14		PCKEY   CMP     #$14        ; PC-Key
   101 1C7F D0 0B		        BNE     ILLKEY
   102 1C81 A5 EF		        LDA     PCL
   103 1C83 85 FA		        STA     POINT      ; Last PC to display buffer
   104 1C85 A5 F0		        LDA     PCH
   105 1C87 85 FB		        STA     POINT+1
   106 1C89 4C 7A 1C		        JMP     STEPA
   107 				        
   108 1C8C C9 15		ILLKEY  CMP     #$15        ; Illegal key?
   109 1C8E 10 EA		        BPL     STEPA       ; If Yes, ignore it
   110
   111 1C90 85 E1		DATA    STA     KEY         ; Save key
   112 1C92 A4 FF		        LDY     MODE        ; Y=0 Is data mode, else address mode
   113 1C94 D0 0D		        BNE     ADDRESS
   114 1C96 B1 FA		        LDA     (POINT),Y   ; Get Data specified
   115 1C98 0A			        ASL                 ; by point
   116 1C99 0A			        ASL                 ; shift low order
   117 1C9A 0A			        ASL                 ; nibble into high order nibble
   118 1C9B 0A			        ASL      
   119 1C9C 05 E1		        ORA     KEY         ; Data with key
   120 1C9E 91 FA		        STA     (POINT),Y   ; Restore data
   121 1CA0 4C 7A 1C		        JMP     STEPA
   122
   123 1CA3 A2 04		ADDRESS LDX     #$04        ; 4 Shifts
   124 1CA5 06 FA		ADLOOP  ASL     POINT       ; POINT+1, POINT 4 Positions to the left
   125 1CA7 26 FB		        ROL     POINT+1
   126 1CA9 CA			        DEX 
   127 1CAA D0 F9		        BNE     ADLOOP
   128 1CAC A5 FA		        LDA     POINT
   129 1CAE 05 E1		        ORA     KEY         ; Restore address
   130 1CB0 85 FA		        STA     POINT
   131 1CB2 4C 7A 1C		        JMP     STEPA
   132
   133 				;-------------------------------------------------------------------------------
   134 				;       JUNIOR'S HEX EDITOR
   135 				;
   136 				;       FOLLOWING COMMANDS ARE VALID:
   137 				;       "INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
   138 				;       "INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
   139 				;       "SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2BYTE PATTERN
   140 				;       "SKIP": SKIP TO NEXT INSTRUCTION
   141 				;       "DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
   142 				;
   143 				;       AN ERROR IS INDICATED, IF THE INSTRUCTION POINTER CURAD IS OUT OF RANGE
   144 				;-------------------------------------------------------------------------------
   145 1CB5 20 D3 1E		EDITOR  JSR     BEGIN       ; CURAD := BEGAD
   146 1CB8 A4 E3		        LDY     BEGADR+1
   147 1CBA A6 E2		        LDX     BEGADR
   148 1CBC E8			        INX 
   149 1CBD D0 01		        BNE     EDIT
   150 1CBF C8			        INY 
   151
   152 1CC0 86 E8		EDIT    STX     CENDADR     ; CEND := BEGAD + 1
   153 1CC2 84 E9		        STY     CENDADR+1
   154 1CC4 A9 77		        LDA     #$77        ; Display "77"
   155 1CC6 A0 00		        LDY     #$00
   156 1CC8 91 E6		        STA     (CURADR),Y
   157 1CCA 20 4D 1D		CMND    JSR     SCAN        ; Display current instruction,
   158 				                            ; wait for a key
   159 1CCD C9 14		SEARCH  CMP     #$14        ; Search command ?
   160 1CCF D0 2A		        BNE     INSERT
   161 1CD1 20 6F 1D		        JSR     GETBYT      ; Read 1st byte
   162 1CD4 10 F7		        BPL     SEARCH      ; COM. Key ?
   163 1CD6 85 FB		        STA     POINT+1     ; Discard data
   164 1CD8 20 6F 1D		        JSR     GETBYT      ; Read 2nd byte
   165 1CDB 10 F0		        BPL     SEARCH      ; COM. Key ?
   166 1CDD 85 FA		        STA     POINT       ; Discard data
   167 1CDF 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   168
   169 1CE2 A0 00		SELOOP  LDY     #$00
   170 1CE4 B1 E6		        LDA     (CURADR),Y  ; Compare instruction
   171 1CE6 C5 FB		        CMP     POINT+1     ; against data to be searched
   172 1CE8 D0 07		        BNE     SEARA       ; Skip to the next instruction, if not equal
   173 1CEA C8			        INY 
   174 1CEB B1 E6		        LDA     (CURADR),Y
   175 1CED C5 FA		        CMP     POINT
   176 1CEF F0 D9		        BEQ     CMND        ; Return if 2byte pattern is found
   177
   178 1CF1 20 5C 1E		SEARA   JSR     OPLEN       ; Get length of the current instruction
   179 1CF4 20 F8 1E		        JSR     NEXT        ; Skip to the next instruction
   180 1CF7 30 E9		        BMI     SELOOP      ; Search again, if CURAD is less than CEND
   181 1CF9 10 3E		        BPL     ERRA
   182
   183 1CFB C9 10		INSERT  CMP     #$10        ; Insert command ?
   184 1CFD D0 0A		        BNE     INPUT
   185 1CFF 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   186 1D02 10 C9		        BPL     SEARCH      ; COM. key?
   187 1D04 20 47 1E		        JSR     FILLWS      ; Move data in WS downward by the amount in bytes
   188 1D07 F0 C1		        BEQ     CMND        ; Return to display the inserted instruction
   189
   190 1D09 C9 13		INPUT   CMP     #$13        ; Input command ?
   191 1D0B D0 14		        BNE     SKIP
   192 1D0D 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   193 1D10 10 BB		        BPL     SEARCH      ; COM. key ?
   194 1D12 20 5C 1E		        JSR     OPLEN       ; Length of the current instruction
   195 1D15 20 F8 1E		        JSR     NEXT        ; Return with N=1, if CURAD is less than CEND
   196 1D18 A5 FD		        LDA     TEMPX       ; Length of instr. to be inserted
   197 1D1A 85 F6		        STA     BYTES
   198 1D1C 20 47 1E		        JSR     FILLWS      ; Move data in ws downward by the amount in bytes
   199 1D1F F0 A9		        BEQ     CMND        ; Return to display the inserted data
   200
   201 1D21 C9 12		SKIP    CMP     #$12        ; Skip command ?
   202 1D23 D0 07		        BNE     DELETE
   203 1D25 20 F8 1E		        JSR     NEXT        ; Skip to next instruction. CURAD less than CEND?
   204 1D28 30 A0		        BMI     CMND
   205 1D2A 10 0D		        BPL     ERRA
   206
   207 1D2C C9 11		DELETE  CMP     #$11        ; Delete command ?
   208 1D2E D0 09		        BNE     ERRA
   209 1D30 20 83 1E		        JSR     UP          ; Delete current instruction by moving up the WS
   210 1D33 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   211 1D36 4C CA 1C		        JMP     CMND
   212
   213 1D39 A9 EE		ERRA    LDA     #$EE
   214 1D3B 85 FB		        STA     POINT+1
   215 1D3D 85 FA		        STA     POINT
   216 1D3F 85 F9		        STA     INH
   217 1D41 A9 03		        LDA     #$03
   218 1D43 85 F6		        STA     BYTES
   219
   220 1D45 20 8E 1D		ERRB    JSR     SCANDS      ; Display "EEEEEE" until key is released
   221 1D48 D0 FB		        BNE     ERRB
   222 1D4A 4C CA 1C		        JMP     CMND
   223
   224 				;----------------------------------------------------------------------------
   225 				;       EDITOR'S SUBROUTINES
   226 				;
   227 				;       SCAN is a subroutine, filling up the display-buffer determined by
   228 				;       CURADR. Then the display is scanned depending on the length of the  
   229 				;       instruction pointed to by CURADR if a keypress is detected.
   230 				;----------------------------------------------------------------------------
   231
   232 				;       SCAN RETURNS WITH VALUE IN A
   233 1D4D A2 02		SCAN    LDX     #$02        ; Fill up the display buffer
   234 1D4F A0 00		        LDY     #$00
   235
   236 1D51 B1 E6		FILBUF  LDA     (CURADR),Y  ; Start filling at OPCode
   237 1D53 95 F9		        STA     INH,X
   238 1D55 C8			        INY 
   239 1D56 CA			        DEX 
   240 1D57 10 F8		        BPL     FILBUF
   241 1D59 20 5C 1E		        JSR     OPLEN       ; Store instruction length in bytes
   242
   243 1D5C 20 8E 1D		SCANA   JSR     SCANDS      ; Display current instruction
   244 1D5F D0 FB		        BNE     SCANA       ; Key released ?
   245
   246 1D61 20 8E 1D		SCANB   JSR     SCANDS      ; Display current instruction
   247 1D64 F0 FB		        BEQ     SCANB       ; Any key pressed
   248 1D66 20 8E 1D		        JSR     SCANDS      ; Display current instruction
   249 1D69 F0 F6		        BEQ     SCANB       ; Any key still pressed ?
   250 1D6B 20 F9 1D		        JSR     GETKEY      ; If yes, return with key in ACC
   251 1D6E 60			        RTS 
   252
   253 				;----------------------------------------------------------------------------
   254 				;       GETBYT reads 2 hex-keys and composes their values in the A register.
   255 				;       If only hex-keys were pressed, it returns with N=1. If a command-key
   256 				;       was pressed, it returns with N=0;
   257 				;----------------------------------------------------------------------------
   258 1D6F 20 5C 1D		GETBYT  JSR     SCANA       ; Read high order nibble
   259 1D72 C9 10		        CMP     #$10
   260 1D74 10 11		        BPL     BYTEND      ; Command key ?
   261 1D76 0A			        ASL     
   262 1D77 0A			        ASL                 ; If not, save high order nibble
   263 1D78 0A			        ASL     
   264 1D79 0A			        ASL     
   265 1D7A 85 FE		        STA     NIBBLE
   266 1D7C 20 5C 1D		        JSR     SCANA       ; Read low order nibble
   267 1D7F C9 10		        CMP     #$10
   268 1D81 10 04		        BPL     BYTEND      ; Command key ?
   269 1D83 05 FE		        ORA     NIBBLE      ; If not, compose byte
   270 1D85 A2 FF		        LDX     #$FF        ; Set N=1
   271 1D87 60			BYTEND  RTS 
   272
   273 				;----------------------------------------------------------------------------
   274 				;       SCAND is a subroutine showing data specified by POINT.
   275 				;       SCANDS is a subroutine showing the contents of the display-buffer as
   276 				;       a function of BYTES.
   277 				;       The next subroutine AK scans the keyboard, it returns with A=0 if no
   278 				;       key was pressed and with A > 0 if a key was pressed.
   279 				;       When SCAND or SCANDS are exit, PA0..PA7 are set to input.
   280 				;----------------------------------------------------------------------------
   281 1D88 A0 00		SCAND   LDY     #$00
   282 1D8A B1 FA		        LDA     (POINT),Y   ; Get data specified by point
   283 1D8C 85 F9		        STA     INH
   284
   285 1D8E A9 7F		SCANDS  LDA     #$7F
   286 1D90 8D 81 1A		        STA     PADD        ; PA0..PA6 is output
   287 1D93 A2 08		        LDX     #$08        ; Enable display
   288 1D95 A4 F6		        LDY     BYTES       ; Fetch length from bytes
   289
   290 1D97 A5 FB		SCDSA   LDA     POINT+1     ; Output 1st byte
   291 1D99 20 CC 1D		        JSR     SHOW
   292 1D9C 88			        DEY 
   293 1D9D F0 0D		        BEQ     SCDSB       ; More bytes ?
   294 1D9F A5 FA		        LDA     POINT
   295 1DA1 20 CC 1D		        JSR     SHOW        ; If yes, output 2nd byte
   296 1DA4 88			        DEY 
   297 1DA5 F0 05		        BEQ     SCDSB       ; More bytes ?
   298 1DA7 A5 F9		        LDA     INH
   299 1DA9 20 CC 1D		        JSR     SHOW        ; If yes, output 3rd byte
   300
   301 1DAC A9 00		SCDSB   LDA     #$00
   302 1DAE 8D 81 1A		        STA     PADD        ; PA0..PA7 is input
   303 1DB1 A0 03		AK      LDY     #$03        ; Scan 3 rows
   304 1DB3 A2 00		        LDX     #$00        ; Reset row counter
   305
   306 1DB5 A9 FF		ONEKEY  LDA     #$FF
   307 1DB7 8E 82 1A		AKA     STX     PBD         ; Output row number
   308 1DBA E8			        INX                 ; Enable next row
   309 1DBB E8			        INX 
   310 1DBC 2D 80 1A		        AND     PAD         ; Input row pattern
   311 1DBF 88			        DEY                 ; All rows scanned ?
   312 1DC0 D0 F5		        BNE     AKA
   313 1DC2 A0 06		        LDY     #$06        ; Turn display off
   314 1DC4 8C 82 1A		        STY     PBD
   315 1DC7 09 80		        ORA     #$80        ; Set BIT7=1
   316 1DC9 49 FF		        EOR     #$FF        ; Invert key pattern
   317 1DCB 60			        RTS 
   318
   319 				;----------------------------------------------------------------------------
   320 				;       Subroutine SHOW copies the contents of a display-buffer to the display.
   321 				;       The X-register is used as a scan-counter. It determines if POINT+1,
   322 				;       POINT or INH is transported to the displays.
   323 				;----------------------------------------------------------------------------
   324 1DCC 48			SHOW    PHA                 ; Save display 
   325 1DCD 84 FC		        STY     TEMP        ; Save Y register
   326 1DCF 4A			        LSR     
   327 1DD0 4A			        LSR                 ; Get high order nibble
   328 1DD1 4A			        LSR     
   329 1DD2 4A			        LSR     
   330 1DD3 20 DF 1D		        JSR     CONVD       ; Output high order nibble
   331 1DD6 68			        PLA                 ; Get display again
   332 1DD7 29 0F		        AND     #$0F        ; Mask off high order nibble
   333 1DD9 20 DF 1D		        JSR     CONVD       ; Output low order nibble
   334 1DDC A4 FC		        LDY     TEMP
   335 1DDE 60			        RTS 
   336
   337 				;----------------------------------------------------------------------------
   338 				;       Subroutine CONVD controls the display scanning. It converts the
   339 				;       contents of the display-buffer to be displayed into a segment pattern.
   340 				;----------------------------------------------------------------------------
   341 1DDF A8			CONVD   TAY                 ; Use nibble as index
   342 1DE0 B9 0F 1F		        LDA     LOOK,Y      ; Fetch segment pattern
   343 1DE3 8D 80 1A		        STA     PAD         ; Output segment pattern
   344 1DE6 8E 82 1A		        STX     PBD         ; Output digit enable
   345 1DE9 A0 7F		        LDY     #$7F
   346
   347 1DEB 88			DELAY   DEY                 ; Delay 500uS approx
   348 1DEC 10 FD		        BPL     DELAY
   349 1DEE 8C 80 1A		        STY     PAD         ; Turns segments off
   350 1DF1 A0 06		        LDY     #$06
   351 1DF3 8C 82 1A		        STY     PBD         ; Turn display off
   352 1DF6 E8			        INX                 ; Enable next digit
   353 1DF7 E8			        INX 
   354 1DF8 60			        RTS 
   355
   356 				;----------------------------------------------------------------------------
   357 				;       GETKEY converts a key-press into a hex number. It returns with the
   358 				;       key value in A. 
   359 				;       If an invalid key was pressed ?
   360 				;----------------------------------------------------------------------------
   361 1DF9 A2 00		GETKEY  LDX     #$00        ; Start at row 0
   362 1DFB A0 01		GETKEA  LDY     #$01        ; Get one row
   363 1DFD 20 B5 1D		        JSR     ONEKEY      ; A=0, No key pressed
   364 1E00 D0 07		        BNE     KEYIN
   365 1E02 E0 06		        CPX     #$06
   366 1E04 D0 F5		        BNE     GETKEA      ; Each row scanned ?
   367 1E06 A9 15		        LDA     #$15        ; Return if invalid key
   368 1E08 60			        RTS 
   369
   370 1E09 A0 FF		KEYIN   LDY     #$FF
   371 1E0B 0A			KEYINA  ASL                 ; Shift left until Y=Key number
   372 1E0C B0 03		        BCS     KEYINB
   373 1E0E C8			        INY 
   374 1E0F 10 FA		        BPL     KEYINA
   375
   376 1E11 8A			KEYINB  TXA 
   377 1E12 29 0F		        AND     #$0F        ; Mask MSD
   378 1E14 4A			        LSR                 ; Divide by 2
   379 1E15 AA			        TAX 
   380 1E16 98			        TYA 
   381 1E17 10 03		        BPL     KEYIND
   382
   383 1E19 18			KEYINC  CLC 
   384 1E1A 69 07		        ADC     #$07        ; Add row offset
   385 1E1C CA			KEYIND  DEX 
   386 1E1D D0 FA		        BNE     KEYINC
   387 1E1F 60			        RTS 
   388
   389 				;----------------------------------------------------------------------------
   390 				;       RDINST transfers an instruction from the keyboard to the display-buffer. 
   391 				;       It returns with N=0 if a command-key was pressed. Once the entire
   392 				;       instruction is read, RDINST returns with N=1;
   393 				;----------------------------------------------------------------------------
   394 1E20 20 6F 1D		RDINST  JSR     GETBYT      ; Read OPCode
   395 1E23 10 21		        BPL     RDB         ; Return if it is the command key
   396 1E25 85 FB		        STA     POINT+1     ; Store OP cod in the display buffer
   397 1E27 20 60 1E		        JSR     LENACC      ; Calculate instruction length
   398 1E2A 84 F7		        STY     COUNT
   399 1E2C 84 FD		        STY     TEMPX
   400 1E2E C6 F7		        DEC     COUNT
   401 1E30 F0 12		        BEQ     RDA         ; 1 Byte instruction ?
   402 1E32 20 6F 1D		        JSR     GETBYT      ; If not, read first operand
   403 1E35 10 0F		        BPL     RDB         ; Return if it is the command key
   404 				        
   405 1E37 85 FA		        STA     POINT       ; Store 1st operand in the display buffer
   406 1E39 C6 F7		        DEC     COUNT
   407 1E3B F0 07		        BEQ     RDA         ; 2 Byte instruction ?
   408 				        
   409 1E3D 20 6F 1D		        JSR     GETBYT      ; If not, read second operand
   410 1E40 10 04		        BPL     RDB         ; Return if it is the command key
   411 				        
   412 1E42 85 F9		        STA     INH         ; Store 2nd operand in the display buffer
   413 1E44 A2 FF		RDA     LDX     #$FF        ; N=1
   414 1E46 60			RDB     RTS 
   415
   416 				;----------------------------------------------------------------------------
   417 				;       WILLWS transfers data from the display to the workspace. It always
   418 				;       returns with Z=1.
   419 				;----------------------------------------------------------------------------
   420 1E47 20 A6 1E		FILLWS  JSR     DOWN        ; Move data down by the amount in bytes
   421 1E4A 20 DC 1E		        JSR     ADCEND      ; Adjust current end address
   422 1E4D A2 02		        LDX     #$02
   423 1E4F A0 00		        LDY     #$00
   424 1E51 B5 F9		WS      LDA     INH,X       ; Fetch data from display buffer
   425 1E53 91 E6		        STA     (CURADR),Y  ; Insert data into the data field
   426 1E55 CA			        DEX 
   427 1E56 C8			        INY 
   428 1E57 C4 F6		        CPY     BYTES       ; All inserted ?
   429 1E59 D0 F6		        BNE     WS          ; If not, continue
   430 1E5B 60			        RTS 
   431
   432 				;----------------------------------------------------------------------------
   433 				;       OPLEN calculates the length of a 6502 instruction.
   434 				;       Instruction length is saved in BYTES.
   435 				;----------------------------------------------------------------------------
   436 1E5C A0 00		OPLEN   LDY     #$00
   437 1E5E B1 E6		        LDA     (CURADR),Y  ; Fetch OPCode from WS
   438 1E60 A0 01		LENACC  LDY     #$01        ; Length of the OPCode is 1 byte
   439 1E62 C9 00		        CMP     #$00
   440 1E64 F0 1A		        BEQ     LENEND      ; BRK Instruction ?
   441 				        
   442 1E66 C9 40		        CMP     #$40
   443 1E68 F0 16		        BEQ     LENEND      ; TRI Instruction ?
   444 				        
   445 1E6A C9 60		        CMP     #$60
   446 1E6C F0 12		        BEQ     LENEND      ; RTS Instruction ?
   447 				        
   448 1E6E A0 03		        LDY     #$03
   449 1E70 C9 20		        CMP     #$20
   450 1E72 F0 0C		        BEQ     LENEND      ; JSR Instruction ?
   451 				        
   452 1E74 29 1F		        AND     #$1F        ; Strip to 5 bits
   453 1E76 C9 19		        CMP     #$19
   454 1E78 F0 06		        BEQ     LENEND      ; Any ABS,Y instruction ?
   455 				        
   456 1E7A 29 0F		        AND     #$0F        ; Strip to 4 bits
   457 1E7C AA			        TAX                 ; Use nibble as index
   458 1E7D BC 1F 1F		        LDY     LEN,X       ; Fetch length from LEN
   459 1E80 84 F6		LENEND  STY     BYTES       ; Discard length in bytes
   460 1E82 60			        RTS 
   461
   462 				;----------------------------------------------------------------------------
   463 				;       UP moves a data-field between CURADR and CENDADR upwards by the
   464 				;       amount in BYTES.
   465 				;----------------------------------------------------------------------------
   466 1E83 A5 E6		UP      LDA     CURADR
   467 1E85 85 EA		        STA     MOVADR
   468 1E87 A5 E7		        LDA     CURADR+1    ; MOVAD := CURADR
   469 1E89 85 EB		        STA     MOVADR+1
   470 1E8B A4 F6		UPLOOP  LDY     BYTES
   471 1E8D B1 EA		        LDA     (MOVADR),Y  ; Move upward by the number of bytes
   472 1E8F A0 00		        LDY     #$00
   473 1E91 91 EA		        STA     (MOVADR),Y
   474 1E93 E6 EA		        INC     MOVADR
   475 1E95 D0 02		        BNE     UPA
   476 				        
   477 1E97 E6 EB		        INC     MOVADR+1    ; MOVADR+1 := MOVADR+1 + 1
   478 1E99 A5 EA		UPA     LDA     MOVADR
   479 1E9B C5 E8		        CMP     CENDADR
   480 1E9D D0 EC		        BNE     UPLOOP      ; All data moved ?
   481 1E9F A5 EB		        LDA     MOVADR+1    ; If not continue
   482 1EA1 C5 E9		        CMP     CENDADR+1
   483 1EA3 D0 E6		        BNE     UPLOOP
   484 1EA5 60			        RTS 
   485
   486 				;----------------------------------------------------------------------------
   487 				;       DOWN moves a data-field between CURADR and CENDADR downwards by the
   488 				;       amount in BYTES.
   489 				;----------------------------------------------------------------------------
   490 1EA6 A5 E8		DOWN    LDA     CENDADR
   491 1EA8 85 EA		        STA     MOVADR      ; MOVAD := CEND
   492 1EAA A5 E9		        LDA     CENDADR+1
   493 1EAC 85 EB		        STA     MOVADR+1
   494 1EAE A0 00		DNLOOP  LDY     #$00
   495 1EB0 B1 EA		        LDA     (MOVADR),Y  ; Move downward by the number of bytes
   496 1EB2 A4 F6		        LDY     BYTES
   497 1EB4 91 EA		        STA     (MOVADR),Y
   498 1EB6 A5 EA		        LDA     MOVADR
   499 1EB8 C5 E6		        CMP     CURADR
   500 1EBA D0 06		        BNE     DNA         ; All data moved ?
   501 				        
   502 1EBC A5 EB		        LDA     MOVADR+1    ; If not, continue
   503 1EBE C5 E7		        CMP     CURADR+1
   504 1EC0 F0 10		        BEQ     DNEND
   505 1EC2 38			DNA     SEC 
   506 1EC3 A5 EA		        LDA     MOVADR
   507 1EC5 E9 01		        SBC     #$01
   508 1EC7 85 EA		        STA     MOVADR
   509 1EC9 A5 EB		        LDA     MOVADR+1    ; MOVAD := MOVAD - 1
   510 1ECB E9 00		        SBC     #$00
   511 1ECD 85 EB		        STA     MOVADR+1
   512 1ECF 4C AE 1E		        JMP     DNLOOP
   513 1ED2 60			DNEND   RTS 
   514
   515 				;----------------------------------------------------------------------------
   516 				;       BEGIN sets CURADR TO BEGADR
   517 				;----------------------------------------------------------------------------
   518 1ED3 A5 E2		BEGIN   LDA     BEGADR
   519 1ED5 85 E6		        STA     CURADR
   520 1ED7 A5 E3		        LDA     BEGADR+1    ; CURAD := BEGADR
   521 1ED9 85 E7		        STA     CURADR+1
   522 1EDB 60			        RTS 
   523
   524 				;----------------------------------------------------------------------------
   525 				;       ADCEND increases the current end-address by the number in BYTES.
   526 				;----------------------------------------------------------------------------
   527 1EDC 18			ADCEND  CLC 
   528 1EDD A5 E8		        LDA     CENDADR
   529 1EDF 65 F6		        ADC     BYTES       ; CEND := CEND + BYTES
   530 1EE1 85 E8		        STA     CENDADR
   531 1EE3 A5 E9		        LDA     CENDADR+1
   532 1EE5 69 00		        ADC     #$00
   533 1EE7 85 E9		        STA     CENDADR+1
   534 1EE9 60			        RTS 
   535
   536 				;----------------------------------------------------------------------------
   537 				;       RECEND decreases the current end-address by the number in BYTES.
   538 				;----------------------------------------------------------------------------
   539 1EEA 38			RECEND  SEC 
   540 1EEB A5 E8		        LDA     CENDADR
   541 1EED E5 F6		        SBC     BYTES       ; CEND := CEND - BYTES
   542 1EEF 85 E8		        STA     CENDADR
   543 1EF1 A5 E9		        LDA     CENDADR+1
   544 1EF3 E9 00		        SBC     #$00
   545 1EF5 85 E9		        STA     CENDADR+1
   546 1EF7 60			        RTS 
   547
   548 				;----------------------------------------------------------------------------
   549 				;       NEXT increases the current displayed address by the number in BYTES.
   550 				;----------------------------------------------------------------------------
   551 1EF8 18			NEXT    CLC 
   552 1EF9 A5 E6		        LDA     CURADR
   553 1EFB 65 F6		        ADC     BYTES       ; CURAD := CURAD + BYTES
   554 1EFD 85 E6		        STA     CURADR
   555 1EFF A5 E7		        LDA     CURADR+1
   556 1F01 69 00		        ADC     #$00
   557 1F03 85 E7		        STA     CURADR+1
   558 1F05 38			        SEC 
   559 1F06 A5 E6		        LDA     CURADR
   560 1F08 E5 E8		        SBC     CENDADR
   561 1F0A A5 E7		        LDA     CURADR+1
   562 1F0C E5 E9		        SBC     CENDADR+1
   563 1F0E 60			        RTS 
   564
   565 				;----------------------------------------------------------------------------
   566 				;       Lookup table "LOOK"" is used to convert a hex number into a pattern
   567 				;       for the seven-segment displays. 
   568 				;       Lookup table "LEN" is used to convert an instruction into an 
   569 				;       instruction length.
   570 				;----------------------------------------------------------------------------
   571 1F0F 40			LOOK    .byte   $40         ; "0"
   572 1F10 79			        .byte   $79         ; "1"
   573 1F11 24			        .byte   $24         ; "2"
   574 1F12 30			        .byte   $30         ; "3"
   575 1F13 19			        .byte   $19         ; "4"
   576 1F14 12			        .byte   $12         ; "5"
   577 1F15 02			        .byte   $02         ; "6"
   578 1F16 78			        .byte   $78         ; "7"
   579 1F17 00			        .byte   $00         ; "8"
   580 1F18 10			        .byte   $10         ; "9"
   581 1F19 08			        .byte   $08         ; "A"
   582 1F1A 03			        .byte   $03         ; "B"
   583 1F1B 46			        .byte   $46         ; "C"
   584 1F1C 21			        .byte   $21         ; "D"
   585 1F1D 06			        .byte   $06         ; "E"
   586 1F1E 0E			        .byte   $0E         ; "F"
   587
   588 1F1F 02			LEN     .byte   $02
   589 1F20 02			        .byte   $02
   590 1F21 02			        .byte   $02
   591 1F22 01			        .byte   $01
   592 1F23 02			        .byte   $02
   593 1F24 02			        .byte   $02
   594 1F25 02			        .byte   $02
   595 1F26 01			        .byte   $01
   596 1F27 01			        .byte   $01
   597 1F28 02			        .byte   $02
   598 1F29 01			        .byte   $01
   599 1F2A 01			        .byte   $01
   600 1F2B 03			        .byte   $03
   601 1F2C 03			        .byte   $03
   602 1F2D 03			        .byte   $03
   603 1F2E 03			        .byte   $03
   604
   605 				; NMI and IRQ JMP vectors are now moved to jc2_main.asm
   606
   607 1F2F				ORG	$1F35		; maintain compatibility with original Monitor
   608 				;----------------------------------------------------------------------------
   609 				;       GETLBL is an assembler subroutine. It searches for labels on the
   610 				;       symbol pseudo stack. If this stack contains a valid label, it returns
   611 				;       with the high-order label address in X and the low-order label
   612 				;       address in A. If no valid label is found, it returns with Z=1.
   613 				;----------------------------------------------------------------------------
   614 1F35 B1 E6		GETLBL  LDA     (CURADR),Y  ; Fetch current label number from WS
   615 1F37 A0 FF		        LDY     #$FF        ; Reset pseudo stack
   616 1F39 C4 EE		SYMA    CPY     LABELS      ; Upper most symbol table address ?
   617 1F3B F0 0D		        BEQ     SYMB        ; If yes, return, no label on pseudo stack
   618 				        
   619 1F3D D1 EC		        CMP     (TABLEA),Y  ; Label Nr. in WS = Label Nr. on pseudo stack
   620 1F3F D0 0A		        BNE     SYMNXT
   621 				        
   622 1F41 88			        DEY                 ; If yes, get high order address
   623 1F42 B1 EC		        LDA     (TABLEA),Y
   624 1F44 AA			        TAX                 ; Discard high order, add in X
   625 1F45 88			        DEY 
   626 1F46 B1 EC		        LDA     (TABLEA),Y  ; Get low order add
   627 1F48 A0 01		        LDY     #$01        ; Prepare Y register
   628 1F4A 60			SYMB    RTS 
   629
   630 1F4B 88			SYMNXT  DEY                 ; *********   *********
   631 1F4C 88			        DEY                 ; * X=ADH *   * A=ADL *
   632 1F4D 88			        DEY                 ; *********   *********
   633 1F4E D0 E9		        BNE     SYMA
   634 1F50 60			        RTS 
   635
   636 				;----------------------------------------------------------------------------
   637 				;       ASSEMBLER main routine.
   638 				;
   639 				;       The following instructions are assembled:
   640 				;       - JSR instruction
   641 				;       - JMP instruction 
   642 				;       - BRANCH instructions
   643 				;----------------------------------------------------------------------------
   644 1F51 38			ASSEMB  SEC 
   645 1F52 A5 E4		        LDA     ENDADR
   646 1F54 E9 FF		        SBC     #$FF
   647 1F56 85 EC		        STA     TABLEA      ; TABLE := ENDAD - $FF
   648 1F58 A5 E5		        LDA     ENDADR+1
   649 1F5A E9 00		        SBC     #$00
   650 1F5C 85 ED		        STA     TABLEA+1
   651 1F5E A9 FF		        LDA     #$FF
   652 1F60 85 EE		        STA     LABELS
   653 1F62 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   654
   655 1F65 20 5C 1E		PASSA   JSR     OPLEN       ; Start pass one, get current instruction
   656 1F68 A0 00		        LDY     #$00
   657 1F6A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   658 1F6C C9 FF		        CMP     #$FF        ; Is the current instruction a label ? 
   659 1F6E D0 1D		        BNE     NXTINS
   660 				        
   661 1F70 C8			        INY 
   662 1F71 B1 E6		        LDA     (CURADR),Y  ; If yes, fetch label number
   663 1F73 A4 EE		        LDY     LABELS
   664 1F75 91 EC		        STA     (TABLEA),Y  ; Push label number on symbol stack
   665 1F77 88			        DEY 
   666 1F78 A5 E7		        LDA     CURADR+1    ; Get high order address
   667 1F7A 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   668 1F7C 88			        DEY 
   669 1F7D A5 E6		        LDA     CURADR      ; Get high order address
   670 1F7F 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   671 1F81 88			        DEY 
   672 1F82 84 EE		        STY     LABELS      ; Adjust pseudo stack pointer
   673 1F84 20 83 1E		        JSR     UP          ; Delete current label in ws
   674 1F87 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   675 1F8A 4C 65 1F		        JMP     PASSA       ; Look for more labels
   676
   677 1F8D 20 F8 1E		NXTINS  JSR     NEXT        ; If no label skip to the next instruction
   678 1F90 30 D3		        BMI     PASSA       ; All labels in WS collected ?
   679 1F92 20 D3 1E		        JSR     BEGIN       ; Start pass 2
   680 				        
   681 1F95 20 5C 1E		PASSB   JSR     OPLEN       ; Get length of the current instruction
   682 1F98 A0 00		        LDY     #$00
   683 1F9A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   684 1F9C C9 4C		        CMP     #$4C        ; JMP instruction ?
   685 1F9E F0 16		        BEQ     JUMPS
   686 				        
   687 1FA0 C9 20		        CMP     #$20        ; JSR Instruction ?
   688 1FA2 F0 12		        BEQ     JUMPS
   689 				        
   690 1FA4 29 1F		        AND     #$1F        ; Strip to 5 bits
   691 1FA6 C9 10		        CMP     #$10        ; Any branch instruction ?
   692 1FA8 F0 1A		        BEQ     BRINST
   693 				        
   694 1FAA 20 F8 1E		PB      JSR     NEXT        ; If not, return
   695 1FAD 30 E6		        BMI     PASSB       ; All labels between CURAD and ENDAD assembled ?
   696 				        
   697 1FAF A9 03		        LDA     #$03        ; Enable 3 display buffers
   698 1FB1 85 F6		        STA     BYTES
   699 1FB3 4C 33 1C		        JMP     START       ; Exit here
   700
   701 1FB6 C8			JUMPS   INY                 ; Set pointer to label number
   702 1FB7 20 35 1F		        JSR     GETLBL      ; Get label address
   703 1FBA F0 EE		        BEQ     PB          ; Return if not found
   704 				        
   705 1FBC 91 E6		        STA     (CURADR),Y  ; Store low order address
   706 1FBE 8A			        TXA 
   707 1FBF C8			        INY 
   708 1FC0 91 E6		        STA     (CURADR),Y  ; Store high order address
   709 1FC2 D0 E6		        BNE     PB
   710
   711 1FC4 C8			BRINST  INY                 ; Set pointer to label number
   712 1FC5 20 35 1F		        JSR     GETLBL      ; Get label address
   713 1FC8 F0 E0		        BEQ     PB          ; Return if label not found
   714 				        
   715 1FCA 38			        SEC 
   716 1FCB E5 E6		        SBC     CURADR      ; Calculate branch offset
   717 1FCD 38			        SEC 
   718 1FCE E9 02		        SBC     #$02        ; DESTINATION - SOURCE - 2 = OFFSET
   719 1FD0 91 E6		        STA     (CURADR),Y  ; Insert branch offset in WS
   720 1FD2 4C AA 1F		        JMP     PB
   721
   722 				;----------------------------------------------------------------------------
   723 				;       BRANCH calculates the offset of branch instructions. The 2 right-hand
   724 				;       displays show the calculated offset defined by the 4 left-hand
   725 				;       displays. The program must be stopped by the RESET key.
   726 				;----------------------------------------------------------------------------
   727 1FD5 D8			BRANCH  CLD 
   728 1FD6 A9 00		        LDA     #$00        ; Reset display buffer
   729 1FD8 85 FB		        STA     POINT+1
   730 1FDA 85 FA		        STA     POINT
   731 1FDC 85 F9		        STA     INH
   732 1FDE 20 6F 1D		BR      JSR     GETBYT      ; Read source
   733 1FE1 10 F2		        BPL     BRANCH      ; Command key ?
   734 				        
   735 1FE3 85 FB		        STA     POINT+1    ; Save source in buffer
   736 1FE5 20 6F 1D		        JSR     GETBYT      ; Read destination
   737 1FE8 10 EB		        BPL     BRANCH      ; Command key ?
   738
   739 1FEA 85 FA		        STA     POINT       ; Save destination in buffer
   740 1FEC 18			        CLC 
   741 1FED A5 FA		        LDA     POINT       ; Fetch destination
   742 1FEF E5 FB		        SBC     POINT+1     ; Substract source
   743 1FF1 85 F9		        STA     INH
   744 1FF3 C6 F9		        DEC     INH         ; Equalize and save offset in buffer
   745 1FF5 4C DE 1F		        JMP     BR
   746
   747 				;----------------------------------------------------------------------------
   748 				;       END OF JUNIOR'S MONITOR
   749 				;----------------------------------------------------------------------------
    36 				;-------------------------------------------------------------------------------------------------------
    37 1FF8			MONITOR_END	
    38 						.endl
    39 				;-------------------------------------------------------------------------------------------------------
    40
    41 9FF8					ORG 	$B000       		; start address of BASIC (12K)
    42 B000			RAM_TOP		icl 	"jc2_basic.asm"		; end of user RAM+1 (set as needed, should be page aligned)
Source: jc2_basic.asm
     1
     2 				; Enhanced BASIC ver 2.30
     3
     4 				; 2.00	new revision numbers start here
     5 				; 2.01	fixed LCASE$() and UCASE$()
     6 				; 2.02	new get value routine done
     7 				; 2.03	changed RND() to galoise method
     8 				; 2.04	fixed SPC()
     9 				; 2.05	new get value routine fixed
    10 				; 2.06	changed USR() code
    11 				; 2.07	fixed STR$()
    12 				; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    13 				; 2.09	fixed RND()
    14 				; 2.10	integrated missed changes from an earlier version
    15 				; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    16 				; 2.21	fixed IF .. THEN RETURN to not cause error
    17 				; 2.22	fixed RND() breaking the get byte routine
    18 				; 2.25  Emile: I2C addresses corrected for V1.1.4 bios and integrated with BIOS & MON source-files.
    19 				; 2.26  - I2Cout, I2Cin() and DOS commands added
    20 				;	- Destructive RAM memory test disabled
    21 				;       - Patches from EhBASIC 2.22 added: 
    22 				;         - RAM above code/Ibuff above patch (LAB_20DC)
    23 				;	  - Some function outputs (e.g. FRE()) limited to integers are negative (LAB_UAYFC)
    24 				;         - Use of decimal mode and invalid BCD (LAB_AL2X)
    25 				;	  - First statement after direct mode does not set continue pointer (LAB_1491, LAB_15C2, LAB_163B, LAB_CONT, LAB_1934)
    26 				;	  - String compare of equal strings in direct mode returns FALSE (LAB_1C25)
    27 				;	  - FALSE value stored to a variable after string compare is not exactly zero (LAB_LET)
    28 				;	  - Stack floor protection does not cater for background interrupts (LAB_1212)
    29 				;	  - Allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack (LAB_174D)
    30 				; 2.27	  - INPBUF moved from $768 to $1868. Also moved Decss, Decssp1, ADREL, ADREH, ADRSL, ADRSH to lower ZP-addresses
    31 				; 2.28	  Bugfix ADREL/ADREH, ADRSL/ADRSH. They had other names in BIOS, so should not be removed!
    32 				;	  Bugfix MODE and NUML/NUMH no init. in LAB_LOAD.
    33 				; 2.29	- PORTIO, PORT() and PORT commands extended with extra VIA and MCP23017 ports from JC2 V4.1 and IO2 boards
    34 				;       - SOUND command added
    35 				; 2.30  - ZP vars I2CStat, Decss, Decssp1 and Rbyte1..4 moved to other locations to free up ZP-space.
    36 				; ********************************************************************************************************
    37
    38 				; changes by Joerg Walke
    39 				; ----------------------
    40 				; 2022/05/14 added command BEEP
    41 				; 2022/05/15 added command PLIST
    42 				; 2022/05/16 changed BPL SwapErr to BNE SwapErr in LAB_SWAP to avoid command always throwing 'Type mismatch Error'
    43 				; 2024/02/03 Source adapted for MAD-Assembler
    44 				; ********************************************************************************************************
    45
    46 				; BASIC ZP variables moved to jc2_basic_zp_vars.inc
    47
    48 				; token values needed for BASIC
    49
    50 				; primary command tokens (can start a statement)
    51
    52 = 0080			TK_END		= $80			; END token
    53 = 0081			TK_FOR		= TK_END+1		; FOR token
    54 = 0082			TK_NEXT		= TK_FOR+1		; NEXT token
    55 = 0083			TK_DATA		= TK_NEXT+1		; DATA token
    56 = 0084			TK_INPUT	= TK_DATA+1		; INPUT token
    57 = 0085			TK_DIM		= TK_INPUT+1		; DIM token
    58 = 0086			TK_READ		= TK_DIM+1		; READ token
    59 = 0087			TK_LET		= TK_READ+1		; LET token
    60 = 0088			TK_DEC		= TK_LET+1		; DEC token
    61 = 0089			TK_GOTO		= TK_DEC+1		; GOTO token
    62 = 008A			TK_RUN		= TK_GOTO+1		; RUN token
    63 = 008B			TK_IF		= TK_RUN+1		; IF token
    64 = 008C			TK_RESTORE	= TK_IF+1		; RESTORE token
    65 = 008D			TK_GOSUB	= TK_RESTORE+1		; GOSUB token
    66 = 008E			TK_SOUND	= TK_GOSUB+1		; SOUND token
    67 = 008F			TK_RES2		= TK_SOUND+1		; RES2 token
    68 = 0090			TK_RETURN	= TK_RES2+1		; RETURN token
    69 = 0091			TK_REM		= TK_RETURN+1		; REM token
    70 = 0092			TK_STOP		= TK_REM+1		; STOP token
    71 = 0093			TK_ON		= TK_STOP+1		; ON token
    72 = 0094			TK_NULL		= TK_ON+1		; NULL token
    73 = 0095			TK_INC		= TK_NULL+1		; INC token
    74 = 0096			TK_WAIT		= TK_INC+1		; WAIT token
    75 = 0097			TK_LOAD		= TK_WAIT+1		; LOAD token
    76 = 0098			TK_SAVE		= TK_LOAD+1		; SAVE token
    77 = 0099			TK_DEF		= TK_SAVE+1		; DEF token
    78 = 009A			TK_POKE		= TK_DEF+1		; POKE token
    79 = 009B			TK_DOKE		= TK_POKE+1		; DOKE token
    80 = 009C			TK_CALL		= TK_DOKE+1		; CALL token
    81 = 009D			TK_DO		= TK_CALL+1		; DO token
    82 = 009E			TK_LOOP		= TK_DO+1		; LOOP token
    83 = 009F			TK_PRINT	= TK_LOOP+1		; PRINT token
    84 = 00A0			TK_CONT		= TK_PRINT+1		; CONT token
    85 = 00A1			TK_LIST		= TK_CONT+1		; LIST token
    86 = 00A2			TK_CLEAR	= TK_LIST+1		; CLEAR token
    87 = 00A3			TK_NEW		= TK_CLEAR+1		; NEW token
    88 = 00A4			TK_WIDTH	= TK_NEW+1		; WIDTH token
    89 = 00A5			TK_GET		= TK_WIDTH+1		; GET token
    90 = 00A6			TK_SWAP		= TK_GET+1		; SWAP token
    91 = 00A7			TK_BITSET	= TK_SWAP+1		; BITSET token
    92 = 00A8			TK_BITCLR	= TK_BITSET+1		; BITCLR token
    93 = 00A9			TK_RES3		= TK_BITCLR+1		; RES3 token
    94 = 00AA			TK_RES4		= TK_RES3+1		; RES4 token
    95 = 00AB			TK_BEEP		= TK_RES4+1		; BEEP token
    96 = 00AC			TK_PLIST    	= TK_BEEP+1		; PLIST token
    97 = 00AD			TK_HOME		= TK_PLIST+1		; HOME token
    98 = 00AE			TK_CLS		= TK_HOME+1		; CLS token
    99 = 00AF			TK_NORMAL	= TK_CLS+1		; NORMAL token
   100 = 00B0			TK_INVERSE	= TK_NORMAL+1		; INVERSE token
   101 = 00B1			TK_FLASH	= TK_INVERSE+1		; FLASH token
   102 = 00B2			TK_LOCATE	= TK_FLASH+1		; LOCATE token	
   103 = 00B3			TK_INNUM	= TK_LOCATE+1		; IN# token
   104 = 00B4			TK_PRNUM	= TK_INNUM+1		; PR# token
   105 = 00B5			TK_PORTIO	= TK_PRNUM+1		; PORTIO token
   106 = 00B6			TK_PORTOUT	= TK_PORTIO+1		; PORTOUT token
   107 = 00B7			TK_SCREEN	= TK_PORTOUT+1		; SCREEN token ###
   108 = 00B8			TK_PIXEL	= TK_SCREEN+1		; PIXEL token ###
   109 = 00B9			TK_LINE		= TK_PIXEL+1		; LINE token ###
   110 = 00BA			TK_OVAL		= TK_LINE+1		; OVAL token ###
   111 = 00BB			TK_RECT		= TK_OVAL+1		; RECT token ###
   112 = 00BC			TK_COLOR	= TK_RECT+1		; COLOR token ###
   113 = 00BD			TK_DELAY	= TK_COLOR+1		; DELAY token
   114 = 00BE			TK_I2COUT	= TK_DELAY+1		; I2Cout token
   115 = 00BF			TK_DOS		= TK_I2COUT+1		; DOS token
   116
   117 				; secondary command tokens, can't start a statement
   118
   119 = 00C0			TK_TAB		= TK_DOS+1		; TAB token
   120 = 00C1			TK_ELSE		= TK_TAB+1		; ELSE token
   121 = 00C2			TK_TO		= TK_ELSE+1		; TO token
   122 = 00C3			TK_FN		= TK_TO+1		; FN token
   123 = 00C4			TK_SPC		= TK_FN+1		; SPC token
   124 = 00C5			TK_THEN		= TK_SPC+1		; THEN token
   125 = 00C6			TK_NOT		= TK_THEN+1		; NOT token
   126 = 00C7			TK_STEP		= TK_NOT+1		; STEP token
   127 = 00C8			TK_UNTIL	= TK_STEP+1		; UNTIL token
   128 = 00C9			TK_WHILE	= TK_UNTIL+1		; WHILE token
   129 = 00CA			TK_OFF		= TK_WHILE+1		; OFF token, removed!
   130
   131 				; opperator tokens
   132
   133 = 00CB			TK_PLUS		= TK_OFF+1		; + token
   134 = 00CC			TK_MINUS	= TK_PLUS+1		; - token
   135 = 00CD			TK_MUL		= TK_MINUS+1		; * token
   136 = 00CE			TK_DIV		= TK_MUL+1		; / token
   137 = 00CF			TK_MOD		= TK_DIV+1		; MOD token ###
   138 = 00D0			TK_POWER	= TK_MOD+1		; ^ token
   139 = 00D1			TK_AND		= TK_POWER+1		; AND token
   140 = 00D2			TK_EOR		= TK_AND+1		; EOR token
   141 = 00D3			TK_OR		= TK_EOR+1		; OR token
   142 = 00D4			TK_RSHIFT	= TK_OR+1		; RSHIFT token
   143 = 00D5			TK_LSHIFT	= TK_RSHIFT+1		; LSHIFT token
   144 = 00D6			TK_GT		= TK_LSHIFT+1		; > token
   145 = 00D7			TK_EQUAL	= TK_GT+1		; = token
   146 = 00D8			TK_LT		= TK_EQUAL+1		; < token
   147
   148 				; functions tokens
   149
   150 = 00D9			TK_SGN		= TK_LT+1		; SGN token
   151 = 00DA			TK_INT		= TK_SGN+1		; INT token
   152 = 00DB			TK_ABS		= TK_INT+1		; ABS token
   153 = 00DC			TK_USR		= TK_ABS+1		; USR token
   154 = 00DD			TK_FRE		= TK_USR+1		; FRE token
   155 = 00DE			TK_POS		= TK_FRE+1		; POS token
   156 = 00DF			TK_SQR		= TK_POS+1		; SQR token
   157 = 00E0			TK_RND		= TK_SQR+1		; RND token
   158 = 00E1			TK_LOG		= TK_RND+1		; LOG token
   159 = 00E2			TK_EXP		= TK_LOG+1		; EXP token
   160 = 00E3			TK_COS		= TK_EXP+1		; COS token
   161 = 00E4			TK_SIN		= TK_COS+1		; SIN token
   162 = 00E5			TK_TAN		= TK_SIN+1		; TAN token
   163 = 00E6			TK_ATN		= TK_TAN+1		; ATN token
   164 = 00E7			TK_PEEK		= TK_ATN+1		; PEEK token
   165 = 00E8			TK_DEEK		= TK_PEEK+1		; DEEK token
   166 = 00E9			TK_SADD		= TK_DEEK+1		; SADD token
   167 = 00EA			TK_LEN		= TK_SADD+1		; LEN token
   168 = 00EB			TK_STRS		= TK_LEN+1		; STR$ token
   169 = 00EC			TK_VAL		= TK_STRS+1		; VAL token
   170 = 00ED			TK_ASC		= TK_VAL+1		; ASC token
   171 = 00EE			TK_UCASES	= TK_ASC+1		; UCASE$ token
   172 = 00EF			TK_LCASES	= TK_UCASES+1		; LCASE$ token
   173 = 00F0			TK_CHRS		= TK_LCASES+1		; CHR$ token
   174 = 00F1			TK_HEXS		= TK_CHRS+1		; HEX$ token
   175 = 00F2			TK_BINS		= TK_HEXS+1		; BIN$ token
   176 = 00F3			TK_BITTST	= TK_BINS+1		; BITTST token
   177 = 00F4			TK_MAX		= TK_BITTST+1		; MAX token
   178 = 00F5			TK_MIN		= TK_MAX+1		; MIN token
   179 = 00F6			TK_PI		= TK_MIN+1		; PI token
   180 = 00F7			TK_TWOPI	= TK_PI+1		; TWOPI token
   181 = 00F8			TK_VPTR		= TK_TWOPI+1		; VARPTR token
   182 = 00F9			TK_LEFTS	= TK_VPTR+1		; LEFT$ token
   183 = 00FA			TK_RIGHTS	= TK_LEFTS+1		; RIGHT$ token
   184 = 00FB			TK_MIDS		= TK_RIGHTS+1		; MID$ token
   185 = 00FC			TK_PORTIN	= TK_MIDS+1		; PORTIN token
   186 = 00FD			TK_I2CIN	= TK_PORTIN+1		; I2CIN token
   187 = 00FE			TK_RES5		= TK_I2CIN+1		; RESERVED ###
   188 = 00FF			TK_RES6		= TK_RES5+1		; RESERVED ###
   189
   190 				; offsets from a base of X or Y
   191 = 0000			PLUS_0		= $00			; X or Y plus 0
   192 = 0001			PLUS_1		= $01			; X or Y plus 1
   193 = 0002			PLUS_2		= $02			; X or Y plus 2
   194 = 0003			PLUS_3		= $03			; X or Y plus 3
   195
   196 = 0100			LAB_STAK	= $0100			; stack bottom, no offset
   197 = 01FE			LAB_SKFE	= LAB_STAK+$FE		; flushed stack address
   198 = 01FF			LAB_SKFF	= LAB_STAK+$FF		; flushed stack address
   199
   200 = 2001			Ram_base	= $2001			; start of user RAM (set as needed, should be page aligned)
   201 = 0010			Stack_floor	= 16			; bytes left free on stack for background interrupts
   202
   203 				; INPBUF moved to jc2_defines.inc 
   204
   205 				; Constants defined for I2Cin() and I2Cout functions
   206 = 0001			I2C_STA		= 1			; I2Cout Start command
   207 = 0000			I2C_STAT	= 0			; I2Cin return I2Cstat value
   208 = 0001			I2C_RD_ACK	= 1			; I2Cin Read + ACK
   209 = 0002			I2C_RD_NAK	= 2			; I2Cin Read + NACK + Stop
   210 = 0003			I2C_STO		= 3			; I2Cin Stop only
   211
   212 				; BASIC cold start entry point
   213 				; new page $18 initialisation, copy block to ccflag on
   214 B000			LAB_COLD
   215 B000 A0 04			LDY	#PG2_TABE-PG2_TABS-1		; byte count-1
   216 B002			LAB_2D13
   217 B002 B9 CB D2			LDA	PG2_TABS,Y			; get byte
   218 B005 99 68 18			STA	ccflag,Y			; store in $1800 RAM area
   219 B008 88				DEY					; decrement count
   220 B009 10 F7			BPL	LAB_2D13			; loop if not done
   221
   222 B00B A2 FF			LDX	#$FF				; set byte
   223 B00D 86 48			STX	Clineh				; set current line high byte (set immediate mode)
   224 B00F 9A				TXS					; reset stack pointer
   225
   226 B010 A9 4C			LDA	#$4C				; code for JMP
   227 B012 85 61			STA	Fnxjmp				; save for jump vector for functions
   228
   229 				; copy block from LAB_2CEE to ZP $007C - $0097
   230 B014 A2 1C			LDX	#StrTab-LAB_2CEE		; set byte count
   231 B016			LAB_2D4E
   232 B016 BD CF D2			LDA	LAB_2CEE-1,X			; get byte from table
   233 B019 95 7B			STA	LAB_IGBY-1,X			; save byte in page zero
   234 B01B CA				DEX					; decrement count
   235 B01C D0 F8			BNE	LAB_2D4E			; loop if not all done
   236
   237 				; copy block from StrTab to ZP $0A - $12
   238 B01E			LAB_GMEM
   239 B01E A2 08			LDX	#EndTab-StrTab-1			; set byte count-1
   240 B020			TabLoop
   241 B020 BD EC D2			LDA	StrTab,X			; get byte from table
   242 B023 95 0A			STA	Usrjmp,X			; save byte in page zero
   243 B025 CA				DEX					; decrement count
   244 B026 10 F8			BPL	TabLoop				; loop if not all done
   245
   246 				; set-up start values
   247 B028 A9 00			LDA	#$00				; clear A
   248 B02A 85 72			STA	FAC1_o				; clear FAC1 overflow byte
   249 B02C 85 27			STA	last_sh				; clear descriptor stack top item pointer high byte
   250
   251 B02E A9 0E			LDA	#$0E				; set default tab size
   252 B030 85 24			STA	TabSiz				; save it
   253 B032 A9 03			LDA	#$03				; set garbage collect step size for descriptor stack
   254 B034 85 60			STA	g_step				; save it
   255 B036 A2 28			LDX	#des_sk				; descriptor stack start
   256 B038 86 25			STX	next_s				; set descriptor stack pointer
   257 B03A 20 4E B8			JSR	LAB_CRLF			; print CR/LF
   258 				; #########################	
   259 B03D 20 F5 D0			JSR	CLEAR_BASE			; clear first two bytes of memory to avoid crash
   260 				; #########################	
   261 B040 A9 F5			LDA	#<LAB_MSZM			; point to memory size message (low addr)
   262 B042 A0 D2			LDY	#>LAB_MSZM			; point to memory size message (high addr)
   263 B044 20 8F B8			JSR	LAB_18C3			; print null terminated string from memory
   264 				;	JSR	LAB_INLN			; print '? ' and get BASIC input
   265 B047 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   266 B049 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   267 				;	JSR	LAB_GBYT			; get last byte back
   268
   269 				;	BNE	LAB_2DAA			; branch if not null (user typed something)
   270
   271 				;	LDY	#$00				; else clear Y
   272 										; character was null so get memory size the hard way
   273 										; we get here with Y=0 and Itempl/h = Ram_base
   274 B04B			LAB_2D93	; Disable destructive RAM-test, which did set all available memory to $AA
   275 B04B A9 00			LDA	#<RAM_TOP			; A = LSB of RAM_TOP
   276 B04D A0 B0			LDY	#>RAM_TOP			; Y = MSB of RAM_TOP
   277 				;	INC	Itempl				; increment temporary integer low byte
   278 				;	BNE	LAB_2D99			; branch if no overflow
   279 				;
   280 				;	INC	Itemph				; increment temporary integer high byte
   281 				;	LDA	Itemph				; get high byte
   282 				;	CMP	#>RAM_TOP			; compare with top of RAM+1
   283 				;	BEQ	LAB_2DB6			; branch if match (end of user RAM)
   284 				;
   285 				;LAB_2D99
   286 				;	LDA	#$55				; set test byte
   287 				;	STA	(Itempl),Y			; save via temporary integer
   288 				;	CMP	(Itempl),Y			; compare via temporary integer
   289 				;	BNE	LAB_2DB6			; branch if fail
   290 				;
   291 				;	ASL					; shift test byte left (now $AA)
   292 				;	STA	(Itempl),Y			; save via temporary integer
   293 				;	CMP	(Itempl),Y			; compare via temporary integer
   294 				;	BEQ	LAB_2D93			; if ok go do next byte
   295 				;
   296 				;	BNE	LAB_2DB6			; branch if fail
   297 				;
   298 				;LAB_2DAA
   299 				;	JSR	LAB_2887			; get FAC1 from string
   300 				;	LDA	FAC1_e				; get FAC1 exponent
   301 				;	CMP	#$98				; compare with exponent = 2^24
   302 				;	BCS	LAB_GMEM			; if too large go try again
   303 				;
   304 				;	JSR	LAB_F2FU			; save integer part of FAC1 in temporary integer
   305 				;						; (no range check)
   306 				;
   307 				;LAB_2DB6
   308 				;	LDA	Itempl				; get temporary integer low byte
   309 				;	LDY	Itemph				; get temporary integer high byte
   310 				;	CPY	#<Ram_base+1			; compare with start of RAM+$100 high byte
   311 				;	BCC	LAB_GMEM			; if too small go try again
   312 				;
   313 				;
   314 				; uncomment these lines if you want to check on the high limit of memory. Note if
   315 				; RAM_TOP is set too low then this will fail. default is ignore it and assume the
   316 				; users know what they're doing!
   317
   318 				;	CPY	#>RAM_TOP			; compare with top of RAM high byte
   319 				;	BCC	MEM_OK				; branch if < RAM top
   320
   321 				;	BNE	LAB_GMEM			; if too large go try again
   322 										; else was = so compare low bytes
   323 				;	CMP	#<RAM_TOP			; compare with top of RAM low byte
   324 				;	BEQ	MEM_OK				; branch if = RAM top
   325
   326 				;	BCS	LAB_GMEM			; if too large go try again
   327 				;MEM_OK
   328 B04F 85 45			STA	Ememl				; set end of mem low byte
   329 B051 84 46			STY	Ememh				; set end of mem high byte
   330 B053 85 41			STA	Sstorl				; set bottom of string space low byte
   331 B055 84 42			STY	Sstorh				; set bottom of string space high byte
   332
   333 B057 A0 01			LDY	#<Ram_base			; set start addr low byte
   334 B059 A2 20			LDX	#>Ram_base			; set start addr high byte
   335 B05B 84 39			STY	Smeml				; save start of mem low byte
   336 B05D 86 3A			STX	Smemh				; save start of mem high byte
   337
   338 				; this line is only needed if Ram_base is not $xx00
   339
   340 				;	LDY	#$00				; clear Y
   341 B05F 98				TYA					; clear A
   342 B060 91 39			STA	(Smeml),Y			; clear first byte
   343 B062 E6 39			INC	Smeml				; increment start of mem low byte
   344
   345 				; these two lines are only needed if Ram_base is $xxFF
   346
   347 				;	BNE	LAB_2E05			; branch if no rollover
   348
   349 				;	INC	Smemh				; increment start of mem high byte
   350 B064			LAB_2E05
   351 B064 20 4E B8			JSR	LAB_CRLF			; print CR/LF
   352 B067 20 29 B3			JSR	LAB_1463			; do 'NEW' and 'CLEAR'
   353 B06A A5 45			LDA	Ememl				; get end of mem low byte
   354 B06C 38				SEC					; set carry for subtract
   355 B06D E5 39			SBC	Smeml				; subtract start of mem low byte
   356 B06F AA				TAX					; copy to X
   357 B070 A5 46			LDA	Ememh				; get end of mem high byte
   358 B072 E5 3A			SBC	Smemh				; subtract start of mem high byte
   359 B074 20 4D CA			JSR	LAB_295E			; print XA as unsigned integer (bytes free)
   360 B077 A9 0A			LDA	#<LAB_SMSG			; point to sign-on message (low addr)
   361 B079 A0 D3			LDY	#>LAB_SMSG			; point to sign-on message (high addr)
   362 B07B 20 8F B8			JSR	LAB_18C3			; print null terminated string from memory
   363 B07E A9 28			LDA	#<LAB_1274			; warm start vector low byte
   364 B080 A0 B1			LDY	#>LAB_1274			; warm start vector high byte
   365 B082 85 01			STA	Wrmjpl				; save warm start vector low byte
   366 B084 84 02			STY	Wrmjph				; save warm start vector high byte
   367 B086 6C 01 00			JMP	(Wrmjpl)			; go do warm start
   368
   369 				; open up space in memory
   370 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   371
   372 				; Nbendl,Nbendh - new block end address (A/Y)
   373 				; Obendl,Obendh - old block end address
   374 				; Ostrtl,Ostrth - old block start address
   375
   376 				; returns with ..
   377
   378 				; Nbendl,Nbendh - new block start address (high byte - $100)
   379 				; Obendl,Obendh - old block start address (high byte - $100)
   380 				; Ostrtl,Ostrth - old block start address (unchanged)
   381 B089			LAB_11CF
   382 B089 20 D6 B0			JSR	LAB_121F			; check available memory, 'Out of memory' error if no room
   383 										; addr to check is in AY (low/high)
   384 B08C 85 3F			STA	Earryl				; save new array mem end low byte
   385 B08E 84 40			STY	Earryh				; save new array mem end high byte
   386
   387 				; open up space in memory
   388 				; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   389 				; don't set array end
   390 B090			LAB_11D6
   391 B090 38				SEC					; set carry for subtract
   392 B091 A5 66			LDA	Obendl				; get block end low byte
   393 B093 E5 6A			SBC	Ostrtl				; subtract block start low byte
   394 B095 A8				TAY					; copy MOD(block length/$100) byte to Y
   395 B096 A5 67			LDA	Obendh				; get block end high byte
   396 B098 E5 6B			SBC	Ostrth				; subtract block start high byte
   397 B09A AA				TAX					; copy block length high byte to X
   398 B09B E8				INX					; +1 to allow for count=0 exit
   399 B09C 98				TYA					; copy block length low byte to A
   400 B09D F0 24			BEQ	LAB_120A			; branch if length low byte=0
   401
   402 										; block is (X-1)*256+Y bytes, do the Y bytes first
   403
   404 B09F 38				SEC					; set carry for add + 1, two's complement
   405 B0A0 49 FF			EOR	#$FF				; invert low byte for subtract
   406 B0A2 65 66			ADC	Obendl				; add block end low byte
   407
   408 B0A4 85 66			STA	Obendl				; save corrected old block end low byte
   409 B0A6 B0 03			BCS	LAB_11F3			; branch if no underflow
   410
   411 B0A8 C6 67			DEC	Obendh				; else decrement block end high byte
   412 B0AA 38				SEC					; set carry for add + 1, two's complement
   413 B0AB			LAB_11F3
   414 B0AB 98				TYA					; get MOD(block length/$100) byte
   415 B0AC 49 FF			EOR	#$FF				; invert low byte for subtract
   416 B0AE 65 64			ADC	Nbendl				; add destination end low byte
   417 B0B0 85 64			STA	Nbendl				; save modified new block end low byte
   418 B0B2 B0 08			BCS	LAB_1203			; branch if no underflow
   419
   420 B0B4 C6 65			DEC	Nbendh				; else decrement block end high byte
   421 B0B6 90 04			BCC	LAB_1203			; branch always
   422
   423 B0B8			LAB_11FF
   424 B0B8 B1 66			LDA	(Obendl),Y			; get byte from source
   425 B0BA 91 64			STA	(Nbendl),Y			; copy byte to destination
   426 B0BC			LAB_1203
   427 B0BC 88				DEY					; decrement index
   428 B0BD D0 F9			BNE	LAB_11FF			; loop until Y=0
   429
   430 										; now do Y=0 indexed byte
   431 B0BF B1 66			LDA	(Obendl),Y			; get byte from source
   432 B0C1 91 64			STA	(Nbendl),Y			; save byte to destination
   433 B0C3			LAB_120A
   434 B0C3 C6 67			DEC	Obendh				; decrement source pointer high byte
   435 B0C5 C6 65			DEC	Nbendh				; decrement destination pointer high byte
   436 B0C7 CA				DEX					; decrement block count
   437 B0C8 D0 F2			BNE	LAB_1203			; loop until count = $0
   438
   439 B0CA 60				RTS
   440
   441 				; check room on stack for A bytes
   442 				; stack too deep? do OM error
   443 B0CB			LAB_1212
   444 					.if	Stack_floor			; Stack floor protection patch
   445 B0CB 18				CLC					; prep ADC
   446 B0CC 69 10			ADC	#Stack_floor			; stack pointer lower limit before interrupts
   447 					.endif
   448 B0CE 85 38			STA	TempB				; save result in temp byte
   449 B0D0 BA				TSX					; copy stack
   450 B0D1 E4 38			CPX	TempB				; compare new 'limit' with stack
   451 B0D3 90 30			BCC	LAB_OMER			; if stack < limit do 'Out of memory' error then warm start
   452
   453 B0D5 60				RTS
   454
   455 				; check available memory, 'Out of memory' error if no room
   456 				; addr to check is in AY (low/high)
   457 B0D6			LAB_121F
   458 B0D6 C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   459 B0D8 90 2A			BCC	LAB_124B			; if less then exit (is ok)
   460
   461 B0DA D0 04			BNE	LAB_1229			; skip next test if greater (tested <)
   462
   463 										; high byte was =, now do low byte
   464 B0DC C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   465 B0DE 90 24			BCC	LAB_124B			; if less then exit (is ok)
   466
   467 										; addr is > string storage ptr (oops!)
   468 B0E0			LAB_1229
   469 B0E0 48				PHA					; push addr low byte
   470 B0E1 A2 08			LDX	#$08				; set index to save Adatal to expneg inclusive
   471 B0E3 98				TYA					; copy addr high byte (to push on stack)
   472
   473 										; save misc numeric work area
   474 B0E4			LAB_122D
   475 B0E4 48				PHA					; push byte
   476 B0E5 B5 63			LDA	Adatal-1,X			; get byte from Adatal to expneg ( ,$00 not pushed)
   477 B0E7 CA				DEX					; decrement index
   478 B0E8 10 FA			BPL	LAB_122D			; loop until all done
   479
   480 B0EA 20 AA C1			JSR	LAB_GARB			; garbage collection routine
   481
   482 										; restore misc numeric work area
   483 B0ED A2 00			LDX	#$00				; clear the index to restore bytes
   484 B0EF			LAB_1238
   485 B0EF 68				PLA					; pop byte
   486 B0F0 95 64			STA	Adatal,X			; save byte to Adatal to expneg
   487 B0F2 E8				INX					; increment index
   488 B0F3 E0 08			CPX	#$08				; compare with end + 1
   489 B0F5 30 F8			BMI	LAB_1238			; loop if more to do
   490
   491 B0F7 68				PLA					; pop addr high byte
   492 B0F8 A8				TAY					; copy back to Y
   493 B0F9 68				PLA					; pop addr low byte
   494 B0FA C4 42			CPY	Sstorh				; compare bottom of string mem high byte
   495 B0FC 90 06			BCC	LAB_124B			; if less then exit (is ok)
   496
   497 B0FE D0 05			BNE	LAB_OMER			; if greater do 'Out of memory' error then warm start
   498
   499 										; high byte was =, now do low byte
   500 B100 C5 41			CMP	Sstorl				; compare with bottom of string mem low byte
   501 B102 B0 01			BCS	LAB_OMER			; if >= do 'Out of memory' error then warm start
   502
   503 										; ok exit, carry clear
   504 B104			LAB_124B
   505 B104 60				RTS
   506
   507 				; do 'Out of memory' error then warm start
   508 B105			LAB_OMER
   509 B105 A2 0C			LDX	#$0C				; error code $0C ('Out of memory' error)
   510
   511 				; do error #X, then warm start
   512 B107			LAB_XERR
   513 B107 20 04 D1			JSR	LAB_SYSBEEP
   514 B10A 20 4E B8			JSR	LAB_CRLF			; print CR/LF
   515
   516 B10D BD 8C D9			LDA	LAB_BAER,X			; get error message pointer low byte
   517 B110 BC 8D D9			LDY	LAB_BAER+1,X			; get error message pointer high byte
   518 B113 20 8F B8			JSR	LAB_18C3			; print null terminated string from memory
   519
   520 B116 20 62 B3			JSR	LAB_1491			; flush stack and clear continue flag
   521 B119 A9 C9			LDA	#<LAB_EMSG			; point to ' Error' low addr
   522 B11B A0 DA			LDY	#>LAB_EMSG			; point to ' Error' high addr
   523 B11D			LAB_1269
   524 B11D 20 8F B8			JSR	LAB_18C3			; print null terminated string from memory
   525 B120 A4 48			LDY	Clineh				; get current line high byte
   526 B122 C8				INY					; increment it
   527 B123 F0 03			BEQ	LAB_1274			; go do warm start (was immediate mode)
   528
   529 										; else print line number
   530 B125 20 42 CA			JSR	LAB_2953			; print ' in line [LINE #]'
   531
   532 				; BASIC warm start entry point
   533 				; wait for Basic command
   534 B128			LAB_1274
   535 B128 A9 DA			LDA	#<LAB_RMSG			; point to 'Ready' message low byte
   536 B12A A0 DA			LDY	#>LAB_RMSG			; point to 'Ready' message high byte
   537
   538 B12C 20 8F B8			JSR	LAB_18C3			; go do print string
   539
   540 				; wait for Basic command (no 'Ready')
   541 B12F			LAB_127D
   542 B12F 20 15 B2			JSR	LAB_1357			; call for BASIC input
   543 B132			LAB_1280
   544 B132 86 83			STX	Bpntrl				; set BASIC execute pointer low byte
   545 B134 84 84			STY	Bpntrh				; set BASIC execute pointer high byte
   546 B136 20 82 00			JSR	LAB_GBYT			; scan memory
   547 B139 F0 F4			BEQ	LAB_127D			; loop while null
   548
   549 				; got to interpret input line now ..
   550 B13B A2 FF			LDX	#$FF				; current line to null value
   551 B13D 86 48			STX	Clineh				; set current line high byte
   552 B13F 90 06			BCC	LAB_1295			; branch if numeric character (handle new BASIC line)
   553
   554 										; no line number .. immediate mode
   555 B141 20 46 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   556 B144 4C C8 B4			JMP	LAB_15F6			; go scan and interpret code
   557
   558 				; handle new BASIC line
   559 B147			LAB_1295
   560 B147 20 11 B7			JSR	LAB_GFPN			; get fixed-point number into temp integer
   561 B14A 20 46 B2			JSR	LAB_13A6			; crunch keywords into Basic tokens
   562 B14D 84 1D			STY	Ibptr				; save index pointer to end of crunched line
   563 B14F 20 FD B2			JSR	LAB_SSLN			; search BASIC for temp integer line number
   564 B152 90 44			BCC	LAB_12E6			; branch if not found
   565
   566 										; aroooogah! line # already exists! delete it
   567 B154 A0 01			LDY	#$01				; set index to next line pointer high byte
   568 B156 B1 6A			LDA	(Baslnl),Y			; get next line pointer high byte
   569 B158 85 32			STA	ut1_ph				; save it
   570 B15A A5 3B			LDA	Svarl				; get start of vars low byte
   571 B15C 85 31			STA	ut1_pl				; save it
   572 B15E A5 6B			LDA	Baslnh				; get found line pointer high byte
   573 B160 85 34			STA	ut2_ph				; save it
   574 B162 A5 6A			LDA	Baslnl				; get found line pointer low byte
   575 B164 88				DEY					; decrement index
   576 B165 F1 6A			SBC	(Baslnl),Y			; subtract next line pointer low byte
   577 B167 18				CLC					; clear carry for add
   578 B168 65 3B			ADC	Svarl				; add start of vars low byte
   579 B16A 85 3B			STA	Svarl				; save new start of vars low byte
   580 B16C 85 33			STA	ut2_pl				; save destination pointer low byte
   581 B16E A5 3C			LDA	Svarh				; get start of vars high byte
   582 B170 69 FF			ADC	#$FF				; -1 + carry
   583 B172 85 3C			STA	Svarh				; save start of vars high byte
   584 B174 E5 6B			SBC	Baslnh				; subtract found line pointer high byte
   585 B176 AA				TAX					; copy to block count
   586 B177 38				SEC					; set carry for subtract
   587 B178 A5 6A			LDA	Baslnl				; get found line pointer low byte
   588 B17A E5 3B			SBC	Svarl				; subtract start of vars low byte
   589 B17C A8				TAY					; copy to bytes in first block count
   590 B17D B0 03			BCS	LAB_12D0			; branch if overflow
   591
   592 B17F E8				INX					; increment block count (correct for =0 loop exit)
   593 B180 C6 34			DEC	ut2_ph				; decrement destination high byte
   594 B182			LAB_12D0
   595 B182 18				CLC					; clear carry for add
   596 B183 65 31			ADC	ut1_pl				; add source pointer low byte
   597 B185 90 03			BCC	LAB_12D8			; branch if no overflow
   598
   599 B187 C6 32			DEC	ut1_ph				; else decrement source pointer high byte
   600 B189 18				CLC					; clear carry
   601
   602 										; close up memory to delete old line
   603 B18A			LAB_12D8
   604 B18A B1 31			LDA	(ut1_pl),Y			; get byte from source
   605 B18C 91 33			STA	(ut2_pl),Y			; copy to destination
   606 B18E C8				INY					; increment index
   607 B18F D0 F9			BNE	LAB_12D8			; while <> 0 do this block
   608
   609 B191 E6 32			INC	ut1_ph				; increment source pointer high byte
   610 B193 E6 34			INC	ut2_ph				; increment destination pointer high byte
   611 B195 CA				DEX					; decrement block count
   612 B196 D0 F2			BNE	LAB_12D8			; loop until all done
   613
   614 										; got new line in buffer and no existing same #
   615 B198			LAB_12E6
   616 B198 AD 7F 18			LDA	Ibuffs				; get byte from start of input buffer
   617 B19B F0 3F			BEQ	LAB_1319			; if null line just go flush stack/vars and exit
   618
   619 										; got new line and it isn't empty line
   620 B19D A5 45			LDA	Ememl				; get end of mem low byte
   621 B19F A4 46			LDY	Ememh				; get end of mem high byte
   622 B1A1 85 41			STA	Sstorl				; set bottom of string space low byte
   623 B1A3 84 42			STY	Sstorh				; set bottom of string space high byte
   624 B1A5 A5 3B			LDA	Svarl				; get start of vars low byte	(end of BASIC)
   625 B1A7 85 66			STA	Obendl				; save old block end low byte
   626 B1A9 A4 3C			LDY	Svarh				; get start of vars high byte	(end of BASIC)
   627 B1AB 84 67			STY	Obendh				; save old block end high byte
   628 B1AD 65 1D			ADC	Ibptr				; add input buffer pointer	(also buffer length)
   629 B1AF 90 01			BCC	LAB_1301			; branch if no overflow from add
   630
   631 B1B1 C8				INY					; else increment high byte
   632 B1B2			LAB_1301
   633 B1B2 85 64			STA	Nbendl				; save new block end low byte	(move to, low byte)
   634 B1B4 84 65			STY	Nbendh				; save new block end high byte
   635 B1B6 20 89 B0			JSR	LAB_11CF			; open up space in memory
   636 										; old start pointer Ostrtl,Ostrth set by the find line call
   637 B1B9 A5 3F			LDA	Earryl				; get array mem end low byte
   638 B1BB A4 40			LDY	Earryh				; get array mem end high byte
   639 B1BD 85 3B			STA	Svarl				; save start of vars low byte
   640 B1BF 84 3C			STY	Svarh				; save start of vars high byte
   641 B1C1 A4 1D			LDY	Ibptr				; get input buffer pointer	(also buffer length)
   642 B1C3 88				DEY					; adjust for loop type
   643 B1C4			LAB_1311
   644 B1C4 B9 7B 18			LDA	Ibuffs-4,Y			; get byte from crunched line
   645 B1C7 91 6A			STA	(Baslnl),Y			; save it to program memory
   646 B1C9 88				DEY					; decrement count
   647 B1CA C0 03			CPY	#$03				; compare with first byte-1
   648 B1CC D0 F6			BNE	LAB_1311			; continue while count <> 3
   649
   650 B1CE A5 12			LDA	Itemph				; get line # high byte
   651 B1D0 91 6A			STA	(Baslnl),Y			; save it to program memory
   652 B1D2 88				DEY					; decrement count
   653 B1D3 A5 11			LDA	Itempl				; get line # low byte
   654 B1D5 91 6A			STA	(Baslnl),Y			; save it to program memory
   655 B1D7 88				DEY					; decrement count
   656 B1D8 A9 FF			LDA	#$FF				; set byte to allow chain rebuild. if you didn't set this
   657 										; byte then a zero already here would stop the chain rebuild
   658 										; as it would think it was the [EOT] marker.
   659 B1DA 91 6A			STA	(Baslnl),Y			; save it to program memory
   660
   661 B1DC			LAB_1319
   662 B1DC 20 3E B3			JSR	LAB_1477			; reset execution to start, clear vars and flush stack
   663 B1DF A6 39			LDX	Smeml				; get start of mem low byte
   664 B1E1 A5 3A			LDA	Smemh				; get start of mem high byte
   665 B1E3 A0 01			LDY	#$01				; index to high byte of next line pointer
   666 B1E5			LAB_1325
   667 B1E5 86 31			STX	ut1_pl				; set line start pointer low byte
   668 B1E7 85 32			STA	ut1_ph				; set line start pointer high byte
   669 B1E9 B1 31			LDA	(ut1_pl),Y			; get it
   670 B1EB F0 18			BEQ	LAB_133E			; exit if end of program
   671
   672 				; rebuild chaining of Basic lines
   673 B1ED A0 04			LDY	#$04				; point to first code byte of line
   674 										; there is always 1 byte + [EOL] as null entries are deleted
   675 B1EF			LAB_1330
   676 B1EF C8				INY					; next code byte
   677 B1F0 B1 31			LDA	(ut1_pl),Y			; get byte
   678 B1F2 D0 FB			BNE	LAB_1330			; loop if not [EOL]
   679
   680 B1F4 38				SEC					; set carry for add + 1
   681 B1F5 98				TYA					; copy end index
   682 B1F6 65 31			ADC	ut1_pl				; add to line start pointer low byte
   683 B1F8 AA				TAX					; copy to X
   684 B1F9 A0 00			LDY	#$00				; clear index, point to this line's next line pointer
   685 B1FB 91 31			STA	(ut1_pl),Y			; set next line pointer low byte
   686 B1FD 98				TYA					; clear A
   687 B1FE 65 32			ADC	ut1_ph				; add line start pointer high byte + carry
   688 B200 C8				INY					; increment index to high byte
   689 B201 91 31			STA	(ut1_pl),Y			; save next line pointer low byte
   690 B203 90 E0			BCC	LAB_1325			; go do next line, branch always, carry clear
   691
   692
   693 B205			LAB_133E
   694 B205 4C 2F B1			JMP	LAB_127D			; else we just wait for Basic command, no 'Ready'
   695
   696 				; print '? ' and get BASIC input
   697 B208			LAB_INLN
   698 B208 20 A7 B8			JSR	LAB_18E3			; print '?' character
   699 B20B 20 A4 B8			JSR	LAB_18E0			; print ' '
   700 B20E D0 05			BNE	LAB_1357			; call for BASIC input and return
   701
   702 				; receive line from keyboard
   703 										; $08 as delete key (BACKSPACE on standard keyboard)
   704 B210			LAB_134B
   705 B210 20 A9 B8			JSR	LAB_PRNA			; go print the character
   706 B213 CA				DEX					; decrement the buffer counter (delete)
   707 B214 2C				.byte	$2C				; make LDX into BIT abs
   708
   709 				; call for BASIC input (main entry point)
   710 B215			LAB_1357
   711 B215 A2 00			LDX	#$00			; clear BASIC line buffer pointer
   712 B217			LAB_1359
   713 B217 20 C5 D2			JSR	V_INPT			; call scan input device
   714 B21A 90 FB			BCC	LAB_1359		; loop if no byte
   715
   716 B21C F0 F9			BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   717
   718 B21E C9 07			CMP	#$07			; compare with [BELL]
   719 B220 F0 10			BEQ	LAB_1378		; branch if [BELL]
   720
   721 B222 C9 0D			CMP	#$0D			; compare with [CR]
   722 B224 F0 19			BEQ	LAB_1384		; do CR/LF exit if [CR]
   723
   724 B226 E0 00			CPX	#$00			; compare pointer with $00
   725 B228 D0 04			BNE	LAB_1374		; branch if not empty
   726
   727 				; next two lines ignore any non print character and [SPACE] if input buffer empty
   728 B22A C9 21			CMP	#$21			; compare with [SP]+1
   729 B22C 90 E9			BCC	LAB_1359		; if < ignore character
   730
   731 B22E			LAB_1374
   732 B22E C9 08			CMP	#$08			; compare with [BACKSPACE] (delete last character)
   733 B230 F0 DE			BEQ	LAB_134B		; go delete last character
   734
   735 B232			LAB_1378
   736 B232 E0 7F			CPX	#Ibuffe-Ibuffs		; compare character count with max
   737 B234 B0 0C			BCS	LAB_138E		; skip store and do [BELL] if buffer full
   738
   739 B236 9D 7F 18			STA	Ibuffs,X		; else store in buffer
   740 B239 E8				INX				; increment pointer
   741 B23A			LAB_137F
   742 B23A 20 A9 B8			JSR	LAB_PRNA		; go print the character
   743 B23D D0 D8			BNE	LAB_1359		; always loop for next character
   744
   745 B23F			LAB_1384
   746 B23F 4C 45 B8			JMP	LAB_1866		; do CR/LF exit to BASIC
   747
   748 				; announce buffer full
   749 B242			LAB_138E
   750 B242 A9 07			LDA	#$07			; [BELL] character into A
   751 B244 D0 F4			BNE	LAB_137F		; go print the [BELL] but ignore input character
   752 									; branch always
   753
   754 				; crunch keywords into Basic tokens
   755 				; position independent buffer version ..
   756 				; faster, dictionary search version ....
   757 B246			LAB_13A6
   758 B246 A0 FF			LDY	#$FF			; set save index (makes for easy math later)
   759
   760 B248 38				SEC				; set carry for subtract
   761 B249 A5 83			LDA	Bpntrl			; get basic execute pointer low byte
   762 B24B E9 7F			SBC	#<Ibuffs		; subtract input buffer start pointer
   763 B24D AA				TAX				; copy result to X (index past line # if any)
   764
   765 B24E 86 20			STX	Oquote			; clear open quote/DATA flag
   766 B250			LAB_13AC
   767 B250 BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
   768 B253 F0 62			BEQ	LAB_13EC		; if null save byte then exit
   769
   770 B255 C9 7B			CMP   	#'{'           		; convert lower to upper case
   771 B257 B0 5E			BCS   	LAB_13EC       	 	; is above lower case
   772 B259 C9 61			CMP   	#'a'
   773 B25B 90 02			BCC   	PATCH_LC       		; is below lower case
   774 B25D 29 DF			AND   	#$DF           		; mask lower case bit
   775 				      
   776 B25F			PATCH_LC
   777 B25F C9 5F			CMP	#'_'			; compare with '_'
   778 B261 B0 54			BCS	LAB_13EC		; if >= go save byte then continue crunching
   779
   780 B263 C9 3C			CMP	#'<'			; compare with '<'
   781 B265 B0 0E			BCS	LAB_13CC		; if >= go crunch now
   782
   783 B267 C9 30			CMP	#'0'			; compare with '0'
   784 B269 B0 4C			BCS	LAB_13EC		; if >= go save byte then continue crunching
   785
   786 B26B 85 1C			STA	Scnquo			; save buffer byte as search character
   787 B26D C9 22			CMP	#$22			; is it quote character?
   788 B26F F0 68			BEQ	LAB_1410		; branch if so (copy quoted string)
   789
   790 B271 C9 2A			CMP	#'*'			; compare with '*'
   791 B273 90 42			BCC	LAB_13EC		; if < go save byte then continue crunching
   792 									; else crunch now
   793 B275			LAB_13CC
   794 B275 24 20			BIT	Oquote			; get open quote/DATA token flag
   795 B277 70 3E			BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
   796 									; go save byte then continue crunching
   797
   798 B279 86 38			STX	TempB			; save buffer read index
   799 B27B 84 7A			STY	csidx			; copy buffer save index
   800 B27D A0 10			LDY	#<TAB_1STC		; get keyword first character table low address
   801 B27F 84 33			STY	ut2_pl			; save pointer low byte
   802 B281 A0 D5			LDY	#>TAB_1STC		; get keyword first character table high address
   803 B283 84 34			STY	ut2_ph			; save pointer high byte
   804 B285 A0 00			LDY	#$00			; clear table pointer
   805
   806 B287			LAB_13D0
   807 B287 D1 33			CMP	(ut2_pl),Y		; compare with keyword first character table byte
   808 B289 F0 05			BEQ	LAB_13D1		; go do word_table_chr if match
   809
   810 B28B 90 60			BCC   	PATCH_LC2		; if < keyword first character table byte go restore
   811 									; Y and save to crunched
   812
   813 B28D C8				INY				; else increment pointer
   814 B28E D0 F7			BNE	LAB_13D0		; and loop (branch always)
   815
   816 				; have matched first character of some keyword
   817 B290			LAB_13D1
   818 B290 98				TYA				; copy matching index
   819 B291 0A				ASL				; *2 (bytes per pointer)
   820 B292 AA				TAX				; copy to new index
   821 B293 BD 2E D5			LDA	TAB_CHRT,X		; get keyword table pointer low byte
   822 B296 85 33			STA	ut2_pl			; save pointer low byte
   823 B298 BD 2F D5			LDA	TAB_CHRT+1,X		; get keyword table pointer high byte
   824 B29B 85 34			STA	ut2_ph			; save pointer high byte
   825
   826 B29D A0 FF			LDY	#$FF			; clear table pointer (make -1 for start)
   827
   828 B29F A6 38			LDX	TempB			; restore buffer read index
   829 B2A1			LAB_13D6
   830 B2A1 C8				INY				; next table byte
   831 B2A2 B1 33			LDA	(ut2_pl),Y		; get byte from table
   832 B2A4			LAB_13D8
   833 B2A4 30 0F			BMI	LAB_13EA		; all bytes matched so go save token
   834
   835 B2A6 E8				INX				; next buffer byte
   836 B2A7 DD 7F 18			CMP	Ibuffs,X		; compare with byte from input buffer
   837 B2AA F0 F5			BEQ	LAB_13D6		; go compare next if match
   838 				    
   839 B2AC 09 20			ORA 	#$20                	; repeat with lower case
   840 B2AE DD 7F 18			CMP 	Ibuffs,X            	; compare with byte from input buffer
   841 B2B1 F0 EE			BEQ 	LAB_13D6            	; go compare next if match
   842 					
   843 B2B3 D0 2B			BNE	LAB_1417		; branch if >< (not found keyword)
   844
   845 B2B5			LAB_13EA
   846 B2B5 A4 7A			LDY	csidx			; restore save index
   847 									; save crunched to output
   848 B2B7			LAB_13EC
   849 B2B7 E8				INX				; increment buffer index (to next input byte)
   850 B2B8 C8				INY				; increment save index (to next output byte)
   851 B2B9 99 7F 18			STA	Ibuffs,Y		; save byte to output
   852 B2BC C9 00			CMP	#$00			; set the flags, set carry
   853 B2BE F0 32			BEQ	LAB_142A		; do exit if was null [EOL]
   854
   855 									; A holds token or byte here
   856 B2C0 E9 3A			SBC	#':'			; subtract ':' (carry set by CMP #00)
   857 B2C2 F0 04			BEQ	LAB_13FF		; branch if it was ':' (is now $00)
   858
   859 									; A now holds token-$3A
   860 B2C4 C9 49			CMP	#TK_DATA-$3A		; compare with DATA token - $3A
   861 B2C6 D0 02			BNE	LAB_1401		; branch if not DATA
   862 									; token was : or DATA
   863 B2C8			LAB_13FF
   864 B2C8 85 20			STA	Oquote			; save token-$3A (clear for ':', TK_DATA-$3A for DATA)
   865 B2CA			LAB_1401
   866 B2CA 49 57			EOR	#TK_REM-$3A		; effectively subtract REM token offset
   867 B2CC D0 82			BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
   868
   869 B2CE 85 1C			STA	Asrch			; else was REM so set search for [EOL]
   870 									; loop for REM, '...' etc.
   871 B2D0			LAB_1408
   872 B2D0 BD 7F 18			LDA	Ibuffs,X		; get byte from input buffer
   873 B2D3 F0 E2			BEQ	LAB_13EC		; branch if null [EOL]
   874
   875 B2D5 C5 1C			CMP	Asrch			; compare with stored character
   876 B2D7 F0 DE			BEQ	LAB_13EC		; branch if match (end quote)
   877
   878 									; entry for copy string in quotes, don't crunch
   879 B2D9			LAB_1410
   880 B2D9 C8				INY				; increment buffer save index
   881 B2DA 99 7F 18			STA	Ibuffs,Y		; save byte to output
   882 B2DD E8				INX				; increment buffer read index
   883 B2DE D0 F0			BNE	LAB_1408		; loop while <> 0 (should never be 0!)
   884
   885 									; not found keyword this go
   886 B2E0			LAB_1417
   887 B2E0 A6 38			LDX	TempB			; compare has failed, restore buffer index (start byte!)
   888
   889 									; now find the end of this word in the table
   890 B2E2			LAB_141B
   891 B2E2 B1 33			LDA	(ut2_pl),Y		; get table byte
   892 B2E4 08				PHP				; save status
   893 B2E5 C8				INY				; increment table index
   894 B2E6 28				PLP				; restore byte status
   895 B2E7 10 F9			BPL	LAB_141B		; if not end of keyword go do next
   896
   897 B2E9 B1 33			LDA	(ut2_pl),Y		; get byte from keyword table
   898 B2EB D0 B7			BNE	LAB_13D8		; go test next word if not zero byte (end of table)
   899
   900 B2ED			PATCH_LC2
   901 									; reached end of table with no match
   902 B2ED BD 7F 18			LDA	Ibuffs,X		; restore byte from input buffer
   903 B2F0 10 C3			BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
   904 									; go save byte in output and continue crunching
   905
   906 									; reached [EOL]
   907 B2F2			LAB_142A
   908 B2F2 C8				INY				; increment pointer
   909 B2F3 C8				INY				; increment pointer (makes it next line pointer high byte)
   910 B2F4 99 7F 18			STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
   911 B2F7 C8				INY				; adjust for line copy
   912 B2F8 C8				INY				; adjust for line copy
   913 B2F9 C8				INY				; adjust for line copy
   914 B2FA C6 83			DEC	Bpntrl			; allow for increment (change if buffer starts at $xxFF)
   915 B2FC 60				RTS
   916
   917 				; search Basic for temp integer line number from start of mem
   918 B2FD			LAB_SSLN
   919 B2FD A5 39			LDA	Smeml			; get start of mem low byte
   920 B2FF A6 3A			LDX	Smemh			; get start of mem high byte
   921
   922 				; search Basic for temp integer line number from AX
   923 				; returns carry set if found
   924 				; returns Baslnl/Baslnh pointer to found or next higher (not found) line
   925
   926 				; old 541 new 507
   927 B301			LAB_SHLN
   928 B301 A0 01			LDY	#$01			; set index
   929 B303 85 6A			STA	Baslnl			; save low byte as current
   930 B305 86 6B			STX	Baslnh			; save high byte as current
   931 B307 B1 6A			LDA	(Baslnl),Y		; get pointer high byte from addr
   932 B309 F0 1A			BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
   933
   934 B30B A0 03			LDY	#$03			; set index to line # high byte
   935 B30D B1 6A			LDA	(Baslnl),Y		; get line # high byte
   936 B30F 88				DEY				; decrement index (point to low byte)
   937 B310 C5 12			CMP	Itemph			; compare with temporary integer high byte
   938 B312 D0 04			BNE	LAB_1455		; if <> skip low byte check
   939
   940 B314 B1 6A			LDA	(Baslnl),Y		; get line # low byte
   941 B316 C5 11			CMP	Itempl			; compare with temporary integer low byte
   942 B318			LAB_1455
   943 B318 B0 09			BCS	LAB_145E		; else if temp < this line, exit (passed line#)
   944
   945 B31A			LAB_1456
   946 B31A 88				DEY				; decrement index to next line ptr high byte
   947 B31B B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
   948 B31D AA				TAX				; copy to X
   949 B31E 88				DEY				; decrement index to next line ptr low byte
   950 B31F B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
   951 B321 90 DE			BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
   952 									; (carry always clear)
   953
   954 B323			LAB_145E
   955 B323 F0 01			BEQ	LAB_1460		; exit if temp = found line #, carry is set
   956
   957 B325			LAB_145F
   958 B325 18				CLC				; clear found flag
   959 B326			LAB_1460
   960 B326 60				RTS
   961
   962 				; perform NEW
   963 B327			LAB_NEW
   964 B327 D0 FD			BNE	LAB_1460		; exit if not end of statement (to do syntax error)
   965
   966 B329			LAB_1463
   967 B329 A9 00			LDA	#$00			; clear A
   968 B32B A8				TAY				; clear Y
   969 B32C 91 39			STA	(Smeml),Y		; clear first line, next line pointer, low byte
   970 B32E C8				INY				; increment index
   971 B32F 91 39			STA	(Smeml),Y		; clear first line, next line pointer, high byte
   972 B331 18				CLC				; clear carry
   973 B332 A5 39			LDA	Smeml			; get start of mem low byte
   974 B334 69 02			ADC	#$02			; calculate end of BASIC low byte
   975 B336 85 3B			STA	Svarl			; save start of vars low byte
   976 B338 A5 3A			LDA	Smemh			; get start of mem high byte
   977 B33A 69 00			ADC	#$00			; add any carry
   978 B33C 85 3C			STA	Svarh			; save start of vars high byte
   979
   980 				; reset execution to start, clear vars and flush stack
   981 B33E			LAB_1477
   982 B33E 18				CLC				; clear carry
   983 B33F A5 39			LDA	Smeml			; get start of mem low byte
   984 B341 69 FF			ADC	#$FF			; -1
   985 B343 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
   986 B345 A5 3A			LDA	Smemh			; get start of mem high byte
   987 B347 69 FF			ADC	#$FF			; -1+carry
   988 B349 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
   989
   990 				; 'CLEAR' command gets here
   991 B34B			LAB_147A
   992 B34B A5 45			LDA	Ememl			; get end of mem low byte
   993 B34D A4 46			LDY	Ememh			; get end of mem high byte
   994 B34F 85 41			STA	Sstorl			; set bottom of string space low byte
   995 B351 84 42			STY	Sstorh			; set bottom of string space high byte
   996 B353 A5 3B			LDA	Svarl			; get start of vars low byte
   997 B355 A4 3C			LDY	Svarh			; get start of vars high byte
   998 B357 85 3D			STA	Sarryl			; save var mem end low byte
   999 B359 84 3E			STY	Sarryh			; save var mem end high byte
  1000 B35B 85 3F			STA	Earryl			; save array mem end low byte
  1001 B35D 84 40			STY	Earryh			; save array mem end high byte
  1002 B35F 20 13 B5			JSR	LAB_161A		; perform RESTORE command
  1003
  1004 				; flush stack and clear continue flag
  1005 B362			LAB_1491
  1006 B362 A2 28			LDX	#des_sk			; set descriptor stack pointer
  1007 B364 86 25			STX	next_s			; save descriptor stack pointer
  1008 B366 68				PLA				; pull return address low byte
  1009 B367 AA				TAX				; copy return address low byte
  1010 B368 68				PLA				; pull return address high byte
  1011 B369 8E FE 01			STX	LAB_SKFE		; save to cleared stack
  1012 B36C 8D FF 01			STA	LAB_SKFF		; save to cleared stack
  1013 B36F A2 FD			LDX	#$FD			; new stack pointer
  1014 B371 9A				TXS				; reset stack
  1015 B372 A9 00			LDA	#$00			; clear byte
  1016 					;STA	Cpntrh			; clear continue pointer high byte (patched)
  1017 B374 85 21			STA	Sufnxf			; clear subscript/FNX flag
  1018 B376			LAB_14A6
  1019 B376 60				RTS
  1020
  1021 				; perform CLEAR
  1022 B377			LAB_CLEAR
  1023 B377 F0 D2			BEQ	LAB_147A		; if no following token go do 'CLEAR'
  1024 									; else there was a following token (go do syntax error)
  1025 B379 60				RTS
  1026
  1027 				; perform LIST [n][-m]
  1028 				; bigger, faster version (a _lot_ faster)
  1029 B37A			LAB_LIST
  1030 B37A 90 06			BCC	LAB_14BD		; branch if next character numeric (LIST n..)
  1031
  1032 B37C F0 04			BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
  1033
  1034 B37E C9 CC			CMP	#TK_MINUS		; compare with token for -
  1035 B380 D0 F4			BNE	LAB_14A6		; exit if not - (LIST -m)
  1036
  1037 									; LIST [[n][-m]]
  1038 									; this bit sets the n , if present, as the start and end
  1039 B382			LAB_14BD
  1040 B382 20 11 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1041 B385 20 FD B2			JSR	LAB_SSLN		; search BASIC for temp integer line number
  1042 									; (pointer in Baslnl/Baslnh)
  1043 B388 20 82 00			JSR	LAB_GBYT		; scan memory
  1044 B38B F0 0C			BEQ	LAB_14D4		; branch if no more characters
  1045
  1046 									; this bit checks the - is present
  1047 B38D C9 CC			CMP	#TK_MINUS		; compare with token for -
  1048 B38F D0 95			BNE	LAB_1460		; return if not '-' (will be Syntax error)
  1049
  1050 									; LIST [n]-m
  1051 									; the - was there so set m as the end value
  1052 B391 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1053 B394 20 11 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1054 B397 D0 8D			BNE	LAB_1460		; exit if not ok
  1055
  1056 B399			LAB_14D4
  1057 B399 A5 11			LDA	Itempl			; get temporary integer low byte
  1058 B39B 05 12			ORA	Itemph			; OR temporary integer high byte
  1059 B39D D0 06			BNE	LAB_14E2		; branch if start set
  1060
  1061 B39F A9 FF			LDA	#$FF			; set for -1
  1062 B3A1 85 11			STA	Itempl			; set temporary integer low byte
  1063 B3A3 85 12			STA	Itemph			; set temporary integer high byte
  1064 B3A5			LAB_14E2
  1065 B3A5 A0 01			LDY	#$01			; set index for line
  1066 B3A7 84 20			STY	Oquote			; clear open quote flag
  1067 B3A9 20 4E B8			JSR	LAB_CRLF		; print CR/LF
  1068 B3AC B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1069 									; pointer initially set by search at LAB_14BD
  1070 B3AE F0 3E			BEQ	LAB_152B		; if null all done so exit
  1071 B3B0 20 E9 B4			JSR	LAB_1629		; do CRTL-C check vector
  1072
  1073 B3B3 C8				INY				; increment index for line
  1074 B3B4 B1 6A			LDA	(Baslnl),Y		; get line # low byte
  1075 B3B6 AA				TAX				; copy to X
  1076 B3B7 C8				INY				; increment index
  1077 B3B8 B1 6A			LDA	(Baslnl),Y		; get line # high byte
  1078 B3BA C5 12			CMP	Itemph			; compare with temporary integer high byte
  1079 B3BC D0 04			BNE	LAB_14FF		; branch if no high byte match
  1080
  1081 B3BE E4 11			CPX	Itempl			; compare with temporary integer low byte
  1082 B3C0 F0 02			BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
  1083
  1084 B3C2			LAB_14FF				; else ..
  1085 B3C2 B0 2A			BCS	LAB_152B		; if greater all done so exit
  1086
  1087 B3C4			LAB_1501
  1088 B3C4 84 57			STY	Tidx1			; save index for line
  1089 B3C6 20 4D CA			JSR	LAB_295E		; print XA as unsigned integer
  1090 B3C9 A9 20			LDA	#$20			; space is the next character
  1091 B3CB			LAB_1508
  1092 B3CB A4 57			LDY	Tidx1			; get index for line
  1093 B3CD 29 7F			AND	#$7F			; mask top out bit of character
  1094 B3CF			LAB_150C
  1095 B3CF 20 A9 B8			JSR	LAB_PRNA		; go print the character
  1096 B3D2 C9 22			CMP	#$22			; was it ' character
  1097 B3D4 D0 06			BNE	LAB_1519		; branch if not
  1098
  1099 									; we are either entering or leaving a pair of quotes
  1100 B3D6 A5 20			LDA	Oquote			; get open quote flag
  1101 B3D8 49 FF			EOR	#$FF			; toggle it
  1102 B3DA 85 20			STA	Oquote			; save it back
  1103 B3DC			LAB_1519
  1104 B3DC C8				INY				; increment index
  1105 B3DD B1 6A			LDA	(Baslnl),Y		; get next byte
  1106 B3DF D0 0E			BNE	LAB_152E		; branch if not [EOL] (go print character)
  1107 B3E1 A8				TAY				; else clear index
  1108 B3E2 B1 6A			LDA	(Baslnl),Y		; get next line pointer low byte
  1109 B3E4 AA				TAX				; copy to X
  1110 B3E5 C8				INY				; increment index
  1111 B3E6 B1 6A			LDA	(Baslnl),Y		; get next line pointer high byte
  1112 B3E8 86 6A			STX	Baslnl			; set pointer to line low byte
  1113 B3EA 85 6B			STA	Baslnh			; set pointer to line high byte
  1114 B3EC D0 B7			BNE	LAB_14E2		; go do next line if not [EOT]
  1115 									; else ..
  1116 B3EE			LAB_152B
  1117 B3EE 60				RTS
  1118
  1119 B3EF			LAB_152E
  1120 B3EF 10 DE			BPL	LAB_150C		; just go print it if not token byte
  1121
  1122 									; else was token byte so uncrunch it (maybe)
  1123 B3F1 24 20			BIT	Oquote			; test the open quote flag
  1124 B3F3 30 DA			BMI	LAB_150C		; just go print character if open quote set
  1125
  1126 B3F5 A2 D7			LDX	#>LAB_KEYT		; get table address high byte
  1127 B3F7 0A				ASL				; *2
  1128 B3F8 0A				ASL				; *4
  1129 B3F9 90 02			BCC	LAB_152F		; branch if no carry
  1130
  1131 B3FB E8				INX				; else increment high byte
  1132 B3FC 18				CLC				; clear carry for add
  1133 B3FD			LAB_152F
  1134 B3FD 69 8C			ADC	#<LAB_KEYT		; add low byte
  1135 B3FF 90 01			BCC	LAB_1530		; branch if no carry
  1136
  1137 B401 E8				INX				; else increment high byte
  1138 B402			LAB_1530
  1139 B402 85 33			STA	ut2_pl			; save table pointer low byte
  1140 B404 86 34			STX	ut2_ph			; save table pointer high byte
  1141 B406 84 57			STY	Tidx1			; save index for line
  1142 B408 A0 00			LDY	#$00			; clear index
  1143 B40A B1 33			LDA	(ut2_pl),Y		; get length
  1144 B40C AA				TAX				; copy length
  1145 B40D C8				INY				; increment index
  1146 B40E B1 33			LDA	(ut2_pl),Y		; get 1st character
  1147 B410 CA				DEX				; decrement length
  1148 B411 F0 B8			BEQ	LAB_1508		; if no more characters exit and print
  1149
  1150 B413 20 A9 B8			JSR	LAB_PRNA		; go print the character
  1151 B416 C8				INY				; increment index
  1152 B417 B1 33			LDA	(ut2_pl),Y		; get keyword address low byte
  1153 B419 48				PHA				; save it for now
  1154 B41A C8				INY				; increment index
  1155 B41B B1 33			LDA	(ut2_pl),Y		; get keyword address high byte
  1156 B41D A0 00			LDY	#$00
  1157 B41F 85 34			STA	ut2_ph			; save keyword pointer high byte
  1158 B421 68				PLA				; pull low byte
  1159 B422 85 33			STA	ut2_pl			; save keyword pointer low byte
  1160 B424			LAB_1540
  1161 B424 B1 33			LDA	(ut2_pl),Y		; get character
  1162 B426 CA				DEX				; decrement character count
  1163 B427 F0 A2			BEQ	LAB_1508		; if last character exit and print
  1164
  1165 B429 20 A9 B8			JSR	LAB_PRNA		; go print the character
  1166 B42C C8				INY				; increment index
  1167 B42D D0 F5			BNE	LAB_1540		; loop for next character
  1168
  1169 				; perform FOR
  1170 B42F			LAB_FOR
  1171 B42F A9 80			LDA	#$80			; set FNX
  1172 B431 85 21			STA	Sufnxf			; set subscript/FNX flag
  1173 B433 20 70 B7			JSR	LAB_LET			; go do LET
  1174 B436 68				PLA				; pull return address
  1175 B437 68				PLA				; pull return address
  1176 B438 A9 10			LDA	#$10			; we need 16d bytes !
  1177 B43A 20 CB B0			JSR	LAB_1212		; check room on stack for A bytes
  1178 B43D 20 64 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1179 B440 18				CLC				; clear carry for add
  1180 B441 98				TYA				; copy index to A
  1181 B442 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1182 B444 48				PHA				; push onto stack
  1183 B445 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1184 B447 69 00			ADC	#$00			; add carry
  1185 B449 48				PHA				; push onto stack
  1186 B44A A5 48			LDA	Clineh			; get current line high byte
  1187 B44C 48				PHA				; push onto stack
  1188 B44D A5 47			LDA	Clinel			; get current line low byte
  1189 B44F 48				PHA				; push onto stack
  1190 B450 A9 C2			LDA	#TK_TO			; get 'TO' token
  1191 B452 20 AC BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1192 B455 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1193 B458 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1194 									; else do type mismatch
  1195 B45B A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  1196 B45D 09 7F			ORA	#$7F			; set all non sign bits
  1197 B45F 25 6D			AND	FAC1_1			; and FAC1 mantissa1
  1198 B461 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  1199 B463 A9 6E			LDA	#<LAB_159F		; set return address low byte
  1200 B465 A0 B4			LDY	#>LAB_159F		; set return address high byte
  1201 B467 85 31			STA	ut1_pl			; save return address low byte
  1202 B469 84 32			STY	ut1_ph			; save return address high byte
  1203 B46B 4C 3F BB			JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1204
  1205 B46E			LAB_159F
  1206 B46E A9 A3			LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1207 B470 A0 D3			LDY	#>LAB_259C		; set 1 pointer high addr
  1208 B472 20 48 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1209 B475 20 82 00			JSR	LAB_GBYT		; scan memory
  1210 B478 C9 C7			CMP	#TK_STEP		; compare with STEP token
  1211 B47A D0 06			BNE	LAB_15B3		; jump if not 'STEP'
  1212
  1213 									;.was step so ..
  1214 B47C 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1215 B47F 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1216 									; else do type mismatch
  1217 B482			LAB_15B3
  1218 B482 20 B4 C8			JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1219 B485 85 70			STA	FAC1_s			; set FAC1 sign (b7)
  1220 									; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1221 									; compare the FOR value and the TO value and return +1 if
  1222 									; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1223 									; here (+/-1) is then compared to that result and if they
  1224 									; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1225 									; the loop is done
  1226 B487 20 34 BB			JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1227 B48A A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  1228 B48C 48				PHA				; push on stack
  1229 B48D A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  1230 B48F 48				PHA				; push on stack
  1231 B490 A9 81			LDA	#TK_FOR			; get FOR token
  1232 B492 48				PHA				; push on stack
  1233
  1234 				; interpreter inner loop
  1235 B493			LAB_15C2
  1236 B493 20 E9 B4			JSR	LAB_1629		; do CRTL-C check vector
  1237 B496 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1238 B498 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  1239
  1240 B49A A6 48			LDX	Clineh			; continue line is $FFxx for immediate mode
  1241 									; ($00xx for RUN from immediate mode)
  1242 B49C E8				INX				; increment it (now $00 if immediate mode)
  1243 					;BEQ	LAB_15D1		; branch if null (immediate mode) (patched)
  1244
  1245 B49D 85 4B			STA	Cpntrl			; save continue pointer low byte
  1246 B49F 84 4C			STY	Cpntrh			; save continue pointer high byte
  1247 B4A1			LAB_15D1
  1248 B4A1 A0 00			LDY	#$00			; clear index
  1249 B4A3 B1 83			LDA	(Bpntrl),Y		; get next byte
  1250 B4A5 F0 07			BEQ	LAB_15DC		; branch if null [EOL]
  1251
  1252 B4A7 C9 3A			CMP	#':'			; compare with ':'
  1253 B4A9 F0 1D			BEQ	LAB_15F6		; branch if = (statement separator)
  1254
  1255 B4AB			LAB_15D9
  1256 B4AB 4C BD BB			JMP	LAB_SNER		; else syntax error then warm start
  1257
  1258 									; have reached [EOL]
  1259 B4AE			LAB_15DC
  1260 B4AE A0 02			LDY	#$02			; set index
  1261 B4B0 B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  1262 B4B2 18				CLC				; clear carry for no 'BREAK' message
  1263 B4B3 F0 50			BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1264 									; marker)
  1265
  1266 B4B5 C8				INY				; increment index
  1267 B4B6 B1 83			LDA	(Bpntrl),Y		; get line # low byte
  1268 B4B8 85 47			STA	Clinel			; save current line low byte
  1269 B4BA C8				INY				; increment index
  1270 B4BB B1 83			LDA	(Bpntrl),Y		; get line # high byte
  1271 B4BD 85 48			STA	Clineh			; save current line high byte
  1272 B4BF 98				TYA				; A now = 4
  1273 B4C0 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1274 B4C2 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1275 B4C4 90 02			BCC	LAB_15F6		; branch if no overflow
  1276
  1277 B4C6 E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1278 B4C8			LAB_15F6
  1279 B4C8 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1280
  1281 B4CB			LAB_15F9
  1282 B4CB 20 D1 B4			JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
  1283
  1284 B4CE			LAB_15FC
  1285 B4CE 4C 93 B4			JMP	LAB_15C2		; loop
  1286
  1287 				; interpret BASIC code from (Bpntrl)
  1288 B4D1			LAB_15FF
  1289 B4D1 F0 4E			BEQ	LAB_1628		; exit if zero [EOL]
  1290
  1291 B4D3			LAB_1602
  1292 B4D3 0A				ASL				; *2 bytes per vector and normalise token
  1293 B4D4 B0 03			BCS	LAB_1609		; branch if was token
  1294
  1295 B4D6 4C 70 B7			JMP	LAB_LET			; else go do implied LET
  1296
  1297 B4D9			LAB_1609
  1298 B4D9 C9 80			CMP	#(TK_TAB-$80)*2		; compare normalised token * 2 with TAB
  1299 B4DB B0 CE			BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  1300 									; only tokens before TAB can start a line
  1301 B4DD A8				TAY				; copy to index
  1302 B4DE B9 CB D3			LDA	LAB_CTBL+1,Y		; get vector high byte
  1303 B4E1 48				PHA				; onto stack
  1304 B4E2 B9 CA D3			LDA	LAB_CTBL,Y		; get vector low byte
  1305 B4E5 48				PHA				; onto stack
  1306 B4E6 4C 7C 00			JMP	LAB_IGBY		; jump to increment and scan memory
  1307 									; then 'return' to vector
  1308
  1309 				; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1310 				; key press is detected.
  1311 B4E9			LAB_1629
  1312 B4E9 6C 6B 18			JMP	(VEC_CC)		; ctrl c check vector
  1313
  1314 				; if there was a key press it gets back here ..
  1315 B4EC			LAB_1636
  1316 B4EC C9 03			CMP	#$03			; compare with CTRL-C
  1317
  1318 				; perform STOP
  1319 B4EE			LAB_STOP
  1320 B4EE B0 01			BCS	LAB_163B		; branch if token follows STOP
  1321 									; else just END
  1322 				; END
  1323 B4F0			LAB_END
  1324 B4F0 18				CLC				; clear the carry, indicate a normal program end
  1325 B4F1			LAB_163B
  1326 B4F1 D0 61			BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1327
  1328 B4F3 A5 84			LDA	Bpntrh			; get the BASIC execute pointer high byte
  1329 					;EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1330 					;BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1331 									; (can't continue in immediate mode)
  1332
  1333 									; else ..
  1334 					;EOR	#>Ibuffs		; correct the bits (patched 3 lines)
  1335 B4F5 A4 83			LDY	Bpntrl			; get BASIC execute pointer low byte
  1336 B4F7 84 4B			STY	Cpntrl			; save continue pointer low byte
  1337 B4F9 85 4C			STA	Cpntrh			; save continue pointer high byte
  1338 B4FB			LAB_1647
  1339 B4FB A5 47			LDA	Clinel			; get current line low byte
  1340 B4FD A4 48			LDY	Clineh			; get current line high byte
  1341 B4FF 85 49			STA	Blinel			; save break line low byte
  1342 B501 84 4A			STY	Blineh			; save break line high byte
  1343 B503			LAB_164F
  1344 B503 68				PLA				; pull return address low
  1345 B504 68				PLA				; pull return address high
  1346 B505			LAB_1651
  1347 B505 90 07			BCC	LAB_165E		; if was program end just do warm start
  1348
  1349 									; else ..
  1350 B507 A9 C1			LDA	#<LAB_BMSG		; point to 'Break' low byte
  1351 B509 A0 DA			LDY	#>LAB_BMSG		; point to 'Break' high byte
  1352 B50B 4C 1D B1			JMP	LAB_1269		; print 'Break' and do warm start
  1353
  1354 B50E			LAB_165E
  1355 B50E 4C 28 B1			JMP	LAB_1274		; go do warm start
  1356
  1357 				; perform RESTORE
  1358 B511			LAB_RESTORE
  1359 B511 D0 0F			BNE	LAB_RESTOREn		; branch if next character not null (RESTORE n)
  1360
  1361 B513			LAB_161A
  1362 B513 38				SEC				; set carry for subtract
  1363 B514 A5 39			LDA	Smeml			; get start of mem low byte
  1364 B516 E9 01			SBC	#$01			; -1
  1365 B518 A4 3A			LDY	Smemh			; get start of mem high byte
  1366 B51A B0 01			BCS	LAB_1624		; branch if no underflow
  1367
  1368 B51C			LAB_uflow
  1369 B51C 88				DEY				; else decrement high byte
  1370 B51D			LAB_1624
  1371 B51D 85 4F			STA	Dptrl			; save DATA pointer low byte
  1372 B51F 84 50			STY	Dptrh			; save DATA pointer high byte
  1373 B521			LAB_1628
  1374 B521 60				RTS
  1375
  1376 									; is RESTORE n
  1377 B522			LAB_RESTOREn
  1378 B522 20 11 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1379 B525 20 67 B6			JSR	LAB_SNBL		; scan for next BASIC line
  1380 B528 A5 48			LDA	Clineh			; get current line high byte
  1381 B52A C5 12			CMP	Itemph			; compare with temporary integer high byte
  1382 B52C B0 0B			BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1383
  1384 B52E 98				TYA				; else copy line index to A
  1385 B52F 38				SEC				; set carry (+1)
  1386 B530 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1387 B532 A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1388 B534 90 07			BCC	LAB_go_search		; branch if no overflow to high byte
  1389
  1390 B536 E8				INX				; increment high byte
  1391 B537 B0 04			BCS	LAB_go_search		; branch always (can never be carry clear)
  1392
  1393 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1394 B539			LAB_reset_search
  1395 B539 A5 39			LDA	Smeml			; get start of mem low byte
  1396 B53B A6 3A			LDX	Smemh			; get start of mem high byte
  1397
  1398 				; search for line # in temp (Itempl/Itemph) from (AX)
  1399 B53D			LAB_go_search
  1400
  1401 B53D 20 01 B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1402 B540 B0 03			BCS	LAB_line_found		; if carry set go set pointer
  1403
  1404 B542 4C 39 B6			JMP	LAB_16F7		; else go do 'Undefined statement' error
  1405
  1406 B545			LAB_line_found
  1407 									; carry already set for subtract
  1408 B545 A5 6A			LDA	Baslnl			; get pointer low byte
  1409 B547 E9 01			SBC	#$01			; -1
  1410 B549 A4 6B			LDY	Baslnh			; get pointer high byte
  1411 B54B B0 D0			BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1412
  1413 B54D 90 CD			BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1414 									; return (branch always)
  1415
  1416 				; perform NULL
  1417 B54F			LAB_NULL
  1418 B54F 20 57 C4			JSR	LAB_GTBY		; get byte parameter
  1419 B552 86 0D			STX	Nullct			; save new NULL count
  1420 B554			LAB_167A
  1421 B554 60				RTS
  1422
  1423 				; perform CONT
  1424 B555			LAB_CONT
  1425 B555 D0 FD			BNE	LAB_167A		; if following byte exit to do syntax error
  1426
  1427 B557 A4 4C			LDY	Cpntrh			; get continue pointer high byte
  1428 B559 C0 18			CPY   	#>Ibuffs          	; *** fix p2: test direct mode 
  1429 B55B D0 05			BNE	LAB_166C		; go do continue if we can
  1430
  1431 B55D A2 1E			LDX	#$1E			; error code $1E ('Can't continue' error)
  1432 B55F 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  1433 									; we can continue so ..
  1434 B562			LAB_166C	; 21-07-25 Emile removed
  1435 					;LDA	#TK_ON			; set token for ON
  1436 					;JSR	LAB_IRQ			; set IRQ flags
  1437 					;LDA	#TK_ON			; set token for ON
  1438 					;JSR	LAB_NMI			; set NMI flags
  1439
  1440 B562 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  1441 B564 A5 4B			LDA	Cpntrl			; get continue pointer low byte
  1442 B566 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1443 B568 A5 49			LDA	Blinel			; get break line low byte
  1444 B56A A4 4A			LDY	Blineh			; get break line high byte
  1445 B56C 85 47			STA	Clinel			; set current line low byte
  1446 B56E 84 48			STY	Clineh			; set current line high byte
  1447 B570 60				RTS
  1448
  1449 				; perform RUN
  1450 B571			LAB_RUN
  1451 B571 D0 03			BNE	LAB_1696		; branch if RUN n
  1452 B573 4C 3E B3			JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1453 									; return
  1454
  1455 				; does RUN n
  1456 B576			LAB_1696
  1457 B576 20 4B B3			JSR	LAB_147A		; go do 'CLEAR'
  1458 B579 F0 2E			BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1459
  1460 				; perform DO
  1461 B57B			LAB_DO
  1462 B57B A9 05			LDA	#$05			; need 5 bytes for DO
  1463 B57D 20 CB B0			JSR	LAB_1212		; check room on stack for A bytes
  1464 B580 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1465 B582 48				PHA				; push on stack
  1466 B583 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1467 B585 48				PHA				; push on stack
  1468 B586 A5 48			LDA	Clineh			; get current line high byte
  1469 B588 48				PHA				; push on stack
  1470 B589 A5 47			LDA	Clinel			; get current line low byte
  1471 B58B 48				PHA				; push on stack
  1472 B58C A9 9D			LDA	#TK_DO			; token for DO
  1473 B58E 48				PHA				; push on stack
  1474 B58F 20 82 00			JSR	LAB_GBYT		; scan memory
  1475 B592 4C 93 B4			JMP	LAB_15C2		; go do interpreter inner loop
  1476
  1477 				; perform GOSUB
  1478 B595			LAB_GOSUB
  1479 B595 A9 05			LDA	#$05			; need 5 bytes for GOSUB
  1480 B597 20 CB B0			JSR	LAB_1212		; check room on stack for A bytes
  1481 B59A A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  1482 B59C 48				PHA				; push on stack
  1483 B59D A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  1484 B59F 48				PHA				; push on stack
  1485 B5A0 A5 48			LDA	Clineh			; get current line high byte
  1486 B5A2 48				PHA				; push on stack
  1487 B5A3 A5 47			LDA	Clinel			; get current line low byte
  1488 B5A5 48				PHA				; push on stack
  1489 B5A6 A9 8D			LDA	#TK_GOSUB		; token for GOSUB
  1490 B5A8 48				PHA				; push on stack
  1491 B5A9			LAB_16B0
  1492 B5A9 20 82 00			JSR	LAB_GBYT		; scan memory
  1493 B5AC 20 B2 B5			JSR	LAB_GOTO		; perform GOTO n
  1494 B5AF 4C 93 B4			JMP	LAB_15C2		; go do interpreter inner loop
  1495 									; (can't RTS, we used the stack!)
  1496
  1497 				; perform GOTO
  1498 B5B2			LAB_GOTO
  1499 B5B2 20 11 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer
  1500 B5B5 20 67 B6			JSR	LAB_SNBL		; scan for next BASIC line
  1501 B5B8 A5 48			LDA	Clineh			; get current line high byte
  1502 B5BA C5 12			CMP	Itemph			; compare with temporary integer high byte
  1503 B5BC B0 0B			BCS	LAB_16D0		; branch if >= (start search from beginning)
  1504
  1505 B5BE 98				TYA				; else copy line index to A
  1506 B5BF 38				SEC				; set carry (+1)
  1507 B5C0 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1508 B5C2 A6 84			LDX	Bpntrh			; get BASIC execute pointer high byte
  1509 B5C4 90 07			BCC	LAB_16D4		; branch if no overflow to high byte
  1510
  1511 B5C6 E8				INX				; increment high byte
  1512 B5C7 B0 04			BCS	LAB_16D4		; branch always (can never be carry)
  1513
  1514 				; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1515 B5C9			LAB_16D0
  1516 B5C9 A5 39			LDA	Smeml			; get start of mem low byte
  1517 B5CB A6 3A			LDX	Smemh			; get start of mem high byte
  1518
  1519 				; search for line # in temp (Itempl/Itemph) from (AX)
  1520 B5CD			LAB_16D4
  1521 B5CD 20 01 B3			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1522 B5D0 90 67			BCC	LAB_16F7		; if carry clear go do 'Undefined statement' error
  1523 									; (unspecified statement)
  1524
  1525 									; carry already set for subtract
  1526 B5D2 A5 6A			LDA	Baslnl			; get pointer low byte
  1527 B5D4 E9 01			SBC	#$01			; -1
  1528 B5D6 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1529 B5D8 A5 6B			LDA	Baslnh			; get pointer high byte
  1530 B5DA E9 00			SBC	#$00			; subtract carry
  1531 B5DC 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1532 B5DE			LAB_16E5
  1533 B5DE 60				RTS
  1534
  1535 B5DF			LAB_DONOK
  1536 B5DF A2 22			LDX	#$22			; error code $22 ('LOOP without DO' error)
  1537 B5E1 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  1538
  1539 				; perform LOOP
  1540 B5E4			LAB_LOOP
  1541 B5E4 A8				TAY				; save following token
  1542 B5E5 BA				TSX				; copy stack pointer
  1543 B5E6 BD 03 01			LDA	LAB_STAK+3,X		; get token byte from stack
  1544 B5E9 C9 9D			CMP	#TK_DO			; compare with DO token
  1545 B5EB D0 F2			BNE	LAB_DONOK		; branch if no matching DO
  1546
  1547 B5ED E8				INX				; dump calling routine return address
  1548 B5EE E8				INX				; dump calling routine return address
  1549 B5EF 9A				TXS				; correct stack
  1550 B5F0 98				TYA				; get saved following token back
  1551 B5F1 F0 20			BEQ	LoopAlways		; if no following token loop forever
  1552 									; (stack pointer in X)
  1553
  1554 B5F3 C9 3A			CMP	#':'			; could be ':'
  1555 B5F5 F0 1C			BEQ	LoopAlways		; if :... loop forever
  1556
  1557 B5F7 E9 C8			SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1558 B5F9 AA				TAX				; copy to X (if it was UNTIL then Y will be correct)
  1559 B5FA F0 04			BEQ	DoRest			; branch if was UNTIL
  1560
  1561 B5FC CA				DEX				; decrement result
  1562 B5FD D0 62			BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1563 									; only if the token was WHILE will this fail
  1564
  1565 B5FF CA				DEX				; set invert result byte
  1566 B600			DoRest
  1567 B600 86 58			STX	Frnxth			; save invert result byte
  1568 B602 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1569 B605 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  1570 B608 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1571 B60A F0 02			BEQ	DoCmp			; if =0 go do straight compare
  1572
  1573 B60C A9 FF			LDA	#$FF			; else set all bits
  1574 B60E			DoCmp
  1575 B60E BA				TSX				; copy stack pointer
  1576 B60F 45 58			EOR	Frnxth			; EOR with invert byte
  1577 B611 D0 1A			BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1578
  1579 									; loop condition wasn't met so do it again
  1580 B613			LoopAlways
  1581 B613 BD 02 01			LDA	LAB_STAK+2,X		; get current line low byte
  1582 B616 85 47			STA	Clinel			; save current line low byte
  1583 B618 BD 03 01			LDA	LAB_STAK+3,X		; get current line high byte
  1584 B61B 85 48			STA	Clineh			; save current line high byte
  1585 B61D BD 04 01			LDA	LAB_STAK+4,X		; get BASIC execute pointer low byte
  1586 B620 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1587 B622 BD 05 01			LDA	LAB_STAK+5,X		; get BASIC execute pointer high byte
  1588 B625 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1589 B627 20 82 00			JSR	LAB_GBYT		; scan memory
  1590 B62A 4C 93 B4			JMP	LAB_15C2		; go do interpreter inner loop
  1591
  1592 									; clear stack and back to interpreter loop
  1593 B62D			LoopDone
  1594 B62D E8				INX				; dump DO token
  1595 B62E E8				INX				; dump current line low byte
  1596 B62F E8				INX				; dump current line high byte
  1597 B630 E8				INX				; dump BASIC execute pointer low byte
  1598 B631 E8				INX				; dump BASIC execute pointer high byte
  1599 B632 9A				TXS				; correct stack
  1600 B633 4C 53 B6			JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1601
  1602 				; do the return without gosub error
  1603 B636			LAB_16F4
  1604 B636 A2 04			LDX	#$04			; error code $04 ('RETURN without GOSUB' error)
  1605 B638 2C				.byte	$2C			; makes next line BIT LAB_0EA2
  1606
  1607 B639			LAB_16F7				; do undefined statement error
  1608 B639 A2 0E			LDX	#$0E			; error code $0E ('Undefined statement' error)
  1609 B63B 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  1610
  1611 				; perform RETURN
  1612 B63E			LAB_RETURN
  1613 B63E D0 9E			BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1614
  1615 B640			LAB_16E8
  1616 B640 68				PLA				; dump calling routine return address
  1617 B641 68				PLA				; dump calling routine return address
  1618 B642 68				PLA				; pull token
  1619 B643 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  1620 B645 D0 EF			BNE	LAB_16F4		; branch if no matching GOSUB
  1621
  1622 B647			LAB_16FF
  1623 B647 68				PLA				; pull current line low byte
  1624 B648 85 47			STA	Clinel			; save current line low byte
  1625 B64A 68				PLA				; pull current line high byte
  1626 B64B 85 48			STA	Clineh			; save current line high byte
  1627 B64D 68				PLA				; pull BASIC execute pointer low byte
  1628 B64E 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1629 B650 68				PLA				; pull BASIC execute pointer high byte
  1630 B651 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  1631
  1632 									; now do the DATA statement as we could be returning into
  1633 									; the middle of an ON <var> GOSUB n,m,p,q line
  1634 									; (the return address used by the DATA statement is the one
  1635 									; pushed before the GOSUB was executed!)
  1636
  1637 				; perform DATA
  1638 B653			LAB_DATA
  1639 B653 20 64 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1640 									; set BASIC execute pointer
  1641 B656			LAB_170F
  1642 B656 98				TYA				; copy index to A
  1643 B657 18				CLC				; clear carry for add
  1644 B658 65 83			ADC	Bpntrl			; add BASIC execute pointer low byte
  1645 B65A 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  1646 B65C 90 02			BCC	LAB_1719		; skip next if no carry
  1647
  1648 B65E E6 84			INC	Bpntrh			; else increment BASIC execute pointer high byte
  1649 B660			LAB_1719
  1650 B660 60				RTS
  1651
  1652 B661			LAB_16FC
  1653 B661 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  1654
  1655 				; scan for next BASIC statement ([:] or [EOL])
  1656 				; returns Y as index to [:] or [EOL]
  1657 B664			LAB_SNBS
  1658 B664 A2 3A			LDX	#':'			; set look for character = ':'
  1659 B666 2C				.byte	$2C			; makes next line BIT $00A2
  1660
  1661 				; scan for next BASIC line
  1662 				; returns Y as index to [EOL]
  1663 B667			LAB_SNBL
  1664 B667 A2 00			LDX	#$00			; set alt search character = [EOL]
  1665 B669 A0 00			LDY	#$00			; set search character = [EOL]
  1666 B66B 84 1C			STY	Asrch			; store search character
  1667 B66D			LAB_1725
  1668 B66D 8A				TXA				; get alt search character
  1669 B66E 45 1C			EOR	Asrch			; toggle search character, effectively swap with $00
  1670 B670 85 1C			STA	Asrch			; save swapped search character
  1671 B672			LAB_172D
  1672 B672 B1 83			LDA	(Bpntrl),Y		; get next byte
  1673 B674 F0 EA			BEQ	LAB_1719		; exit if null [EOL]
  1674
  1675 B676 C5 1C			CMP	Asrch			; compare with search character
  1676 B678 F0 E6			BEQ	LAB_1719		; exit if found
  1677
  1678 B67A C8				INY				; increment index
  1679 B67B C9 22			CMP	#$22			; compare current character with open quote
  1680 B67D D0 F3			BNE	LAB_172D		; if not open quote go get next character
  1681
  1682 B67F F0 EC			BEQ	LAB_1725		; if found go swap search character for alt search character
  1683
  1684 				; perform IF
  1685 B681			LAB_IF
  1686 B681 20 9C BA			JSR	LAB_EVEX		; evaluate the expression
  1687 B684 20 82 00			JSR	LAB_GBYT		; scan memory
  1688 B687 C9 C5			CMP	#TK_THEN		; compare with THEN token
  1689 B689 F0 11			BEQ	LAB_174B		; if it was THEN go do IF
  1690
  1691 									; wasn't IF .. THEN so must be IF .. GOTO
  1692 B68B C9 89			CMP	#TK_GOTO		; compare with GOTO token
  1693 B68D D0 D2			BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  1694
  1695 B68F A6 83			LDX	Bpntrl			; save the basic pointer low byte
  1696 B691 A4 84			LDY	Bpntrh			; save the basic pointer high byte
  1697 B693 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1698 B696 B0 C9			BCS	LAB_16FC		; if not numeric go do syntax error
  1699
  1700 B698 86 83			STX	Bpntrl			; restore the basic pointer low byte
  1701 B69A 84 84			STY	Bpntrh			; restore the basic pointer high byte
  1702 B69C			LAB_174B
  1703 B69C A5 6C			LDA	FAC1_e			; get FAC1 exponent
  1704 B69E F0 1E			BEQ	LAB_174E		; if the result was zero go look for an ELSE
  1705
  1706 B6A0 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  1707 B6A3 B0 03			BCS	LAB_174D		; if not numeric go do var or keyword
  1708
  1709 B6A5			LAB_174C
  1710 B6A5 4C B2 B5			JMP	LAB_GOTO		; else was numeric so do GOTO n
  1711
  1712 									; is var or keyword
  1713 B6A8			LAB_174D	; Patch: allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structures on stack
  1714 B6A8 68				PLA                     	; discard interpreter loop return address
  1715 B6A9 68				PLA                     	; so data structures are at the correct stack offset
  1716 B6AA 20 82 00			JSR   	LAB_GBYT          	; restore token or variable
  1717 B6AD 20 D1 B4			JSR   	LAB_15FF          	; interpret BASIC code from (Bpntrl)
  1718
  1719 				; the IF was executed and there may be a following ELSE so the code needs to return
  1720 				; here to check and ignore the ELSE if present
  1721
  1722 B6B0 A0 00			LDY   	#$00              	; clear the index
  1723 B6B2 B1 83			LDA   	(Bpntrl),Y        	; get the next BASIC byte
  1724 B6B4 C9 C1			CMP   	#TK_ELSE          	; compare it with the token for ELSE
  1725 B6B6 D0 03			BNE   	LAB_no_ELSE       	; no - continue on this line
  1726 B6B8 20 53 B6			JSR   	LAB_DATA          	; yes - skip the rest of the line
  1727
  1728 				; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1729 				; following ELSE will, correctly, cause a syntax error
  1730
  1731 B6BB			LAB_no_ELSE
  1732 B6BB 4C 93 B4			JMP 	LAB_15C2            	; return to the interpreter inner loop 
  1733 				;	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  1734 				;	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  1735 				;					; and return to this code to process any following code
  1736 				;
  1737 				;	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
  1738 				;					; but don't return here
  1739 				;
  1740 				;LAB_174G
  1741 				;	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
  1742 				;
  1743 				;; the IF was executed and there may be a following ELSE so the code needs to return
  1744 				;; here to check and ignore the ELSE if present
  1745 				;
  1746 				;	LDY	#$00			; clear the index
  1747 				;	LDA	(Bpntrl),Y		; get the next BASIC byte
  1748 				;	CMP	#TK_ELSE		; compare it with the token for ELSE
  1749 				;	BEQ	LAB_DATA		; if ELSE ignore the following statement
  1750 				;
  1751 				;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1752 				;; following ELSE will, correctly, cause a syntax error
  1753 				;
  1754 				;	RTS				; else return to the interpreter inner loop
  1755 				;
  1756 				; perform ELSE after IF
  1757 B6BE			LAB_174E
  1758 B6BE A0 00			LDY	#$00			; clear the BASIC byte index
  1759 B6C0 A2 01			LDX	#$01			; clear the nesting depth
  1760 B6C2			LAB_1750
  1761 B6C2 C8				INY				; increment the BASIC byte index
  1762 B6C3 B1 83			LDA	(Bpntrl),Y		; get the next BASIC byte
  1763 B6C5 F0 0F			BEQ	LAB_1753		; if EOL go add the pointer and return
  1764
  1765 B6C7 C9 8B			CMP	#TK_IF			; compare the byte with the token for IF
  1766 B6C9 D0 03			BNE	LAB_1752		; if not IF token skip the depth increment
  1767
  1768 B6CB E8				INX				; else increment the nesting depth ..
  1769 B6CC D0 F4			BNE	LAB_1750		; .. and continue looking
  1770
  1771 B6CE			LAB_1752
  1772 B6CE C9 C1			CMP	#TK_ELSE		; compare the byte with the token for ELSE
  1773 B6D0 D0 F0			BNE	LAB_1750		; if not ELSE token continue looking
  1774
  1775 B6D2 CA				DEX				; was ELSE so decrement the nesting depth
  1776 B6D3 D0 ED			BNE	LAB_1750		; loop if still nested
  1777
  1778 B6D5 C8				INY				; increment the BASIC byte index past the ELSE
  1779
  1780 				; found the matching ELSE, now do <{n|statement}>
  1781 B6D6			LAB_1753
  1782 B6D6 98				TYA				; else copy line index to A
  1783 B6D7 18				CLC				; clear carry for add
  1784 B6D8 65 83			ADC	Bpntrl			; add the BASIC execute pointer low byte
  1785 B6DA 85 83			STA	Bpntrl			; save the BASIC execute pointer low byte
  1786 B6DC 90 02			BCC	LAB_1754		; branch if no overflow to high byte
  1787
  1788 B6DE E6 84			INC	Bpntrh			; else increment the BASIC execute pointer high byte
  1789 B6E0			LAB_1754
  1790 B6E0 20 82 00			JSR	LAB_GBYT		; scan memory
  1791 B6E3 90 C0			BCC	LAB_174C		; if numeric do GOTO n
  1792 									; the code will return to the interpreter loop at the
  1793 									; tail end of the GOTO <n>
  1794
  1795 B6E5 4C D1 B4			JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
  1796 									; the code will return to the interpreter loop at the
  1797 									; tail end of the <statement>
  1798
  1799 				; perform REM, skip (rest of) line
  1800 B6E8			LAB_REM
  1801 B6E8 20 67 B6			JSR	LAB_SNBL		; scan for next BASIC line
  1802 B6EB 4C 56 B6			JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  1803
  1804 B6EE			LAB_16FD
  1805 B6EE 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  1806
  1807 				; perform ON
  1808 				; 21-7-25 Emile: ON {IRQ|NMI} removed
  1809 B6F1 20 57 C4		LAB_ON	JSR	LAB_GTBY		; get byte parameter
  1810 B6F4 48				PHA				; push GOTO/GOSUB token
  1811 B6F5 C9 8D			CMP	#TK_GOSUB		; compare with GOSUB token
  1812 B6F7 F0 04			BEQ	LAB_176B		; branch if GOSUB
  1813
  1814 B6F9 C9 89			CMP	#TK_GOTO		; compare with GOTO token
  1815 B6FB			LAB_1767
  1816 B6FB D0 F1			BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  1817
  1818 				; next character was GOTO or GOSUB
  1819 B6FD			LAB_176B
  1820 B6FD C6 6F			DEC	FAC1_3			; decrement index (byte value)
  1821 B6FF D0 04			BNE	LAB_1773		; branch if not zero
  1822
  1823 B701 68				PLA				; pull GOTO/GOSUB token
  1824 B702 4C D3 B4			JMP	LAB_1602		; go execute it
  1825
  1826 B705			LAB_1773
  1827 B705 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1828 B708 20 11 B7			JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  1829 									; (we could LDX #',' and JSR LAB_SNBL+2, then we
  1830 									; just BNE LAB_176B for the loop. should be quicker ..
  1831 									; no we can't, what if we meet a colon or [EOL]?)
  1832 B70B C9 2C			CMP	#$2C			; compare next character with ','
  1833 B70D F0 EE			BEQ	LAB_176B		; loop if ','
  1834
  1835 B70F			LAB_177E
  1836 B70F 68				PLA				; else pull keyword token (run out of options)
  1837 									; also dump +/-1 pointer low byte and exit
  1838 B710			LAB_177F
  1839 B710 60				RTS
  1840
  1841 				; takes n * 106 + 11 cycles where n is the number of digits
  1842 				; get fixed-point number into temp integer
  1843 B711			LAB_GFPN
  1844 B711 A2 00			LDX	#$00			; clear reg
  1845 B713 86 11			STX	Itempl			; clear temporary integer low byte
  1846 B715			LAB_1785
  1847 B715 86 12			STX	Itemph			; save temporary integer high byte
  1848 B717 B0 F7			BCS	LAB_177F		; return if carry set, end of scan, character was
  1849 									; not 0-9
  1850
  1851 B719 E0 19			CPX	#$19			; compare high byte with $19
  1852 B71B A8				TAY				; ensure Zb = 0 if the branch is taken
  1853 B71C B0 DD			BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  1854 									; bit does *$0A, = 64000, compare at target will fail
  1855 									; and do syntax error
  1856
  1857 B71E E9 2F			SBC	#'0'-1			; subtract '0', $2F + carry, from byte
  1858 B720 A8				TAY				; copy binary digit
  1859 B721 A5 11			LDA	Itempl			; get temporary integer low byte
  1860 B723 0A				ASL				; *2 low byte
  1861 B724 26 12			ROL	Itemph			; *2 high byte
  1862 B726 0A				ASL				; *2 low byte
  1863 B727 26 12			ROL	Itemph			; *2 high byte, *4
  1864 B729 65 11			ADC	Itempl			; + low byte, *5
  1865 B72B 85 11			STA	Itempl			; save it
  1866 B72D 8A				TXA				; get high byte copy to A
  1867 B72E 65 12			ADC	Itemph			; + high byte, *5
  1868 B730 06 11			ASL	Itempl			; *2 low byte, *10d
  1869 B732 2A				ROL				; *2 high byte, *10d
  1870 B733 AA				TAX				; copy high byte back to X
  1871 B734 98				TYA				; get binary digit back
  1872 B735 65 11			ADC	Itempl			; add number low byte
  1873 B737 85 11			STA	Itempl			; save number low byte
  1874 B739 90 01			BCC	LAB_17B3		; if no overflow to high byte get next character
  1875
  1876 B73B E8				INX				; else increment high byte
  1877 B73C			LAB_17B3
  1878 B73C 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1879 B73F 4C 15 B7			JMP	LAB_1785		; loop for next character
  1880
  1881 				; perform DEC
  1882 B742			LAB_DEC
  1883 B742 A9 A7			LDA	#<LAB_2AFD		; set -1 pointer low byte
  1884 B744 2C				.byte	$2C			; BIT abs to skip the LDA below
  1885
  1886 				; perform INC
  1887 B745			LAB_INC
  1888 B745 A9 A3			LDA	#<LAB_259C		; set 1 pointer low byte
  1889 B747			LAB_17B5
  1890 B747 48				PHA				; save +/-1 pointer low byte
  1891 B748			LAB_17B7
  1892 B748 20 67 BD			JSR	LAB_GVAR		; get var address
  1893 B74B A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  1894 B74D 30 1E			BMI	IncrErr			; exit if string
  1895
  1896 B74F 85 57			STA	Lvarpl			; save var address low byte
  1897 B751 84 58			STY	Lvarph			; save var address high byte
  1898 B753 20 48 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1899 B756 68				PLA				; get +/-1 pointer low byte
  1900 B757 48				PHA				; save +/-1 pointer low byte
  1901 B758 A0 D3			LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  1902 B75A 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1
  1903 B75D 20 6E C8			JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
  1904
  1905 B760 20 82 00			JSR	LAB_GBYT		; scan memory
  1906 B763 C9 2C			CMP	#','			; compare with ','
  1907 B765 D0 A8			BNE	LAB_177E		; exit if not ',' (either end or error)
  1908
  1909 									; was ',' so another INCR variable to do
  1910 B767 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  1911 B76A 4C 48 B7			JMP	LAB_17B7		; go do next var
  1912
  1913 B76D			IncrErr
  1914 B76D 4C 97 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  1915
  1916 				; perform LET
  1917 B770			LAB_LET
  1918 B770 20 67 BD			JSR	LAB_GVAR		; get var address
  1919 B773 85 57			STA	Lvarpl			; save var address low byte
  1920 B775 84 58			STY	Lvarph			; save var address high byte
  1921 B777 A9 D7			LDA	#TK_EQUAL		; get = token
  1922 B779 20 AC BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  1923 B77C A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  1924 B77E 48				PHA				; push data type flag
  1925 B77F 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  1926 B782 68				PLA				; pop data type flag
  1927 B783 2A				ROL				; set carry if type = string
  1928 					; patch result of a string compare stores string pointer to variable
  1929 B784 20 8E BA			JSR	LAB_CKTM		; type match check, keep C (expected type)
  1930 B787 B0 03			BCS	LAB_17D5		; branch if string
  1931
  1932 B789 4C 6E C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  1933
  1934 				; string LET
  1935 B78C			LAB_17D5
  1936 B78C A0 02			LDY	#$02			; set index to pointer high byte
  1937 B78E B1 6E			LDA	(des_pl),Y		; get string pointer high byte
  1938 B790 C5 42			CMP	Sstorh			; compare bottom of string space high byte
  1939 B792 90 17			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  1940
  1941 B794 D0 07			BNE	LAB_17E6		; branch if >
  1942 									; else was equal so compare low bytes
  1943 B796 88				DEY				; decrement index
  1944 B797 B1 6E			LDA	(des_pl),Y		; get pointer low byte
  1945 B799 C5 41			CMP	Sstorl			; compare bottom of string space low byte
  1946 B79B 90 0E			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  1947 									; pointer was >= to bottom of string space pointer
  1948 B79D			LAB_17E6
  1949 B79D A4 6F			LDY	des_ph			; get descriptor pointer high byte
  1950 B79F C4 3C			CPY	Svarh			; compare start of vars high byte
  1951 B7A1 90 08			BCC	LAB_17F4		; branch if less (descriptor is on stack)
  1952
  1953 B7A3 D0 0D			BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  1954
  1955 									; else high bytes were equal so ..
  1956 B7A5 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  1957 B7A7 C5 3B			CMP	Svarl			; compare start of vars low byte
  1958 B7A9 B0 07			BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  1959
  1960 B7AB			LAB_17F4
  1961 B7AB A5 6E			LDA	des_pl			; get descriptor pointer low byte
  1962 B7AD A4 6F			LDY	des_ph			; get descriptor pointer high byte
  1963 B7AF 4C C8 B7			JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  1964
  1965 									; make space and copy string
  1966 B7B2			LAB_17FB
  1967 B7B2 A0 00			LDY	#$00			; index to length
  1968 B7B4 B1 6E			LDA	(des_pl),Y		; get string length
  1969 B7B6 20 FB C0			JSR	LAB_209C		; copy string
  1970 B7B9 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  1971 B7BB A4 5F			LDY	des_2h			; get descriptor pointer high byte
  1972 B7BD 85 78			STA	ssptr_l			; save descriptor pointer low byte
  1973 B7BF 84 79			STY	ssptr_h			; save descriptor pointer high byte
  1974 B7C1 20 DC C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  1975 B7C4 A9 6C			LDA	#<FAC1_e		; set descriptor pointer low byte
  1976 B7C6 A0 00			LDY	#>FAC1_e		; get descriptor pointer high byte
  1977
  1978 									; clean stack and assign value to string variable
  1979 B7C8			LAB_1811
  1980 B7C8 85 5E			STA	des_2l			; save descriptor_2 pointer low byte
  1981 B7CA 84 5F			STY	des_2h			; save descriptor_2 pointer high byte
  1982 B7CC 20 3E C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  1983 B7CF A0 00			LDY	#$00			; index to length
  1984 B7D1 B1 5E			LDA	(des_2l),Y		; get string length
  1985 B7D3 91 57			STA	(Lvarpl),Y		; copy to let string variable
  1986 B7D5 C8				INY				; index to string pointer low byte
  1987 B7D6 B1 5E			LDA	(des_2l),Y		; get string pointer low byte
  1988 B7D8 91 57			STA	(Lvarpl),Y		; copy to let string variable
  1989 B7DA C8				INY				; index to string pointer high byte
  1990 B7DB B1 5E			LDA	(des_2l),Y		; get string pointer high byte
  1991 B7DD 91 57			STA	(Lvarpl),Y		; copy to let string variable
  1992 B7DF 60				RTS
  1993
  1994 				; perform GET
  1995 B7E0			LAB_GET
  1996 B7E0 20 67 BD			JSR	LAB_GVAR		; get var address
  1997 B7E3 85 57			STA	Lvarpl			; save var address low byte
  1998 B7E5 84 58			STY	Lvarph			; save var address high byte
  1999 B7E7 20 9A CE			JSR	INGET			; get input byte
  2000 B7EA A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2001 B7EC 30 07			BMI	LAB_GETS		; go get string character
  2002
  2003 									; was numeric get
  2004 B7EE A8				TAY				; copy character to Y
  2005 B7EF 20 2F C0			JSR	LAB_1FD0		; convert Y to byte in FAC1
  2006 B7F2 4C 6E C8			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2007
  2008 B7F5			LAB_GETS
  2009 B7F5 48				PHA				; save character
  2010 B7F6 A9 01			LDA	#$01			; string is single byte
  2011 B7F8 B0 01			BCS	LAB_IsByte		; branch if byte received
  2012
  2013 B7FA 68				PLA				; string is null
  2014 B7FB			LAB_IsByte
  2015 B7FB 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  2016 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2017 B7FE F0 05			BEQ	LAB_NoSt		; skip store if null string
  2018
  2019 B800 68				PLA				; get character back
  2020 B801 A0 00			LDY	#$00			; clear index
  2021 B803 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  2022 B805			LAB_NoSt
  2023 B805 20 50 C1			JSR	LAB_RTST		; check for space on descriptor stack then put address
  2024 									; and length on descriptor stack and update stack pointers
  2025
  2026 B808 4C 8C B7			JMP	LAB_17D5		; do string LET and return
  2027
  2028 				; perform PRINT
  2029 B80B			LAB_1829
  2030 B80B 20 92 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2031 B80E			LAB_182C
  2032 B80E 20 82 00			JSR	LAB_GBYT		; scan memory
  2033
  2034 				; PRINT
  2035 B811			LAB_PRINT
  2036 B811 F0 3B			BEQ	LAB_CRLF		; if nothing following just print CR/LF
  2037
  2038 B813			LAB_1831
  2039 B813 C9 C0			CMP	#TK_TAB			; compare with TAB( token
  2040 B815 F0 56			BEQ	LAB_18A2		; go do TAB/SPC
  2041
  2042 B817 C9 C4			CMP	#TK_SPC			; compare with SPC( token
  2043 B819 F0 52			BEQ	LAB_18A2		; go do TAB/SPC
  2044
  2045 B81B C9 2C			CMP	#','			; compare with ','
  2046 B81D F0 38			BEQ	LAB_188B		; go do move to next TAB mark
  2047
  2048 B81F C9 3B			CMP	#';'			; compare with ';'
  2049 B821 F0 66			BEQ	LAB_18BD		; if ';' continue with PRINT processing
  2050
  2051 B823 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  2052 B826 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2053 B828 30 E1			BMI	LAB_1829		; branch if string
  2054
  2055 B82A 20 60 CA			JSR	LAB_296E		; convert FAC1 to string
  2056 B82D 20 0D C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2057 B830 A0 00			LDY	#$00			; clear index
  2058
  2059 				; don't check fit if terminal width byte is zero
  2060
  2061 B832 A5 0F			LDA	TWidth			; get terminal width byte
  2062 B834 F0 0A			BEQ	LAB_185E		; skip check if zero
  2063
  2064 B836 38				SEC				; set carry for subtract
  2065 B837 E5 0E			SBC	TPos			; subtract terminal position
  2066 B839 F1 6E			SBC	(des_pl),Y		; subtract string length
  2067 B83B B0 03			BCS	LAB_185E		; branch if less than terminal width
  2068
  2069 B83D 20 4E B8			JSR	LAB_CRLF		; else print CR/LF
  2070 B840			LAB_185E
  2071 B840 20 92 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2072 B843 F0 C9			BEQ	LAB_182C		; always go continue processing line
  2073
  2074 				; CR/LF return to BASIC from BASIC input handler
  2075 B845			LAB_1866
  2076 B845 A9 00			LDA	#$00			; clear byte
  2077 B847 9D 7F 18			STA	Ibuffs,X		; null terminate input
  2078 B84A A2 7F			LDX	#<Ibuffs		; set X to buffer start-1 low byte
  2079 B84C A0 18			LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  2080
  2081 				; print CR/LF
  2082 B84E			LAB_CRLF
  2083 B84E A9 0D			LDA	#$0D			; load [CR]
  2084 B850 20 A9 B8			JSR	LAB_PRNA		; go print the character
  2085 B853 A9 0A			LDA	#$0A			; load [LF]
  2086 B855 D0 52			BNE	LAB_PRNA		; go print the character and return, branch always
  2087
  2088 B857			LAB_188B
  2089 B857 A5 0E			LDA	TPos			; get terminal position
  2090 B859 C5 10			CMP	Iclim			; compare with input column limit
  2091 B85B 90 05			BCC	LAB_1897		; branch if less
  2092
  2093 B85D 20 4E B8			JSR	LAB_CRLF		; else print CR/LF (next line)
  2094 B860 D0 27			BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2095
  2096 B862			LAB_1897
  2097 B862 38				SEC				; set carry for subtract
  2098 B863			LAB_1898
  2099 B863 E5 24			SBC	TabSiz			; subtract TAB size
  2100 B865 B0 FC			BCS	LAB_1898		; loop if result was +ve
  2101
  2102 B867 49 FF			EOR	#$FF			; complement it
  2103 B869 69 01			ADC	#$01			; +1 (twos complement)
  2104 B86B D0 12			BNE	LAB_18B6		; always print A spaces (result is never $00)
  2105 									; do TAB/SPC
  2106 B86D			LAB_18A2
  2107 B86D 48				PHA				; save token
  2108 B86E 20 54 C4			JSR	LAB_SGBY		; scan and get byte parameter
  2109 B871 C9 29			CMP	#$29			; is next character )
  2110 B873 D0 7B			BNE	LAB_1910		; if not do syntax error then warm start
  2111
  2112 B875 68				PLA				; get token back
  2113 B876 C9 C0			CMP	#TK_TAB			; was it TAB ?
  2114 B878 D0 06			BNE	LAB_18B7		; if not go do SPC
  2115
  2116 									; calculate TAB offset
  2117 B87A 8A				TXA				; copy integer value to A
  2118 B87B E5 0E			SBC	TPos			; subtract terminal position
  2119 B87D 90 0A			BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  2120 									; print A spaces
  2121 B87F			LAB_18B6
  2122 B87F AA				TAX				; copy result to X
  2123 B880			LAB_18B7
  2124 B880 8A				TXA				; set flags on size for SPC
  2125 B881 F0 06			BEQ	LAB_18BD		; branch if result was = $0, already here
  2126
  2127 									; print X spaces
  2128 B883			LAB_18BA
  2129 B883 20 A4 B8			JSR	LAB_18E0		; print ' '
  2130 B886 CA				DEX				; decrement count
  2131 B887 D0 FA			BNE	LAB_18BA		; loop if not all done
  2132
  2133 									; continue with PRINT processing
  2134 B889			LAB_18BD
  2135 B889 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2136 B88C D0 85			BNE	LAB_1831		; if more to print go do it
  2137
  2138 B88E 60				RTS
  2139
  2140 				; print null terminated string from memory
  2141 B88F			LAB_18C3
  2142 B88F 20 0D C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2143
  2144 				; print string from Sutill/Sutilh
  2145 B892			LAB_18C6
  2146 B892 20 09 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2147 									; space returns with A = length, X=$71=pointer low byte,
  2148 									; Y=$72=pointer high byte
  2149 B895 A0 00			LDY	#$00			; reset index
  2150 B897 AA				TAX				; copy length to X
  2151 B898 F0 49			BEQ	LAB_188C		; exit (RTS) if null string
  2152
  2153 B89A			LAB_18CD
  2154
  2155 B89A B1 31			LDA	(ut1_pl),Y		; get next byte
  2156 B89C 20 A9 B8			JSR	LAB_PRNA		; go print the character
  2157 B89F C8				INY				; increment index
  2158 B8A0 CA				DEX				; decrement count
  2159 B8A1 D0 F7			BNE	LAB_18CD		; loop if not done yet
  2160
  2161 B8A3 60				RTS
  2162
  2163 									; Print single format character
  2164 				; print ' '
  2165 B8A4			LAB_18E0
  2166 B8A4 A9 20			LDA	#$20			; load ' '
  2167 B8A6 2C				.byte	$2C			; change next line to BIT LAB_3FA9
  2168
  2169 				; print '?' character
  2170 B8A7			LAB_18E3
  2171 B8A7 A9 3F			LDA	#$3F			; load '?' character
  2172
  2173 				; print character in A
  2174 				; now includes the null handler
  2175 				; also includes infinite line length code
  2176 				; note! some routines expect this one to exit with Zb=0
  2177 B8A9			LAB_PRNA
  2178 B8A9 C9 20			CMP	#' '			; compare with ' '
  2179 B8AB 90 19			BCC	LAB_18F9		; branch if less (non printing)
  2180
  2181 									; else printable character
  2182 B8AD 48				PHA				; save the character
  2183
  2184 				; don't check fit if terminal width byte is zero
  2185 B8AE A5 0F			LDA	TWidth			; get terminal width
  2186 B8B0 D0 0A			BNE	LAB_18F0		; branch if not zero (not infinite length)
  2187
  2188 				; is 'infinite line' so check TAB position
  2189 B8B2 A5 0E			LDA	TPos			; get position
  2190 B8B4 E5 24			SBC	TabSiz			; subtract TAB size, carry set by CMP #$20 above
  2191 B8B6 D0 0B			BNE	LAB_18F7		; skip reset if different
  2192
  2193 B8B8 85 0E			STA	TPos			; else reset position
  2194 B8BA F0 07			BEQ	LAB_18F7		; go print character
  2195
  2196 B8BC			LAB_18F0
  2197 B8BC C5 0E			CMP	TPos			; compare with terminal character position
  2198 B8BE D0 03			BNE	LAB_18F7		; branch if not at end of line
  2199
  2200 B8C0 20 4E B8			JSR	LAB_CRLF		; else print CR/LF
  2201 B8C3			LAB_18F7
  2202 B8C3 E6 0E			INC	TPos			; increment terminal position
  2203 B8C5 68				PLA				; get character back
  2204 B8C6			LAB_18F9
  2205 B8C6 20 C8 D2			JSR	V_OUTP			; output byte via output vector
  2206 B8C9 C9 0D			CMP	#$0D			; compare with [CR]
  2207 B8CB D0 14			BNE	LAB_188A		; branch if not [CR]
  2208
  2209 									; else print nullct nulls after the [CR]
  2210 B8CD 86 38			STX	TempB			; save buffer index
  2211 B8CF A6 0D			LDX	Nullct			; get null count
  2212 B8D1 F0 0A			BEQ	LAB_1886		; branch if no nulls
  2213
  2214 B8D3 A9 00			LDA	#$00			; load [NULL]
  2215 B8D5			LAB_1880
  2216 B8D5 20 A9 B8			JSR	LAB_PRNA		; go print the character
  2217 B8D8 CA				DEX				; decrement count
  2218 B8D9 D0 FA			BNE	LAB_1880		; loop if not all done
  2219
  2220 B8DB A9 0D			LDA	#$0D			; restore the character (and set the flags)
  2221 B8DD			LAB_1886
  2222 B8DD 86 0E			STX	TPos			; clear terminal position (X always = zero when we get here)
  2223 B8DF A6 38			LDX	TempB			; restore buffer index
  2224 B8E1			LAB_188A
  2225 B8E1 29 FF			AND	#$FF			; set the flags
  2226 B8E3			LAB_188C
  2227 B8E3 60				RTS
  2228
  2229 				; handle bad input data
  2230 B8E4			LAB_1904
  2231 B8E4 A5 22			LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
  2232 B8E6 10 0B			BPL	LAB_1913		; branch if INPUT (go do redo)
  2233
  2234 B8E8 A5 4D			LDA	Dlinel			; get current DATA line low byte
  2235 B8EA A4 4E			LDY	Dlineh			; get current DATA line high byte
  2236 B8EC 85 47			STA	Clinel			; save current line low byte
  2237 B8EE 84 48			STY	Clineh			; save current line high byte
  2238 B8F0			LAB_1910
  2239 B8F0 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  2240
  2241 									; mode was INPUT
  2242 B8F3			LAB_1913
  2243 B8F3 A9 F5			LDA	#<LAB_REDO		; point to redo message (low addr)
  2244 B8F5 A0 DA			LDY	#>LAB_REDO		; point to redo message (high addr)
  2245 B8F7 20 8F B8			JSR	LAB_18C3		; print null terminated string from memory
  2246 B8FA A5 4B			LDA	Cpntrl			; get continue pointer low byte
  2247 B8FC A4 4C			LDY	Cpntrh			; get continue pointer high byte
  2248 B8FE 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2249 B900 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  2250 B902 60				RTS
  2251
  2252 				; perform INPUT
  2253 B903			LAB_INPUT
  2254 B903 C9 22			CMP	#$22			; compare next byte with open quote
  2255 B905 D0 0B			BNE	LAB_1934		; branch if no prompt string
  2256
  2257 B907 20 79 BB			JSR	LAB_1BC1		; print '...' string
  2258 B90A A9 3B			LDA	#$3B			; load A with ';'
  2259 B90C 20 AC BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2260 B90F 20 92 B8			JSR	LAB_18C6		; print string from Sutill/Sutilh
  2261
  2262 									; done with prompt, now get data
  2263 B912			LAB_1934
  2264 B912 20 33 C0			JSR	LAB_CKRN		; check not Direct, back here if ok
  2265 B915 20 08 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2266 B918 A9 00			LDA	#$00			; set mode = INPUT
  2267 B91A CD 7F 18			CMP	Ibuffs			; test first byte in buffer
  2268 B91D D0 09			BNE	LAB_1953		; branch if not null input
  2269
  2270 					; *** change p2: keep carry set to throw break message
  2271 					;CLC				; was null input so clear carry to exit program
  2272 B91F 4C FB B4			JMP	LAB_1647		; go do BREAK exit
  2273
  2274 				; perform READ
  2275 B922			LAB_READ
  2276 B922 A6 4F			LDX	Dptrl			; get DATA pointer low byte
  2277 B924 A4 50			LDY	Dptrh			; get DATA pointer high byte
  2278 B926 A9 80			LDA	#$80			; set mode = READ
  2279
  2280 B928			LAB_1953
  2281 B928 85 22			STA	Imode			; set input mode flag, $00=INPUT, $80=READ
  2282 B92A 86 51			STX	Rdptrl			; save READ pointer low byte
  2283 B92C 84 52			STY	Rdptrh			; save READ pointer high byte
  2284 									; READ or INPUT next variable from list
  2285 B92E			LAB_195B
  2286 B92E 20 67 BD			JSR	LAB_GVAR		; get (var) address
  2287 B931 85 57			STA	Lvarpl			; save address low byte
  2288 B933 84 58			STY	Lvarph			; save address high byte
  2289 B935 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2290 B937 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2291 B939 85 11			STA	Itempl			; save as temporary integer low byte
  2292 B93B 84 12			STY	Itemph			; save as temporary integer high byte
  2293 B93D A6 51			LDX	Rdptrl			; get READ pointer low byte
  2294 B93F A4 52			LDY	Rdptrh			; get READ pointer high byte
  2295 B941 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2296 B943 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2297 B945 20 82 00			JSR	LAB_GBYT		; scan memory
  2298 B948 D0 11			BNE	LAB_1988		; branch if not null
  2299
  2300 									; pointer was to null entry
  2301 B94A 24 22			BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
  2302 B94C 30 65			BMI	LAB_19DD		; branch if READ
  2303
  2304 									; mode was INPUT
  2305 B94E 20 A7 B8			JSR	LAB_18E3		; print '?' character (double ? for extended input)
  2306 B951 20 08 B2			JSR	LAB_INLN		; print '? ' and get BASIC input
  2307 B954 86 83			STX	Bpntrl			; set BASIC execute pointer low byte
  2308 B956 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2309 B958			LAB_1985
  2310 B958 20 82 00			JSR	LAB_GBYT		; scan memory
  2311 B95B			LAB_1988
  2312 B95B 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2313 B95D 10 24			BPL	LAB_19B0		; branch if numeric
  2314
  2315 									; else get string
  2316 B95F 85 1B			STA	Srchc			; save search character
  2317 B961 C9 22			CMP	#$22			; was it ' ?
  2318 B963 F0 07			BEQ	LAB_1999		; branch if so
  2319
  2320 B965 A9 3A			LDA	#':'			; else search character is ':'
  2321 B967 85 1B			STA	Srchc			; set new search character
  2322 B969 A9 2C			LDA	#','			; other search character is ','
  2323 B96B 18				CLC				; clear carry for add
  2324 B96C			LAB_1999
  2325 B96C 85 1C			STA	Asrch			; set second search character
  2326 B96E A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2327 B970 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2328
  2329 B972 69 00			ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2330 B974 90 01			BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2331
  2332 B976 C8				INY				; else increment high byte
  2333 B977			LAB_19A4
  2334 B977 20 13 C1			JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
  2335 B97A 20 9A C4			JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2336 B97D 20 8C B7			JSR	LAB_17D5		; go do string LET
  2337 B980 4C 89 B9			JMP	LAB_19B6		; go check string terminator
  2338
  2339 									; get numeric INPUT
  2340 B983			LAB_19B0
  2341 B983 20 71 C9			JSR	LAB_2887		; get FAC1 from string
  2342 B986 20 6E C8			JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
  2343 B989			LAB_19B6
  2344 B989 20 82 00			JSR	LAB_GBYT		; scan memory
  2345 B98C F0 0A			BEQ	LAB_19C5		; branch if null (last entry)
  2346
  2347 B98E C9 2C			CMP	#','			; else compare with ','
  2348 B990 F0 03			BEQ	LAB_19C2		; branch if ','
  2349
  2350 B992 4C E4 B8			JMP	LAB_1904		; else go handle bad input data
  2351
  2352 									; got good input data
  2353 B995			LAB_19C2
  2354 B995 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2355 B998			LAB_19C5
  2356 B998 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2357 B99A A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2358 B99C 85 51			STA	Rdptrl			; save for now
  2359 B99E 84 52			STY	Rdptrh			; save for now
  2360 B9A0 A5 11			LDA	Itempl			; get temporary integer low byte (temp BASIC execute ptr)
  2361 B9A2 A4 12			LDY	Itemph			; get temporary integer high byte (temp BASIC execute ptr)
  2362 B9A4 85 83			STA	Bpntrl			; set BASIC execute pointer low byte
  2363 B9A6 84 84			STY	Bpntrh			; set BASIC execute pointer high byte
  2364 B9A8 20 82 00			JSR	LAB_GBYT		; scan memory
  2365 B9AB F0 2C			BEQ	LAB_1A03		; if null go do extra ignored message
  2366
  2367 B9AD 20 B9 BB			JSR	LAB_1C01		; else scan for ',' , else do syntax error then warm start
  2368 B9B0 4C 2E B9			JMP	LAB_195B		; go INPUT next variable from list
  2369
  2370 									; find next DATA statement or do 'Out of DATA' error
  2371 B9B3			LAB_19DD
  2372 B9B3 20 64 B6			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2373 B9B6 C8				INY				; increment index
  2374 B9B7 AA				TAX				; copy character ([:] or [EOL])
  2375 B9B8 D0 12			BNE	LAB_19F6		; branch if [:]
  2376
  2377 B9BA A2 06			LDX	#$06			; set for 'Out of DATA' error
  2378 B9BC C8				INY				; increment index, now points to next line pointer high byte
  2379 B9BD B1 83			LDA	(Bpntrl),Y		; get next line pointer high byte
  2380 B9BF F0 73			BEQ	LAB_1A54		; branch if end (eventually does error X)
  2381
  2382 B9C1 C8				INY				; increment index
  2383 B9C2 B1 83			LDA	(Bpntrl),Y		; get next line # low byte
  2384 B9C4 85 4D			STA	Dlinel			; save current DATA line low byte
  2385 B9C6 C8				INY				; increment index
  2386 B9C7 B1 83			LDA	(Bpntrl),Y		; get next line # high byte
  2387 B9C9 C8				INY				; increment index
  2388 B9CA 85 4E			STA	Dlineh			; save current DATA line high byte
  2389 B9CC			LAB_19F6
  2390 B9CC B1 83			LDA	(Bpntrl),Y		; get byte
  2391 B9CE C8				INY				; increment index
  2392 B9CF AA				TAX				; copy to X
  2393 B9D0 20 56 B6			JSR	LAB_170F		; set BASIC execute pointer
  2394 B9D3 E0 83			CPX	#TK_DATA		; compare with 'DATA' token
  2395 B9D5 F0 81			BEQ	LAB_1985		; was 'DATA' so go do next READ
  2396
  2397 B9D7 D0 DA			BNE	LAB_19DD		; go find next statement if not 'DATA'
  2398
  2399 				; end of INPUT/READ routine
  2400 B9D9			LAB_1A03
  2401 B9D9 A5 51			LDA	Rdptrl			; get temp READ pointer low byte
  2402 B9DB A4 52			LDY	Rdptrh			; get temp READ pointer high byte
  2403 B9DD A6 22			LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
  2404 B9DF 10 03			BPL	LAB_1A0E		; branch if INPUT
  2405
  2406 B9E1 4C 1D B5			JMP	LAB_1624		; save AY as DATA pointer and return
  2407
  2408 									; we were getting INPUT
  2409 B9E4			LAB_1A0E
  2410 B9E4 A0 00			LDY	#$00			; clear index
  2411 B9E6 B1 51			LDA	(Rdptrl),Y		; get next byte
  2412 B9E8 D0 01			BNE	LAB_1A1B		; error if not end of INPUT
  2413
  2414 B9EA 60				RTS
  2415
  2416 									; user typed too much
  2417 B9EB			LAB_1A1B
  2418 B9EB A9 E4			LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2419 B9ED A0 DA			LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2420 B9EF 4C 8F B8			JMP	LAB_18C3		; print null terminated string from memory and return
  2421
  2422 				; search the stack for FOR activity
  2423 				; exit with z=1 if FOR else exit with z=0
  2424 B9F2			LAB_11A1
  2425 B9F2 BA				TSX				; copy stack pointer
  2426 B9F3 E8				INX				; +1 pass return address
  2427 B9F4 E8				INX				; +2 pass return address
  2428 B9F5 E8				INX				; +3 pass calling routine return address
  2429 B9F6 E8				INX				; +4 pass calling routine return address
  2430 B9F7			LAB_11A6
  2431 B9F7 BD 01 01			LDA	LAB_STAK+1,X		; get token byte from stack
  2432 B9FA C9 81			CMP	#TK_FOR			; is it FOR token
  2433 B9FC D0 21			BNE	LAB_11CE		; exit if not FOR token
  2434
  2435 									; was FOR token
  2436 B9FE A5 58			LDA	Frnxth			; get var pointer for FOR/NEXT high byte
  2437 BA00 D0 0A			BNE	LAB_11BB		; branch if not null
  2438
  2439 BA02 BD 02 01			LDA	LAB_STAK+2,X		; get FOR variable pointer low byte
  2440 BA05 85 57			STA	Frnxtl			; save var pointer for FOR/NEXT low byte
  2441 BA07 BD 03 01			LDA	LAB_STAK+3,X		; get FOR variable pointer high byte
  2442 BA0A 85 58			STA	Frnxth			; save var pointer for FOR/NEXT high byte
  2443 BA0C			LAB_11BB
  2444 BA0C DD 03 01			CMP	LAB_STAK+3,X		; compare var pointer with stacked var pointer (high byte)
  2445 BA0F D0 07			BNE	LAB_11C7		; branch if no match
  2446
  2447 BA11 A5 57			LDA	Frnxtl			; get var pointer for FOR/NEXT low byte
  2448 BA13 DD 02 01			CMP	LAB_STAK+2,X		; compare var pointer with stacked var pointer (low byte)
  2449 BA16 F0 07			BEQ	LAB_11CE		; exit if match found
  2450
  2451 BA18			LAB_11C7
  2452 BA18 8A				TXA				; copy index
  2453 BA19 18				CLC				; clear carry for add
  2454 BA1A 69 10			ADC	#$10			; add FOR stack use size
  2455 BA1C AA				TAX				; copy back to index
  2456 BA1D D0 D8			BNE	LAB_11A6		; loop if not at start of stack
  2457
  2458 BA1F			LAB_11CE
  2459 BA1F 60				RTS
  2460
  2461 				; perform NEXT
  2462 BA20			LAB_NEXT
  2463 BA20 D0 04			BNE	LAB_1A46		; branch if NEXT var
  2464
  2465 BA22 A0 00			LDY	#$00			; else clear Y
  2466 BA24 F0 03			BEQ	LAB_1A49		; branch always (no variable to search for)
  2467
  2468 				; NEXT var
  2469 BA26			LAB_1A46
  2470 BA26 20 67 BD			JSR	LAB_GVAR		; get variable address
  2471 BA29			LAB_1A49
  2472 BA29 85 57			STA	Frnxtl			; store variable pointer low byte
  2473 BA2B 84 58			STY	Frnxth			; store variable pointer high byte
  2474 									; (both cleared if no variable defined)
  2475 BA2D 20 F2 B9			JSR	LAB_11A1		; search the stack for FOR activity
  2476 BA30 F0 04			BEQ	LAB_1A56		; branch if found
  2477
  2478 BA32 A2 00			LDX	#$00			; else set error $00 ('NEXT without FOR' error)
  2479 BA34			LAB_1A54
  2480 BA34 F0 63			BEQ	LAB_1ABE		; do error #X, then warm start
  2481
  2482 BA36			LAB_1A56
  2483 BA36 9A				TXS				; set stack pointer, X set by search, dumps return addresses
  2484
  2485 BA37 8A				TXA				; copy stack pointer
  2486 BA38 38				SEC				; set carry for subtract
  2487 BA39 E9 F7			SBC	#$F7			; point to TO var
  2488 BA3B 85 33			STA	ut2_pl			; save pointer to TO var for compare
  2489 BA3D 69 FB			ADC	#$FB			; point to STEP var
  2490
  2491 BA3F A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2492 BA41 20 48 C8			JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
  2493 BA44 BA				TSX				; get stack pointer back
  2494 BA45 BD 08 01			LDA	LAB_STAK+8,X		; get step sign
  2495 BA48 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  2496 BA4A A5 57			LDA	Frnxtl			; get FOR variable pointer low byte
  2497 BA4C A4 58			LDY	Frnxth			; get FOR variable pointer high byte
  2498 BA4E 20 89 C5			JSR	LAB_246C		; add (FOR variable) to FAC1
  2499 BA51 20 6E C8			JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2500 BA54 A0 01			LDY	#>LAB_STAK		; point to stack page high byte
  2501 BA56 20 E4 C8			JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
  2502 BA59 BA				TSX				; get stack pointer back
  2503 BA5A DD 08 01			CMP	LAB_STAK+8,X		; compare step sign
  2504 BA5D F0 17			BEQ	LAB_1A9B		; branch if = (loop complete)
  2505
  2506 									; loop back and do it all again
  2507 BA5F BD 0D 01			LDA	LAB_STAK+$0D,X		; get FOR line low byte
  2508 BA62 85 47			STA	Clinel			; save current line low byte
  2509 BA64 BD 0E 01			LDA	LAB_STAK+$0E,X		; get FOR line high byte
  2510 BA67 85 48			STA	Clineh			; save current line high byte
  2511 BA69 BD 10 01			LDA	LAB_STAK+$10,X		; get BASIC execute pointer low byte
  2512 BA6C 85 83			STA	Bpntrl			; save BASIC execute pointer low byte
  2513 BA6E BD 0F 01			LDA	LAB_STAK+$0F,X		; get BASIC execute pointer high byte
  2514 BA71 85 84			STA	Bpntrh			; save BASIC execute pointer high byte
  2515 BA73			LAB_1A98
  2516 BA73 4C 93 B4			JMP	LAB_15C2		; go do interpreter inner loop
  2517
  2518 									; loop complete so carry on
  2519 BA76			LAB_1A9B
  2520 BA76 8A				TXA				; stack copy to A
  2521 BA77 69 0F			ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
  2522 BA79 AA				TAX				; copy back to index
  2523 BA7A 9A				TXS				; copy to stack pointer
  2524 BA7B 20 82 00			JSR	LAB_GBYT		; scan memory
  2525 BA7E C9 2C			CMP	#','			; compare with ','
  2526 BA80 D0 F1			BNE	LAB_1A98		; branch if not ',' (go do interpreter inner loop)
  2527
  2528 									; was ',' so another NEXT variable to do
  2529 BA82 20 7C 00			JSR	LAB_IGBY		; else increment and scan memory
  2530 BA85 20 26 BA			JSR	LAB_1A46		; do NEXT (var)
  2531
  2532 				; evaluate expression and check is numeric, else do type mismatch
  2533 BA88			LAB_EVNM
  2534 BA88 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  2535
  2536 				; check if source is numeric, else do type mismatch
  2537 BA8B			LAB_CTNM
  2538 BA8B 18				CLC				; destination is numeric
  2539 BA8C 24				.byte	$24			; makes next line BIT $38
  2540
  2541 				; check if source is string, else do type mismatch
  2542 BA8D			LAB_CTST
  2543 BA8D 38				SEC				; required type is string
  2544
  2545 				; type match check, set C for string, clear C for numeric
  2546 BA8E			LAB_CKTM
  2547 BA8E 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2548 BA90 30 03			BMI	LAB_1ABA		; branch if data type is string
  2549
  2550 									; else data type was numeric
  2551 BA92 B0 03			BCS	LAB_1ABC		; if required type is string do type mismatch error
  2552 BA94			LAB_1AB9
  2553 BA94 60				RTS
  2554
  2555 									; data type was string, now check required type
  2556 BA95			LAB_1ABA
  2557 BA95 B0 FD			BCS	LAB_1AB9		; exit if required type is string
  2558
  2559 									; else do type mismatch error
  2560 BA97			LAB_1ABC
  2561 BA97 A2 18			LDX	#$18			; error code $18 ('Type mismatch' error)
  2562 BA99			LAB_1ABE
  2563 BA99 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  2564
  2565 				; evaluate expression
  2566 BA9C			LAB_EVEX
  2567 BA9C A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2568 BA9E D0 02			BNE	LAB_1AC7		; skip next if not zero
  2569
  2570 BAA0 C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2571 BAA2			LAB_1AC7
  2572 BAA2 C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2573
  2574 BAA4			LAB_EVEZ
  2575 BAA4 A9 00			LDA	#$00			; set null precedence (flag done)
  2576 BAA6			LAB_1ACC
  2577 BAA6 48				PHA				; push precedence byte
  2578 BAA7 A9 02			LDA	#$02			; 2 bytes
  2579 BAA9 20 CB B0			JSR	LAB_1212		; check room on stack for A bytes
  2580 BAAC 20 88 BB			JSR	LAB_GVAL		; get value from line
  2581 BAAF A9 00			LDA	#$00			; clear A
  2582 BAB1 85 5B			STA	comp_f			; clear compare function flag
  2583 BAB3			LAB_1ADB
  2584 BAB3 20 82 00			JSR	LAB_GBYT		; scan memory
  2585 BAB6			LAB_1ADE
  2586 BAB6 38				SEC				; set carry for subtract
  2587 BAB7 E9 D6			SBC	#TK_GT			; subtract token for > (lowest comparison function)
  2588 BAB9 90 17			BCC	LAB_1AFA		; branch if < TK_GT
  2589
  2590 BABB C9 03			CMP	#$03			; compare with '>' to '<' tokens
  2591 BABD B0 13			BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2592
  2593 									; was token for > = or < (A = 0, 1 or 2)
  2594 BABF C9 01			CMP	#$01			; compare with token for =
  2595 BAC1 2A				ROL				; *2, b0 = carry (=1 if token was = or <)
  2596 									; (A = 0, 3 or 5)
  2597 BAC2 49 01			EOR	#$01			; toggle b0
  2598 									; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2599 BAC4 45 5B			EOR	comp_f			; EOR with compare function flag bits
  2600 BAC6 C5 5B			CMP	comp_f			; compare with compare function flag
  2601 BAC8 90 67			BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
  2602 									; was more than one <, = or >)
  2603
  2604 BACA 85 5B			STA	comp_f			; save new compare function flag
  2605 BACC 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2606 BACF 4C B6 BA			JMP	LAB_1ADE		; go do next character
  2607
  2608 									; token is < '>' or > '<' tokens
  2609 BAD2			LAB_1AFA
  2610 BAD2 A6 5B			LDX	comp_f			; get compare function flag
  2611 BAD4 D0 2C			BNE	LAB_1B2A		; branch if compare function
  2612
  2613 BAD6 B0 79			BCS	LAB_1B78		; go do functions
  2614
  2615 									; else was <  TK_GT so is operator or lower
  2616 BAD8 69 0B			ADC	#TK_GT-TK_PLUS		; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2617 BADA 90 75			BCC	LAB_1B78		; branch if < + operator
  2618
  2619 									; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2620 BADC D0 07			BNE	LAB_1B0B		; branch if not + token
  2621
  2622 BADE 24 1F			BIT	Dtypef			; test data type flag, $FF=string, $00=numeric
  2623 BAE0 10 03			BPL	LAB_1B0B		; branch if not string
  2624
  2625 									; will only be $00 if type is string and token was +
  2626 BAE2 4C 9F C2			JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
  2627 									; is in line, and return
  2628
  2629 BAE5			LAB_1B0B
  2630 BAE5 85 31			STA	ut1_pl			; save it
  2631 BAE7 0A				ASL				; *2
  2632 BAE8 65 31			ADC	ut1_pl			; *3
  2633 BAEA A8				TAY				; copy to index
  2634 BAEB			LAB_1B13
  2635 BAEB 68				PLA				; pull previous precedence
  2636 BAEC D9 E6 D4			CMP	LAB_OPPT,Y		; compare with precedence byte
  2637 BAEF B0 65			BCS	LAB_1B7D		; branch if A >=
  2638
  2639 BAF1 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2640 BAF4			LAB_1B1C
  2641 BAF4 48				PHA				; save precedence
  2642 BAF5			LAB_1B1D
  2643 BAF5 20 1D BB			JSR	LAB_1B43		; get vector, execute function then continue evaluation
  2644 BAF8 68				PLA				; restore precedence
  2645 BAF9 A4 59			LDY	prstk			; get precedence stacked flag
  2646 BAFB 10 19			BPL	LAB_1B3C		; branch if stacked values
  2647
  2648 BAFD AA				TAX				; copy precedence (set flags)
  2649 BAFE F0 76			BEQ	LAB_1B9D		; exit if done
  2650
  2651 BB00 D0 5D			BNE	LAB_1B86		; else pop FAC2 and return, branch always
  2652
  2653 BB02			LAB_1B2A
  2654 BB02 26 1F			ROL	Dtypef			; shift data type flag into Cb
  2655 BB04 8A				TXA				; copy compare function flag
  2656 BB05 85 1F			STA	Dtypef			; clear data type flag, X is 0xxx xxxx
  2657 BB07 2A				ROL				; shift data type into compare function byte b0
  2658 BB08 A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  2659 BB0A D0 02			BNE	LAB_1B34		; branch if no underflow
  2660
  2661 BB0C C6 84			DEC	Bpntrh			; else decrement BASIC execute pointer high byte
  2662 BB0E			LAB_1B34
  2663 BB0E C6 83			DEC	Bpntrl			; decrement BASIC execute pointer low byte
  2664 = 000D			TK_LT_PLUS	= TK_LT-TK_PLUS
  2665 BB10 A0 27			LDY	#TK_LT_PLUS*3		; set offset to last operator entry
  2666 BB12 85 5B			STA	comp_f			; save new compare function flag
  2667 BB14 D0 D5			BNE	LAB_1B13		; branch always
  2668
  2669 BB16			LAB_1B3C
  2670 BB16 D9 E6 D4			CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  2671 BB19 B0 44			BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  2672
  2673 BB1B 90 D7			BCC	LAB_1B1C		; branch always
  2674
  2675 				;.get vector, execute function then continue evaluation
  2676 BB1D			LAB_1B43
  2677 BB1D B9 E8 D4			LDA	LAB_OPPT+2,Y		; get function vector high byte
  2678 BB20 48				PHA				; onto stack
  2679 BB21 B9 E7 D4			LDA	LAB_OPPT+1,Y		; get function vector low byte
  2680 BB24 48				PHA				; onto stack
  2681 									; now push sign, round FAC1 and put on stack
  2682 BB25 20 34 BB			JSR	LAB_1B5B		; function will return here, then the next RTS will call
  2683 									; the function
  2684 BB28 A5 5B			LDA	comp_f			; get compare function flag
  2685 BB2A 48				PHA				; push compare evaluation byte
  2686 BB2B B9 E6 D4			LDA	LAB_OPPT,Y		; get precedence byte
  2687 BB2E 4C A6 BA			JMP	LAB_1ACC		; continue evaluating expression
  2688
  2689 BB31			LAB_1B53
  2690 BB31 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  2691
  2692 				; push sign, round FAC1 and put on stack
  2693 BB34			LAB_1B5B
  2694 BB34 68				PLA				; get return addr low byte
  2695 BB35 85 31			STA	ut1_pl			; save it
  2696 BB37 E6 31			INC	ut1_pl			; increment it (was ret-1 pushed? yes!)
  2697 									; note! no check is made on the high byte! if the calling
  2698 									; routine assembles to a page edge then this all goes
  2699 									; horribly wrong !!!
  2700 BB39 68				PLA				; get return addr high byte
  2701 BB3A 85 32			STA	ut1_ph			; save it
  2702 BB3C A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  2703 BB3E 48				PHA				; push sign
  2704
  2705 				; round FAC1 and put on stack
  2706 BB3F			LAB_1B66
  2707 BB3F 20 A4 C8			JSR	LAB_27BA		; round FAC1
  2708 BB42 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  2709 BB44 48				PHA				; push on stack
  2710 BB45 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  2711 BB47 48				PHA				; push on stack
  2712 BB48 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  2713 BB4A 48				PHA				; push on stack
  2714 BB4B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  2715 BB4D 48				PHA				; push on stack
  2716 BB4E 6C 31 00			JMP	(ut1_pl)		; return, sort of
  2717
  2718 				; do functions
  2719 BB51			LAB_1B78
  2720 BB51 A0 FF			LDY	#$FF			; flag function
  2721 BB53 68				PLA				; pull precedence byte
  2722 BB54			LAB_1B7B
  2723 BB54 F0 20			BEQ	LAB_1B9D		; exit if done
  2724
  2725 BB56			LAB_1B7D
  2726 BB56 C9 64			CMP	#$64			; compare previous precedence with $64
  2727 BB58 F0 03			BEQ	LAB_1B84		; branch if was $64 (< function)
  2728
  2729 BB5A 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2730 BB5D			LAB_1B84
  2731 BB5D 84 59			STY	prstk			; save precedence stacked flag
  2732
  2733 									; pop FAC2 and return
  2734 BB5F			LAB_1B86
  2735 BB5F 68				PLA				; pop byte
  2736 BB60 4A				LSR				; shift out comparison evaluation lowest bit
  2737 BB61 85 23			STA	Cflag			; save comparison evaluation flag
  2738 BB63 68				PLA				; pop exponent
  2739 BB64 85 73			STA	FAC2_e			; save FAC2 exponent
  2740 BB66 68				PLA				; pop mantissa1
  2741 BB67 85 74			STA	FAC2_1			; save FAC2 mantissa1
  2742 BB69 68				PLA				; pop mantissa2
  2743 BB6A 85 75			STA	FAC2_2			; save FAC2 mantissa2
  2744 BB6C 68				PLA				; pop mantissa3
  2745 BB6D 85 76			STA	FAC2_3			; save FAC2 mantissa3
  2746 BB6F 68				PLA				; pop sign
  2747 BB70 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  2748 BB72 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  2749 BB74 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  2750 BB76			LAB_1B9D
  2751 BB76 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  2752 BB78 60				RTS
  2753
  2754 				; print '...' string to string util area
  2755 BB79			LAB_1BC1
  2756 BB79 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  2757 BB7B A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  2758 BB7D 69 00			ADC	#$00			; add carry to low byte
  2759 BB7F 90 01			BCC	LAB_1BCA		; branch if no overflow
  2760
  2761 BB81 C8				INY				; increment high byte
  2762 BB82			LAB_1BCA
  2763 BB82 20 0D C1			JSR	LAB_20AE		; print ' terminated string to Sutill/Sutilh
  2764 BB85 4C 9A C4			JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  2765
  2766 				; get value from line
  2767 BB88			LAB_GVAL
  2768 BB88 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  2769 BB8B B0 03			BCS	LAB_1BAC		; branch if not numeric character
  2770
  2771 									; else numeric string found (e.g. 123)
  2772 BB8D			LAB_1BA9
  2773 BB8D 4C 71 C9			JMP	LAB_2887		; get FAC1 from string and return
  2774
  2775 				; get value from line .. continued
  2776 									; wasn't a number so ..
  2777 BB90			LAB_1BAC
  2778 BB90 AA				TAX				; set the flags
  2779 BB91 30 2F			BMI	LAB_1BD0		; if -ve go test token values
  2780
  2781 									; else it is either a string, number, variable or (<expr>)
  2782 BB93 C9 24			CMP	#'$'			; compare with '$'
  2783 BB95 F0 F6			BEQ	LAB_1BA9		; branch if '$', hex number
  2784
  2785 BB97 C9 25			CMP	#'%'			; else compare with '%'
  2786 BB99 F0 F2			BEQ	LAB_1BA9		; branch if '%', binary number
  2787
  2788 BB9B C9 2E			CMP	#'.'			; compare with '.'
  2789 BB9D F0 EE			BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  2790
  2791 									; it wasn't any sort of number so ..
  2792 BB9F C9 22			CMP	#$22			; compare with '
  2793 BBA1 F0 D6			BEQ	LAB_1BC1		; branch if open quote
  2794
  2795 									; wasn't any sort of number so ..
  2796
  2797 				; evaluate expression within parentheses
  2798 BBA3 C9 28			CMP	#'('			; compare with '('
  2799 BBA5 D0 4F			BNE	LAB_1C18		; if not '(' get (var), return value in FAC1 and $ flag
  2800
  2801 BBA7			LAB_1BF7
  2802 BBA7 20 A4 BA			JSR	LAB_EVEZ		; evaluate expression, no decrement
  2803
  2804 				; all the 'scan for' routines return the character after the sought character
  2805
  2806 				; scan for ')' , else do syntax error then warm start
  2807 BBAA			LAB_1BFB
  2808 BBAA A9 29			LDA	#$29			; load A with ')'
  2809
  2810 				; scan for CHR$(A) , else do syntax error then warm start
  2811 BBAC			LAB_SCCA
  2812 BBAC A0 00			LDY	#$00			; clear index
  2813 BBAE D1 83			CMP	(Bpntrl),Y		; check next byte is = A
  2814 BBB0 D0 0B			BNE	LAB_SNER		; if not do syntax error then warm start
  2815
  2816 BBB2 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then return
  2817
  2818 				; scan for '(' , else do syntax error then warm start
  2819 BBB5			LAB_1BFE
  2820 BBB5 A9 28			LDA	#$28			; load A with '('
  2821 BBB7 D0 F3			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2822 									; (branch always)
  2823
  2824 				; scan for ',' , else do syntax error then warm start
  2825 BBB9			LAB_1C01
  2826 BBB9 A9 2C			LDA	#$2C			; load A with ','
  2827 BBBB D0 EF			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2828 									; (branch always)
  2829
  2830 				; syntax error then warm start
  2831 BBBD			LAB_SNER
  2832 BBBD A2 02			LDX	#$02			; error code $02 ('Syntax' error)
  2833 BBBF 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  2834
  2835 				; get value from line .. continued
  2836 				; do tokens
  2837 BBC2			LAB_1BD0
  2838 BBC2 C9 CC			CMP	#TK_MINUS		; compare with token for -
  2839 BBC4 F0 29			BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  2840
  2841 									; wasn't -n so ..
  2842 BBC6 C9 CB			CMP	#TK_PLUS		; compare with token for +
  2843 BBC8 F0 BE			BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  2844
  2845 BBCA C9 C6			CMP	#TK_NOT		; compare with token for NOT
  2846 BBCC D0 13			BNE	LAB_1BE7		; branch if not token for NOT
  2847
  2848 									; was NOT token
  2849 = 000C			TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
  2850 BBCE A0 24			LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  2851 BBD0 D0 1F			BNE	LAB_1C13		; do set-up for function then execute (branch always)
  2852
  2853 				; do = compare
  2854 BBD2			LAB_EQUAL
  2855 BBD2 20 63 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  2856 BBD5 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  2857 BBD7 49 FF			EOR	#$FF			; invert it
  2858 BBD9 A8				TAY				; copy it
  2859 BBDA A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  2860 BBDC 49 FF			EOR	#$FF			; invert it
  2861 BBDE 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  2862
  2863 				; get value from line .. continued
  2864 									; wasn't +, -, or NOT so ..
  2865 BBE1			LAB_1BE7
  2866 BBE1 C9 C3			CMP	#TK_FN			; compare with token for FN
  2867 BBE3 D0 03			BNE	LAB_1BEE		; branch if not token for FN
  2868
  2869 BBE5 4C 7D C0			JMP	LAB_201E		; go evaluate FNx
  2870
  2871 				; get value from line .. continued
  2872 									; wasn't +, -, NOT or FN so ..
  2873 BBE8			LAB_1BEE
  2874 BBE8 E9 D9			SBC	#TK_SGN			; subtract with token for SGN
  2875 BBEA B0 1B			BCS	LAB_1C27		; if a function token go do it
  2876
  2877 BBEC 4C BD BB			JMP	LAB_SNER		; else do syntax error
  2878
  2879 				; set-up for functions
  2880 BBEF			LAB_1C11
  2881 = 000B			TK_GT_PLUS	= TK_GT-TK_PLUS
  2882 BBEF A0 21			LDY	#TK_GT_PLUS*3		; set offset from base to > operator
  2883 BBF1			LAB_1C13
  2884 BBF1 68				PLA				; dump return address low byte
  2885 BBF2 68				PLA				; dump return address high byte
  2886 BBF3 4C F5 BA			JMP	LAB_1B1D		; execute function then continue evaluation
  2887
  2888 				; variable name set-up
  2889 				; get (var), return value in FAC_1 and $ flag
  2890 BBF6			LAB_1C18
  2891 BBF6 20 67 BD			JSR	LAB_GVAR		; get (var) address
  2892 BBF9 85 6E			STA	FAC1_2			; save address low byte in FAC1 mantissa2
  2893 BBFB 84 6F			STY	FAC1_3			; save address high byte in FAC1 mantissa3
  2894 BBFD A6 1F			LDX	Dtypef			; get data type flag, $FF=string, $00=numeric
  2895 BBFF 30 03			BMI	LAB_1C25		; if string then return (does RTS)
  2896
  2897 BC01			LAB_1C24
  2898 BC01 4C 48 C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  2899
  2900 BC04			LAB_1C25	; patch string pointer high byte trashed when moved to stack
  2901 BC04 46 79			LSR   	FAC1_r            	; clear bit 7 (<$80) = do not round up
  2902 BC06 60				RTS
  2903
  2904 				; get value from line .. continued
  2905 				; only functions left so ..
  2906
  2907 				; set up function references
  2908
  2909 				; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  2910 				; to process function calls. now the function vector is computed and pushed on the stack
  2911 				; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  2912 				; is calculated and the routine called, if not this routine just does RTS. whichever
  2913 				; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  2914 				; the function code
  2915
  2916 				; this also removes some less than elegant code that was used to bypass type checking
  2917 				; for functions that returned strings
  2918 BC07			LAB_1C27
  2919 BC07 0A				ASL				; *2 (2 bytes per function address)
  2920 BC08 A8				TAY				; copy to index
  2921
  2922 BC09 B9 99 D4			LDA	LAB_FTBM,Y		; get function jump vector high byte
  2923 BC0C 48				PHA				; push functions jump vector high byte
  2924 BC0D B9 98 D4			LDA	LAB_FTBL,Y		; get function jump vector low byte
  2925 BC10 48				PHA				; push functions jump vector low byte
  2926
  2927 BC11 B9 4B D4			LDA	LAB_FTPM,Y		; get function pre process vector high byte
  2928 BC14 F0 05			BEQ	LAB_1C56		; skip pre process if null vector
  2929
  2930 BC16 48				PHA				; push functions pre process vector high byte
  2931 BC17 B9 4A D4			LDA	LAB_FTPL,Y		; get function pre process vector low byte
  2932 BC1A 48				PHA				; push functions pre process vector low byte
  2933
  2934 BC1B			LAB_1C56
  2935 BC1B 60				RTS				; do function, or pre process, call
  2936
  2937 				; process string expression in parenthesis
  2938 BC1C			LAB_PPFS
  2939 BC1C 20 A7 BB			JSR	LAB_1BF7		; process expression in parenthesis
  2940 BC1F 4C 8D BA			JMP	LAB_CTST		; check if source is string then do function,
  2941 									; else do type mismatch
  2942
  2943 				; process numeric expression in parenthesis
  2944 BC22			LAB_PPFN
  2945 BC22 20 A7 BB			JSR	LAB_1BF7		; process expression in parenthesis
  2946 BC25 4C 8B BA			JMP	LAB_CTNM		; check if source is numeric then do function,
  2947 									; else do type mismatch
  2948
  2949 				; set numeric data type and increment BASIC execute pointer
  2950 BC28			LAB_PPBI
  2951 BC28 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  2952 BC2A 4C 7C 00			JMP	LAB_IGBY		; increment and scan memory then do function
  2953
  2954 				; process string for LEFT$, RIGHT$ or MID$
  2955 BC2D			LAB_LRMS
  2956 BC2D 20 A4 BA			JSR	LAB_EVEZ		; evaluate (should be string) expression
  2957 BC30 20 B9 BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  2958 BC33 20 8D BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  2959
  2960 BC36 68				PLA				; get function jump vector low byte
  2961 BC37 AA				TAX				; save functions jump vector low byte
  2962 BC38 68				PLA				; get function jump vector high byte
  2963 BC39 A8				TAY				; save functions jump vector high byte
  2964 BC3A A5 6F			LDA	des_ph			; get descriptor pointer high byte
  2965 BC3C 48				PHA				; push string pointer high byte
  2966 BC3D A5 6E			LDA	des_pl			; get descriptor pointer low byte
  2967 BC3F 48				PHA				; push string pointer low byte
  2968 BC40 98				TYA				; get function jump vector high byte back
  2969 BC41 48				PHA				; save functions jump vector high byte
  2970 BC42 8A				TXA				; get function jump vector low byte back
  2971 BC43 48				PHA				; save functions jump vector low byte
  2972 BC44 20 57 C4			JSR	LAB_GTBY		; get byte parameter
  2973 BC47 8A				TXA				; copy byte parameter to A
  2974 BC48 60				RTS				; go do function
  2975
  2976 				; process numeric expression(s) for BIN$ or HEX$
  2977 BC49			LAB_BHSS
  2978 BC49 20 A4 BA			JSR	LAB_EVEZ		; process expression
  2979 BC4C 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2980 BC4F A5 6C			LDA	FAC1_e			; get FAC1 exponent
  2981 BC51 C9 98			CMP	#$98			; compare with exponent = 2^24
  2982 BC53 B0 20			BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  2983
  2984 BC55 20 1B C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  2985 BC58 A2 02			LDX	#$02			; 3 bytes to do
  2986 BC5A			LAB_CFAC
  2987 BC5A B5 6D			LDA	FAC1_1,X		; get byte from FAC1
  2988 BC5C 95 11			STA	nums_1,X		; save byte to temp
  2989 BC5E CA				DEX				; decrement index
  2990 BC5F 10 F9			BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  2991
  2992 BC61 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  2993 BC64 A2 00			LDX	#$00			; set default to no leading '0's
  2994 BC66 C9 29			CMP	#')'			; compare with close bracket
  2995 BC68 F0 0A			BEQ	LAB_1C54		; if ')' go do rest of function
  2996
  2997 BC6A 20 A9 C4			JSR	LAB_SCGB		; scan for ',' and get byte
  2998 BC6D 20 82 00			JSR	LAB_GBYT		; get last byte back
  2999 BC70 C9 29			CMP	#')'			; is next character )
  3000 BC72 D0 01			BNE	LAB_BHER		; if not ')' go do error
  3001
  3002 BC74			LAB_1C54
  3003 BC74 60				RTS				; else do function
  3004
  3005 BC75			LAB_BHER
  3006 BC75 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start
  3007
  3008 				; perform EOR
  3009
  3010 				; added operator format is the same as AND or OR, precedence is the same as OR
  3011
  3012 				; this bit worked first time but it took a while to sort out the operator table
  3013 				; pointers and offsets afterwards!
  3014 BC78			LAB_EOR
  3015 BC78 20 9F BC			JSR	GetFirst		; get first integer expression (no sign check)
  3016 BC7B 45 1B			EOR	XOAw_l			; EOR with expression 1 low byte
  3017 BC7D A8				TAY				; save in Y
  3018 BC7E A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3019 BC80 45 1C			EOR	XOAw_h			; EOR with expression 1 high byte
  3020 BC82 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3021
  3022 				; perform OR
  3023 BC85			LAB_OR
  3024 BC85 20 9F BC			JSR	GetFirst		; get first integer expression (no sign check)
  3025 BC88 05 1B			ORA	XOAw_l			; OR with expression 1 low byte
  3026 BC8A A8				TAY				; save in Y
  3027 BC8B A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3028 BC8D 05 1C			ORA	XOAw_h			; OR with expression 1 high byte
  3029 BC8F 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3030
  3031 				; perform AND
  3032 BC92			LAB_AND
  3033 BC92 20 9F BC			JSR	GetFirst		; get first integer expression (no sign check)
  3034 BC95 25 1B			AND	XOAw_l			; AND with expression 1 low byte
  3035 BC97 A8				TAY				; save in Y
  3036 BC98 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3037 BC9A 25 1C			AND	XOAw_h			; AND with expression 1 high byte
  3038 BC9C 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3039
  3040 				; get first value for OR, AND or EOR
  3041 BC9F			GetFirst
  3042 BC9F 20 63 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3043 BCA2 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  3044 BCA4 85 1C			STA	XOAw_h			; save it
  3045 BCA6 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3046 BCA8 85 1B			STA	XOAw_l			; save it
  3047 BCAA 20 8E C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3048 BCAD 20 63 BE			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3049 BCB0 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  3050 BCB2			LAB_1C95
  3051 BCB2 60				RTS
  3052
  3053 				; perform comparisons
  3054
  3055 				; do < compare
  3056 BCB3			LAB_LTHAN
  3057 BCB3 20 8E BA			JSR	LAB_CKTM		; type match check, set C for string
  3058 BCB6 B0 13			BCS	LAB_1CAE		; branch if string
  3059 									; do numeric < compare
  3060 BCB8 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  3061 BCBA 09 7F			ORA	#$7F			; set all non sign bits
  3062 BCBC 25 74			AND	FAC2_1			; and FAC2 mantissa1 (AND in sign bit)
  3063 BCBE 85 74			STA	FAC2_1			; save FAC2 mantissa1
  3064 BCC0 A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  3065 BCC2 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  3066 BCC4 20 E2 C8			JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3067 BCC7 AA				TAX				; copy result
  3068 BCC8 4C FC BC			JMP	LAB_1CE1		; go evaluate result
  3069 									; do string < compare
  3070 BCCB			LAB_1CAE
  3071 BCCB 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3072 BCCD C6 5B			DEC	comp_f			; clear < bit in compare function flag
  3073 BCCF 20 09 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3074 									; space returns with A = length, X=pointer low byte,
  3075 									; Y=pointer high byte
  3076 BCD2 85 6C			STA	str_ln			; save length
  3077 BCD4 86 6D			STX	str_pl			; save string pointer low byte
  3078 BCD6 84 6E			STY	str_ph			; save string pointer high byte
  3079 BCD8 A5 75			LDA	FAC2_2			; get descriptor pointer low byte
  3080 BCDA A4 76			LDY	FAC2_3			; get descriptor pointer high byte
  3081 BCDC 20 0D C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3082 									; returns with A = length, X=pointer low byte,
  3083 									; Y=pointer high byte
  3084 BCDF 86 75			STX	FAC2_2			; save string pointer low byte
  3085 BCE1 84 76			STY	FAC2_3			; save string pointer high byte
  3086 BCE3 AA				TAX				; copy length
  3087 BCE4 38				SEC				; set carry for subtract
  3088 BCE5 E5 6C			SBC	str_ln			; subtract string 1 length
  3089 BCE7 F0 08			BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3090
  3091 BCE9 A9 01			LDA	#$01			; set str 1 length > string 2 length
  3092 BCEB 90 04			BCC	LAB_1CD6		; branch if so
  3093
  3094 BCED A6 6C			LDX	str_ln			; get string 1 length
  3095 BCEF A9 FF			LDA	#$FF			; set str 1 length < string 2 length
  3096 BCF1			LAB_1CD6
  3097 BCF1 85 70			STA	FAC1_s			; save length compare
  3098 BCF3 A0 FF			LDY	#$FF			; set index
  3099 BCF5 E8				INX				; adjust for loop
  3100 BCF6			LAB_1CDB
  3101 BCF6 C8				INY				; increment index
  3102 BCF7 CA				DEX				; decrement count
  3103 BCF8 D0 07			BNE	LAB_1CE6		; branch if still bytes to do
  3104
  3105 BCFA A6 70			LDX	FAC1_s			; get length compare back
  3106 BCFC			LAB_1CE1
  3107 BCFC 30 0F			BMI	LAB_1CF2		; branch if str 1 < str 2
  3108
  3109 BCFE 18				CLC				; flag str 1 <= str 2
  3110 BCFF 90 0C			BCC	LAB_1CF2		; go evaluate result
  3111
  3112 BD01			LAB_1CE6
  3113 BD01 B1 75			LDA	(FAC2_2),Y		; get string 2 byte
  3114 BD03 D1 6D			CMP	(FAC1_1),Y		; compare with string 1 byte
  3115 BD05 F0 EF			BEQ	LAB_1CDB		; loop if bytes =
  3116
  3117 BD07 A2 FF			LDX	#$FF			; set str 1 < string 2
  3118 BD09 B0 02			BCS	LAB_1CF2		; branch if so
  3119
  3120 BD0B A2 01			LDX	#$01			;  set str 1 > string 2
  3121 BD0D			LAB_1CF2
  3122 BD0D E8				INX				; x = 0, 1 or 2
  3123 BD0E 8A				TXA				; copy to A
  3124 BD0F 2A				ROL				; *2 (1, 2 or 4)
  3125 BD10 25 23			AND	Cflag			; AND with comparison evaluation flag
  3126 BD12 F0 02			BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3127
  3128 BD14 A9 FF			LDA	#$FF			; else set result true
  3129 BD16			LAB_1CFB
  3130 BD16 4C C5 C8			JMP	LAB_27DB		; save A as integer byte and return
  3131
  3132 BD19			LAB_1CFE
  3133 BD19 20 B9 BB			JSR	LAB_1C01		; scan for ',', else do syntax error then warm start
  3134
  3135 				; perform DIM
  3136 BD1C			LAB_DIM
  3137 BD1C AA				TAX				; copy 'DIM' flag to X
  3138 BD1D 20 6C BD			JSR	LAB_1D10		; search for variable
  3139 BD20 20 82 00			JSR	LAB_GBYT		; scan memory
  3140 BD23 D0 F4			BNE	LAB_1CFE		; scan for ',' and loop if not null
  3141
  3142 BD25 60				RTS
  3143
  3144 				; perform << (left shift)
  3145 BD26			LAB_LSHIFT
  3146 BD26 20 5C BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3147 BD29 A5 6E			LDA	FAC1_2			; get expression high byte
  3148 BD2B A6 38			LDX	TempB			; get shift count
  3149 BD2D F0 22			BEQ	NoShift			; branch if zero
  3150
  3151 BD2F E0 10			CPX	#$10			; compare bit count with 16d
  3152 BD31 B0 23			BCS	TooBig			; branch if >=
  3153
  3154 BD33			Ls_loop
  3155 BD33 06 6F			ASL	FAC1_3			; shift low byte
  3156 BD35 2A				ROL				; shift high byte
  3157 BD36 CA				DEX				; decrement bit count
  3158 BD37 D0 FA			BNE	Ls_loop			; loop if shift not complete
  3159
  3160 BD39 A4 6F			LDY	FAC1_3			; get expression low byte
  3161 BD3B 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3162
  3163 				; perform >> (right shift)
  3164 BD3E			LAB_RSHIFT
  3165 BD3E 20 5C BD			JSR	GetPair			; get integer expression and byte (no sign check)
  3166 BD41 A5 6E			LDA	FAC1_2			; get expression high byte
  3167 BD43 A6 38			LDX	TempB			; get shift count
  3168 BD45 F0 0A			BEQ	NoShift			; branch if zero
  3169
  3170 BD47 E0 10			CPX	#$10			; compare bit count with 16d
  3171 BD49 B0 0B			BCS	TooBig			; branch if >=
  3172
  3173 BD4B			Rs_loop
  3174 BD4B 4A				LSR				; shift high byte
  3175 BD4C 66 6F			ROR	FAC1_3			; shift low byte
  3176 BD4E CA				DEX				; decrement bit count
  3177 BD4F D0 FA			BNE	Rs_loop			; loop if shift not complete
  3178
  3179 BD51			NoShift
  3180 BD51 A4 6F			LDY	FAC1_3			; get expression low byte
  3181 BD53 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3182
  3183 BD56			TooBig
  3184 BD56 A9 00			LDA	#$00			; clear high byte
  3185 BD58 A8				TAY				; copy to low byte
  3186 BD59 4C 22 C0			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3187
  3188 BD5C			GetPair
  3189 BD5C 20 5A C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  3190 BD5F 86 38			STX	TempB			; save it
  3191 BD61 20 8E C5			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3192 BD64 4C 63 BE			JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3193
  3194 				; search for variable
  3195
  3196 				; return pointer to variable in Cvaral/Cvarah
  3197 BD67			LAB_GVAR
  3198 BD67 A2 00			LDX	#$00			; set DIM flag = $00
  3199 BD69 20 82 00			JSR	LAB_GBYT		; scan memory (1st character)
  3200 BD6C			LAB_1D10
  3201 BD6C 86 1E			STX	Defdim			; save DIM flag
  3202 BD6E			LAB_1D12
  3203 BD6E 85 53			STA	Varnm1			; save 1st character
  3204 BD70 29 7F			AND	#$7F			; clear FN flag bit
  3205 BD72 20 DB BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3206 BD75 B0 03			BCS	LAB_1D1F		; branch if ok
  3207
  3208 BD77 4C BD BB			JMP	LAB_SNER		; else syntax error then warm start
  3209
  3210 									; was variable name so ..
  3211 BD7A			LAB_1D1F
  3212 BD7A A2 00			LDX	#$00			; clear 2nd character temp
  3213 BD7C 86 1F			STX	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3214 BD7E 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (2nd character)
  3215 BD81 90 05			BCC	LAB_1D2D		; branch if character = '0'-'9' (ok)
  3216
  3217 									; 2nd character wasn't '0' to '9' so ..
  3218 BD83 20 DB BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3219 BD86 90 0B			BCC	LAB_1D38		; branch if <'A' or >'Z' (go check if string)
  3220
  3221 BD88			LAB_1D2D
  3222 BD88 AA				TAX				; copy 2nd character
  3223
  3224 									; ignore further (valid) characters in the variable name
  3225 BD89			LAB_1D2E
  3226 BD89 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (3rd character)
  3227 BD8C 90 FB			BCC	LAB_1D2E		; loop if character = '0'-'9' (ignore)
  3228
  3229 BD8E 20 DB BD			JSR	LAB_CASC		; check byte, return C=0 if<'A' or >'Z'
  3230 BD91 B0 F6			BCS	LAB_1D2E		; loop if character = 'A'-'Z' (ignore)
  3231
  3232 									; check if string variable
  3233 BD93			LAB_1D38
  3234 BD93 C9 24			CMP	#'$'			; compare with '$'
  3235 BD95 D0 0B			BNE	LAB_1D47		; branch if not string
  3236
  3237 				; to introduce a new variable type (% suffix for integers say) then this branch
  3238 				; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3239 									; type is string
  3240 BD97 A9 FF			LDA	#$FF			; set data type = string
  3241 BD99 85 1F			STA	Dtypef			; set data type flag, $FF=string, $00=numeric
  3242 BD9B 8A				TXA				; get 2nd character back
  3243 BD9C 09 80			ORA	#$80			; set top bit (indicate string var)
  3244 BD9E AA				TAX				; copy back to 2nd character temp
  3245 BD9F 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3246
  3247 				; after we have determined the variable type we need to come back here to determine
  3248 				; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3249 BDA2			LAB_1D47				; gets here with character after var name in A
  3250 BDA2 86 54			STX	Varnm2			; save 2nd character
  3251 BDA4 05 21			ORA	Sufnxf			; or with subscript/FNX flag (or FN name)
  3252 BDA6 C9 28			CMP	#'('			; compare with '('
  3253 BDA8 D0 03			BNE	LAB_1D53		; branch if not '('
  3254
  3255 BDAA 4C 75 BE			JMP	LAB_1E17		; go find, or make, array
  3256
  3257 				; either find or create var
  3258 				; var name (1st two characters only!) is in Varnm1,Varnm2
  3259 									; variable name wasn't var(... so look for plain var
  3260 BDAD			LAB_1D53
  3261 BDAD A9 00			LDA	#$00			; clear A
  3262 BDAF 85 21			STA	Sufnxf			; clear subscript/FNX flag
  3263 BDB1 A5 3B			LDA	Svarl			; get start of vars low byte
  3264 BDB3 A6 3C			LDX	Svarh			; get start of vars high byte
  3265 BDB5 A0 00			LDY	#$00			; clear index
  3266 BDB7			LAB_1D5D
  3267 BDB7 86 6B			STX	Vrschh			; save search address high byte
  3268 BDB9			LAB_1D5F
  3269 BDB9 85 6A			STA	Vrschl			; save search address low byte
  3270 BDBB E4 3E			CPX	Sarryh			; compare high address with var space end
  3271 BDBD D0 04			BNE	LAB_1D69		; skip next compare if <>
  3272
  3273 									; high addresses were = so compare low addresses
  3274 BDBF C5 3D			CMP	Sarryl			; compare low address with var space end
  3275 BDC1 F0 2C			BEQ	LAB_1D8B		; if not found go make new var
  3276
  3277 BDC3			LAB_1D69
  3278 BDC3 A5 53			LDA	Varnm1			; get 1st character of var to find
  3279 BDC5 D1 6A			CMP	(Vrschl),Y		; compare with variable name 1st character
  3280 BDC7 D0 08			BNE	LAB_1D77		; branch if no match
  3281
  3282 									; 1st characters match so compare 2nd characters
  3283 BDC9 A5 54			LDA	Varnm2			; get 2nd character of var to find
  3284 BDCB C8				INY				; index to point to variable name 2nd character
  3285 BDCC D1 6A			CMP	(Vrschl),Y		; compare with variable name 2nd character
  3286 BDCE F0 69			BEQ	LAB_1DD7		; branch if match (found var)
  3287
  3288 BDD0 88				DEY				; else decrement index (now = $00)
  3289 BDD1			LAB_1D77
  3290 BDD1 18				CLC				; clear carry for add
  3291 BDD2 A5 6A			LDA	Vrschl			; get search address low byte
  3292 BDD4 69 06			ADC	#$06			; +6 (offset to next var name)
  3293 BDD6 90 E1			BCC	LAB_1D5F		; loop if no overflow to high byte
  3294
  3295 BDD8 E8				INX				; else increment high byte
  3296 BDD9 D0 DC			BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3297
  3298 				; check byte, return C=0 if<'A' or >'Z' or 'a' to 'z'
  3299 BDDB			LAB_CASC
  3300 BDDB C9 61			CMP	#'a'			; compare with 'a'
  3301 BDDD B0 0A			BCS	LAB_1D83		; go check <'z'+1
  3302
  3303 				; check byte, return C=0 if<'A' or >'Z'
  3304 BDDF			LAB_1D82
  3305 BDDF C9 41			CMP	#'A'			; compare with 'A'
  3306 BDE1 90 05			BCC	LAB_1D8A		; exit if less
  3307
  3308 									; carry is set
  3309 BDE3 E9 5B			SBC	#$5B			; subtract 'Z'+1
  3310 BDE5 38				SEC				; set carry
  3311 BDE6 E9 A5			SBC	#$A5			; subtract $A5 (restore byte)
  3312 									; carry clear if byte>$5A
  3313 BDE8			LAB_1D8A
  3314 BDE8 60				RTS
  3315
  3316 BDE9			LAB_1D83
  3317 BDE9 E9 7B			SBC	#$7B			; subtract 'z'+1
  3318 BDEB 38				SEC				; set carry
  3319 BDEC E9 85			SBC	#$85			; subtract $85 (restore byte)
  3320 									; carry clear if byte>$7A
  3321 BDEE 60				RTS
  3322
  3323 									; reached end of variable mem without match
  3324 									; .. so create new variable
  3325 BDEF			LAB_1D8B
  3326 BDEF 68				PLA				; pop return address low byte
  3327 BDF0 48				PHA				; push return address low byte
  3328 = BBF8			LAB_1C18p2	= LAB_1C18+2
  3329 BDF1 C9 F8			CMP	#<LAB_1C18p2		; compare with expected calling routine return low byte
  3330 BDF3 D0 05			BNE	LAB_1D98		; if not get (var) go create new var
  3331
  3332 				; This will only drop through if the call was from LAB_1C18 and is only called
  3333 				; from there if it is searching for a variable from the RHS of a LET a=b statement
  3334 				; it prevents the creation of variables not assigned a value.
  3335
  3336 				; value returned by this is either numeric zero (exponent byte is $00) or null string
  3337 				; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3338
  3339 				; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3340
  3341 				; this is where you would put the undefined variable error call e.g.
  3342
  3343 				;					; variable doesn't exist so flag error
  3344 				;	LDX	#$24			; error code $24 ('undefined variable' error)
  3345 				;	JMP	LAB_XERR		; do error #X then warm start
  3346
  3347 				; the above code has been tested and works a treat! (it replaces the three code lines
  3348 				; below)
  3349 									; else return dummy null value
  3350 BDF5 A9 A4			LDA	#<LAB_1D96		; low byte point to $00,$00
  3351 									; (uses part of misc constants table)
  3352 BDF7 A0 D3			LDY	#>LAB_1D96		; high byte point to $00,$00
  3353 BDF9 60				RTS
  3354
  3355 				; create new numeric variable
  3356 BDFA			LAB_1D98
  3357 BDFA A5 3D			LDA	Sarryl			; get var mem end low byte
  3358 BDFC A4 3E			LDY	Sarryh			; get var mem end high byte
  3359 BDFE 85 6A			STA	Ostrtl			; save old block start low byte
  3360 BE00 84 6B			STY	Ostrth			; save old block start high byte
  3361 BE02 A5 3F			LDA	Earryl			; get array mem end low byte
  3362 BE04 A4 40			LDY	Earryh			; get array mem end high byte
  3363 BE06 85 66			STA	Obendl			; save old block end low byte
  3364 BE08 84 67			STY	Obendh			; save old block end high byte
  3365 BE0A 18				CLC				; clear carry for add
  3366 BE0B 69 06			ADC	#$06			; +6 (space for one var)
  3367 BE0D 90 01			BCC	LAB_1DAE		; branch if no overflow to high byte
  3368
  3369 BE0F C8				INY				; else increment high byte
  3370 BE10			LAB_1DAE
  3371 BE10 85 64			STA	Nbendl			; set new block end low byte
  3372 BE12 84 65			STY	Nbendh			; set new block end high byte
  3373 BE14 20 89 B0			JSR	LAB_11CF		; open up space in memory
  3374 BE17 A5 64			LDA	Nbendl			; get new start low byte
  3375 BE19 A4 65			LDY	Nbendh			; get new start high byte (-$100)
  3376 BE1B C8				INY				; correct high byte
  3377 BE1C 85 3D			STA	Sarryl			; save new var mem end low byte
  3378 BE1E 84 3E			STY	Sarryh			; save new var mem end high byte
  3379 BE20 A0 00			LDY	#$00			; clear index
  3380 BE22 A5 53			LDA	Varnm1			; get var name 1st character
  3381 BE24 91 6A			STA	(Vrschl),Y		; save var name 1st character
  3382 BE26 C8				INY				; increment index
  3383 BE27 A5 54			LDA	Varnm2			; get var name 2nd character
  3384 BE29 91 6A			STA	(Vrschl),Y		; save var name 2nd character
  3385 BE2B A9 00			LDA	#$00			; clear A
  3386 BE2D C8				INY				; increment index
  3387 BE2E 91 6A			STA	(Vrschl),Y		; initialise var byte
  3388 BE30 C8				INY				; increment index
  3389 BE31 91 6A			STA	(Vrschl),Y		; initialise var byte
  3390 BE33 C8				INY				; increment index
  3391 BE34 91 6A			STA	(Vrschl),Y		; initialise var byte
  3392 BE36 C8				INY				; increment index
  3393 BE37 91 6A			STA	(Vrschl),Y		; initialise var byte
  3394
  3395 									; found a match for var ((Vrschl) = ptr)
  3396 BE39			LAB_1DD7
  3397 BE39 A5 6A			LDA	Vrschl			; get var address low byte
  3398 BE3B 18				CLC				; clear carry for add
  3399 BE3C 69 02			ADC	#$02			; +2 (offset past var name bytes)
  3400 BE3E A4 6B			LDY	Vrschh			; get var address high byte
  3401 BE40 90 01			BCC	LAB_1DE1		; branch if no overflow from add
  3402
  3403 BE42 C8				INY				; else increment high byte
  3404 BE43			LAB_1DE1
  3405 BE43 85 55			STA	Cvaral			; save current var address low byte
  3406 BE45 84 56			STY	Cvarah			; save current var address high byte
  3407 BE47 60				RTS
  3408
  3409 				; set-up array pointer (Adatal/h) to first element in array
  3410 				; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3411 BE48			LAB_1DE6
  3412 BE48 A5 1D			LDA	Dimcnt			; get # of dimensions (1, 2 or 3)
  3413 BE4A 0A				ASL				; *2 (also clears the carry !)
  3414 BE4B 69 05			ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3415 BE4D 65 6A			ADC	Astrtl			; add array start pointer low byte
  3416 BE4F A4 6B			LDY	Astrth			; get array pointer high byte
  3417 BE51 90 01			BCC	LAB_1DF2		; branch if no overflow
  3418
  3419 BE53 C8				INY				; else increment high byte
  3420 BE54			LAB_1DF2
  3421 BE54 85 64			STA	Adatal			; save array data pointer low byte
  3422 BE56 84 65			STY	Adatah			; save array data pointer high byte
  3423 BE58 60				RTS
  3424
  3425 				; evaluate integer expression
  3426 BE59			LAB_EVIN
  3427 BE59 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  3428 BE5C 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3429 									; else do type mismatch
  3430
  3431 				; evaluate integer expression (no check)
  3432 BE5F			LAB_EVPI
  3433 BE5F A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  3434 BE61 30 0D			BMI	LAB_1E12		; do function call error if -ve
  3435
  3436 				; evaluate integer expression (no sign check)
  3437 BE63			LAB_EVIR
  3438 BE63 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  3439 BE65 C9 90			CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3440 BE67 90 09			BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3441
  3442 BE69 A9 AB			LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3443 BE6B A0 D3			LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3444 BE6D 20 E2 C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  3445 BE70			LAB_1E12
  3446 BE70 D0 74			BNE	LAB_FCER		; if <> do function call error then warm start
  3447
  3448 BE72			LAB_1E14
  3449 BE72 4C 1B C9			JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  3450
  3451 				; find or make array
  3452 BE75			LAB_1E17
  3453 BE75 A5 1E			LDA	Defdim			; get DIM flag
  3454 BE77 48				PHA				; push it
  3455 BE78 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  3456 BE7A 48				PHA				; push it
  3457 BE7B A0 00			LDY	#$00			; clear dimensions count
  3458
  3459 				; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3460 BE7D			LAB_1E1F
  3461 BE7D 98				TYA				; copy dimensions count
  3462 BE7E 48				PHA				; save it
  3463 BE7F A5 54			LDA	Varnm2			; get array name 2nd byte
  3464 BE81 48				PHA				; save it
  3465 BE82 A5 53			LDA	Varnm1			; get array name 1st byte
  3466 BE84 48				PHA				; save it
  3467 BE85 20 59 BE			JSR	LAB_EVIN		; evaluate integer expression
  3468 BE88 68				PLA				; pull array name 1st byte
  3469 BE89 85 53			STA	Varnm1			; restore array name 1st byte
  3470 BE8B 68				PLA				; pull array name 2nd byte
  3471 BE8C 85 54			STA	Varnm2			; restore array name 2nd byte
  3472 BE8E 68				PLA				; pull dimensions count
  3473 BE8F A8				TAY				; restore it
  3474 BE90 BA				TSX				; copy stack pointer
  3475 BE91 BD 02 01			LDA	LAB_STAK+2,X		; get DIM flag
  3476 BE94 48				PHA				; push it
  3477 BE95 BD 01 01			LDA	LAB_STAK+1,X		; get data type flag
  3478 BE98 48				PHA				; push it
  3479 BE99 A5 6E			LDA	FAC1_2			; get this dimension size high byte
  3480 BE9B 9D 02 01			STA	LAB_STAK+2,X		; stack before flag bytes
  3481 BE9E A5 6F			LDA	FAC1_3			; get this dimension size low byte
  3482 BEA0 9D 01 01			STA	LAB_STAK+1,X		; stack before flag bytes
  3483 BEA3 C8				INY				; increment dimensions count
  3484 BEA4 20 82 00			JSR	LAB_GBYT		; scan memory
  3485 BEA7 C9 2C			CMP	#','			; compare with ','
  3486 BEA9 F0 D2			BEQ	LAB_1E1F		; if found go do next dimension
  3487
  3488 BEAB 84 1D			STY	Dimcnt			; store dimensions count
  3489 BEAD 20 AA BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  3490 BEB0 68				PLA				; pull data type flag
  3491 BEB1 85 1F			STA	Dtypef			; restore data type flag, $FF=string, $00=numeric
  3492 BEB3 68				PLA				; pull DIM flag
  3493 BEB4 85 1E			STA	Defdim			; restore DIM flag
  3494 BEB6 A6 3D			LDX	Sarryl			; get array mem start low byte
  3495 BEB8 A5 3E			LDA	Sarryh			; get array mem start high byte
  3496
  3497 				; now check to see if we are at the end of array memory (we would be if there were
  3498 				; no arrays).
  3499 BEBA			LAB_1E5C
  3500 BEBA 86 6A			STX	Astrtl			; save as array start pointer low byte
  3501 BEBC 85 6B			STA	Astrth			; save as array start pointer high byte
  3502 BEBE C5 40			CMP	Earryh			; compare with array mem end high byte
  3503 BEC0 D0 04			BNE	LAB_1E68		; branch if not reached array mem end
  3504
  3505 BEC2 E4 3F			CPX	Earryl			; else compare with array mem end low byte
  3506 BEC4 F0 39			BEQ	LAB_1EA1		; go build array if not found
  3507
  3508 									; search for array
  3509 BEC6			LAB_1E68
  3510 BEC6 A0 00			LDY	#$00			; clear index
  3511 BEC8 B1 6A			LDA	(Astrtl),Y		; get array name first byte
  3512 BECA C8				INY				; increment index to second name byte
  3513 BECB C5 53			CMP	Varnm1			; compare with this array name first byte
  3514 BECD D0 06			BNE	LAB_1E77		; branch if no match
  3515
  3516 BECF A5 54			LDA	Varnm2			; else get this array name second byte
  3517 BED1 D1 6A			CMP	(Astrtl),Y		; compare with array name second byte
  3518 BED3 F0 16			BEQ	LAB_1E8D		; array found so branch
  3519
  3520 									; no match
  3521 BED5			LAB_1E77
  3522 BED5 C8				INY				; increment index
  3523 BED6 B1 6A			LDA	(Astrtl),Y		; get array size low byte
  3524 BED8 18				CLC				; clear carry for add
  3525 BED9 65 6A			ADC	Astrtl			; add array start pointer low byte
  3526 BEDB AA				TAX				; copy low byte to X
  3527 BEDC C8				INY				; increment index
  3528 BEDD B1 6A			LDA	(Astrtl),Y		; get array size high byte
  3529 BEDF 65 6B			ADC	Astrth			; add array mem pointer high byte
  3530 BEE1 90 D7			BCC	LAB_1E5C		; if no overflow go check next array
  3531
  3532 				; do array bounds error
  3533 BEE3			LAB_1E85
  3534 BEE3 A2 10			LDX	#$10			; error code $10 ('Array bounds' error)
  3535 BEE5 2C				.byte	$2C			; makes next bit BIT LAB_08A2
  3536
  3537 				; do function call error
  3538 BEE6			LAB_FCER
  3539 BEE6 A2 08			LDX	#$08			; error code $08 ('Function call' error)
  3540 BEE8			LAB_1E8A
  3541 BEE8 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  3542
  3543 									; found array, are we trying to dimension it?
  3544 BEEB			LAB_1E8D
  3545 BEEB A2 12			LDX	#$12			; set error $12 ('Double dimension' error)
  3546 BEED A5 1E			LDA	Defdim			; get DIM flag
  3547 BEEF D0 F7			BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3548 									; start
  3549
  3550 				; found the array and we're not dimensioning it so we must find an element in it
  3551 BEF1 20 48 BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3552 									; (Astrtl,Astrth points to start of array)
  3553 BEF4 A5 1D			LDA	Dimcnt			; get dimensions count
  3554 BEF6 A0 04			LDY	#$04			; set index to array's # of dimensions
  3555 BEF8 D1 6A			CMP	(Astrtl),Y		; compare with no of dimensions
  3556 BEFA D0 E7			BNE	LAB_1E85		; if wrong do array bounds error, could do 'Wrong
  3557 									; dimensions' error here .. if we want a different
  3558 									; error message
  3559
  3560 BEFC 4C 82 BF			JMP	LAB_1F28		; found array so go get element
  3561 									; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3562 									; Dimcnt and save it at (Astrtl),Y which is already the
  3563 									; same or we would have taken the BNE)
  3564
  3565 									; array not found, so build it
  3566 BEFF			LAB_1EA1
  3567 BEFF 20 48 BE			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3568 									; (Astrtl,Astrth points to start of array)
  3569 BF02 20 D6 B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3570 									; addr to check is in AY (low/high)
  3571 BF05 A0 00			LDY	#$00			; clear Y (don't need to clear A)
  3572 BF07 84 7B			STY	Aspth			; clear array data size high byte
  3573 BF09 A5 53			LDA	Varnm1			; get variable name 1st byte
  3574 BF0B 91 6A			STA	(Astrtl),Y		; save array name 1st byte
  3575 BF0D C8				INY				; increment index
  3576 BF0E A5 54			LDA	Varnm2			; get variable name 2nd byte
  3577 BF10 91 6A			STA	(Astrtl),Y		; save array name 2nd byte
  3578 BF12 A5 1D			LDA	Dimcnt			; get dimensions count
  3579 BF14 A0 04			LDY	#$04			; index to dimension count
  3580 BF16 84 7A			STY	Asptl			; set array data size low byte (four bytes per element)
  3581 BF18 91 6A			STA	(Astrtl),Y		; set array's dimensions count
  3582
  3583 									; now calculate the size of the data space for the array
  3584 BF1A 18				CLC				; clear carry for add (clear on subsequent loops)
  3585 BF1B			LAB_1EC0
  3586 BF1B A2 0B			LDX	#$0B			; set default dimension value low byte
  3587 BF1D A9 00			LDA	#$00			; set default dimension value high byte
  3588 BF1F 24 1E			BIT	Defdim			; test default DIM flag
  3589 BF21 50 07			BVC	LAB_1ED0		; branch if b6 of Defdim is clear
  3590
  3591 BF23 68				PLA				; else pull dimension value low byte
  3592 BF24 69 01			ADC	#$01			; +1 (allow for zeroeth element)
  3593 BF26 AA				TAX				; copy low byte to X
  3594 BF27 68				PLA				; pull dimension value high byte
  3595 BF28 69 00			ADC	#$00			; add carry from low byte
  3596
  3597 BF2A			LAB_1ED0
  3598 BF2A C8				INY				; index to dimension value high byte
  3599 BF2B 91 6A			STA	(Astrtl),Y		; save dimension value high byte
  3600 BF2D C8				INY				; index to dimension value high byte
  3601 BF2E 8A				TXA				; get dimension value low byte
  3602 BF2F 91 6A			STA	(Astrtl),Y		; save dimension value low byte
  3603 BF31 20 D1 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3604 BF34 86 7A			STX	Asptl			; save array data size low byte
  3605 BF36 85 7B			STA	Aspth			; save array data size high byte
  3606 BF38 A4 31			LDY	ut1_pl			; restore index (saved by subroutine)
  3607 BF3A C6 1D			DEC	Dimcnt			; decrement dimensions count
  3608 BF3C D0 DD			BNE	LAB_1EC0		; loop while not = 0
  3609
  3610 BF3E 65 65			ADC	Adatah			; add size high byte to first element high byte
  3611 									; (carry is always clear here)
  3612 BF40 B0 5D			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3613
  3614 BF42 85 65			STA	Adatah			; save end of array high byte
  3615 BF44 A8				TAY				; copy end high byte to Y
  3616 BF45 8A				TXA				; get array size low byte
  3617 BF46 65 64			ADC	Adatal			; add array start low byte
  3618 BF48 90 03			BCC	LAB_1EF3		; branch if no carry
  3619
  3620 BF4A C8				INY				; else increment end of array high byte
  3621 BF4B F0 52			BEQ	LAB_1F45		; if overflow go do 'Out of memory' error
  3622
  3623 									; set-up mostly complete, now zero the array
  3624 BF4D			LAB_1EF3
  3625 BF4D 20 D6 B0			JSR	LAB_121F		; check available memory, 'Out of memory' error if no room
  3626 									; addr to check is in AY (low/high)
  3627 BF50 85 3F			STA	Earryl			; save array mem end low byte
  3628 BF52 84 40			STY	Earryh			; save array mem end high byte
  3629 BF54 A9 00			LDA	#$00			; clear byte for array clear
  3630 BF56 E6 7B			INC	Aspth			; increment array size high byte (now block count)
  3631 BF58 A4 7A			LDY	Asptl			; get array size low byte (now index to block)
  3632 BF5A F0 05			BEQ	LAB_1F07		; branch if low byte = $00
  3633
  3634 BF5C			LAB_1F02
  3635 BF5C 88				DEY				; decrement index (do 0 to n-1)
  3636 BF5D 91 64			STA	(Adatal),Y		; zero byte
  3637 BF5F D0 FB			BNE	LAB_1F02		; loop until this block done
  3638
  3639 BF61			LAB_1F07
  3640 BF61 C6 65			DEC	Adatah			; decrement array pointer high byte
  3641 BF63 C6 7B			DEC	Aspth			; decrement block count high byte
  3642 BF65 D0 F5			BNE	LAB_1F02		; loop until all blocks done
  3643
  3644 BF67 E6 65			INC	Adatah			; correct for last loop
  3645 BF69 38				SEC				; set carry for subtract
  3646 BF6A A0 02			LDY	#$02			; index to array size low byte
  3647 BF6C A5 3F			LDA	Earryl			; get array mem end low byte
  3648 BF6E E5 6A			SBC	Astrtl			; subtract array start low byte
  3649 BF70 91 6A			STA	(Astrtl),Y		; save array size low byte
  3650 BF72 C8				INY				; index to array size high byte
  3651 BF73 A5 40			LDA	Earryh			; get array mem end high byte
  3652 BF75 E5 6B			SBC	Astrth			; subtract array start high byte
  3653 BF77 91 6A			STA	(Astrtl),Y		; save array size high byte
  3654 BF79 A5 1E			LDA	Defdim			; get default DIM flag
  3655 BF7B D0 53			BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  3656
  3657 									; else, find element
  3658 BF7D C8				INY				; index to # of dimensions
  3659
  3660 BF7E			LAB_1F24
  3661 BF7E B1 6A			LDA	(Astrtl),Y		; get array's dimension count
  3662 BF80 85 1D			STA	Dimcnt			; save it
  3663
  3664 				; we have found, or built, the array. now we need to find the element
  3665 BF82			LAB_1F28
  3666 BF82 A9 00			LDA	#$00			; clear byte
  3667 BF84 85 7A			STA	Asptl			; clear array data pointer low byte
  3668 BF86			LAB_1F2C
  3669 BF86 85 7B			STA	Aspth			; save array data pointer high byte
  3670 BF88 C8				INY				; increment index (point to array bound high byte)
  3671 BF89 68				PLA				; pull array index low byte
  3672 BF8A AA				TAX				; copy to X
  3673 BF8B 85 6E			STA	FAC1_2			; save index low byte to FAC1 mantissa2
  3674 BF8D 68				PLA				; pull array index high byte
  3675 BF8E 85 6F			STA	FAC1_3			; save index high byte to FAC1 mantissa3
  3676 BF90 D1 6A			CMP	(Astrtl),Y		; compare with array bound high byte
  3677 BF92 90 0E			BCC	LAB_1F48		; branch if within bounds
  3678
  3679 BF94 D0 06			BNE	LAB_1F42		; if outside bounds do array bounds error
  3680
  3681 									; else high byte was = so test low bytes
  3682 BF96 C8				INY				; index to array bound low byte
  3683 BF97 8A				TXA				; get array index low byte
  3684 BF98 D1 6A			CMP	(Astrtl),Y		; compare with array bound low byte
  3685 BF9A 90 07			BCC	LAB_1F49		; branch if within bounds
  3686
  3687 BF9C			LAB_1F42
  3688 BF9C 4C E3 BE			JMP	LAB_1E85		; else do array bounds error
  3689
  3690 BF9F			LAB_1F45
  3691 BF9F 4C 05 B1			JMP	LAB_OMER		; do 'Out of memory' error then warm start
  3692
  3693 BFA2			LAB_1F48
  3694 BFA2 C8				INY				; index to array bound low byte
  3695 BFA3			LAB_1F49
  3696 BFA3 A5 7B			LDA	Aspth			; get array data pointer high byte
  3697 BFA5 05 7A			ORA	Asptl			; OR with array data pointer low byte
  3698 BFA7 F0 0A			BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  3699
  3700 BFA9 20 D1 BF			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  3701 BFAC 8A				TXA				; get result low byte
  3702 BFAD 65 6E			ADC	FAC1_2			; add index low byte from FAC1 mantissa2
  3703 BFAF AA				TAX				; save result low byte
  3704 BFB0 98				TYA				; get result high byte
  3705 BFB1 A4 31			LDY	ut1_pl			; restore index
  3706 BFB3			LAB_1F5A
  3707 BFB3 65 6F			ADC	FAC1_3			; add index high byte from FAC1 mantissa3
  3708 BFB5 86 7A			STX	Asptl			; save array data pointer low byte
  3709 BFB7 C6 1D			DEC	Dimcnt			; decrement dimensions count
  3710 BFB9 D0 CB			BNE	LAB_1F2C		; loop if dimensions still to do
  3711
  3712 BFBB 06 7A			ASL	Asptl			; array data pointer low byte * 2
  3713 BFBD 2A				ROL				; array data pointer high byte * 2
  3714 BFBE 06 7A			ASL	Asptl			; array data pointer low byte * 4
  3715 BFC0 2A				ROL				; array data pointer high byte * 4
  3716 BFC1 A8				TAY				; copy high byte
  3717 BFC2 A5 7A			LDA	Asptl			; get low byte
  3718 BFC4 65 64			ADC	Adatal			; add array data start pointer low byte
  3719 BFC6 85 55			STA	Cvaral			; save as current var address low byte
  3720 BFC8 98				TYA				; get high byte back
  3721 BFC9 65 65			ADC	Adatah			; add array data start pointer high byte
  3722 BFCB 85 56			STA	Cvarah			; save as current var address high byte
  3723 BFCD A8				TAY				; copy high byte to Y
  3724 BFCE A5 55			LDA	Cvaral			; get current var address low byte
  3725 BFD0			LAB_1F7B
  3726 BFD0 60				RTS
  3727
  3728 				; does XY = (Astrtl),Y * (Asptl)
  3729 BFD1			LAB_1F7C
  3730 BFD1 84 31			STY	ut1_pl			; save index
  3731 BFD3 B1 6A			LDA	(Astrtl),Y		; get dimension size low byte
  3732 BFD5 85 36			STA	dims_l			; save dimension size low byte
  3733 BFD7 88				DEY				; decrement index
  3734 BFD8 B1 6A			LDA	(Astrtl),Y		; get dimension size high byte
  3735 BFDA 85 37			STA	dims_h			; save dimension size high byte
  3736
  3737 BFDC A9 10			LDA	#$10			; count = $10 (16 bit multiply)
  3738 BFDE 85 68			STA	numbit			; save bit count
  3739 BFE0 A2 00			LDX	#$00			; clear result low byte
  3740 BFE2 A0 00			LDY	#$00			; clear result high byte
  3741 BFE4			LAB_1F8F
  3742 BFE4 8A				TXA				; get result low byte
  3743 BFE5 0A				ASL				; *2
  3744 BFE6 AA				TAX				; save result low byte
  3745 BFE7 98				TYA				; get result high byte
  3746 BFE8 2A				ROL				; *2
  3747 BFE9 A8				TAY				; save result high byte
  3748 BFEA B0 B3			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3749
  3750 BFEC 06 7A			ASL	Asptl			; shift multiplier low byte
  3751 BFEE 26 7B			ROL	Aspth			; shift multiplier high byte
  3752 BFF0 90 0B			BCC	LAB_1FA8		; skip add if no carry
  3753
  3754 BFF2 18				CLC				; else clear carry for add
  3755 BFF3 8A				TXA				; get result low byte
  3756 BFF4 65 36			ADC	dims_l			; add dimension size low byte
  3757 BFF6 AA				TAX				; save result low byte
  3758 BFF7 98				TYA				; get result high byte
  3759 BFF8 65 37			ADC	dims_h			; add dimension size high byte
  3760 BFFA A8				TAY				; save result high byte
  3761 BFFB B0 A2			BCS	LAB_1F45		; if overflow go do 'Out of memory' error
  3762
  3763 BFFD			LAB_1FA8
  3764 BFFD C6 68			DEC	numbit			; decrement bit count
  3765 BFFF D0 E3			BNE	LAB_1F8F		; loop until all done
  3766
  3767 C001 60				RTS
  3768
  3769 				; perform FRE()
  3770 C002			LAB_FRE
  3771 C002 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  3772 C004 10 03			BPL	LAB_1FB4		; branch if numeric
  3773
  3774 C006 20 09 C3			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3775 									; space returns with A = length, X=$71=pointer low byte,
  3776 									; Y=$72=pointer high byte
  3777
  3778 									; FRE(n) was numeric so do this
  3779 C009			LAB_1FB4
  3780 C009 20 AA C1			JSR	LAB_GARB		; go do garbage collection
  3781 C00C 38				SEC				; set carry for subtract
  3782 C00D A5 41			LDA	Sstorl			; get bottom of string space low byte
  3783 C00F E5 3F			SBC	Earryl			; subtract array mem end low byte
  3784 C011 A8				TAY				; copy result to Y
  3785 C012 A5 42			LDA	Sstorh			; get bottom of string space high byte
  3786 C014 E5 40			SBC	Earryh			; subtract array mem end high byte
  3787
  3788 				; save and convert unsigned integer AY to FAC1
  3789 C016			LAB_UAYFC
  3790 C016 46 1F			LSR	Dtypef            	; clear data type flag, $FF=string, $00=numeric
  3791 C018 85 6D			STA	FAC1_1            	; save FAC1 mantissa1
  3792 C01A 84 6E			STY	FAC1_2            	; save FAC1 mantissa2
  3793 C01C A2 90			LDX	#$90              	; set exponent=2^16 (integer)
  3794 C01E 38				SEC                     	; always positive
  3795 C01F 4C D2 C8			JMP	LAB_STFA          	; set exp=X, clear FAC1_3, normalise and return 
  3796 				      
  3797 				; save and convert integer AY to FAC1
  3798 C022			LAB_AYFC
  3799 C022 46 1F			LSR	Dtypef			; clear data type flag, $FF=string, $00=numeric
  3800 C024 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  3801 C026 84 6E			STY	FAC1_2			; save FAC1 mantissa2
  3802 C028 A2 90			LDX	#$90			; set exponent=2^16 (integer)
  3803 C02A 4C CD C8			JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
  3804
  3805 				; perform POS()
  3806 C02D			LAB_POS
  3807 C02D A4 0E			LDY	TPos			; get terminal position
  3808
  3809 				; convert Y to byte in FAC1
  3810 C02F			LAB_1FD0
  3811 C02F A9 00			LDA	#$00			; clear high byte
  3812 C031 F0 EF			BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  3813
  3814 				; check not Direct (used by DEF and INPUT)
  3815 C033			LAB_CKRN
  3816 C033 A6 48			LDX	Clineh			; get current line high byte
  3817 C035 E8				INX				; increment it
  3818 C036 D0 98			BNE	LAB_1F7B		; return if can continue not direct mode
  3819
  3820 									; else do illegal direct error
  3821 C038			LAB_1FD9
  3822 C038 A2 16			LDX	#$16			; error code $16 ('Illegal direct' error)
  3823 C03A			LAB_1FDB
  3824 C03A 4C 07 B1			JMP	LAB_XERR		; go do error #X, then warm start
  3825
  3826 				; perform DEF
  3827 C03D			LAB_DEF
  3828 C03D 20 6E C0			JSR	LAB_200B		; check FNx syntax
  3829 C040 85 5C			STA	func_l			; save function pointer low byte
  3830 C042 84 5D			STY	func_h			; save function pointer high byte
  3831 C044 20 33 C0			JSR	LAB_CKRN		; check not Direct (back here if ok)
  3832 C047 20 B5 BB			JSR	LAB_1BFE		; scan for '(' , else do syntax error then warm start
  3833 C04A A9 80			LDA	#$80			; set flag for FNx
  3834 C04C 85 21			STA	Sufnxf			; save subscript/FNx flag
  3835 C04E 20 67 BD			JSR	LAB_GVAR		; get (var) address
  3836 C051 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3837 C054 20 AA BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  3838 C057 A9 D7			LDA	#TK_EQUAL		; get = token
  3839 C059 20 AC BB			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3840 C05C A5 56			LDA	Cvarah			; get current var address high byte
  3841 C05E 48				PHA				; push it
  3842 C05F A5 55			LDA	Cvaral			; get current var address low byte
  3843 C061 48				PHA				; push it
  3844 C062 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  3845 C064 48				PHA				; push it
  3846 C065 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  3847 C067 48				PHA				; push it
  3848 C068 20 53 B6			JSR	LAB_DATA		; go perform DATA
  3849 C06B 4C DD C0			JMP	LAB_207A		; put execute pointer and variable pointer into function
  3850 									; and return
  3851
  3852 				; check FNx syntax
  3853 C06E			LAB_200B
  3854 C06E A9 C3			LDA	#TK_FN			; get FN' token
  3855 C070 20 AC BB			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  3856 									; return character after A
  3857 C073 09 80			ORA	#$80			; set FN flag bit
  3858 C075 85 21			STA	Sufnxf			; save FN flag so array variable test fails
  3859 C077 20 6E BD			JSR	LAB_1D12		; search for FN variable
  3860 C07A 4C 8B BA			JMP	LAB_CTNM		; check if source is numeric and return, else do type
  3861 									; mismatch
  3862 									; Evaluate FNx
  3863 C07D			LAB_201E
  3864 C07D 20 6E C0			JSR	LAB_200B		; check FNx syntax
  3865 C080 48				PHA				; push function pointer low byte
  3866 C081 98				TYA				; copy function pointer high byte
  3867 C082 48				PHA				; push function pointer high byte
  3868 C083 20 B5 BB			JSR	LAB_1BFE		; scan for '(', else do syntax error then warm start
  3869 C086 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  3870 C089 20 AA BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  3871 C08C 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3872 C08F 68				PLA				; pop function pointer high byte
  3873 C090 85 5D			STA	func_h			; restore it
  3874 C092 68				PLA				; pop function pointer low byte
  3875 C093 85 5C			STA	func_l			; restore it
  3876 C095 A2 20			LDX	#$20			; error code $20 ('Undefined function' error)
  3877 C097 A0 03			LDY	#$03			; index to variable pointer high byte
  3878 C099 B1 5C			LDA	(func_l),Y		; get variable pointer high byte
  3879 C09B F0 9D			BEQ	LAB_1FDB		; if zero go do undefined function error
  3880
  3881 C09D 85 56			STA	Cvarah			; save variable address high byte
  3882 C09F 88				DEY				; index to variable address low byte
  3883 C0A0 B1 5C			LDA	(func_l),Y		; get variable address low byte
  3884 C0A2 85 55			STA	Cvaral			; save variable address low byte
  3885 C0A4 AA				TAX				; copy address low byte
  3886 									; now stack the function variable value before use
  3887 C0A5 C8				INY				; index to mantissa_3
  3888 C0A6			LAB_2043
  3889 C0A6 B1 55			LDA	(Cvaral),Y		; get byte from variable
  3890 C0A8 48				PHA				; stack it
  3891 C0A9 88				DEY				; decrement index
  3892 C0AA 10 FA			BPL	LAB_2043		; loop until variable stacked
  3893
  3894 C0AC A4 56			LDY	Cvarah			; get variable address high byte
  3895 C0AE 20 72 C8			JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  3896 									; (function variable), return Y=0, always
  3897 C0B1 A5 84			LDA	Bpntrh			; get BASIC execute pointer high byte
  3898 C0B3 48				PHA				; push it
  3899 C0B4 A5 83			LDA	Bpntrl			; get BASIC execute pointer low byte
  3900 C0B6 48				PHA				; push it
  3901 C0B7 B1 5C			LDA	(func_l),Y		; get function execute pointer low byte
  3902 C0B9 85 83			STA	Bpntrl			; save as BASIC execute pointer low byte
  3903 C0BB C8				INY				; index to high byte
  3904 C0BC B1 5C			LDA	(func_l),Y		; get function execute pointer high byte
  3905 C0BE 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  3906 C0C0 A5 56			LDA	Cvarah			; get variable address high byte
  3907 C0C2 48				PHA				; push it
  3908 C0C3 A5 55			LDA	Cvaral			; get variable address low byte
  3909 C0C5 48				PHA				; push it
  3910 C0C6 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3911 									; else do type mismatch
  3912 C0C9 68				PLA				; pull variable address low byte
  3913 C0CA 85 5C			STA	func_l			; save variable address low byte
  3914 C0CC 68				PLA				; pull variable address high byte
  3915 C0CD 85 5D			STA	func_h			; save variable address high byte
  3916 C0CF 20 82 00			JSR	LAB_GBYT		; scan memory
  3917 C0D2 F0 03			BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  3918
  3919 C0D4 4C BD BB			JMP	LAB_SNER		; else syntax error then warm start
  3920
  3921 				; restore Bpntrl,Bpntrh and function variable from stack
  3922 C0D7			LAB_2074
  3923 C0D7 68				PLA				; pull BASIC execute pointer low byte
  3924 C0D8 85 83			STA	Bpntrl			; restore BASIC execute pointer low byte
  3925 C0DA 68				PLA				; pull BASIC execute pointer high byte
  3926 C0DB 85 84			STA	Bpntrh			; restore BASIC execute pointer high byte
  3927
  3928 				; put execute pointer and variable pointer into function
  3929 C0DD			LAB_207A
  3930 C0DD A0 00			LDY	#$00			; clear index
  3931 C0DF 68				PLA				; pull BASIC execute pointer low byte
  3932 C0E0 91 5C			STA	(func_l),Y		; save to function
  3933 C0E2 C8				INY				; increment index
  3934 C0E3 68				PLA				; pull BASIC execute pointer high byte
  3935 C0E4 91 5C			STA	(func_l),Y		; save to function
  3936 C0E6 C8				INY				; increment index
  3937 C0E7 68				PLA				; pull current var address low byte
  3938 C0E8 91 5C			STA	(func_l),Y		; save to function
  3939 C0EA C8				INY				; increment index
  3940 C0EB 68				PLA				; pull current var address high byte
  3941 C0EC 91 5C			STA	(func_l),Y		; save to function
  3942 C0EE 60				RTS
  3943
  3944 				; perform STR$()
  3945 C0EF			LAB_STRS
  3946 C0EF 20 8B BA			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3947 C0F2 20 60 CA			JSR	LAB_296E		; convert FAC1 to string
  3948 C0F5 A9 05			LDA	#<Decssp1		; set result string low pointer
  3949 C0F7 A0 00			LDY	#>Decssp1		; set result string high pointer
  3950 C0F9 F0 12			BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
  3951
  3952 				; Do string vector
  3953 				; copy des_pl/h to des_2l/h and make string space A bytes long
  3954 C0FB			LAB_209C
  3955 C0FB A6 6E			LDX	des_pl			; get descriptor pointer low byte
  3956 C0FD A4 6F			LDY	des_ph			; get descriptor pointer high byte
  3957 C0FF 86 5E			STX	des_2l			; save descriptor pointer low byte
  3958 C101 84 5F			STY	des_2h			; save descriptor pointer high byte
  3959
  3960 				; make string space A bytes long
  3961 				; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  3962 C103			LAB_MSSP
  3963 C103 20 78 C1			JSR	LAB_2115		; make space in string memory for string A long
  3964 									; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  3965 C106 86 6D			STX	str_pl			; save string pointer low byte
  3966 C108 84 6E			STY	str_ph			; save string pointer high byte
  3967 C10A 85 6C			STA	str_ln			; save length
  3968 C10C 60				RTS
  3969
  3970 				; Scan, set up string
  3971 				; print ' terminated string to Sutill/Sutilh
  3972 C10D			LAB_20AE
  3973 C10D A2 22			LDX	#$22			; set terminator to '
  3974 C10F 86 1B			STX	Srchc			; set search character (terminator 1)
  3975 C111 86 1C			STX	Asrch			; set terminator 2
  3976
  3977 				; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  3978 				; source is AY
  3979 C113			LAB_20B4
  3980 C113 85 78			STA	ssptr_l			; store string start low byte
  3981 C115 84 79			STY	ssptr_h			; store string start high byte
  3982 C117 85 6D			STA	str_pl			; save string pointer low byte
  3983 C119 84 6E			STY	str_ph			; save string pointer high byte
  3984 C11B A0 FF			LDY	#$FF			; set length to -1
  3985 C11D			LAB_20BE
  3986 C11D C8				INY				; increment length
  3987 C11E B1 78			LDA	(ssptr_l),Y		; get byte from string
  3988 C120 F0 0C			BEQ	LAB_20CF		; exit loop if null byte [EOS]
  3989
  3990 C122 C5 1B			CMP	Srchc			; compare with search character (terminator 1)
  3991 C124 F0 04			BEQ	LAB_20CB		; branch if terminator
  3992
  3993 C126 C5 1C			CMP	Asrch			; compare with terminator 2
  3994 C128 D0 F3			BNE	LAB_20BE		; loop if not terminator 2
  3995
  3996 C12A			LAB_20CB
  3997 C12A C9 22			CMP	#$22			; compare with '
  3998 C12C F0 01			BEQ	LAB_20D0		; branch if ' (carry set if = !)
  3999
  4000 C12E			LAB_20CF
  4001 C12E 18				CLC				; clear carry for add (only if [EOL] terminated string)
  4002 C12F			LAB_20D0
  4003 C12F 84 6C			STY	str_ln			; save length in FAC1 exponent
  4004 C131 98				TYA				; copy length to A
  4005 C132 65 78			ADC	ssptr_l			; add string start low byte
  4006 C134 85 7A			STA	Sendl			; save string end low byte
  4007 C136 A6 79			LDX	ssptr_h			; get string start high byte
  4008 C138 90 01			BCC	LAB_20DC		; branch if no low byte overflow
  4009
  4010 C13A E8				INX				; else increment high byte
  4011 C13B			LAB_20DC				; RAM above code / Ibuff above EhBASIC patch V2
  4012 C13B 86 7B			STX	Sendh			; save string end high byte
  4013 C13D A5 79			LDA	ssptr_h			; get string start high byte
  4014 C13F F0 04			BEQ   	LAB_MVST          	; fix STR$() using page zero via LAB_296E
  4015 					
  4016 C141 C9 18			CMP   	#>Ibuffs          	; compare with location of input buffer page
  4017 C143 D0 0B			BNE   	LAB_RTST          	; branch if not in utility area
  4018 C145			LAB_MVST 
  4019 									; string in utility area, move to string memory
  4020 C145 98				TYA				; copy length to A
  4021 C146 20 FB C0			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4022 									; long
  4023 C149 A6 78			LDX	ssptr_l			; get string start low byte
  4024 C14B A4 79			LDY	ssptr_h			; get string start high byte
  4025 C14D 20 EA C2			JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
  4026
  4027 				; check for space on descriptor stack then ..
  4028 				; put string address and length on descriptor stack and update stack pointers
  4029 C150			LAB_RTST
  4030 C150 A6 25			LDX	next_s			; get string stack pointer
  4031 C152 E0 31			CPX	#des_sk+$09		; compare with max+1
  4032 C154 D0 05			BNE	LAB_20F8		; branch if space on string stack
  4033
  4034 									; else do string too complex error
  4035 C156 A2 1C			LDX	#$1C			; error code $1C ('String too complex' error)
  4036 C158			LAB_20F5
  4037 C158 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  4038
  4039 				; put string address and length on descriptor stack and update stack pointers
  4040 C15B			LAB_20F8
  4041 C15B A5 6C			LDA	str_ln			; get string length
  4042 C15D 95 00			STA	PLUS_0,X		; put on string stack
  4043 C15F A5 6D			LDA	str_pl			; get string pointer low byte
  4044 C161 95 01			STA	PLUS_1,X		; put on string stack
  4045 C163 A5 6E			LDA	str_ph			; get string pointer high byte
  4046 C165 95 02			STA	PLUS_2,X		; put on string stack
  4047 C167 A0 00			LDY	#$00			; clear Y
  4048 C169 86 6E			STX	des_pl			; save string descriptor pointer low byte
  4049 C16B 84 6F			STY	des_ph			; save string descriptor pointer high byte (always $00)
  4050 C16D 88				DEY				; Y = $FF
  4051 C16E 84 1F			STY	Dtypef			; save data type flag, $FF=string
  4052 C170 86 26			STX	last_sl			; save old stack pointer (current top item)
  4053 C172 E8				INX				; update stack pointer
  4054 C173 E8				INX				; update stack pointer
  4055 C174 E8				INX				; update stack pointer
  4056 C175 86 25			STX	next_s			; save new top item value
  4057 C177 60				RTS
  4058
  4059 				; Build descriptor
  4060 				; make space in string memory for string A long
  4061 				; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4062 C178			LAB_2115
  4063 C178 46 20			LSR	Gclctd			; clear garbage collected flag (b7)
  4064 									; make space for string A long
  4065 C17A			LAB_2117
  4066 C17A 48				PHA				; save string length
  4067 C17B 49 FF			EOR	#$FF			; complement it
  4068 C17D 38				SEC				; set carry for subtract (twos comp add)
  4069 C17E 65 41			ADC	Sstorl			; add bottom of string space low byte (subtract length)
  4070 C180 A4 42			LDY	Sstorh			; get bottom of string space high byte
  4071 C182 B0 01			BCS	LAB_2122		; skip decrement if no underflow
  4072
  4073 C184 88				DEY				; decrement bottom of string space high byte
  4074 C185			LAB_2122
  4075 C185 C4 40			CPY	Earryh			; compare with array mem end high byte
  4076 C187 90 11			BCC	LAB_2137		; do out of memory error if less
  4077
  4078 C189 D0 04			BNE	LAB_212C		; if not = skip next test
  4079
  4080 C18B C5 3F			CMP	Earryl			; compare with array mem end low byte
  4081 C18D 90 0B			BCC	LAB_2137		; do out of memory error if less
  4082
  4083 C18F			LAB_212C
  4084 C18F 85 41			STA	Sstorl			; save bottom of string space low byte
  4085 C191 84 42			STY	Sstorh			; save bottom of string space high byte
  4086 C193 85 43			STA	Sutill			; save string utility ptr low byte
  4087 C195 84 44			STY	Sutilh			; save string utility ptr high byte
  4088 C197 AA				TAX				; copy low byte to X
  4089 C198 68				PLA				; get string length back
  4090 C199 60				RTS
  4091
  4092 C19A			LAB_2137
  4093 C19A A2 0C			LDX	#$0C			; error code $0C ('Out of memory' error)
  4094 C19C A5 20			LDA	Gclctd			; get garbage collected flag
  4095 C19E 30 B8			BMI	LAB_20F5		; if set then do error code X
  4096
  4097 C1A0 20 AA C1			JSR	LAB_GARB		; else go do garbage collection
  4098 C1A3 A9 80			LDA	#$80			; flag for garbage collected
  4099 C1A5 85 20			STA	Gclctd			; set garbage collected flag
  4100 C1A7 68				PLA				; pull length
  4101 C1A8 D0 D0			BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4102
  4103 				; garbage collection routine
  4104 C1AA			LAB_GARB
  4105 C1AA A6 45			LDX	Ememl			; get end of mem low byte
  4106 C1AC A5 46			LDA	Ememh			; get end of mem high byte
  4107
  4108 				; re-run routine from last ending
  4109 C1AE			LAB_214B
  4110 C1AE 86 41			STX	Sstorl			; set string storage low byte
  4111 C1B0 85 42			STA	Sstorh			; set string storage high byte
  4112 C1B2 A0 00			LDY	#$00			; clear index
  4113 C1B4 84 5D			STY	garb_h			; clear working pointer high byte (flag no strings to move)
  4114 C1B6 A5 3F			LDA	Earryl			; get array mem end low byte
  4115 C1B8 A6 40			LDX	Earryh			; get array mem end high byte
  4116 C1BA 85 6A			STA	Histrl			; save as highest string low byte
  4117 C1BC 86 6B			STX	Histrh			; save as highest string high byte
  4118 C1BE A9 28			LDA	#des_sk			; set descriptor stack pointer
  4119 C1C0 85 31			STA	ut1_pl			; save descriptor stack pointer low byte
  4120 C1C2 84 32			STY	ut1_ph			; save descriptor stack pointer high byte ($00)
  4121 C1C4			LAB_2161
  4122 C1C4 C5 25			CMP	next_s			; compare with descriptor stack pointer
  4123 C1C6 F0 05			BEQ	LAB_216A		; branch if =
  4124
  4125 C1C8 20 2E C2			JSR	LAB_21D7		; go garbage collect descriptor stack
  4126 C1CB F0 F7			BEQ	LAB_2161		; loop always
  4127
  4128 									; done stacked strings, now do string vars
  4129 C1CD			LAB_216A
  4130 C1CD 06 60			ASL	g_step			; set step size = $06
  4131 C1CF A5 3B			LDA	Svarl			; get start of vars low byte
  4132 C1D1 A6 3C			LDX	Svarh			; get start of vars high byte
  4133 C1D3 85 31			STA	ut1_pl			; save as pointer low byte
  4134 C1D5 86 32			STX	ut1_ph			; save as pointer high byte
  4135 C1D7			LAB_2176
  4136 C1D7 E4 3E			CPX	Sarryh			; compare start of arrays high byte
  4137 C1D9 D0 04			BNE	LAB_217E		; branch if no high byte match
  4138
  4139 C1DB C5 3D			CMP	Sarryl			; else compare start of arrays low byte
  4140 C1DD F0 05			BEQ	LAB_2183		; branch if = var mem end
  4141
  4142 C1DF			LAB_217E
  4143 C1DF 20 28 C2			JSR	LAB_21D1		; go garbage collect strings
  4144 C1E2 F0 F3			BEQ	LAB_2176		; loop always
  4145
  4146 									; done string vars, now do string arrays
  4147 C1E4			LAB_2183
  4148 C1E4 85 64			STA	Nbendl			; save start of arrays low byte as working pointer
  4149 C1E6 86 65			STX	Nbendh			; save start of arrays high byte as working pointer
  4150 C1E8 A9 04			LDA	#$04			; set step size
  4151 C1EA 85 60			STA	g_step			; save step size
  4152 C1EC			LAB_218B
  4153 C1EC A5 64			LDA	Nbendl			; get pointer low byte
  4154 C1EE A6 65			LDX	Nbendh			; get pointer high byte
  4155 C1F0			LAB_218F
  4156 C1F0 E4 40			CPX	Earryh			; compare with array mem end high byte
  4157 C1F2 D0 04			BNE	LAB_219A		; branch if not at end
  4158
  4159 C1F4 C5 3F			CMP	Earryl			; else compare with array mem end low byte
  4160 C1F6 F0 75			BEQ	LAB_2216		; tidy up and exit if at end
  4161
  4162 C1F8			LAB_219A
  4163 C1F8 85 31			STA	ut1_pl			; save pointer low byte
  4164 C1FA 86 32			STX	ut1_ph			; save pointer high byte
  4165 C1FC A0 02			LDY	#$02			; set index
  4166 C1FE B1 31			LDA	(ut1_pl),Y		; get array size low byte
  4167 C200 65 64			ADC	Nbendl			; add start of this array low byte
  4168 C202 85 64			STA	Nbendl			; save start of next array low byte
  4169 C204 C8				INY				; increment index
  4170 C205 B1 31			LDA	(ut1_pl),Y		; get array size high byte
  4171 C207 65 65			ADC	Nbendh			; add start of this array high byte
  4172 C209 85 65			STA	Nbendh			; save start of next array high byte
  4173 C20B A0 01			LDY	#$01			; set index
  4174 C20D B1 31			LDA	(ut1_pl),Y		; get name second byte
  4175 C20F 10 DB			BPL	LAB_218B		; skip if not string array
  4176
  4177 				; was string array so ..
  4178 C211 A0 04			LDY	#$04			; set index
  4179 C213 B1 31			LDA	(ut1_pl),Y		; get # of dimensions
  4180 C215 0A				ASL				; *2
  4181 C216 69 05			ADC	#$05			; +5 (array header size)
  4182 C218 20 60 C2			JSR	LAB_2208		; go set up for first element
  4183 C21B			LAB_21C4
  4184 C21B E4 65			CPX	Nbendh			; compare with start of next array high byte
  4185 C21D D0 04			BNE	LAB_21CC		; branch if <> (go do this array)
  4186
  4187 C21F C5 64			CMP	Nbendl			; else compare element pointer low byte with next array
  4188 									; low byte
  4189 C221 F0 CD			BEQ	LAB_218F		; if equal then go do next array
  4190
  4191 C223			LAB_21CC
  4192 C223 20 2E C2			JSR	LAB_21D7		; go defrag array strings
  4193 C226 F0 F3			BEQ	LAB_21C4		; go do next array string (loop always)
  4194
  4195 				; defrag string variables
  4196 				; enter with XA = variable pointer
  4197 				; return with XA = next variable pointer
  4198 C228			LAB_21D1
  4199 C228 C8				INY				; increment index (Y was $00)
  4200 C229 B1 31			LDA	(ut1_pl),Y		; get var name byte 2
  4201 C22B 10 30			BPL	LAB_2206		; if not string, step pointer to next var and return
  4202
  4203 C22D C8				INY				; else increment index
  4204 C22E			LAB_21D7
  4205 C22E B1 31			LDA	(ut1_pl),Y		; get string length
  4206 C230 F0 2B			BEQ	LAB_2206		; if null, step pointer to next string and return
  4207
  4208 C232 C8				INY				; else increment index
  4209 C233 B1 31			LDA	(ut1_pl),Y		; get string pointer low byte
  4210 C235 AA				TAX				; copy to X
  4211 C236 C8				INY				; increment index
  4212 C237 B1 31			LDA	(ut1_pl),Y		; get string pointer high byte
  4213 C239 C5 42			CMP	Sstorh			; compare bottom of string space high byte
  4214 C23B 90 06			BCC	LAB_21EC		; branch if less
  4215
  4216 C23D D0 1E			BNE	LAB_2206		; if greater, step pointer to next string and return
  4217
  4218 									; high bytes were = so compare low bytes
  4219 C23F E4 41			CPX	Sstorl			; compare bottom of string space low byte
  4220 C241 B0 1A			BCS	LAB_2206		; if >=, step pointer to next string and return
  4221
  4222 									; string pointer is < string storage pointer (pos in mem)
  4223 C243			LAB_21EC
  4224 C243 C5 6B			CMP	Histrh			; compare to highest string high byte
  4225 C245 90 17			BCC	LAB_2207		; if <, step pointer to next string and return
  4226
  4227 C247 D0 04			BNE	LAB_21F6		; if > update pointers, step to next and return
  4228
  4229 									; high bytes were = so compare low bytes
  4230 C249 E4 6A			CPX	Histrl			; compare to highest string low byte
  4231 C24B 90 11			BCC	LAB_2207		; if <, step pointer to next string and return
  4232
  4233 									; string is in string memory space
  4234 C24D			LAB_21F6
  4235 C24D 86 6A			STX	Histrl			; save as new highest string low byte
  4236 C24F 85 6B			STA	Histrh			; save as new highest string high byte
  4237 C251 A5 31			LDA	ut1_pl			; get start of vars(descriptors) low byte
  4238 C253 A6 32			LDX	ut1_ph			; get start of vars(descriptors) high byte
  4239 C255 85 5C			STA	garb_l			; save as working pointer low byte
  4240 C257 86 5D			STX	garb_h			; save as working pointer high byte
  4241 C259 88				DEY				; decrement index DIFFERS
  4242 C25A 88				DEY				; decrement index (should point to descriptor start)
  4243 C25B 84 62			STY	g_indx			; save index pointer
  4244
  4245 									; step pointer to next string
  4246 C25D			LAB_2206
  4247 C25D 18				CLC				; clear carry for add
  4248 C25E			LAB_2207
  4249 C25E A5 60			LDA	g_step			; get step size
  4250 C260			LAB_2208
  4251 C260 65 31			ADC	ut1_pl			; add pointer low byte
  4252 C262 85 31			STA	ut1_pl			; save pointer low byte
  4253 C264 90 02			BCC	LAB_2211		; branch if no overflow
  4254
  4255 C266 E6 32			INC	ut1_ph			; else increment high byte
  4256 C268			LAB_2211
  4257 C268 A6 32			LDX	ut1_ph			; get pointer high byte
  4258 C26A A0 00			LDY	#$00			; clear Y
  4259 C26C 60				RTS
  4260
  4261 				; search complete, now either exit or set-up and move string
  4262 C26D			LAB_2216
  4263 C26D C6 60			DEC	g_step			; decrement step size (now $03 for descriptor stack)
  4264 C26F A6 5D			LDX	garb_h			; get string to move high byte
  4265 C271 F0 F5			BEQ	LAB_2211		; exit if nothing to move
  4266
  4267 C273 A4 62			LDY	g_indx			; get index byte back (points to descriptor)
  4268 C275 18				CLC				; clear carry for add
  4269 C276 B1 5C			LDA	(garb_l),Y		; get string length
  4270 C278 65 6A			ADC	Histrl			; add highest string low byte
  4271 C27A 85 66			STA	Obendl			; save old block end low pointer
  4272 C27C A5 6B			LDA	Histrh			; get highest string high byte
  4273 C27E 69 00			ADC	#$00			; add any carry
  4274 C280 85 67			STA	Obendh			; save old block end high byte
  4275 C282 A5 41			LDA	Sstorl			; get bottom of string space low byte
  4276 C284 A6 42			LDX	Sstorh			; get bottom of string space high byte
  4277 C286 85 64			STA	Nbendl			; save new block end low byte
  4278 C288 86 65			STX	Nbendh			; save new block end high byte
  4279 C28A 20 90 B0			JSR	LAB_11D6		; open up space in memory, don't set array end
  4280 C28D A4 62			LDY	g_indx			; get index byte
  4281 C28F C8				INY				; point to descriptor low byte
  4282 C290 A5 64			LDA	Nbendl			; get string pointer low byte
  4283 C292 91 5C			STA	(garb_l),Y		; save new string pointer low byte
  4284 C294 AA				TAX				; copy string pointer low byte
  4285 C295 E6 65			INC	Nbendh			; correct high byte (move sets high byte -1)
  4286 C297 A5 65			LDA	Nbendh			; get new string pointer high byte
  4287 C299 C8				INY				; point to descriptor high byte
  4288 C29A 91 5C			STA	(garb_l),Y		; save new string pointer high byte
  4289 C29C 4C AE C1			JMP	LAB_214B		; re-run routine from last ending
  4290 									; (but don't collect this string)
  4291
  4292 				; concatenate
  4293 				; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4294 C29F			LAB_224D
  4295 C29F A5 6F			LDA	des_ph			; get descriptor pointer high byte
  4296 C2A1 48				PHA				; put on stack
  4297 C2A2 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4298 C2A4 48				PHA				; put on stack
  4299 C2A5 20 88 BB			JSR	LAB_GVAL		; get value from line
  4300 C2A8 20 8D BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4301 C2AB 68				PLA				; get descriptor pointer low byte back
  4302 C2AC 85 78			STA	ssptr_l			; set pointer low byte
  4303 C2AE 68				PLA				; get descriptor pointer high byte back
  4304 C2AF 85 79			STA	ssptr_h			; set pointer high byte
  4305 C2B1 A0 00			LDY	#$00			; clear index
  4306 C2B3 B1 78			LDA	(ssptr_l),Y		; get length_1 from descriptor
  4307 C2B5 18				CLC				; clear carry for add
  4308 C2B6 71 6E			ADC	(des_pl),Y		; add length_2
  4309 C2B8 90 05			BCC	LAB_226D		; branch if no overflow
  4310
  4311 C2BA A2 1A			LDX	#$1A			; else set error code $1A ('String too long' error)
  4312 C2BC 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  4313
  4314 C2BF			LAB_226D
  4315 C2BF 20 FB C0			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4316 									; long
  4317 C2C2 20 DC C2			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  4318 C2C5 A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4319 C2C7 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4320 C2C9 20 0D C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4321 									; returns with A = length, ut1_pl = pointer low byte,
  4322 									; ut1_ph = pointer high byte
  4323 C2CC 20 EE C2			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4324 C2CF A5 78			LDA	ssptr_l			;.set descriptor pointer low byte
  4325 C2D1 A4 79			LDY	ssptr_h			;.set descriptor pointer high byte
  4326 C2D3 20 0D C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4327 									; returns with A = length, X=ut1_pl=pointer low byte,
  4328 									; Y=ut1_ph=pointer high byte
  4329 C2D6 20 50 C1			JSR	LAB_RTST		; check for space on descriptor stack then put string
  4330 									; address and length on descriptor stack and update stack
  4331 									; pointers
  4332 C2D9 4C B3 BA			JMP	LAB_1ADB		;.continue evaluation
  4333
  4334 				; copy string from descriptor (sdescr) to (Sutill)
  4335 C2DC			LAB_228A
  4336 C2DC A0 00			LDY	#$00			; clear index
  4337 C2DE B1 78			LDA	(sdescr),Y		; get string length
  4338 C2E0 48				PHA				; save on stack
  4339 C2E1 C8				INY				; increment index
  4340 C2E2 B1 78			LDA	(sdescr),Y		; get source string pointer low byte
  4341 C2E4 AA				TAX				; copy to X
  4342 C2E5 C8				INY				; increment index
  4343 C2E6 B1 78			LDA	(sdescr),Y		; get source string pointer high byte
  4344 C2E8 A8				TAY				; copy to Y
  4345 C2E9 68				PLA				; get length back
  4346
  4347 				; store string A bytes long from YX to (Sutill)
  4348 C2EA			LAB_2298
  4349 C2EA 86 31			STX	ut1_pl			; save source string pointer low byte
  4350 C2EC 84 32			STY	ut1_ph			; save source string pointer high byte
  4351
  4352 				; store string A bytes long from (ut1_pl) to (Sutill)
  4353 C2EE			LAB_229C
  4354 C2EE AA				TAX				; copy length to index (don't count with Y)
  4355 C2EF F0 14			BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4356
  4357 C2F1 A0 00			LDY	#$00			; zero pointer (copy forward)
  4358 C2F3			LAB_22A0
  4359 C2F3 B1 31			LDA	(ut1_pl),Y		; get source byte
  4360 C2F5 91 43			STA	(Sutill),Y		; save destination byte
  4361
  4362 C2F7 C8				INY				; increment index
  4363 C2F8 CA				DEX				; decrement counter
  4364 C2F9 D0 F8			BNE	LAB_22A0		; loop while <> 0
  4365
  4366 C2FB 98				TYA				; restore length from Y
  4367 C2FC			LAB_22A9
  4368 C2FC 18				CLC				; clear carry for add
  4369 C2FD 65 43			ADC	Sutill			; add string utility ptr low byte
  4370 C2FF 85 43			STA	Sutill			; save string utility ptr low byte
  4371 C301 90 02			BCC	LAB_22B2		; branch if no carry
  4372
  4373 C303 E6 44			INC	Sutilh			; else increment string utility ptr high byte
  4374 C305			LAB_22B2
  4375 C305 60				RTS
  4376
  4377 				; evaluate string
  4378 C306			LAB_EVST
  4379 C306 20 8D BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4380
  4381 				; pop string off descriptor stack, or from top of string space
  4382 				; returns with A = length, X=pointer low byte, Y=pointer high byte
  4383 C309			LAB_22B6
  4384 C309 A5 6E			LDA	des_pl			; get descriptor pointer low byte
  4385 C30B A4 6F			LDY	des_ph			; get descriptor pointer high byte
  4386
  4387 				; pop (YA) descriptor off stack or from top of string space
  4388 				; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4389 C30D			LAB_22BA
  4390 C30D 85 31			STA	ut1_pl			; save descriptor pointer low byte
  4391 C30F 84 32			STY	ut1_ph			; save descriptor pointer high byte
  4392 C311 20 3E C3			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  4393 C314 08				PHP				; save status flags
  4394 C315 A0 00			LDY	#$00			; clear index
  4395 C317 B1 31			LDA	(ut1_pl),Y		; get length from string descriptor
  4396 C319 48				PHA				; put on stack
  4397 C31A C8				INY				; increment index
  4398 C31B B1 31			LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
  4399 C31D AA				TAX				; copy to X
  4400 C31E C8				INY				; increment index
  4401 C31F B1 31			LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
  4402 C321 A8				TAY				; copy to Y
  4403 C322 68				PLA				; get string length back
  4404 C323 28				PLP				; restore status
  4405 C324 D0 13			BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
  4406
  4407 C326 C4 42			CPY	Sstorh			; compare bottom of string space high byte
  4408 C328 D0 0F			BNE	LAB_22E6		; branch if <>
  4409
  4410 C32A E4 41			CPX	Sstorl			; else compare bottom of string space low byte
  4411 C32C D0 0B			BNE	LAB_22E6		; branch if <>
  4412
  4413 C32E 48				PHA				; save string length
  4414 C32F 18				CLC				; clear carry for add
  4415 C330 65 41			ADC	Sstorl			; add bottom of string space low byte
  4416 C332 85 41			STA	Sstorl			; save bottom of string space low byte
  4417 C334 90 02			BCC	LAB_22E5		; skip increment if no overflow
  4418
  4419 C336 E6 42			INC	Sstorh			; increment bottom of string space high byte
  4420 C338			LAB_22E5
  4421 C338 68				PLA				; restore string length
  4422 C339			LAB_22E6
  4423 C339 86 31			STX	ut1_pl			; save string pointer low byte
  4424 C33B 84 32			STY	ut1_ph			; save string pointer high byte
  4425 C33D 60				RTS
  4426
  4427 				; clean descriptor stack, YA = pointer
  4428 				; checks if AY is on the descriptor stack, if so does a stack discard
  4429 C33E			LAB_22EB
  4430 C33E C4 27			CPY	last_sh			; compare pointer high byte
  4431 C340 D0 0C			BNE	LAB_22FB		; exit if <>
  4432
  4433 C342 C5 26			CMP	last_sl			; compare pointer low byte
  4434 C344 D0 08			BNE	LAB_22FB		; exit if <>
  4435
  4436 C346 85 25			STA	next_s			; save descriptor stack pointer
  4437 C348 E9 03			SBC	#$03			; -3
  4438 C34A 85 26			STA	last_sl			; save low byte -3
  4439 C34C A0 00			LDY	#$00			; clear high byte
  4440 C34E			LAB_22FB
  4441 C34E 60				RTS
  4442
  4443 				; perform CHR$()
  4444 C34F			LAB_CHRS
  4445 C34F 20 5A C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  4446 C352 8A				TXA				; copy to A
  4447 C353 48				PHA				; save character
  4448 C354 A9 01			LDA	#$01			; string is single byte
  4449 C356 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4450 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4451 C359 68				PLA				; get character back
  4452 C35A A0 00			LDY	#$00			; clear index
  4453 C35C 91 6D			STA	(str_pl),Y		; save byte in string (byte IS string!)
  4454 C35E 4C 50 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4455 									; address and length on descriptor stack and update stack
  4456 									; pointers
  4457
  4458 				; perform LEFT$()
  4459 C361			LAB_LEFT
  4460 C361 48				PHA				; push byte parameter
  4461 C362 20 C2 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4462 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4463 C365 D1 5E			CMP	(des_2l),Y		; compare byte parameter with string length
  4464 C367 98				TYA				; clear A
  4465 C368 F0 09			BEQ	LAB_2316		; go do string copy (branch always)
  4466
  4467 				; perform RIGHT$()
  4468 C36A			LAB_RIGHT
  4469 C36A 48				PHA				; push byte parameter
  4470 C36B 20 C2 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4471 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4472 C36E 18				CLC				; clear carry for add-1
  4473 C36F F1 5E			SBC	(des_2l),Y		; subtract string length
  4474 C371 49 FF			EOR	#$FF			; invert it (A=LEN(expression$)-l)
  4475
  4476 C373			LAB_2316
  4477 C373 90 04			BCC	LAB_231C		; branch if string length > byte parameter
  4478
  4479 C375 B1 5E			LDA	(des_2l),Y		; else make parameter = length
  4480 C377 AA				TAX				; copy to byte parameter copy
  4481 C378 98				TYA				; clear string start offset
  4482 C379			LAB_231C
  4483 C379 48				PHA				; save string start offset
  4484 C37A			LAB_231D
  4485 C37A 8A				TXA				; copy byte parameter (or string length if <)
  4486 C37B			LAB_231E
  4487 C37B 48				PHA				; save string length
  4488 C37C 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4489 									; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4490 C37F A5 5E			LDA	des_2l			; get descriptor pointer low byte
  4491 C381 A4 5F			LDY	des_2h			; get descriptor pointer high byte
  4492 C383 20 0D C3			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4493 									; returns with A = length, X=ut1_pl=pointer low byte,
  4494 									; Y=ut1_ph=pointer high byte
  4495 C386 68				PLA				; get string length back
  4496 C387 A8				TAY				; copy length to Y
  4497 C388 68				PLA				; get string start offset back
  4498 C389 18				CLC				; clear carry for add
  4499 C38A 65 31			ADC	ut1_pl			; add start offset to string start pointer low byte
  4500 C38C 85 31			STA	ut1_pl			; save string start pointer low byte
  4501 C38E 90 02			BCC	LAB_2335		; branch if no overflow
  4502
  4503 C390 E6 32			INC	ut1_ph			; else increment string start pointer high byte
  4504 C392			LAB_2335
  4505 C392 98				TYA				; copy length to A
  4506 C393 20 EE C2			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4507 C396 4C 50 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4508 									; address and length on descriptor stack and update stack
  4509 									; pointers
  4510
  4511 				; perform MID$()
  4512 C399			LAB_MIDS
  4513 C399 48				PHA				; push byte parameter
  4514 C39A A9 FF			LDA	#$FF			; set default length = 255
  4515 C39C 85 6F			STA	mids_l			; save default length
  4516 C39E 20 82 00			JSR	LAB_GBYT		; scan memory
  4517 C3A1 C9 29			CMP	#')'			; compare with ')'
  4518 C3A3 F0 06			BEQ	LAB_2358		; branch if = ')' (skip second byte get)
  4519
  4520 C3A5 20 B9 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4521 C3A8 20 57 C4			JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
  4522 C3AB			LAB_2358
  4523 C3AB 20 C2 C3			JSR	LAB_236F		; pull string data and byte parameter from stack
  4524 									; return pointer in des_2l/h, byte in A (and X), Y=0
  4525 C3AE CA				DEX				; decrement start index
  4526 C3AF 8A				TXA				; copy to A
  4527 C3B0 48				PHA				; save string start offset
  4528 C3B1 18				CLC				; clear carry for sub-1
  4529 C3B2 A2 00			LDX	#$00			; clear output string length
  4530 C3B4 F1 5E			SBC	(des_2l),Y		; subtract string length
  4531 C3B6 B0 C2			BCS	LAB_231D		; if start>string length go do null string
  4532
  4533 C3B8 49 FF			EOR	#$FF			; complement -length
  4534 C3BA C5 6F			CMP	mids_l			; compare byte parameter
  4535 C3BC 90 BD			BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4536
  4537 C3BE A5 6F			LDA	mids_l			; get length byte
  4538 C3C0 B0 B9			BCS	LAB_231E		; go do string copy (branch always)
  4539
  4540 				; pull string data and byte parameter from stack
  4541 				; return pointer in des_2l/h, byte in A (and X), Y=0
  4542 C3C2			LAB_236F
  4543 C3C2 20 AA BB			JSR	LAB_1BFB		; scan for ')' , else do syntax error then warm start
  4544 C3C5 68				PLA				; pull return address low byte (return address)
  4545 C3C6 85 62			STA	Fnxjpl			; save functions jump vector low byte
  4546 C3C8 68				PLA				; pull return address high byte (return address)
  4547 C3C9 85 63			STA	Fnxjph			; save functions jump vector high byte
  4548 C3CB 68				PLA				; pull byte parameter
  4549 C3CC AA				TAX				; copy byte parameter to X
  4550 C3CD 68				PLA				; pull string pointer low byte
  4551 C3CE 85 5E			STA	des_2l			; save it
  4552 C3D0 68				PLA				; pull string pointer high byte
  4553 C3D1 85 5F			STA	des_2h			; save it
  4554 C3D3 A0 00			LDY	#$00			; clear index
  4555 C3D5 8A				TXA				; copy byte parameter
  4556 C3D6 F0 79			BEQ	LAB_23A8		; if null do function call error then warm start
  4557
  4558 C3D8 E6 62			INC	Fnxjpl			; increment function jump vector low byte
  4559 									; (JSR pushes return addr-1. this is all very nice
  4560 									; but will go tits up if either call is on a page
  4561 									; boundary!)
  4562 C3DA 6C 62 00			JMP	(Fnxjpl)		; in effect, RTS
  4563
  4564 				; perform LCASE$()
  4565 C3DD			LAB_LCASE
  4566 C3DD 20 06 C3			JSR	LAB_EVST		; evaluate string
  4567 C3E0 85 6C			STA	str_ln			; set string length
  4568 C3E2 A8				TAY				; copy length to Y
  4569 C3E3 F0 38			BEQ	NoString		; branch if null string
  4570
  4571 C3E5 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4572 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4573 C3E8 86 6D			STX	str_pl			; save string pointer low byte
  4574 C3EA 84 6E			STY	str_ph			; save string pointer high byte
  4575 C3EC A8				TAY				; get string length back
  4576
  4577 C3ED			LC_loop
  4578 C3ED 88				DEY				; decrement index
  4579 C3EE B1 31			LDA	(ut1_pl),Y		; get byte from string
  4580 C3F0 20 DF BD			JSR	LAB_1D82		; is character 'A' to 'Z'
  4581 C3F3 90 02			BCC	NoUcase			; branch if not upper case alpha
  4582
  4583 C3F5 09 20			ORA	#$20			; convert upper to lower case
  4584 C3F7			NoUcase
  4585 C3F7 91 43			STA	(Sutill),Y		; save byte back to string
  4586 C3F9 98				TYA				; test index
  4587 C3FA D0 F1			BNE	LC_loop			; loop if not all done
  4588
  4589 C3FC F0 1F			BEQ	NoString		; tidy up and exit, branch always
  4590
  4591 				; perform UCASE$()
  4592 C3FE			LAB_UCASE
  4593 C3FE 20 06 C3			JSR	LAB_EVST		; evaluate string
  4594 C401 85 6C			STA	str_ln			; set string length
  4595 C403 A8				TAY				; copy length to Y
  4596 C404 F0 17			BEQ	NoString		; branch if null string
  4597
  4598 C406 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long A=length,
  4599 									; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4600 C409 86 6D			STX	str_pl			; save string pointer low byte
  4601 C40B 84 6E			STY	str_ph			; save string pointer high byte
  4602 C40D A8				TAY				; get string length back
  4603
  4604 C40E			UC_loop
  4605 C40E 88				DEY				; decrement index
  4606 C40F B1 31			LDA	(ut1_pl),Y		; get byte from string
  4607 C411 20 DB BD			JSR	LAB_CASC		; is character 'a' to 'z' (or 'A' to 'Z')
  4608 C414 90 02			BCC	NoLcase			; branch if not alpha
  4609
  4610 C416 29 DF			AND	#$DF			; convert lower to upper case
  4611 C418			NoLcase
  4612 C418 91 43			STA	(Sutill),Y		; save byte back to string
  4613 C41A 98				TYA				; test index
  4614 C41B D0 F1			BNE	UC_loop			; loop if not all done
  4615
  4616 C41D			NoString
  4617 C41D 4C 50 C1			JMP	LAB_RTST		; check for space on descriptor stack then put string
  4618 									; address and length on descriptor stack and update stack
  4619 									; pointers
  4620
  4621 				; perform SADD()
  4622 C420			LAB_SADD
  4623 C420 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4624 C423 20 67 BD			JSR	LAB_GVAR		; get var address
  4625
  4626 C426 20 AA BB			JSR	LAB_1BFB		; scan for ')', else do syntax error then warm start
  4627 C429 20 8D BA			JSR	LAB_CTST		; check if source is string, else do type mismatch
  4628
  4629 C42C A0 02			LDY	#$02			; index to string pointer high byte
  4630 C42E B1 55			LDA	(Cvaral),Y		; get string pointer high byte
  4631 C430 AA				TAX				; copy string pointer high byte to X
  4632 C431 88				DEY				; index to string pointer low byte
  4633 C432 B1 55			LDA	(Cvaral),Y		; get string pointer low byte
  4634 C434 A8				TAY				; copy string pointer low byte to Y
  4635 C435 8A				TXA				; copy string pointer high byte to A
  4636 C436 4C 16 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  4637
  4638 				; perform LEN()
  4639 C439			LAB_LENS
  4640 C439 20 3F C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4641 C43C 4C 2F C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4642
  4643 				; evaluate string, get length in Y
  4644 C43F			LAB_ESGL
  4645 C43F 20 06 C3			JSR	LAB_EVST		; evaluate string
  4646 C442 A8				TAY				; copy length to Y
  4647 C443 60				RTS
  4648
  4649 				; perform ASC()
  4650 C444			LAB_ASC
  4651 C444 20 3F C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4652 C447 F0 08			BEQ	LAB_23A8		; if null do function call error then warm start
  4653
  4654 C449 A0 00			LDY	#$00			; set index to first character
  4655 C44B B1 31			LDA	(ut1_pl),Y		; get byte
  4656 C44D A8				TAY				; copy to Y
  4657 C44E 4C 2F C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4658
  4659 				; do function call error then warm start
  4660 C451			LAB_23A8
  4661 C451 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start
  4662
  4663 				; scan and get byte parameter
  4664 C454			LAB_SGBY
  4665 C454 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  4666
  4667 				; get byte parameter
  4668 C457			LAB_GTBY
  4669 C457 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4670 									; else do type mismatch
  4671
  4672 				; evaluate byte expression, result in X
  4673 C45A			LAB_EVBY
  4674 C45A 20 5F BE			JSR	LAB_EVPI		; evaluate integer expression (no check)
  4675
  4676 C45D A4 6E			LDY	FAC1_2			; get FAC1 mantissa2
  4677 C45F D0 F0			BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  4678
  4679 C461 A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  4680 C463 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4681
  4682 				; perform VAL()
  4683 C466			LAB_VAL
  4684 C466 20 3F C4			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4685 C469 D0 03			BNE	LAB_23C5		; branch if not null string
  4686
  4687 									; string was null so set result = $00
  4688 C46B 4C 1B C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  4689
  4690 C46E			LAB_23C5
  4691 C46E A6 83			LDX	Bpntrl			; get BASIC execute pointer low byte
  4692 C470 A4 84			LDY	Bpntrh			; get BASIC execute pointer high byte
  4693 C472 86 7A			STX	Btmpl			; save BASIC execute pointer low byte
  4694 C474 84 7B			STY	Btmph			; save BASIC execute pointer high byte
  4695 C476 A6 31			LDX	ut1_pl			; get string pointer low byte
  4696 C478 86 83			STX	Bpntrl			; save as BASIC execute pointer low byte
  4697 C47A 18				CLC				; clear carry
  4698 C47B 65 31			ADC	ut1_pl			; add string length
  4699 C47D 85 33			STA	ut2_pl			; save string end low byte
  4700 C47F A5 32			LDA	ut1_ph			; get string pointer high byte
  4701 C481 85 84			STA	Bpntrh			; save as BASIC execute pointer high byte
  4702 C483 69 00			ADC	#$00			; add carry to high byte
  4703 C485 85 34			STA	ut2_ph			; save string end high byte
  4704 C487 A0 00			LDY	#$00			; set index to $00
  4705 C489 B1 33			LDA	(ut2_pl),Y		; get string end +1 byte
  4706 C48B 48				PHA				; push it
  4707 C48C 98				TYA				; clear A
  4708 C48D 91 33			STA	(ut2_pl),Y		; terminate string with $00
  4709 C48F 20 82 00			JSR	LAB_GBYT		; scan memory
  4710 C492 20 71 C9			JSR	LAB_2887		; get FAC1 from string
  4711 C495 68				PLA				; restore string end +1 byte
  4712 C496 A0 00			LDY	#$00			; set index to zero
  4713 C498 91 33			STA	(ut2_pl),Y		; put string end byte back
  4714
  4715 				; restore BASIC execute pointer from temp (Btmpl/Btmph)
  4716 C49A			LAB_23F3
  4717 C49A A6 7A			LDX	Btmpl			; get BASIC execute pointer low byte back
  4718 C49C A4 7B			LDY	Btmph			; get BASIC execute pointer high byte back
  4719 C49E 86 83			STX	Bpntrl			; save BASIC execute pointer low byte
  4720 C4A0 84 84			STY	Bpntrh			; save BASIC execute pointer high byte
  4721 C4A2 60				RTS
  4722
  4723 				; get two parameters for POKE or WAIT
  4724 C4A3			LAB_GADB
  4725 C4A3 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4726 									; else do type mismatch
  4727 C4A6 20 BC C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4728
  4729 				; scan for ',' and get byte, else do Syntax error then warm start
  4730 C4A9			LAB_SCGB
  4731 C4A9 20 B9 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4732 C4AC A5 12			LDA	Itemph			; save temporary integer high byte
  4733 C4AE 48				PHA				; on stack
  4734 C4AF A5 11			LDA	Itempl			; save temporary integer low byte
  4735 C4B1 48				PHA				; on stack
  4736 C4B2 20 57 C4			JSR	LAB_GTBY		; get byte parameter
  4737 C4B5 68				PLA				; pull low byte
  4738 C4B6 85 11			STA	Itempl			; restore temporary integer low byte
  4739 C4B8 68				PLA				; pull high byte
  4740 C4B9 85 12			STA	Itemph			; restore temporary integer high byte
  4741 C4BB 60				RTS
  4742
  4743 				; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  4744 				; -ve and converts it into a right truncated integer in Itempl and Itemph
  4745
  4746 				; save unsigned 16 bit integer part of FAC1 in temporary integer
  4747 C4BC			LAB_F2FX
  4748 C4BC A5 6C			LDA	FAC1_e			; get FAC1 exponent
  4749 C4BE C9 98			CMP	#$98			; compare with exponent = 2^24
  4750 C4C0 B0 8F			BCS	LAB_23A8		; if >= do function call error then warm start
  4751
  4752 C4C2			LAB_F2FU
  4753 C4C2 20 1B C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  4754 C4C5 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  4755 C4C7 A4 6F			LDY	FAC1_3			; get FAC1 mantissa3
  4756 C4C9 84 11			STY	Itempl			; save temporary integer low byte
  4757 C4CB 85 12			STA	Itemph			; save temporary integer high byte
  4758 C4CD 60				RTS
  4759
  4760 				; perform PEEK()
  4761 C4CE			LAB_PEEK
  4762 C4CE 20 BC C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4763 C4D1 A2 00			LDX	#$00			; clear index
  4764 C4D3 A1 11			LDA	(Itempl,X)		; get byte via temporary integer (addr)
  4765 C4D5 A8				TAY				; copy byte to Y
  4766 C4D6 4C 2F C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4767
  4768 				; perform POKE
  4769 C4D9			LAB_POKE
  4770 C4D9 20 A3 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  4771 C4DC 8A				TXA				; copy byte argument to A
  4772 C4DD A2 00			LDX	#$00			; clear index
  4773 C4DF 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  4774 C4E1 60				RTS
  4775
  4776 				; perform DEEK()
  4777 C4E2			LAB_DEEK
  4778 C4E2 20 BC C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4779 C4E5 A2 00			LDX	#$00			; clear index
  4780 C4E7 A1 11			LDA	(Itempl,X)		; PEEK low byte
  4781 C4E9 A8				TAY				; copy to Y
  4782 C4EA E6 11			INC	Itempl			; increment pointer low byte
  4783 C4EC D0 02			BNE	Deekh			; skip high increment if no rollover
  4784
  4785 C4EE E6 12			INC	Itemph			; increment pointer high byte
  4786 C4F0			Deekh
  4787 C4F0 A1 11			LDA	(Itempl,X)		; PEEK high byte
  4788 C4F2 4C 16 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  4789
  4790 				; perform DOKE
  4791 C4F5			LAB_DOKE
  4792 C4F5 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4793 									; else do type mismatch
  4794 C4F8 20 BC C4			JSR	LAB_F2FX		; convert floating-to-fixed
  4795
  4796 C4FB 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  4797 C4FD 85 58			STA	Frnxth			; save pointer high byte
  4798
  4799 C4FF 20 B9 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4800 C502 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4801 									; else do type mismatch
  4802 C505 20 BC C4			JSR	LAB_F2FX		; convert floating-to-fixed
  4803
  4804 C508 98				TYA				; copy value low byte (float to fixed returns word in AY)
  4805 C509 A2 00			LDX	#$00			; clear index
  4806 C50B 81 57			STA	(Frnxtl,X)		; POKE low byte
  4807 C50D E6 57			INC	Frnxtl			; increment pointer low byte
  4808 C50F D0 02			BNE	Dokeh			; skip high increment if no rollover
  4809
  4810 C511 E6 58			INC	Frnxth			; increment pointer high byte
  4811 C513			Dokeh
  4812 C513 A5 12			LDA	Itemph			; get value high byte
  4813 C515 81 57			STA	(Frnxtl,X)		; POKE high byte
  4814 C517 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4815
  4816 				; perform SWAP
  4817 C51A			LAB_SWAP
  4818 C51A 20 67 BD			JSR	LAB_GVAR		; get var1 address
  4819 C51D 85 57			STA	Lvarpl			; save var1 address low byte
  4820 C51F 84 58			STY	Lvarph			; save var1 address high byte
  4821 C521 A5 1F			LDA	Dtypef			; get data type flag, $FF=string, $00=numeric
  4822 C523 48				PHA				; save data type flag
  4823
  4824 C524 20 B9 BB			JSR	LAB_1C01		; scan for ',' , else do syntax error then warm start
  4825 C527 20 67 BD			JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
  4826 C52A 68				PLA				; pull var1 data type flag
  4827 C52B 45 1F			EOR	Dtypef			; compare with var2 data type
  4828 C52D D0 10			BNE	SwapErr			; exit if not both the same type  (changed 2022/05/16 by Joerg Walke)
  4829
  4830 C52F A0 03			LDY	#$03			; four bytes to swap (either value or descriptor+1)
  4831 C531			SwapLp
  4832 C531 B1 57			LDA	(Lvarpl),Y		; get byte from var1
  4833 C533 AA				TAX				; save var1 byte
  4834 C534 B1 55			LDA	(Cvaral),Y		; get byte from var2
  4835 C536 91 57			STA	(Lvarpl),Y		; save byte to var1
  4836 C538 8A				TXA				; restore var1 byte
  4837 C539 91 55			STA	(Cvaral),Y		; save byte to var2
  4838 C53B 88				DEY				; decrement index
  4839 C53C 10 F3			BPL	SwapLp			; loop until done
  4840
  4841 C53E 60				RTS
  4842
  4843 C53F			SwapErr
  4844 C53F 4C 97 BA			JMP	LAB_1ABC		; do 'Type mismatch' error then warm start
  4845
  4846 				; perform CALL
  4847 C542			LAB_CALL
  4848 C542 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4849 									; else do type mismatch
  4850 C545 20 BC C4			JSR	LAB_F2FX		; convert floating-to-fixed
  4851 C548 A9 C5			LDA	#>CallExit		; set return address high byte
  4852 C54A 48				PHA				; put on stack
  4853 C54B A9 50			LDA	#<CallExit-1		; set return address low byte
  4854 C54D 48				PHA				; put on stack
  4855 C54E 6C 11 00			JMP	(Itempl)		; do indirect jump to user routine
  4856
  4857 				; if the called routine exits correctly then it will return to here. this will then get
  4858 				; the next byte for the interpreter and return
  4859
  4860 C551			CallExit
  4861 C551 4C 82 00			JMP	LAB_GBYT		; scan memory and return
  4862
  4863 				; perform WAIT
  4864 C554			LAB_WAIT
  4865 C554 20 A3 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  4866 C557 86 57			STX	Frnxtl			; save byte
  4867 C559 A2 00			LDX	#$00			; clear mask
  4868 C55B 20 82 00			JSR	LAB_GBYT		; scan memory
  4869 C55E F0 03			BEQ	LAB_2441		; skip if no third argument
  4870
  4871 C560 20 A9 C4			JSR	LAB_SCGB		; scan for ',' and get byte, else SN error then warm start
  4872 C563			LAB_2441
  4873 C563 86 58			STX	Frnxth			; save EOR argument
  4874 C565			LAB_2445
  4875 C565 B1 11			LDA	(Itempl),Y		; get byte via temporary integer (addr)
  4876 C567 45 58			EOR	Frnxth			; EOR with second argument (mask)
  4877 C569 25 57			AND	Frnxtl			; AND with first argument (byte)
  4878 C56B F0 F8			BEQ	LAB_2445		; loop if result is zero
  4879
  4880 C56D			LAB_244D
  4881 C56D 60				RTS
  4882
  4883 				; perform subtraction, FAC1 from (AY)
  4884 C56E			LAB_2455
  4885 C56E 20 56 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  4886
  4887 				; perform subtraction, FAC1 from FAC2
  4888
  4889 C571			LAB_SUBTRACT
  4890 C571 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  4891 C573 49 FF			EOR	#$FF			; complement it
  4892 C575 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  4893 C577 45 77			EOR	FAC2_s			; EOR with FAC2 sign (b7)
  4894 C579 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  4895 C57B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  4896 C57D 4C 8C C5			JMP	LAB_ADD			; go add FAC2 to FAC1
  4897
  4898 				; perform addition
  4899 C580			LAB_2467
  4900 C580 20 A5 C6			JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  4901 C583 90 4D			BCC	LAB_24A8		;.go subtract mantissas
  4902
  4903 				; add 0.5 to FAC1
  4904 C585			LAB_244E
  4905 C585 A9 AC			LDA	#<LAB_2A96		; set 0.5 pointer low byte
  4906 C587 A0 D3			LDY	#>LAB_2A96		; set 0.5 pointer high byte
  4907
  4908 				; add (AY) to FAC1
  4909 C589			LAB_246C
  4910 C589 20 56 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  4911
  4912 				; add FAC2 to FAC1
  4913 C58C			LAB_ADD
  4914 C58C D0 10			BNE	LAB_2474		; branch if FAC1 was not zero
  4915
  4916 				; copy FAC2 to FAC1
  4917 C58E			LAB_279B
  4918 C58E A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  4919
  4920 				; save FAC1 sign and copy ABS(FAC2) to FAC1
  4921 C590			LAB_279D
  4922 C590 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  4923 C592 A2 04			LDX	#$04			; 4 bytes to copy
  4924 C594			LAB_27A1
  4925 C594 B5 72			LDA	FAC1_o,X		; get byte from FAC2,X
  4926 C596 95 6B			STA	FAC1_e-1,X		; save byte at FAC1,X
  4927 C598 CA				DEX				; decrement count
  4928 C599 D0 F9			BNE	LAB_27A1		; loop if not all done
  4929
  4930 C59B 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  4931 C59D 60				RTS
  4932 									; FAC1 is non zero
  4933 C59E			LAB_2474
  4934 C59E A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  4935 C5A0 86 63			STX	FAC2_r			; save as FAC2 rounding byte
  4936 C5A2 A2 73			LDX	#FAC2_e			; set index to FAC2 exponent addr
  4937 C5A4 A5 73			LDA	FAC2_e			; get FAC2 exponent
  4938 C5A6			LAB_247C
  4939 C5A6 A8				TAY				; copy exponent
  4940 C5A7 F0 C4			BEQ	LAB_244D		; exit if zero
  4941
  4942 C5A9 38				SEC				; set carry for subtract
  4943 C5AA E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  4944 C5AC F0 24			BEQ	LAB_24A8		; branch if = (go add mantissa)
  4945
  4946 C5AE 90 12			BCC	LAB_2498		; branch if <
  4947
  4948 									; FAC2>FAC1
  4949 C5B0 84 6C			STY	FAC1_e			; save FAC1 exponent
  4950 C5B2 A4 77			LDY	FAC2_s			; get FAC2 sign (b7)
  4951 C5B4 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  4952 C5B6 49 FF			EOR	#$FF			; complement A
  4953 C5B8 69 00			ADC	#$00			; +1 (twos complement, carry is set)
  4954 C5BA A0 00			LDY	#$00			; clear Y
  4955 C5BC 84 63			STY	FAC2_r			; clear FAC2 rounding byte
  4956 C5BE A2 6C			LDX	#FAC1_e			; set index to FAC1 exponent addr
  4957 C5C0 D0 04			BNE	LAB_249C		; branch always
  4958
  4959 C5C2			LAB_2498
  4960 C5C2 A0 00			LDY	#$00			; clear Y
  4961 C5C4 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  4962 C5C6			LAB_249C
  4963 C5C6 C9 F9			CMP	#$F9			; compare exponent diff with $F9
  4964 C5C8 30 B6			BMI	LAB_2467		; branch if range $79-$F8
  4965
  4966 C5CA A8				TAY				; copy exponent difference to Y
  4967 C5CB A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  4968 C5CD 56 01			LSR	PLUS_1,X		; shift FAC? mantissa1
  4969 C5CF 20 BC C6			JSR	LAB_2592		; shift FACX Y times right
  4970
  4971 									; exponents are equal now do mantissa subtract
  4972 C5D2			LAB_24A8
  4973 C5D2 24 78			BIT	FAC_sc			; test sign compare (FAC1 EOR FAC2)
  4974 C5D4 10 4C			BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  4975
  4976 C5D6 A0 6C			LDY	#FAC1_e			; set index to FAC1 exponent addr
  4977 C5D8 E0 73			CPX	#FAC2_e			; compare X to FAC2 exponent addr
  4978 C5DA F0 02			BEQ	LAB_24B4		; branch if =
  4979
  4980 C5DC A0 73			LDY	#FAC2_e			; else set index to FAC2 exponent addr
  4981
  4982 									; subtract smaller from bigger (take sign of bigger)
  4983 C5DE			LAB_24B4
  4984 C5DE 38				SEC				; set carry for subtract
  4985 C5DF 49 FF			EOR	#$FF			; ones complement A
  4986 C5E1 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  4987 C5E3 85 79			STA	FAC1_r			; save FAC1 rounding byte
  4988 C5E5 B9 03 00			LDA	PLUS_3,Y		; get FACY mantissa3
  4989 C5E8 F5 03			SBC	PLUS_3,X		; subtract FACX mantissa3
  4990 C5EA 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  4991 C5EC B9 02 00			LDA	PLUS_2,Y		; get FACY mantissa2
  4992 C5EF F5 02			SBC	PLUS_2,X		; subtract FACX mantissa2
  4993 C5F1 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  4994 C5F3 B9 01 00			LDA	PLUS_1,Y		; get FACY mantissa1
  4995 C5F6 F5 01			SBC	PLUS_1,X		; subtract FACX mantissa1
  4996 C5F8 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  4997
  4998 				; do ABS and normalise FAC1
  4999 C5FA			LAB_24D0
  5000 C5FA B0 03			BCS	LAB_24D5		; branch if number is +ve
  5001
  5002 C5FC 20 61 C6			JSR	LAB_2537		; negate FAC1
  5003
  5004 				; normalise FAC1
  5005 C5FF			LAB_24D5
  5006 C5FF A0 00			LDY	#$00			; clear Y
  5007 C601 98				TYA				; clear A
  5008 C602 18				CLC				; clear carry for add
  5009 C603			LAB_24D9
  5010 C603 A6 6D			LDX	FAC1_1			; get FAC1 mantissa1
  5011 C605 D0 3E			BNE	LAB_251B		; if not zero normalise FAC1
  5012
  5013 C607 A6 6E			LDX	FAC1_2			; get FAC1 mantissa2
  5014 C609 86 6D			STX	FAC1_1			; save FAC1 mantissa1
  5015 C60B A6 6F			LDX	FAC1_3			; get FAC1 mantissa3
  5016 C60D 86 6E			STX	FAC1_2			; save FAC1 mantissa2
  5017 C60F A6 79			LDX	FAC1_r			; get FAC1 rounding byte
  5018 C611 86 6F			STX	FAC1_3			; save FAC1 mantissa3
  5019 C613 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5020 C615 69 08			ADC	#$08			; add x to exponent offset
  5021 C617 C9 18			CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5022 C619 D0 E8			BNE	LAB_24D9		; loop if not max
  5023
  5024 				; clear FAC1 exponent and sign
  5025 C61B			LAB_24F1
  5026 C61B A9 00			LDA	#$00			; clear A
  5027 C61D			LAB_24F3
  5028 C61D 85 6C			STA	FAC1_e			; set FAC1 exponent
  5029
  5030 				; save FAC1 sign
  5031 C61F			LAB_24F5
  5032 C61F 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5033 C621 60				RTS
  5034
  5035 				; add FAC2 mantissa to FAC1 mantissa
  5036 C622			LAB_24F8
  5037 C622 65 63			ADC	FAC2_r			; add FAC2 rounding byte
  5038 C624 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5039 C626 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5040 C628 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5041 C62A 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5042 C62C A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5043 C62E 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5044 C630 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5045 C632 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5046 C634 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5047 C636 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5048 C638 B0 1A			BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  5049
  5050 C63A 60				RTS				; else just exit
  5051
  5052 C63B			LAB_2511
  5053 C63B 69 01			ADC	#$01			; add 1 to exponent offset
  5054 C63D 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5055 C63F 26 6F			ROL	FAC1_3			; shift FAC1 mantissa3
  5056 C641 26 6E			ROL	FAC1_2			; shift FAC1 mantissa2
  5057 C643 26 6D			ROL	FAC1_1			; shift FAC1 mantissa1
  5058
  5059 				; normalise FAC1
  5060 C645			LAB_251B
  5061 C645 10 F4			BPL	LAB_2511		; loop if not normalised
  5062
  5063 C647 38				SEC				; set carry for subtract
  5064 C648 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent
  5065 C64A B0 CF			BCS	LAB_24F1		; branch if underflow (set result = $0)
  5066
  5067 C64C 49 FF			EOR	#$FF			; complement exponent
  5068 C64E 69 01			ADC	#$01			; +1 (twos complement)
  5069 C650 85 6C			STA	FAC1_e			; save FAC1 exponent
  5070 					
  5071 				; test and normalise FAC1 for C=0/1
  5072 C652			LAB_2528
  5073 C652 90 0C			BCC	LAB_2536		; exit if no overflow
  5074
  5075 				; normalise FAC1 for C=1
  5076 C654			LAB_252A
  5077 C654 E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5078 C656 F0 36			BEQ	LAB_2564		; if zero do overflow error and warm start
  5079
  5080 C658 66 6D			ROR	FAC1_1			; shift FAC1 mantissa1
  5081 C65A 66 6E			ROR	FAC1_2			; shift FAC1 mantissa2
  5082 C65C 66 6F			ROR	FAC1_3			; shift FAC1 mantissa3
  5083 C65E 66 79			ROR	FAC1_r			; shift FAC1 rounding byte
  5084 C660			LAB_2536
  5085 C660 60				RTS
  5086
  5087 				; negate FAC1
  5088 C661			LAB_2537
  5089 C661 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5090 C663 49 FF			EOR	#$FF			; complement it
  5091 C665 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5092
  5093 				; twos complement FAC1 mantissa
  5094 C667			LAB_253D
  5095 C667 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5096 C669 49 FF			EOR	#$FF			; complement it
  5097 C66B 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5098 C66D A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5099 C66F 49 FF			EOR	#$FF			; complement it
  5100 C671 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5101 C673 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5102 C675 49 FF			EOR	#$FF			; complement it
  5103 C677 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5104 C679 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5105 C67B 49 FF			EOR	#$FF			; complement it
  5106 C67D 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5107 C67F E6 79			INC	FAC1_r			; increment FAC1 rounding byte
  5108 C681 D0 0A			BNE	LAB_2563		; exit if no overflow
  5109
  5110 				; increment FAC1 mantissa
  5111 C683			LAB_2559
  5112 C683 E6 6F			INC	FAC1_3			; increment FAC1 mantissa3
  5113 C685 D0 06			BNE	LAB_2563		; finished if no rollover
  5114
  5115 C687 E6 6E			INC	FAC1_2			; increment FAC1 mantissa2
  5116 C689 D0 02			BNE	LAB_2563		; finished if no rollover
  5117
  5118 C68B E6 6D			INC	FAC1_1			; increment FAC1 mantissa1
  5119 C68D			LAB_2563
  5120 C68D 60				RTS
  5121
  5122 				; do overflow error (overflow exit)
  5123 C68E			LAB_2564
  5124 C68E A2 0A			LDX	#$0A			; error code $0A ('Overflow' error)
  5125 C690 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  5126
  5127 				; shift FCAtemp << A+8 times
  5128 C693			LAB_2569
  5129 C693 A2 34			LDX	#FACt_1-1		; set offset to FACtemp
  5130 C695			LAB_256B
  5131 C695 B4 03			LDY	PLUS_3,X		; get FACX mantissa3
  5132 C697 84 79			STY	FAC1_r			; save as FAC1 rounding byte
  5133 C699 B4 02			LDY	PLUS_2,X		; get FACX mantissa2
  5134 C69B 94 03			STY	PLUS_3,X		; save FACX mantissa3
  5135 C69D B4 01			LDY	PLUS_1,X		; get FACX mantissa1
  5136 C69F 94 02			STY	PLUS_2,X		; save FACX mantissa2
  5137 C6A1 A4 72			LDY	FAC1_o			; get FAC1 overflow byte
  5138 C6A3 94 01			STY	PLUS_1,X		; save FACX mantissa1
  5139
  5140 				; shift FACX -A times right (> 8 shifts)
  5141 C6A5			LAB_257B
  5142 C6A5 69 08			ADC	#$08			; add 8 to shift count
  5143 C6A7 30 EC			BMI	LAB_256B		; go do 8 shift if still -ve
  5144
  5145 C6A9 F0 EA			BEQ	LAB_256B		; go do 8 shift if zero
  5146
  5147 C6AB E9 08			SBC	#$08			; else subtract 8 again
  5148 C6AD A8				TAY				; save count to Y
  5149 C6AE A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5150 C6B0 B0 12			BCS	LAB_259A		;.
  5151
  5152 C6B2			LAB_2588
  5153 C6B2 16 01			ASL	PLUS_1,X		; shift FACX mantissa1
  5154 C6B4 90 02			BCC	LAB_258E		; branch if +ve
  5155
  5156 C6B6 F6 01			INC	PLUS_1,X		; this sets b7 eventually
  5157 C6B8			LAB_258E
  5158 C6B8 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5159 C6BA 76 01			ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5160
  5161 				; shift FACX Y times right
  5162 C6BC			LAB_2592
  5163 C6BC 76 02			ROR	PLUS_2,X		; shift FACX mantissa2
  5164 C6BE 76 03			ROR	PLUS_3,X		; shift FACX mantissa3
  5165 C6C0 6A				ROR				; shift FACX rounding byte
  5166 C6C1 C8				INY				; increment exponent diff
  5167 C6C2 D0 EE			BNE	LAB_2588		; branch if range adjust not complete
  5168
  5169 C6C4			LAB_259A
  5170 C6C4 18				CLC				; just clear it
  5171 C6C5 60				RTS
  5172
  5173 				; perform LOG()
  5174 C6C6			LAB_LOG
  5175 C6C6 20 B4 C8			JSR	LAB_27CA		; test sign and zero
  5176 C6C9 F0 02			BEQ	LAB_25C4		; if zero do function call error then warm start
  5177
  5178 C6CB 10 03			BPL	LAB_25C7		; skip error if +ve
  5179
  5180 C6CD			LAB_25C4
  5181 C6CD 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start (-ve)
  5182
  5183 C6D0			LAB_25C7
  5184 C6D0 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5185 C6D2 E9 7F			SBC	#$7F			; normalise it
  5186 C6D4 48				PHA				; save it
  5187 C6D5 A9 80			LDA	#$80			; set exponent to zero
  5188 C6D7 85 6C			STA	FAC1_e			; save FAC1 exponent
  5189 C6D9 A9 2C			LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5190 C6DB A0 D3			LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5191 C6DD 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5192 C6E0 A9 30			LDA	#<LAB_25B1		; set root2 pointer low byte
  5193 C6E2 A0 D3			LDY	#>LAB_25B1		; set root2 pointer high byte
  5194 C6E4 20 CC C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5195 C6E7 A9 A3			LDA	#<LAB_259C		; set 1 pointer low byte
  5196 C6E9 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  5197 C6EB 20 6E C5			JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5198 C6EE A9 1F			LDA	#<LAB_25A0		; set pointer low byte to counter
  5199 C6F0 A0 D3			LDY	#>LAB_25A0		; set pointer high byte to counter
  5200 C6F2 20 1C CC			JSR	LAB_2B6E		; ^2 then series evaluation
  5201 C6F5 A9 34			LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5202 C6F7 A0 D3			LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5203 C6F9 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1
  5204 C6FC 68				PLA				; restore FAC1 exponent
  5205 C6FD 20 10 CA			JSR	LAB_2912		; evaluate new ASCII digit
  5206 C700 A9 38			LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5207 C702 A0 D3			LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5208
  5209 				; do convert AY, FCA1*(AY)
  5210 C704			LAB_25FB
  5211 C704 20 56 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5212 C707			LAB_MULTIPLY
  5213 C707 F0 4C			BEQ	LAB_264C		; exit if zero
  5214
  5215 C709 20 7C C7			JSR	LAB_2673		; test and adjust accumulators
  5216 C70C A9 00			LDA	#$00			; clear A
  5217 C70E 85 35			STA	FACt_1			; clear temp mantissa1
  5218 C710 85 36			STA	FACt_2			; clear temp mantissa2
  5219 C712 85 37			STA	FACt_3			; clear temp mantissa3
  5220 C714 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  5221 C716 20 2B C7			JSR	LAB_2622		; go do shift/add FAC2
  5222 C719 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5223 C71B 20 2B C7			JSR	LAB_2622		; go do shift/add FAC2
  5224 C71E A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5225 C720 20 2B C7			JSR	LAB_2622		; go do shift/add FAC2
  5226 C723 A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5227 C725 20 30 C7			JSR	LAB_2627		; go do shift/add FAC2
  5228 C728 4C 39 C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5229
  5230 C72B			LAB_2622
  5231 C72B D0 03			BNE	LAB_2627		; branch if byte <> zero
  5232
  5233 C72D 4C 93 C6			JMP	LAB_2569		; shift FCAtemp << A+8 times
  5234
  5235 									; else do shift and add
  5236 C730			LAB_2627
  5237 C730 4A				LSR				; shift byte
  5238 C731 09 80			ORA	#$80			; set top bit (mark for 8 times)
  5239 C733			LAB_262A
  5240 C733 A8				TAY				; copy result
  5241 C734 90 13			BCC	LAB_2640		; skip next if bit was zero
  5242
  5243 C736 18				CLC				; clear carry for add
  5244 C737 A5 37			LDA	FACt_3			; get temp mantissa3
  5245 C739 65 76			ADC	FAC2_3			; add FAC2 mantissa3
  5246 C73B 85 37			STA	FACt_3			; save temp mantissa3
  5247 C73D A5 36			LDA	FACt_2			; get temp mantissa2
  5248 C73F 65 75			ADC	FAC2_2			; add FAC2 mantissa2
  5249 C741 85 36			STA	FACt_2			; save temp mantissa2
  5250 C743 A5 35			LDA	FACt_1			; get temp mantissa1
  5251 C745 65 74			ADC	FAC2_1			; add FAC2 mantissa1
  5252 C747 85 35			STA	FACt_1			; save temp mantissa1
  5253 C749			LAB_2640
  5254 C749 66 35			ROR	FACt_1			; shift temp mantissa1
  5255 C74B 66 36			ROR	FACt_2			; shift temp mantissa2
  5256 C74D 66 37			ROR	FACt_3			; shift temp mantissa3
  5257 C74F 66 79			ROR	FAC1_r			; shift temp rounding byte
  5258 C751 98				TYA				; get byte back
  5259 C752 4A				LSR				; shift byte
  5260 C753 D0 DE			BNE	LAB_262A		; loop if all bits not done
  5261
  5262 C755			LAB_264C
  5263 C755 60				RTS
  5264
  5265 				; unpack memory (AY) into FAC2
  5266 C756			LAB_264D
  5267 C756 85 31			STA	ut1_pl			; save pointer low byte
  5268 C758 84 32			STY	ut1_ph			; save pointer high byte
  5269 C75A A0 03			LDY	#$03			; 4 bytes to get (0-3)
  5270 C75C B1 31			LDA	(ut1_pl),Y		; get mantissa3
  5271 C75E 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5272 C760 88				DEY				; decrement index
  5273 C761 B1 31			LDA	(ut1_pl),Y		; get mantissa2
  5274 C763 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5275 C765 88				DEY				; decrement index
  5276 C766 B1 31			LDA	(ut1_pl),Y		; get mantissa1+sign
  5277 C768 85 77			STA	FAC2_s			; save FAC2 sign (b7)
  5278 C76A 45 70			EOR	FAC1_s			; EOR with FAC1 sign (b7)
  5279 C76C 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5280 C76E A5 77			LDA	FAC2_s			; recover FAC2 sign (b7)
  5281 C770 09 80			ORA	#$80			; set 1xxx xxx (set normal bit)
  5282 C772 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5283 C774 88				DEY				; decrement index
  5284 C775 B1 31			LDA	(ut1_pl),Y		; get exponent byte
  5285 C777 85 73			STA	FAC2_e			; save FAC2 exponent
  5286 C779 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5287 C77B 60				RTS
  5288
  5289 				; test and adjust accumulators
  5290 C77C			LAB_2673
  5291 C77C A5 73			LDA	FAC2_e			; get FAC2 exponent
  5292 C77E			LAB_2675
  5293 C77E F0 1D			BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5294
  5295 C780 18				CLC				; clear carry for add
  5296 C781 65 6C			ADC	FAC1_e			; add FAC1 exponent
  5297 C783 90 04			BCC	LAB_2680		; branch if sum of exponents <$0100
  5298
  5299 C785 30 31			BMI	LAB_269B		; do overflow error
  5300
  5301 C787 18				CLC				; clear carry for the add
  5302 C788 2C				.byte	$2C			; makes next line BIT $1410
  5303 C789			LAB_2680
  5304 C789 10 12			BPL	LAB_2696		; if +ve go handle underflow
  5305
  5306 C78B 69 80			ADC	#$80			; adjust exponent
  5307 C78D 85 6C			STA	FAC1_e			; save FAC1 exponent
  5308 C78F D0 03			BNE	LAB_268B		; branch if not zero
  5309
  5310 C791 4C 1F C6			JMP	LAB_24F5		; save FAC1 sign and return
  5311
  5312 C794			LAB_268B
  5313 C794 A5 78			LDA	FAC_sc			; get sign compare (FAC1 EOR FAC2)
  5314 C796 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5315 C798			LAB_268F
  5316 C798 60				RTS
  5317
  5318 				; handle overflow and underflow
  5319 C799			LAB_2690
  5320 C799 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5321 C79B 10 1B			BPL	LAB_269B		; do overflow error
  5322
  5323 									; handle underflow
  5324 C79D			LAB_2696
  5325 C79D 68				PLA				; pop return address low byte
  5326 C79E 68				PLA				; pop return address high byte
  5327 C79F 4C 1B C6			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5328
  5329 				; multiply by 10
  5330 C7A2			LAB_269E
  5331 C7A2 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5332 C7A5 AA				TAX				; copy exponent (set the flags)
  5333 C7A6 F0 F0			BEQ	LAB_268F		; exit if zero
  5334
  5335 C7A8 18				CLC				; clear carry for add
  5336 C7A9 69 02			ADC	#$02			; add two to exponent (*4)
  5337 C7AB B0 0B			BCS	LAB_269B		; do overflow error if > $FF
  5338
  5339 C7AD A2 00			LDX	#$00			; clear byte
  5340 C7AF 86 78			STX	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  5341 C7B1 20 A6 C5			JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5342 C7B4 E6 6C			INC	FAC1_e			; increment FAC1 exponent (*10)
  5343 C7B6 D0 E0			BNE	LAB_268F		; if non zero just do RTS
  5344
  5345 C7B8			LAB_269B
  5346 C7B8 4C 8E C6			JMP	LAB_2564		; do overflow error and warm start
  5347
  5348 				; divide by 10
  5349 C7BB			LAB_26B9
  5350 C7BB 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5351 C7BE A9 B4			LDA	#<LAB_26B5		; set pointer to 10d low addr
  5352 C7C0 A0 D3			LDY	#>LAB_26B5		; set pointer to 10d high addr
  5353 C7C2 A2 00			LDX	#$00			; clear sign
  5354
  5355 				; divide by (AY) (X=sign)
  5356 C7C4			LAB_26C2
  5357 C7C4 86 78			STX	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5358 C7C6 20 48 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5359 C7C9 4C CF C7			JMP	LAB_DIVIDE		; do FAC2/FAC1
  5360
  5361 									; Perform divide-by
  5362 				; convert AY and do (AY)/FAC1
  5363 C7CC			LAB_26CA
  5364 C7CC 20 56 C7			JSR	LAB_264D		; unpack memory (AY) into FAC2
  5365
  5366 				; Perform divide-into
  5367 C7CF			LAB_DIVIDE
  5368 C7CF F0 63			BEQ	LAB_2737		; if zero go do /0 error
  5369
  5370 C7D1 20 A4 C8			JSR	LAB_27BA		; round FAC1
  5371 C7D4 A9 00			LDA	#$00			; clear A
  5372 C7D6 38				SEC				; set carry for subtract
  5373 C7D7 E5 6C			SBC	FAC1_e			; subtract FAC1 exponent (2s complement)
  5374 C7D9 85 6C			STA	FAC1_e			; save FAC1 exponent
  5375 C7DB 20 7C C7			JSR	LAB_2673		; test and adjust accumulators
  5376 C7DE E6 6C			INC	FAC1_e			; increment FAC1 exponent
  5377 C7E0 F0 D6			BEQ	LAB_269B		; if zero do overflow error
  5378
  5379 C7E2 A2 FF			LDX	#$FF			; set index for pre increment
  5380 C7E4 A9 01			LDA	#$01			; set bit to flag byte save
  5381 C7E6			LAB_26E4
  5382 C7E6 A4 74			LDY	FAC2_1			; get FAC2 mantissa1
  5383 C7E8 C4 6D			CPY	FAC1_1			; compare FAC1 mantissa1
  5384 C7EA D0 0A			BNE	LAB_26F4		; branch if <>
  5385
  5386 C7EC A4 75			LDY	FAC2_2			; get FAC2 mantissa2
  5387 C7EE C4 6E			CPY	FAC1_2			; compare FAC1 mantissa2
  5388 C7F0 D0 04			BNE	LAB_26F4		; branch if <>
  5389
  5390 C7F2 A4 76			LDY	FAC2_3			; get FAC2 mantissa3
  5391 C7F4 C4 6F			CPY	FAC1_3			; compare FAC1 mantissa3
  5392 C7F6			LAB_26F4
  5393 C7F6 08				PHP				; save FAC2-FAC1 compare status
  5394 C7F7 2A				ROL				; shift the result byte
  5395 C7F8 90 0E			BCC	LAB_2702		; if no carry skip the byte save
  5396
  5397 C7FA A0 01			LDY	#$01			; set bit to flag byte save
  5398 C7FC E8				INX				; else increment the index to FACt
  5399 C7FD E0 02			CPX	#$02			; compare with the index to FACt_3
  5400 C7FF 30 04			BMI	LAB_2701		; if not last byte just go save it
  5401
  5402 C801 D0 28			BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5403 									; return
  5404
  5405 C803 A0 40			LDY	#$40			; set bit to flag byte save for the rounding byte
  5406 C805			LAB_2701
  5407 C805 95 35			STA	FACt_1,X		; write result byte to FACt_1 + index
  5408 C807 98				TYA				; copy the next save byte flag
  5409 C808			LAB_2702
  5410 C808 28				PLP				; restore FAC2-FAC1 compare status
  5411 C809 90 14			BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5412
  5413 C80B A8				TAY				; save FAC2-FAC1 compare status
  5414 C80C A5 76			LDA	FAC2_3			; get FAC2 mantissa3
  5415 C80E E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5416 C810 85 76			STA	FAC2_3			; save FAC2 mantissa3
  5417 C812 A5 75			LDA	FAC2_2			; get FAC2 mantissa2
  5418 C814 E5 6E			SBC	FAC1_2			; subtract FAC1 mantissa2
  5419 C816 85 75			STA	FAC2_2			; save FAC2 mantissa2
  5420 C818 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  5421 C81A E5 6D			SBC	FAC1_1			; subtract FAC1 mantissa1
  5422 C81C 85 74			STA	FAC2_1			; save FAC2 mantissa1
  5423 C81E 98				TYA				; restore FAC2-FAC1 compare status
  5424
  5425 									; FAC2 = FAC2*2
  5426 C81F			LAB_2704
  5427 C81F 06 76			ASL	FAC2_3			; shift FAC2 mantissa3
  5428 C821 26 75			ROL	FAC2_2			; shift FAC2 mantissa2
  5429 C823 26 74			ROL	FAC2_1			; shift FAC2 mantissa1
  5430 C825 B0 CF			BCS	LAB_26F4		; loop with no compare
  5431
  5432 C827 30 BD			BMI	LAB_26E4		; loop with compare
  5433
  5434 C829 10 CB			BPL	LAB_26F4		; loop always with no compare
  5435
  5436 				; do A<<6, save as FAC1 rounding byte, normalise and return
  5437 C82B			LAB_272B
  5438 C82B 4A				LSR				; shift b1 - b0 ..
  5439 C82C 6A				ROR				; ..
  5440 C82D 6A				ROR				; .. to b7 - b6
  5441 C82E 85 79			STA	FAC1_r			; save FAC1 rounding byte
  5442 C830 28				PLP				; dump FAC2-FAC1 compare status
  5443 C831 4C 39 C8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5444
  5445 				; do 'Divide by zero' error
  5446 C834			LAB_2737
  5447 C834 A2 14			LDX	#$14			; error code $14 ('Divide by zero' error)
  5448 C836 4C 07 B1			JMP	LAB_XERR		; do error #X, then warm start
  5449
  5450 				; copy temp to FAC1 and normalise
  5451 C839			LAB_273C
  5452 C839 A5 35			LDA	FACt_1			; get temp mantissa1
  5453 C83B 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5454 C83D A5 36			LDA	FACt_2			; get temp mantissa2
  5455 C83F 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5456 C841 A5 37			LDA	FACt_3			; get temp mantissa3
  5457 C843 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5458 C845 4C FF C5			JMP	LAB_24D5		; normalise FAC1 and return
  5459
  5460 				; unpack memory (AY) into FAC1
  5461 C848			LAB_UFAC
  5462 C848 85 31			STA	ut1_pl			; save pointer low byte
  5463 C84A 84 32			STY	ut1_ph			; save pointer high byte
  5464 C84C A0 03			LDY	#$03			; 4 bytes to do
  5465 C84E B1 31			LDA	(ut1_pl),Y		; get last byte
  5466 C850 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  5467 C852 88				DEY				; decrement index
  5468 C853 B1 31			LDA	(ut1_pl),Y		; get last-1 byte
  5469 C855 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  5470 C857 88				DEY				; decrement index
  5471 C858 B1 31			LDA	(ut1_pl),Y		; get second byte
  5472 C85A 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  5473 C85C 09 80			ORA	#$80			; set 1xxx xxxx (add normal bit)
  5474 C85E 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5475 C860 88				DEY				; decrement index
  5476 C861 B1 31			LDA	(ut1_pl),Y		; get first byte (exponent)
  5477 C863 85 6C			STA	FAC1_e			; save FAC1 exponent
  5478 C865 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5479 C867 60				RTS
  5480
  5481 				; pack FAC1 into Adatal
  5482 C868			LAB_276E
  5483 C868 A2 64			LDX	#<Adatal		; set pointer low byte
  5484 C86A			LAB_2770
  5485 C86A A0 00			LDY	#>Adatal		; set pointer high byte
  5486 C86C F0 04			BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5487
  5488 				; pack FAC1 into (Lvarpl)
  5489 C86E			LAB_PFAC
  5490 C86E A6 57			LDX	Lvarpl			; get destination pointer low byte
  5491 C870 A4 58			LDY	Lvarph			; get destination pointer high byte
  5492
  5493 				; pack FAC1 into (XY)
  5494 C872			LAB_2778
  5495 C872 20 A4 C8			JSR	LAB_27BA		; round FAC1
  5496 C875 86 31			STX	ut1_pl			; save pointer low byte
  5497 C877 84 32			STY	ut1_ph			; save pointer high byte
  5498 C879 A0 03			LDY	#$03			; set index
  5499 C87B A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5500 C87D 91 31			STA	(ut1_pl),Y		; store in destination
  5501 C87F 88				DEY				; decrement index
  5502 C880 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  5503 C882 91 31			STA	(ut1_pl),Y		; store in destination
  5504 C884 88				DEY				; decrement index
  5505 C885 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5506 C887 09 7F			ORA	#$7F			; set bits x111 1111
  5507 C889 25 6D			AND	FAC1_1			; AND in FAC1 mantissa1
  5508 C88B 91 31			STA	(ut1_pl),Y		; store in destination
  5509 C88D 88				DEY				; decrement index
  5510 C88E A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5511 C890 91 31			STA	(ut1_pl),Y		; store in destination
  5512 C892 84 79			STY	FAC1_r			; clear FAC1 rounding byte
  5513 C894 60				RTS
  5514
  5515 				; round and copy FAC1 to FAC2
  5516 C895			LAB_27AB
  5517 C895 20 A4 C8			JSR	LAB_27BA		; round FAC1
  5518
  5519 				; copy FAC1 to FAC2
  5520 C898			LAB_27AE
  5521 C898 A2 05			LDX	#$05			; 5 bytes to copy
  5522 C89A			LAB_27B0
  5523 C89A B5 6B			LDA	FAC1_e-1,X		; get byte from FAC1,X
  5524 C89C 95 72			STA	FAC1_o,X		; save byte at FAC2,X
  5525 C89E CA				DEX				; decrement count
  5526 C89F D0 F9			BNE	LAB_27B0		; loop if not all done
  5527
  5528 C8A1 86 79			STX	FAC1_r			; clear FAC1 rounding byte
  5529 C8A3			LAB_27B9
  5530 C8A3 60				RTS
  5531
  5532 				; round FAC1
  5533 C8A4			LAB_27BA
  5534 C8A4 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5535 C8A6 F0 FB			BEQ	LAB_27B9		; exit if zero
  5536
  5537 C8A8 06 79			ASL	FAC1_r			; shift FAC1 rounding byte
  5538 C8AA 90 F7			BCC	LAB_27B9		; exit if no overflow
  5539
  5540 				; round FAC1 (no check)
  5541 C8AC			LAB_27C2
  5542 C8AC 20 83 C6			JSR	LAB_2559		; increment FAC1 mantissa
  5543 C8AF D0 F2			BNE	LAB_27B9		; branch if no overflow
  5544
  5545 C8B1 4C 54 C6			JMP	LAB_252A		; normalise FAC1 for C=1 and return
  5546
  5547 				; get FAC1 sign
  5548 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5549 C8B4			LAB_27CA
  5550 C8B4 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5551 C8B6 F0 09			BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  5552
  5553 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5554 				; no = 0 check
  5555 C8B8			LAB_27CE
  5556 C8B8 A5 70			LDA	FAC1_s			; else get FAC1 sign (b7)
  5557
  5558 				; return A=FF,C=1/-ve A=01,C=0/+ve
  5559 				; no = 0 check, sign in A
  5560 C8BA			LAB_27D0
  5561 C8BA 2A				ROL				; move sign bit to carry
  5562 C8BB A9 FF			LDA	#$FF			; set byte for -ve result
  5563 C8BD B0 02			BCS	LAB_27D7		; return if sign was set (-ve)
  5564
  5565 C8BF A9 01			LDA	#$01			; else set byte for +ve result
  5566 C8C1			LAB_27D7
  5567 C8C1 60				RTS
  5568
  5569 				; perform SGN()
  5570 C8C2			LAB_SGN
  5571 C8C2 20 B4 C8			JSR	LAB_27CA		; get FAC1 sign
  5572 									; return A=$FF/-ve A=$01/+ve
  5573 				; save A as integer byte
  5574 C8C5			LAB_27DB
  5575 C8C5 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5576 C8C7 A9 00			LDA	#$00			; clear A
  5577 C8C9 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5578 C8CB A2 88			LDX	#$88			; set exponent
  5579
  5580 				; set exp=X, clearFAC1 mantissa3 and normalise
  5581 C8CD			LAB_27E3
  5582 C8CD A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  5583 C8CF 49 FF			EOR	#$FF			; complement it
  5584 C8D1 2A				ROL				; sign bit into carry
  5585
  5586 				; set exp=X, clearFAC1 mantissa3 and normalise
  5587 C8D2			LAB_STFA
  5588 C8D2 A9 00			LDA	#$00			; clear A
  5589 C8D4 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5590 C8D6 86 6C			STX	FAC1_e			; set FAC1 exponent
  5591 C8D8 85 79			STA	FAC1_r			; clear FAC1 rounding byte
  5592 C8DA 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  5593 C8DC 4C FA C5			JMP	LAB_24D0		; do ABS and normalise FAC1
  5594
  5595 				; perform ABS()
  5596 C8DF			LAB_ABS
  5597 C8DF 46 70			LSR	FAC1_s			; clear FAC1 sign (put zero in b7)
  5598 C8E1 60				RTS
  5599
  5600 				; compare FAC1 with (AY)
  5601 				; returns A=$00 if FAC1 = (AY)
  5602 				; returns A=$01 if FAC1 > (AY)
  5603 				; returns A=$FF if FAC1 < (AY)
  5604 C8E2			LAB_27F8
  5605 C8E2 85 33			STA	ut2_pl			; save pointer low byte
  5606 C8E4			LAB_27FA
  5607 C8E4 84 34			STY	ut2_ph			; save pointer high byte
  5608 C8E6 A0 00			LDY	#$00			; clear index
  5609 C8E8 B1 33			LDA	(ut2_pl),Y		; get exponent
  5610 C8EA C8				INY				; increment index
  5611 C8EB AA				TAX				; copy (AY) exponent to X
  5612 C8EC F0 C6			BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  5613 									; A=FF,C=1/-ve A=01,C=0/+ve
  5614
  5615 C8EE B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5616 C8F0 45 70			EOR	FAC1_s			; EOR FAC1 sign (b7)
  5617 C8F2 30 C4			BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  5618 									; A=01,C=0/+ve and return
  5619
  5620 C8F4 E4 6C			CPX	FAC1_e			; compare (AY) exponent with FAC1 exponent
  5621 C8F6 D0 1A			BNE	LAB_2828		; branch if different
  5622
  5623 C8F8 B1 33			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  5624 C8FA 09 80			ORA	#$80			; normalise top bit
  5625 C8FC C5 6D			CMP	FAC1_1			; compare with FAC1 mantissa1
  5626 C8FE D0 12			BNE	LAB_2828		; branch if different
  5627
  5628 C900 C8				INY				; increment index
  5629 C901 B1 33			LDA	(ut2_pl),Y		; get mantissa2
  5630 C903 C5 6E			CMP	FAC1_2			; compare with FAC1 mantissa2
  5631 C905 D0 0B			BNE	LAB_2828		; branch if different
  5632
  5633 C907 C8				INY				; increment index
  5634 C908 A9 7F			LDA	#$7F			; set for 1/2 value rounding byte
  5635 C90A C5 79			CMP	FAC1_r			; compare with FAC1 rounding byte (set carry)
  5636 C90C B1 33			LDA	(ut2_pl),Y		; get mantissa3
  5637 C90E E5 6F			SBC	FAC1_3			; subtract FAC1 mantissa3
  5638 C910 F0 28			BEQ	LAB_2850		; exit if mantissa3 equal
  5639
  5640 				; gets here if number <> FAC1
  5641 C912			LAB_2828
  5642 C912 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5643 C914 90 02			BCC	LAB_282E		; branch if FAC1 > (AY)
  5644
  5645 C916 49 FF			EOR	#$FF			; else toggle FAC1 sign
  5646 C918			LAB_282E
  5647 C918 4C BA C8			JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  5648
  5649 				; convert FAC1 floating-to-fixed
  5650 C91B			LAB_2831
  5651 C91B A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5652 C91D F0 4A			BEQ	LAB_287F		; if zero go clear FAC1 and return
  5653
  5654 C91F 38				SEC				; set carry for subtract
  5655 C920 E9 98			SBC	#$98			; subtract maximum integer range exponent
  5656 C922 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  5657 C924 10 09			BPL	LAB_2845		; branch if FAC1 +ve
  5658
  5659 									; FAC1 was -ve
  5660 C926 AA				TAX				; copy subtracted exponent
  5661 C927 A9 FF			LDA	#$FF			; overflow for -ve number
  5662 C929 85 72			STA	FAC1_o			; set FAC1 overflow byte
  5663 C92B 20 67 C6			JSR	LAB_253D		; twos complement FAC1 mantissa
  5664 C92E 8A				TXA				; restore subtracted exponent
  5665 C92F			LAB_2845
  5666 C92F A2 6C			LDX	#FAC1_e			; set index to FAC1
  5667 C931 C9 F9			CMP	#$F9			; compare exponent result
  5668 C933 10 06			BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  5669
  5670 C935 20 A5 C6			JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  5671 C938 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5672 C93A			LAB_2850
  5673 C93A 60				RTS
  5674
  5675 				; shift FAC1 A times right
  5676 C93B			LAB_2851
  5677 C93B A8				TAY				; copy shift count
  5678 C93C A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5679 C93E 29 80			AND	#$80			; mask sign bit only (x000 0000)
  5680 C940 46 6D			LSR	FAC1_1			; shift FAC1 mantissa1
  5681 C942 05 6D			ORA	FAC1_1			; OR sign in b7 FAC1 mantissa1
  5682 C944 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  5683 C946 20 BC C6			JSR	LAB_2592		; shift FAC1 Y times right
  5684 C949 84 72			STY	FAC1_o			; clear FAC1 overflow byte
  5685 C94B 60				RTS
  5686
  5687 				; perform INT()
  5688 C94C			LAB_INT
  5689 C94C A5 6C			LDA	FAC1_e			; get FAC1 exponent
  5690 C94E C9 98			CMP	#$98			; compare with max int
  5691 C950 B0 1E			BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  5692
  5693 C952 20 1B C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5694 C955 84 79			STY	FAC1_r			; save FAC1 rounding byte
  5695 C957 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  5696 C959 84 70			STY	FAC1_s			; save FAC1 sign (b7)
  5697 C95B 49 80			EOR	#$80			; toggle FAC1 sign
  5698 C95D 2A				ROL				; shift into carry
  5699 C95E A9 98			LDA	#$98			; set new exponent
  5700 C960 85 6C			STA	FAC1_e			; save FAC1 exponent
  5701 C962 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  5702 C964 85 1B			STA	Temp3			; save for EXP() function
  5703 C966 4C FA C5			JMP	LAB_24D0		; do ABS and normalise FAC1
  5704
  5705 				; clear FAC1 and return
  5706 C969			LAB_287F
  5707 C969 85 6D			STA	FAC1_1			; clear FAC1 mantissa1
  5708 C96B 85 6E			STA	FAC1_2			; clear FAC1 mantissa2
  5709 C96D 85 6F			STA	FAC1_3			; clear FAC1 mantissa3
  5710 C96F A8				TAY				; clear Y
  5711 C970			LAB_2886
  5712 C970 60				RTS
  5713
  5714 				; get FAC1 from string
  5715 				; this routine now handles hex and binary values from strings
  5716 				; starting with '$' and '%' respectively
  5717 C971			LAB_2887
  5718 C971 A0 00			LDY	#$00			; clear Y
  5719 C973 84 1F			STY	Dtypef			; clear data type flag, $FF=string, $00=numeric
  5720 C975 A2 09			LDX	#$09			; set index
  5721 C977			LAB_288B
  5722 C977 94 68			STY	numexp,X		; clear byte
  5723 C979 CA				DEX				; decrement index
  5724 C97A 10 FB			BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
  5725
  5726 C97C 90 7F			BCC	LAB_28FE		; branch if 1st character numeric
  5727
  5728 				; get FAC1 from string .. first character wasn't numeric
  5729 C97E C9 2D			CMP	#'-'			; else compare with '-'
  5730 C980 D0 04			BNE	LAB_289A		; branch if not '-'
  5731
  5732 C982 86 71			STX	negnum			; set flag for -ve number (X = $FF)
  5733 C984 F0 04			BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  5734
  5735 				; get FAC1 from string .. first character wasn't numeric or -
  5736 C986			LAB_289A
  5737 C986 C9 2B			CMP	#'+'			; else compare with '+'
  5738 C988 D0 05			BNE	LAB_289D		; branch if not '+' (go check for hex/bin)
  5739
  5740 				; was '+' or '-' to start, so get next character
  5741 C98A			LAB_289C
  5742 C98A 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  5743 C98D 90 6E			BCC	LAB_28FE		; branch if numeric character
  5744
  5745 				; code here for hex and binary numbers
  5746 C98F			LAB_289D
  5747 C98F C9 24			CMP	#'$'			; else compare with '$'
  5748 C991 D0 03			BNE	LAB_NHEX		; branch if not '$'
  5749
  5750 C993 4C 42 CE			JMP	LAB_CHEX		; branch if '$'
  5751
  5752 C996			LAB_NHEX
  5753 C996 C9 25			CMP	#'%'			; else compare with '%'
  5754 C998 D0 08			BNE	LAB_28A3		; branch if not '%' (continue original code)
  5755
  5756 C99A 4C 70 CE			JMP	LAB_CBIN		; branch if '%'
  5757
  5758 C99D			LAB_289E
  5759 C99D 20 7C 00			JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  5760 C9A0			LAB_28A1
  5761 C9A0 90 5B			BCC	LAB_28FE		; branch if numeric character
  5762
  5763 				; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  5764 C9A2			LAB_28A3
  5765 C9A2 C9 2E			CMP	#'.'			; else compare with '.'
  5766 C9A4 F0 2E			BEQ	LAB_28D5		; branch if '.'
  5767
  5768 				; get FAC1 from string .. character wasn't numeric, -, + or .
  5769 C9A6 C9 45			CMP	#'E'			; else compare with 'E'
  5770 C9A8 D0 30			BNE	LAB_28DB		; branch if not 'E'
  5771
  5772 									; was 'E' so evaluate exponential part
  5773 C9AA 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  5774 C9AD 90 17			BCC	LAB_28C7		; branch if numeric character
  5775
  5776 C9AF C9 CC			CMP	#TK_MINUS		; else compare with token for -
  5777 C9B1 F0 0E			BEQ	LAB_28C2		; branch if token for -
  5778
  5779 C9B3 C9 2D			CMP	#'-'			; else compare with '-'
  5780 C9B5 F0 0A			BEQ	LAB_28C2		; branch if '-'
  5781
  5782 C9B7 C9 CB			CMP	#TK_PLUS		; else compare with token for +
  5783 C9B9 F0 08			BEQ	LAB_28C4		; branch if token for +
  5784
  5785 C9BB C9 2B			CMP	#'+'			; else compare with '+'
  5786 C9BD F0 04			BEQ	LAB_28C4		; branch if '+'
  5787
  5788 C9BF D0 07			BNE	LAB_28C9		; branch always
  5789
  5790 C9C1			LAB_28C2
  5791 C9C1 66 6B			ROR	expneg			; set exponent -ve flag (C, which=1, into b7)
  5792 C9C3			LAB_28C4
  5793 C9C3 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  5794 C9C6			LAB_28C7
  5795 C9C6 90 5B			BCC	LAB_2925		; branch if numeric character
  5796
  5797 C9C8			LAB_28C9
  5798 C9C8 24 6B			BIT	expneg			; test exponent -ve flag
  5799 C9CA 10 0E			BPL	LAB_28DB		; if +ve go evaluate exponent
  5800
  5801 									; else do exponent = -exponent 
  5802 C9CC A9 00			LDA	#$00			; clear result
  5803 C9CE 38				SEC				; set carry for subtract
  5804 C9CF E5 69			SBC	expcnt			; subtract exponent byte
  5805 C9D1 4C DC C9			JMP	LAB_28DD		; go evaluate exponent
  5806
  5807 C9D4			LAB_28D5
  5808 C9D4 66 6A			ROR	numdpf			; set decimal point flag
  5809 C9D6 24 6A			BIT	numdpf			; test decimal point flag
  5810 C9D8 50 C3			BVC	LAB_289E		; branch if only one decimal point so far
  5811
  5812 									; evaluate exponent
  5813 C9DA			LAB_28DB
  5814 C9DA A5 69			LDA	expcnt			; get exponent count byte
  5815 C9DC			LAB_28DD
  5816 C9DC 38				SEC				; set carry for subtract
  5817 C9DD E5 68			SBC	numexp			; subtract numerator exponent
  5818 C9DF 85 69			STA	expcnt			; save exponent count byte
  5819 C9E1 F0 12			BEQ	LAB_28F6		; branch if no adjustment
  5820
  5821 C9E3 10 09			BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
  5822
  5823 									; else go do FAC1/10^(0-expcnt)
  5824 C9E5			LAB_28E6
  5825 C9E5 20 BB C7			JSR	LAB_26B9		; divide by 10
  5826 C9E8 E6 69			INC	expcnt			; increment exponent count byte
  5827 C9EA D0 F9			BNE	LAB_28E6		; loop until all done
  5828
  5829 C9EC F0 07			BEQ	LAB_28F6		; branch always
  5830
  5831 C9EE			LAB_28EF
  5832 C9EE 20 A2 C7			JSR	LAB_269E		; multiply by 10
  5833 C9F1 C6 69			DEC	expcnt			; decrement exponent count byte
  5834 C9F3 D0 F9			BNE	LAB_28EF		; loop until all done
  5835
  5836 C9F5			LAB_28F6
  5837 C9F5 A5 71			LDA	negnum			; get -ve flag
  5838 C9F7 30 01			BMI	LAB_28FB		; if -ve do - FAC1 and return
  5839
  5840 C9F9 60				RTS
  5841
  5842 				; do - FAC1 and return
  5843 C9FA			LAB_28FB
  5844 C9FA 4C BF CB			JMP	LAB_GTHAN		; do - FAC1 and return
  5845
  5846 				; do unsigned FAC1*10+number
  5847 C9FD			LAB_28FE
  5848 C9FD 48				PHA				; save character
  5849 C9FE 24 6A			BIT	numdpf			; test decimal point flag
  5850 CA00 10 02			BPL	LAB_2905		; skip exponent increment if not set
  5851
  5852 CA02 E6 68			INC	numexp			; else increment number exponent
  5853 CA04			LAB_2905
  5854 CA04 20 A2 C7			JSR	LAB_269E		; multiply FAC1 by 10
  5855 CA07 68				PLA				; restore character
  5856 CA08 29 0F			AND	#$0F			; convert to binary
  5857 CA0A 20 10 CA			JSR	LAB_2912		; evaluate new ASCII digit
  5858 CA0D 4C 9D C9			JMP	LAB_289E		; go do next character
  5859
  5860 				; evaluate new ASCII digit
  5861 CA10			LAB_2912
  5862 CA10 48				PHA				; save digit
  5863 CA11 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5864 CA14 68				PLA				; restore digit
  5865 CA15 20 C5 C8			JSR	LAB_27DB		; save A as integer byte
  5866 CA18 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  5867 CA1A 45 70			EOR	FAC1_s			; toggle with FAC1 sign (b7)
  5868 CA1C 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  5869 CA1E A6 6C			LDX	FAC1_e			; get FAC1 exponent
  5870 CA20 4C 8C C5			JMP	LAB_ADD			; add FAC2 to FAC1 and return
  5871
  5872 				; evaluate next character of exponential part of number
  5873 CA23			LAB_2925
  5874 CA23 A5 69			LDA	expcnt			; get exponent count byte
  5875 CA25 C9 0A			CMP	#$0A			; compare with 10 decimal
  5876 CA27 90 09			BCC	LAB_2934		; branch if less
  5877
  5878 CA29 A9 64			LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  5879 CA2B 24 6B			BIT	expneg			; test exponent -ve flag
  5880 CA2D 30 0E			BMI	LAB_2942		; branch if -ve
  5881
  5882 CA2F 4C 8E C6			JMP	LAB_2564		; else do overflow error
  5883
  5884 CA32			LAB_2934
  5885 CA32 0A				ASL				; * 2
  5886 CA33 0A				ASL				; * 4
  5887 CA34 65 69			ADC	expcnt			; * 5
  5888 CA36 0A				ASL				; * 10
  5889 CA37 A0 00			LDY	#$00			; set index
  5890 CA39 71 83			ADC	(Bpntrl),Y		; add character (will be $30 too much!)
  5891 CA3B E9 2F			SBC	#'0'-1			; convert character to binary
  5892 CA3D			LAB_2942
  5893 CA3D 85 69			STA	expcnt			; save exponent count byte
  5894 CA3F 4C C3 C9			JMP	LAB_28C4		; go get next character
  5895
  5896 				; print ' in line [LINE #]'
  5897 CA42			LAB_2953
  5898 CA42 A9 D0			LDA	#<LAB_LMSG		; point to ' in line ' message low byte
  5899 CA44 A0 DA			LDY	#>LAB_LMSG		; point to ' in line ' message high byte
  5900 CA46 20 8F B8			JSR	LAB_18C3		; print null terminated string from memory
  5901
  5902 									; print Basic line #
  5903 CA49 A5 48			LDA	Clineh			; get current line high byte
  5904 CA4B A6 47			LDX	Clinel			; get current line low byte
  5905
  5906 				; print XA as unsigned integer
  5907 CA4D			LAB_295E
  5908 CA4D 85 6D			STA	FAC1_1			; save low byte as FAC1 mantissa1
  5909 CA4F 86 6E			STX	FAC1_2			; save high byte as FAC1 mantissa2
  5910 CA51 A2 90			LDX	#$90			; set exponent to 16d bits
  5911 CA53 38				SEC				; set integer is +ve flag
  5912 CA54 20 D2 C8			JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  5913 CA57 A0 00			LDY	#$00			; clear index
  5914 CA59 98				TYA				; clear A
  5915 CA5A 20 6D CA			JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  5916 CA5D 4C 8F B8			JMP	LAB_18C3		; print null terminated string from memory and return
  5917
  5918 				; convert FAC1 to ASCII string result in (AY)
  5919 				; not any more, moved scratchpad to page 0
  5920 CA60			LAB_296E
  5921 CA60 A0 01			LDY	#$01			; set index = 1
  5922 CA62 A9 20			LDA	#$20			; character = ' ' (assume +ve)
  5923 CA64 24 70			BIT	FAC1_s			; test FAC1 sign (b7)
  5924 CA66 10 02			BPL	LAB_2978		; branch if +ve
  5925
  5926 CA68 A9 2D			LDA	#$2D			; else character = '-'
  5927 CA6A			LAB_2978
  5928 CA6A 99 04 00			STA	Decss,Y			; save leading character (' ' or '-')
  5929 CA6D			LAB_297B
  5930 CA6D 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  5931 CA6F 84 7A			STY	Sendl			; save index
  5932 CA71 C8				INY				; increment index
  5933 CA72 A6 6C			LDX	FAC1_e			; get FAC1 exponent
  5934 CA74 D0 05			BNE	LAB_2989		; branch if FAC1<>0
  5935
  5936 									; exponent was $00 so FAC1 is 0
  5937 CA76 A9 30			LDA	#'0'			; set character = '0'
  5938 CA78 4C 79 CB			JMP	LAB_2A89		; save last character, [EOT] and exit
  5939
  5940 									; FAC1 is some non zero value
  5941 CA7B			LAB_2989
  5942 CA7B A9 00			LDA	#$00			; clear (number exponent count)
  5943 CA7D E0 81			CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  5944
  5945 CA7F B0 09			BCS	LAB_299A		; branch if FAC1=>1
  5946
  5947 									; FAC1<1
  5948 CA81 A9 44			LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  5949 CA83 A0 D3			LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  5950 CA85 20 04 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  5951 CA88 A9 FA			LDA	#$FA			; set number exponent count (-6)
  5952 CA8A			LAB_299A
  5953 CA8A 85 68			STA	numexp			; save number exponent count
  5954 CA8C			LAB_299C
  5955 CA8C A9 40			LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  5956 CA8E A0 D3			LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  5957 CA90 20 E2 C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  5958 CA93 F0 1E			BEQ	LAB_29C3		; exit if FAC1 = (AY)
  5959
  5960 CA95 10 12			BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  5961
  5962 									; FAC1 < (AY)
  5963 CA97			LAB_29A7
  5964 CA97 A9 3C			LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  5965 CA99 A0 D3			LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  5966 CA9B 20 E2 C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  5967 CA9E F0 02			BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  5968
  5969 CAA0 10 0E			BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  5970
  5971 									; FAC1 <= (AY)
  5972 CAA2			LAB_29B2
  5973 CAA2 20 A2 C7			JSR	LAB_269E		; multiply by 10
  5974 CAA5 C6 68			DEC	numexp			; decrement number exponent count
  5975 CAA7 D0 EE			BNE	LAB_29A7		; go test again (branch always)
  5976
  5977 CAA9			LAB_29B9
  5978 CAA9 20 BB C7			JSR	LAB_26B9		; divide by 10
  5979 CAAC E6 68			INC	numexp			; increment number exponent count
  5980 CAAE D0 DC			BNE	LAB_299C		; go test again (branch always)
  5981
  5982 				; now we have just the digits to do
  5983 CAB0			LAB_29C0
  5984 CAB0 20 85 C5			JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  5985 CAB3			LAB_29C3
  5986 CAB3 20 1B C9			JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5987 CAB6 A2 01			LDX	#$01			; set default digits before dp = 1
  5988 CAB8 A5 68			LDA	numexp			; get number exponent count
  5989 CABA 18				CLC				; clear carry for add
  5990 CABB 69 07			ADC	#$07			; up to 6 digits before point
  5991 CABD 30 09			BMI	LAB_29D8		; if -ve then 1 digit before dp
  5992
  5993 CABF C9 08			CMP	#$08			; A>=8 if n>=1E6
  5994 CAC1 B0 06			BCS	LAB_29D9		; branch if >= $08
  5995
  5996 									; carry is clear
  5997 CAC3 69 FF			ADC	#$FF			; take 1 from digit count
  5998 CAC5 AA				TAX				; copy to A
  5999 CAC6 A9 02			LDA	#$02			;.set exponent adjust
  6000 CAC8			LAB_29D8
  6001 CAC8 38				SEC				; set carry for subtract
  6002 CAC9			LAB_29D9
  6003 CAC9 E9 02			SBC	#$02			; -2
  6004 CACB 85 69			STA	expcnt			;.save exponent adjust
  6005 CACD 86 68			STX	numexp			; save digits before dp count
  6006 CACF 8A				TXA				; copy to A
  6007 CAD0 F0 02			BEQ	LAB_29E4		; branch if no digits before dp
  6008
  6009 CAD2 10 13			BPL	LAB_29F7		; branch if digits before dp
  6010
  6011 CAD4			LAB_29E4
  6012 CAD4 A4 7A			LDY	Sendl			; get output string index
  6013 CAD6 A9 2E			LDA	#$2E			; character '.'
  6014 CAD8 C8				INY				; increment index
  6015 CAD9 99 04 00			STA	Decss,Y			; save to output string
  6016 CADC 8A				TXA				;.
  6017 CADD F0 06			BEQ	LAB_29F5		;.
  6018
  6019 CADF A9 30			LDA	#'0'			; character '0'
  6020 CAE1 C8				INY				; increment index
  6021 CAE2 99 04 00			STA	Decss,Y			; save to output string
  6022 CAE5			LAB_29F5
  6023 CAE5 84 7A			STY	Sendl			; save output string index
  6024 CAE7			LAB_29F7
  6025 CAE7 A0 00			LDY	#$00			; clear index (point to 100,000)
  6026 CAE9 A2 80			LDX	#$80			; 
  6027 CAEB			LAB_29FB
  6028 CAEB A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  6029 CAED 18				CLC				; clear carry for add
  6030 CAEE 79 BA D3			ADC	LAB_2A9C,Y		; add -ve LSB
  6031 CAF1 85 6F			STA	FAC1_3			; save FAC1 mantissa3
  6032 CAF3 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  6033 CAF5 79 B9 D3			ADC	LAB_2A9B,Y		; add -ve NMSB
  6034 CAF8 85 6E			STA	FAC1_2			; save FAC1 mantissa2
  6035 CAFA A5 6D			LDA	FAC1_1			; get FAC1 mantissa1
  6036 CAFC 79 B8 D3			ADC	LAB_2A9A,Y		; add -ve MSB
  6037 CAFF 85 6D			STA	FAC1_1			; save FAC1 mantissa1
  6038 CB01 E8				INX				; 
  6039 CB02 B0 04			BCS	LAB_2A18		; 
  6040
  6041 CB04 10 E5			BPL	LAB_29FB		; not -ve so try again
  6042
  6043 CB06 30 02			BMI	LAB_2A1A		; 
  6044
  6045 CB08			LAB_2A18
  6046 CB08 30 E1			BMI	LAB_29FB		; 
  6047
  6048 CB0A			LAB_2A1A
  6049 CB0A 8A				TXA				; 
  6050 CB0B 90 04			BCC	LAB_2A21		; 
  6051
  6052 CB0D 49 FF			EOR	#$FF			; 
  6053 CB0F 69 0A			ADC	#$0A			; 
  6054 CB11			LAB_2A21
  6055 CB11 69 2F			ADC	#'0'-1			; add '0'-1 to result
  6056 CB13 C8				INY				; increment index ..
  6057 CB14 C8				INY				; .. to next less ..
  6058 CB15 C8				INY				; .. power of ten
  6059 CB16 84 55			STY	Cvaral			; save as current var address low byte
  6060 CB18 A4 7A			LDY	Sendl			; get output string index
  6061 CB1A C8				INY				; increment output string index
  6062 CB1B AA				TAX				; copy character to X
  6063 CB1C 29 7F			AND	#$7F			; mask out top bit
  6064 CB1E 99 04 00			STA	Decss,Y			; save to output string
  6065 CB21 C6 68			DEC	numexp			; decrement # of characters before the dp
  6066 CB23 D0 06			BNE	LAB_2A3B		; branch if still characters to do
  6067
  6068 									; else output the point
  6069 CB25 A9 2E			LDA	#$2E			; character '.'
  6070 CB27 C8				INY				; increment output string index
  6071 CB28 99 04 00			STA	Decss,Y			; save to output string
  6072 CB2B			LAB_2A3B
  6073 CB2B 84 7A			STY	Sendl			; save output string index
  6074 CB2D A4 55			LDY	Cvaral			; get current var address low byte
  6075 CB2F 8A				TXA				; get character back
  6076 CB30 49 FF			EOR	#$FF			; 
  6077 CB32 29 80			AND	#$80			; 
  6078 CB34 AA				TAX				; 
  6079 CB35 C0 12			CPY	#$12			; compare index with max
  6080 CB37 D0 B2			BNE	LAB_29FB		; loop if not max
  6081
  6082 									; now remove trailing zeroes
  6083 CB39 A4 7A			LDY	Sendl			; get output string index
  6084 CB3B			LAB_2A4B
  6085 CB3B B9 04 00			LDA	Decss,Y			; get character from output string
  6086 CB3E 88				DEY				; decrement output string index
  6087 CB3F C9 30			CMP	#'0'			; compare with '0'
  6088 CB41 F0 F8			BEQ	LAB_2A4B		; loop until non '0' character found
  6089
  6090 CB43 C9 2E			CMP	#'.'			; compare with '.'
  6091 CB45 F0 01			BEQ	LAB_2A58		; branch if was dp
  6092
  6093 									; restore last character
  6094 CB47 C8				INY				; increment output string index
  6095 CB48			LAB_2A58
  6096 CB48 A9 2B			LDA	#$2B			; character '+'
  6097 CB4A A6 69			LDX	expcnt			; get exponent count
  6098 CB4C F0 2E			BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6099
  6100 									; exponent isn't zero so write exponent
  6101 CB4E 10 08			BPL	LAB_2A68		; branch if exponent count +ve
  6102
  6103 CB50 A9 00			LDA	#$00			; clear A
  6104 CB52 38				SEC				; set carry for subtract
  6105 CB53 E5 69			SBC	expcnt			; subtract exponent count adjust (convert -ve to +ve)
  6106 CB55 AA				TAX				; copy exponent count to X
  6107 CB56 A9 2D			LDA	#'-'			; character '-'
  6108 CB58			LAB_2A68
  6109 CB58 99 06 00			STA	Decss+2,Y		; save to output string
  6110 CB5B A9 45			LDA	#$45			; character 'E'
  6111 CB5D 99 05 00			STA	Decss+1,Y		; save exponent sign to output string
  6112 CB60 8A				TXA				; get exponent count back
  6113 CB61 A2 2F			LDX	#'0'-1			; one less than '0' character
  6114 CB63 38				SEC				; set carry for subtract
  6115 CB64			LAB_2A74
  6116 CB64 E8				INX				; increment 10's character
  6117 CB65 E9 0A			SBC	#$0A			;.subtract 10 from exponent count
  6118 CB67 B0 FB			BCS	LAB_2A74		; loop while still >= 0
  6119
  6120 CB69 69 3A			ADC	#':'			; add character ':' ($30+$0A, result is 10 less that value)
  6121 CB6B 99 08 00			STA	Decss+4,Y		; save to output string
  6122 CB6E 8A				TXA				; copy 10's character
  6123 CB6F 99 07 00			STA	Decss+3,Y		; save to output string
  6124 CB72 A9 00			LDA	#$00			; set null terminator
  6125 CB74 99 09 00			STA	Decss+5,Y		; save to output string
  6126 CB77 F0 08			BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6127
  6128 									; save last character, [EOT] and exit
  6129 CB79			LAB_2A89
  6130 CB79 99 04 00			STA	Decss,Y			; save last character to output string
  6131
  6132 									; set null terminator and exit
  6133 CB7C			LAB_2A8C
  6134 CB7C A9 00			LDA	#$00			; set null terminator
  6135 CB7E 99 05 00			STA	Decss+1,Y		; save after last character
  6136
  6137 									; set string pointer (AY) and exit
  6138 CB81			LAB_2A91
  6139 CB81 A9 05			LDA	#<Decssp1		; set result string low pointer
  6140 CB83 A0 00			LDY	#>Decssp1		; set result string high pointer
  6141 CB85 60				RTS
  6142
  6143 				; perform power function
  6144 CB86			LAB_POWER
  6145 CB86 F0 42			BEQ	LAB_EXP			; go do  EXP()
  6146
  6147 CB88 A5 73			LDA	FAC2_e			; get FAC2 exponent
  6148 CB8A D0 03			BNE	LAB_2ABF		; branch if FAC2<>0
  6149
  6150 CB8C 4C 1D C6			JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6151
  6152 CB8F			LAB_2ABF
  6153 CB8F A2 5C			LDX	#<func_l		; set destination pointer low byte
  6154 CB91 A0 00			LDY	#>func_l		; set destination pointer high byte
  6155 CB93 20 72 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6156 CB96 A5 77			LDA	FAC2_s			; get FAC2 sign (b7)
  6157 CB98 10 0F			BPL	LAB_2AD9		; branch if FAC2>0
  6158
  6159 									; else FAC2 is -ve and can only be raised to an
  6160 									; integer power which gives an x +j0 result
  6161 CB9A 20 4C C9			JSR	LAB_INT			; perform INT
  6162 CB9D A9 5C			LDA	#<func_l		; set source pointer low byte
  6163 CB9F A0 00			LDY	#>func_l		; set source pointer high byte
  6164 CBA1 20 E2 C8			JSR	LAB_27F8		; compare FAC1 with (AY)
  6165 CBA4 D0 03			BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6166 									; this will leave FAC1 -ve and cause a Function Call
  6167 									; error when LOG() is called
  6168
  6169 CBA6 98				TYA				; clear sign b7
  6170 CBA7 A4 1B			LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
  6171 									; for possible later negation, b0
  6172 CBA9			LAB_2AD9
  6173 CBA9 20 90 C5			JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6174 CBAC 98				TYA				; copy sign back ..
  6175 CBAD 48				PHA				; .. and save it
  6176 CBAE 20 C6 C6			JSR	LAB_LOG			; do LOG(n)
  6177 CBB1 A9 5C			LDA	#<garb_l		; set pointer low byte
  6178 CBB3 A0 00			LDY	#>garb_l		; set pointer high byte
  6179 CBB5 20 04 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6180 CBB8 20 CA CB			JSR	LAB_EXP			; go do EXP(n)
  6181 CBBB 68				PLA				; pull sign from stack
  6182 CBBC 4A				LSR				; b0 is to be tested, shift to Cb
  6183 CBBD 90 0A			BCC	LAB_2AF9		; if no bit then exit
  6184
  6185 									; Perform negation
  6186 				; do - FAC1
  6187 CBBF			LAB_GTHAN
  6188 CBBF A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6189 CBC1 F0 06			BEQ	LAB_2AF9		; exit if FAC1_e = $00
  6190
  6191 CBC3 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6192 CBC5 49 FF			EOR	#$FF			; complement it
  6193 CBC7 85 70			STA	FAC1_s			; save FAC1 sign (b7)
  6194 CBC9			LAB_2AF9
  6195 CBC9 60				RTS
  6196
  6197 				; perform EXP()	(x^e)
  6198 CBCA			LAB_EXP
  6199 CBCA A9 48			LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6200 CBCC A0 D3			LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6201 CBCE 20 04 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6202 CBD1 A5 79			LDA	FAC1_r			; get FAC1 rounding byte
  6203 CBD3 69 50			ADC	#$50			; +$50/$100
  6204 CBD5 90 03			BCC	LAB_2B2B		; skip rounding if no carry
  6205
  6206 CBD7 20 AC C8			JSR	LAB_27C2		; round FAC1 (no check)
  6207 CBDA			LAB_2B2B
  6208 CBDA 85 63			STA	FAC2_r			; save FAC2 rounding byte
  6209 CBDC 20 98 C8			JSR	LAB_27AE		; copy FAC1 to FAC2
  6210 CBDF A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6211 CBE1 C9 88			CMP	#$88			; compare with EXP limit (256d)
  6212 CBE3 90 03			BCC	LAB_2B39		; branch if less
  6213
  6214 CBE5			LAB_2B36
  6215 CBE5 20 99 C7			JSR	LAB_2690		; handle overflow and underflow
  6216 CBE8			LAB_2B39
  6217 CBE8 20 4C C9			JSR	LAB_INT			; perform INT
  6218 CBEB A5 1B			LDA	Temp3			; get mantissa 3 from INT() function
  6219 CBED 18				CLC				; clear carry for add
  6220 CBEE 69 81			ADC	#$81			; normalise +1
  6221 CBF0 F0 F3			BEQ	LAB_2B36		; if $00 go handle overflow
  6222
  6223 CBF2 38				SEC				; set carry for subtract
  6224 CBF3 E9 01			SBC	#$01			; now correct for exponent
  6225 CBF5 48				PHA				; save FAC2 exponent
  6226
  6227 									; swap FAC1 and FAC2
  6228 CBF6 A2 04			LDX	#$04			; 4 bytes to do
  6229 CBF8			LAB_2B49
  6230 CBF8 B5 73			LDA	FAC2_e,X		; get FAC2,X
  6231 CBFA B4 6C			LDY	FAC1_e,X		; get FAC1,X
  6232 CBFC 95 6C			STA	FAC1_e,X		; save FAC1,X
  6233 CBFE 94 73			STY	FAC2_e,X		; save FAC2,X
  6234 CC00 CA				DEX				; decrement count/index
  6235 CC01 10 F5			BPL	LAB_2B49		; loop if not all done
  6236
  6237 CC03 A5 63			LDA	FAC2_r			; get FAC2 rounding byte
  6238 CC05 85 79			STA	FAC1_r			; save as FAC1 rounding byte
  6239 CC07 20 71 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6240 CC0A 20 BF CB			JSR	LAB_GTHAN		; do - FAC1
  6241 CC0D A9 4C			LDA	#<LAB_2AFE		; set counter pointer low byte
  6242 CC0F A0 D3			LDY	#>LAB_2AFE		; set counter pointer high byte
  6243 CC11 20 32 CC			JSR	LAB_2B84		; go do series evaluation
  6244 CC14 A9 00			LDA	#$00			; clear A
  6245 CC16 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6246 CC18 68				PLA				;.get saved FAC2 exponent
  6247 CC19 4C 7E C7			JMP	LAB_2675		; test and adjust accumulators and return
  6248
  6249 				; ^2 then series evaluation
  6250 CC1C			LAB_2B6E
  6251 CC1C 85 7A			STA	Cptrl			; save count pointer low byte
  6252 CC1E 84 7B			STY	Cptrh			; save count pointer high byte
  6253 CC20 20 68 C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6254 CC23 A9 64			LDA	#<Adatal		; set pointer low byte (Y already $00)
  6255 CC25 20 04 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6256 CC28 20 36 CC			JSR	LAB_2B88		; go do series evaluation
  6257 CC2B A9 64			LDA	#<Adatal		; pointer to original # low byte
  6258 CC2D A0 00			LDY	#>Adatal		; pointer to original # high byte
  6259 CC2F 4C 04 C7			JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6260
  6261 				; series evaluation
  6262 CC32			LAB_2B84
  6263 CC32 85 7A			STA	Cptrl			; save count pointer low byte
  6264 CC34 84 7B			STY	Cptrh			; save count pointer high byte
  6265 CC36			LAB_2B88
  6266 CC36 A2 68			LDX	#<numexp		; set pointer low byte
  6267 CC38 20 6A C8			JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
  6268 CC3B B1 7A			LDA	(Cptrl),Y		; get constants count
  6269 CC3D 85 71			STA	numcon			; save constants count
  6270 CC3F A4 7A			LDY	Cptrl			; get count pointer low byte
  6271 CC41 C8				INY				; increment it (now constants pointer)
  6272 CC42 98				TYA				; copy it
  6273 CC43 D0 02			BNE	LAB_2B97		; skip next if no overflow
  6274
  6275 CC45 E6 7B			INC	Cptrh			; else increment high byte
  6276 CC47			LAB_2B97
  6277 CC47 85 7A			STA	Cptrl			; save low byte
  6278 CC49 A4 7B			LDY	Cptrh			; get high byte
  6279 CC4B			LAB_2B9B
  6280 CC4B 20 04 C7			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6281 CC4E A5 7A			LDA	Cptrl			; get constants pointer low byte
  6282 CC50 A4 7B			LDY	Cptrh			; get constants pointer high byte
  6283 CC52 18				CLC				; clear carry for add
  6284 CC53 69 04			ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6285 CC55 90 01			BCC	LAB_2BA8		; skip next if no overflow
  6286
  6287 CC57 C8				INY				; increment high byte
  6288 CC58			LAB_2BA8
  6289 CC58 85 7A			STA	Cptrl			; save pointer low byte
  6290 CC5A 84 7B			STY	Cptrh			; save pointer high byte
  6291 CC5C 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1
  6292 CC5F A9 68			LDA	#<numexp		; set pointer low byte to partial @ numexp
  6293 CC61 A0 00			LDY	#>numexp		; set pointer high byte to partial @ numexp
  6294 CC63 C6 71			DEC	numcon			; decrement constants count
  6295 CC65 D0 E4			BNE	LAB_2B9B		; loop until all done
  6296
  6297 CC67 60				RTS
  6298
  6299 				; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6300 				; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6301 				; the Galois method and a sample of 65536 bytes produced gives the following values.
  6302
  6303 				; Entropy = 7.997442 bits per byte
  6304 				; Optimum compression would reduce these 65536 bytes by 0 percent
  6305
  6306 				; Chi square distribution for 65536 samples is 232.01, and
  6307 				; randomly would exceed this value 75.00 percent of the time
  6308
  6309 				; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6310 				; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6311 				; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6312 CC68			LAB_RND
  6313 CC68 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6314 CC6A F0 07			BEQ	NextPRN			; do next random # if zero
  6315
  6316 									; else get seed into random number store
  6317 CC6C A2 60			LDX	#<Rbyte4		; set PRNG pointer low byte
  6318 CC6E A0 18			LDY	#>Rbyte4		; set PRNG pointer high byte
  6319 CC70 20 72 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6320 CC73			NextPRN
  6321 CC73 A2 AF			LDX	#$AF			; set EOR byte
  6322 CC75 A0 13			LDY	#$13			; do this nineteen times
  6323 CC77			LoopPRN
  6324 CC77 0E 61 18			ASL	Rbyte1			; shift PRNG most significant byte
  6325 CC7A 2E 62 18			ROL	Rbyte2			; shift PRNG middle byte
  6326 CC7D 2E 63 18			ROL	Rbyte3			; shift PRNG least significant byte
  6327 CC80 2E 60 18			ROL	Rbyte4			; shift PRNG extra byte
  6328 CC83 90 07			BCC	Ninc1			; branch if bit 32 clear
  6329
  6330 CC85 8A				TXA				; set EOR byte
  6331 CC86 4D 61 18			EOR	Rbyte1			; EOR PRNG extra byte
  6332 CC89 8D 61 18			STA	Rbyte1			; save new PRNG extra byte
  6333 CC8C			Ninc1
  6334 CC8C 88				DEY				; decrement loop count
  6335 CC8D D0 E8			BNE	LoopPRN			; loop if not all done
  6336
  6337 CC8F A2 02			LDX	#$02			; three bytes to copy
  6338 CC91			CopyPRNG
  6339 CC91 BD 61 18			LDA	Rbyte1,X		; get PRNG byte
  6340 CC94 95 6D			STA	FAC1_1,X		; save FAC1 byte
  6341 CC96 CA				DEX
  6342 CC97 10 F8			BPL	CopyPRNG		; loop if not complete
  6343
  6344 CC99 A9 80			LDA	#$80			; set the exponent
  6345 CC9B 85 6C			STA	FAC1_e			; save FAC1 exponent
  6346
  6347 CC9D 0A				ASL				; clear A
  6348 CC9E 85 70			STA	FAC1_s			; save FAC1 sign
  6349
  6350 CCA0 4C FF C5			JMP	LAB_24D5		; normalise FAC1 and return
  6351
  6352 				; perform COS()
  6353 CCA3			LAB_COS
  6354 CCA3 A9 69			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6355 CCA5 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6356 CCA7 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1
  6357
  6358 				; perform SIN()
  6359 CCAA			LAB_SIN
  6360 CCAA 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6361 CCAD A9 7E			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6362 CCAF A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6363 CCB1 A6 77			LDX	FAC2_s			; get FAC2 sign (b7)
  6364 CCB3 20 C4 C7			JSR	LAB_26C2		; divide by (AY) (X=sign)
  6365 CCB6 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6366 CCB9 20 4C C9			JSR	LAB_INT			; perform INT
  6367 CCBC A9 00			LDA	#$00			; clear byte
  6368 CCBE 85 78			STA	FAC_sc			; clear sign compare (FAC1 EOR FAC2)
  6369 CCC0 20 71 C5			JSR	LAB_SUBTRACT		; perform subtraction, FAC2 from FAC1
  6370 CCC3 A9 B0			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6371 CCC5 A0 D3			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6372 CCC7 20 6E C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6373 CCCA A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6374 CCCC 48				PHA				; save FAC1 sign
  6375 CCCD 10 0D			BPL	LAB_2C35		; branch if +ve
  6376
  6377 									; FAC1 sign was -ve
  6378 CCCF 20 85 C5			JSR	LAB_244E		; add 0.5 to FAC1
  6379 CCD2 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6380 CCD4 30 09			BMI	LAB_2C38		; branch if -ve
  6381
  6382 CCD6 A5 23			LDA	Cflag			; get comparison evaluation flag
  6383 CCD8 49 FF			EOR	#$FF			; toggle flag
  6384 CCDA 85 23			STA	Cflag			; save comparison evaluation flag
  6385 CCDC			LAB_2C35
  6386 CCDC 20 BF CB			JSR	LAB_GTHAN		; do - FAC1
  6387 CCDF			LAB_2C38
  6388 CCDF A9 B0			LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6389 CCE1 A0 D3			LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6390 CCE3 20 89 C5			JSR	LAB_246C		; add (AY) to FAC1
  6391 CCE6 68				PLA				; restore FAC1 sign
  6392 CCE7 10 03			BPL	LAB_2C45		; branch if was +ve
  6393
  6394 									; else correct FAC1
  6395 CCE9 20 BF CB			JSR	LAB_GTHAN		; do - FAC1
  6396 CCEC			LAB_2C45
  6397 CCEC A9 6D			LDA	#<LAB_2C84		; set pointer low byte to counter
  6398 CCEE A0 D3			LDY	#>LAB_2C84		; set pointer high byte to counter
  6399 CCF0 4C 1C CC			JMP	LAB_2B6E		; ^2 then series evaluation and return
  6400
  6401 				; perform TAN()
  6402 CCF3			LAB_TAN
  6403 CCF3 20 68 C8			JSR	LAB_276E		; pack FAC1 into Adatal
  6404 CCF6 A9 00			LDA	#$00			; clear byte
  6405 CCF8 85 23			STA	Cflag			; clear comparison evaluation flag
  6406 CCFA 20 AA CC			JSR	LAB_SIN			; go do SIN(n)
  6407 CCFD A2 5C			LDX	#<func_l		; set sin(n) pointer low byte
  6408 CCFF A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6409 CD01 20 72 C8			JSR	LAB_2778		; pack FAC1 into (XY)
  6410 CD04 A9 64			LDA	#<Adatal		; set n pointer low addr
  6411 CD06 A0 00			LDY	#>Adatal		; set n pointer high addr
  6412 CD08 20 48 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6413 CD0B A9 00			LDA	#$00			; clear byte
  6414 CD0D 85 70			STA	FAC1_s			; clear FAC1 sign (b7)
  6415 CD0F A5 23			LDA	Cflag			; get comparison evaluation flag
  6416 CD11 20 1B CD			JSR	LAB_2C74		; save flag and go do series evaluation
  6417
  6418 CD14 A9 5C			LDA	#<func_l		; set sin(n) pointer low byte
  6419 CD16 A0 00			LDY	#>func_l		; set sin(n) pointer high byte
  6420 CD18 4C CC C7			JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6421
  6422 CD1B			LAB_2C74
  6423 CD1B 48				PHA				; save comparison evaluation flag
  6424 CD1C 4C DC CC			JMP	LAB_2C35		; go do series evaluation
  6425
  6426 				; perform USR()
  6427 CD1F			LAB_USR
  6428 CD1F 20 0A 00			JSR	Usrjmp			; call user code
  6429 CD22 4C AA BB			JMP	LAB_1BFB		; scan for ')', else do syntax error then warm start
  6430
  6431 				; perform ATN()
  6432 CD25			LAB_ATN
  6433 CD25 A5 70			LDA	FAC1_s			; get FAC1 sign (b7)
  6434 CD27 48				PHA				; save sign
  6435 CD28 10 03			BPL	LAB_2CA1		; branch if +ve
  6436
  6437 CD2A 20 BF CB			JSR	LAB_GTHAN		; else do - FAC1
  6438 CD2D			LAB_2CA1
  6439 CD2D A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6440 CD2F 48				PHA				; push exponent
  6441 CD30 C9 81			CMP	#$81			; compare with 1
  6442 CD32 90 07			BCC	LAB_2CAF		; branch if FAC1<1
  6443
  6444 CD34 A9 A3			LDA	#<LAB_259C		; set 1 pointer low byte
  6445 CD36 A0 D3			LDY	#>LAB_259C		; set 1 pointer high byte
  6446 CD38 20 CC C7			JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6447 CD3B			LAB_2CAF
  6448 CD3B A9 82			LDA	#<LAB_2CC9		; set pointer low byte to counter
  6449 CD3D A0 D3			LDY	#>LAB_2CC9		; set pointer high byte to counter
  6450 CD3F 20 1C CC			JSR	LAB_2B6E		; ^2 then series evaluation
  6451 CD42 68				PLA				; restore old FAC1 exponent
  6452 CD43 C9 81			CMP	#$81			; compare with 1
  6453 CD45 90 07			BCC	LAB_2CC2		; branch if FAC1<1
  6454
  6455 CD47 A9 69			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6456 CD49 A0 D3			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6457 CD4B 20 6E C5			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6458 CD4E			LAB_2CC2
  6459 CD4E 68				PLA				; restore FAC1 sign
  6460 CD4F 10 16			BPL	LAB_2D04		; exit if was +ve
  6461
  6462 CD51 4C BF CB			JMP	LAB_GTHAN		; else do - FAC1 and return
  6463
  6464 				; perform BITSET
  6465 CD54			LAB_BITSET
  6466 CD54 20 A3 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6467 CD57 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6468 CD59 B0 20			BCS	FCError			; branch if > 7
  6469
  6470 CD5B A9 00			LDA	#$00			; clear A
  6471 CD5D 38				SEC				; set the carry
  6472 CD5E			S_Bits
  6473 CD5E 2A				ROL				; shift bit
  6474 CD5F CA				DEX				; decrement bit number
  6475 CD60 10 FC			BPL	S_Bits			; loop if still +ve
  6476
  6477 CD62 E8				INX				; make X = $00
  6478 CD63 01 11			ORA	(Itempl,X)		; or with byte via temporary integer (addr)
  6479 CD65 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6480 CD67			LAB_2D04
  6481 CD67 60				RTS
  6482
  6483 				; perform BITCLR
  6484 CD68			LAB_BITCLR
  6485 CD68 20 A3 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6486 CD6B E0 08			CPX	#$08			; only 0 to 7 are allowed
  6487 CD6D B0 0C			BCS	FCError			; branch if > 7
  6488
  6489 CD6F A9 FF			LDA	#$FF			; set A
  6490 CD71			S_Bitc
  6491 CD71 2A				ROL				; shift bit
  6492 CD72 CA				DEX				; decrement bit number
  6493 CD73 10 FC			BPL	S_Bitc			; loop if still +ve
  6494
  6495 CD75 E8				INX				; make X = $00
  6496 CD76 21 11			AND	(Itempl,X)		; and with byte via temporary integer (addr)
  6497 CD78 81 11			STA	(Itempl,X)		; save byte via temporary integer (addr)
  6498 CD7A 60				RTS
  6499
  6500 CD7B			FCError
  6501 CD7B 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start
  6502
  6503 				; perform BITTST()
  6504 CD7E			LAB_BTST
  6505 CD7E 20 7C 00			JSR	LAB_IGBY		; increment BASIC pointer
  6506 CD81 20 A3 C4			JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6507 CD84 E0 08			CPX	#$08			; only 0 to 7 are allowed
  6508 CD86 B0 F3			BCS	FCError			; branch if > 7
  6509
  6510 CD88 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  6511 CD8B C9 29			CMP	#')'			; is next character ')'
  6512 CD8D F0 03			BEQ	TST_OK			; if ')' go do rest of function
  6513
  6514 CD8F 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  6515
  6516 CD92			TST_OK
  6517 CD92 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6518 CD95 A9 00			LDA	#$00			; clear A
  6519 CD97 38				SEC				; set the carry
  6520 CD98			T_Bits
  6521 CD98 2A				ROL				; shift bit
  6522 CD99 CA				DEX				; decrement bit number
  6523 CD9A 10 FC			BPL	T_Bits			; loop if still +ve
  6524
  6525 CD9C E8				INX				; make X = $00
  6526 CD9D 21 11			AND	(Itempl,X)		; AND with byte via temporary integer (addr)
  6527 CD9F F0 02			BEQ	LAB_NOTT		; branch if zero (already correct)
  6528
  6529 CDA1 A9 FF			LDA	#$FF			; set for -1 result
  6530 CDA3			LAB_NOTT
  6531 CDA3 4C C5 C8			JMP	LAB_27DB		; go do SGN tail
  6532
  6533 				; perform BIN$()
  6534 CDA6			LAB_BINS
  6535 CDA6 E0 19			CPX	#$19			; max + 1
  6536 CDA8 B0 48			BCS	BinFErr			; exit if too big ( > or = )
  6537
  6538 CDAA 86 38			STX	TempB			; save # of characters ($00 = leading zero remove)
  6539 CDAC A9 18			LDA	#$18			; need A byte long space
  6540 CDAE 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long
  6541 CDB1 A0 17			LDY	#$17			; set index
  6542 CDB3 A2 18			LDX	#$18			; character count
  6543 CDB5			NextB1
  6544 CDB5 46 11			LSR	nums_1			; shift highest byte
  6545 CDB7 66 12			ROR	nums_2			; shift middle byte
  6546 CDB9 66 13			ROR	nums_3			; shift lowest byte bit 0 to carry
  6547 CDBB 8A				TXA				; load with '0'/2
  6548 CDBC 2A				ROL				; shift in carry
  6549 CDBD 91 6D			STA	(str_pl),Y		; save to temp string + index
  6550 CDBF 88				DEY				; decrement index
  6551 CDC0 10 F3			BPL	NextB1			; loop if not done
  6552
  6553 CDC2 A5 38			LDA	TempB			; get # of characters
  6554 CDC4 F0 0A			BEQ	EndBHS			; branch if truncate
  6555
  6556 CDC6 AA				TAX				; copy length to X
  6557 CDC7 38				SEC				; set carry for add !
  6558 CDC8 49 FF			EOR	#$FF			; 1's complement
  6559 CDCA 69 18			ADC	#$18			; add 24d
  6560 CDCC F0 1C			BEQ	GoPr2			; if zero print whole string
  6561
  6562 CDCE D0 0F			BNE	GoPr1			; else go make output string
  6563 					
  6564 				; this is the exit code and is also used by HEX$()
  6565 				; truncate string to remove leading '0's
  6566 CDD0			EndBHS
  6567 CDD0 A8				TAY				; clear index (A=0, X=length here)
  6568 CDD1			NextB2
  6569 CDD1 B1 6D			LDA	(str_pl),Y		; get character from string
  6570 CDD3 C9 30			CMP	#'0'			; compare with '0'
  6571 CDD5 D0 07			BNE	GoPr			; if not '0' then go print string from here
  6572
  6573 CDD7 CA				DEX				; decrement character count
  6574 CDD8 F0 03			BEQ	GoPr3			; if zero then end of string so go print it
  6575
  6576 CDDA C8				INY				; else increment index
  6577 CDDB 10 F4			BPL	NextB2			; loop always
  6578
  6579 				; make fixed length output string - ignore overflows!
  6580 CDDD			GoPr3
  6581 CDDD E8				INX				; need at least 1 character
  6582 CDDE			GoPr
  6583 CDDE 98				TYA				; copy result
  6584 CDDF			GoPr1
  6585 CDDF 18				CLC				; clear carry for add
  6586 CDE0 65 6D			ADC	str_pl			; add low address
  6587 CDE2 85 6D			STA	str_pl			; save low address
  6588 CDE4 A9 00			LDA	#$00			; do high byte
  6589 CDE6 65 6E			ADC	str_ph			; add high address
  6590 CDE8 85 6E			STA	str_ph			; save high address
  6591 CDEA			GoPr2
  6592 CDEA 86 6C			STX	str_ln			; X holds string length
  6593 CDEC 20 7C 00			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ')')
  6594 CDEF 4C 50 C1			JMP	LAB_RTST		; check for space on descriptor stack then put address
  6595 									; and length on descriptor stack and update stack pointers
  6596
  6597 CDF2			BinFErr
  6598 CDF2 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start
  6599
  6600 				; perform HEX$()
  6601 CDF5			LAB_HEXS
  6602 CDF5 E0 07			CPX	#$07			; max + 1
  6603 CDF7 B0 F9			BCS	BinFErr			; exit if too big ( > or = )
  6604
  6605 CDF9 86 38			STX	TempB			; save # of characters
  6606
  6607 CDFB A9 06			LDA	#$06			; need 6 bytes for string
  6608 CDFD 20 03 C1			JSR	LAB_MSSP		; make string space A bytes long
  6609 CE00 A0 05			LDY	#$05			; set string index
  6610
  6611 					; Disable decimal mode patch
  6612 					;SED				; need decimal mode for nibble convert
  6613 CE02 A5 13			LDA	nums_3			; get lowest byte
  6614 CE04 20 21 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6615 CE07 A5 12			LDA	nums_2			; get middle byte
  6616 CE09 20 21 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6617 CE0C A5 11			LDA	nums_1			; get highest byte
  6618 CE0E 20 21 CE			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6619 					;CLD				; back to binary
  6620
  6621 CE11 A2 06			LDX	#$06			; character count
  6622 CE13 A5 38			LDA	TempB			; get # of characters
  6623 CE15 F0 B9			BEQ	EndBHS			; branch if truncate
  6624
  6625 CE17 AA				TAX				; copy length to X
  6626 CE18 38				SEC				; set carry for add !
  6627 CE19 49 FF			EOR	#$FF			; 1's complement
  6628 CE1B 69 06			ADC	#$06			; add 6d
  6629 CE1D F0 CB			BEQ	GoPr2			; if zero print whole string
  6630
  6631 CE1F D0 BE			BNE	GoPr1			; else go make output string (branch always)
  6632
  6633 				; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6634 CE21			LAB_A2HX
  6635 CE21 AA				TAX				; save byte
  6636 CE22 29 0F			AND	#$0F			; mask off top bits
  6637 CE24 20 2C CE			JSR	LAB_AL2X		; convert low nibble to ASCII and output
  6638 CE27 8A				TXA				; get byte back
  6639 CE28 4A				LSR				; /2	shift high nibble to low nibble
  6640 CE29 4A				LSR				; /4
  6641 CE2A 4A				LSR				; /8
  6642 CE2B 4A				LSR				; /16
  6643 CE2C			LAB_AL2X				; Disable decimal mode patch added
  6644 CE2C C9 0A			CMP	#$0A			; set carry for +1 if >9
  6645 CE2E 90 02			BCC   	LAB_AL20          	; skip adjust if <= 9
  6646 CE30 69 06			ADC   	#$06              	; adjust for A to F 
  6647 CE32			LAB_AL20
  6648 CE32 69 30			ADC	#'0'			; add ASCII '0'
  6649 CE34 91 6D			STA	(str_pl),Y		; save to temp string
  6650 CE36 88				DEY				; decrement counter
  6651 CE37 60				RTS
  6652
  6653 CE38			LAB_NLTO
  6654 CE38 85 6C			STA	FAC1_e			; save FAC1 exponent
  6655 CE3A A9 00			LDA	#$00			; clear sign compare
  6656 CE3C			LAB_MLTE
  6657 CE3C 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6658 CE3E 8A				TXA				; restore character
  6659 CE3F 20 10 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6660
  6661 				; gets here if the first character was '$' for hex
  6662 				; get hex number
  6663 CE42			LAB_CHEX
  6664 CE42 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6665 CE45 90 0A			BCC	LAB_ISHN		; branch if numeric character
  6666
  6667 CE47 09 20			ORA	#$20			; case convert, allow 'A' to 'F' and 'a' to 'f'
  6668 CE49 E9 61			SBC	#'a'			; subtract 'a' (carry set here)
  6669 CE4B C9 06			CMP	#$06			; compare normalised with $06 (max+1)
  6670 CE4D B0 2A			BCS	LAB_EXCH		; exit if >'f' or <'0'
  6671
  6672 CE4F 69 0A			ADC	#$0A			; convert to nibble
  6673 CE51			LAB_ISHN
  6674 CE51 29 0F			AND	#$0F			; convert to binary
  6675 CE53 AA				TAX				; save nibble
  6676 CE54 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6677 CE56 F0 E4			BEQ	LAB_MLTE		; skip multiply if zero
  6678
  6679 CE58 69 04			ADC	#$04			; add four to exponent (*16 - carry clear here)
  6680 CE5A 90 DC			BCC	LAB_NLTO		; if no overflow do evaluate digit
  6681
  6682 CE5C			LAB_MLTO
  6683 CE5C 4C 8E C6			JMP	LAB_2564		; do overflow error and warm start
  6684
  6685 CE5F			LAB_NXCH
  6686 CE5F AA				TAX				; save bit
  6687 CE60 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6688 CE62 F0 06			BEQ	LAB_MLBT		; skip multiply if zero
  6689
  6690 CE64 E6 6C			INC	FAC1_e			; increment FAC1 exponent (*2)
  6691 CE66 F0 F4			BEQ	LAB_MLTO		; do overflow error if = $00
  6692
  6693 CE68 A9 00			LDA	#$00			; clear sign compare
  6694 CE6A			LAB_MLBT
  6695 CE6A 85 78			STA	FAC_sc			; save sign compare (FAC1 EOR FAC2)
  6696 CE6C 8A				TXA				; restore bit
  6697 CE6D 20 10 CA			JSR	LAB_2912		; evaluate new ASCII digit
  6698
  6699 				; gets here if the first character was  '%' for binary
  6700 				; get binary number
  6701 CE70			LAB_CBIN
  6702 CE70 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  6703 CE73 49 30			EOR	#'0'			; convert '0' to 0 etc.
  6704 CE75 C9 02			CMP	#$02			; compare with max+1
  6705 CE77 90 E6			BCC	LAB_NXCH		; branch exit if < 2
  6706
  6707 CE79			LAB_EXCH
  6708 CE79 4C F5 C9			JMP	LAB_28F6		; evaluate -ve flag and return
  6709
  6710 				; ctrl-c check routine. includes limited 'life' byte save for INGET routine
  6711 				; now also the code that checks to see if an interrupt has occurred
  6712 CE7C			CTRLC
  6713 CE7C AD 68 18			LDA	ccflag			; get [CTRL-C] check flag
  6714 CE7F D0 18			BNE	LAB_CRTS		; exit if inhibited
  6715
  6716 CE81 20 C5 D2			JSR	V_INPT			; scan input device
  6717 CE84 90 0B			BCC	LAB_FBA0		; exit if buffer empty
  6718
  6719 CE86 8D 69 18			STA	ccbyte			; save received byte
  6720 CE89 A2 20			LDX	#$20			; 'life' timer for bytes
  6721 CE8B 8E 6A 18			STX	ccnull			; set countdown
  6722 CE8E 4C EC B4			JMP	LAB_1636		; return to BASIC
  6723
  6724 CE91			LAB_FBA0
  6725 CE91 AE 6A 18			LDX	ccnull			; get countdown byte
  6726 CE94 F0 03			BEQ	LAB_CRTS		; exit if finished
  6727
  6728 CE96 CE 6A 18			DEC	ccnull			; else decrement countdown
  6729 CE99			LAB_CRTS
  6730 CE99 60				RTS
  6731
  6732 				; 02-08-'25 Emile removed: check whichever interrupt is indexed by X
  6733
  6734 				; get byte from input device, no waiting
  6735 				; returns with carry set if byte in A
  6736 CE9A			INGET
  6737 CE9A 20 C5 D2			JSR	V_INPT			; call scan input device
  6738 CE9D B0 09			BCS	LAB_FB95		; if byte go reset timer
  6739
  6740 CE9F AD 6A 18			LDA	ccnull			; get countdown
  6741 CEA2 F0 09			BEQ	LAB_FB96		; exit if empty
  6742
  6743 CEA4 AD 69 18			LDA	ccbyte			; get last received byte
  6744 CEA7 38				SEC				; flag we got a byte
  6745 CEA8			LAB_FB95
  6746 CEA8 A2 00			LDX	#$00			; clear X
  6747 CEAA 8E 6A 18			STX	ccnull			; clear timer because we got a byte
  6748 CEAD			LAB_FB96
  6749 CEAD 60				RTS
  6750
  6751 				; 21-07-'25 Emile LAB_IRQ, LAB_NMI, LAB_SIRQ, LAB_SNMI, RETIRQ and RETNMI removed (+105 bytes)
  6752
  6753 				; MAX() MIN() pre process
  6754 CEAE			LAB_MMPP
  6755 CEAE 20 A4 BA			JSR	LAB_EVEZ		; process expression
  6756 CEB1 4C 8B BA			JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  6757
  6758 				; perform MAX()
  6759 CEB4			LAB_MAX
  6760 CEB4 20 E2 CE			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  6761 									; pull FAC2 and compare with FAC1
  6762 CEB7 10 FB			BPL	LAB_MAX			; branch if no swap to do
  6763
  6764 CEB9 A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  6765 CEBB 09 80			ORA	#$80			; set top bit (clear sign from compare)
  6766 CEBD 85 74			STA	FAC2_1			; save FAC2 mantissa1
  6767 CEBF 20 8E C5			JSR	LAB_279B		; copy FAC2 to FAC1
  6768 CEC2 F0 F0			BEQ	LAB_MAX			; go do next (branch always)
  6769
  6770 				; perform MIN()
  6771 CEC4			LAB_MIN
  6772 CEC4 20 E2 CE			JSR	LAB_PHFA		; push FAC1, evaluate expression,
  6773 									; pull FAC2 and compare with FAC1
  6774 CEC7 30 FB			BMI	LAB_MIN			; branch if no swap to do
  6775
  6776 CEC9 F0 F9			BEQ	LAB_MIN			; branch if no swap to do
  6777
  6778 CECB A5 74			LDA	FAC2_1			; get FAC2 mantissa1
  6779 CECD 09 80			ORA	#$80			; set top bit (clear sign from compare)
  6780 CECF 85 74			STA	FAC2_1			; save FAC2 mantissa1
  6781 CED1 20 8E C5			JSR	LAB_279B		; copy FAC2 to FAC1
  6782 CED4 F0 EE			BEQ	LAB_MIN			; go do next (branch always)
  6783
  6784 				; exit routine. don't bother returning to the loop code
  6785 				; check for correct exit, else so syntax error
  6786 CED6			LAB_MMEC
  6787 CED6 C9 29			CMP	#')'			; is it end of function?
  6788 CED8 D0 05			BNE	LAB_MMSE		; if not do MAX MIN syntax error
  6789
  6790 CEDA 68				PLA				; dump return address low byte
  6791 CEDB 68				PLA				; dump return address high byte
  6792 CEDC 4C 7C 00			JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ')')
  6793
  6794 CEDF			LAB_MMSE
  6795 CEDF 4C BD BB			JMP	LAB_SNER		; do syntax error then warm start
  6796
  6797 				; check for next, evaluate and return or exit
  6798 				; this is the routine that does most of the work
  6799 CEE2			LAB_PHFA
  6800 CEE2 20 82 00			JSR	LAB_GBYT		; get next BASIC byte
  6801 CEE5 C9 2C			CMP	#','			; is there more ?
  6802 CEE7 D0 ED			BNE	LAB_MMEC		; if not go do end check
  6803
  6804 									; push FAC1
  6805 CEE9 20 A4 C8			JSR	LAB_27BA		; round FAC1
  6806 CEEC A5 70			LDA	FAC1_s			; get FAC1 sign
  6807 CEEE 09 7F			ORA	#$7F			; set all non sign bits
  6808 CEF0 25 6D			AND	FAC1_1			; AND FAC1 mantissa1 (AND in sign bit)
  6809 CEF2 48				PHA				; push on stack
  6810 CEF3 A5 6E			LDA	FAC1_2			; get FAC1 mantissa2
  6811 CEF5 48				PHA				; push on stack
  6812 CEF6 A5 6F			LDA	FAC1_3			; get FAC1 mantissa3
  6813 CEF8 48				PHA				; push on stack
  6814 CEF9 A5 6C			LDA	FAC1_e			; get FAC1 exponent
  6815 CEFB 48				PHA				; push on stack
  6816
  6817 CEFC 20 7C 00			JSR	LAB_IGBY		; scan and get next BASIC byte (after ',')
  6818 CEFF 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  6819 									; else do type mismatch
  6820
  6821 									; pop FAC2 (MAX/MIN expression so far)
  6822 CF02 68				PLA				; pop exponent
  6823 CF03 85 73			STA	FAC2_e			; save FAC2 exponent
  6824 CF05 68				PLA				; pop mantissa3
  6825 CF06 85 76			STA	FAC2_3			; save FAC2 mantissa3
  6826 CF08 68				PLA				; pop mantissa1
  6827 CF09 85 75			STA	FAC2_2			; save FAC2 mantissa2
  6828 CF0B 68				PLA				; pop sign/mantissa1
  6829 CF0C 85 74			STA	FAC2_1			; save FAC2 sign/mantissa1
  6830 CF0E 85 77			STA	FAC2_s			; save FAC2 sign
  6831
  6832 									; compare FAC1 with (packed) FAC2
  6833 CF10 A9 73			LDA	#<FAC2_e		; set pointer low byte to FAC2
  6834 CF12 A0 00			LDY	#>FAC2_e		; set pointer high byte to FAC2
  6835 CF14 4C E2 C8			JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  6836 									; returns A=$00 if FAC1 = (AY)
  6837 									; returns A=$01 if FAC1 > (AY)
  6838 									; returns A=$FF if FAC1 < (AY)
  6839
  6840 				; perform WIDTH
  6841 CF17			LAB_WDTH
  6842 CF17 C9 2C			CMP	#','			; is next byte ','
  6843 CF19 F0 1B			BEQ	LAB_TBSZ		; if so do tab size
  6844
  6845 CF1B 20 57 C4			JSR	LAB_GTBY		; get byte parameter
  6846 CF1E 8A				TXA				; copy width to A
  6847 CF1F F0 0A			BEQ	LAB_NSTT		; branch if set for infinite line
  6848
  6849 CF21 E0 10			CPX	#$10			; else make min width = 16d
  6850 CF23 90 45			BCC	TabErr			; if less do function call error and exit
  6851
  6852 				; this next compare ensures that we can't exit WIDTH via an error leaving the
  6853 				; tab size greater than the line length.
  6854 CF25 E4 24			CPX	TabSiz			; compare with tab size
  6855 CF27 B0 02			BCS	LAB_NSTT		; branch if >= tab size
  6856
  6857 CF29 86 24			STX	TabSiz			; else make tab size = terminal width
  6858 CF2B			LAB_NSTT
  6859 CF2B 86 0F			STX	TWidth			; set the terminal width
  6860 CF2D 20 82 00			JSR	LAB_GBYT		; get BASIC byte back
  6861 CF30 F0 1A			BEQ	WExit			; exit if no following
  6862
  6863 CF32 C9 2C			CMP	#','			; else is it ','
  6864 CF34 D0 A9			BNE	LAB_MMSE		; if not do syntax error
  6865
  6866 CF36			LAB_TBSZ
  6867 CF36 20 54 C4			JSR	LAB_SGBY		; scan and get byte parameter
  6868 CF39 8A				TXA				; copy TAB size
  6869 CF3A 30 2E			BMI	TabErr			; if >127 do function call error and exit
  6870
  6871 CF3C E0 01			CPX	#$01			; compare with min-1
  6872 CF3E 90 2A			BCC	TabErr			; if <=1 do function call error and exit
  6873
  6874 CF40 A5 0F			LDA	TWidth			; set flags for width
  6875 CF42 F0 06			BEQ	LAB_SVTB		; skip check if infinite line
  6876
  6877 CF44 E4 0F			CPX	TWidth			; compare TAB with width
  6878 CF46 F0 02			BEQ	LAB_SVTB		; ok if =
  6879
  6880 CF48 B0 20			BCS	TabErr			; branch if too big
  6881
  6882 CF4A			LAB_SVTB
  6883 CF4A 86 24			STX	TabSiz			; save TAB size
  6884
  6885 				; calculate tab column limit from TAB size. The Iclim is set to the last tab
  6886 				; position on a line that still has at least one whole tab width between it
  6887 				; and the end of the line.
  6888 CF4C			WExit
  6889 CF4C A5 0F			LDA	TWidth			; get width
  6890 CF4E F0 06			BEQ	LAB_SULP		; branch if infinite line
  6891
  6892 CF50 C5 24			CMP	TabSiz			; compare with tab size
  6893 CF52 B0 03			BCS	LAB_WDLP		; branch if >= tab size
  6894
  6895 CF54 85 24			STA	TabSiz			; else make tab size = terminal width
  6896 CF56			LAB_SULP
  6897 CF56 38				SEC				; set carry for subtract
  6898 CF57			LAB_WDLP
  6899 CF57 E5 24			SBC	TabSiz			; subtract tab size
  6900 CF59 B0 FC			BCS	LAB_WDLP		; loop while no borrow
  6901
  6902 CF5B 65 24			ADC	TabSiz			; add tab size back
  6903 CF5D 18				CLC				; clear carry for add
  6904 CF5E 65 24			ADC	TabSiz			; add tab size back again
  6905 CF60 85 10			STA	Iclim			; save for now
  6906 CF62 A5 0F			LDA	TWidth			; get width back
  6907 CF64 38				SEC				; set carry for subtract
  6908 CF65 E5 10			SBC	Iclim			; subtract remainder
  6909 CF67 85 10			STA	Iclim			; save tab column limit
  6910 CF69			LAB_NOSQ
  6911 CF69 60				RTS
  6912
  6913 CF6A			TabErr
  6914 CF6A 4C E6 BE			JMP	LAB_FCER		; do function call error then warm start
  6915
  6916 				; perform SQR()
  6917 CF6D			LAB_SQR
  6918 CF6D A5 70			LDA	FAC1_s			; get FAC1 sign
  6919 CF6F 30 F9			BMI	TabErr			; if -ve do function call error
  6920
  6921 CF71 A5 6C			LDA	FAC1_e			; get exponent
  6922 CF73 F0 F4			BEQ	LAB_NOSQ		; if zero just return
  6923
  6924 									; else do root
  6925 CF75 20 95 C8			JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6926 CF78 A9 00			LDA	#$00			; clear A
  6927
  6928 CF7A 85 37			STA	FACt_3			; clear remainder
  6929 CF7C 85 36			STA	FACt_2			; ..
  6930 CF7E 85 35			STA	FACt_1			; ..
  6931 CF80 85 38			STA	TempB			; ..
  6932
  6933 CF82 85 6F			STA	FAC1_3			; clear root
  6934 CF84 85 6E			STA	FAC1_2			; ..
  6935 CF86 85 6D			STA	FAC1_1			; ..
  6936
  6937 CF88 A2 18			LDX	#$18			; 24 pairs of bits to do
  6938 CF8A A5 73			LDA	FAC2_e			; get exponent
  6939 CF8C 4A				LSR				; check odd/even
  6940 CF8D B0 0E			BCS	LAB_SQE2		; if odd only 1 shift first time
  6941
  6942 CF8F			LAB_SQE1
  6943 CF8F 06 76			ASL	FAC2_3			; shift highest bit of number ..
  6944 CF91 26 75			ROL	FAC2_2			; ..
  6945 CF93 26 74			ROL	FAC2_1			; ..
  6946 CF95 26 37			ROL	FACt_3			; .. into remainder
  6947 CF97 26 36			ROL	FACt_2			; ..
  6948 CF99 26 35			ROL	FACt_1			; ..
  6949 CF9B 26 38			ROL	TempB			; .. never overflows
  6950 CF9D			LAB_SQE2
  6951 CF9D 06 76			ASL	FAC2_3			; shift highest bit of number ..
  6952 CF9F 26 75			ROL	FAC2_2			; ..
  6953 CFA1 26 74			ROL	FAC2_1			; ..
  6954 CFA3 26 37			ROL	FACt_3			; .. into remainder
  6955 CFA5 26 36			ROL	FACt_2			; ..
  6956 CFA7 26 35			ROL	FACt_1			; ..
  6957 CFA9 26 38			ROL	TempB			; .. never overflows
  6958
  6959 CFAB 06 6F			ASL	FAC1_3			; root = root * 2
  6960 CFAD 26 6E			ROL	FAC1_2			; ..
  6961 CFAF 26 6D			ROL	FAC1_1			; .. never overflows
  6962
  6963 CFB1 A5 6F			LDA	FAC1_3			; get root low byte
  6964 CFB3 2A				ROL				; *2
  6965 CFB4 85 1B			STA	Temp3			; save partial low byte
  6966 CFB6 A5 6E			LDA	FAC1_2			; get root low mid byte
  6967 CFB8 2A				ROL				; *2
  6968 CFB9 85 1C			STA	Temp3+1			; save partial low mid byte
  6969 CFBB A5 6D			LDA	FAC1_1			; get root high mid byte
  6970 CFBD 2A				ROL				; *2
  6971 CFBE 85 1D			STA	Temp3+2			; save partial high mid byte
  6972 CFC0 A9 00			LDA	#$00			; get root high byte (always $00)
  6973 CFC2 2A				ROL				; *2
  6974 CFC3 85 1E			STA	Temp3+3			; save partial high byte
  6975
  6976 									; carry clear for subtract +1
  6977 CFC5 A5 37			LDA	FACt_3			; get remainder low byte
  6978 CFC7 E5 1B			SBC	Temp3			; subtract partial low byte
  6979 CFC9 85 1B			STA	Temp3			; save partial low byte
  6980
  6981 CFCB A5 36			LDA	FACt_2			; get remainder low mid byte
  6982 CFCD E5 1C			SBC	Temp3+1			; subtract partial low mid byte
  6983 CFCF 85 1C			STA	Temp3+1			; save partial low mid byte
  6984
  6985 CFD1 A5 35			LDA	FACt_1			; get remainder high mid byte
  6986 CFD3 E5 1D			SBC	Temp3+2			; subtract partial high mid byte
  6987 CFD5 A8				TAY				; copy partial high mid byte
  6988
  6989 CFD6 A5 38			LDA	TempB			; get remainder high byte
  6990 CFD8 E5 1E			SBC	Temp3+3			; subtract partial high byte
  6991 CFDA 90 0E			BCC	LAB_SQNS		; skip sub if remainder smaller
  6992
  6993 CFDC 85 38			STA	TempB			; save remainder high byte
  6994
  6995 CFDE 84 35			STY	FACt_1			; save remainder high mid byte
  6996
  6997 CFE0 A5 1C			LDA	Temp3+1			; get remainder low mid byte
  6998 CFE2 85 36			STA	FACt_2			; save remainder low mid byte
  6999
  7000 CFE4 A5 1B			LDA	Temp3			; get partial low byte
  7001 CFE6 85 37			STA	FACt_3			; save remainder low byte
  7002
  7003 CFE8 E6 6F			INC	FAC1_3			; increment root low byte (never any rollover)
  7004 CFEA			LAB_SQNS
  7005 CFEA CA				DEX				; decrement bit pair count
  7006 CFEB D0 A2			BNE	LAB_SQE1		; loop if not all done
  7007
  7008 CFED 38				SEC				; set carry for subtract
  7009 CFEE A5 73			LDA	FAC2_e			; get exponent
  7010 CFF0 E9 80			SBC	#$80			; normalise
  7011 CFF2 6A				ROR				; /2 and re-bias to $80
  7012 CFF3 69 00			ADC	#$00			; add bit zero back in (allow for half shift)
  7013 CFF5 85 6C			STA	FAC1_e			; save it
  7014 CFF7 4C FF C5			JMP	LAB_24D5		; normalise FAC1 and return
  7015
  7016 				; perform VARPTR()
  7017 CFFA			LAB_VARPTR
  7018 CFFA 20 7C 00			JSR	LAB_IGBY		; increment and scan memory
  7019 CFFD 20 67 BD			JSR	LAB_GVAR		; get var address
  7020 D000 20 AA BB			JSR	LAB_1BFB		; scan for ')" , else do syntax error then warm start
  7021 D003 A4 55			LDY	Cvaral			; get var address low byte
  7022 D005 A5 56			LDA	Cvarah			; get var address high byte
  7023 D007 4C 16 C0			JMP	LAB_UAYFC		; save and convert unsigned integer AY to FAC1 and return
  7024
  7025 				; perform PI
  7026 D00A			LAB_PI
  7027 D00A A9 7E			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7028 D00C A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7029 D00E 20 48 C8			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  7030 D011 C6 6C			DEC	FAC1_e			; make result = PI
  7031 D013 60				RTS
  7032
  7033 				; perform TWOPI
  7034 D014			LAB_TWOPI
  7035 D014 A9 7E			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7036 D016 A0 D3			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7037 D018 4C 48 C8			JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
  7038 					
  7039 				; *****************************************
  7040 				; ** New Commands For Junior Computer 2 ***
  7041 				; *****************************************
  7042 D01B			LAB_MOD
  7043 D01B 60				RTS
  7044 				;	LDX	#$04
  7045 				;LAB_STO_FAC2
  7046 				;	LDA	FAC2_e,X
  7047 				;	PHA
  7048 				;	DEX
  7049 				;	BPL	LAB_STO_FAC2
  7050 D01C A2 04			LDX	#$04
  7051 D01E			LAB_STO_FAC1
  7052 D01E B5 6C			LDA	FAC1_e,X
  7053 D020 48				PHA
  7054 D021 CA				DEX
  7055 D022 10 FA			BPL	LAB_STO_FAC1
  7056
  7057 D024 20 CF C7			JSR 	LAB_DIVIDE
  7058 D027 20 4C C9			JSR	LAB_INT
  7059
  7060 D02A 20 98 C8			JSR	LAB_27AE
  7061 				;	LDX	#$00
  7062 				;	STX	FAC1_r
  7063 				;LAB_LOD_FAC2_1
  7064 				;	PLA
  7065 				;	STA	FAC1_e,X
  7066 				;	INX
  7067 				;	CPX	#$05
  7068 				;	BNE	LAB_LOD_FAC2_1
  7069
  7070 					;JSR	LAB_MULTIPLY
  7071 					
  7072 D02D A2 00			LDX	#$00
  7073 D02F			LAB_LOD_FAC2_2
  7074 D02F 68				PLA
  7075 D030 95 6C			STA	FAC1_e,X
  7076 D032 E8				INX
  7077 D033 E0 05			CPX	#$05
  7078 D035 D0 F8			BNE	LAB_LOD_FAC2_2
  7079
  7080 					;JSR	LAB_SUBTRACT
  7081 D037 4C 07 C7			JMP	LAB_MULTIPLY		; call routine and return
  7082
  7083 				; Call Device Command Routine *************
  7084 D03A			CALL_CMD
  7085 D03A 6C 6C 1A			JMP	(DEVCMD)		; current opened device command vector (Junior Computer 2)
  7086
  7087 				; Get Null Terminated String Parameter ****
  7088 D03D			LAB_GETSTRPARM
  7089 D03D 85 1A			STA	Temp1
  7090 D03F 20 9C BA			JSR	LAB_EVEX		; evaluate expression
  7091 D042 A5 1F			LDA	Dtypef			; is it a string expression
  7092 D044 D0 03			BNE	LAB_GETSTR0		; yes, get string				
  7093 D046 20 97 BA			JSR	LAB_1ABC		; no, throw type mismatch error
  7094 D049			LAB_GETSTR0
  7095 D049 A0 00			LDY	#$00			; set string index to 0
  7096 D04B			LAB_GETSTR1
  7097 D04B B1 78			LDA	(ssptr_l),Y		; load a string char
  7098 D04D F0 0B			BEQ	LAB_GETSTR2		; is it a NULL? yes, exit
  7099 D04F C9 22			CMP	#'"'			; is it a '"'?
  7100 D051 F0 03			BEQ	LAB_TERM		; yes, set string termination
  7101 D053 C8				INY				; increment string index
  7102 D054 D0 F5			BNE	LAB_GETSTR1		; and repeat loop
  7103 D056			LAB_TERM
  7104 D056 A9 00			LDA 	#$00			; store termination char
  7105 D058 91 78			STA 	(ssptr_l),Y		; at the end of the string
  7106 D05A			LAB_GETSTR2
  7107 D05A A6 78			LDX	ssptr_l			; load string pointer low byte into X
  7108 D05C A4 79			LDY	ssptr_h			; load string pointer high byte into X
  7109 D05E A5 1A			LDA	Temp1
  7110 D060 60				RTS
  7111
  7112 				; Get Device Parameters *******************
  7113 D061			LAB_GETDEVPARM
  7114 D061 20 57 C4			JSR	LAB_GTBY		; scan for byte value
  7115 D064 8A				TXA				; and set A to result
  7116 D065 F0 08			BEQ	LAB_DEV0		; device is 0, no more parameters needed
  7117 D067 85 1A			STA	Temp1			; save device number
  7118 D069 20 B9 BB			JSR	LAB_1C01		; check for ','
  7119 D06C A5 1A			LDA	Temp1
  7120 D06E 60				RTS
  7121 D06F			LAB_DEV0
  7122 D06F 4C AC BB			JMP	LAB_SCCA		; check if more token, if so throw syntax error
  7123
  7124 				; Get Two Byte Parameters *****************
  7125 D072			LAB_GET2BYTEPARMS
  7126 					;JSR	LAB_EVBY		; evaluate byte expression, result in X
  7127 D072 20 57 C4			JSR	LAB_GTBY		; get first byte parameter into X
  7128 D075 86 1A			STX	Temp1			; and store it in temp var
  7129 D077 20 B9 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7130 D07A 20 57 C4			JSR	LAB_GTBY		; get second byte parameter into X
  7131 D07D 8A				TXA
  7132 D07E A8				TAY				; and transfer it into Y
  7133 D07F A6 1A			LDX	Temp1			; restore first parameter into X
  7134 D081 60				RTS
  7135
  7136 				; get device number parameter *************
  7137 D082			LAB_GETDEVID
  7138 D082 20 57 C4			JSR	LAB_GTBY		; get byte parameter into X
  7139 D085 8A				TXA				; and transfer it into A
  7140 D086 09 10			ORA	#$10			; search for stdio devices
  7141 D088 60				RTS
  7142
  7143 				; perform LOAD ****************************
  7144 D089			LAB_LOAD 
  7145 D089 D0 04			BNE	LOAD_DEV		; if no following token use device 0
  7146 D08B A9 00			LDA	#$00			; set device id = 0
  7147 D08D F0 03			BEQ	SET_LOADADR		; branch always
  7148 D08F			LOAD_DEV
  7149 D08F 20 61 D0			JSR	LAB_GETDEVPARM		; get device id
  7150 D092			SET_LOADADR
  7151 D092 48				PHA
  7152 D093 A2 00			LDX	#$00
  7153 D095 86 FA			STX	ADRL			; set load destination address low, needed by XModem routines
  7154 D097 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7155 D099 A2 B0			LDX	#>RAM_TOP		; Highest RAM load-address for BASIC
  7156 D09B 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7157 D09D A2 20			LDX	#$20
  7158 D09F 86 FB			STX	ADRH			; set load destination address high, needed by XModem routines
  7159 D0A1 86 FF			STX	MODE			; Set to a non-zero value so that XModemRcv uses ADRL/ADRH as dest. address
  7160 D0A3 09 20			ORA	#$20			; it's a storage device
  7161 D0A5 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7162 D0A8 68				PLA
  7163 D0A9 F0 03			BEQ	CALL_LOAD		; device id = 0?
  7164 D0AB 20 3D D0			JSR	LAB_GETSTRPARM		; no, get string parameter
  7165 D0AE			CALL_LOAD
  7166 D0AE A9 20			LDA	#CMD_LOAD
  7167 D0B0 20 3A D0			JSR	CALL_CMD		; call load command
  7168 D0B3 90 40			BCC	CLEAR_BASE		; load interrupted, exit
  7169 D0B5 AE 00 20			LDX	Ram_base-1
  7170 D0B8 86 3B			STX	Svarl
  7171 D0BA AE 01 20			LDX	Ram_base
  7172 D0BD 86 3C			STX	Svarh
  7173 D0BF 20 F5 D0			JSR	CLEAR_BASE
  7174 D0C2 4C 4B B3			JMP	LAB_147A
  7175
  7176 				; perform SAVE ****************************
  7177 D0C5			LAB_SAVE
  7178 D0C5 D0 04			BNE	SAVE_DEV		; if no following token use device 0
  7179 D0C7 A9 00			LDA	#$00			; set device id = 0
  7180 D0C9 F0 03			BEQ	SET_SAVEADR
  7181 D0CB			SAVE_DEV
  7182 D0CB 20 61 D0			JSR	LAB_GETDEVPARM		; get device id
  7183 D0CE			SET_SAVEADR
  7184 D0CE 48				PHA
  7185 D0CF A2 00			LDX	#$00			; Basic-files start at $2000
  7186 D0D1 86 FA			STX	ADRL			; Start of File pointer LSB, needed by XModem routines
  7187 D0D3 A2 20			LDX	#$20			
  7188 D0D5 86 FB			STX	ADRH			; Start of File pointer MSB, needed by XModem routines
  7189 D0D7 A6 3B			LDX	Svarl
  7190 D0D9 8E 00 20			STX	Ram_base-1
  7191 D0DC 86 F8			STX	NUML			; End-address File pointer LSB, needed by XModem routines
  7192 D0DE A6 3C			LDX	Svarh
  7193 D0E0 8E 01 20			STX	Ram_base
  7194 D0E3 86 F9			STX	NUMH			; End-address File pointer MSB, needed by XModem routines
  7195 D0E5 09 20			ORA	#$20			; Disk-devices
  7196 D0E7 20 AA E1			JSR	OPEN_DEVICE		; Open Device for Read/Write
  7197 D0EA 68				PLA
  7198 D0EB F0 03			BEQ	CALL_SAVE
  7199 D0ED 20 3D D0			JSR	LAB_GETSTRPARM		; X,Y = Ptr to Filename
  7200 D0F0			CALL_SAVE
  7201 D0F0 A9 21			LDA	#CMD_SAVE
  7202 D0F2 20 3A D0			JSR	CALL_CMD		; Device-driver Write
  7203 D0F5			CLEAR_BASE
  7204 D0F5 A2 00			LDX	#$00
  7205 D0F7 8E 00 20			STX	Ram_base-1
  7206 D0FA 8E 01 20			STX	Ram_base
  7207 D0FD 60				RTS
  7208 					
  7209 				; 'BEEP' command **************************
  7210 D0FE			LAB_JC001
  7211 D0FE 6C 66 1A			JMP 	(STDBEEP)		; Jump to Junior Computer standard BEEP routine
  7212
  7213 				; perform BEEP ****************************
  7214 D101			LAB_BEEP
  7215 D101 F0 FB			BEQ 	LAB_JC001		; if no following token go do 'BEEP'
  7216 D103 60				RTS
  7217
  7218 D104			LAB_SYSBEEP
  7219 D104 48				PHA
  7220 D105 98				TYA
  7221 D106 48				PHA
  7222 D107 8A				TXA
  7223 D108 48				PHA
  7224 D109 20 FE D0			JSR	LAB_JC001
  7225 D10C 68				PLA
  7226 D10D AA				TAX
  7227 D10E 68				PLA
  7228 D10F A8				TAY
  7229 D110 68				PLA
  7230 D111 60				RTS	
  7231 					
  7232 				; perform PLIST ***************************
  7233 				; #### TODO: save current output device and restore pointer after list command !!!!!!!
  7234 D112			LAB_PLIST
  7235 D112 48			    	PHA				; save token
  7236 D113 AD 76 1A		    	LDA	STDPRINTDEV		; get standard printer id
  7237 D116 20 18 E0			JSR	SET_STDOUTID		; and set it as standard output device
  7238 D119 68				PLA				; restore token
  7239 D11A 20 7A B3			JSR 	LAB_LIST		; call list command
  7240 D11D AD 75 1A			LDA	STDOUTDEV		; get standard output device id
  7241 D120 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device and return
  7242
  7243 				; perform DOS ****************************
  7244 D123			LAB_DOS					; If no DOS is loaded, this could hang the system!
  7245 D123 6C 0A 18			JMP 	(RETURN_VECT)		; Return to DOS through return vector
  7246
  7247 				; perform HOME ****************************
  7248 D126			LAB_HOME
  7249 D126 A9 05			LDA	#CMD_HOME		; Call Junior Computer standard HOME routine
  7250 D128 D0 0E			BNE	STDCMD_JMP		; branch always
  7251
  7252 				; perform CLS *****************************
  7253 D12A			LAB_CLS
  7254 D12A A9 07			LDA	#CMD_CLRSCRN		; Call Junior Computer standard CLS routine
  7255 D12C D0 0A			BNE	STDCMD_JMP		; branch always
  7256
  7257 				; perform NORMAL **************************
  7258 D12E			LAB_NORMAL
  7259 D12E A9 02			LDA	#CMD_NORMAL		; Call Junior Computer standard NORMAL routine
  7260 D130 D0 06			BNE	STDCMD_JMP		; branch always
  7261
  7262 				; perform INVERSE *************************
  7263 D132			LAB_INVERSE
  7264 D132 A9 03			LDA	#CMD_INVERSE		; Call Junior Computer standard INVERSE routine
  7265 D134 D0 02			BNE	STDCMD_JMP		; branch always
  7266
  7267 				; perform FLASH ***************************
  7268 D136			LAB_FLASH
  7269 D136 A9 04			LDA	#CMD_FLASH		; Call Junior Computer standard FLASH routine
  7270 D138			STDCMD_JMP
  7271 D138 6C 72 1A			JMP 	(STDCMD)		; call STDOUT routine
  7272 					
  7273 				; perform LOCATE **************************
  7274 D13B			LAB_LOCATE
  7275 D13B F0 70			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7276 D13D 20 72 D0			JSR	LAB_GET2BYTEPARMS	; get two byte parameters into X and Y
  7277 D140 A9 08			LDA	#CMD_SETCURSOR
  7278 D142 6C 72 1A			JMP 	(STDCMD)		; Call Junior Computer standard SETCURSOR routine
  7279
  7280 				; perform IN# *****************************
  7281 D145			LAB_INNUM
  7282 D145 F0 66			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7283 D147 20 82 D0			JSR	LAB_GETDEVID
  7284 D14A 4C 2F E0			JMP	SET_STDINID		; Set Standard In Routine ID
  7285
  7286 				; perform PR# *****************************
  7287 D14D			LAB_PRNUM
  7288 D14D F0 5E			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7289 D14F 20 82 D0			JSR	LAB_GETDEVID
  7290 D152 4C 18 E0			JMP	SET_STDOUTID		; and set it as standard output device
  7291
  7292 				; perform PORTIO ******************************************************************************
  7293 				; Set Port-bits to Input (0) or Output (1). Port number is between 0 and 9.
  7294 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7295 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7296 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7297 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7298 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7299 				; *********************************************************************************************
  7300 D155			LAB_PORTIO
  7301 D155 F0 56			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7302 D157 20 72 D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X = par1 (0=PORTA, 1=PORTB, ..), Y = par2 (value to write)
  7303 D15A 98				TYA				; A = par2, value to write to data dir. register
  7304 D15B E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7305 D15D B0 13			BCS	MCPIO			; branch if not a VIA, might be a MCP23017
  7306 					
  7307 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7308 D15F 48				PHA				; save value to write to DDR register
  7309 D160 8A				TXA				; A = port number 0, 1, 2 or 3
  7310 D161 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7311 D163 09 02			ORA	#$02			; A = 2 (X=1 or X=3) or A = 3 (X=0 or X=2)
  7312 D165 A8				TAY				; Y = DDRB (X=1 or X=3) or Y = DDRA (X=0 or X=2)
  7313 D166 68				PLA				; get value to write back
  7314 					
  7315 D167 E0 02		VIA_WR	CPX	#2			; VIA U5 on IO-board?
  7316 D169 B0 03			BCS	VIA_U15			; branch if it is VIA on JC2 V4.1 main-board
  7317 					
  7318 D16B 91 14			STA	(IOBASE),Y		; store in VIA (U5) of IO board, DDRA (X=0,Y=1) or DDRB (X=1,Y=0) register
  7319 D16D 60				RTS				; return
  7320
  7321 D16E			VIA_U15	; VIA on new JC2 main-board (V4.1), is has a fixed address of $1750-$175F
  7322 D16E 99 50 17			STA	$1750,Y			; Y = 2 or 3, VIA on JC2 V4.1 main-board, fixed address $1750
  7323 D171 60			LPIO_X	RTS
  7324
  7325 D172			MCPIO	; X > 4, either a MCP23017 or a port number error
  7326 D172 E0 0A			CPX	#10
  7327 D174 B0 FB			BCS	LPIO_X			; Error if port number > 9
  7328 					
  7329 					; ------------------------------------------------------------------------------------------
  7330 					; The MCP23017 direction registers are IODIRA ($00) and IODIRB ($01)
  7331 					;
  7332 					; A: value to write to register
  7333 					; X: port number [4..9]
  7334 					; ------------------------------------------------------------------------------------------
  7335 D176 49 FF			EOR	#$FF			; Invert all bytes, since 0 = output for a MCP23017 but input for a VIA
  7336 D178 A8				TAY				; Y = databyte to write into IODIRx register
  7337 D179 8A				TXA				; A = port number [4..9]
  7338 D17A 29 FE			AND	#$FE			; clear bit 0 of port number, A is now 4, 6 or 8
  7339 D17C 18				CLC
  7340 D17D 69 3C			ADC	#MCP23017_I2C_0-4	; A = $40 (ports 4 & 5), $42 (ports 6 & 7) or $44 (ports 8 & 9)
  7341 D17F 48				PHA				; save I2C-address
  7342 D180 8A				TXA				; A = port number [4..9]
  7343 D181 29 01			AND	#$01			; A = 0 or 1
  7344 D183 AA				TAX				; X = 0 (IODIRA) or 1 (IODIRB)
  7345 D184 68				PLA				; Get I2C-address back
  7346 D185 4C 96 ED			JMP 	MCP23017_WRITE		; A = I2C-addr, X = register, Y = data to write and return
  7347 					
  7348 				;--------------------------------------------------------------------------------------------- 
  7349 				; Input  : X: Port number for MCP23017 ICs [4..9]
  7350 				; Outputs: A: I2C-address of MCP23017: $40, $42 or $44
  7351 				;          X: $12 (GPIOA) or $13 (GPIOB)
  7352 				;--------------------------------------------------------------------------------------------- 
  7353 D188			PORT2GPIO
  7354 D188 8A				TXA				; A = port number [4..9]
  7355 D189 29 FE			AND	#$FE			; clear bit 0 of I2C-address
  7356 D18B 18				CLC
  7357 D18C 69 3C			ADC	#MCP23017_I2C_0-4	; A = $40 (ports 4 & 5), $42 (ports 6 & 7) or $44 (ports 8 & 9)
  7358 D18E 48				PHA				; save I2C-address
  7359 D18F 8A				TXA				; A = port number [4..9]
  7360 D190 29 01			AND	#$01			; A = 0 or 1
  7361 D192 18				CLC
  7362 D193 69 12			ADC	#GPIOA			; $12 = GPIOA
  7363 D195 AA				TAX				; X = $12 (GPIOA) or 1 (GPIOB)
  7364 D196 68				PLA				; Get I2C-address back
  7365 D197 60				RTS				; return
  7366 					
  7367 				; perform PORTOUT ****************************************************************************
  7368 				; Write Port outputbits. Port number is between 0 and 9.
  7369 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7370 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7371 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7372 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7373 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7374 				; *********************************************************************************************
  7375 D198			LAB_PORTOUT
  7376 D198 F0 13			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7377 D19A 20 72 D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X = par1 (0=PORTA, 1=PORTB, ..), Y = par2 (value to write)
  7378 D19D 98				TYA				; A = par2, value to write to data dir. register
  7379 D19E E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7380 D1A0 B0 0E			BCS	MCP_OUT			; branch if not a VIA, might be a MCP23017
  7381
  7382 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7383 D1A2 48				PHA				; save value to write to DDR register
  7384 D1A3 8A				TXA				; A = port number 0, 1, 2 or 3
  7385 D1A4 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7386 D1A6 29 01			AND	#$01			; A = 0 (X=1 or X=3) or A = 1 (X=0 or X=2)
  7387 D1A8 A8				TAY				; Y = PORTB (X=1 or X=3) or Y = PORTA (X=0 or X=2)
  7388 D1A9 68				PLA				; get value to write back
  7389 D1AA 4C 67 D1			JMP	VIA_WR			; Write value into VIA PORTA or PORTB register
  7390
  7391 D1AD			LAB_SYNTAX_ERR
  7392 D1AD 4C BD BB			JMP	LAB_SNER		; throw syntax error and return
  7393
  7394 D1B0			MCP_OUT	; X > 4, either a MCP23017 or a port number error
  7395 D1B0 E0 0A			CPX	#10
  7396 D1B2 B0 BD			BCS	LPIO_X			; Error if port number > 9
  7397
  7398 					; ------------------------------------------------------------------------------------------
  7399 					; The MCP23017 output registers are GPIOA ($12) and GPIOB ($13)
  7400 					; A: value to write to register
  7401 					; X: port number [4..9]
  7402 					; ------------------------------------------------------------------------------------------
  7403 D1B4 A8				TAY				; Y = databyte to write into GPIOx register
  7404 D1B5 20 88 D1			JSR	PORT2GPIO		; Returns A=I2C-address, X= GPIOA or GPIOB
  7405 D1B8 4C 96 ED			JMP 	MCP23017_WRITE		; A = I2C-addr, X = register, Y = data to write and return
  7406
  7407 				; perform I2C write operations ************
  7408 D1BB			LAB_I2COUT
  7409 D1BB F0 F0			BEQ	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7410 D1BD 20 72 D0			JSR	LAB_GET2BYTEPARMS	; get two parameters: X=addr, Y=ctrl
  7411 D1C0 86 1A			STX	Temp1			; Temp1=X=addr/data byte
  7412 D1C2 98				TYA				; A=ctrl byte
  7413 D1C3 C9 01			CMP	#I2C_STA		; I2C-start?
  7414 D1C5 D0 08			BNE	I2C_WR			; branch if not I2C-start
  7415 					
  7416 D1C7 20 26 E3			JSR	I2C_START		; send start condition (affects A and Y)
  7417 D1CA E0 00			CPX	#$00			; Is address byte 0?
  7418 D1CC D0 01			BNE	I2C_WR			; branch if address byte > 0
  7419 D1CE 60				RTS				; otherwise, just return
  7420
  7421 D1CF A5 1A		I2C_WR	LDA	Temp1			; restore data byte to A
  7422 D1D1 20 67 E3			JSR	I2C_SEND		; I2C-write: write byte
  7423 D1D4 90 04			BCC	SET_NAK			; C=0: NACK, C=1: ACK, branch if NACK
  7424
  7425 D1D6 A9 00			LDA	#0			; return I2C ACK (0)
  7426 D1D8 F0 02			BEQ	SV_NAK			; branch always
  7427 D1DA A9 01		SET_NAK	LDA	#1			; return I2C NACK (1)
  7428 D1DC 8D 0C 18		SV_NAK	STA	I2Cstat			; save in I2C status
  7429 D1DF 60				RTS
  7430
  7431 				; perform I2C read operations ************
  7432 D1E0			LAB_I2CIN
  7433 D1E0 20 BC C4			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer (Itempl)
  7434 D1E3 A5 11			LDA	Itempl			; get byte via temporary integer
  7435 D1E5 C9 03			CMP	#I2C_STO		; I2C-stop command only?
  7436 D1E7 F0 18			BEQ	I2C_STOP_CMD		; branch if stop-command only
  7437
  7438 D1E9 C9 00			CMP	#I2C_STAT		; Return I2Cstat result?
  7439 D1EB F0 17			BEQ	I2C_RD_X		; branch if I2Cstat return only
  7440
  7441 D1ED 20 9F E3			JSR	I2C_RCV			; I2C-read: receive byte 
  7442 D1F0 8D 0C 18			STA	I2Cstat			; save received byte
  7443 D1F3 A5 11			LDA	Itempl			; get ctrl byte back
  7444 D1F5 C9 01			CMP	#I2C_RD_ACK		; Read followed by ACK?
  7445 D1F7 D0 05			BNE	RD_NAK			; branch if not an ACK
  7446 					
  7447 D1F9 20 44 E3			JSR	I2C_ACK			; send ACK (more bytes to read) and return
  7448 D1FC D0 06			BNE	I2C_RD_X		; branch always
  7449 					
  7450 D1FE 20 53 E3		RD_NAK	JSR	I2C_NACK		; send NACK (done reading)
  7451 D201			I2C_STOP_CMD
  7452 D201 20 35 E3			JSR	I2C_STOP		; send I2C-stop Command
  7453 D204			I2C_RD_X
  7454 D204 AC 0C 18			LDY	I2Cstat			; load I2C-status byte in Y
  7455 D207 4C 2F C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7456 					
  7457 				; perform PORTIN *****************************************************************************
  7458 				; Read Port inputbits. Port number is between 0 and 9.
  7459 				; Port 0,1: PORTA, PORTB on VIA U5 on IO-board
  7460 				; Port 2,3: PORTA, PORTB on VIA U15 on JC2 V4.1 main-board (not present on V3.1 main-board)
  7461 				; Port 4,5: PORTA, PORTB on MCP23017 with I2C-address $40
  7462 				; Port 6,7: PORTA, PORTB on MCP23017 with I2C-address $42
  7463 				; Port 8,9: PORTA, PORTB on MCP23017 with I2C-address $44
  7464 				; *********************************************************************************************
  7465 D20A			LAB_PORTIN
  7466 D20A 20 5A C4			JSR	LAB_EVBY		; evaluate byte expression, result in X
  7467 D20D E0 04			CPX	#4			; Is it a VIA (U5 on IO-board or U15 on JC2 V4.1 main board)?
  7468 D20F B0 16			BCS	MCP_IN			; branch if not a VIA, might be a MCP23017
  7469
  7470 					; X = 0, 1, 2 or 3. Either VIA U5 on IO-board or VIA U15 on JC2 V4.1 main-board
  7471 D211 8A				TXA				; A = port number 0, 1, 2 or 3
  7472 D212 49 01			EOR	#$01			; A = 0->1, A=1->0, A=2->3, A=3->2
  7473 D214 29 01			AND	#$01			; A = 0 (X=1 or X=3) or A = 1 (X=0 or X=2)
  7474 D216 A8				TAY				; Y = PORTB (X=1 or X=3) or Y = PORTA (X=0 or X=2)
  7475 D217 E0 02			CPX	#2			; VIA U5 on IO-board?
  7476 D219 B0 05			BCS	U15_IN			; branch if it is VIA on JC2 V4.1 main-board
  7477 					
  7478 D21B B1 14			LDA	(IOBASE),Y		; Load from VIA (U5), PORTA (X=0) or PORTB (X=1)
  7479 D21D 4C 23 D2			JMP	PIN_X			; convert byte and return it
  7480
  7481 D220			U15_IN	; VIA on new JC2 main-board (V4.1), is has a fixed address of $1750-$175F
  7482 D220 B9 50 17			LDA	$1750,Y			; Y = 0 or 1, VIA on JC2 V4.1 main-board
  7483 D223 A8			PIN_X	TAY				; copy received byte into Y
  7484 D224 4C 2F C0			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  7485 					
  7486 D227 E0 0A		MCP_IN	CPX	#10
  7487 D229 90 01			BCC	MCPRC			; Continue if port number < 10
  7488
  7489 D22B 60				RTS				; return if port number > 9
  7490 					
  7491 					; ------------------------------------------------------------------------------------------
  7492 					; The MCP23017 input registers are GPIOA ($12) and GPIOB ($13)
  7493 					; X: port number [4..9]
  7494 					; ------------------------------------------------------------------------------------------
  7495 D22C 20 88 D1		MCPRC	JSR	PORT2GPIO		; Returns A=I2C-address, X= GPIOA or GPIOB
  7496 D22F 20 B5 ED			JSR	MCP23017_READ		; A = I2C-address of MCP23017 ($40, $42 or $44), X = register to read from
  7497 D232 4C 23 D2			JMP	PIN_X			; convert byte and return
  7498 					
  7499 				; perform DELAY *************************
  7500 D235			LAB_DELAY
  7501 D235 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7502 									; else do type mismatch
  7503 D238 20 5F BE			JSR	LAB_EVPI		; evaluate positive integer expression
  7504 D23B A5 15			LDA	IOBASE+1
  7505 D23D F0 2F			BEQ	LAB_DELAY_OLD		; check if IO is available (needed for RAM based EhBasic only)
  7506 D23F A0 0E			LDY	#VIA_IER		; select interrupt enable register
  7507 D241 A9 7F			LDA	#$7F
  7508 D243 91 14			STA	(IOBASE),Y		; disable all VIA2 interrupts
  7509 D245			LAB_DELAY_LOOP
  7510 D245 A0 08			LDY	#VIA_T2CL		; select Timer2 lower byte register
  7511 D247 A9 E8			LDA	#$E8			; set Timer2
  7512 D249 91 14			STA	(IOBASE),Y		; store timer low value
  7513 D24B A9 03			LDA	#$03
  7514 D24D C8				INY				; select Timer2 higher byte register
  7515 D24E 91 14			STA	(IOBASE),Y		; store timer high value and start timer
  7516 D250 A0 0D			LDY	#VIA_IFR		; select interrupt flag register
  7517 D252 A5 6E			LDA	FAC1_2
  7518 D254 D0 04			BNE	LAB_WAIT_TIMER
  7519 D256 A5 6F			LDA	FAC1_3
  7520 D258 F0 13			BEQ	LAB_DELAY_END
  7521 D25A			LAB_WAIT_TIMER
  7522 D25A B1 14			LDA	(IOBASE),Y
  7523 D25C 29 20			AND	#$20
  7524 D25E F0 FA			BEQ	LAB_WAIT_TIMER
  7525 D260 C6 6F			DEC	FAC1_3
  7526 D262 A5 6F			LDA	FAC1_3
  7527 D264 C9 FF			CMP	#$FF
  7528 D266 D0 DD			BNE	LAB_DELAY_LOOP
  7529 D268 C6 6E			DEC	FAC1_2
  7530 D26A 4C 45 D2			JMP	LAB_DELAY_LOOP
  7531 D26D			LAB_DELAY_END
  7532 D26D 60				RTS
  7533
  7534 D26E			LAB_DELAY_OLD
  7535 D26E A6 6E			LDX	FAC1_2
  7536 D270 F0 FB			BEQ	LAB_DELAY_END
  7537 D272			LAB_SET_TIMER
  7538 D272 A5 6F			LDA	FAC1_3
  7539 D274 20 4D E1			JSR	DELAY			; Delay routine
  7540 D277 A9 FF			LDA	#$FF
  7541 D279 85 6F			STA	FAC1_3
  7542 D27B CA				DEX
  7543 D27C D0 F4			BNE	LAB_SET_TIMER
  7544 D27E 60				RTS
  7545
  7546 				; perform SOUND ****************************************************************************
  7547 				; SOUND sends data to the SN76489 sound-generator.
  7548 				; Syntax: SOUND ch, N, att
  7549 				;   ch = 0, 1, 2, 3: channel number, channel 3 is the noise channel
  7550 				;   N: 1-1023: 10-bit number: frequency = 125000/N for ch = 0, 1 or 2
  7551 				;      000-111 bit 2 = FB (0 = Periodic, 1= White Noise), bit 1 = NF0, bit 0 = NF1
  7552 				;   att: attenutation: 0 = 0 dB, 1 = 2 dB ... 14 = 28 dB, 15 = OFF
  7553 				; *********************************************************************************************
  7554 D27F			LAB_SOUND
  7555 D27F D0 03			BNE	SND_CONT		; branch if tokens present
  7556 D281 4C AD D1			JMP	LAB_SYNTAX_ERR		; if no following token, exit and throw syntax error
  7557 D284			SND_CONT
  7558 D284 20 57 C4			JSR	LAB_GTBY		; get first byte parameter (ch) into X
  7559 D287 8A				TXA				; A = channel number
  7560 D288 29 03			AND	#$03			; Only channels 0-3 are allowed
  7561 D28A 85 1A			STA	Temp1			; Temp1 = channel number 
  7562 D28C 20 B9 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7563
  7564 D28F 20 88 BA			JSR	LAB_EVNM		; evaluate expression and check if numeric, else do type mismatch
  7565 D292 20 BC C4			JSR	LAB_F2FX		; convert floating-to-fixed
  7566 D295 84 57			STY	Frnxtl			; save pointer low byte (float to fixed returns word in AY)
  7567 D297 29 03			AND	#$03			; only bits 9 and 8 are valid
  7568 D299 85 58			STA	Frnxth			; save pointer high byte
  7569 D29B 20 B9 BB			JSR	LAB_1C01		; check for ',' else syntax error
  7570 D29E A6 1A			LDX	Temp1			; Get channel number
  7571 D2A0 E0 03			CPX	#3			; ch 3 = noise-channel
  7572 D2A2 B0 0B			BCS	NOISE_CH		; branch if noise-channel
  7573
  7574 D2A4 8A				TXA				; A = channel number: 0, 1 or 2
  7575 D2A5 A6 57			LDX	Frnxtl			; Get frequency low byte
  7576 D2A7 A4 58			LDY	Frnxth			; Get frequency bits 9 and 8
  7577 D2A9 20 FB E3			JSR	SOUND_SETFREQ		; A - Channel (0..2), X - Freq. LSB 7..0, Y - Freq. MSB 9..8
  7578 D2AC 4C B8 D2			JMP	SEND_ATTN		; branch always
  7579
  7580 D2AF			NOISE_CH				; Channel 3, noise channel
  7581 D2AF A5 57			LDA	Frnxtl			; 000-111 bit 2 = FB (0 = Periodic, 1= White Noise), bit 1 = NF0, bit 0 = NF1  
  7582 D2B1 29 07			AND	#$07			; Only use bits 2-0
  7583 D2B3 09 E0			ORA	#$E0			; Noise control register
  7584 D2B5 20 BB E3			JSR	SOUND_SENDBYTE		; send complete command byte to the sound chip
  7585
  7586 D2B8			SEND_ATTN				; Send attenuation to SN76489
  7587 D2B8 20 57 C4			JSR	LAB_GTBY		; get 3rd byte parameter (att) into X
  7588 D2BB 8A				TXA				; A = attenuation
  7589 D2BC 29 0F			AND	#$0F			; Only 0-15 is allowed
  7590 D2BE AA				TAX				; X = attenuation [0..15]
  7591 D2BF A5 1A			LDA	Temp1			; A = channel number
  7592 D2C1 4C DC E3			JMP	SOUND_SETATN		; A = channel [0..3], X = att. level [0..15] and return
  7593
  7594 				; *****************************************
  7595
  7596 D2C4			LAB_SCREEN	
  7597 D2C4			LAB_PIXEL
  7598 D2C4			LAB_LINE	
  7599 D2C4			LAB_OVAL
  7600 D2C4			LAB_COLOR
  7601 D2C4			LAB_RECT
  7602 							
  7603 D2C4			LAB_RES1
  7604 D2C4			LAB_RES2
  7605 D2C4			LAB_RES3
  7606 D2C4			LAB_RES4
  7607 D2C4			LAB_RES5
  7608 D2C4			LAB_RES6
  7609 D2C4 60				RTS
  7610
  7611 				; **** end of new commands ****
  7612
  7613 				; system dependent i/o vectors
  7614 				; these are in RAM and are set by the monitor at start-up
  7615
  7616 D2C5 6C 6E 1A		V_INPT	JMP	(STDIN)			; non halting scan input device vector (Junior Computer 2)
  7617 D2C8 6C 70 1A		V_OUTP	JMP	(STDOUT)		; send byte to output device vector (Junior Computer 2)
  7618
  7619 				; The rest are tables messages and code for RAM
  7620 				; the rest of the code is tables and BASIC start-up code
  7621
  7622 D2CB			PG2_TABS
  7623 D2CB 00				.byte	$00			; ctrl-c flag		-	$00 = enabled
  7624 D2CC 00				.byte	$00			; ctrl-c byte		-	GET needs this
  7625 D2CD 00				.byte	$00			; ctrl-c byte timeout	-	GET needs this
  7626 D2CE 7C CE			.word	CTRLC			; ctrl c check vector
  7627 D2D0			PG2_TABE
  7628
  7629 				; character get subroutine for zero page
  7630
  7631 				; For a 1.8432MHz 6502 including the JSR and RTS
  7632 				; fastest (>=':')	=  29 cycles =  15.7uS
  7633 				; slowest (<':')	=  40 cycles =  21.7uS
  7634 				; space skip	= +21 cycles = +11.4uS
  7635 				; inc across page	=  +4 cycles =  +2.2uS
  7636
  7637 				; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7638 				; block is copied to it's destination, any non zero page address will do at assembly
  7639 				; time, to assemble a three byte instruction.
  7640
  7641 				; page 0 initialisation table from $BC
  7642 				; increment and scan memory
  7643 D2D0			LAB_2CEE
  7644 D2D0 E6 83			INC	Bpntrl			; increment BASIC execute pointer low byte
  7645 D2D2 D0 02			BNE	LAB_2CF4		; branch if no carry
  7646 									; else
  7647 D2D4 E6 84			INC	Bpntrh			; increment BASIC execute pointer high byte
  7648
  7649 				; page 0 initialisation table from $C2
  7650 				; scan memory
  7651 D2D6			LAB_2CF4
  7652 D2D6 AD FF FF			LDA	$FFFF			; get byte to scan (addr set by call routine)
  7653 D2D9 C9 C1			CMP	#TK_ELSE		; compare with the token for ELSE
  7654 D2DB F0 0E			BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
  7655
  7656 D2DD C9 3A			CMP	#':'			; compare with ':'
  7657 D2DF B0 0A			BCS	LAB_2D05		; exit if >= ':', not numeric, carry set
  7658
  7659 D2E1 C9 20			CMP	#' '			; compare with ' '
  7660 D2E3 F0 EB			BEQ	LAB_2CEE		; if ' ' go do next
  7661
  7662 D2E5 38				SEC				; set carry for SBC
  7663 D2E6 E9 30			SBC	#'0'			; subtract '0'
  7664 D2E8 38				SEC				; set carry for SBC
  7665 D2E9 E9 D0			SBC	#$D0			; subtract -'0'
  7666 									; clear carry if byte = '0'-'9'
  7667 D2EB			LAB_2D05
  7668 D2EB 60				RTS
  7669
  7670 				; page zero initialisation table $0A-$12 (9 bytes) inclusive
  7671 D2EC			StrTab
  7672 D2EC 4C				.byte	$4C			; Usrjmp, JMP opcode
  7673 D2ED E6 BE			.word	LAB_FCER		; Usrjpl/h, initial user function vector ('Function call' error)
  7674 D2EF 00				.byte	$00			; Nullct, default NULL count
  7675 D2F0 00				.byte	$00			; Tpos, clear terminal position
  7676 D2F1 00				.byte	$00			; Twidth, default terminal width byte
  7677 D2F2 F2				.byte	$F2			; Iclim, default limit for TAB = 14
  7678 D2F3 01 20			.word	Ram_base		; Itempl/h, Start of user RAM
  7679 D2F5			EndTab
  7680
  7681 D2F5			LAB_MSZM
  7682 D2F5 45 6E 68 61 6E 63 + 	.by	'Enhanced BASIC 2.30',$0A,$00
  7683
  7684 D30A			LAB_SMSG
  7685 D30A 20 42 61 73 69 63 + 	.by	' Basic Bytes free',$0D,$0A,$0A,$00
  7686
  7687 				; numeric constants and series
  7688
  7689 									; constants and series for LOG(n)
  7690 D31F			LAB_25A0
  7691 D31F 02				.byte	$02			; counter
  7692 D320 80 19 56 62			.byte	$80,$19,$56,$62		; 0.59898
  7693 D324 80 76 22 F3			.byte	$80,$76,$22,$F3		; 0.96147
  7694 				;##	.byte	$80,$76,$22,$F1		; 0.96147
  7695 D328 82 38 AA 40			.byte	$82,$38,$AA,$40		; 2.88539
  7696 				;##	.byte	$82,$38,$AA,$45		; 2.88539
  7697
  7698 D32C			LAB_25AD
  7699 D32C 80 35 04 F3			.byte	$80,$35,$04,$F3		; 0.70711	1/root 2
  7700 D330			LAB_25B1
  7701 D330 81 35 04 F3			.byte	$81,$35,$04,$F3		; 1.41421	root 2
  7702 D334			LAB_25B5
  7703 D334 80 80 00 00			.byte	$80,$80,$00,$00		; -0.5
  7704 D338			LAB_25B9
  7705 D338 80 31 72 18			.byte	$80,$31,$72,$18		; 0.69315	LOG(2)
  7706
  7707 									; numeric PRINT constants
  7708 D33C			LAB_2947
  7709 D33C 91 43 4F F8			.byte	$91,$43,$4F,$F8		; 99999.9375 (max value with at least one decimal)
  7710 D340			LAB_294B
  7711 D340 94 74 23 F7			.byte	$94,$74,$23,$F7		; 999999.4375 (max value before scientific notation)
  7712 D344			LAB_294F
  7713 D344 94 74 24 00			.byte	$94,$74,$24,$00		; 1000000
  7714
  7715 									; EXP(n) constants and series
  7716 D348			LAB_2AFA
  7717 D348 81 38 AA 3B			.byte	$81,$38,$AA,$3B		; 1.4427	(1/LOG base 2 e)
  7718 D34C			LAB_2AFE
  7719 D34C 06				.byte	$06			; counter
  7720 D34D 74 63 90 8C			.byte	$74,$63,$90,$8C		; 2.17023e-4
  7721 D351 77 23 0C AB			.byte	$77,$23,$0C,$AB		; 0.00124
  7722 D355 7A 1E 94 00			.byte	$7A,$1E,$94,$00		; 0.00968
  7723 D359 7C 63 42 80			.byte	$7C,$63,$42,$80		; 0.05548
  7724 D35D 7E 75 FE D0			.byte	$7E,$75,$FE,$D0		; 0.24023
  7725 D361 80 31 72 15			.byte	$80,$31,$72,$15		; 0.69315
  7726 D365 81 00 00 00			.byte	$81,$00,$00,$00		; 1.00000
  7727
  7728 				;##	.byte	$07			; counter
  7729 				;##	.byte	$74,$94,$2E,$40		; -1/7! (-1/5040)
  7730 				;##	.byte	$77,$2E,$4F,$70		;  1/6! ( 1/720)
  7731 				;##	.byte	$7A,$88,$02,$6E		; -1/5! (-1/120)
  7732 				;##	.byte	$7C,$2A,$A0,$E6		;  1/4! ( 1/24)
  7733 				;##	.byte	$7E,$AA,$AA,$50		; -1/3! (-1/6)
  7734 				;##	.byte	$7F,$7F,$FF,$FF		;  1/2! ( 1/2)
  7735 				;##	.byte	$81,$80,$00,$00		; -1/1! (-1/1)
  7736 				;##	.byte	$81,$00,$00,$00		;  1/0! ( 1/1)
  7737
  7738 									; trigonometric constants and series
  7739 D369			LAB_2C78
  7740 D369 81 49 0F DB			.byte	$81,$49,$0F,$DB		; 1.570796371 (pi/2) as floating #
  7741 D36D			LAB_2C84
  7742 D36D 04				.byte	$04			; counter
  7743 D36E 86 1E D7 FB			.byte	$86,$1E,$D7,$FB		; 39.7109
  7744 				;##	.byte	$86,$1E,$D7,$BA		; 39.7109
  7745 D372 87 99 26 65			.byte	$87,$99,$26,$65		;-76.575
  7746 				;##	.byte	$87,$99,$26,$64		;-76.575
  7747 D376 87 23 34 58			.byte	$87,$23,$34,$58		; 81.6022
  7748 D37A 86 A5 5D E1			.byte	$86,$A5,$5D,$E1		;-41.3417
  7749 				;##	.byte	$86,$A5,$5D,$E0		;-41.3417
  7750 D37E			LAB_2C7C
  7751 D37E 83 49 0F DB			.byte	$83,$49,$0F,$DB		; 6.28319 (2*pi) as floating #
  7752 				;##	.byte	$83,$49,$0F,$DA		; 6.28319 (2*pi) as floating #
  7753
  7754 D382			LAB_2CC9
  7755 D382 08				.byte	$08			; counter
  7756 D383 78 3A C5 37			.byte	$78,$3A,$C5,$37		; 0.00285
  7757 D387 7B 83 A2 5C			.byte	$7B,$83,$A2,$5C		;-0.0160686
  7758 D38B 7C 2E DD 4D			.byte	$7C,$2E,$DD,$4D		; 0.0426915
  7759 D38F 7D 99 B0 1E			.byte	$7D,$99,$B0,$1E		;-0.0750429
  7760 D393 7D 59 ED 24			.byte	$7D,$59,$ED,$24		; 0.106409
  7761 D397 7E 91 72 00			.byte	$7E,$91,$72,$00		;-0.142036
  7762 D39B 7E 4C B9 73			.byte	$7E,$4C,$B9,$73		; 0.199926
  7763 D39F 7F AA AA 53			.byte	$7F,$AA,$AA,$53		;-0.333331
  7764
  7765 				;##	.byte	$08			; counter
  7766 				;##	.byte	$78,$3B,$D7,$4A		; 1/17
  7767 				;##	.byte	$7B,$84,$6E,$02		;-1/15
  7768 				;##	.byte	$7C,$2F,$C1,$FE		; 1/13
  7769 				;##	.byte	$7D,$9A,$31,$74		;-1/11
  7770 				;##	.byte	$7D,$5A,$3D,$84		; 1/9
  7771 				;##	.byte	$7E,$91,$7F,$C8		;-1/7
  7772 				;##	.byte	$7E,$4C,$BB,$E4		; 1/5
  7773 				;##	.byte	$7F,$AA,$AA,$6C		;-1/3
  7774
  7775 = D3A4			LAB_1D96	= *+1			; $00,$00 used for undefined variables
  7776 D3A3			LAB_259C
  7777 D3A3 81 00 00 00			.byte	$81,$00,$00,$00		; 1.000000, used for INC
  7778 D3A7			LAB_2AFD
  7779 D3A7 81 80 00 00			.byte	$81,$80,$00,$00		; -1.00000, used for DEC. must be on the same page as +1.00
  7780
  7781 									; misc constants
  7782 D3AB			LAB_1DF7
  7783 D3AB 90				.byte	$90			;-32768 (uses first three bytes from 0.5)
  7784 D3AC			LAB_2A96
  7785 D3AC 80 00 00 00			.byte	$80,$00,$00,$00		; 0.5
  7786 D3B0			LAB_2C80
  7787 D3B0 7F 00 00 00			.byte	$7F,$00,$00,$00		; 0.25
  7788 D3B4			LAB_26B5
  7789 D3B4 84 20 00 00			.byte	$84,$20,$00,$00		; 10.0000 divide by 10 constant
  7790
  7791 				; This table is used in converting numbers to ASCII.
  7792 D3B8			LAB_2A9A
  7793 = D3B9			LAB_2A9B = LAB_2A9A+1
  7794 = D3BA			LAB_2A9C = LAB_2A9B+1
  7795 D3B8 FE 79 60			.byte	$FE,$79,$60		; -100000
  7796 D3BB 00 27 10			.byte	$00,$27,$10		; 10000
  7797 D3BE FF FC 18			.byte	$FF,$FC,$18		; -1000
  7798 D3C1 00 00 64			.byte	$00,$00,$64		; 100
  7799 D3C4 FF FF F6			.byte	$FF,$FF,$F6		; -10
  7800 D3C7 00 00 01			.byte	$00,$00,$01		; 1
  7801
  7802 D3CA			LAB_CTBL
  7803 D3CA EF B4			.word	LAB_END-1		; END
  7804 D3CC 2E B4			.word	LAB_FOR-1		; FOR
  7805 D3CE 1F BA			.word	LAB_NEXT-1		; NEXT
  7806 D3D0 52 B6			.word	LAB_DATA-1		; DATA
  7807 D3D2 02 B9			.word	LAB_INPUT-1		; INPUT
  7808 D3D4 1B BD			.word	LAB_DIM-1		; DIM
  7809 D3D6 21 B9			.word	LAB_READ-1		; READ
  7810 D3D8 6F B7			.word	LAB_LET-1		; LET
  7811 D3DA 41 B7			.word	LAB_DEC-1		; DEC		new command
  7812 D3DC B1 B5			.word	LAB_GOTO-1		; GOTO
  7813 D3DE 70 B5			.word	LAB_RUN-1		; RUN
  7814 D3E0 80 B6			.word	LAB_IF-1		; IF
  7815 D3E2 10 B5			.word	LAB_RESTORE-1		; RESTORE	modified command
  7816 D3E4 94 B5			.word	LAB_GOSUB-1		; GOSUB
  7817 D3E6 7E D2			.word	LAB_SOUND-1		; SOUND	
  7818 D3E8 C3 D2			.word	LAB_RES2-1		; RET2
  7819 D3EA 3D B6			.word	LAB_RETURN-1		; RETURN
  7820 D3EC E7 B6			.word	LAB_REM-1		; REM
  7821 D3EE ED B4			.word	LAB_STOP-1		; STOP
  7822 D3F0 F0 B6			.word	LAB_ON-1		; ON		modified command
  7823 D3F2 4E B5			.word	LAB_NULL-1		; NULL		modified command
  7824 D3F4 44 B7			.word	LAB_INC-1		; INC		new command
  7825 D3F6 53 C5			.word	LAB_WAIT-1		; WAIT
  7826 D3F8 88 D0			.word	LAB_LOAD-1		; LOAD
  7827 D3FA C4 D0			.word	LAB_SAVE-1		; SAVE
  7828 D3FC 3C C0			.word	LAB_DEF-1		; DEF
  7829 D3FE D8 C4			.word	LAB_POKE-1		; POKE
  7830 D400 F4 C4			.word	LAB_DOKE-1		; DOKE		new command
  7831 D402 41 C5			.word	LAB_CALL-1		; CALL		new command
  7832 D404 7A B5			.word	LAB_DO-1		; DO		new command
  7833 D406 E3 B5			.word	LAB_LOOP-1		; LOOP		new command
  7834 D408 10 B8			.word	LAB_PRINT-1		; PRINT
  7835 D40A 54 B5			.word	LAB_CONT-1		; CONT
  7836 D40C 79 B3			.word	LAB_LIST-1		; LIST
  7837 D40E 76 B3			.word	LAB_CLEAR-1		; CLEAR
  7838 D410 26 B3			.word	LAB_NEW-1		; NEW
  7839 D412 16 CF			.word	LAB_WDTH-1		; WIDTH		new command
  7840 D414 DF B7			.word	LAB_GET-1		; GET		new command
  7841 D416 19 C5			.word	LAB_SWAP-1		; SWAP		new command
  7842 D418 53 CD			.word	LAB_BITSET-1		; BITSET	new command
  7843 D41A 67 CD			.word	LAB_BITCLR-1		; BITCLR	new command
  7844 D41C C3 D2			.word	LAB_RES3-1		; RES3
  7845 D41E C3 D2			.word	LAB_RES4-1		; RES4		
  7846 D420 00 D1			.word	LAB_BEEP-1		; BEEP		new command (Junior Computer 2)
  7847 D422 11 D1			.word	LAB_PLIST-1		; PLIST		new command (Junior Computer 2)
  7848 D424 25 D1			.word	LAB_HOME-1		; HOME		new command (Junior Computer 2)
  7849 D426 29 D1			.word	LAB_CLS-1		; CLS		new command (Junior Computer 2)
  7850 D428 2D D1			.word	LAB_NORMAL-1		; NORMAL	new command (Junior Computer 2)
  7851 D42A 31 D1			.word	LAB_INVERSE-1		; INVERSE	new command (Junior Computer 2)
  7852 D42C 35 D1			.word	LAB_FLASH-1		; FLASH		new command (Junior Computer 2)
  7853 D42E 3A D1			.word	LAB_LOCATE-1		; LOCATE	new command (Junior Computer 2)
  7854 D430 44 D1			.word	LAB_INNUM-1		; IN#		new command (Junior Computer 2)
  7855 D432 4C D1			.word	LAB_PRNUM-1		; PR#		new command (Junior Computer 2)
  7856 D434 54 D1			.word	LAB_PORTIO-1		; PORTIO	new command (Junior Computer 2)
  7857 D436 97 D1			.word	LAB_PORTOUT-1		; PORTOUT	new command (Junior Computer 2)
  7858 D438 C3 D2			.word	LAB_SCREEN-1		; SCREEN	new command (Junior Computer 2)	
  7859 D43A C3 D2			.word	LAB_PIXEL-1		; PIXEL		new command (Junior Computer 2)
  7860 D43C C3 D2			.word	LAB_LINE-1		; LINE		new command (Junior Computer 2)	
  7861 D43E C3 D2			.word	LAB_OVAL-1		; OVAL		new command (Junior Computer 2)	
  7862 D440 C3 D2			.word	LAB_RECT-1		; RECT		new command (Junior Computer 2)	
  7863 D442 C3 D2			.word	LAB_COLOR-1		; COLOR		new command (Junior Computer 2)	
  7864 D444 34 D2			.word	LAB_DELAY-1		; DELAY		new command (Junior Computer 2)	
  7865 D446 BA D1			.word	LAB_I2COUT-1		; I2COUT	new command (Junior Computer 2)
  7866 D448 22 D1			.word	LAB_DOS-1		; DOS		new command (Junior Computer 2)
  7867
  7868 				; function pre process routine table
  7869
  7870 D44A			LAB_FTPL
  7871 = D44B			LAB_FTPM	= LAB_FTPL+$01
  7872 D44A 21 BC			.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
  7873 D44C 21 BC			.word	LAB_PPFN-1		; INT(n)		"
  7874 D44E 21 BC			.word	LAB_PPFN-1		; ABS(n)		"
  7875 D450 A3 BA			.word	LAB_EVEZ-1		; USR(x)	process any expression
  7876 D452 A6 BB			.word	LAB_1BF7-1		; FRE(x)		"
  7877 D454 A6 BB			.word	LAB_1BF7-1		; POS(x)		"
  7878 D456 21 BC			.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
  7879 D458 21 BC			.word	LAB_PPFN-1		; RND(n)		"
  7880 D45A 21 BC			.word	LAB_PPFN-1		; LOG(n)		"
  7881 D45C 21 BC			.word	LAB_PPFN-1		; EXP(n)		"
  7882 D45E 21 BC			.word	LAB_PPFN-1		; COS(n)		"
  7883 D460 21 BC			.word	LAB_PPFN-1		; SIN(n)		"
  7884 D462 21 BC			.word	LAB_PPFN-1		; TAN(n)		"
  7885 D464 21 BC			.word	LAB_PPFN-1		; ATN(n)		"
  7886 D466 21 BC			.word	LAB_PPFN-1		; PEEK(n)		"
  7887 D468 21 BC			.word	LAB_PPFN-1		; DEEK(n)		"
  7888 D46A 00 00			.word	$0000			; SADD()	none
  7889 D46C 1B BC			.word	LAB_PPFS-1		; LEN($)	process string expression in ()
  7890 D46E 21 BC			.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
  7891 D470 1B BC			.word	LAB_PPFS-1		; VAL($)	process string expression in ()
  7892 D472 1B BC			.word	LAB_PPFS-1		; ASC($)		"
  7893 D474 1B BC			.word	LAB_PPFS-1		; UCASE$($)		"
  7894 D476 1B BC			.word	LAB_PPFS-1		; LCASE$($)		"
  7895 D478 21 BC			.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
  7896 D47A 48 BC			.word	LAB_BHSS-1		; HEX$(n)		"
  7897 D47C 48 BC			.word	LAB_BHSS-1		; BIN$(n)		"
  7898 D47E 00 00			.word	$0000			; BITTST()	none
  7899 D480 AD CE			.word	LAB_MMPP-1		; MAX()		process numeric expression
  7900 D482 AD CE			.word	LAB_MMPP-1		; MIN()		"
  7901 D484 27 BC			.word	LAB_PPBI-1		; PI		advance pointer
  7902 D486 27 BC			.word	LAB_PPBI-1		; TWOPI		"
  7903 D488 00 00			.word	$0000			; VARPTR()	none
  7904 D48A 2C BC			.word	LAB_LRMS-1		; LEFT$()	process string expression
  7905 D48C 2C BC			.word	LAB_LRMS-1		; RIGHT$()		"
  7906 D48E 2C BC			.word	LAB_LRMS-1		; MID$()		"
  7907 D490 21 BC			.word	LAB_PPFN-1		; PORTIN(n)	process string expression in ()
  7908 D492 21 BC			.word	LAB_PPFN-1		; I2CIN(n)	process string expression in ()
  7909 D494 00 00			.word	$0000			; RESERVED	none TEMP
  7910 D496 00 00			.word	$0000			; RESERVED	none TEMP
  7911
  7912 				; action addresses for functions
  7913 D498			LAB_FTBL
  7914 = D499			LAB_FTBM	= LAB_FTBL+$01
  7915 D498 C1 C8			.word	LAB_SGN-1		; SGN()
  7916 D49A 4B C9			.word	LAB_INT-1		; INT()
  7917 D49C DE C8			.word	LAB_ABS-1		; ABS()
  7918 D49E 1E CD			.word	LAB_USR-1		; USR()
  7919 D4A0 01 C0			.word	LAB_FRE-1		; FRE()
  7920 D4A2 2C C0			.word	LAB_POS-1		; POS()
  7921 D4A4 6C CF			.word	LAB_SQR-1		; SQR()
  7922 D4A6 67 CC			.word	LAB_RND-1		; RND()		modified function
  7923 D4A8 C5 C6			.word	LAB_LOG-1		; LOG()
  7924 D4AA C9 CB			.word	LAB_EXP-1		; EXP()
  7925 D4AC A2 CC			.word	LAB_COS-1		; COS()
  7926 D4AE A9 CC			.word	LAB_SIN-1		; SIN()
  7927 D4B0 F2 CC			.word	LAB_TAN-1		; TAN()
  7928 D4B2 24 CD			.word	LAB_ATN-1		; ATN()
  7929 D4B4 CD C4			.word	LAB_PEEK-1		; PEEK()
  7930 D4B6 E1 C4			.word	LAB_DEEK-1		; DEEK()	new function
  7931 D4B8 1F C4			.word	LAB_SADD-1		; SADD()	new function
  7932 D4BA 38 C4			.word	LAB_LENS-1		; LEN()
  7933 D4BC EE C0			.word	LAB_STRS-1		; STR$()
  7934 D4BE 65 C4			.word	LAB_VAL-1		; VAL()
  7935 D4C0 43 C4			.word	LAB_ASC-1		; ASC()
  7936 D4C2 FD C3			.word	LAB_UCASE-1		; UCASE$()	new function
  7937 D4C4 DC C3			.word	LAB_LCASE-1		; LCASE$()	new function
  7938 D4C6 4E C3			.word	LAB_CHRS-1		; CHR$()
  7939 D4C8 F4 CD			.word	LAB_HEXS-1		; HEX$()	new function
  7940 D4CA A5 CD			.word	LAB_BINS-1		; BIN$()	new function
  7941 D4CC 7D CD			.word	LAB_BTST-1		; BITTST()	new function
  7942 D4CE B3 CE			.word	LAB_MAX-1		; MAX()		new function
  7943 D4D0 C3 CE			.word	LAB_MIN-1		; MIN()		new function
  7944 D4D2 09 D0			.word	LAB_PI-1		; PI		new function
  7945 D4D4 13 D0			.word	LAB_TWOPI-1		; TWOPI		new function
  7946 D4D6 F9 CF			.word	LAB_VARPTR-1		; VARPTR()	new function
  7947 D4D8 60 C3			.word	LAB_LEFT-1		; LEFT$()
  7948 D4DA 69 C3			.word	LAB_RIGHT-1		; RIGHT$()
  7949 D4DC 98 C3			.word	LAB_MIDS-1		; MID$()
  7950 D4DE 09 D2			.word	LAB_PORTIN-1		; PORTIN	new function (Junior Computer 2)
  7951 D4E0 DF D1			.word	LAB_I2CIN-1		; I2CIN()	new function (Junior Computer 2)		
  7952 D4E2 C3 D2			.word	LAB_RES5-1		; RESERVED	new function (Junior Computer 2)
  7953 D4E4 C3 D2			.word	LAB_RES6-1		; RESERVED	new function (Junior Computer 2)
  7954
  7955 				; hierarchy and action addresses for operator
  7956 D4E6			LAB_OPPT
  7957 D4E6 79				.byte	$79			; +
  7958 D4E7 8B C5			.word	LAB_ADD-1
  7959 D4E9 79				.byte	$79			; -
  7960 D4EA 70 C5			.word	LAB_SUBTRACT-1
  7961 D4EC 7B				.byte	$7B			; *
  7962 D4ED 06 C7			.word	LAB_MULTIPLY-1
  7963 D4EF 7B				.byte	$7B			; /
  7964 D4F0 CE C7			.word	LAB_DIVIDE-1
  7965 D4F2 7B				.byte	$7B			; MOD		new operator (Junior Computer 2)
  7966 D4F3 1A D0			.word	LAB_MOD-1
  7967 D4F5 7F				.byte	$7F			; ^
  7968 D4F6 85 CB			.word	LAB_POWER-1
  7969 D4F8 50				.byte	$50			; AND
  7970 D4F9 91 BC			.word	LAB_AND-1
  7971 D4FB 46				.byte	$46			; EOR		new operator
  7972 D4FC 77 BC			.word	LAB_EOR-1
  7973 D4FE 46				.byte	$46			; OR
  7974 D4FF 84 BC			.word	LAB_OR-1
  7975 D501 56				.byte	$56			; >>		new operator
  7976 D502 3D BD			.word	LAB_RSHIFT-1
  7977 D504 56				.byte	$56			; <<		new operator
  7978 D505 25 BD			.word	LAB_LSHIFT-1
  7979 D507 7D				.byte	$7D			; >
  7980 D508 BE CB			.word	LAB_GTHAN-1
  7981 D50A 5A				.byte	$5A			; =
  7982 D50B D1 BB			.word	LAB_EQUAL-1
  7983 D50D 64				.byte	$64			; <
  7984 D50E B2 BC			.word	LAB_LTHAN-1
  7985
  7986 				; keywords start with ..
  7987 				; this is the first character table and must be in alphabetic order
  7988 D510			TAB_1STC
  7989 D510 2A				.byte	'*'
  7990 D511 2B				.byte	'+'
  7991 D512 2D				.byte	'-'
  7992 D513 2F				.byte	'/'
  7993 D514 3C				.byte	'<'
  7994 D515 3D				.byte	'='
  7995 D516 3E				.byte	'>'
  7996 D517 3F				.byte	'?'
  7997 D518 41				.byte	'A'
  7998 D519 42				.byte	'B'
  7999 D51A 43				.byte	'C'
  8000 D51B 44				.byte	'D'
  8001 D51C 45				.byte	'E'
  8002 D51D 46				.byte	'F'
  8003 D51E 47				.byte	'G'
  8004 D51F 48				.byte	'H'
  8005 D520 49				.byte	'I'
  8006 D521 4C				.byte	'L'
  8007 D522 4D				.byte	'M'
  8008 D523 4E				.byte	'N'
  8009 D524 4F				.byte	'O'
  8010 D525 50				.byte	'P'
  8011 D526 52				.byte	'R'
  8012 D527 53				.byte	'S'
  8013 D528 54				.byte	'T'
  8014 D529 55				.byte	'U'
  8015 D52A 56				.byte	'V'
  8016 D52B 57				.byte	'W'
  8017 D52C 5E				.byte	'^'
  8018 D52D 00				.byte	$00			; table terminator
  8019
  8020 				; pointers to keyword tables
  8021
  8022 D52E			TAB_CHRT
  8023 D52E 68 D5			.word	TAB_STAR		; table for '*'
  8024 D530 6A D5			.word	TAB_PLUS		; table for '+'
  8025 D532 6C D5			.word	TAB_MNUS		; table for '-'
  8026 D534 6E D5			.word	TAB_SLAS		; table for '/'
  8027 D536 70 D5			.word	TAB_LESS		; table for '<'
  8028 D538 74 D5			.word	TAB_EQUL		; table for '='
  8029 D53A 76 D5			.word	TAB_MORE		; table for '>'
  8030 D53C 7A D5			.word	TAB_QEST		; table for '?'
  8031 D53E 7C D5			.word	TAB_ASCA		; table for 'A'
  8032 D540 8C D5			.word	TAB_ASCB		; table for 'B'
  8033 D542 A9 D5			.word	TAB_ASCC		; table for 'C'
  8034 D544 C8 D5			.word	TAB_ASCD		; table for 'D'
  8035 D546 E9 D5			.word	TAB_ASCE		; table for 'E'
  8036 D548 F8 D5			.word	TAB_ASCF		; table for 'F'
  8037 D54A 07 D6			.word	TAB_ASCG		; table for 'G'
  8038 D54C 14 D6			.word	TAB_ASCH		; table for 'H'
  8039 D54E 1E D6			.word	TAB_ASCI		; table for 'I'
  8040 D550 43 D6			.word	TAB_ASCL		; table for 'L'
  8041 D552 72 D6			.word	TAB_ASCM		; table for 'M'
  8042 D554 85 D6			.word	TAB_ASCN		; table for 'N'
  8043 D556 9A D6			.word	TAB_ASCO		; table for 'O'
  8044 D558 A6 D6			.word	TAB_ASCP		; table for 'P'
  8045 D55A D7 D6			.word	TAB_ASCR		; table for 'R'
  8046 D55C 14 D7			.word	TAB_ASCS		; table for 'S'
  8047 D55E 4A D7			.word	TAB_ASCT		; table for 'T'
  8048 D560 5E D7			.word	TAB_ASCU		; table for 'U'
  8049 D562 6F D7			.word	TAB_ASCV		; table for 'V'
  8050 D564 7B D7			.word	TAB_ASCW		; table for 'W'
  8051 D566 8A D7			.word	TAB_POWR		; table for '^'
  8052
  8053 				; tables for each start character, note if a longer keyword with the same start
  8054 				; letters as a shorter one exists then it must come first, else the list is in
  8055 				; alphabetical order as follows ..
  8056
  8057 				; [keyword,token
  8058 				; [keyword,token]]
  8059 				; end marker (#$00)
  8060
  8061 D568			TAB_STAR
  8062 D568 CD 00			.byte TK_MUL,$00		; *
  8063 D56A			TAB_PLUS
  8064 D56A CB 00			.byte TK_PLUS,$00		; +
  8065 D56C			TAB_MNUS
  8066 D56C CC 00			.byte TK_MINUS,$00		; -
  8067 D56E			TAB_SLAS
  8068 D56E CE 00			.byte TK_DIV,$00		; /
  8069 D570			TAB_LESS
  8070 D570			LBB_LSHIFT
  8071 D570 3C D5			.byte	'<',TK_LSHIFT		; <<	note - '<<' must come before '<'
  8072 D572 D8				.byte 	TK_LT			; <
  8073 D573 00				.byte	$00
  8074 D574			TAB_EQUL
  8075 D574 D7 00			.byte 	TK_EQUAL,$00		; =
  8076 D576			TAB_MORE
  8077 D576			LBB_RSHIFT
  8078 D576 3E D4			.byte	'>',TK_RSHIFT		; >>	note - '>>' must come before '>'
  8079 D578 D6				.byte 	TK_GT			; >
  8080 D579 00				.byte	$00
  8081 D57A			TAB_QEST
  8082 D57A 9F 00			.byte 	TK_PRINT,$00		; ?
  8083 D57C			TAB_ASCA
  8084 D57C			LBB_ABS
  8085 D57C 42 53 28 DB			.byte	'BS(',TK_ABS		; ABS(
  8086 D580			LBB_AND
  8087 D580 4E 44 D1			.byte	'ND',TK_AND		; AND
  8088 D583			LBB_ASC
  8089 D583 53 43 28 ED			.byte	'SC(',TK_ASC		; ASC(
  8090 D587			LBB_ATN
  8091 D587 54 4E 28 E6			.byte	'TN(',TK_ATN		; ATN(
  8092 D58B 00				.byte	$00
  8093 D58C			TAB_ASCB
  8094 D58C			LBB_BEEP
  8095 D58C 45 45 50 AB			.byte	'EEP',TK_BEEP		; BEEP
  8096 D590			LBB_BINS
  8097 D590 49 4E 24 28 F2		.byte	'IN$(',TK_BINS		; BIN$(
  8098 D595			LBB_BITCLR
  8099 D595 49 54 43 4C 52 A8		.byte	'ITCLR',TK_BITCLR	; BITCLR
  8100 D59B			LBB_BITSET
  8101 D59B 49 54 53 45 54 A7		.byte	'ITSET',TK_BITSET	; BITSET
  8102 D5A1			LBB_BITTST
  8103 D5A1 49 54 54 53 54 28 + 	.byte	'ITTST(',TK_BITTST  	; BITTST(
  8104 D5A8 00				.byte	$00
  8105 D5A9			TAB_ASCC
  8106 D5A9			LBB_CALL
  8107 D5A9 41 4C 4C 9C			.byte	'ALL',TK_CALL		; CALL
  8108 D5AD			LBB_CHRS
  8109 D5AD 48 52 24 28 F0		.byte	'HR$(',TK_CHRS		; CHR$(
  8110 D5B2			LBB_CLEAR
  8111 D5B2 4C 45 41 52 A2		.byte	'LEAR',TK_CLEAR		; CLEAR
  8112 D5B7			LBB_CLS
  8113 D5B7 4C 53 AE		    	.byte   'LS',TK_CLS 		; CLS
  8114 D5BA			LBB_COLOR
  8115 D5BA 4F 4C 4F 52 BC		.byte	'OLOR',TK_COLOR		; COLOR
  8116 D5BF			LBB_CONT
  8117 D5BF 4F 4E 54 A0			.byte	'ONT',TK_CONT		; CONT
  8118 D5C3			LBB_COS
  8119 D5C3 4F 53 28 E3			.byte	'OS(',TK_COS		; COS(
  8120 D5C7 00				.byte	$00
  8121 D5C8			TAB_ASCD
  8122 D5C8			LBB_DATA
  8123 D5C8 41 54 41 83			.byte	'ATA',TK_DATA		; DATA
  8124 D5CC			LBB_DEC
  8125 D5CC 45 43 88			.byte	'EC',TK_DEC		; DEC
  8126 D5CF			LBB_DEEK
  8127 D5CF 45 45 4B 28 E8		.byte	'EEK(',TK_DEEK		; DEEK(
  8128 D5D4			LBB_DEF
  8129 D5D4 45 46 99			.byte	'EF',TK_DEF		; DEF
  8130 D5D7			LBB_DELAY
  8131 D5D7 45 4C 41 59 BD		.byte	'ELAY',TK_DELAY		; DELAY
  8132 D5DC			LBB_DIM
  8133 D5DC 49 4D 85			.byte	'IM',TK_DIM		; DIM
  8134 D5DF			LBB_DOKE
  8135 D5DF 4F 4B 45 9B			.byte	'OKE',TK_DOKE		; DOKE
  8136 D5E3			LBB_DOS
  8137 D5E3 4F 53 BF			.byte	'OS',TK_DOS		; DOS note - 'DOS' must come before 'DO'
  8138 D5E6			LBB_DO
  8139 D5E6 4F 9D			.byte	'O',TK_DO		; DO
  8140 D5E8 00				.byte	$00
  8141 D5E9			TAB_ASCE
  8142 D5E9			LBB_ELSE
  8143 D5E9 4C 53 45 C1			.byte	'LSE',TK_ELSE		; ELSE
  8144 D5ED			LBB_END
  8145 D5ED 4E 44 80			.byte	'ND',TK_END		; END
  8146 D5F0			LBB_EOR
  8147 D5F0 4F 52 D2			.byte	'OR',TK_EOR		; EOR
  8148 D5F3			LBB_EXP
  8149 D5F3 58 50 28 E2			.byte	'XP(',TK_EXP		; EXP(
  8150 D5F7 00				.byte	$00
  8151 D5F8			TAB_ASCF
  8152 D5F8			LBB_FLASH
  8153 D5F8 4C 41 53 48 B1	    	.byte   'LASH',TK_FLASH 	; FLASH
  8154 D5FD			LBB_FN
  8155 D5FD 4E C3			.byte	'N',TK_FN		; FN
  8156 D5FF			LBB_FOR
  8157 D5FF 4F 52 81			.byte	'OR',TK_FOR		; FOR
  8158 D602			LBB_FRE
  8159 D602 52 45 28 DD			.byte	'RE(',TK_FRE		; FRE(
  8160 D606 00				.byte	$00
  8161 D607			TAB_ASCG
  8162 D607			LBB_GET
  8163 D607 45 54 A5			.byte	'ET',TK_GET		; GET
  8164 D60A			LBB_GOSUB
  8165 D60A 4F 53 55 42 8D		.byte	'OSUB',TK_GOSUB		; GOSUB
  8166 D60F			LBB_GOTO
  8167 D60F 4F 54 4F 89			.byte	'OTO',TK_GOTO		; GOTO
  8168 D613 00				.byte	$00
  8169 D614			TAB_ASCH
  8170 D614			LBB_HEXS
  8171 D614 45 58 24 28 F1		.byte	'EX$(',TK_HEXS		; HEX$(
  8172 D619			LBB_HOME
  8173 D619 4F 4D 45 AD		    	.byte   'OME',TK_HOME 		; HOME
  8174 D61D 00				.byte	$00
  8175 D61E			TAB_ASCI
  8176 D61E			LBB_I2CIN
  8177 D61E 32 43 69 6E 28 FD		.byte	'2Cin(',TK_I2CIN	; I2Cin
  8178 D624			LBB_I2COUT
  8179 D624 32 43 6F 75 74 BE		.byte	'2Cout',TK_I2COUT	; I2Cout
  8180 D62A			LBB_IF
  8181 D62A 46 8B			.byte	'F',TK_IF		; IF
  8182 D62C			LBB_INNUM
  8183 D62C 4E 23 B3			.byte	'N#',TK_INNUM		; IN#
  8184 D62F			LBB_INC
  8185 D62F 4E 43 95			.byte	'NC',TK_INC		; INC
  8186 D632			LBB_INPUT
  8187 D632 4E 50 55 54 84		.byte	'NPUT',TK_INPUT		; INPUT
  8188 D637			LBB_INT
  8189 D637 4E 54 28 DA			.byte	'NT(',TK_INT		; INT(
  8190 D63B			LBB_INVERSE
  8191 D63B 4E 56 45 52 53 45 +     	.byte   'NVERSE',TK_INVERSE 	; INVERSE
  8192 D642 00				.byte	$00
  8193 D643			TAB_ASCL
  8194 D643			LBB_LCASES
  8195 D643 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_LCASES
  8196 									; LCASE$(
  8197 D64A			LBB_LEFTS
  8198 D64A 45 46 54 24 28 F9		.byte	'EFT$(',TK_LEFTS	; LEFT$(
  8199 D650			LBB_LEN
  8200 D650 45 4E 28 EA			.byte	'EN(',TK_LEN		; LEN(
  8201 D654			LBB_LET
  8202 D654 45 54 87			.byte	'ET',TK_LET		; LET
  8203 D657			LBB_LINE
  8204 D657 49 4E 45 B9			.byte	'INE',TK_LINE		; LINE
  8205 D65B			LBB_LIST
  8206 D65B 49 53 54 A1			.byte	'IST',TK_LIST		; LIST
  8207 D65F			LBB_LOAD
  8208 D65F 4F 41 44 97			.byte	'OAD',TK_LOAD		; LOAD
  8209 D663			LBB_LOCATE
  8210 D663 4F 43 41 54 45 B2	    	.byte   'OCATE',TK_LOCATE 	; LOCATE
  8211 D669			LBB_LOG
  8212 D669 4F 47 28 E1			.byte	'OG(',TK_LOG		; LOG(
  8213 D66D			LBB_LOOP
  8214 D66D 4F 4F 50 9E			.byte	'OOP',TK_LOOP		; LOOP
  8215 D671 00				.byte	$00
  8216 D672			TAB_ASCM
  8217 D672			LBB_MAX
  8218 D672 41 58 28 F4			.byte	'AX(',TK_MAX		; MAX(
  8219 D676			LBB_MIDS
  8220 D676 49 44 24 28 FB		.byte	'ID$(',TK_MIDS		; MID$(
  8221 D67B			LBB_MIN
  8222 D67B 49 4E 28 F5			.byte	'IN(',TK_MIN		; MIN(
  8223 D67F			LBB_MOD
  8224 D67F 4F 44 5F 23 CF		.byte	'OD_#',TK_MOD		; MOD
  8225 D684 00				.byte	$00
  8226 D685			TAB_ASCN
  8227 D685			LBB_NEW
  8228 D685 45 57 A3			.byte	'EW',TK_NEW		; NEW
  8229 D688			LBB_NEXT
  8230 D688 45 58 54 82			.byte	'EXT',TK_NEXT		; NEXT
  8231 D68C			LBB_NOT
  8232 D68C 4F 54 C6			.byte	'OT',TK_NOT		; NOT
  8233 D68F			LBB_NORMAL
  8234 D68F 4F 52 4D 41 4C AF	    	.byte   'ORMAL',TK_NORMAL 	; NORMAL
  8235 D695			LBB_NULL
  8236 D695 55 4C 4C 94			.byte	'ULL',TK_NULL		; NULL
  8237 D699 00				.byte	$00
  8238 D69A			TAB_ASCO
  8239 D69A			LBB_OFF
  8240 D69A 46 46 CA			.byte	'FF',TK_OFF		; OFF
  8241 D69D			LBB_ON
  8242 D69D 4E 93			.byte	'N',TK_ON		; ON
  8243 D69F			LBB_OR
  8244 D69F 52 D3			.byte	'R',TK_OR		; OR
  8245 D6A1			LBB_OVAL
  8246 D6A1 56 41 4C BA			.byte	'VAL',TK_OVAL		; OVAL
  8247 D6A5 00				.byte	$00
  8248 D6A6			TAB_ASCP
  8249 D6A6			LBB_PEEK
  8250 D6A6 45 45 4B 28 E7		.byte	'EEK(',TK_PEEK		; PEEK(
  8251 D6AB			LBB_PIXEL
  8252 D6AB 49 58 45 4C B8		.byte	'IXEL',TK_PIXEL		; PIXEL
  8253 D6B0			LBB_PI
  8254 D6B0 49 F6			.byte	'I',TK_PI		; PI
  8255 D6B2			LBB_PLIST
  8256 D6B2 4C 49 53 54 AC	    .byte   	'LIST',TK_PLIST 	; PLIST
  8257 D6B7			LBB_POKE
  8258 D6B7 4F 4B 45 9A			.byte	'OKE',TK_POKE		; POKE
  8259 D6BB			LBB_PORTIO
  8260 D6BB 4F 52 54 49 4F B5		.byte	'ORTIO',TK_PORTIO	; PORTIO
  8261 D6C1			LBB_PORTIN
  8262 D6C1 4F 52 54 28 FC		.byte	'ORT(',TK_PORTIN	; PORT IN
  8263 D6C6			LBB_PORTOUT
  8264 D6C6 4F 52 54 B6			.byte	'ORT',TK_PORTOUT	; PORT OUT
  8265 D6CA			LBB_POS
  8266 D6CA 4F 53 28 DE			.byte	'OS(',TK_POS		; POS(
  8267 D6CE			LBB_PRNUM
  8268 D6CE 52 23 B4			.byte	'R#',TK_PRNUM		; PR#
  8269 D6D1			LBB_PRINT
  8270 D6D1 52 49 4E 54 9F		.byte	'RINT',TK_PRINT		; PRINT
  8271 D6D6 00				.byte	$00
  8272 D6D7			TAB_ASCR
  8273 D6D7			LBB_READ
  8274 D6D7 45 41 44 86			.byte	'EAD',TK_READ		; READ
  8275 D6DB			LBB_RECT
  8276 D6DB 45 43 54 BB			.byte	'ECT',TK_RECT		; RECT
  8277 D6DF			LBB_REM
  8278 D6DF 45 4D 91			.byte	'EM',TK_REM		; REM
  8279 D6E2			LBB_RESTORE
  8280 D6E2 45 53 54 4F 52 45 + 	.byte	'ESTORE',TK_RESTORE	; RESTORE
  8281 D6E9			LBB_RES2
  8282 D6E9 45 53 32 8F			.byte	'ES2',TK_RES2		; RES2
  8283 D6ED			LBB_RES3
  8284 D6ED 45 53 33 A9			.byte	'ES3',TK_RES3		; RES3
  8285 D6F1			LBB_RES4
  8286 D6F1 45 53 34 AA			.byte	'ES4',TK_RES4		; RES4
  8287 D6F5			LBB_RES5
  8288 D6F5 45 53 35 28 FE		.byte	'ES5(',TK_RES5		; RES5
  8289 D6FA			LBB_RES6
  8290 D6FA 45 53 36 28 FF		.byte	'ES6(',TK_RES6		; RES6
  8291 D6FF			LBB_RETURN
  8292 D6FF 45 54 55 52 4E 90		.byte	'ETURN',TK_RETURN	; RETURN
  8293 D705			LBB_RIGHTS
  8294 D705 49 47 48 54 24 28 + 	.byte	'IGHT$(',TK_RIGHTS
  8295 									; RIGHT$(
  8296 D70C			LBB_RND
  8297 D70C 4E 44 28 E0			.byte	'ND(',TK_RND		; RND(
  8298 D710			LBB_RUN
  8299 D710 55 4E 8A			.byte	'UN',TK_RUN		; RUN
  8300 D713 00				.byte	$00
  8301 D714			TAB_ASCS
  8302 D714			LBB_SADD
  8303 D714 41 44 44 28 E9		.byte	'ADD(',TK_SADD		; SADD(
  8304 D719			LBB_SAVE
  8305 D719 41 56 45 98			.byte	'AVE',TK_SAVE		; SAVE
  8306 D71D			LBB_SCREEN
  8307 D71D 43 52 45 45 4E B7		.byte	'CREEN',TK_SCREEN	; SCREEN
  8308 D723			LBB_SGN
  8309 D723 47 4E 28 D9			.byte	'GN(',TK_SGN		; SGN(
  8310 D727			LBB_SIN
  8311 D727 49 4E 28 E4			.byte	'IN(',TK_SIN		; SIN(
  8312 D72B			LBB_SOUND
  8313 D72B 4F 55 4E 44 8E		.byte	'OUND',TK_SOUND		; SOUND
  8314 D730			LBB_SPC
  8315 D730 50 43 28 C4			.byte	'PC(',TK_SPC		; SPC(
  8316 D734			LBB_SQR
  8317 D734 51 52 28 DF			.byte	'QR(',TK_SQR		; SQR(
  8318 D738			LBB_STEP
  8319 D738 54 45 50 C7			.byte	'TEP',TK_STEP		; STEP
  8320 D73C			LBB_STOP
  8321 D73C 54 4F 50 92			.byte	'TOP',TK_STOP		; STOP
  8322 D740			LBB_STRS
  8323 D740 54 52 24 28 EB		.byte	'TR$(',TK_STRS		; STR$(
  8324 D745			LBB_SWAP
  8325 D745 57 41 50 A6			.byte	'WAP',TK_SWAP		; SWAP
  8326 D749 00				.byte	$00
  8327 D74A			TAB_ASCT
  8328 D74A			LBB_TAB
  8329 D74A 41 42 28 C0			.byte	'AB(',TK_TAB		; TAB(
  8330 D74E			LBB_TAN
  8331 D74E 41 4E 28 E5			.byte	'AN(',TK_TAN		; TAN(
  8332 D752			LBB_THEN
  8333 D752 48 45 4E C5			.byte	'HEN',TK_THEN		; THEN
  8334 D756			LBB_TO
  8335 D756 4F C2			.byte	'O',TK_TO		; TO
  8336 D758			LBB_TWOPI
  8337 D758 57 4F 50 49 F7		.byte	'WOPI',TK_TWOPI		; TWOPI
  8338 D75D 00				.byte	$00
  8339 D75E			TAB_ASCU
  8340 D75E			LBB_UCASES
  8341 D75E 43 41 53 45 24 28 + 	.byte	'CASE$(',TK_UCASES
  8342 									; UCASE$(
  8343 D765			LBB_UNTIL
  8344 D765 4E 54 49 4C C8		.byte	'NTIL',TK_UNTIL		; UNTIL
  8345 D76A			LBB_USR
  8346 D76A 53 52 28 DC			.byte	'SR(',TK_USR		; USR(
  8347 D76E 00				.byte	$00
  8348 D76F			TAB_ASCV
  8349 D76F			LBB_VAL
  8350 D76F 41 4C 28 EC			.byte	'AL(',TK_VAL		; VAL(
  8351 D773			LBB_VPTR
  8352 D773 41 52 50 54 52 28 + 	.byte	'ARPTR(',TK_VPTR	; VARPTR(
  8353 D77A 00				.byte	$00
  8354 D77B			TAB_ASCW
  8355 D77B			LBB_WAIT
  8356 D77B 41 49 54 96			.byte	'AIT',TK_WAIT		; WAIT
  8357 D77F			LBB_WHILE
  8358 D77F 48 49 4C 45 C9		.byte	'HILE',TK_WHILE		; WHILE
  8359 D784			LBB_WIDTH
  8360 D784 49 44 54 48 A4		.byte	'IDTH',TK_WIDTH		; WIDTH
  8361 D789 00				.byte	$00
  8362 D78A			TAB_POWR
  8363 D78A D0 00			.byte	TK_POWER,$00		; ^
  8364
  8365 				; new decode table for LIST
  8366 				; Table is ..
  8367 				; byte - keyword length, keyword first character
  8368 				; word - pointer to rest of keyword from dictionary
  8369
  8370 				; note if length is 1 then the pointer is ignored
  8371 D78C			LAB_KEYT
  8372 D78C 03 45			.byte	3,'E'
  8373 D78E ED D5			.word	LBB_END			; END
  8374 D790 03 46			.byte	3,'F'
  8375 D792 FF D5			.word	LBB_FOR			; FOR
  8376 D794 04 4E			.byte	4,'N'
  8377 D796 88 D6			.word	LBB_NEXT		; NEXT
  8378 D798 04 44			.byte	4,'D'
  8379 D79A C8 D5			.word	LBB_DATA		; DATA
  8380 D79C 05 49			.byte	5,'I'
  8381 D79E 32 D6			.word	LBB_INPUT		; INPUT
  8382 D7A0 03 44			.byte	3,'D'
  8383 D7A2 DC D5			.word	LBB_DIM			; DIM
  8384 D7A4 04 52			.byte	4,'R'
  8385 D7A6 D7 D6			.word	LBB_READ		; READ
  8386 D7A8 03 4C			.byte	3,'L'
  8387 D7AA 54 D6			.word	LBB_LET			; LET
  8388 D7AC 03 44			.byte	3,'D'
  8389 D7AE CC D5			.word	LBB_DEC			; DEC
  8390 D7B0 04 47			.byte	4,'G'
  8391 D7B2 0F D6			.word	LBB_GOTO		; GOTO
  8392 D7B4 03 52			.byte	3,'R'
  8393 D7B6 10 D7			.word	LBB_RUN			; RUN
  8394 D7B8 02 49			.byte	2,'I'
  8395 D7BA 2A D6			.word	LBB_IF			; IF
  8396 D7BC 07 52			.byte	7,'R'
  8397 D7BE E2 D6			.word	LBB_RESTORE		; RESTORE
  8398 D7C0 05 47			.byte	5,'G'
  8399 D7C2 0A D6			.word	LBB_GOSUB		; GOSUB
  8400 D7C4 05 53			.byte	5,'S'
  8401 D7C6 2B D7			.word	LBB_SOUND		; SOUND
  8402 D7C8 04 52			.byte	4,'R'
  8403 D7CA E9 D6			.word	LBB_RES2		; RES2
  8404 D7CC 06 52			.byte	6,'R'
  8405 D7CE FF D6			.word	LBB_RETURN		; RETURN
  8406 D7D0 03 52			.byte	3,'R'
  8407 D7D2 DF D6			.word	LBB_REM			; REM
  8408 D7D4 04 53			.byte	4,'S'
  8409 D7D6 3C D7			.word	LBB_STOP		; STOP
  8410 D7D8 02 4F			.byte	2,'O'
  8411 D7DA 9D D6			.word	LBB_ON			; ON
  8412 D7DC 04 4E			.byte	4,'N'
  8413 D7DE 95 D6			.word	LBB_NULL		; NULL
  8414 D7E0 03 49			.byte	3,'I'
  8415 D7E2 2F D6			.word	LBB_INC			; INC
  8416 D7E4 04 57			.byte	4,'W'
  8417 D7E6 7B D7			.word	LBB_WAIT		; WAIT
  8418 D7E8 04 4C			.byte	4,'L'
  8419 D7EA 5F D6			.word	LBB_LOAD		; LOAD
  8420 D7EC 04 53			.byte	4,'S'
  8421 D7EE 19 D7			.word	LBB_SAVE		; SAVE
  8422 D7F0 03 44			.byte	3,'D'
  8423 D7F2 D4 D5			.word	LBB_DEF			; DEF
  8424 D7F4 04 50			.byte	4,'P'
  8425 D7F6 B7 D6			.word	LBB_POKE		; POKE
  8426 D7F8 04 44			.byte	4,'D'
  8427 D7FA DF D5			.word	LBB_DOKE		; DOKE
  8428 D7FC 04 43			.byte	4,'C'
  8429 D7FE A9 D5			.word	LBB_CALL		; CALL
  8430 D800 02 44			.byte	2,'D'
  8431 D802 E6 D5			.word	LBB_DO			; DO
  8432 D804 04 4C			.byte	4,'L'
  8433 D806 6D D6			.word	LBB_LOOP		; LOOP
  8434 D808 05 50			.byte	5,'P'
  8435 D80A D1 D6			.word	LBB_PRINT		; PRINT
  8436 D80C 04 43			.byte	4,'C'
  8437 D80E BF D5			.word	LBB_CONT		; CONT
  8438 D810 04 4C			.byte	4,'L'
  8439 D812 5B D6			.word	LBB_LIST		; LIST
  8440 D814 05 43			.byte	5,'C'
  8441 D816 B2 D5			.word	LBB_CLEAR		; CLEAR
  8442 D818 03 4E			.byte	3,'N'
  8443 D81A 85 D6			.word	LBB_NEW			; NEW
  8444 D81C 05 57			.byte	5,'W'
  8445 D81E 84 D7			.word	LBB_WIDTH		; WIDTH
  8446 D820 03 47			.byte	3,'G'
  8447 D822 07 D6			.word	LBB_GET			; GET
  8448 D824 04 53			.byte	4,'S'
  8449 D826 45 D7			.word	LBB_SWAP		; SWAP
  8450 D828 06 42			.byte	6,'B'
  8451 D82A 9B D5			.word	LBB_BITSET		; BITSET
  8452 D82C 06 42			.byte	6,'B'
  8453 D82E 95 D5			.word	LBB_BITCLR		; BITCLR
  8454 D830 04 52			.byte	4,'R'
  8455 D832 ED D6			.word	LBB_RES3		; RES3
  8456 D834 04 52			.byte	4,'R'
  8457 D836 F1 D6			.word	LBB_RES4		; RES4
  8458 D838 04 42			.byte	4,'B'
  8459 D83A 8C D5			.word	LBB_BEEP		; BEEP
  8460 D83C 05 50			.byte	5,'P'
  8461 D83E B2 D6			.word	LBB_PLIST		; PLIST
  8462 D840 04 48			.byte	4,'H'
  8463 D842 19 D6			.word	LBB_HOME		; HOME
  8464 D844 03 43			.byte	3,'C'
  8465 D846 B7 D5			.word	LBB_CLS			; CLS
  8466 D848 06 4E			.byte	6,'N'
  8467 D84A 8F D6			.word	LBB_NORMAL		; NORMAL
  8468 D84C 07 49			.byte	7,'I'
  8469 D84E 3B D6			.word	LBB_INVERSE		; INVERSE
  8470 D850 05 46			.byte	5,'F'
  8471 D852 F8 D5			.word	LBB_FLASH		; FLASH
  8472 D854 06 4C			.byte	6,'L'
  8473 D856 63 D6			.word	LBB_LOCATE		; LOCATE
  8474 D858 03 49			.byte	3,'I'
  8475 D85A 2C D6			.word	LBB_INNUM		; IN#
  8476 D85C 03 50			.byte	3,'P'
  8477 D85E CE D6			.word	LBB_PRNUM		; PR#
  8478
  8479 D860 06 50			.byte	6,'P'
  8480 D862 BB D6			.word	LBB_PORTIO		; PORTIO
  8481 D864 04 50			.byte	4,'P'
  8482 D866 C6 D6			.word	LBB_PORTOUT		; PORTOUT
  8483 D868 06 53			.byte	6,'S'
  8484 D86A 1D D7			.word	LBB_SCREEN		; SCREEN
  8485 D86C 05 50			.byte	5,'P'
  8486 D86E AB D6			.word	LBB_PIXEL		; PIXEL
  8487 D870 04 4C			.byte	4,'L'
  8488 D872 57 D6			.word	LBB_LINE		; LINE
  8489 D874 04 4F			.byte	4,'O'
  8490 D876 A1 D6			.word	LBB_OVAL		; OVAL
  8491 D878 04 52			.byte	4,'R'
  8492 D87A DB D6			.word	LBB_RECT		; RECT
  8493 D87C 05 43			.byte	5,'C'
  8494 D87E BA D5			.word	LBB_COLOR		; COLOR
  8495 D880 05 44			.byte	5,'D'
  8496 D882 D7 D5			.word	LBB_DELAY		; DELAY	
  8497 D884 06 49			.byte	6,'I'
  8498 D886 24 D6			.word	LBB_I2COUT		; I2COUT
  8499 D888 03 44			.byte	3,'D'
  8500 D88A E3 D5			.word	LBB_DOS			; DOS
  8501
  8502 				; secondary commands (can't start a statement)
  8503 D88C 04 54			.byte	4,'T'
  8504 D88E 4A D7			.word	LBB_TAB			; TAB
  8505 D890 04 45			.byte	4,'E'
  8506 D892 E9 D5			.word	LBB_ELSE		; ELSE
  8507 D894 02 54			.byte	2,'T'
  8508 D896 56 D7			.word	LBB_TO			; TO
  8509 D898 02 46			.byte	2,'F'
  8510 D89A FD D5			.word	LBB_FN			; FN
  8511 D89C 04 53			.byte	4,'S'
  8512 D89E 30 D7			.word	LBB_SPC			; SPC
  8513 D8A0 04 54			.byte	4,'T'
  8514 D8A2 52 D7			.word	LBB_THEN		; THEN
  8515 D8A4 03 4E			.byte	3,'N'
  8516 D8A6 8C D6			.word	LBB_NOT			; NOT
  8517 D8A8 04 53			.byte	4,'S'
  8518 D8AA 38 D7			.word	LBB_STEP		; STEP
  8519 D8AC 05 55			.byte	5,'U'
  8520 D8AE 65 D7			.word	LBB_UNTIL		; UNTIL
  8521 D8B0 05 57			.byte	5,'W'
  8522 D8B2 7F D7			.word	LBB_WHILE		; WHILE
  8523 D8B4 03 4F			.byte	3,'O'
  8524 D8B6 9A D6			.word	LBB_OFF			; OFF
  8525
  8526 				; opperators
  8527 D8B8 01 2B			.byte	1,'+'
  8528 D8BA 00 00			.word	$0000			; +
  8529 D8BC 01 2D			.byte	1,'-'
  8530 D8BE 00 00			.word	$0000			; -
  8531 D8C0 01 2A			.byte	1,'*'
  8532 D8C2 00 00			.word	$0000			; *
  8533 D8C4 01 2F			.byte	1,'/'
  8534 D8C6 00 00			.word	$0000			; /
  8535 D8C8 05 4D			.byte	5,'M'
  8536 D8CA 7F D6			.word	LBB_MOD			; MOD
  8537 D8CC 01 5E			.byte	1,'^'
  8538 D8CE 00 00			.word	$0000			; ^
  8539 D8D0 03 41			.byte	3,'A'
  8540 D8D2 80 D5			.word	LBB_AND			; AND
  8541 D8D4 03 45			.byte	3,'E'
  8542 D8D6 F0 D5			.word	LBB_EOR			; EOR
  8543 D8D8 02 4F			.byte	2,'O'
  8544 D8DA 9F D6			.word	LBB_OR			; OR
  8545 D8DC 02 3E			.byte	2,'>'
  8546 D8DE 76 D5			.word	LBB_RSHIFT		; >>
  8547 D8E0 02 3C			.byte	2,'<'
  8548 D8E2 70 D5			.word	LBB_LSHIFT		; <<
  8549 D8E4 01 3E			.byte	1,'>'
  8550 D8E6 00 00			.word	$0000			; >
  8551 D8E8 01 3D			.byte	1,'='
  8552 D8EA 00 00			.word	$0000			; =
  8553 D8EC 01 3C			.byte	1,'<'
  8554 D8EE 00 00			.word	$0000			; <
  8555
  8556 				; functions
  8557 D8F0 04 53			.byte	4,'S'			;
  8558 D8F2 23 D7			.word	LBB_SGN			; SGN
  8559 D8F4 04 49			.byte	4,'I'			;
  8560 D8F6 37 D6			.word	LBB_INT			; INT
  8561 D8F8 04 41			.byte	4,'A'			;
  8562 D8FA 7C D5			.word	LBB_ABS			; ABS
  8563 D8FC 04 55			.byte	4,'U'			;
  8564 D8FE 6A D7			.word	LBB_USR			; USR
  8565 D900 04 46			.byte	4,'F'			;
  8566 D902 02 D6			.word	LBB_FRE			; FRE
  8567 D904 04 50			.byte	4,'P'			;
  8568 D906 CA D6			.word	LBB_POS			; POS
  8569 D908 04 53			.byte	4,'S'			;
  8570 D90A 34 D7			.word	LBB_SQR			; SQR
  8571 D90C 04 52			.byte	4,'R'			;
  8572 D90E 0C D7			.word	LBB_RND			; RND
  8573 D910 04 4C			.byte	4,'L'			;
  8574 D912 69 D6			.word	LBB_LOG			; LOG
  8575 D914 04 45			.byte	4,'E'			;
  8576 D916 F3 D5			.word	LBB_EXP			; EXP
  8577 D918 04 43			.byte	4,'C'			;
  8578 D91A C3 D5			.word	LBB_COS			; COS
  8579 D91C 04 53			.byte	4,'S'			;
  8580 D91E 27 D7			.word	LBB_SIN			; SIN
  8581 D920 04 54			.byte	4,'T'			;
  8582 D922 4E D7			.word	LBB_TAN			; TAN
  8583 D924 04 41			.byte	4,'A'			;
  8584 D926 87 D5			.word	LBB_ATN			; ATN
  8585 D928 05 50			.byte	5,'P'			;
  8586 D92A A6 D6			.word	LBB_PEEK		; PEEK
  8587 D92C 05 44			.byte	5,'D'			;
  8588 D92E CF D5			.word	LBB_DEEK		; DEEK
  8589 D930 05 53			.byte	5,'S'			;
  8590 D932 14 D7			.word	LBB_SADD		; SADD
  8591 D934 04 4C			.byte	4,'L'			;
  8592 D936 50 D6			.word	LBB_LEN			; LEN
  8593 D938 05 53			.byte	5,'S'			;
  8594 D93A 40 D7			.word	LBB_STRS		; STR$
  8595 D93C 04 56			.byte	4,'V'			;
  8596 D93E 6F D7			.word	LBB_VAL			; VAL
  8597 D940 04 41			.byte	4,'A'			;
  8598 D942 83 D5			.word	LBB_ASC			; ASC
  8599 D944 07 55			.byte	7,'U'			;
  8600 D946 5E D7			.word	LBB_UCASES		; UCASE$
  8601 D948 07 4C			.byte	7,'L'			;
  8602 D94A 43 D6			.word	LBB_LCASES		; LCASE$
  8603 D94C 05 43			.byte	5,'C'			;
  8604 D94E AD D5			.word	LBB_CHRS		; CHR$
  8605 D950 05 48			.byte	5,'H'			;
  8606 D952 14 D6			.word	LBB_HEXS		; HEX$
  8607 D954 05 42			.byte	5,'B'			;
  8608 D956 90 D5			.word	LBB_BINS		; BIN$
  8609 D958 07 42			.byte	7,'B'			;
  8610 D95A A1 D5			.word	LBB_BITTST		; BITTST
  8611 D95C 04 4D			.byte	4,'M'			;
  8612 D95E 72 D6			.word	LBB_MAX			; MAX
  8613 D960 04 4D			.byte	4,'M'			;
  8614 D962 7B D6			.word	LBB_MIN			; MIN
  8615 D964 02 50			.byte	2,'P'			;
  8616 D966 B0 D6			.word	LBB_PI			; PI
  8617 D968 05 54			.byte	5,'T'			;
  8618 D96A 58 D7			.word	LBB_TWOPI		; TWOPI
  8619 D96C 07 56			.byte	7,'V'			;
  8620 D96E 73 D7			.word	LBB_VPTR		; VARPTR
  8621 D970 06 4C			.byte	6,'L'			;
  8622 D972 4A D6			.word	LBB_LEFTS		; LEFT$
  8623 D974 07 52			.byte	7,'R'			;
  8624 D976 05 D7			.word	LBB_RIGHTS		; RIGHT$
  8625 D978 05 4D			.byte	5,'M'			;
  8626 D97A 76 D6			.word	LBB_MIDS		; MID$
  8627 D97C 05 50			.byte	5,'P'			;
  8628 D97E C1 D6			.word	LBB_PORTIN		; PORTIN
  8629 D980 06 49			.byte	6,'I'			;
  8630 D982 1E D6			.word	LBB_I2CIN		; I2CIN
  8631 D984 05 52			.byte	5,'R'			;
  8632 D986 F5 D6			.word	LBB_RES5		; RESERVED
  8633 D988 05 52			.byte	5,'R'			;
  8634 D98A FA D6			.word	LBB_RES6		; RESERVED
  8635
  8636 				; BASIC messages, mostly error messages
  8637 D98C			LAB_BAER
  8638 D98C B0 D9			.word	ERR_NF			;$00 NEXT without FOR
  8639 D98E C1 D9			.word	ERR_SN			;$02 syntax
  8640 D990 C8 D9			.word	ERR_RG			;$04 RETURN without GOSUB
  8641 D992 DD D9			.word	ERR_OD			;$06 out of data
  8642 D994 E9 D9			.word	ERR_FC			;$08 function call
  8643 D996 F7 D9			.word	ERR_OV			;$0A overflow
  8644 D998 00 DA			.word	ERR_OM			;$0C out of memory
  8645 D99A 0E DA			.word	ERR_US			;$0E undefined statement
  8646 D99C 22 DA			.word	ERR_BS			;$10 array bounds
  8647 D99E 2F DA			.word	ERR_DD			;$12 double dimension array
  8648 D9A0 40 DA			.word	ERR_D0			;$14 divide by 0
  8649 D9A2 4F DA			.word	ERR_ID			;$16 illegal direct
  8650 D9A4 5E DA			.word	ERR_TM			;$18 type mismatch
  8651 D9A6 6C DA			.word	ERR_LS			;$1A long string
  8652 D9A8 7C DA			.word	ERR_ST			;$1C string too complex
  8653 D9AA 8F DA			.word	ERR_CN			;$1E continue error
  8654 D9AC 9E DA			.word	ERR_UF			;$20 undefined function
  8655 D9AE B1 DA			.word 	ERR_LD			;$22 LOOP without DO
  8656
  8657 				; I may implement these two errors to force definition of variables and
  8658 				; dimensioning of arrays before use.
  8659
  8660 				;	.word ERR_UV		;$24 undefined variable
  8661
  8662 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8663
  8664 				;	.word ERR_UA		;$26 undimensioned array
  8665 D9B0 4E 45 58 54 20 77 + ERR_NF	.by	'NEXT without FOR',$00
  8666 D9C1 53 79 6E 74 61 78 + ERR_SN	.by	'Syntax',$00
  8667 D9C8 52 45 54 55 52 4E + ERR_RG	.by	'RETURN without GOSUB',$00
  8668 D9DD 4F 75 74 20 6F 66 + ERR_OD	.by	'Out of DATA',$00
  8669 D9E9 46 75 6E 63 74 69 + ERR_FC	.by	'Function call',$00
  8670 D9F7 4F 76 65 72 66 6C + ERR_OV	.by	'Overflow',$00
  8671 DA00 4F 75 74 20 6F 66 + ERR_OM	.by	'Out of memory',$00
  8672 DA0E 55 6E 64 65 66 69 + ERR_US	.by	'Undefined statement',$00
  8673 DA22 41 72 72 61 79 20 + ERR_BS	.by	'Array bounds',$00
  8674 DA2F 44 6F 75 62 6C 65 + ERR_DD	.by	'Double dimension',$00
  8675 DA40 44 69 76 69 64 65 + ERR_D0	.by	'Divide by zero',$00
  8676 DA4F 49 6C 6C 65 67 61 + ERR_ID	.by	'Illegal direct',$00
  8677 DA5E 54 79 70 65 20 6D + ERR_TM	.by	'Type mismatch',$00
  8678 DA6C 53 74 72 69 6E 67 + ERR_LS	.by	'String too long',$00
  8679 DA7C 53 74 72 69 6E 67 + ERR_ST	.by	'String too complex',$00
  8680 DA8F 43 61 6E 27 74 20 + ERR_CN	.by	'Can' $27 't continue',$00
  8681 DA9E 55 6E 64 65 66 69 + ERR_UF	.by	'Undefined function',$00
  8682 DAB1 4C 4F 4F 50 20 77 + ERR_LD	.by	'LOOP without DO',$00
  8683
  8684 				;ERR_UV	.byte	'Undefined variable',$00
  8685
  8686 				; the above error has been tested and works (see code and comments below LAB_1D8B)
  8687
  8688 				;ERR_UA	.byte	'Undimensioned array',$00
  8689 DAC1 0D 0A 42 72 65 61 + LAB_BMSG	.byte	$0D,$0A,'Break',$00
  8690 DAC9 20 45 72 72 6F 72 + LAB_EMSG	.byte	' Error',$00
  8691 DAD0 20 69 6E 20 6C 69 + LAB_LMSG	.byte	' in line ',$00
  8692 DADA 0D 0A 52 65 61 64 + LAB_RMSG	.byte	$0D,$0A,'Ready',$0D,$0A,$00
  8693
  8694 DAE4 20 45 78 74 72 61 + LAB_IMSG	.byte	' Extra ignored',$0D,$0A,$00
  8695 DAF5 20 52 65 64 6F 20 + LAB_REDO	.byte	' Redo from start',$0D,$0A,$00
  8696
  8697 DB08			AA_end_basic
    43 						
    44 DB08					ORG	$DFD8
    45 				;----------------------------------------------------------------------------
    46 				; This function enables BIOS-ROM at $E000-$FFFF and disables the RAM behind it.
    47 				;----------------------------------------------------------------------------
    48 DFD8 AD 00 17		BIOS2ROM	LDA	MMU		; MMU-register
    49 DFDB 09 01				ORA	#BIOS_EN	; 1 = enable BIOS ROM
    50 DFDD 8D 00 17				STA	MMU		; Activate BIOS ROM
    51 DFE0 60					RTS			; return
    52 						
    53 				;----------------------------------------------------------------------------
    54 				; This function Enables BIOS-RAM at $E000-$FFFF and disables BIOS-ROM.
    55 				;----------------------------------------------------------------------------
    56 DFE1 AD 00 17		BIOS2RAM	LDA	MMU		; MMU-register
    57 DFE4 29 FE				AND	#~BIOS_EN	; 0 = enable BIOS RAM, disable ROM
    58 DFE6 8D 00 17				STA	MMU		; Activate BIOS RAM
    59 DFE9 60					RTS			; return
    60
    61 DFEA					ORG 	$DFF0
    62 DFF0 42			LANGKEY		.byte	'B'
    63 DFF1 28 42 29 61 73 69 + LANGNAME 	.by	'(B)asic' $00
    64
    65 DFF9					ORG 	$E000       		; start address of BIOS (8K)
    66 E000					icl 	"jc2_bios.asm"
Source: jc2_bios.asm
     1 				; ******************************************************************************
     2 				; Junior Computer ][ BIOS Version 1.2.0 by Joerg Walke
     3 				;
     4 				; first implementation 28.12.2021, updated 16.11.2024 by Joerg Walke
     5 				; Assembled With A65
     6 				;
     7 				; 20.03.2023 A bug in the disassembler code was fixed by the German Classic 
     8 				; Computing forum user jet2bue. See version history
     9 				;
    10 				; 01.08.2023 A bug in SD_WR_BLK was fixed. The bug was found by German Classic 
    11 				; Computing forum user Dietrich Lausberg. See version history
    12 				;
    13 				; 29.04.2024 SPI & IRQ optimization by Dietrich Lausberg
    14 				;
    15 				; 26.05.24 Changes in Fast SPI by Dietrich Lausberg
    16 				;
    17 				; 21.04.24 Integration with CF-IDE drivers into 1 32K eprom
    18 				; ******************************************************************************
    19
    20 E000 4C 3F E4		MON_COLD_START	JMP  	MAINSTART	; jump to monitor cold start
    21 E003 4C 3E E6		MON_WARM_START	JMP	MONINP		; jump to monitor warm start
    22
    23 				; **** Switch BASIC To RAM Page (B000..DFFF) ***********************************
    24 				; ******************************************************************************
    25 E006 20 8F FD		SWITCH_TO_RAM	JSR	BAS2RAM		; Set MMU bit 7 to 0, enable BASIC RAM
    26 E009 60					RTS			; return
    27
    28 				; **** Switch BASIC To ROM Page (B000..DFFF) ***********************************
    29 				; ******************************************************************************
    30 E00A 20 98 FD		SWITCH_TO_ROM	JSR	BAS2ROM		; Set MMU bit 7 to 1, enable BASIC ROM
    31 E00D EA			SWITCH		NOP			; maintain compatibility with v1.1.4
    32 E00E 60			_NO_HANDLER_	RTS
    33
    34 				; **** Set Standard In/Out Routine ID ******************************************
    35 				; Input: A - ID Of Standard IO Device
    36 				; ******************************************************************************
    37 E00F 20 BE F7		SET_STDIOID	JSR	DEV_OPEN
    38
    39 				; **** Set Standard In/Out Routine *********************************************
    40 				; Input: X - Low Byte Of Standard Device Descriptor
    41 				;	 Y - High Byte Of Standard Device Descriptor
    42 				; ******************************************************************************
    43 E012 20 32 E0		SET_STDIO	JSR	SET_STDIN
    44 E015 4C 1F E0				JMP	SET_STDOUT0
    45
    46 				; **** Set Standard Out Routine ID *********************************************
    47 				; Input: A - ID Of Standard Output Device
    48 				; ******************************************************************************
    49 E018 20 BE F7		SET_STDOUTID	JSR	DEV_OPEN
    50
    51 				; **** Set Standard Out Routine ************************************************
    52 				; Input: X - Low Byte Of Standard Out Device Descriptor
    53 				;	 Y - High Byte Of Standard Out Device Descriptor
    54 				; ******************************************************************************
    55 E01B 86 DE		SET_STDOUT	STX	PDEVL
    56 E01D 84 DF				STY	PDEVH
    57 E01F A0 04		SET_STDOUT0	LDY	#$04
    58 E021 A2 00				LDX	#$00
    59 E023 B1 DE		SET_STDOUT1	LDA	(PDEV),Y
    60 E025 9D 70 1A				STA	STDOUT,X
    61 E028 C8					INY
    62 E029 E8					INX
    63 E02A E0 04				CPX	#$04
    64 E02C D0 F5				BNE	SET_STDOUT1
    65 E02E 60					RTS
    66
    67 				; **** Set Standard In Routine ID **********************************************
    68 				; Input: A - ID Of Standard Input Device
    69 				; ******************************************************************************
    70 E02F 20 BE F7		SET_STDINID	JSR	DEV_OPEN
    71
    72 				; **** Set Standard In Routine *************************************************
    73 				; Input: X - Low Byte Of Standard In Device Descriptor
    74 				;	 Y - High Byte Of Standard In Device Descriptor
    75 				; ******************************************************************************
    76 E032 86 DE		SET_STDIN	STX	PDEVL
    77 E034 84 DF				STY	PDEVH
    78 E036 A0 02				LDY	#$02
    79 E038 B1 DE				LDA	(PDEV),Y
    80 E03A 8D 6E 1A				STA	STDIN
    81 E03D C8					INY
    82 E03E B1 DE				LDA	(PDEV),Y
    83 E040 8D 6F 1A				STA	STDIN+1
    84 E043 60			         	RTS
    85
    86 				; **** Write Binary Routine ****************************************************
    87 				; Input: A - Output Byte to Standard Out
    88 				; ******************************************************************************
    89 E044 6C 70 1A		BOUT		JMP	(STDOUT)
    90
    91 				; **** Read Character Routine **************************************************
    92 				; Output: A - character read from standard in
    93 				; ******************************************************************************
    94 E047 20 4D E0		CIN		JSR	CGET		; call standard in. Character available?
    95 E04A 90 FB				BCC	CIN		; no, repeat
    96 E04C 60					RTS
    97
    98 				; **** Get Character (no wait) Routine *****************************************
    99 				; Output: A - character read from standard in
   100 				;         C - 1 char get, 0 no char get
   101 				; ******************************************************************************
   102 E04D 4C D4 E1		CGET            JMP     CHAR_GET
   103
   104 				; **** Write LF Character Routine **********************************************
   105 				; ******************************************************************************
   106 E050 A9 0A		LFOUT		LDA  	#LF        	; write a LF
   107 									; fall through to COUT
   108
   109 				; **** Write Character Routine *************************************************
   110 				; Input: A - character to write
   111 				; ******************************************************************************
   112 E052 20 44 E0		COUT 		JSR     BOUT
   113 E055 C9 0D		                CMP  	#CR        	; character was a CR?
   114 E057 F0 F7				BEQ  	LFOUT      	; yes, also write LF
   115 E059 60					RTS
   116
   117 				; **** Write CR/LF To Terminal *************************************************
   118 				; ******************************************************************************
   119 E05A A9 0D		CROUT		LDA	#CR		; write a CR
   120 E05C D0 F4				BNE	COUT
   121
   122 				; **** Write Single Space Char To Terminal *************************************
   123 				; ******************************************************************************
   124 E05E A9 20		SPCOUT		LDA	#$20		; write a Space char
   125 E060 D0 E2				BNE	BOUT
   126
   127 				; **** Read String Routine *****************************************************
   128 				; Output:  (PSTRL, PSTRH) - pointer to CR terminated string data
   129 				; ******************************************************************************
   130 E062 A2 02		STRIN           LDX  	#$02		; initialize character index
   131 E064 CA			BACKSPACE       DEX
   132 E065 F0 FB				BEQ  	STRIN		; if line empty, restart
   133 E067 20 47 E0		NEXTCHR         JSR  	CIN        	; get next character from input buffer
   134 E06A 9D 00 14				STA  	STRBUF,X   	; store character in string buffer
   135 E06D C9 0D				CMP  	#CR		; is it a CR?
   136 E06F F0 0F		                BEQ  	ENDSTRIN	; yes, exit
   137 E071 20 52 E0		                JSR  	COUT		; echo character
   138 E074 C9 08				CMP  	#BS        	; backspace key?
   139 E076 F0 EC				BEQ  	BACKSPACE  	; yes
   140 E078 E8			                INX             	; advance string index
   141 E079 D0 EC		                BNE  	NEXTCHR    	; more then 255 characters? No, read next char
   142 E07B A9 0D		                LDA  	#CR        	; yes, auto new line and stop reading
   143 E07D 9D 00 14				STA  	STRBUF,X   	; store CR in string buffer
   144 E080 4C 52 E0		ENDSTRIN        JMP  	COUT       	; send CR
   145
   146 				; **** Write String Routine ****************************************************
   147 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   148 				; ******************************************************************************
   149 E083 A0 00		STROUT		LDY  	#$00       	; index y is 0
   150
   151 				; **** Write String From Index Routine *****************************************
   152 				; Input:  (PSTRL, PSTRH) - pointer to null terminated string data
   153 				;	  Y              - start index into string data
   154 				; ******************************************************************************
   155 E085 B1 EA		WRSTR		LDA  	(PSTR),Y   	; load char at string pos y
   156 E087 F0 07				BEQ  	ENDSTROUT  	; exit, if NULL char
   157 E089 20 52 E0				JSR  	COUT       	; write character
   158 E08C C8					INY             	; next index
   159 E08D 4C 85 E0				JMP  	WRSTR
   160 E090 60			ENDSTROUT	RTS
   161
   162 				; **** Print A Byte In Hexadecimal *********************************************
   163 				; Input: A - data byte to print in hex
   164 				; ******************************************************************************
   165 E091 48			HEXOUT          PHA             	; save A for lower hex digit
   166 E092 4A			                LSR  	
   167 E093 4A			                LSR  	
   168 E094 4A			                LSR  	
   169 E095 4A			                LSR  	
   170 E096 20 9A E0		                JSR  	HEXDIG		; write upper hex digit
   171 E099 68			                PLA             	; write lower hex digit
   172 									; fall through to HEXDIG
   173
   174 				; **** Print A Single Hexadecimal Digit ****************************************
   175 				; Input: A - data nibble in Bit 0-3 to print in hex
   176 				; ******************************************************************************
   177 E09A 29 0F		HEXDIG          AND     #$0F    	; mask lower digit
   178 E09C 09 30		                ORA     #'0'    	; add 48
   179 E09E C9 3A		                CMP     #'9'+1  	; decimal digit?
   180 E0A0 90 02		                BCC     PRHEX   	; yes, print it
   181 E0A2 69 06		                ADC     #6      	; add offset for letter digit
   182 E0A4 4C 44 E0		PRHEX		JMP     BOUT
   183
   184 				; **** Print A Byte As Decimal Number ******************************************
   185 				; Input: A - number 00..FF (0..255)
   186 				; ******************************************************************************
   187 E0A7 20 BD E0		NUMOUT		JSR	DEC2STR
   188 E0AA A2 02				LDX	#2
   189 E0AC B5 F8		NEXTNUMOUT	LDA	DIG0,X
   190 E0AE 20 44 E0				JSR	BOUT
   191 E0B1 CA					DEX
   192 E0B2 10 F8				BPL	NEXTNUMOUT
   193 E0B4 60					RTS
   194
   195 				; **** Clear Screen Routine ****************************************************
   196 				; ******************************************************************************
   197 E0B5 A9 07		CLRSCRN		LDA	#CMD_CLRSCRN
   198
   199 				; **** Call Standard Print Command Routine *************************************
   200 				; Input : A - command byte
   201 				;         X - command data byte low
   202 				;         Y - command data byte high
   203 				; ******************************************************************************
   204 E0B7 6C 72 1A		CMDPRINT	JMP	(STDCMD)
   205
   206 				; **** Call Opened Device Command Routine **************************************
   207 				; Input : A - command byte
   208 				;         X - command data byte low
   209 				;         Y - command data byte high
   210 				; ******************************************************************************
   211 E0BA 6C 6C 1A		CMDDEV		JMP	(DEVCMD)
   212
   213 				; **** Convert a Byte To Decimal String ****************************************
   214 				; Input:  A - number 00..FF (0..255)
   215 				; Output; DIG0 (10^0), DIG1 (10^1), DIG2 (10^2)
   216 				; ******************************************************************************
   217 E0BD A2 30		DEC2STR		LDX	#48
   218 E0BF 86 F8				STX	DIG0		; initialize digit counter 0 to '0'
   219 E0C1 86 F9				STX	DIG1		; initialize digit counter 1 to '0'
   220 E0C3 86 FA				STX	DIG2		; initialize digit counter 2 to '0'
   221 E0C5 C9 64		GETDIG2		CMP	#100		; is A >= 100?
   222 E0C7 90 06				BCC	GETDIG1		; no, convert next digit
   223 E0C9 E9 64				SBC	#100		; yes, subract 100 from A
   224 E0CB E6 FA				INC	DIG2		; and increment digit counter 2
   225 E0CD D0 F6				BNE	GETDIG2		; branch always
   226 E0CF C9 0A		GETDIG1		CMP	#10		; is A >= 10?
   227 E0D1 90 06				BCC	GETDIG0		; no, convert next digit
   228 E0D3 E9 0A				SBC	#10		; yes, subract 10 from A
   229 E0D5 E6 F9				INC	DIG1		; and increment digit counter 1
   230 E0D7 D0 F6				BNE	GETDIG1		; branch always
   231 E0D9 65 F8		GETDIG0		ADC	DIG0		; add digit counter 0 to remainder in A
   232 E0DB 85 F8				STA	DIG0		; and store it back to digit counter 0
   233 E0DD 60					RTS
   234
   235 				; **** Print Tab Routine *******************************************************
   236 				; Input: A - number of space characters to print
   237 				; ******************************************************************************
   238 E0DE 85 FC		PRTAB		STA  	TEMP
   239 E0E0 A9 20				LDA  	#SPC		; load SPC char
   240 E0E2 20 52 E0		PRINTTAB	JSR  	COUT		; write SPC
   241 E0E5 C6 FC				DEC   	TEMP
   242 E0E7 D0 F9		                BNE   	PRINTTAB   	; all spaces written? No, repeat
   243 E0E9 60					RTS
   244
   245 				; **** Read Hex Number From Input String ***************************************
   246 				; Input:  Y - current input string position to read from
   247 				; Output: (NUML, NUMH) - last 8 digits of read hex number
   248 				; ******************************************************************************
   249 E0EA A2 00		HEXINPUT	LDX   	#$00
   250 E0EC 86 F8				STX   	NUML       	; clear input value
   251 E0EE 86 F9				STX   	NUMH
   252 E0F0 B9 00 14		NEXTDIGIT       LDA   	STRBUF,Y   	; get next input char
   253 E0F3 C9 30				CMP   	#'0'
   254 E0F5 90 21				BCC   	NOTHEX     	; char < '0'? Yes, no hex digit
   255 E0F7 C9 3A				CMP   	#':'
   256 E0F9 90 0C				BCC   	NUMDIGIT   	; char is in '0'..'9'
   257 E0FB 29 DF				AND   	#$DF	 	; uppercase chars only
   258 E0FD C9 41		HEXDIGIT	CMP   	#'A'
   259 E0FF 90 17				BCC   	NOTHEX     	; char < 'A'? Yes, no hex digit
   260 E101 C9 47				CMP   	#'G'
   261 E103 B0 13				BCS   	NOTHEX     	; char > 'F'? Yes, no hex digit
   262 E105 E9 36				SBC   	#'A'-11	 	; char 'A'..'F' to value 10..16
   263 E107 0A			NUMDIGIT        ASL   	
   264 E108 0A					ASL   	
   265 E109 0A					ASL   	
   266 E10A 0A					ASL   			; digit shifted to upper nibble
   267 E10B A2 04				LDX   	#$04      	; load shift loop counter
   268 E10D 0A			SHIFT		ASL   			; shift msb in C
   269 E10E 26 F8				ROL   	NUML
   270 E110 26 F9				ROL   	NUMH
   271 E112 CA					DEX
   272 E113 D0 F8				BNE   	SHIFT	 	; 4 times shifted? No, repeat
   273 E115 C8					INY		 	; increment string index
   274 E116 D0 D8				BNE   	NEXTDIGIT	; branch always
   275 E118 60			NOTHEX		RTS
   276
   277 				; **** Read String From Input Buffer *******************************************
   278 				; Input:  Y - current input string position to read from
   279 				; Output: C = 1, string found C = 0, string not found
   280 				;         PSTRL = low byte of string pointer
   281 				;	  PSTRH = high byte of string pointer
   282 				; ******************************************************************************
   283 E119 18			STRINPUT	CLC
   284 E11A B9 00 14		NEXTSTRCHAR	LDA  	STRBUF,Y   	; get next input char
   285 E11D C8					INY
   286 E11E C9 20				CMP  	#' '
   287 E120 F0 F8				BEQ  	NEXTSTRCHAR 	; ignore spaces
   288 E122 C9 0D				CMP  	#CR
   289 E124 F0 19				BEQ  	ENDSTRING 	; end of input line, no filename found
   290 E126 C9 22				CMP	#'"'
   291 E128 D0 15				BNE	ENDSTRING
   292 E12A A2 00				LDX	#$00
   293 E12C 38					SEC
   294 E12D B9 00 14		READSTRING	LDA  	STRBUF,Y   	; get next input char
   295 E130 C9 0D				CMP	#CR
   296 E132 F0 0B				BEQ	ENDSTRING
   297 E134 C9 22				CMP	#'"'
   298 E136 F0 07				BEQ	ENDSTRING
   299 E138 9D 00 15				STA	RBUFF,X		; char to buffer
   300 E13B C8					INY
   301 E13C E8					INX
   302 E13D D0 EE				BNE	READSTRING	; read next char of filename
   303 E13F A9 00		ENDSTRING	LDA	#$00
   304 E141 9D 00 15				STA	RBUFF,X		; terminate filename string with NULL
   305
   306 				; **** Set String Pointer To Read Buffer ***************************************
   307 				; Output: X - low byte of string pointer
   308 				;	  Y - high byte of string pointer
   309 				; ******************************************************************************
   310
   311 E144 A2 00		SETSTRBUFF	LDX	#< RBUFF	; set string pointer to filename buffer
   312 E146 A0 15				LDY	#> RBUFF
   313 E148 86 EA		SETSTRBUFF0	STX	PSTRL
   314 E14A 84 EB				STY	PSTRH
   315 E14C 60					RTS
   316
   317 				; **** Delay Routine ***********************************************************
   318 				; Input: A - milliseconds to wait
   319 				; ******************************************************************************
   320 E14D 8D 97 1A		DELAY           STA  	CNTD
   321 E150 D0 04				BNE	LOOPDELAY
   322
   323 				; **** Short Delay Routine *****************************************************
   324 				; Input: A - microseconds to wait
   325 				; ******************************************************************************
   326 E152 A8			SHORTDELAY	TAY
   327 E153 8C 94 1A		SHORTDELAY1	STY  	CNTA		; set counter
   328 E156 2C 9F 1A		LOOPDELAY	BIT  	CNTIRQ		; check if counter reached 0
   329 E159 10 FB				BPL  	LOOPDELAY	; no, check again
   330 E15B 60					RTS
   331
   332 				; **** Check ESC Routine *******************************************************
   333 				; Output: C = 1 ESC pressed, 0 ESC not pressed
   334 				; Beep if ESC pressed
   335 				; ******************************************************************************
   336 E15C 20 4D E0		CHKESC		JSR     CGET            ; key pressed?
   337 E15F 90 05				BCC	NOTESC		; no
   338 E161 C9 1B				CMP     #ESC		; ESC pressed?
   339 E163 F0 02				BEQ	BEEP		; yes, exit and beep.
   340 E165 18					CLC			; no, clear carry flag
   341 E166 60			NOTESC		RTS
   342
   343 				; **** System Beep Routine *****************************************************
   344 				; ******************************************************************************
   345 E167 6C 66 1A		BEEP		JMP	(STDBEEP)	; call standard BEEP routine
   346
   347 				; **** Simple Beep Routine *****************************************************
   348 				; ******************************************************************************
   349 E16A AD 83 1A		DOBEEP		LDA	PBDD		; save port b data direction register
   350 E16D 48					PHA
   351 E16E A2 60				LDX     #$60		; repeat 60 times
   352 E170 A9 21				LDA     #$21
   353 E172 A8					TAY
   354 E173 8D 83 1A				STA     PBDD		; turn speaker on
   355 E176 8C 82 1A		BEEPLOOP	STY     PBD		; set PB0 high
   356 E179 A9 01				LDA     #$01
   357 E17B 20 4D E1				JSR     DELAY		; delay of ~1ms
   358 E17E 88					DEY
   359 E17F 8C 82 1A				STY	PBD		; set PB0 low
   360 E182 A9 01				LDA	#$01
   361 E184 20 4D E1				JSR	DELAY		; delay of ~1ms
   362 E187 A0 21				LDY	#$21
   363 E189 CA					DEX
   364 E18A D0 EA				BNE	BEEPLOOP	; not finished, repeat
   365 E18C 68					PLA
   366 E18D 8D 83 1A				STA	PBDD		; restore port b data direction register
   367 E190 38					SEC
   368 E191 60					RTS
   369
   370 				; ******************************************************************************
   371 				; REAL TIME CLOCK ROUTINES ALIASES
   372 				; ******************************************************************************
   373
   374 				; **** Print Date And Time *****************************************************
   375
   376 				; ******************************************************************************
   377
   378 E192 4C F9 EB		PRINT_DATETIME	JMP	PRINTDATETIME
   379
   380 				; **** Print Time *************************************************************
   381
   382 				; ******************************************************************************
   383
   384 E195 4C 05 EC		PRINT_TIME	JMP	PRINTTIME
   385
   386 				; **** Print Date **************************************************************
   387
   388 				; ******************************************************************************
   389
   390 E198 4C 2B EC		PRINT_DATE	JMP	PRINTDATE
   391
   392 				; **** Print Date Including Day Of Week ****************************************
   393
   394 				; ******************************************************************************
   395
   396 E19B 4C 17 EC		PRINT_FULLDATE	JMP	PRINTFULLDATE
   397
   398 				; **** Set Date And Time *******************************************************
   399
   400 				; ******************************************************************************
   401
   402 E19E 4C 59 EB		SET_DATETIME	JMP	SETDATETIME
   403
   404 				; **** Set Time ****************************************************************
   405
   406 				; ******************************************************************************
   407
   408 E1A1 4C 86 EB		SET_TIME	JMP	SETTIME
   409
   410 				; **** Set Date ****************************************************************
   411
   412 				; ******************************************************************************
   413
   414 E1A4 4C 5C EB		SET_DATE	JMP	SETDATE
   415
   416 				; **** Add Storage Device ******************************************************
   417
   418 				; Input:   X - device descriptor pointer low
   419 				;          Y - device descriptor pointer high
   420 				; Output - C = 1 Success, C = 0 Error
   421 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
   422
   423 				; ******************************************************************************
   424
   425 E1A7 4C 6F F7		ADD_DEVICE	JMP	DEV_ADD
   426
   427 				; **** Open Device For Read/Write **********************************************
   428
   429 				; Input:  A - device id
   430 				; Output: C = 1 Success, C = 0 Error
   431 				;         X - device descriptor pointer low
   432 				;         Y - device descriptor pointer high
   433
   434 				; ******************************************************************************
   435
   436 E1AA 4C BE F7		OPEN_DEVICE	JMP	DEV_OPEN
   437
   438 				; **** Reset Standard I/O To First Screen Device *******************************
   439
   440 				; ******************************************************************************
   441
   442 E1AD AD 74 1A		RESET_STDIO	LDA	STDINDEV	; open base In device
   443 E1B0 20 2F E0				JSR	SET_STDINID	; and set it as standard input
   444 E1B3 AD 75 1A				LDA	STDOUTDEV	; open base Out device
   445 E1B6 4C 18 E0				JMP	SET_STDOUTID	; and set it as standard output
   446
   447 				; **** Read Joystick Port ******************************************************
   448
   449 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   450 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   451 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   452 				;         C = 0 - No joystick port available; C = 1 - Joystickport available
   453
   454 				; ******************************************************************************
   455
   456 E1B9 4C 15 F7		READ_JOYSTICK   JMP     READ_JOY_PORT
   457
   458 				; **** Decode Joystick Data ****************************************************
   459
   460 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
   461 				;         X - horizontal joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
   462 				;         Y - vertical joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
   463
   464 				; ******************************************************************************
   465
   466 E1BC 4C 1D F7		DECODE_JOYSTICK JMP     DECODE_JOY_PORT
   467
   468 				; **** Mute All Sound Chip Channels ********************************************
   469
   470 				; ******************************************************************************
   471
   472 E1BF 4C D0 E3		SOUND_MUTE_ALL  JMP     SOUND_MUTEALL
   473
   474 				; **** Mute A Sound Chip Channel ***********************************************
   475
   476 				; Input: A - Channel # (0..3)
   477
   478 				; ******************************************************************************
   479
   480 E1C2 4C DA E3		SOUND_MUTE_CHAN JMP     SOUND_MUTE
   481
   482 				; **** Set Attenuation For A Sound Chip Channel ********************************
   483
   484 				; Input: A - Channel # (0..3)
   485 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
   486
   487 				; ******************************************************************************
   488
   489 E1C5 4C DC E3		SOUND_SET_ATN   JMP     SOUND_SETATN
   490
   491 				; **** Set Periodic Noise ******************************************************
   492
   493 				; Input: X - Noise Shift Rate
   494
   495 				; ******************************************************************************
   496
   497 E1C8 4C EA E3		SOUND_P_NOISE   JMP     SOUND_PNOISE
   498
   499 				; **** Set White Noise *********************************************************
   500
   501 				; Input: X - Noise Shift Rate
   502
   503 				; ******************************************************************************
   504
   505 E1CB 4C EE E3		SOUND_W_NOISE   JMP     SOUND_WNOISE
   506
   507 				; **** Set Noise ***************************************************************
   508
   509 				; Input: A - 0 = Periodic Noise  1 = White Noise
   510 				;	 X - Noise Shift Rate
   511
   512 				; ******************************************************************************
   513
   514 E1CE 4C F0 E3		SOUND_SET_NOISE JMP     SOUND_SETNOISE
   515
   516 				; **** Set Sound Frequency in HZ ***********************************************
   517
   518 				; Input: A - Channel (0..2)
   519 				;	 X - Frequency Low Bits 7..0
   520 				;	 Y - Frequency High Bits 9..8
   521
   522 				; ******************************************************************************
   523
   524 E1D1 4C FB E3		SOUND_SET_FREQ  JMP     SOUND_SETFREQ
   525
   526 				; ******************************************************************************
   527 				; INTERNAL
   528 				; ******************************************************************************
   529
   530 				; **** Extended Read-Character Handler *****************************************
   531
   532 E1D4 20 DF E1		CHAR_GET        JSR     READ_STD_IN
   533 E1D7 90 03		                BCC     NO_CHAR_GET
   534 E1D9 6C 24 1A		                JMP     (KEY_HANDLER)
   535 E1DC 6C 26 1A		NO_CHAR_GET     JMP     (NKEY_HANDLER)
   536 E1DF 6C 6E 1A		READ_STD_IN     JMP	(STDIN)
   537
   538 				; ******************************************************************************
   539 				; TTY DEVICE DRIVER
   540 				; ******************************************************************************
   541
   542 				; **** Terminal Command Routine ************************************************
   543
   544 				; Input : A - command byte
   545 				;         X - command data byte low
   546 				;         Y - command data byte high
   547
   548 				; ******************************************************************************
   549
   550 E1E2 C9 09		TTY_CMD		CMP	#9
   551 E1E4 B0 13				BCS	END_TTY_CMD
   552 E1E6 84 FD				STY	YSAV
   553 E1E8 0A					ASL	
   554 E1E9 A8					TAY
   555 E1EA B9 FA E1				LDA	TTY_CMD_TABLE,Y
   556 E1ED 85 EA				STA	PSTRL
   557 E1EF B9 FB E1				LDA	TTY_CMD_TABLE+1,Y
   558 E1F2 85 EB				STA	PSTRH
   559 E1F4 A4 FD				LDY	YSAV
   560 E1F6 6C EA 00				JMP     (PSTR)
   561 E1F9 60			END_TTY_CMD	RTS
   562
   563 E1FA 0C E2 3A E2 3E E2 + TTY_CMD_TABLE	.word	TTY_INIT,TTY_IDENTIFY,TTY_NORMAL,TTY_INVERSE,TTY_FLASH
   564 E204 4A E2 4E E2 57 E2 + 		.word	TTY_HOME,TTY_CLRLINE,TTY_CLRSCRN,TTY_SETCURSOR
   565
   566 				; **** Initialize TTY Device ***************************************************
   567
   568 				; ******************************************************************************
   569
   570 E20C A9 00		TTY_INIT	LDA  	#$00
   571 E20E 85 E0				STA  	BAUDRATE   	; initialize baud rate variable
   572 E210 A9 0B				LDA  	#$0B       	; set ACIA to
   573 E212 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
   574 E215 A2 19				LDX  	#$19		; start with 1 stop bit, 8 data bits, 2400 bps as the current baud rate
   575 E217 8E 03 16		NEXTBAUD	STX  	CTRL_REG	; set the baud rate
   576 E21A 20 3A E2				JSR  	TTY_IDENTIFY	; send identify string to terminal
   577 E21D A9 28				LDA  	#40
   578 E21F 20 4D E1				JSR  	DELAY		; wait for ~64ms
   579 E222 AD 01 16				LDA  	STAT_REG
   580 E225 29 08				AND  	#$08		; ACIA input register full?
   581 E227 F0 0B				BEQ  	NOESC	 	; no, go on
   582 E229 AD 00 16				LDA  	DATA_REG    	; read data register from ACIA
   583 E22C C9 1B				CMP  	#ESC	 	; is it a ESC char
   584 E22E D0 04				BNE  	NOESC	 	; no, go on
   585 E230 86 E0				STX  	BAUDRATE    	; and store it
   586 E232 A2 1F				LDX  	#$1F	 	; detection finished
   587 E234 E8			NOESC           INX  			; try next baud rate
   588 E235 E0 20				CPX  	#$20
   589 E237 90 DE				BCC  	NEXTBAUD   	; tried all baud rates?
   590 E239 60					RTS
   591
   592 				; **** Identify TTY Device *****************************************************
   593
   594 				; ******************************************************************************
   595
   596 E23A A0 09		TTY_IDENTIFY    LDY  	#ESCGID-STRINGP	; load sequence index
   597 E23C D0 1B				BNE  	PRINTESC   	; jump always
   598
   599 				; **** Set Normal Text *********************************************************
   600
   601 				; ******************************************************************************
   602
   603 E23E A0 0C		TTY_NORMAL      LDY  	#ESCNORM-STRINGP; load sequence index
   604 E240 D0 17				BNE  	PRINTESC   	; jump always
   605
   606 				; **** Set Inverse Text ********************************************************
   607
   608 				; ******************************************************************************
   609
   610 E242 A0 0E		TTY_INVERSE     LDY  	#ESCINV-STRINGP ; load sequence index
   611 E244 D0 13				BNE  	PRINTESC   	; jump always
   612
   613 				; **** Set Blinking Text *******************************************************
   614
   615 				; ******************************************************************************
   616
   617 E246 A0 11		TTY_FLASH       LDY  	#ESCBLNK-STRINGP; load sequence index
   618 E248 D0 0F				BNE  	PRINTESC   	; jump always
   619
   620 				; **** Set Cursor To Home Position *********************************************
   621
   622 				; ******************************************************************************
   623
   624 E24A A0 04		TTY_HOME        LDY  	#ESCHOME-STRINGP; load sequence index
   625 E24C D0 0B				BNE  	PRINTESC   	; jump always
   626
   627 				; **** Clear Line **************************************************************
   628
   629 				; ******************************************************************************
   630
   631 E24E A9 0D		TTY_CLRLINE     LDA	#$0D
   632 E250 20 44 E0				JSR	BOUT
   633 E253 A0 06				LDY  	#ESCCLL-STRINGP	; load sequence index
   634 E255 D0 02				BNE  	PRINTESC   	; jump always
   635
   636 				; **** Clear Screen And Set Cursor To Home Position ****************************
   637
   638 				; ******************************************************************************
   639
   640 E257 A0 00		TTY_CLRSCRN     LDY  	#ESCCLS-STRINGP	; load sequence index
   641 									; fall through to PRINTESC
   642
   643 				; **** VT100 ESC Sequence Loader ***********************************************
   644
   645 				; ******************************************************************************
   646
   647 E259 20 62 E2		PRINTESC        JSR	TTY_ESCCODE
   648 E25C 20 43 E5				JSR	LOADSTRING
   649 E25F 4C 85 E0				JMP  	WRSTR
   650
   651 				; **** VT100 ESC Start Code ****************************************************
   652
   653 				; ******************************************************************************
   654
   655 E262 A9 1B		TTY_ESCCODE	LDA	#$1B
   656 E264 20 44 E0				JSR	BOUT
   657 E267 A9 5B				LDA	#'['
   658 E269 4C 44 E0				JMP	BOUT
   659
   660 				; **** Set Cursor Location *****************************************************
   661
   662 				; Input: X - x position of cursor.  Y - y position of cursor
   663
   664 				; ******************************************************************************
   665
   666 E26C 8A			TTY_SETCURSOR	TXA
   667 E26D 48					PHA
   668 E26E 20 62 E2				JSR	TTY_ESCCODE
   669 E271 98					TYA
   670 E272 20 A7 E0				JSR	NUMOUT
   671 E275 A9 3B				LDA	#';'
   672 E277 20 44 E0				JSR	BOUT
   673 E27A 68					PLA
   674 E27B 20 A7 E0				JSR	NUMOUT
   675 E27E A9 48				LDA	#'H'
   676 E280 4C 44 E0				JMP	BOUT
   677
   678 				; ******************************************************************************
   679 				; LOW LEVEL REAL TIME CLOCK CODE
   680 				; ******************************************************************************
   681
   682 				; **** Set Day Of Week *********************************************************
   683
   684 				; Input: A - Day Of Week 1 (MON) - 7 (SUN)
   685
   686 				; ******************************************************************************
   687
   688 E283 85 F3		WRITEDOW	STA	ACC
   689 E285 A9 03				LDA	#$03
   690 E287 20 13 E3				JSR	SETRTCADR
   691 E28A A5 F3				LDA	ACC
   692 E28C 20 67 E3				JSR	I2C_SEND	; set day of week
   693 E28F 4C 35 E3				JMP	I2C_STOP
   694
   695 				; **** Get Day Of Week *********************************************************
   696
   697 				; Output: A - Day Of Week 1 (MON) - 7 (SUN)
   698
   699 				; ******************************************************************************
   700
   701 E292 A9 03		READDOW		LDA	#$03
   702 E294 20 E6 E2				JSR	READCLOCK
   703 E297 98					TYA
   704 E298 60					RTS
   705
   706 				; **** Write Time **************************************************************
   707
   708 				; Input: A - HOUR 	in BCD ($00-$23)
   709 				;	 X - MINUTE 	in BCD ($00-$59)
   710 				;	 Y - SECOND	in BCD ($00-$59)
   711
   712 				; ******************************************************************************
   713
   714 E299 85 F3		WRITETIME	STA	ACC
   715 E29B 86 F5				STX	XREG
   716 E29D 84 F4				STY	YREG
   717 E29F A9 00		WRITETIME2	LDA	#$00		; start at register 0
   718 E2A1 20 C9 E2				JSR	WRITECLOCK	; write time bytes to clock registers
   719 E2A4 A9 08				LDA	#$08		; set address pointer to ram
   720 E2A6 20 13 E3				JSR	SETRTCADR
   721 E2A9 A9 65				LDA	#$65		; time set mark
   722 E2AB 20 67 E3				JSR	I2C_SEND
   723 E2AE 4C 35 E3				JMP	I2C_STOP
   724
   725 				; **** Write Date **************************************************************
   726
   727 				; Input: A - YEAR 	in BCD ($00-$99)
   728 				;	 X - MONTH 	in BCD ($01-$12)
   729 				;	 Y - DAY	in BCD ($01-$31)
   730
   731 				; ******************************************************************************
   732
   733 E2B1 85 F3		WRITEDATE	STA	ACC
   734 E2B3 86 F5				STX	XREG
   735 E2B5 84 F4				STY	YREG
   736 E2B7 A9 04		WRITEDATE2	LDA	#$04		; start at register 4
   737 E2B9 20 C9 E2				JSR	WRITECLOCK	; write date bytes to clock register
   738 E2BC A9 09				LDA	#$09		; set address pointer to ram
   739 E2BE 20 13 E3				JSR	SETRTCADR
   740 E2C1 A9 02				LDA	#$02		; date set mark
   741 E2C3 20 67 E3				JSR	I2C_SEND
   742 E2C6 4C 35 E3				JMP	I2C_STOP
   743
   744 				; **** Write Data To Clock *****************************************************
   745
   746 				; ******************************************************************************
   747
   748 E2C9 20 13 E3		WRITECLOCK	JSR	SETRTCADR
   749 E2CC A5 F4				LDA	YREG
   750 E2CE 20 67 E3				JSR	I2C_SEND	; set second or day
   751 E2D1 A5 F5				LDA	XREG
   752 E2D3 20 67 E3				JSR	I2C_SEND	; set minute or month
   753 E2D6 A5 F3				LDA	ACC
   754 E2D8 20 67 E3				JSR	I2C_SEND	; set hour or year
   755 E2DB 4C 35 E3				JMP	I2C_STOP
   756
   757 				; **** Read Time ***************************************************************
   758
   759 				; Output: A - HOUR 	in BCD ($00-$23)
   760 				;	  X - MINUTE 	in BCD ($00-$59)
   761 				;	  Y - SECOND	in BCD ($00-$59)
   762
   763 				; ******************************************************************************
   764
   765 E2DE A9 00		READTIME	LDA	#$00
   766 E2E0 F0 04				BEQ	READCLOCK
   767
   768 				; **** Read Date ***************************************************************
   769
   770 				; Output: A - YEAR 	in BCD ($00-$99)
   771 				; 	  X - MONTH 	in BCD ($01-$12)
   772 				; 	  Y - DAY	in BCD ($01-$31)
   773
   774
   775 				; ******************************************************************************
   776
   777 E2E2 A9 04		READDATE	LDA	#$04
   778 E2E4 D0 00				BNE	READCLOCK
   779
   780 				; **** Read Data From Clock ****************************************************
   781
   782 				; ******************************************************************************
   783
   784 E2E6 20 13 E3		READCLOCK	JSR	SETRTCADR	; set read pointer
   785 E2E9 20 26 E3				JSR	I2C_START	; send start condition
   786 E2EC A9 68				LDA	#I2C_RTC_ADR	; the I2C address
   787 E2EE 20 62 E3				JSR	I2C_READ_DEV	; send device id and set read mode
   788 E2F1 20 9F E3				JSR	I2C_RCV		; receive first data byte
   789 E2F4 85 F4				STA	YREG		; and store it
   790 E2F6 20 44 E3				JSR	I2C_ACK		; send acknowlege
   791 E2F9 20 9F E3				JSR	I2C_RCV		; receive second data byte
   792 E2FC 85 F5				STA	XREG		; and store it
   793 E2FE 20 44 E3				JSR	I2C_ACK		; send acknowlege
   794 E301 20 9F E3				JSR	I2C_RCV		; receive third data byte
   795 E304 85 F3				STA	ACC		; and store it
   796 E306 20 53 E3				JSR	I2C_NACK	; no more data
   797 E309 20 35 E3				JSR	I2C_STOP	; stop communication
   798 E30C A5 F3				LDA	ACC		; load third data byte into A
   799 E30E A6 F5				LDX	XREG		; load second data byte into X
   800 E310 A4 F4				LDY	YREG		; load first data byte into Y
   801 E312 60					RTS
   802
   803 				; **** Set RTC Address Read/Write Pointer **************************************
   804
   805 				; Input: A - Register Address
   806
   807 				; ******************************************************************************
   808
   809 E313 48			SETRTCADR	PHA			; save register address onto stack
   810 E314 20 26 E3				JSR	I2C_START	; send start condition
   811 E317 A9 68				LDA	#I2C_RTC_ADR	; the I2C device address
   812 E319 20 66 E3				JSR	I2C_WRITE_DEV	; send device address and write bit
   813 E31C 68					PLA			; restore register address
   814 E31D 4C 67 E3				JMP	I2C_SEND	; send register address
   815
   816 						; 25-07-25 Emile: WRITE_VIA and READ_VIA removed
   817 E320					ORG	*+6		; Maintain compatibility with v1.1.4
   818 						
   819 				; ******************************************************************************
   820 				; START OF I2C CODE
   821 				; ******************************************************************************
   822
   823 				; **** Send I2C Start Condition ************************************************
   824
   825 				; ******************************************************************************
   826
   827 E326 A0 12		I2C_START	LDY	#DDRB
   828 E328 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   829 E32A 91 14				STA	(IOBASE),Y
   830 E32C A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   831 E32E 91 14				STA	(IOBASE),Y
   832 E330 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   833 E332 91 14				STA	(IOBASE),Y
   834 E334 60					RTS
   835
   836 				; **** Send I2C Stop Condition *************************************************
   837
   838 				; ******************************************************************************
   839
   840 E335 A0 12		I2C_STOP	LDY	#DDRB
   841 E337 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   842 E339 91 14				STA	(IOBASE),Y
   843 E33B A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   844 E33D 91 14				STA	(IOBASE),Y
   845 E33F A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   846 E341 91 14				STA	(IOBASE),Y
   847 E343 60					RTS
   848
   849 				; **** Send I2C Acknowledged ***************************************************
   850
   851 				; ******************************************************************************
   852
   853 E344 A0 12		I2C_ACK		LDY	#DDRB
   854 E346 A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   855 E348 91 14				STA	(IOBASE),Y
   856 E34A A9 DE				LDA	#%11011110	; SDA = 0; SCL = 1
   857 E34C 91 14				STA	(IOBASE),Y
   858 E34E A9 DF				LDA	#%11011111	; SDA = 0; SCL = 0
   859 E350 91 14				STA	(IOBASE),Y
   860 E352 60					RTS
   861
   862 				; **** Send I2C Not Acknowledged ***********************************************
   863
   864 				; ******************************************************************************
   865
   866 E353 A0 12		I2C_NACK	LDY	#DDRB
   867 E355 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   868 E357 91 14				STA	(IOBASE),Y
   869 E359 A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   870 E35B 91 14				STA	(IOBASE),Y
   871 E35D A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   872 E35F 91 14				STA	(IOBASE),Y
   873 E361 60					RTS
   874
   875 				; **** Read I2C Device *********************************************************
   876
   877 				; Input:  A - Device Address
   878 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   879
   880 				; ******************************************************************************
   881
   882 E362 38			I2C_READ_DEV	SEC			; set carry flag
   883 E363 2A					ROL			; shift device address one bit left and rotate C in LSB. LSB = 1 = read
   884 E364 D0 01				BNE	I2C_SEND	; and send it
   885
   886 				; **** Write I2C Device ********************************************************
   887
   888 				; Input:  A - Device Address
   889 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   890
   891 				; ******************************************************************************
   892
   893 E366 0A			I2C_WRITE_DEV	ASL			; shift device address one bit left. LSB is now 0 = write
   894 									; directly fallthrough to I2C_SEND
   895
   896 				; **** Send a Byte to I2C Device ***********************************************
   897
   898 				; Input:  A - Data Byte
   899 				; Output: C - 0 = not acknowledged, 1 = acknowledged
   900
   901 				; ******************************************************************************
   902
   903 E367 85 E0		I2C_SEND	STA	I2C_DATA
   904 E369 A2 08				LDX	#$08		; send 8 bits
   905 E36B A0 12				LDY	#DDRB
   906 E36D 06 E0		SENDLOOP	ASL	I2C_DATA	; get next bit into C flag
   907 E36F B0 04				BCS	MSENDH		; is it a 1 bit?
   908 E371 A9 DF				LDA	#%11011111	; no, SDA = 0; SCL = 0
   909 E373 D0 02				BNE	SETBIT		; branch always
   910 E375 A9 5F		MSENDH		LDA	#%01011111	; yes, SDA = 1; SCL = 0
   911 E377 91 14		SETBIT		STA	(IOBASE),Y
   912 E379 29 FE				AND	#%11111110	; SDA = X; SCL = 1
   913 E37B 91 14				STA	(IOBASE),Y
   914 E37D 09 01				ORA	#%00000001	; SDA = X, SCL = 0
   915 E37F 91 14				STA	(IOBASE),Y
   916 E381 CA					DEX
   917 E382 D0 E9				BNE	SENDLOOP
   918
   919 E384 A0 12		I2C_ACK?	LDY	#DDRB
   920
   921 E386 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   922 E388 91 14				STA	(IOBASE),Y
   923
   924 E38A A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   925 E38C 91 14				STA	(IOBASE),Y
   926 E38E A0 10				LDY	#PORTB
   927 E390 B1 14				LDA	(IOBASE),Y	; get SDA
   928 E392 10 03				BPL	ISACK		; SDA = 1 ?
   929 E394 18					CLC			; no, not acknowledeged
   930 E395 90 01				BCC	CLKDOWN
   931 E397 38			ISACK		SEC			; yes, acknowledeged
   932 E398 A0 12		CLKDOWN		LDY	#DDRB
   933 E39A A9 5F				LDA	#%01011111	; SCL = 0
   934 E39C 91 14				STA	(IOBASE),Y
   935 E39E 60					RTS
   936
   937 				; **** Receive a Byte from I2C Device ******************************************
   938
   939 				; Output: A - Data Byte
   940
   941 				; ******************************************************************************
   942
   943 E39F A2 09		I2C_RCV		LDX	#$09
   944 E3A1 A0 12		RCVLOOP		LDY	#DDRB
   945 E3A3 A9 5F				LDA	#%01011111	; SDA = 1; SCL = 0
   946 E3A5 91 14				STA	(IOBASE),Y
   947 E3A7 CA					DEX
   948 E3A8 F0 0E				BEQ	RCVEND		; all eight bits received?
   949 E3AA A9 5E				LDA	#%01011110	; SDA = 1; SCL = 1
   950 E3AC 91 14				STA	(IOBASE),Y
   951 E3AE A0 10				LDY	#PORTB
   952 E3B0 B1 14				LDA	(IOBASE),Y	; get SDA
   953 E3B2 0A					ASL			; and shift it into C
   954 E3B3 26 E0				ROL	I2C_DATA	; shift byte buffer one bit left. C goes into LSB
   955 E3B5 4C A1 E3				JMP	RCVLOOP
   956 E3B8 A5 E0		RCVEND		LDA	I2C_DATA	; load data into A
   957 E3BA 60					RTS
   958
   959 				; ******************************************************************************
   960 				; START OF SOUND GENERATOR CODE
   961 				; ******************************************************************************
   962
   963 				; **** Send A Command Byte To The Sound Chip ***********************************
   964
   965 				; Input: A - Data Byte
   966
   967 				; ******************************************************************************
   968
   969 E3BB 84 FD		SOUND_SENDBYTE	STY	YSAV		; save current Y register
   970 E3BD A0 11				LDY	#PORTA
   971 E3BF 91 14				STA	(IOBASE),Y	; set data
   972 E3C1 A0 10				LDY	#PORTB
   973 E3C3 A9 FD				LDA	#%11111101	; Set sound WE low
   974 E3C5 25 E4				AND	VIA_STATUS
   975 E3C7 91 14				STA	(IOBASE),Y	; enable sound data write
   976 E3C9 A5 E4				LDA	VIA_STATUS	; set sound WE high
   977 E3CB 91 14				STA	(IOBASE),Y	; disable sound data write
   978 E3CD A4 FD				LDY	YSAV		; restore Y register
   979 E3CF 60					RTS
   980
   981 				; **** Mute All Sound Chip Channels ********************************************
   982
   983 				; ******************************************************************************
   984
   985 E3D0 A0 03		SOUND_MUTEALL	LDY	#$03		; channels 0..3 to mute
   986 E3D2 98			NEXTCHANNEL	TYA
   987 E3D3 20 DA E3				JSR	SOUND_MUTE	; mute current channel
   988 E3D6 88					DEY			; next channel
   989 E3D7 10 F9				BPL	NEXTCHANNEL	; loop if not all four channels done
   990 E3D9 60					RTS
   991
   992 				; **** Mute A Sound Chip Channel ***********************************************
   993
   994 				; Input: A - Channel # (0..3)
   995
   996 				; ******************************************************************************
   997
   998 E3DA A2 0F		SOUND_MUTE	LDX	#$0F		; set attenuation level to maximum
   999 									; fall through to set attenuation level
  1000
  1001 				; **** Set Attenuation For A Sound Chip Channel ********************************
  1002
  1003 				; Input: A - Channel # (0..3)
  1004 				; 	 X - Attenuation Level 0..15 (0dB, 2dB, 4dB ... OFF)
  1005
  1006 				; ******************************************************************************
  1007
  1008 E3DC 86 FC		SOUND_SETATN	STX	TEMP		; store attenuation level in TEMP variable
  1009 E3DE 18					CLC			; clear carry flag
  1010 E3DF 6A					ROR			; and rotate channel number to bit 5 and 6
  1011 E3E0 6A					ROR	
  1012 E3E1 6A					ROR	
  1013 E3E2 6A					ROR	
  1014 E3E3 05 FC				ORA	TEMP		; combine channel number with attenuation value
  1015 E3E5 09 90				ORA	#$90		; and also set bit 7 and 4
  1016 E3E7 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1017
  1018 				; **** Set Periodic Noise ******************************************************
  1019
  1020 				; Input: X - Noise Shift Rate
  1021
  1022 				; ******************************************************************************
  1023
  1024 E3EA A9 00		SOUND_PNOISE	LDA	#$00
  1025 E3EC F0 04				BEQ	SET_NOISE
  1026
  1027 				; **** Set White Noise *********************************************************
  1028
  1029 				; Input: X - Noise Shift Rate
  1030
  1031 				; ******************************************************************************
  1032
  1033 E3EE A9 01		SOUND_WNOISE	LDA	#$01
  1034
  1035 				; **** Set Noise ***************************************************************
  1036
  1037 				; Input: A - 0 = Periodic Noise  1 = White Noise
  1038 				;	 X - Noise Shift Rate [0..3]
  1039
  1040 				; ******************************************************************************
  1041
  1042 E3F0 0A			SOUND_SETNOISE	ASL	
  1043 E3F1 0A					ASL	
  1044 E3F2 86 FC		SET_NOISE	STX	TEMP
  1045 E3F4 05 FC				ORA	TEMP
  1046 E3F6 09 E0				ORA	#$E0		; Emile: 23-07-25, corrected, was $F0 (noise-att.), $E0 is noise-control register
  1047 E3F8 4C BB E3				JMP	SOUND_SENDBYTE	; send complete command byte to the sound chip
  1048
  1049 				; **** Set Sound Frequency in HZ ***********************************************
  1050
  1051 				; Input: A - Channel (0..2)
  1052 				;	 X - Frequency Low Bits 7..0
  1053 				;	 Y - Frequency High Bits 9..8
  1054
  1055 				; *****************************************************************************
  1056
  1057 E3FB 18			SOUND_SETFREQ	CLC			; clear carry flag
  1058 E3FC 6A					ROR			; and rotate channel number to bit 5 and 6
  1059 E3FD 6A					ROR	
  1060 E3FE 6A					ROR	
  1061 E3FF 6A					ROR	
  1062 E400 09 80				ORA	#$80		; set high bit
  1063 E402 85 FC				STA	TEMP		; and store it in TEMP variable
  1064 E404 8A					TXA			; load frequency low bits into A
  1065 E405 29 0F				AND	#$0F		; we first want to send the lower 4 bits
  1066 E407 05 FC				ORA	TEMP		; combined it with the channel number
  1067 E409 20 BB E3				JSR	SOUND_SENDBYTE	; send complete first command byte to the sound chip
  1068 E40C 98					TYA			; load frequency high bits into A
  1069 E40D 86 FC				STX	TEMP		; store frequency low bits to TEMP variable
  1070 E40F A2 04				LDX	#$04		; we need four bits shifted
  1071 E411 06 FC		LOOP_NXT	ASL	TEMP		; shift highest bit of low frequency to Carry flag
  1072 E413 2A					ROL			; and shift it into the high frequency bits
  1073 E414 CA					DEX			; decrement counter
  1074 E415 D0 FA				BNE	LOOP_NXT	; do we need more shifts?
  1075 E417 4C BB E3				JMP	SOUND_SENDBYTE	; send complete second command byte to the sound chip
  1076
  1077 				; ******************************************************************************
  1078 				; ***************************** MAIN MONITOR ***********************************
  1079 				; ******************************************************************************
  1080
  1081 				; **** Auto Terminal And Baud Rate Detection Routine ***************************
  1082
  1083 				; ******************************************************************************
  1084
  1085 E41A A2 2D		INITVECT        LDX	#< NMI		; set NMI service routine
  1086 E41C A0 F3		                LDY	#> NMI
  1087 E41E 8E 7A 1A				STX	NMIVECT
  1088 E421 8C 7B 1A				STY	NMIVECT+1
  1089 E424 8E 7C 1A				STX	IRQUSR
  1090 E427 8C 7D 1A				STY	IRQUSR+1
  1091 E42A 8E 78 1A				STX	BRKUSR
  1092 E42D 8C 79 1A		                STY	BRKUSR+1
  1093 E430 A2 18				LDX	#< IRQ
  1094 E432 A0 F3				LDY	#> IRQ
  1095 E434 4C 40 ED				JMP	SETIRQVECT	; Set IRQ vector and return
  1096
  1097 E437					ORG	*+8		; maintain compatibility with v1.1.4
  1098 						
  1099 E43F 78			MAINSTART       SEI			; disable Interrupts
  1100 E440 A2 FF		                LDX     #$FF
  1101 E442 9A					TXS			; initialize stack pointer
  1102 E443 D8					CLD			; set binary mode
  1103
  1104 E444 A9 4F		                LDA     #< _HANDLER_  ; low address to empty event handler (RTS)
  1105 E446 8D 24 1A		                STA     KEY_HANDLER     ; init character input handler low address
  1106 E449 8D 26 1A		                STA     NKEY_HANDLER    ; init no character input handler low address
  1107 E44C A9 F8		                LDA     #> _HANDLER_ ; high address to empty event handler (RTS)
  1108 E44E 8D 25 1A		                STA     KEY_HANDLER+1   ; init character input handler high address
  1109 E451 8D 27 1A		                STA     NKEY_HANDLER+1  ; init no character input handler high address
  1110
  1111 E454 20 1A E4		                JSR     INITVECT
  1112
  1113 E457 A2 03		INITRESET       LDX     #< MON_WARM_START
  1114 E459 A0 E0				LDY     #> MON_WARM_START
  1115 E45B 20 C5 E5				JSR	SET_RETURN_VECT		; set entry point for monitor warm start
  1116 E45E EA					NOP				; maintain compatibility with v1.1.4
  1117
  1118 E45F A9 80				LDA     #$80
  1119 E461 20 4D E1				JSR  	DELAY		; wait for ~128ms after reset
  1120 E464 20 6A EC				JSR	INITIO		; find and initialize IO cards
  1121 E467 20 4D E1		VTDETECT	JSR  	DELAY		; wait for ~128ms after reset
  1122 E46A 8D 01 16				STA  	STAT_REG   	; reset ACIA
  1123
  1124 				; ******************************************************************************
  1125 				; Set Fixed Baud Rate Patch
  1126 				; ******************************************************************************
  1127
  1128 E46D A9 3E				LDA	#$3E
  1129 E46F 8D 83 1A				STA	PBDD
  1130 E472 A9 06				LDA	#$06		; set keyboard decoder Q4 to low
  1131 E474 8D 82 1A				STA	PBD		; write value to RIOT port B
  1132 E477 AD F9 FF				LDA	$FFF9		; load standard baud rate value
  1133 E47A 85 E0				STA	BAUDRATE	; and store it in detected baud rate variable
  1134 E47C A9 0B				LDA  	#$0B       	; set ACIA to
  1135 E47E 8D 02 16		         	STA  	COMM_REG	; no parity, no receiver echo, RTS low, no IRQ, DTR low
  1136 E481 AD 82 1A				LDA	PBD		; read RIOT port B
  1137 E484 A2 0F				LDX	#$0F		; set all keyboard decoder outputs to high
  1138 E486 8E 82 1A				STX	PBD		; write value to RIOT port B
  1139 E489 6A					ROR			; rotate bit 0 into Carry
  1140 E48A 90 05				BCC	INIT		; if Carry = 0 then skip autodetection
  1141
  1142 				; ******************************************************************************
  1143
  1144 E48C A9 00				LDA	#CMD_INIT
  1145 E48E 20 B7 E0				JSR	CMDPRINT	; try to detect connected terminal
  1146
  1147 				; **** Main Initialization Routine *********************************************
  1148
  1149 				; ******************************************************************************
  1150
  1151 E491 20 67 E1		INIT            JSR     BEEP		; give some feedback
  1152 E494 A5 E0				LDA  	BAUDRATE   	; load selected baud rate
  1153 E496 D0 1A				BNE     SETBAUDRATE	; terminal detected or fixed baud rate?
  1154 E498 AD F9 FF				LDA	$FFF9		; no, load standard baud rate value
  1155 E49B 8D 03 16				STA  	CTRL_REG	; set baud rate
  1156 E49E A5 C9				LDA     DEVID
  1157 E4A0 C9 10				CMP     #TTY1_ID        ; is TTY still the standard output device?
  1158 E4A2 D0 03				BNE     SET_CRTDEV      ; no, CRT controller is installed. Continue initialization
  1159 E4A4 4C 55 E7				JMP  	JCRESET		; TTY ist still sdtoutdev, but not connected. Jump to junior monitor
  1160
  1161 E4A7 8D 75 1A		SET_CRTDEV      STA     STDOUTDEV       ; make CRT controller the standard output device
  1162 E4AA 20 18 E0		                JSR     SET_STDOUTID
  1163 E4AD A9 00		                LDA	#CMD_INIT
  1164 E4AF 20 B7 E0				JSR	CMDPRINT	; initialize standard output device
  1165
  1166 E4B2 8D 03 16		SETBAUDRATE     STA  	CTRL_REG	; set detected baud rate
  1167
  1168 E4B5 58					CLI			; enable interrupts
  1169
  1170 				; **** Main Program Loop *******************************************************
  1171
  1172 				; ******************************************************************************
  1173
  1174 E4B6 20 4D E0		MAIN		JSR	CGET		; clear input buffer
  1175 E4B9 20 40 E5				JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1176 E4BC A9 1F				LDA  	#$1F
  1177 E4BE 20 DE E0				JSR  	PRTAB		; send some space chars to center title
  1178 E4C1 A0 14		        	LDY  	#TITLE-STRINGP 	; load title string
  1179 E4C3 20 85 E0				JSR  	WRSTR		; and write it
  1180 E4C6 20 16 F9				JSR     INIT_CFC	; init. CFC-driver
  1181
  1182 E4C9 A5 15		CHK_IO_CARD     LDA	IOBASEH		; language card available?
  1183 E4CB F0 21				BEQ	TRY_BOOT	; no, try to boot from CF-device
  1184 						
  1185 E4CD A0 60				LDY	#IOCARD-STRINGP ; load detect message
  1186 E4CF 20 85 E0				JSR	WRSTR		; and write it
  1187 E4D2 A5 15				LDA	IOBASEH
  1188 E4D4 20 91 E0				JSR	HEXOUT
  1189 E4D7 A9 00				LDA	#$00
  1190 E4D9 20 91 E0				JSR	HEXOUT
  1191 E4DC AD 74 1A				LDA	STDINDEV
  1192 E4DF C9 13				CMP	#KEYBD1_ID	; is ASCII keyboard the standard input device?
  1193 E4E1 D0 08				BNE	SHOW_CLOCK 	; no, show clock
  1194 						
  1195 E4E3 A0 6E				LDY	#KBDSTR-STRINGP	; yes, load detect message
  1196 E4E5 20 85 E0				JSR	WRSTR		; and write it
  1197 E4E8 20 10 F4				JSR	SETPPORTIN
  1198 E4EB 20 34 EB		SHOW_CLOCK	JSR	CLOCKSTART	; call clock
  1199
  1200 E4EE 20 B8 F6		TRY_BOOT        JSR     SYS_BOOT        ; try to boot from CF or SD device
  1201 E4F1 90 03		                BCC     NO_BOOT_DEV     ; no boot device found, show menu
  1202 						
  1203 E4F3 4C 00 06		                JMP     BLOCK_BUF       ; jump to boot code in Volume-ID with C=1
  1204
  1205 E4F6 A5 15		NO_BOOT_DEV     LDA	IOBASEH		; language card available?
  1206 E4F8 F0 43				BEQ	SHOWMON		; no, just start monitor
  1207
  1208 E4FA A9 00				LDA	#$00
  1209 E4FC A0 1B		                LDY	#ACR		; select auxilary control register
  1210 E4FE 91 14				STA	(IOBASE),Y	; disable shift operation
  1211 E500 20 43 E5		                JSR     LOADSTRING
  1212 E503 A0 89				LDY	#SPACE-STRINGP
  1213 E505 20 85 E0				JSR	WRSTR		; write spacer lines
  1214 E508 A9 1E				LDA	#$1E		; send some space chars to center menu
  1215 E50A 20 DE E0				JSR  	PRTAB
  1216 E50D A0 8E				LDY	#MENU-STRINGP   ; load menu string
  1217 E50F 20 85 E0				JSR	WRSTR		; and write it
  1218 E512 A2 F1				LDX	#< LANGNAME	; load language name
  1219 E514 A0 DF				LDY	#> LANGNAME
  1220 E516 20 82 F6				JSR	SPRINT		; and write it
  1221 E519 A9 20				LDA	#SPC
  1222 E51B 20 52 E0				JSR	COUT
  1223 E51E A9 3F				LDA	#'?'
  1224 E520 20 52 E0				JSR	COUT
  1225 E523 20 47 E0		MLOOP		JSR  	CIN		; main menu loop
  1226 E526 29 DF		        	AND  	#$DF		; convert the input to uppercase char
  1227 E528 C9 4D		        	CMP  	#'M'		; (M)onitor choosen?
  1228 E52A D0 03				BNE	MNEXT1
  1229
  1230 E52C 4C 33 E6		STARTMON	JMP  	MONITOR		; yes, start monitor
  1231 E52F CD F0 DF		MNEXT1		CMP	LANGKEY		; compare with language key char
  1232 E532 D0 06				BNE	MNEXT
  1233
  1234 E534 20 B5 E0				JSR  	CLRSCRN    	; clear screen
  1235 E537 4C 00 B0				JMP	$B000		; jump to language start
  1236 E53A 4C 23 E5		MNEXT		JMP  	MLOOP		; no valid input choosen, try again
  1237 E53D 4C 3B E6		SHOWMON		JMP	MONRESET
  1238
  1239 				; Load String Pointer **********************************************************
  1240
  1241 E540 20 B5 E0		CLRLOADSTR      JSR     CLRSCRN
  1242 E543 A9 72		LOADSTRING	LDA  	#< STRINGP 	; load string pointer 1
  1243 E545 85 EA				STA  	PSTRL
  1244 E547 A9 E7				LDA  	#> STRINGP
  1245 E549 85 EB				STA  	PSTRH
  1246 E54B 60					RTS
  1247 						
  1248 E54C A9 62		LOADSTRING2	LDA  	#< STRINGP2 	; load string pointer 2
  1249 E54E 85 EA				STA  	PSTRL
  1250 E550 A9 E8				LDA  	#> STRINGP2
  1251 E552 85 EB				STA  	PSTRH
  1252 E554 60					RTS
  1253
  1254 E555 A9 10		WRITE_IO_INFO   LDA     #$10
  1255 E557 8D 00 1A				STA     IO_INFO
  1256 E55A A5 17		CHK_IO_0	LDA     FGCBASEH        ; controller card 0 available?
  1257 E55C F0 06				BEQ     CHK_IO_1        ; no, check next card
  1258 E55E 8D 01 1A				STA     IO_INFO+1
  1259 E561 20 6F E5				JSR     CALL_INFO
  1260 E564 A5 19		CHK_IO_1        LDA     CARD3BASEH      ; controller card 1 available?
  1261 E566 F0 06		                BEQ     IO_INFO_END     ; no, exit
  1262 						
  1263 E568 8D 01 1A		                STA     IO_INFO+1
  1264 E56B 20 6F E5				JSR     CALL_INFO
  1265 E56E 60			IO_INFO_END	RTS
  1266
  1267 E56F 6C 00 1A		CALL_INFO       JMP     (IO_INFO)
  1268
  1269 				; ******************************************************************************
  1270 				; MONITOR COMMAND EXECUTOR ROUTINES
  1271 				; ******************************************************************************
  1272
  1273 				; print command ****************************************************************
  1274
  1275 E572 84 FD		PRINTOUT	STY	YSAV		; save y register
  1276 E574 AD 76 1A				LDA	STDPRINTDEV	; get standard printer
  1277 E577 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1278 E57A A4 FD				LDY	YSAV		; restore y register
  1279 E57C C8					INY
  1280 E57D B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1281 E580 29 DF				AND  	#$DF		; uppercase chars only
  1282 E582 C9 44				CMP  	#'D'		; print mem dump?
  1283 E584 F0 06				BEQ	PRINTDUMP
  1284 E586 20 AC E8				JSR	DISASSEM
  1285 E589 4C 94 E5				JMP	ENDINP
  1286 E58C 20 C7 E6		PRINTDUMP	JSR	MEMDUMP		; print memory dump
  1287 E58F 90 03				BCC	ENDINP 		; normal termination?
  1288 E591 20 67 E1				JSR	BEEP		; no, ESC pressed. Beep
  1289 E594 20 5A E0		ENDINP		JSR	CROUT		; send CR/LF to print last line
  1290 E597 AD 75 1A				LDA	STDOUTDEV	; get standard output device
  1291 E59A 20 18 E0				JSR	SET_STDOUTID    ; and make it the current output device
  1292 E59D 4C 3E E6				JMP	MONINP		; get next command line
  1293
  1294 				; XMODEM load/save command *****************************************************
  1295
  1296 E5A0 CA			XMODEM		DEX			; check read/write mode
  1297 E5A1 F0 09				BEQ	XMODEML		; read mode?
  1298 E5A3 A5 FF				LDA	MODE		; no, test if valid address mode
  1299 E5A5 F0 6A				BEQ	NOTVALID	; not valid, get next input
  1300 E5A7 20 06 F1				JSR	XModemSnd	; call xmodem send
  1301 E5AA F0 03				BEQ	XMODEME
  1302 E5AC 20 15 F0		XMODEML		JSR	XModemRcv	; yes, call xmodem receive
  1303 E5AF 4C 3E E6		XMODEME		JMP	MONINP		; get next command line
  1304
  1305 				; parallel load/save command ***************************************************
  1306
  1307 E5B2 CA			PARALLEL	DEX			; check read/write mode
  1308 E5B3 F0 0A				BEQ	PARALLELL	; read mode?
  1309 E5B5 A5 FF				LDA	MODE		; no, test if valid address mode
  1310 E5B7 F0 58				BEQ	NOTVALID	; not valid, get next input
  1311 E5B9 20 03 18				JSR	PPORTSAVE	; call save pport ### not implemented yet
  1312 E5BC 4C 3E E6				JMP	MONINP
  1313 E5BF 20 00 18		PARALLELL	JSR	PPORTLOAD	; call load pport ### not implemented yet
  1314 E5C2 4C 3E E6				JMP	MONINP		; get next command line
  1315
  1316 				; Removed 20-07-'25 (+34 bytes): tape load/save command **********************************
  1317
  1318 				;----------------------------------------------------------------------------------		
  1319 				; This routine sets the return vector that is used by both Monitor and boot.sys.
  1320 				;----------------------------------------------------------------------------------		
  1321 E5C5 8E 0A 18		SET_RETURN_VECT	STX     RETURN_VECT     	; set entry point for monitor warm start
  1322 E5C8 8C 0B 18		                STY     RETURN_VECT+1
  1323 E5CB 60					RTS
  1324
  1325 E5CC					ORG	$E5E7		; maintain compatibility with previous BIOS versions
  1326 				; load/save command ************************************************************
  1327
  1328 E5E7 A5 FF		LOADSAVE	LDA	MODE		; check address mode
  1329 E5E9 0A					ASL	
  1330 E5EA 30 06				BMI	CHKNEXTCMD	; mode = $C0 (block mode)?
  1331 E5EC A9 FF				LDA	#$FF		; no, set end address to $ffff
  1332 E5EE 85 F8				STA	NUML
  1333 E5F0 85 F9				STA	NUMH
  1334 E5F2 C8			CHKNEXTCMD	INY
  1335 E5F3 B9 00 14				LDA  	STRBUF,Y   	; get next input char
  1336 E5F6 29 DF				AND  	#$DF		; uppercase chars only
  1337 E5F8 C9 4D				CMP  	#'M'		; load/save via xmodem
  1338 E5FA F0 A4				BEQ  	XMODEM
  1339 E5FC C9 50				CMP  	#'P'		; load/save via parallel port
  1340 E5FE F0 B2				BEQ  	PARALLEL
  1341 E600 EA EA EA EA			:4	NOP			; REMOVED load/save via tape
  1342 E604 C9 30				CMP	#'0'
  1343 E606 B0 09				BCS	NOTVALID
  1344 E608 CA					DEX			; check load/save mode
  1345 E609 D0 06				BNE	NOTVALID	; if save mode, just get next input char
  1346 E60B 20 AC E8				JSR	DISASSEM	; last command was L, so call disassembler
  1347 E60E 4C 3E E6				JMP	MONINP		; we are finnished, get next input line
  1348 E611 A9 00		NOTVALID	LDA	#$00		; no valid command, so restore registers
  1349 E613 AA					TAX
  1350 E614 4C A1 E6				JMP  	SETMODE2   	; and get next input char
  1351
  1352 				; save command *****************************************************************
  1353
  1354 E617 E8			SAVE		INX
  1355
  1356 				; load command *****************************************************************
  1357
  1358 E618 E8			LOAD		INX
  1359 E619 4C E7 E5				JMP	LOADSAVE
  1360
  1361 				; print command ****************************************************************
  1362
  1363 E61C 4C 72 E5		PRINT		JMP	PRINTOUT
  1364
  1365 				; call a program ***************************************************************
  1366
  1367 E61F 20 36 E7		RUN		JSR	PRADDRESS
  1368 E622 A9 52				LDA	#'R'		; print R to signal run mode
  1369 E624 20 52 E0				JSR	COUT
  1370 E627 20 5A E0				JSR	CROUT
  1371 E62A 20 30 E6				JSR     EXECPROG
  1372 E62D 4C 3E E6				JMP  	MONINP		; jump back from program call
  1373 E630 6C FA 00		EXECPROG	JMP  	(ADRL)     	; jump to program address; execute program
  1374
  1375 				; **** Start Of Hex Monitor ****************************************************
  1376
  1377 				; ******************************************************************************
  1378 E633 20 40 E5		MONITOR 	JSR  	CLRLOADSTR    	; clear screen and load pointer to string table
  1379 E636 A0 9A				LDY  	#MONSTR-STRINGP
  1380 E638 20 85 E0		        	JSR  	WRSTR		; show monitor title
  1381 E63B 20 10 F4		MONRESET	JSR	SETPPORTIN	; initialize RIOT
  1382 E63E 20 5A E0		MONINP		JSR  	CROUT
  1383 E641 A9 2A				LDA  	#MON_PROMPT
  1384 E643 20 52 E0				JSR  	COUT		; show monitor prompt
  1385 E646 20 62 E0				JSR  	STRIN      	; read input string
  1386 E649 A0 00				LDY  	#$00       	; reset string index
  1387 E64B 98					TYA			; mode = 0 (none)
  1388
  1389 E64C AA			MONINIT		TAX
  1390 E64D 85 FF		SETADRMODE	STA  	MODE
  1391 E64F C8			SKIPCMDCHR      INY			; increment string index
  1392 E650 B9 00 14		NEXTCMDCHR	LDA  	STRBUF,Y   	; get next input char
  1393 E653 C9 0D				CMP  	#CR
  1394 E655 F0 52				BEQ  	ENDCMD 		; end of input line, return to reader routine
  1395 E657 C9 20				CMP  	#' '
  1396 E659 F0 F4				BEQ  	SKIPCMDCHR 	; ignore spaces
  1397 E65B C9 2E				CMP  	#'.'
  1398 E65D F0 46				BEQ  	SETBLKMODE 	; block mode
  1399 E65F C9 3A				CMP	#':'
  1400 E661 F0 EA				BEQ	SETADRMODE
  1401 E663 29 DF				AND  	#$DF		; uppercase chars only
  1402 E665 C9 4C				CMP  	#'L'		; LOAD/LIST command
  1403 E667 F0 AF				BEQ	LOAD 		; load or list data
  1404 E669 C9 53				CMP  	#'S'		; SAVE command
  1405 E66B F0 AA				BEQ	SAVE		; save data
  1406 E66D C9 50				CMP	#'P'		; PRINT command
  1407 E66F F0 AB				BEQ	PRINT		; print data
  1408 E671 C9 47				CMP  	#'G'		; GO command
  1409 E673 F0 AA				BEQ  	RUN		; call program
  1410 E675 C9 4D				CMP  	#'M'		; JUNIOR MONITOR command
  1411 E677 D0 03				BNE  	NEXTCMD
  1412 E679 4C 55 E7				JMP	JCRESET		; execute original junior computer monitor
  1413 E67C C9 51		NEXTCMD		CMP  	#'Q'		; QUIT command
  1414 E67E F0 30				BEQ  	MONEND		; exit monitor program
  1415 E680 A5 FF				LDA	MODE		; test if list command pending
  1416 E682 30 3C				BMI	DUMP		; if mode = $80, dump last line
  1417 E684 84 FD				STY  	YSAV		; save Y
  1418 E686 20 EA E0				JSR  	HEXINPUT   	; read hex number
  1419 E689 C4 FD			 	CPY  	YSAV		; min 1 hex digit entered?
  1420 E68B F0 C2				BEQ  	SKIPCMDCHR     	; no, read next command
  1421 E68D A5 FF				LDA  	MODE
  1422 E68F D0 0A				BNE	SETMODE
  1423 E691 A5 F8		STOREADR	LDA  	NUML       	; yes, copy input value to last address
  1424 E693 85 FA		                STA  	ADRL
  1425 E695 A5 F9		                LDA  	NUMH
  1426 E697 85 FB		                STA  	ADRH
  1427 E699 A9 00				LDA	#$00		; line list mode
  1428 E69B C9 3A		SETMODE		CMP	#':'		; is it store mode?
  1429 E69D F0 14				BEQ	STOREDATA	; yes, store data
  1430 E69F 09 80				ORA	#$80
  1431 E6A1 85 FF		SETMODE2	STA	MODE
  1432 E6A3 D0 AB				BNE	NEXTCMDCHR	; branch always
  1433 E6A5 A9 40		SETBLKMODE	LDA	#$40		; set block list mode
  1434 E6A7 D0 A4				BNE	SETADRMODE
  1435 E6A9 A5 FF		ENDCMD		LDA	MODE		; test if list command pending
  1436 E6AB 30 13				BMI	DUMP		; yes, dump last line
  1437 E6AD 4C 3E E6		CMDEND		JMP	MONINP		; read next command line
  1438 E6B0 6C 0A 18		MONEND		JMP     (RETURN_VECT)   ; return to monitor caller
  1439
  1440 				; store data *******************************************************************
  1441
  1442 E6B3 A5 F8		STOREDATA	LDA  	NUML       	; load lower byte of number
  1443 E6B5 81 FA		                STA  	(ADRL,X)   	; store current store address (X=0)
  1444 E6B7 E6 FA		                INC  	ADRL       	; increment lower store index.
  1445 E6B9 D0 02		                BNE  	NEXTITEM    	; no overflow
  1446 E6BB E6 FB		                INC  	ADRH       	; add carry to upper store index
  1447 E6BD 4C 50 E6		NEXTITEM        JMP  	NEXTCMDCHR    	; get next command string
  1448
  1449 				; call memory dump *************************************************************
  1450
  1451 E6C0 20 C7 E6		DUMP		JSR	MEMDUMP
  1452 E6C3 90 8B				BCC	NEXTCMDCHR   	; get next input
  1453 E6C5 B0 E6				BCS	CMDEND		; yes, stop printing memory dump
  1454
  1455 				; print memory dump ************************************************************
  1456
  1457 E6C7 A2 00		MEMDUMP		LDX	#$00
  1458 E6C9 86 FE				STX  	PDBCNT		; printed data byte count = 0
  1459 E6CB 20 5C E1				JSR	CHKESC		; ESC pressed?
  1460 E6CE 90 01				BCC	PRADR		; no, go on dumping
  1461 E6D0 60					RTS			; yes, exit leaving carry flag set
  1462 E6D1 20 36 E7		PRADR		JSR	PRADDRESS	; print current address
  1463
  1464 				; print current data byte ******************************************************
  1465
  1466 E6D4 20 5E E0		PRDATA		JSR  	SPCOUT		; print space
  1467 E6D7 A1 FA		                LDA  	(ADRL,X)   	; get data from address (X=0)
  1468 E6D9 20 91 E0		                JSR  	HEXOUT     	; print data in hex format
  1469 E6DC E6 FE				INC  	PDBCNT     	; increment data counter
  1470
  1471 				; examine next address *********************************************************
  1472
  1473 E6DE 20 4C E7		ADRNEXT		JSR	CMPADDR		; see if there's more to print
  1474 E6E1 B0 18		                BCS  	FINISHED?  	; no more data to output
  1475
  1476 E6E3 20 7F E9				JSR	INCADR          ; increment list index
  1477 E6E6 A5 FE		DIVCHK          LDA  	PDBCNT
  1478 E6E8 C9 08				CMP  	#$08
  1479 E6EA D0 03				BNE  	MOD16CHK	; do we need a divider?
  1480 E6EC 20 5E E0				JSR  	SPCOUT		; yes, print single SPC as block divider
  1481 E6EF A5 FA		MOD16CHK	LDA  	ADRL       	; if address MOD 16 = 0 start new line
  1482 E6F1 29 0F		                AND  	#$0F
  1483 E6F3 D0 DF				BNE  	PRDATA
  1484 E6F5 20 07 E7				JSR  	PRASCII
  1485 E6F8 4C C7 E6				JMP  	MEMDUMP		; print next line
  1486
  1487 				; check if line print completed ************************************************
  1488
  1489 E6FB A5 FF		FINISHED?	LDA  	MODE		; examine last mode
  1490 E6FD 86 FF				STX  	MODE       	; set mode 0
  1491 E6FF 0A					ASL			; mode = $D0?
  1492 E700 10 03				BPL  	ENDDUMP		; no, get next input
  1493 E702 20 07 E7				JSR  	PRASCII		; yes, we are not finished, print ASCII output for last address
  1494 E705 18			ENDDUMP		CLC			; normal exit, so clear carry flag
  1495 E706 60					RTS
  1496
  1497 				; print a column with ASCII representation of data *****************************
  1498
  1499 E707 84 FD		PRASCII         STY  	YSAV       	; store Y
  1500 E709 38					SEC			; no carry to subtract
  1501 E70A A9 34				LDA  	#52		; max tabs
  1502 E70C E5 FE				SBC  	PDBCNT		; calc tab count to print ASCII column
  1503 E70E E5 FE				SBC  	PDBCNT		; tab = 52-3*printed_data_bytes_count
  1504 E710 E5 FE				SBC  	PDBCNT
  1505 E712 A4 FE				LDY  	PDBCNT
  1506 E714 C0 09				CPY  	#9		; more than 8 bytes viewed?
  1507 E716 B0 02				BCS  	NOADJUST	; no
  1508 E718 69 01				ADC  	#1		; yes, adjust by one char for block divider
  1509 E71A 20 DE E0		NOADJUST	JSR  	PRTAB		; print tab spaces
  1510
  1511 E71D A0 00				LDY  	#$00
  1512 E71F B1 E6		NEXTASC		LDA  	(ASCL),Y   	; get data from address
  1513 E721 C9 7F				CMP	#$7F
  1514 E723 B0 04				BCS  	NOASC      	; char >= ASCII 127? yes, print '.'
  1515 E725 C9 20				CMP  	#' '
  1516 E727 B0 02				BCS  	ASCOUT		; printable character?
  1517 E729 A9 2E		NOASC		LDA  	#'.'       	; no, print '.'
  1518 E72B 20 52 E0		ASCOUT		JSR  	COUT
  1519 E72E C8					INY
  1520 E72F C4 FE				CPY  	PDBCNT
  1521 E731 D0 EC				BNE  	NEXTASC
  1522 E733 A4 FD				LDY  	YSAV       	; restore Y
  1523 E735 60					RTS
  1524
  1525 				; Prompt new line with current address *****************************************
  1526
  1527 				;*******************************************************************************
  1528
  1529 E736 20 5A E0		PRADDRESS	JSR  	CROUT
  1530 E739 A5 FB				LDA  	ADRH
  1531 E73B 85 E7		                STA  	ASCH		; store current print address high-order byte
  1532 E73D 20 91 E0				JSR  	HEXOUT		; print high-order byte of address
  1533 E740 A5 FA		                LDA  	ADRL
  1534 E742 85 E6				STA  	ASCL		; store current print address low-order byte
  1535 E744 20 91 E0		                JSR  	HEXOUT		; print low-order byte of address
  1536 E747 A9 2D				LDA  	#ADIV      	; print '-'
  1537 E749 4C 52 E0		                JMP  	COUT
  1538
  1539 				; Compare if start address ADR is greater end address NUM **********************
  1540
  1541 				;*******************************************************************************
  1542
  1543 E74C A5 FA		CMPADDR		LDA  	ADRL       	; see if there's more to print
  1544 E74E C5 F8		                CMP  	NUML
  1545 E750 A5 FB		                LDA  	ADRH
  1546 E752 E5 F9		                SBC  	NUMH
  1547 E754 60					RTS
  1548
  1549 				; Jump to original Junior Computer reset vector ********************************
  1550
  1551 				;*******************************************************************************
  1552 E755 A9 06		JCRESET		LDA	#$06			; set PB5 = L (WRITE)
  1553 E757 8D 82 1A				STA	PBD
  1554 E75A 78					SEI
  1555 E75B 20 1A E4				JSR     INITVECT
  1556 E75E 20 81 ED		                JSR     VIA2IRQ_OFF
  1557 E761 58					CLI
  1558 E762 4C 1D 1C				JMP	MONITOR_BLOCK.RESET	; jump to Junior Computer reset routine
  1559
  1560 				; ******************************************************************************
  1561 				; String Data Section
  1562 				; ******************************************************************************
  1563
  1564 E765 00 00 00 00		MAGIC0		.byte	$00,$00,$00,$00                 ; Removed by Emile
  1565 E769 18 90 00 90		MAGIC1          .byte   $18,$90,$00,$90                 ; clc bcc 00 bcc
  1566
  1567 E76D 50 53 41 59 58	PSSTR		.by	'PSAYX'				; processor status string
  1568
  1569 E772			STRINGP							; *** string base pointer ***
  1570 E772 32 4A 1B 5B		ESCCLS  	.byte   $32,$4A,$1B,$5B                 ; VT100 clear screen sequence
  1571 E776 48 00		ESCHOME        	.byte   $48,$00                 	; VT100 cursor home sequence
  1572 E778 32 4B 00		ESCCLL        	.byte   $32,$4B,$00         		; VT100 clear line sequence
  1573 E77B 30 63 00		ESCGID		.byte   $30,$63,$00	        	; VT100 get ID sequence
  1574 E77E 6D 00		ESCNORM		.byte   $6D,$00	        		; VT100 set normal text mode
  1575 E780 37 6D 00		ESCINV		.byte   $37,$6D,$00	        	; VT100 set inverse text mode
  1576 E783 35 6D 00		ESCBLNK		.byte   $35,$6D,$00	        	; VT100 set blinking text mode
  1577
  1578 E786 4A 75 6E 69 6F 72 + TITLE		.by   	'Junior Computer ][ ' CR,CR,CR
  1579 E79C 20 42 49 4F 53 20 + 		.by   	' BIOS V'
  1580 E7A3 31 2E 32 2E 35 0D	        	.byte   VERMAIN,$2E,VERPSUB,$2E,VERSSUB,CR
  1581 E7A9 20 32 30 32 30 2F +         	.by   	' 2020/24 by Joerg Walke, 2025 by Emile' CR CR $00
  1582 E7D2 20 49 4F 2D 43 61 + IOCARD		.by	' IO-Card at $' $00
  1583 E7E0 0D 20 41 53 43 49 + KBDSTR		.by	CR ' ASCII Keyboard connected' $00
  1584 E7FB 0D 0D 0D 0D 00	SPACE    	.byte  	CR, CR, CR, CR, $00
  1585 E800 28 4D 29 6F 6E 69 + MENU		.by   	'(M)onitor  ' $00
  1586 E80C 0D 48 65 78 20 4D + MONSTR		.by	CR 'Hex Monitor' CR $00
  1587
  1588 E81A 0D 0D 20 44 61 74 + DT_NOT_SET	.by	CR CR ' Date/Time not set' CR $00
  1589 E830 0D 20 44 61 74 65 + DATEINPUT	.by	CR ' Date: DD' DATEDIV 'MM' DATEDIV 'YY'
  1590 E840 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1591 E849 0D 20 54 69 6D 65 + TIMEINPUT	.by	CR ' Time: HH' TIMEDIV 'MM' TIMEDIV 'SS'
  1592 E859 08 08 08 08 08 08 + 		.byte	8,8,8,8,8,8,8,8,$00
  1593
  1594 E862			STRINGP2
  1595 E862 4D 6F 6E 00		DAYS		.by	'Mon' $00
  1596 E866 54 75 65 00				.by	'Tue' $00
  1597 E86A 57 65 64 00				.by	'Wed' $00
  1598 E86E 54 68 75 00				.by	'Thu' $00
  1599 E872 46 72 69 00				.by	'Fri' $00
  1600 E876 53 61 74 00				.by	'Sat' $00
  1601 E87A 53 75 6E 00				.by	'Sun' $00
  1602 E87E 4A 43 4F 53		OSID            .by    'JCOS'
  1603 E882 0D 20 42 6F 6F 74 + BOOTDEV         .by    CR ' Booting from ' $00
  1604 E892 0D 20 4E 6F 20 42 + NOBOOTDEV       .by    CR ' No Boot Disk ' $00
  1605 E8A2 43 46 43 31 00	CFCDEV          .by    'CFC1' $00
  1606 E8A7 53 44 43 31 00	SDCDEV          .by    'SDC1' $00
  1607
  1608 				; ******************************************************************************
  1609 				; START OF DISASSEMBLER
  1610 				; ******************************************************************************
  1611
  1612 E8AC A5 FF		DISASSEM	LDA	MODE
  1613 E8AE 0A					ASL	
  1614 E8AF 10 0E				BPL	SHOW1PAGE	; mode <> $C0 (block mode)?
  1615 E8B1 20 5C E1		NEXTLINE1	JSR     CHKESC          ; ESC pressed?
  1616 E8B4 B0 14				BCS	ENDDISASSEM	; yes, quit disassembling
  1617 E8B6 20 CB E8		NEXTOP		JSR	LOADOPCODE	; load current opcode
  1618 E8B9 20 4C E7		MORE?		JSR	CMPADDR		; see if there's more to print
  1619 E8BC 90 F3		                BCC  	NEXTLINE1  	; no more data to output
  1620 E8BE 60					RTS
  1621 E8BF A9 17		SHOW1PAGE	LDA	#23		; show 23 disassembled lines
  1622 E8C1 85 E1				STA	LINECNT
  1623 E8C3 20 CB E8		NEXTLINE2	JSR	LOADOPCODE	; load current opcode
  1624 E8C6 C6 E1				DEC	LINECNT
  1625 E8C8 D0 F9				BNE	NEXTLINE2	; more lines to show?
  1626 E8CA 60			ENDDISASSEM	RTS			; no, jump back to monitor
  1627
  1628 				; load next opcode
  1629
  1630 E8CB 20 36 E7		LOADOPCODE	JSR	PRADDRESS	; print current address
  1631 E8CE A0 00				LDY	#$00
  1632 E8D0 B1 FA				LDA	(ADRL),Y	; load opcode
  1633 E8D2 A8					TAY			; store opcode in Y
  1634 E8D3 29 03				AND	#$03
  1635 E8D5 C9 03				CMP	#$03		; is it a unused opcode?
  1636 E8D7 D0 05				BNE	DECODE  	; no, decode it
  1637 E8D9 A0 02				LDY	#$02		; Y points to unused opcode $02 to print '???'
  1638 E8DB 98					TYA			; and we also need it in A
  1639 E8DC D0 09				BNE	DECODEMNEM	; branch always
  1640
  1641 				; decode opcode index into compressed opcode instruction table
  1642
  1643 E8DE 98			DECODE		TYA			; reload opcode into A
  1644 E8DF 4A					LSR			; every fourth column in the opcode table is a (opcode) gap
  1645 E8E0 4A					LSR			; so we have to adjust the index because these columns are
  1646 									; stripped off in our indirect index table
  1647 E8E1 85 FC				STA	TEMP		; store number of bytes to subtract
  1648 E8E3 98					TYA			; reload opcode again
  1649 E8E4 38					SEC
  1650 E8E5 E5 FC				SBC	TEMP		; and subtract value in TEMP from the original opcode.
  1651 E8E7 84 E0		DECODEMNEM	STY	OPCODE		; store opcode
  1652 E8E9 A8					TAY			; Y holds now the actual index to the stripped opcode table
  1653 E8EA B9 74 EA				LDA	OPCODES,Y	; load packed mnemonic_index/instr._bytes from opcode table
  1654 E8ED A8					TAY			; and save to Y
  1655 E8EE 29 03				AND	#$03		; the lower two bits are the number of instruction bytes
  1656 E8F0 85 E3				STA	IBYTES		; store it in IBYTES var
  1657 E8F2 98					TYA			; reload packed index
  1658 E8F3 4A					LSR			; and strip the lower two bits off
  1659 E8F4 4A					LSR	
  1660 E8F5 A8					TAY			; Y holds now the index to the mnemonics table
  1661 E8F6 B9 3B EA				LDA   	MNEMONICSH,Y    ; load first packed byte of mnemonic string
  1662 E8F9 85 E7				STA   	ASCH            ; and store it as left byte of mnemonic
  1663 E8FB B9 02 EA				LDA   	MNEMONICSL,Y    ; load second packed byte of mnemonic string
  1664 E8FE 85 E6				STA   	ASCL            ; and store it as right byte of mnemonic
  1665 E900 20 AB E9				JSR	SHOWHEX		; first print out all instruction bytes as hex numbers
  1666 E903 A2 03				LDX   	#$03		; we have to unpack three chars
  1667 E905 A9 00		NEXTMCHR        LDA   	#$00		; clear A
  1668 E907 A0 05				LDY   	#$05            ; shift 5 bits into A
  1669 E909 06 E6		NEXTSHIFT       ASL   	ASCL           	; MSBit of ASCL in C
  1670 E90B 26 E7				ROL   	ASCH		; C in LSBit of ASCH and MSBit of ASCH in C
  1671 E90D 2A					ROL   			; C in A
  1672 E90E 88					DEY
  1673 E90F D0 F8				BNE   	NEXTSHIFT
  1674 E911 69 3F				ADC   	#'?'		; add offset to result, to make it an ASCII char
  1675 E913 20 52 E0				JSR     COUT		; print one character of mnemonic
  1676 E916 CA					DEX
  1677 E917 D0 EC				BNE     NEXTMCHR	; more chars to decode?
  1678 E919 A9 02				LDA	#$02		; print two space chars
  1679 E91B 20 DE E0				JSR	PRTAB
  1680
  1681 				; decode address mode and print left part of mode string ('#', '(' or 'A')
  1682
  1683 E91E A2 A0				LDX     #$A0            ; default address mode is implied
  1684 E920 A0 FF				LDY	#$FF
  1685 E922 C8			NEXTMASK	INY
  1686 E923 C0 0F				CPY	#$0F		; all masks tested?
  1687 E925 F0 0D				BEQ	ENDMASK		; yes, finish. Address mode is implied
  1688 E927 B9 C5 E9				LDA	ADRMODEM,Y	; load mask
  1689 E92A 25 E0				AND	OPCODE		; mask opcode
  1690 E92C D9 D4 E9				CMP	ADRMODEC,Y	; is it the mask result?
  1691 E92F D0 F1				BNE	NEXTMASK	; no, try next mask
  1692 E931 BE E3 E9				LDX	ADRMODER,Y	; yes, load the resulting address mode
  1693 E934 86 E2		ENDMASK		STX	ADRMODE		; save address mode
  1694 E936 8A					TXA			; address mode is in A
  1695 E937 29 0F				AND	#$0F		; A holds left mode string index
  1696 E939 A8					TAY
  1697 E93A B9 F2 E9				LDA	ADRMSTRL,Y      ; load left mode string
  1698 E93D F0 03				BEQ	PRINTVAL	; is it a NULL char? Then there is nothing to print
  1699 E93F 20 52 E0				JSR	COUT		; else print character
  1700
  1701 				; print either one or two operand value bytes
  1702
  1703 E942 20 7F E9		PRINTVAL	JSR	INCADR		; increment current address
  1704 E945 A6 E3				LDX	IBYTES		; load number of instruction bytes
  1705 E947 CA					DEX			; more than one IBs?
  1706 E948 F0 3B				BEQ	ENDINC		; no, just finish
  1707 E94A A9 24				LDA	#'$'		; yes, print operant value
  1708 E94C 20 52 E0				JSR	COUT		; first print out '$' as hex number indicator
  1709 E94F A0 01				LDY	#$01
  1710 E951 CA					DEX			; more than two IBs?
  1711 E952 F0 05				BEQ	HEX1		; no, just print one byte
  1712 E954 B1 FA				LDA	(ADRL),Y	; load high byte
  1713 E956 20 91 E0				JSR	HEXOUT		; and print it as hex number
  1714 E959 88			HEX1		DEY
  1715 E95A B1 FA				LDA	(ADRL),Y	; load low byte
  1716 E95C A6 E2				LDX	ADRMODE
  1717 E95E E0 A4				CPX	#$A4		; is it a branch opcode?
  1718 E960 F0 24				BEQ	CALCADR		; yes, calculate branch destination address
  1719 E962 20 91 E0				JSR	HEXOUT		; no, print byte as hex number
  1720
  1721 				; print right part of mode string. (',X', ',Y', ',X)', '),Y' or ')' )
  1722
  1723 E965 8A					TXA			; load address mode in A
  1724 E966 4A					LSR			; upper nibble is index to right address mode string
  1725 E967 4A					LSR			; so we have to shift it right by four bits
  1726 E968 4A					LSR	
  1727 E969 4A					LSR	
  1728 E96A A8					TAY
  1729 E96B B9 F7 E9		NEXTAMCHR	LDA	ADRMSTRR,Y	; load one char of right mode string
  1730 E96E F0 06				BEQ     ENDMODE		; if a NULL char then we are finished
  1731 E970 20 52 E0				JSR	COUT		; else print char
  1732 E973 C8					INY
  1733 E974 D0 F5				BNE	NEXTAMCHR	; branch always
  1734
  1735 				; finish current instruction
  1736
  1737 E976 A5 E3		ENDMODE		LDA	IBYTES		; how many address increments left?
  1738 E978 C9 03				CMP	#$03
  1739 E97A D0 03				BNE	INCADR		; just one?
  1740 E97C 20 7F E9				JSR	INCADR		; no, two increments needed
  1741
  1742 				; increment current address
  1743
  1744 E97F E6 FA		INCADR  	INC  	ADRL    	; increment current address
  1745 E981 D0 02		        	BNE  	ENDINC  	; no carry!
  1746 E983 E6 FB		        	INC  	ADRH
  1747 E985 60			ENDINC		RTS			; end of disassembly
  1748
  1749 				; calculate destination address for branch instructions
  1750
  1751 E986 38			CALCADR		SEC
  1752 E987 A8					TAY			; transfer A to Y for sign test
  1753 E988 10 10				BPL	ADDOFS		; is the branch offset positiv?
  1754 E98A 49 FF				EOR	#$FF		; no, subtract offset from current address
  1755 E98C 85 E8				STA	STOL
  1756 E98E A5 FA				LDA	ADRL
  1757 E990 E5 E8				SBC	STOL		; subtract branch offset from LSB current address
  1758 E992 A8					TAY			; store low byte of address to Y
  1759 E993 A5 FB				LDA	ADRH
  1760 E995 E9 00				SBC	#$00		; substract carry from MSB of address
  1761 E997 4C A1 E9				JMP	PRINTOFFS
  1762 E99A 65 FA		ADDOFS		ADC	ADRL		; add branch offset to LSB of current address
  1763 E99C A8					TAY			; store low byte of address to Y
  1764 E99D A5 FB				LDA	ADRH
  1765 E99F 69 00				ADC	#$00		; add carry to MSB of address
  1766 E9A1 20 91 E0		PRINTOFFS	JSR	HEXOUT		; print high byte of branch address
  1767 E9A4 98					TYA
  1768 E9A5 20 91 E0				JSR	HEXOUT		; print low byte of branch address
  1769 E9A8 4C 7F E9				JMP	INCADR		; and increment current address by one
  1770
  1771 				; show instruction bytes as hex values and trailing variable number of space chars
  1772
  1773 E9AB A0 00		SHOWHEX		LDY	#$00
  1774 E9AD 20 5E E0		NEXTBYTE	JSR	SPCOUT		; print leading space char
  1775 E9B0 B1 FA				LDA	(ADRL),Y	; load data byte
  1776 E9B2 20 91 E0				JSR	HEXOUT		; and print it
  1777 E9B5 C8					INY
  1778 E9B6 C4 E3				CPY	IBYTES		; all data bytes printed?
  1779 E9B8 D0 F3				BNE	NEXTBYTE	; no, print next byte
  1780 E9BA A9 0C				LDA	#$0C		; tab size is 12
  1781 E9BC 38					SEC
  1782 E9BD E9 03		CALCTAB		SBC	#$03		; reduce tab space by 3 for every data byte
  1783 E9BF 88					DEY
  1784 E9C0 D0 FB				BNE	CALCTAB		; all data bytes considered?
  1785 E9C2 4C DE E0				JMP	PRTAB
  1786
  1787 				; Address Mode Decode Tables ***************************************************
  1788
  1789 				; Mask, Mask Result and Mode tables. If Opcode and Mask = Mask Result then Mode
  1790 				; each Mode holds two indices (4 bits R | 4 bits L) to the mode string parts
  1791
  1792 				; ******************************************************************************
  1793
  1794 E9C5 FF FF FF 1F 1F 1F + ADRMODEM	.byte	$FF,$FF,$FF,$1F,$1F,$1F,$1F,$1F,$9F,$9F,$1C,$1C,$DF,$1C,$1C ; mask bits
  1795
  1796 E9D4 6C A2 BE 01 09 10 + ADRMODEC	.byte	$6C,$A2,$BE,$01,$09,$10,$11,$19,$0A,$80,$04,$0C,$96,$14,$1C ; mask result bits
  1797
  1798 E9E3 52 A1 80 32 A1 A4 + ADRMODER	.byte	$52,$A1,$80,$32,$A1,$A4,$72,$80,$A3,$A1,$A0,$A0,$80,$00,$00 ; packed mode bits
  1799
  1800 				; Address Mode Strings *********************************************************
  1801
  1802 E9F2 00 23 28 41 00	ADRMSTRL	.byte	$00,$23,$28,$41,$00
  1803 						;	 0   #   (   A   0
  1804
  1805 E9F7 2C 58 00 2C 58 29 + ADRMSTRR	.byte	$2C,$58,$00,$2C,$58,$29,$00,$29,$2C,$59,$00
  1806 						;	 ,   X   0   ,   X   )   0   )   ,   Y   0
  1807
  1808 				; Mnemonics Table **************************************************************
  1809
  1810 				; three characters packed in two bytes. Each character uses 5 bits, last bit is
  1811 				; unused
  1812
  1813 				; ******************************************************************************
  1814
  1815 				; low bytes of table
  1816
  1817 EA02 48 CA 1A 08 28 A4 + MNEMONICSL	.byte	$48, $CA, $1A, $08, $28, $A4, $AA, $94
  1818 EA0A CC 5A D8 C8 E8 48 +      		.byte	$CC, $5A, $D8, $C8, $E8, $48, $4A, $54
  1819 EA12 6E A2 72 74 88 B2 +      		.byte	$6E, $A2, $72, $74, $88, $B2, $B4, $26
  1820 EA1A C8 F2 F4 A2 26 44 +      		.byte	$C8, $F2, $F4, $A2, $26, $44, $72, $74
  1821 EA22 26 22 C4 44 62 44 +      		.byte	$26, $22, $C4, $44, $62, $44, $62, $1A
  1822 EA2A 26 54 68 C8 88 8A +      		.byte	$26, $54, $68, $C8, $88, $8A, $94, $44
  1823 EA32 72 74 B2 B4 32 44 +      		.byte	$72, $74, $B2, $B4, $32, $44, $68, $84, $00
  1824
  1825 				; high bytes of table
  1826
  1827 EA3B 11 13 15 19 19 19 + MNEMONICSH	.byte	$11, $13, $15, $19, $19, $19, $1A, $1B
  1828 EA43 1B 1C 1C 1D 1D 23 +      		.byte	$1B, $1C, $1C, $1D, $1D, $23, $23, $23
  1829 EA4B 23 23 24 24 29 29 +      		.byte	$23, $23, $24, $24, $29, $29, $29, $34
  1830 EA53 53 53 53 5B 5D 69 +      		.byte	$53, $53, $53, $5B, $5D, $69, $69, $69
  1831 EA5B 6D 7C 84 8A 8A 8B +      		.byte	$6D, $7C, $84, $8A, $8A, $8B, $8B, $9C
  1832 EA63 9C 9D 9D A0 A1 A1 +      		.byte	$9C, $9D, $9D, $A0, $A1, $A1, $A1, $A5
  1833 EA6B A5 A5 A8 A8 AD AE +      		.byte	$A5, $A5, $A8, $A8, $AD, $AE, $AE, $AE, $00
  1834
  1835 				; Compressed Opcode Table ******************************************************
  1836
  1837 				; each byte holds a 6 bit index to the mnemonic table and 2 bits instruction
  1838 				; byte count
  1839 				; empty opcode table columns (3,7,B,F) are stripped out
  1840
  1841 				; ******************************************************************************
  1842
  1843 EA74 29 8A E1 E1 8A 0A + OPCODES         .byte	$29, $8A, $E1, $E1, $8A, $0A, $91, $8A, $09, $E1, $8B, $0B
  1844 EA80 26 8A E1 E1 8A 0A +      		.byte	$26, $8A, $E1, $E1, $8A, $0A, $35, $8B, $E1, $E1, $8B, $0B
  1845 EA8C 73 06 E1 1A 06 9E +      		.byte	$73, $06, $E1, $1A, $06, $9E, $99, $06, $9D, $1B, $07, $9F
  1846 EA98 1E 06 E1 E1 06 9E +      		.byte	$1E, $06, $E1, $E1, $06, $9E, $B1, $07, $E1, $E1, $07, $9F
  1847 EAA4 A5 5E E1 E1 5E 82 +      		.byte	$A5, $5E, $E1, $E1, $5E, $82, $8D, $5E, $81, $6F, $5F, $83
  1848 EAB0 2E 5E E1 E1 5E 82 +      		.byte	$2E, $5E, $E1, $E1, $5E, $82, $3D, $5F, $E1, $E1, $5F, $83
  1849 EABC A9 02 E1 E1 02 A2 +      		.byte	$A9, $02, $E1, $E1, $02, $A2, $95, $02, $A1, $6F, $03, $A3
  1850 EAC8 32 02 E1 E1 02 A2 +      		.byte	$32, $02, $E1, $E1, $02, $A2, $B9, $03, $E1, $E1, $03, $A3
  1851 EAD4 E1 BE E1 C6 BE C2 +      		.byte	$E1, $BE, $E1, $C6, $BE, $C2, $59, $E1, $D5, $C7, $BF, $C3
  1852 EAE0 0E BE E1 C6 BE C2 +      		.byte	$0E, $BE, $E1, $C6, $BE, $C2, $DD, $BF, $D9, $E1, $BF, $E1
  1853 EAEC 7E 76 7A 7E 76 7A +      		.byte	$7E, $76, $7A, $7E, $76, $7A, $CD, $76, $C9, $7F, $77, $7B
  1854 EAF8 12 76 E1 7E 76 7A +      		.byte	$12, $76, $E1, $7E, $76, $7A, $41, $77, $D1, $7F, $77, $7B
  1855 EB04 4E 46 E1 4E 46 52 +      		.byte	$4E, $46, $E1, $4E, $46, $52, $69, $46, $55, $4F, $47, $53
  1856 EB10 22 46 E1 E1 46 52 +      		.byte	$22, $46, $E1, $E1, $46, $52, $39, $47, $E1, $E1, $47, $53
  1857 EB1C 4A AE E1 4A AE 62 +      		.byte	$4A, $AE, $E1, $4A, $AE, $62, $65, $AE, $85, $4B, $AF, $63
  1858 EB28 16 AE E1 E1 AE 62 +      		.byte	$16, $AE, $E1, $E1, $AE, $62, $B5, $AF, $E1, $E1, $AF, $63
  1859
  1860 				; ******************************************************************************
  1861 				; START OF HIGH LEVEL REAL TIME CLOCK CODE
  1862 				; ******************************************************************************
  1863
  1864 				; **** Check If Date/Time Is Set And Show Date/Time ****************************
  1865
  1866 EB34 20 43 EB		CLOCKSTART	JSR	CHECKDATETIME
  1867 EB37 20 5A E0				JSR	CROUT
  1868 EB3A 20 5A E0				JSR	CROUT
  1869 EB3D 20 5E E0				JSR	SPCOUT
  1870 EB40 4C F9 EB				JMP	PRINTDATETIME
  1871
  1872 				; **** Check If Date/Time Is Set ***********************************************
  1873
  1874 				; ******************************************************************************
  1875
  1876 EB43 A9 08		CHECKDATETIME	LDA	#$08
  1877 EB45 20 E6 E2				JSR	READCLOCK
  1878 EB48 C0 65				CPY	#$65
  1879 EB4A D0 05				BNE	DATETIMELOST
  1880 EB4C E0 02				CPX	#$02
  1881 EB4E D0 01				BNE	DATETIMELOST
  1882 EB50 60					RTS
  1883
  1884 EB51 20 43 E5		DATETIMELOST	JSR	LOADSTRING
  1885 EB54 A0 A8				LDY	#DT_NOT_SET-STRINGP
  1886 EB56 20 85 E0				JSR	WRSTR
  1887
  1888 EB59 20 86 EB		SETDATETIME	JSR	SETTIME
  1889
  1890 EB5C 20 43 E5		SETDATE		JSR	LOADSTRING
  1891 EB5F A9 2E				LDA	#'.'
  1892 EB61 85 F2				STA	DIVCHAR
  1893 EB63 A0 BE				LDY	#DATEINPUT-STRINGP
  1894 EB65 20 85 E0				JSR	WRSTR
  1895 EB68 A0 31				LDY	#$31
  1896 EB6A 20 B0 EB				JSR	GETDIGIT
  1897 EB6D 85 F4				STA	YREG
  1898 EB6F 20 49 EC				JSR	PRINTDIVCHAR
  1899 EB72 A0 12				LDY	#$12
  1900 EB74 20 B0 EB				JSR	GETDIGIT
  1901 EB77 85 F5				STA	XREG
  1902 EB79 20 49 EC				JSR	PRINTDIVCHAR
  1903 EB7C A0 99				LDY	#$99
  1904 EB7E 20 B0 EB				JSR	GETDIGIT
  1905 EB81 85 F3				STA	ACC
  1906 EB83 4C B7 E2				JMP	WRITEDATE2
  1907
  1908 EB86 20 43 E5		SETTIME		JSR	LOADSTRING
  1909 EB89 A9 3A				LDA	#':'
  1910 EB8B 85 F2				STA	DIVCHAR
  1911 EB8D A0 D7				LDY	#TIMEINPUT-STRINGP
  1912 EB8F 20 85 E0				JSR	WRSTR
  1913 EB92 A0 23				LDY	#$23
  1914 EB94 20 B0 EB				JSR	GETDIGIT
  1915 EB97 85 F3				STA	ACC
  1916 EB99 20 49 EC				JSR	PRINTDIVCHAR
  1917 EB9C A0 59				LDY	#$59
  1918 EB9E 20 B0 EB				JSR	GETDIGIT
  1919 EBA1 85 F5				STA	XREG
  1920 EBA3 20 49 EC				JSR	PRINTDIVCHAR
  1921 EBA6 A0 59				LDY	#$59
  1922 EBA8 20 B0 EB				JSR	GETDIGIT
  1923 EBAB 85 F4				STA	YREG
  1924 EBAD 4C 9F E2				JMP	WRITETIME2
  1925
  1926 EBB0 C8			GETDIGIT	INY
  1927 EBB1 84 FD				STY	YSAV
  1928 EBB3 20 EA EB		GETDIGIT1	JSR	NUMINPUT
  1929 EBB6 90 FB				BCC	GETDIGIT1
  1930 EBB8 AA					TAX
  1931 EBB9 E9 30				SBC	#48
  1932 EBBB 0A					ASL	
  1933 EBBC 0A					ASL	
  1934 EBBD 0A					ASL	
  1935 EBBE 0A					ASL	
  1936 EBBF C5 FD				CMP	YSAV
  1937 EBC1 B0 F0				BCS	GETDIGIT1
  1938 EBC3 85 FC				STA	TEMP
  1939 EBC5 8A					TXA
  1940 EBC6 20 52 E0				JSR	COUT
  1941 EBC9 20 EA EB		GETDIGIT2	JSR	NUMINPUT
  1942 EBCC 90 FB				BCC	GETDIGIT2
  1943 EBCE AA					TAX
  1944 EBCF E9 30				SBC	#48
  1945 EBD1 05 FC				ORA	TEMP
  1946 EBD3 C5 FD				CMP	YSAV
  1947 EBD5 B0 F2				BCS	GETDIGIT2
  1948 EBD7 85 FC				STA	TEMP
  1949 EBD9 A9 2E				LDA	#'.'
  1950 EBDB C5 F2				CMP	DIVCHAR
  1951 EBDD D0 04				BNE	GETDIGITEND
  1952 EBDF A5 FC				LDA	TEMP
  1953 EBE1 F0 E6				BEQ	GETDIGIT2
  1954 EBE3 8A			GETDIGITEND	TXA
  1955 EBE4 20 52 E0				JSR	COUT
  1956 EBE7 A5 FC				LDA	TEMP
  1957 EBE9 60					RTS
  1958
  1959
  1960 EBEA 20 47 E0		NUMINPUT	JSR	CIN
  1961 EBED C9 30				CMP	#'0'
  1962 EBEF 90 04				BCC	NOTNUM
  1963 EBF1 C9 3A				CMP	#':'
  1964 EBF3 90 02				BCC	ISNUM
  1965 EBF5 18			NOTNUM		CLC
  1966 EBF6 60					RTS
  1967 EBF7 38			ISNUM		SEC
  1968 EBF8 60					RTS
  1969
  1970 				; **** Print Date And Time *****************************************************
  1971
  1972 				; ******************************************************************************
  1973
  1974 EBF9 20 2B EC		PRINTDATETIME	JSR	PRINTDATE	; print current date	; PRINTFULLDATE
  1975 EBFC 20 5E E0				JSR	SPCOUT
  1976 EBFF 20 05 EC				JSR	PRINTTIME	; print current time
  1977 EC02 4C 5A E0				JMP	CROUT
  1978
  1979 				; **** Print Time **************************************************************
  1980
  1981 				; ******************************************************************************
  1982
  1983 EC05 A9 3A		PRINTTIME	LDA	#':'
  1984 EC07 85 F2				STA	DIVCHAR
  1985 EC09 20 DE E2				JSR	READTIME
  1986 EC0C 20 46 EC				JSR	PRINTDIGIT
  1987 EC0F 8A					TXA
  1988 EC10 20 46 EC				JSR	PRINTDIGIT
  1989 EC13 98					TYA
  1990 EC14 4C 91 E0				JMP	HEXOUT
  1991
  1992 				; **** Print Date And Day Of Week **********************************************
  1993
  1994 				; ******************************************************************************
  1995
  1996 EC17 20 92 E2		PRINTFULLDATE	JSR	READDOW
  1997 EC1A 0A					ASL	
  1998 EC1B 0A					ASL	
  1999 EC1C A8					TAY
  2000 EC1D A9 5E				LDA  	#< (DAYS-4)
  2001 EC1F 85 EA				STA  	PSTRL
  2002 EC21 A9 E8				LDA  	#> (DAYS-4)
  2003 EC23 85 EB				STA  	PSTRH
  2004 EC25 20 85 E0				JSR	WRSTR
  2005 EC28 20 5E E0				JSR	SPCOUT
  2006
  2007 				; **** Print Date **************************************************************
  2008
  2009 				; ******************************************************************************
  2010
  2011 EC2B A9 2E		PRINTDATE	LDA	#DATEDIV	; load divider char
  2012 EC2D 85 F2				STA	DIVCHAR
  2013 EC2F 20 E2 E2				JSR	READDATE	; read current date
  2014 EC32 85 FC				STA	TEMP		; store year value in TEMP
  2015 EC34 98					TYA
  2016 EC35 20 46 EC				JSR	PRINTDIGIT	; print day
  2017 EC38 8A					TXA
  2018 EC39 20 46 EC				JSR	PRINTDIGIT	; print month
  2019 EC3C A9 20				LDA	#CENTURY
  2020 EC3E 20 91 E0				JSR	HEXOUT		; print century
  2021 EC41 A5 FC				LDA	TEMP
  2022 EC43 4C 91 E0				JMP	HEXOUT		; print year
  2023
  2024 EC46 20 91 E0		PRINTDIGIT	JSR	HEXOUT		; print digit
  2025 EC49 A5 F2		PRINTDIVCHAR	LDA	DIVCHAR		; print divider char
  2026 EC4B 4C 52 E0				JMP	COUT
  2027
  2028 				; ******************************************************************************
  2029 				; START OF LOW LEVEL ROUTINES
  2030 				; ******************************************************************************
  2031
  2032 				; **** Print Processor Status **************************************************
  2033
  2034 				; ******************************************************************************
  2035
  2036 EC4E 20 36 E7		PRSTATUS	JSR	PRADDRESS	; print current program counter
  2037 EC51 A2 04				LDX	#$04
  2038 EC53 20 5E E0		NXTREG		JSR	SPCOUT		; print space char
  2039 EC56 BD 6D E7				LDA	PSSTR,X		; load register label
  2040 EC59 20 52 E0				JSR	COUT		; and print it
  2041 EC5C A9 3D				LDA	#'='
  2042 EC5E 20 52 E0				JSR	COUT		; print =
  2043 EC61 B5 F1				LDA	PREG,X
  2044 EC63 20 91 E0				JSR	HEXOUT
  2045 EC66 CA					DEX
  2046 EC67 10 EA				BPL	NXTREG
  2047 EC69 60					RTS
  2048
  2049 				; **** Initialize IO Devices ***************************************************
  2050
  2051 				; ******************************************************************************
  2052
  2053 EC6A A9 00		INITIO          LDA     #$00
  2054 EC6C A2 06		                LDX     #$06
  2055 EC6E 95 14		INITIO1         STA     IOBASE,X        ; clear K2,K3 and K4 base address pointers
  2056 EC70 CA			                DEX
  2057 EC71 D0 FB		                BNE     INITIO1
  2058
  2059 EC73 20 64 F7		                JSR     DEV_INIT        ; initialize driver list
  2060 EC76 A2 88		SET_TTY_DEV     LDX     #<  TTY_DEV
  2061 EC78 A0 F9		                LDY     #> TTY_DEV
  2062 EC7A 20 6F F7		                JSR     DEV_ADD         ; add terminal driver
  2063 EC7D 8D 74 1A				STA	STDINDEV        ; and initially set TTY as standard IO
  2064 EC80 8D 75 1A				STA	STDOUTDEV
  2065 EC83 85 C9				STA     DEVID
  2066
  2067 EC85 A2 A8		SET_XMODEM_DEV  LDX     #<  XMODEM_DEV
  2068 EC87 A0 F9		                LDY     #> XMODEM_DEV
  2069 EC89 20 6F F7		                JSR     DEV_ADD         ; add xmodem driver
  2070
  2071 EC8C A2 90		SET_PRINTER_DEV LDX     #<  PPRINT_DEV
  2072 EC8E A0 F9		                LDY     #> PPRINT_DEV
  2073 EC90 20 6F F7		                JSR     DEV_ADD         ; add parallel printer driver
  2074 EC93 8D 76 1A		                STA	STDPRINTDEV     ; and initially set parallel port printer as standard printer
  2075
  2076 EC96 20 A9 EC				JSR     DETECT_IO       ; detect IO cards
  2077
  2078 				; TEMP #### future: Set std beep only if no language card found
  2079
  2080 EC99 A9 6A		INIT_BEEP	LDA	#< DOBEEP	; load low byte of address of system beep
  2081 EC9B 8D 66 1A				STA	STDBEEP
  2082 EC9E A9 E1				LDA	#> DOBEEP	; load high byte of address of system beep
  2083 ECA0 8D 67 1A				STA	STDBEEP+1
  2084
  2085 ECA3 4C AD E1		                JMP     RESET_STDIO     ; reset to standard IO devices
  2086
  2087 ECA6 6C FA 00		IO_INITIALIZE   JMP     (ADRL)
  2088
  2089 				; **** Scan Bus And Detect IO Cards ********************************************
  2090 				;
  2091 				; ******************************************************************************
  2092
  2093 ECA9 A9 FB		DETECT_IO       LDA     #$FB
  2094 ECAB 85 FA		                STA     ADRL            ; set pointer to init routine
  2095 ECAD A9 07		                LDA     #$07
  2096 ECAF 85 FB		                STA     ADRH
  2097 ECB1 A9 03		                LDA     #$03            ; search on three slot base addresses
  2098 ECB3 85 FE		                STA     PDBCNT
  2099 ECB5 18			DETECT_LOOP     CLC
  2100 ECB6 A5 FB		                LDA     ADRH
  2101 ECB8 AA			                TAX
  2102 ECB9 E8			                INX                     ; X holds slot base address high byte
  2103 ECBA 69 04		                ADC     #$04
  2104 ECBC 85 FB		                STA     ADRH            ; set high byte to init routine
  2105 ECBE A0 03		                LDY	#$03            ; test byte string in card ROM against magic number
  2106 ECC0 B9 69 E7		COMP_LOOP	LDA	MAGIC1,Y        ; get one byte of magic number
  2107 ECC3 D1 FA				CMP	(ADRL),Y        ; and compare it with ROM content.
  2108 ECC5 D0 06				BNE	NO_MATCH        ; byte does not match, exit inner detection loop
  2109 ECC7 88					DEY                     ; byte matched magic number, try next one
  2110 ECC8 10 F6				BPL	COMP_LOOP       ; more bytes to compare?
  2111 ECCA 20 A6 EC				JSR     IO_INITIALIZE   ; IO card detected. Call init routine
  2112 ECCD C6 FE		NO_MATCH        DEC     PDBCNT
  2113 ECCF D0 E4		                BNE     DETECT_LOOP     ; try next card base address
  2114 				                                        ; fall through to IO/Language Card detection
  2115
  2116 				; **** Try To Detect IO/Language Card ******************************************
  2117 				;
  2118 				; ******************************************************************************
  2119
  2120 ECD1 A9 00		DETECT_IOL_CARD	LDA	#$00
  2121 ECD3 85 14				STA	IOBASEL		; set low byte of IO base pointer to $00
  2122 ECD5 A9 08				LDA	#$08		; try 1st IO-card at $0800
  2123 ECD7 85 15				STA	IOBASEH		; set high byte of IO base pointer to $00
  2124 						
  2125 ECD9 A0 03		DETECT_LP	LDY	#VIA_DDRA	; input & output regs are the same
  2126 ECDB A9 55				LDA	#$55		; DDRA = $55
  2127 ECDD 91 14				STA	(IOBASE),Y	; DDRA = 0101 0101 (0=input, 1=output)
  2128 ECDF A0 01				LDY	#VIA_PORTA	; 
  2129 ECE1 A9 00				LDA	#0
  2130 ECE3 91 14				STA	(IOBASE),Y	; Write all zeros to PORTA	
  2131 ECE5 B1 14				LDA	(IOBASE),Y	; Get PORTA value
  2132 ECE7 C9 AA				CMP	#$AA		; input bits should be 1, output bits should be 0
  2133 ECE9 F0 16				BEQ	INIT_IOCARD	; branch if a card is found
  2134 						
  2135 ECEB A5 15				LDA	IOBASEH		; MSB of IO base pointer
  2136 ECED 18					CLC
  2137 ECEE 69 04				ADC	#4		; next IO base-address
  2138 ECF0 85 15				STA	IOBASEH		; next card-address
  2139 ECF2 C9 14				CMP	#$14
  2140 ECF4 90 E3				BCC	DETECT_LP	; branch if MSB base-address < $14
  2141 						
  2142 ECF6 A9 00				LDA	#0
  2143 ECF8 85 15				STA	IOBASEH		; 0 = no card found
  2144 ECFA 60			NOCARD          RTS                     ; no card found
  2145
  2146 ECFB					ORG	$ED01		; maintain compatibility with v1.1.4
  2147 						
  2148 				; **** Initialize The IO/Language Card *****************************************
  2149 ED01 AD 74 1A		INIT_IOCARD     LDA     STDINDEV
  2150 ED04 C9 10		                CMP     #TTY1_ID
  2151 ED06 D0 03		                BNE     INIT_VIA        ; is standard input device still TTY?
  2152 ED08 20 BD F3		                JSR	DETECT_ASCIIKBD	; yes, check if ASCII keyboard available, else skip it
  2153 ED0B A0 10		INIT_VIA	LDY	#PORTB
  2154 ED0D A9 4E				LDA	#%01001110	; SDA=0,/CAS_MOT=1,CAS_SENSE=0,CAS_WR=0,/SPI_LOAD=1,SPI_CS=1,/SND_WE=1,SCL=0
  2155 ED0F 85 E4				STA	VIA_STATUS	; store current PortB output status
  2156 ED11 91 14				STA	(IOBASE),Y	; set SDA as input to pull it high, set SCL as input to pull it high
  2157 ED13 A0 12				LDY	#DDRB		; initialize data direction of port B
  2158 ED15 A9 5E				LDA	#%01011110	; SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
  2159 ED17 91 14				STA	(IOBASE),Y
  2160 ED19 A0 13				LDY	#DDRA		; initialize data direction of port A
  2161 ED1B A9 FF				LDA	#$FF		; all pins of port A are outputs
  2162 ED1D 91 14				STA	(IOBASE),Y
  2163 ED1F 20 D0 E3				JSR	SOUND_MUTEALL	; mute sound output
  2164 ED22 20 26 F4		INIT_SDCARD     JSR     SPI_INIT        ; initialize SPI
  2165 ED25 A2 B8		                LDX     #< SDC_DEV
  2166 ED27 A0 F9		                LDY     #> SDC_DEV
  2167 ED29 20 6F F7		                JSR     DEV_ADD         ; add sd-card driver
  2168 ED2C A9 00		INIT_TAPE       LDA	#$00
  2169 ED2E A0 1B		                LDY	#ACR		; select auxilary control register
  2170 ED30 91 14				STA	(IOBASE),Y	; set one shot timer mode
  2171 ED32 A0 1C				LDY	#PCR		; select peripheral control register
  2172 ED34 91 14				STA	(IOBASE),Y	; set interrupt on falling edge of CA1
  2173 ED36 20 8B ED				JSR	VIA2IRQ_ON	; Enable VIA2 Timer interrupt
  2174 ED39 20 75 ED				JSR	RESET_TIMER2	; set Timer2 to 1/60 second
  2175 ED3C A2 47				LDX	#< VIA2IRQ 	; set low address of clock interrupt routine
  2176 ED3E A0 ED				LDY	#> VIA2IRQ   	; set high address of clock interrupt routine
  2177 ED40 8E 7E 1A		SETIRQVECT	STX	IRQVECT
  2178 ED43 8C 7F 1A				STY	IRQVECT+1
  2179 ED46 60					RTS
  2180
  2181 				; ******************************************************************************
  2182 				; TAPE READ/WRITE ROUTINES removed 24-07-'25 Emile
  2183 				; ******************************************************************************
  2184
  2185 				; **** VIA2 IRQ Routine ********************************************************
  2186 ED47 48			VIA2IRQ		PHA			; save accumulator
  2187 ED48 98					TYA
  2188 ED49 48					PHA			; save Y register
  2189 ED4A A0 1D				LDY	#IFR		; select interrupt flag register
  2190 ED4C B1 14				LDA	(IOBASE),Y
  2191 ED4E 10 1F				BPL	NOVIA2IRQ	; check if it was a VIA2 interrupt
  2192 						
  2193 ED50 29 02				AND	#$02		; yes, CA1 interrupt occured?
  2194 ED52 F0 0E				BEQ	CHECKKEY	; no, check key status
  2195 						
  2196 ED54 A0 11		CHECKBIT	LDY	#PORTA		; VIA2 PORTA
  2197 ED56 B1 14				LDA	(IOBASE),Y	; clear CA1 interrupt flag
  2198 ED58 AD 9F 1A				LDA	CNTIRQ		; load timer IRQ status
  2199 ED5B A9 31				LDA	#RPTIME
  2200 ED5D 8D 95 1A				STA	CNTB		; set RIOT timer B to Read-Point-Time
  2201 ED60 D0 09				BNE	ENDVIA2IRQ	; and exit IRQ routine
  2202 						
  2203 ED62 20 75 ED		CHECKKEY	JSR	RESET_TIMER2	; reset Timer2 and interrupt flags
  2204 ED65 A5 DA				LDA     TICKCNT         ; load the tick counter
  2205 ED67 F0 02				BEQ     ENDVIA2IRQ      ; is it 0?
  2206 						
  2207 ED69 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  2208 ED6B 68			ENDVIA2IRQ	PLA
  2209 ED6C A8					TAY			; restore Y register
  2210 ED6D 68					PLA			; restore accumulator
  2211 ED6E 40					RTI
  2212
  2213 ED6F 68			NOVIA2IRQ	PLA
  2214 ED70 A8					TAY			; restore Y register
  2215 ED71 68				        PLA			; restore accumulator
  2216 ED72 4C 18 F3		USRIRQ		JMP	IRQ		; call user interrupt routine
  2217
  2218 				; **** Reset Timer2 Routine ****************************************************
  2219 ED75 A0 18		RESET_TIMER2	LDY	#T2CL		; select Timer2 lower byte register
  2220 ED77 A9 4B				LDA	#$4B		; reset Timer2
  2221 ED79 91 14				STA	(IOBASE),Y	; store timer low value
  2222 ED7B A9 41				LDA	#$41		; $411A = 16666 => 1/60 second
  2223 ED7D C8					INY			; select Timer2 higher byte register
  2224 ED7E 91 14		VIA2IRQ_W	STA	(IOBASE),Y	; store timer high value
  2225 ED80 60			VIA2IRQ_X	RTS			; return
  2226
  2227 				; **** VIA2 IRQ Off ************************************************************
  2228 ED81 A0 1E		VIA2IRQ_OFF     LDY	#IER		; select interrupt enable register
  2229 ED83 A5 15		                LDA     IOBASEH
  2230 ED85 F0 F9		                BEQ     VIA2IRQ_X    	; IO card available? No, just exit
  2231 ED87 A9 7F				LDA	#$7F		; Disable all VIA2 interrupts
  2232 ED89 D0 F3				BNE	VIA2IRQ_W	; branch always
  2233
  2234 				; **** VIA2 IRQ On *************************************************************
  2235 ED8B 20 81 ED		VIA2IRQ_ON	JSR	VIA2IRQ_OFF	; disable all VIA2 interrupts
  2236 ED8E A5 15		                LDA     IOBASEH
  2237 ED90 F0 EE		                BEQ     VIA2IRQ_X    	; IO card available? No, just exit
  2238 ED92 A9 A0				LDA	#$A0		; Enable interrupt for Timer2
  2239 ED94 D0 E8				BNE	VIA2IRQ_W	; branch always
  2240 						
  2241 				; ------------------------------------------------------------------------------
  2242 				; Writes one data byte to a specific register of the MCP23017.
  2243 				; Inputs: A: I2C-address of MCP23017 ($40, $42 or $44).
  2244 				;         X: the register to write to
  2245 				;         Y: the databyte to write into the register
  2246 				; Output: C=0: Error writing byte
  2247 				;         C=1: OK
  2248 				; ------------------------------------------------------------------------------
  2249 ED96 86 D8		MCP23017_WRITE	STX	SAVEX		; Save register address
  2250 ED98 84 D9				STY	SAVEY		; Save register data
  2251 ED9A AA					TAX			; X = I2C-address
  2252 ED9B 20 26 E3				JSR	I2C_START	; Send I2C start condition (affects A and Y)
  2253 ED9E 8A					TXA			; A now contains the address of the MCP23017 to write to
  2254 ED9F 29 FE				AND	#$FE		; Make sure it is an I2C write address
  2255 EDA1 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 address
  2256 EDA4 90 0C				BCC	MCP_WRX		; branch if C=0 (NACK)
  2257 						
  2258 EDA6 A5 D8				LDA	SAVEX		; Get register address
  2259 EDA8 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2260 EDAB 90 05				BCC	MCP_WRX		; branch if C=0 (NACK)
  2261
  2262 EDAD A5 D9				LDA	SAVEY		; Get databyte to write
  2263 EDAF 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2264 EDB2 4C 35 E3		MCP_WRX		JMP	I2C_STOP	; send I2C-stop and return
  2265
  2266 				; ------------------------------------------------------------------------------
  2267 				; Reads one data byte from a specific register of the MCP23017.
  2268 				; Inputs: A: I2C-address of MCP23017 ($40, $42 or $44).
  2269 				;         X: the register to read from
  2270 				; Output: C=0: Error reading byte
  2271 				;         C=1: A = byte read
  2272 				; ------------------------------------------------------------------------------
  2273 EDB5 29 FE		MCP23017_READ	AND	#$FE		; Make sure it is an I2C write address
  2274 EDB7 85 D9				STA	SAVEY		; Save I2C write address in SAVEY
  2275 EDB9 86 D8				STX	SAVEX		; SAVEX = register address
  2276 EDBB AA					TAX			; X = I2C write-address
  2277 EDBC 20 26 E3				JSR	I2C_START	; Send I2C start condition (affects A and Y)
  2278 EDBF 8A					TXA			; A now contains the address of the MCP23017 to write to
  2279 EDC0 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 address
  2280 EDC3 90 ED				BCC	MCP_WRX		; branch if C=0 (NACK)
  2281 						
  2282 EDC5 A5 D8				LDA	SAVEX		; Get register address
  2283 EDC7 20 67 E3				JSR	I2C_SEND	; I2C-write register address
  2284 EDCA 90 E6				BCC	MCP_WRX		; branch if C=0 (NACK)
  2285 						
  2286 EDCC 20 26 E3				JSR	I2C_START	; Send I2C repeated start condition
  2287 EDCF A5 D9				LDA	SAVEY		; Get I2C write address back
  2288 EDD1 09 01				ORA	#$01		; Make it an I2C read-address
  2289 EDD3 20 67 E3				JSR	I2C_SEND	; I2C-write MCP23017 read-address
  2290 EDD6 90 DA				BCC	MCP_WRX		; branch if C=0 (NACK)
  2291
  2292 EDD8 20 9F E3				JSR	I2C_RCV		; I2C-read: receive byte 
  2293 EDDB 48					PHA			; Save for now
  2294 EDDC 20 53 E3				JSR	I2C_NACK	; Send NACK (done reading)
  2295 EDDF 20 35 E3				JSR	I2C_STOP	; send I2C-stop and return
  2296 EDE2 68					PLA			; Get byte read back
  2297 EDE3 38					SEC			; C=1: ok
  2298 EDE4 60					RTS			; and return
  2299
  2300 EDE5					ORG 	$F015		; maintain compatibility with previous BIOS versions
  2301
  2302 				; ******************************************************************************
  2303 				; START OF XMODEM CODE
  2304 				; ******************************************************************************
  2305 				;
  2306 				; XMODEM/CRC Sender/Receiver for the 6502
  2307 				;
  2308 				; By Daryl Rictor Aug 2002
  2309 				;
  2310 				; A simple file transfer program to allow transfers between the SBC and a
  2311 				; console device utilizing the x-modem/CRC transfer protocol.
  2312 				;
  2313 				;*******************************************************************************
  2314 				; This implementation of XMODEM/CRC does NOT conform strictly to the
  2315 				; XMODEM protocol standard in that it (1) does not accurately time character
  2316 				; reception or (2) fall back to the Checksum mode.
  2317
  2318 				; (1) For timing, it uses a crude timing loop to provide approximate
  2319 				; delays.  These have been calibrated against a 1MHz CPU clock.  I have
  2320 				; found that CPU clock speed of up to 5MHz also work but may not in
  2321 				; every case.  Windows HyperTerminal worked quite well at both speeds!
  2322 				;
  2323 				; (2) Most modern terminal programs support XMODEM/CRC which can detect a
  2324 				; wider range of transmission errors so the fallback to the simple checksum
  2325 				; calculation was not implemented to save space.
  2326 				;*******************************************************************************
  2327 				;
  2328 				; Files transferred via XMODEM-CRC will have the load address contained in
  2329 				; the first two bytes in little-endian format:
  2330 				;  FIRST BLOCK
  2331 				;     offset(0) = lo(load start address),
  2332 				;     offset(1) = hi(load start address)
  2333 				;     offset(2) = data byte (0)
  2334 				;     offset(n) = data byte (n-2)
  2335 				;
  2336 				; Subsequent blocks
  2337 				;     offset(n) = data byte (n)
  2338 				;
  2339 				; One note, XMODEM send 128 byte blocks.  If the block of memory that
  2340 				; you wish to save is smaller than the 128 byte block boundary, then
  2341 				; the last block will be padded with zeros.  Upon reloading, the
  2342 				; data will be written back to the original location.  In addition, the
  2343 				; padded zeros WILL also be written into RAM, which could overwrite other
  2344 				; data.
  2345 				;
  2346 				;*******************************************************************************
  2347 				;
  2348 				; Code extensions 2022 by Joerg Walke
  2349 				;
  2350 				; Included: CAN command in addition to ESC to cancel sending and receiving data.
  2351 				; Included: EOT command to signal end of transmition.
  2352 				; Included: address range for received data, to override the start address in
  2353 				;           the first data block and to prevent overwriting of data by
  2354 				;	    trailing zeros.
  2355
  2356 				; XMODEM Receive Routine *******************************************************
  2357
  2358 F015 20 39 F2		XModemRcv       JSR     PrintXStart
  2359 F018 85 E0				STA	BLKEND		; set flag to false
  2360 F01A A9 01		                LDA     #$01
  2361 F01C 85 E2		                STA     BLKNO           ; set block # to 1
  2362 F01E 85 E1		                STA	BFLAG           ; set flag to get address from block 1
  2363 F020 A9 43		StartRcv        LDA     #'C'            ; "C" start with CRC mode
  2364 F022 20 65 F3		                JSR     SOUT	     	; send it
  2365 F025 A9 FF		                LDA     #$FF
  2366 F027 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2367 F029 A9 00		                LDA     #$00
  2368 F02B 85 DC		                STA     CRCL
  2369 F02D 85 DD		                STA     CRCH            ; init CRC value
  2370 F02F 20 E2 F1		                JSR     GetByte         ; wait for input
  2371 F032 B0 0C				BCS     GotByte         ; byte received, process it
  2372 F034 4C 20 F0				JMP     StartRcv
  2373 F037 A9 FF		StartBlk        LDA     #$FF
  2374 F039 85 DF		                STA     RETRYH          ; set loop counter for ~3 sec delay
  2375 F03B 20 E2 F1		                JSR     GetByte         ; get first byte of block
  2376 F03E 90 F7		                BCC     StartBlk        ; timed out, keep waiting...
  2377 F040 C9 1B		GotByte         CMP     #ESC            ; quitting?
  2378 F042 F0 04		                BEQ     GotESC          ; yes
  2379 F044 C9 18				CMP	#CAN		; cancel?
  2380 F046 D0 03				BNE     GotByte1	; no
  2381 F048 4C 41 F2		GotESC          JMP     PrintXErr       ; print error and return
  2382 F04B C9 01		GotByte1        CMP     #SOH            ; start of block?
  2383 F04D F0 07		                BEQ     BegBlk          ; yes
  2384 F04F C9 04		                CMP     #EOT            ;
  2385 F051 D0 45		                BNE     BadCRC          ; Not SOH or EOT, so flush buffer & send NAK
  2386 F053 4C FB F0		                JMP     RDone           ; EOT - all done!
  2387 F056 A2 00		BegBlk          LDX     #$00
  2388 F058 A9 FF		GetBlk          LDA     #$FF            ; 3 sec window to receive characters
  2389 F05A 85 DF		                STA     RETRYH
  2390 F05C 20 CF F1		GetBlk1         JSR     GetData         ; get next character
  2391 F05F 90 37		                BCC     BadCRC          ; chr rcv error, flush and send NAK
  2392 F061 9D 00 15		GetBlk2         STA     RBUFF,x         ; good char, save it in the rcv buffer
  2393 F064 E8			                INX                     ; inc buffer pointer
  2394 F065 E0 84		                CPX     #$84            ; <01> <FE> <128 bytes> <CRCH> <CRCL>
  2395 F067 D0 EF		                BNE     GetBlk          ; get 132 characters
  2396 F069 A2 00		                LDX     #$00
  2397 F06B BD 00 15		                LDA     RBUFF,x         ; get block # from buffer
  2398 F06E C5 E2		                CMP     BLKNO           ; compare to expected block #
  2399 F070 F0 06		                BEQ     GoodBlk1        ; matched!
  2400 F072 20 41 F2		                jsr     PrintXErr       ; Unexpected block number - abort
  2401 F075 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2402 F078 49 FF		GoodBlk1        EOR     #$FF            ; 1's comp of block #
  2403 F07A E8			                INX                     ;
  2404 F07B DD 00 15		                CMP     RBUFF,x         ; compare with expected 1's comp of block #
  2405 F07E F0 06		                BEQ     GoodBlk2        ; matched!
  2406 F080 20 41 F2		                JSR     PrintXErr       ; Unexpected block number - abort
  2407 F083 4C 0F F2		                JMP     Flush           ; mismatched - flush buffer and return
  2408 F086 20 19 F2		GoodBlk2        JSR     CalcCRC         ; calc CRC
  2409 F089 B9 00 15		                LDA     RBUFF,y         ; get hi CRC from buffer
  2410 F08C C5 DD		                CMP     CRCH            ; compare to calculated hi CRC
  2411 F08E D0 08		                BNE     BadCRC          ; bad crc, send NAK
  2412 F090 C8			                INY                     ;
  2413 F091 B9 00 15		                LDA     RBUFF,y         ; get lo CRC from buffer
  2414 F094 C5 DC		                CMP     CRCL            ; compare to calculated lo CRC
  2415 F096 F0 0B		                BEQ     GoodCRC         ; good CRC
  2416 F098 20 0F F2		BadCRC          JSR     Flush           ; flush the input port
  2417 F09B A9 15		                LDA     #NAK            ;
  2418 F09D 20 65 F3		                JSR     SOUT            ; send NAK to resend block
  2419 F0A0 4C 37 F0		                JMP     StartBlk        ; start over, get the block again
  2420 F0A3 A2 02		GoodCRC         LDX     #$02            ;
  2421 F0A5 A5 E2		                LDA     BLKNO           ; get the block number
  2422 F0A7 C9 01		                CMP     #$01            ; 1st block?
  2423 F0A9 D0 21		                BNE     CopyBlk         ; no, copy all 128 bytes
  2424 F0AB A5 E1		                LDA     BFLAG           ; is it really block 1, not block 257, 513 etc.
  2425 F0AD F0 1D		                BEQ     CopyBlk         ; no, copy all 128 bytes
  2426 F0AF A5 FF				LDA     MODE		; address mode = 0?
  2427 F0B1 F0 03				BEQ	READADR         ; yes, read start address from data stream
  2428 F0B3 E8			                INX
  2429 F0B4 D0 0B				BNE     READDATA	; branch always
  2430 F0B6 BD 00 15		READADR         LDA     RBUFF,x         ; get target address from 1st 2 bytes of blk 1
  2431 F0B9 85 FA				STA     ADRL            ; save lo address
  2432 F0BB E8			                INX
  2433 F0BC BD 00 15		                LDA     RBUFF,x         ; get hi address
  2434 F0BF 85 FB		                STA     ADRH            ; save it
  2435 F0C1 A5 FA		READDATA        LDA	ADRL
  2436 F0C3 85 E8				STA	STOL		; save start address low byte
  2437 F0C5 A5 FB				LDA	ADRH
  2438 F0C7 85 E9				STA	STOH		; save start address high byte
  2439 F0C9 E8					INX                     ; point to first byte of data
  2440 F0CA C6 E1		                DEC     BFLAG           ; set the flag so we won't get another address
  2441 F0CC A0 00		CopyBlk         LDY     #$00            ; set offset to zero
  2442 F0CE A5 E0		CopyBlk3        LDA     BLKEND		; block end flag set?
  2443 F0D0 D0 14				BNE     CopyBlk5	; yes, skip reading data
  2444 F0D2 BD 00 15				LDA     RBUFF,x         ; get data byte from buffer
  2445 F0D5 91 E8				STA     (STOL),y        ; save to target
  2446 F0D7 38					SEC
  2447 F0D8 A5 F8		                LDA     NUML
  2448 F0DA E5 E8		                SBC     STOL            ; are we at the last address?
  2449 F0DC D0 08		                BNE     CopyBlk5  	; no, inc pointer and continue
  2450 F0DE A5 F9		                LDA     NUMH
  2451 F0E0 E5 E9		                SBC     STOH
  2452 F0E2 D0 02		                BNE     CopyBlk5
  2453 F0E4 E6 E0		                INC     BLKEND		; yes, set last byte flag
  2454 F0E6 E6 E8		CopyBlk5	INC     STOL            ; point to next address
  2455 F0E8 D0 02		                BNE     CopyBlk4        ; did it step over page boundary?
  2456 F0EA E6 E9		                INC     STOH            ; adjust high address for page crossing
  2457 F0EC E8			CopyBlk4        INX                     ; point to next data byte
  2458 F0ED E0 82		                CPX     #$82            ; is it the last byte
  2459 F0EF D0 DD		                BNE     CopyBlk3        ; no, get the next one
  2460 F0F1 E6 E2		IncBlk          INC     BLKNO           ; done.  Inc the block #
  2461 F0F3 A9 06		                LDA     #ACK            ; send ACK
  2462 F0F5 20 65 F3		                JSR     SOUT
  2463 F0F8 4C 37 F0		                JMP     StartBlk        ; get next block
  2464 F0FB A9 06		RDone           LDA     #ACK            ; last block, send ACK and exit.
  2465 F0FD 20 65 F3		                JSR     SOUT
  2466 F100 20 0F F2		                JSR     Flush           ; get leftover characters, if any
  2467 F103 4C 49 F2		                JMP     PrintXSucc
  2468
  2469 				; XMODEM Send Routine **********************************************************
  2470
  2471 F106 20 39 F2		XModemSnd       JSR     PrintXStart
  2472 F109 85 E3				STA     ERRCNT          ; error counter set to 0
  2473 F10B 85 E0				STA     BLKEND          ; set flag to false
  2474 F10D A9 01				LDA     #$01
  2475 F10F 85 E2		                STA     BLKNO           ; set block # to 1
  2476 F111 A9 FF		Wait4CRC        LDA     #$FF            ; 3 seconds
  2477 F113 85 DF		                STA     RETRYH
  2478 F115 20 E2 F1		                JSR     GetByte
  2479 F118 90 F7		                BCC     Wait4CRC        ; wait for something to come in...
  2480 F11A C9 43		                CMP     #'C'            ; is it the "C" to start a CRC xfer?
  2481 F11C F0 0B		                BEQ     SetStoAddr      ; yes
  2482 F11E C9 1B		                CMP     #ESC            ; is it a cancel? <Esc> Key
  2483 F120 F0 04		                BEQ     DoCancel        ; No, wait for another character
  2484 F122 C9 18				CMP     #CAN            ; is it a cancel?
  2485 F124 D0 EB		                BNE     Wait4CRC        ; No, wait for another character
  2486 F126 4C C6 F1		DoCancel        JMP     PrtAbort        ; Print abort msg and exit
  2487 F129 A9 01		SetStoAddr	LDA     #$01            ; manually load blk number
  2488 F12B 8D 00 15		                STA     RBUFF           ; into 1st byte
  2489 F12E A9 FE		                LDA     #$FE            ; load 1's comp of block #
  2490 F130 8D 01 15		                STA     RBUFF+1         ; into 2nd byte
  2491 F133 A5 FA		                LDA     ADRL            ; load low byte of start address
  2492 F135 8D 02 15		                STA     RBUFF+2         ; into 3rd byte
  2493 F138 A5 FB		                LDA     ADRH            ; load hi byte of start address
  2494 F13A 8D 03 15		                STA     RBUFF+3         ; into 4th byte
  2495 F13D A2 04				LDX     #$04            ; preload X to receive buffer
  2496 F13F A0 00				LDY     #$00            ; init data block offset to 0
  2497 F141 F0 17		                BEQ     LdBuff1         ; jump into buffer load routine
  2498 F143 A5 E0		LdBuffer        LDA     BLKEND          ; was the last block sent?
  2499 F145 F0 03		                BEQ     LdBuff0         ; no, send the next one
  2500 F147 4C CC F1		                JMP     SDone           ; yes, we're done
  2501 F14A A2 02		LdBuff0         LDX     #$02            ; init pointers
  2502 F14C A0 00		                LDY     #$00
  2503 F14E E6 E2		                INC     BLKNO           ; inc block counter
  2504 F150 A5 E2		                LDA     BLKNO
  2505 F152 8D 00 15		                STA     RBUFF           ; save in 1st byte of buffer
  2506 F155 49 FF		                EOR     #$FF
  2507 F157 8D 01 15		                STA     RBUFF+1         ; save 1's comp of blkno next
  2508 F15A B1 FA		LdBuff1         LDA     (ADRL),y        ; save 128 bytes of data
  2509 F15C 9D 00 15		                STA     RBUFF,x
  2510 F15F 38			LdBuff2         SEC
  2511 F160 A5 F8		                LDA     NUML
  2512 F162 E5 FA		                SBC     ADRL            ; are we at the last address?
  2513 F164 D0 14		                BNE     LdBuff4         ; no, inc pointer and continue
  2514 F166 A5 F9		                LDA     NUMH
  2515 F168 E5 FB		                SBC     ADRH
  2516 F16A D0 0E		                BNE     LdBuff4
  2517 F16C E6 E0		                INC     BLKEND          ; yes, set last byte flag
  2518 F16E E8			LdBuff3         INX
  2519 F16F E0 82		                CPX     #$82            ; are we at the end of the 128 byte block?
  2520 F171 F0 12		                BEQ     SCalcCRC        ; yes, calc CRC
  2521 F173 A9 00		                LDA     #$00            ; fill rest of 128 bytes with $00
  2522 F175 9D 00 15		                STA     RBUFF,x
  2523 F178 F0 F4		                BEQ     LdBuff3         ; branch always
  2524 F17A E6 FA		LdBuff4         INC     ADRL            ; inc address pointer
  2525 F17C D0 02		                BNE     LdBuff5
  2526 F17E E6 FB		                INC     ADRH
  2527 F180 E8			LdBuff5         INX
  2528 F181 E0 82		                CPX     #$82            ; last byte in block?
  2529 F183 D0 D5		                BNE     LdBuff1         ; no, get the next
  2530 F185 20 19 F2		SCalcCRC        JSR     CalcCRC
  2531 F188 A5 DD		                LDA     CRCH            ; save hi byte of CRC to buffer
  2532 F18A 99 00 15		                STA     RBUFF,y
  2533 F18D C8			                INY
  2534 F18E A5 DC		                LDA     CRCL            ; save lo byte of CRC to buffer
  2535 F190 99 00 15		                STA     RBUFF,y
  2536 F193 A2 00		Resend          LDX     #$00
  2537 F195 A9 01		                LDA     #SOH
  2538 F197 20 65 F3		                JSR     SOUT            ; send SOH
  2539 F19A BD 00 15		SendBlk         LDA     RBUFF,x         ; send 132 bytes in buffer to the console
  2540 F19D 20 65 F3		                JSR     SOUT
  2541 F1A0 E8			                INX
  2542 F1A1 E0 84		                CPX     #$84            ; last byte?
  2543 F1A3 D0 F5		                BNE     SendBlk         ; no, get next
  2544 F1A5 A9 FF		                LDA     #$FF            ; yes, set 3 second delay
  2545 F1A7 85 DF		                STA     RETRYH          ; and
  2546 F1A9 20 E2 F1		                JSR     GetByte         ; wait for ACK/NACK
  2547 F1AC 90 10		                BCC     SetError        ; no char received after 3 seconds, resend
  2548 F1AE C9 06		                CMP     #ACK            ; char received... is it:
  2549 F1B0 F0 91		                BEQ     LdBuffer        ; ACK, send next block
  2550 F1B2 C9 15		                CMP     #NAK
  2551 F1B4 F0 08		                BEQ     SetError        ; NAK, inc errors and resend
  2552 F1B6 C9 1B		                CMP     #ESC
  2553 F1B8 F0 0C		                BEQ     PrtAbort        ; ESC pressed to abort
  2554 F1BA C9 18				CMP	#CAN
  2555 F1BC F0 08				BEQ     PrtAbort	; CANCEL send
  2556 									; fall through to error counter
  2557 F1BE E6 E3		SetError        INC     ERRCNT          ; inc error counter
  2558 F1C0 A5 E3		                LDA     ERRCNT
  2559 F1C2 C9 0A		                CMP     #$0A            ; are there 10 errors? (Xmodem spec for failure)
  2560 F1C4 D0 CD		                BNE     Resend          ; no, resend block
  2561
  2562 F1C6 20 0F F2		PrtAbort        JSR     Flush           ; yes, too many errors, flush buffer,
  2563 F1C9 4C 41 F2		                JMP     PrintXErr       ; print error msg and exit
  2564 F1CC 4C 49 F2		SDone           JMP     PrintXSucc   	; All Done..Print msg and exit
  2565
  2566 				; Get Data From Serial Port ****************************************************
  2567
  2568 F1CF A9 00		GetData		LDA     #$00            ; wait for chr input and cycle timing loop
  2569 F1D1 85 DE		                STA     RETRYL          ; set low value of timing loop
  2570 F1D3 20 75 F3		LoopGetData     JSR     SIN        	; get chr from serial port, don't wait
  2571 F1D6 B0 09		                BCS     EndGetData      ; got one, so exit
  2572 F1D8 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2573 F1DA D0 F7		                BNE     LoopGetData
  2574 F1DC C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2575 F1DE D0 F3		                BNE     LoopGetData     ; look for character again
  2576 F1E0 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2577 F1E1 60			EndGetData      RTS                     ; with character in A
  2578
  2579 				; Get Byte From Serial Port. Check if ESC pressed ******************************
  2580
  2581 F1E2 A9 00		GetByte		LDA     #$00            ; wait for chr input and cycle timing loop
  2582 F1E4 85 DE		                STA     RETRYL          ; set low value of timing loop
  2583 F1E6 A9 75		LoopGetByte     LDA     #< SIN        ; check low byte of serial in address
  2584 F1E8 CD 6E 1A				CMP	STDIN	        ; is Low(stdin) = Low(SIN)?
  2585 F1EB D0 07		                BNE     GetChar         ; no, use standard Get Char Routine
  2586 F1ED A9 F3		                LDA     #> SIN       ; yes, check high byte of serial in address
  2587 F1EF CD 6F 1A		                CMP     STDIN+1         ; is High(stdin) = High(SIN)?
  2588 F1F2 F0 0C		                BEQ	ReadByte	; yes, just read input stream
  2589 F1F4 20 4D E0		GetChar		JSR	CGET
  2590 F1F7 90 07				BCC	ReadByte
  2591 F1F9 C9 1B				CMP	#ESC
  2592 F1FB D0 03				BNE	ReadByte
  2593 F1FD 38					SEC
  2594 F1FE B0 0E				BCS	EndGetByte
  2595 				;		JSR	CHKESC		; no, check stdin if ESC key pressed
  2596 				;		BCC	ReadByte	; no ESC pressed, read data byte from serial port
  2597 				;		LDA	#ESC
  2598 				;		BNE     EndGetByte      ; ESC pressed, so exit
  2599 F200 20 75 F3		ReadByte	JSR     SIN        	; get chr from serial port, don't wait
  2600 F203 B0 09		                BCS     EndGetByte      ; got one, so exit
  2601 F205 C6 DE		                DEC     RETRYL          ; no character received, so dec counter
  2602 F207 D0 DD		                BNE     LoopGetByte
  2603 F209 C6 DF		                DEC     RETRYH          ; dec hi byte of counter
  2604 F20B D0 D9		                BNE     LoopGetByte     ; look for character again
  2605 F20D 18			                CLC                     ; if loop times out, CLC, else SEC and return
  2606 F20E 60			EndGetByte      RTS                     ; with character in A
  2607
  2608 				; Empty Buffer *****************************************************************
  2609
  2610 F20F A9 1C		Flush           LDA     #$1C            ; flush receive buffer
  2611 F211 85 DF		                STA     RETRYH          ; flush until empty for ~1/4 sec.
  2612 F213 20 CF F1		Flush1          JSR     GetData         ; read the port
  2613 F216 B0 F7		                BCS     Flush           ; if char received, wait for another
  2614 F218 60			                RTS
  2615
  2616 				; Calculate CRC ****************************************************************
  2617
  2618 F219 A9 00		CalcCRC		LDA	#$00		; calculate the CRC for the 128 bytes
  2619 F21B 85 DC				STA	CRCL
  2620 F21D 85 DD				STA	CRCH
  2621 F21F A0 02				LDY	#$02
  2622 F221 B9 00 15		CalcCRC1	LDA	RBUFF,y
  2623 F224 45 DD				EOR 	CRCH 		; Quick CRC computation with lookup tables
  2624 F226 AA			       		TAX		 	; updates the two bytes at crc & crc+1
  2625 F227 A5 DC		       		LDA 	CRCL		; with the byte send in the "A" register
  2626 F229 5D 00 FB		       		EOR 	CRCHI,x
  2627 F22C 85 DD		       		STA 	CRCH
  2628 F22E BD 00 FA		      	 	LDA 	CRCLO,x
  2629 F231 85 DC		       		STA 	CRCL
  2630 F233 C8					INY
  2631 F234 C0 82				CPY	#$82		; done yet?
  2632 F236 D0 E9				BNE	CalcCRC1	; no, get next
  2633 F238 60					RTS			; y=82 on exit
  2634
  2635 				; Print XModem Messages ********************************************************
  2636
  2637 F239 78			PrintXStart     SEI			; disable interrupts during XModem transfer
  2638 F23A 20 0F F2				JSR	Flush		; clear buffer
  2639 F23D A0 00				LDY     #$00		; load start message
  2640 F23F F0 0C				BEQ	PrintXMsg
  2641
  2642 F241 20 67 E1		PrintXErr       JSR	BEEP
  2643 F244 A0 28		PrintXError	LDY     #(ERRX-MSGX)	; load error message
  2644 F246 18					CLC
  2645 F247 D0 03				BNE     PrintXEnd
  2646
  2647 F249 A0 39		PrintXSucc      LDY     #(SUCCX-MSGX)	; load success message
  2648 F24B 38					SEC
  2649 F24C 58			PrintXEnd	CLI			; enable interrupts
  2650
  2651 F24D A9 00		PrintXMsg	LDA     #$00
  2652 F24F 2A					ROL			; save carry
  2653 F250 48					PHA
  2654 F251 B9 5F F2		PrintXMsg1	LDA  	MSGX,Y   	; load char at string pos y
  2655 F254 F0 06				BEQ  	EndXMsg  	; exit, if NULL char
  2656 F256 20 52 E0				JSR  	COUT       	; write character
  2657 F259 C8					INY             	; next index
  2658 F25A D0 F5				BNE  	PrintXMsg1
  2659 F25C 68			EndXMsg		PLA
  2660 F25D 4A					LSR			; restore carry and leave A = 0
  2661 F25E 60					RTS
  2662
  2663 				; ******************************************************************************
  2664 				; String Data Section
  2665 				; ******************************************************************************
  2666 F25F 0D 42 65 67 69 6E + MSGX            .by     CR 'Begin data transfer, <ESC> to cancel. ' $00
  2667 F287 0D 54 72 61 6E 73 + ERRX		.by	CR 'Transfer Error' CR $00
  2668 F298 04 04 04		SUCCX           .byte	EOT,EOT,EOT
  2669 F29B 0D 4F 4B 0D 00	MSG_OK		.by	CR 'OK' CR $00
  2670 									; Tape Messages removed 25-07-'25 Emile
  2671 F2A0					ORG	*+120		; maintain compatibility with v1.1.4
  2672 						
  2673 				; **** IRQ, NMI and BREAK Service Routines *************************************
  2674
  2675 				; ******************************************************************************
  2676
  2677 F318 8D 77 1A		IRQ		STA	STOACC		; save current accumulator
  2678 F31B 68					PLA			; get current processor status in A
  2679 F31C 48					PHA			; and push it back to stack
  2680 F31D 29 10				AND	#$10		; mask break flag
  2681 F31F D0 06				BNE	USRBREAK	; if break flag set, jump to user break handler
  2682 F321 AD 77 1A				LDA	STOACC
  2683 F324 6C 7C 1A				JMP	(IRQUSR)	; else jump to clock IRQ routine
  2684
  2685 F327 AD 77 1A		USRBREAK	LDA	STOACC
  2686 F32A 6C 78 1A				JMP	(BRKUSR)
  2687
  2688 F32D 85 F3		NMI		STA	ACC		; save current accumulator
  2689
  2690 F32F			BREAK					; default IRQUSR & BRKUSR entry
  2691 F32F 68					PLA			; get current processor status in A
  2692 F330 85 F1				STA	PREG		; save it
  2693 F332 48					PHA			; and push it back to stack
  2694 F333 86 F5				STX	XREG		; save x-register
  2695 F335 84 F4				STY	YREG		; save y-register
  2696 F337 20 AD E1				JSR	RESET_STDIO	; always reset to standard I/O
  2697 F33A 28					PLP			; get last processor status
  2698 F33B 68					PLA			; get last program counter low byte
  2699 F33C 85 EF				STA	PCL		; and store it
  2700 F33E 85 FA				STA	ADRL
  2701 F340 68					PLA			; get last program counter high byte
  2702 F341 85 F0				STA	PCH		; and store it
  2703 F343 85 FB				STA	ADRH
  2704 F345 BA					TSX			; get current stack pointer
  2705 F346 86 F2				STX	SPUSER		; and store it
  2706 F348 D8					CLD			; set binary mode
  2707 F349 20 67 E1				JSR	BEEP		; error beep
  2708 F34C 20 4E EC				JSR	PRSTATUS	; print user program status
  2709 F34F A2 FF				LDX     #$FF
  2710 F351 9A					TXS			; initialize stack pointer
  2711 F352 58					CLI			; enable interrupts
  2712 F353 4C 3B E6				JMP	MONRESET	; and return to monitor
  2713
  2714 									; GETMAGIC removed 25-07-'25 Emile
  2715 F356					ORG	*+15		; maintain compatibility with v1.1.4
  2716
  2717 				; **** Write To Serial Routine *************************************************
  2718
  2719 				; Input: A - Output Byte to RS232
  2720
  2721 				; ******************************************************************************
  2722
  2723 F365			SOUT
  2724 F365 08			SERIALOUT	PHP			; save processor status
  2725 F366 78					SEI			; disable interrupts
  2726 F367 48					PHA			; save character
  2727 F368 A9 10				LDA  	#$10
  2728 F36A 2C 01 16		EMPTY?		BIT  	STAT_REG	; ACIA output register empty?
  2729 F36D F0 FB				BEQ  	EMPTY?		; no, check again.
  2730 F36F 68					PLA			; restore character
  2731 F370 8D 00 16				STA  	DATA_REG   	; write character to ACIA
  2732 F373 28					PLP			; restore processor status
  2733 F374 60					RTS
  2734
  2735 				; **** Read From Serial Routine ************************************************
  2736
  2737 				; Output: A - Input Byte from RS232
  2738 				;         C - 1 char get, 0 no char get
  2739
  2740 				; ******************************************************************************
  2741
  2742 F375			SIN
  2743 F375 18			SERIALIN	CLC              	; set to no chr present
  2744 F376 AD 01 16				LDA	STAT_REG
  2745 F379 29 08				AND	#$08		; ACIA input register full?
  2746 F37B F0 04				BEQ	SERIALEND	; no, just exit
  2747 F37D AD 00 16				LDA	DATA_REG	; yes, read character
  2748 F380 38					SEC		 	; and set C = 1, char present
  2749 F381 60			SERIALEND	RTS
  2750
  2751 				; **** Read From ASCII Keyboard Routine ****************************************
  2752
  2753 				; Output: A - Input Byte from Keyboard
  2754 				;         C - 1 char get, 0 no char get
  2755
  2756 				; ******************************************************************************
  2757
  2758 F382 AD 81 1A		ASCIIKBD	LDA	PADD		; are we in read mode?
  2759 F385 F0 03				BEQ	READMODE	; yes, check if data available
  2760 F387 20 10 F4				JSR	SETPPORTIN	; no, first set parallel port as an input
  2761 F38A 18			READMODE	CLC			; set to no char present
  2762 F38B 2C 85 1A				BIT	WRDC		; test PA7 (DATA_AVAIL)
  2763 F38E 50 09				BVC	NODATA		; no new data, just exit with C = 0
  2764 F390 AD 85 1A				LDA	WRDC		; clear PA7 flag
  2765 F393 AD 80 1A				LDA	PAD		; load keyboard ASCII code from port A
  2766 F396 29 7F				AND	#%01111111	; clear MSB
  2767 F398 38			DATA_AVAIL	SEC			; and set C = 1, char present
  2768 F399 60			NODATA		RTS
  2769
  2770 				; **** PS2 Keyboard Driver Routine *********************************************
  2771
  2772 				; Output: A - Input Byte from Keyboard
  2773 				;         C - 1 char get, 0 no char get
  2774
  2775 				; ******************************************************************************
  2776
  2777 F39A 18			PS2KBD          CLC                     ; set to no char present
  2778 F39B 84 F1		                STY     PREG            ; save current Y register
  2779 F39D A0 0E		                LDY     #PIA_PORTC
  2780 F39F B1 16		                LDA     (FGCBASE),Y     ; load data from Port C
  2781 F3A1 29 20		                AND     #$20            ; and check Strobe line
  2782 F3A3 F0 15		                BEQ     PS2_NODATA      ; no data received, just exit with C = 0
  2783 F3A5 A0 0C		                LDY     #PIA_PORTA
  2784 F3A7 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  2785 F3A9 D0 0E		                BNE     PS2_DATA_AVAIL
  2786 F3AB A0 0E		                LDY     #PIA_PORTC      ; NULL Byte received, check for second byte
  2787 F3AD B1 16		PS2_CHECK       LDA     (FGCBASE),Y     ; load data from Port C
  2788 F3AF 29 20		                AND     #$20            ; and check Strobe line
  2789 F3B1 F0 FA		                BEQ     PS2_CHECK       ; no data received, repeat
  2790 F3B3 A0 0C		                LDY     #PIA_PORTA
  2791 F3B5 B1 16		                LDA     (FGCBASE),Y     ; data received, load it from Port A
  2792 F3B7 09 80		                ORA     #$80            ; set bit 7
  2793 F3B9 38			PS2_DATA_AVAIL  SEC			; and set C = 1, char present
  2794 F3BA A4 F1		PS2_NODATA      LDY     PREG            ; restore Y register
  2795 F3BC 60			                RTS
  2796
  2797 				; **** Detect ASCII Keyboard Routine *******************************************
  2798
  2799 				; ******************************************************************************
  2800
  2801 F3BD 20 10 F4		DETECT_ASCIIKBD JSR	SETPPORTIN	; set parallel port as an input
  2802 F3C0 AD 80 1A				LDA	PAD		; read parallel port
  2803 F3C3 C9 FF				CMP	#$FF		; is there anything connected?
  2804 F3C5 F0 0A				BEQ	NOKBD		; no, just exit
  2805 F3C7 A2 98		                LDX     #<  KEYBD_DEV
  2806 F3C9 A0 F9		                LDY     #> KEYBD_DEV
  2807 F3CB 20 6F F7		                JSR     DEV_ADD         ; add ASCII keyboard driver
  2808 F3CE 8D 74 1A				STA	STDINDEV	; make it the standard input device
  2809 F3D1 60			NOKBD		RTS
  2810
  2811 				; **** Write To Parallel Port Routine ******************************************
  2812
  2813 				; Input: A - Output Byte to parallel port
  2814
  2815 				; ******************************************************************************
  2816
  2817 F3D2 48			PPORTOUT	PHA			; save character
  2818 F3D3 A9 BE				LDA	#$BE		; initialize handshake line I/O on port b
  2819 F3D5 CD 83 1A				CMP	PBDD		; already initialized?
  2820 F3D8 F0 03				BEQ	SETHSK		; yes, just set output values
  2821 F3DA 8D 83 1A				STA	PBDD		; no, PB7 = /strobe, PB6 = busy, PB5 = r/w, PB0 = speaker off
  2822 F3DD A9 86		SETHSK		LDA	#$86		; set handshake lines to their initial values
  2823 F3DF 8D 82 1A				STA	PBD		; r/w = L, strobe = H, PB1,PB2 = H -> hex-kbd disabled; speaker = H
  2824 F3E2 A9 FF				LDA	#$FF		; all port A lines are outputs
  2825 F3E4 8D 81 1A				STA	PADD
  2826 F3E7 68					PLA			; reload character in A
  2827 F3E8 48					PHA
  2828 F3E9 8D 80 1A				STA	PAD		; set output data
  2829 F3EC 2C 82 1A		PPORTBSY?	BIT	PBD		; bussy line is high?
  2830 F3EF 70 FB				BVS	PPORTBSY?	; yes, check bussy line again
  2831 F3F1 A9 06				LDA	#$06		; generate strobe pulse
  2832 F3F3 8D 82 1A				STA	PBD		; set strobe line low
  2833 F3F6 A9 86				LDA	#$86
  2834 F3F8 8D 82 1A				STA	PBD		; set strobe line high
  2835 F3FB 68					PLA			; restore character
  2836 F3FC 60					RTS
  2837
  2838 				; **** Read From Parallel Port Routine *****************************************
  2839
  2840 				; Output: A - Input Byte from parallel port
  2841 				;         C - 1 char get, 0 no char get
  2842
  2843 				; ******************************************************************************
  2844
  2845 F3FD 20 10 F4		PPORTIN		JSR	SETPPORTIN	; set parallel port as input
  2846 F400 18					CLC
  2847 F401 2C 82 1A				BIT	PBD		; check if /STROBE = 0
  2848 F404 30 09				BMI	NOSTROBE	; no, just exit with C = 0
  2849 F406 2C 82 1A		STROBE?		BIT	PBD		; yes, wait for strobe to come high again
  2850 F409 30 FB				BMI	STROBE?
  2851 F40B AD 80 1A				LDA	PAD		; load data from port A
  2852 F40E 38					SEC			; and set C = 1, data present
  2853 F40F 60			NOSTROBE	RTS
  2854
  2855 				; **** Switch Parallel Port To Data Input **************************************
  2856
  2857 				; ******************************************************************************
  2858
  2859 F410 A9 00		SETPPORTIN	LDA	#$00		; initialize port A as input
  2860 F412 8D 81 1A				STA	PADD
  2861 F415 A9 3E				LDA	#$3E		; initialize port B bits for read operation
  2862 F417 8D 83 1A				STA	PBDD
  2863 F41A A9 26				LDA	#$26		; set PB5 = H (READ)
  2864 F41C 8D 82 1A				STA	PBD
  2865 F41F 8D 85 1A				STA	WRDC		; set PA7 raising edge detection, no interrupt
  2866 F422 AD 85 1A				LDA	WRDC		; clear interrupt flag
  2867 F425 60					RTS
  2868
  2869 				; ******************************************************************************
  2870 				; SPI Driver
  2871 				; ******************************************************************************
  2872
  2873 				; ******************************************************************************
  2874 				; Initialize SPI Interface
  2875 				; ******************************************************************************
  2876
  2877 F426			SPI_INIT					;fall trough to SPI_SLOW
  2878
  2879 				; ******************************************************************************
  2880 				; Set SPI to Slow Mode (250KHz)
  2881 				; ******************************************************************************
  2882
  2883 F426 A9 04		SPI_SLOW        LDA	#$04
  2884 F428 A0 1B				LDY	#ACR
  2885 F42A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under T2 control"
  2886 F42C A9 00				LDA	#$00			; reset Timer2
  2887 F42E A0 18				LDY	#T2CL
  2888 F430 91 14				STA	(IOBASE),Y		; store timer low value
  2889 F432 20 61 F4				JSR	SPI_RESET		; flush shift register
  2890 F435 60					RTS				; Clock is set to 250 kHz
  2891 						
  2892 				; ******************************************************************************
  2893 				; Set SPI to Fast Mode (500KHz)
  2894 				; ******************************************************************************
  2895
  2896 F436 A9 08		SPI_FAST	LDA	#$08
  2897 F438 A0 1B				LDY	#ACR
  2898 F43A 91 14				STA	(IOBASE),Y		; set VIA mode "shift in under phi2 control"
  2899 F43C 60					RTS				; Clock is set to 500 kHz
  2900
  2901 				; ******************************************************************************
  2902 				; Write a Single Byte to the SPI Interface
  2903 				;
  2904 				; Input: A = Byte to Send
  2905 				; ******************************************************************************
  2906
  2907 F43D 84 FD		SPI_WRITE	STY	YSAV
  2908 F43F A0 11				LDY	#PORTA
  2909 F441 91 14				STA	(IOBASE),Y		; output data to shift register
  2910 F443 A0 1D				LDY	#IFR
  2911 F445 A9 04		SPI_WRITE1	LDA	#$04			; set bit mask for data available flag
  2912 F447 31 14				AND	(IOBASE),Y		; shift register full?
  2913 F449 F0 FA				BEQ	SPI_WRITE1		; no, check again
  2914 F44B A0 10				LDY	#PORTB
  2915 F44D A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  2916 F44F 91 14				STA	(IOBASE),Y		; load data into shift register
  2917 F451 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  2918 F453 91 14				STA	(IOBASE),Y		; data is now in shift register
  2919 F455 D0 0A				BNE	SPI_RESET               ; branch always
  2920
  2921 				; ******************************************************************************
  2922 				; Read a Single Byte from the SPI Interface
  2923 				;
  2924 				; Output: A = Received Byte
  2925 				; ******************************************************************************
  2926
  2927 F457 84 FD		SPI_READ	STY	YSAV
  2928 F459 A0 1D				LDY	#IFR
  2929 F45B A9 04		SPI_READ1	LDA	#$04			; set bit mask for data available flag
  2930 F45D 31 14				AND	(IOBASE),Y		; shift register full?
  2931 F45F F0 FA				BEQ	SPI_READ1		; no, check again
  2932 F461 A0 1A		SPI_RESET	LDY	#SR
  2933 F463 B1 14				LDA	(IOBASE),Y		; start next shifting, clear data available flag
  2934 F465 A4 FD				LDY	YSAV
  2935 F467 60					RTS
  2936
  2937 				; ******************************************************************************
  2938 				; SD-Card Driver Routines
  2939 				; ******************************************************************************
  2940
  2941 				; ******************************************************************************
  2942 				; Initialize SD-Card
  2943 				; Output: C = 1 Init OK, C = 0 Error
  2944 				; ******************************************************************************
  2945
  2946 F468 78			SD_INIT		SEI                             ; disable interrupts
  2947 F469 A9 00		                LDA	#$00
  2948 F46B 85 DB				STA	SD_TYPE
  2949 F46D 20 E1 F5				JSR	SD_RESET		; reset SD-Card
  2950 F470 C9 01				CMP	#$01			; SD-Card present?
  2951 F472 D0 57				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2952 F474 20 D0 F4				JSR	SD_GET_VERS		; get SD-Card version
  2953 F477 C9 05				CMP	#$05			; seems to be a version 1 card
  2954 F479 F0 08				BEQ	INIT_SD0		; so just try to initialize it
  2955 F47B C9 AA				CMP	#$AA			; version 2 cards should response with $(01)AA
  2956 F47D D0 4C				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2957 F47F A9 40				LDA	#$40			; try ACMD41($40000000) init (SD Ver. 2+)
  2958 F481 D0 02				BNE	INIT_SD1
  2959 F483 A9 00		INIT_SD0	LDA	#$00			; try ACMD41($00000000) init (SD Ver. 1)
  2960 F485 20 F3 F4		INIT_SD1	JSR	SD_CLEAR_CMD		; prepare for new command
  2961 F488 85 DF				STA	SD_PB3
  2962 F48A A9 77		INIT_SD2	LDA	#CMD55			; send prefix CMD55 (application cmd)
  2963 F48C 20 02 F5				JSR	SD_SEND_CMD
  2964 F48F C9 01				CMP	#$01
  2965 F491 D0 38				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2966 F493 A9 69				LDA	#ACMD41			; send ACMD41 (initialize)
  2967 F495 20 02 F5				JSR	SD_SEND_CMD
  2968 F498 F0 06				BEQ	INIT_SD3		; response = 0 means card waked up,
  2969 F49A C9 01				CMP	#$01			; card still idle?
  2970 F49C F0 EC				BEQ	INIT_SD2		; yes, try again
  2971 F49E D0 2B				BNE	SDC_NOT_FOUND		; no, invalid response, no usable card found
  2972 F4A0 A5 DF		INIT_SD3	LDA	SD_PB3			; Ver. 2+ Card?
  2973 F4A2 F0 13				BEQ	INIT_SD4		; no, just set block size
  2974 F4A4 20 F3 F4				JSR	SD_CLEAR_CMD		; prepare for new command
  2975 F4A7 A9 7A				LDA	#CMD58			; send CMD58 (get OCR)
  2976 F4A9 20 02 F5				JSR	SD_SEND_CMD
  2977 F4AC D0 1D				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2978 F4AE 20 E5 F4				JSR	SD_WAIT_RESP3		; wait for OCR response
  2979 F4B1 A5 DF				LDA	SD_PB3			; Test Bit 30
  2980 F4B3 29 40				AND	#$40			; 1 if SDHC/SDXC card, 0 else
  2981 F4B5 85 DB				STA	SD_TYPE			; set type $00 Byte mode, $40 LBA mode
  2982 F4B7 20 F3 F4		INIT_SD4	JSR	SD_CLEAR_CMD		; prepare for new command
  2983 F4BA A9 02				LDA	#$02			; set blocksize to 512 byte
  2984 F4BC 85 E1				STA	SD_PB1
  2985 F4BE A9 50				LDA	#CMD16			; send CMD16 (set block size)
  2986 F4C0 20 02 F5				JSR	SD_SEND_CMD
  2987 F4C3 D0 06				BNE	SDC_NOT_FOUND		; invalid response, no usable card found
  2988 F4C5 20 36 F4				JSR	SPI_FAST		; and switch to SPI fast mode (500kHz)
  2989 F4C8 58					CLI                             ; reenable interrupts
  2990 F4C9 38					SEC				; everything gone well, set carry
  2991 F4CA 60					RTS
  2992 F4CB A9 80		SDC_NOT_FOUND	LDA	#$80
  2993 F4CD 58			                CLI                             ; reenable interrupts
  2994 F4CE 18					CLC				; something went wrong, clear carry
  2995 F4CF 60					RTS				; to signal error
  2996
  2997 				; ******************************************************************************
  2998 				; Get SD-Card Version
  2999 				; ******************************************************************************
  3000
  3001 F4D0 A9 01		SD_GET_VERS	LDA	#$01			; set parameter byte 1
  3002 F4D2 85 E1				STA	SD_PB1
  3003 F4D4 A9 AA				LDA	#$AA			; set parameter byte 0
  3004 F4D6 85 E2				STA	SD_PB0
  3005 F4D8 A9 87				LDA	#$87			; set crc
  3006 F4DA 85 E3				STA	SD_CRC
  3007 F4DC A9 48				LDA	#CMD8			; send CMD8($000001AA) (get version)
  3008 F4DE 20 02 F5				JSR	SD_SEND_CMD		; response should be $01
  3009 F4E1 C9 01				CMP	#$01			; SD-Card present?
  3010 F4E3 D0 0D				BNE	END_GET_VERS		; no, exit with result <> $01
  3011 										; yes, fall through to sd_wait_resp
  3012
  3013 				; ******************************************************************************
  3014 				; Wait for a 32 Bit Command R3 Response from SD-Card
  3015 				; ******************************************************************************
  3016
  3017 F4E5 A0 00		SD_WAIT_RESP3	LDY	#$00
  3018 F4E7 20 13 F5		READ_RESP3	JSR	SD_WAIT_RESP		; yes, receive 4 response bytes
  3019 F4EA 99 DF 00				STA	SD_PB3,Y		; store response bytes in PB0..3
  3020 F4ED C8					INY
  3021 F4EE C0 04				CPY	#$04
  3022 F4F0 D0 F5				BNE	READ_RESP3
  3023 F4F2 60			END_GET_VERS	RTS
  3024
  3025 				; ******************************************************************************
  3026 				; Clear SD-Card Command Parameters
  3027 				; ******************************************************************************
  3028
  3029 F4F3 A9 00		SD_CLEAR_CMD	LDA	#$00
  3030 F4F5 A0 04				LDY	#$04			; 4 parameter bytes to clear
  3031 F4F7 99 DE 00		NEXT_PARAM	STA	SD_CMD,Y		; clear parameter byte
  3032 F4FA 88					DEY
  3033 F4FB D0 FA				BNE	NEXT_PARAM		; more to clear?
  3034 F4FD A9 FF				LDA	#$FF
  3035 F4FF 85 E3				STA	SD_CRC			; no, finally set CRC byte to $FF
  3036 F501 60					RTS
  3037
  3038 				; ******************************************************************************
  3039 				; Send Command to SD-Card
  3040 				; Input: A = Command Index
  3041 				; ******************************************************************************
  3042
  3043 F502 85 DE		SD_SEND_CMD	STA	SD_CMD
  3044 F504 20 57 F4				JSR	SPI_READ		; send one dummy
  3045 F507 A2 00				LDX	#$00
  3046 F509 B5 DE		SEND_BYTE	LDA	SD_CMD,X		; get one command byte
  3047 F50B 20 3D F4				JSR	SPI_WRITE		; and send it
  3048 F50E E8					INX
  3049 F50F E0 06				CPX	#$06			; all 6 cmd bytes send?
  3050 F511 D0 F6				BNE	SEND_BYTE		; no, send more bytes
  3051 										; yes, fall through to sd_wait_resp
  3052
  3053 				; ******************************************************************************
  3054 				; Wait for a 8 Bit Command R1 Response from SD-Card
  3055 				; Output: A = Response Byte
  3056 				; ******************************************************************************
  3057
  3058 F513 A2 08		SD_WAIT_RESP	LDX	#$08			; wait for max 8 cycles
  3059 F515 20 57 F4		READ_RESP1	JSR	SPI_READ		; receive data
  3060 F518 C9 FF				CMP	#$FF			; is it a $FF?
  3061 F51A D0 03				BNE	RESPONSE		; no, card did response
  3062 F51C CA					DEX				; yes, try again
  3063 F51D D0 F6				BNE	READ_RESP1		; check for timeout
  3064 F51F AA			RESPONSE	TAX
  3065 F520 8A					TXA				; set proper status flags for A
  3066 F521 60					RTS
  3067
  3068 				; ******************************************************************************
  3069 				; Wait for a Special Token Response from SD-Card
  3070 				; Input:  A = Token Byte
  3071 				; Output: A = Response Byte
  3072 				; ******************************************************************************
  3073
  3074 F522 85 FC		SD_WAIT_TOKEN	STA	TEMP			; store token into TEMP variable
  3075 F524 A0 FF				LDY	#$FF			; load low byte of time out counter
  3076 F526 A2 0A				LDX	#$0A			; load high byte of time out counter
  3077 F528 20 57 F4		WAIT_RESP	JSR	SPI_READ		; read byte from SPI
  3078 F52B 88					DEY				; decrement wait counter
  3079 F52C D0 03				BNE	WAIT_RESP0
  3080 F52E CA					DEX
  3081 F52F F0 04				BEQ	WAIT_RESP_END		; wait counter is 0 -> time out
  3082 F531 C5 FC		WAIT_RESP0	CMP	TEMP			; did we read the token we are waiting for?
  3083 F533 D0 F3				BNE	WAIT_RESP		; no, read next byte
  3084 F535 60			WAIT_RESP_END	RTS
  3085
  3086 				; ******************************************************************************
  3087 				; Read Single Data Block to Std. Block Buffer
  3088 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3089 				; Output: C = 0 Error, C = 1 Read OK
  3090 				;	  A = Error Code
  3091 				; ******************************************************************************
  3092
  3093 F536 20 8B F6		SD_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3094 F539 F0 06				BEQ	SD_RD_BLK
  3095
  3096 				; ******************************************************************************
  3097 				; Read Single Data Block from Logical Address to Std. Block Buffer
  3098 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3099 				; Output: C = 0 Error, C = 1 Data OK
  3100 				;	  A = Error Code
  3101 				; ******************************************************************************
  3102
  3103 F53B 20 8B F6		SD_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3104 										; fall through to sd_rd_lblk
  3105
  3106 				; ******************************************************************************
  3107 				; Read Single Data Block from Logical Address
  3108 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  3109 				;	  BLKBUF,BLKBUFH = 16 Bit Destination Address
  3110 				; Output: C = 0 Error, C = 1 Data OK
  3111 				;	  A = Error Code
  3112 				; ******************************************************************************
  3113
  3114 F53E 20 94 F6		SD_RD_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3115 										; fall through to sd_rd_blk
  3116
  3117 				; ******************************************************************************
  3118 				; Read Single Data Block
  3119 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Source Address
  3120 				;         BLKBUF,BLKBUFH = 16 Bit Destination Address
  3121 				; Output: C = 0 Error, C = 1 Read OK
  3122 				;	  A = Error Code
  3123 				; ******************************************************************************
  3124
  3125 F541 A9 51		SD_RD_BLK	LDA	#CMD17			; send CMD17 (blk read)
  3126 F543 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3127 F546 20 22 F5				JSR	SD_WAIT_TOKEN		; wait for data token $FE
  3128 F549 C9 FE				CMP	#$FE			; is card ready for block read?
  3129 F54B 18					CLC
  3130 F54C D0 1F				BNE	SD_RD_END		; did not receive data token, exit with C = 0
  3131 F54E A2 01				LDX	#$01			; initialize page counter
  3132 F550 A0 00				LDY	#$00			; initialize byte counter
  3133 F552 84 FD		SD_RD_BLK0	STY	YSAV			; read a byte
  3134 F554 A0 1A				LDY 	#SR
  3135 F556 B1 14				LDA	(IOBASE),Y
  3136 F558 A4 FD				LDY	YSAV
  3137 F55A 91 DC				STA	(BLKBUF),Y		; and store it into the block buffer
  3138 F55C C8					INY				; increment destination pointer
  3139 F55D D0 F3				BNE	SD_RD_BLK0		; pointer overflow? No, read next byte
  3140 F55F E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3141 F561 CA					DEX
  3142 F562 10 EE				BPL	SD_RD_BLK0		; two pages read? no, read next byte
  3143 F564 20 57 F4		SD_RD_BLK1	JSR	SPI_READ		; yes, read 3 more bytes (CRC H, CRC L, dummy)
  3144 F567 C8					INY
  3145 F568 C0 03				CPY	#$03			; all 3 bytes read?
  3146 F56A D0 F8				BNE	SD_RD_BLK1		; no, read next byte
  3147 F56C 38					SEC				; yes, all data read, set C = 1
  3148 F56D 60			SD_RD_END	RTS
  3149
  3150 				; ******************************************************************************
  3151 				; Write Single Data Block from Std. Block Buffer
  3152 				; Input:  SD_PB3..SD_PB0 = 32 Bit Command Block Destination Address
  3153 				; Output: C = 0 Error, C = 1 Read OK
  3154 				;	  A = Error Code
  3155 				; ******************************************************************************
  3156
  3157 F56E 20 8B F6		SD_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3158 F571 F0 06				BEQ	SD_WR_BLK
  3159
  3160 				; ******************************************************************************
  3161 				; Write Single Data Block from Std. Block Buffer to Logical Address
  3162 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3163 				; Output: C = 0 Error, C = 1 Data OK
  3164 				;	  A = Error Code
  3165 				; ******************************************************************************
  3166
  3167 F573 20 8B F6		SD_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  3168 										; fall through to sd_rd_lblk
  3169
  3170 				; ******************************************************************************
  3171 				; Write Single Data Block to Logical Address
  3172 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  3173 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3174 				; Output: C = 0 Error, C = 1 Data OK
  3175 				;	  A = Error Code
  3176 				; ******************************************************************************
  3177
  3178 F576 20 94 F6		SD_WR_LBLK	JSR	LOAD_LBA_SD		; convert LBA CMD ADR
  3179 										; fall through to sd_rd_blk
  3180
  3181 				; ******************************************************************************
  3182 				; Write Single Data Block
  3183 				; Input:  SD_PB3..SD_PB0 = 32 Bit CommandBlock Destination Address
  3184 				;	  BLKBUF,BLKBUFH = 16 Bit Source Address
  3185 				; Output: C = 0 Error, C = 1 Write OK
  3186 				;	  A = Error Code
  3187 				; ******************************************************************************
  3188
  3189 F579 A9 58		SD_WR_BLK	LDA	#CMD24			; send CMD24 (blk write)
  3190 F57B 20 C2 F5				JSR	SD_SEND_BLK_CMD
  3191 F57E 20 3D F4				JSR	SPI_WRITE		; write data token
  3192 F581 A2 01				LDX	#1			; initialize page counter
  3193 F583 86 FD				STX	YSAV
  3194 F585 CA					DEX				; initialize byte counter
  3195 F586 8A			SD_WR_BLK0	TXA
  3196 F587 A8					TAY
  3197 F588 B1 DC				LDA	(BLKBUF),Y		; read next byte from buffer
  3198 F58A A0 11				LDY	#PORTA			; and write it to the card
  3199 F58C 91 14				STA	(IOBASE),Y		; output data to shift register
  3200 F58E 88					DEY				; set for PORTB
  3201 F58F A9 42				LDA	#$42 			; SPI_CS = L; LOAD_DATA = 0
  3202 F591 91 14				STA	(IOBASE),Y		; load data into shift register
  3203 F593 A9 4A				LDA	#$4A 			; SPI_CS = L; LOAD_DATA = 1
  3204 F595 91 14				STA	(IOBASE),Y		; data is now in shift register
  3205 F597 A0 1A				LDY 	#SR
  3206 F599 B1 14				LDA	(IOBASE),Y		; and start clk'ing
  3207 F59B E8					INX				; increment source pointer
  3208 F59C D0 E8				BNE	SD_WR_BLK0		; pointer overflow? No, write next byte
  3209 F59E E6 DD				INC	BLKBUFH			; yes, increment block buffer page
  3210 F5A0 C6 FD				DEC	YSAV
  3211 F5A2 10 E2				BPL	SD_WR_BLK0		; two pages written? no, write next byte
  3212 F5A4 20 57 F4				JSR	SPI_READ		; yes, send a (dummy) CRC ($FFFF)
  3213 F5A7 20 57 F4				JSR	SPI_READ
  3214 F5AA 20 57 F4				JSR	SPI_READ		; read one dummy byte
  3215 F5AD 20 57 F4				JSR	SPI_READ		; read response byte
  3216 F5B0 48			                PHA                             ; and save it onto the stack
  3217 F5B1 20 57 F4		SD_WR_BUSY?	JSR	SPI_READ		; read next byte
  3218 F5B4 C9 00				CMP	#0
  3219 F5B6 F0 F9				BEQ	SD_WR_BUSY?		; check if busy ($00)
  3220 F5B8 68					PLA
  3221 F5B9 29 1F				AND	#$1F			; mask result bits
  3222 F5BB C9 05				CMP	#$05			; data accepted?
  3223 F5BD 18					CLC
  3224 F5BE D0 01				BNE	SD_WR_END		; no, exit with C = 0
  3225 F5C0 38					SEC				; yes, exit with C = 1
  3226 F5C1 60			SD_WR_END	RTS
  3227
  3228 				; ******************************************************************************
  3229 				; Send Block Read or Write Command
  3230 				; Input :  A = Command (CMD17,CMD24)
  3231 				; Output : A = Data Token
  3232 				; ******************************************************************************
  3233
  3234 F5C2 20 02 F5		SD_SEND_BLK_CMD	JSR	SD_SEND_CMD
  3235 F5C5 D0 03				BNE	SD_RESP_ERR		; response <> 0 check error type
  3236 F5C7 A9 FE				LDA	#DATA_TOKEN
  3237 F5C9 60					RTS
  3238
  3239 				; ******************************************************************************
  3240 				; Check Error
  3241 				; ******************************************************************************
  3242
  3243 F5CA 29 01		SD_RESP_ERR	AND	#$01			; is card in idle mode?
  3244 F5CC F0 0B				BEQ	SD_DISK_RW		; no, print error
  3245 F5CE 20 26 F4				JSR	SPI_SLOW		; set SPI slow mode
  3246 F5D1 20 68 F4				JSR	SD_INIT			; yes, maybe card changed, reset
  3247 F5D4 B0 07				BCS	SD_DISK_CHNG
  3248 F5D6 A9 80		SD_NO_DISK	LDA	#$80
  3249 F5D8 60					RTS
  3250 F5D9 A9 81		SD_DISK_RW	LDA	#$81
  3251 F5DB 18					CLC
  3252 F5DC 60					RTS
  3253 F5DD A9 82		SD_DISK_CHNG	LDA	#$82
  3254 F5DF 18					CLC
  3255 F5E0 60					RTS
  3256
  3257 				; ******************************************************************************
  3258 				; Reset SD-Card
  3259 				; ******************************************************************************
  3260
  3261 F5E1 20 F3 F4		SD_RESET	JSR	SD_CLEAR_CMD		; clear command parameters
  3262 F5E4 A9 95				LDA	#$95
  3263 F5E6 85 E3				STA	SD_CRC			; and set crc to $95 for CMD0
  3264 F5E8 20 FF F5				JSR	SD_PREPARE		; send dummy sequence to SD-Card
  3265 F5EB D0 0A				BNE	RESET_SDC		; is MISO line high?
  3266 F5ED A9 40				LDA	#CMD0			; no, send CMD0 (reset) to SD-Card
  3267 F5EF 20 02 F5				JSR	SD_SEND_CMD
  3268 F5F2 20 FF F5				JSR	SD_PREPARE		; send init dummy sequence again
  3269 F5F5 F0 05				BEQ	END_SD_RESET		; MISO still low? Exit with A = $FF
  3270 F5F7 A9 40		RESET_SDC	LDA	#CMD0			; send CMD0 (reset) to SD-Card
  3271 F5F9 4C 02 F5				JMP	SD_SEND_CMD		; response should be $01
  3272
  3273 F5FC A9 FF		END_SD_RESET	LDA	#$FF			; reset failed
  3274 F5FE 60					RTS
  3275
  3276 				; **** Prepare SD-Card for Communication ***************************************
  3277 				;
  3278 				; ******************************************************************************
  3279
  3280 F5FF 20 26 F4		SD_PREPARE	JSR	SPI_SLOW		; set SPI slow mode
  3281 F602 A0 10				LDY	#PORTB			; initialize VIA Port B
  3282 F604 A9 4E				LDA	#$4E			; set /SPI_CS = H and /SPI_LOAD = H
  3283 F606 91 14				STA	(IOBASE),Y
  3284 F608 A2 0A				LDX	#10			; first send 80 clocks to SD-Card
  3285 F60A 20 57 F4		SEND_CLOCK	JSR	SPI_READ		; send 8 clock cycles
  3286 F60D CA					DEX
  3287 F60E D0 FA				BNE	SEND_CLOCK		; send more clock cycles
  3288 F610 AA					TAX
  3289 F611 A0 1D				LDY	#IFR
  3290 F613 A9 04		SD_PREPARE1	LDA	#$04
  3291 F615 31 14				AND	(IOBASE),Y
  3292 F617 F0 FA				BEQ	SD_PREPARE1
  3293 F619 A0 10				LDY	#PORTB
  3294 F61B A9 4A				LDA	#$4A			; set /SPI_CS = L and /SPI_LOAD = H
  3295 F61D 91 14				STA	(IOBASE),Y
  3296 F61F 8A					TXA				; set proper status flags
  3297 F620 60			SD_END		RTS
  3298
  3299 				; **** SD-Card Boot Routine ****************************************************
  3300 				;
  3301 				; ******************************************************************************
  3302 F621 20 F3 F4		SD_BOOT         JSR	SD_CLEAR_CMD
  3303 F624 20 36 F5				JSR	SD_RD_BLK_BUF           ; read MBR
  3304 F627 90 F7		                BCC     SD_END                  ; error reading MBR. Exit
  3305
  3306 F629 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3307 F62C 90 F2				BCC	SD_END			; branch if error
  3308 						
  3309 F62E A0 45				LDY     #SDCDEV-STRINGP2        ; load pointer to device name
  3310 F630 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3311 					
  3312 				;----------------------------------------------------------------------------------		
  3313 				; This routine is the same for both the CF and SD cards. It does the following:
  3314 				; - Load the MBR (sector 0) and does check for $55 $AA and $65 $02
  3315 				; - It runs the boot-menu routine in the MBR
  3316 				; - It loads the begin-LBA of the selected partition
  3317 				; - It loads the Volume ID (first sector) of the partition
  3318 				; Exit: C=0: Error, C=1: OK
  3319 				;----------------------------------------------------------------------------------		
  3320 F633 20 EE F6		LOAD_RUN_PART   JSR     SYS_MBR_ID              ; check boot block ID tag
  3321 F636 90 E8		                BCC     SD_END                  ; error, wrong ID. Exit
  3322 F638 AD BC 07		                LDA     PART0-2                 ; check if partition ID1 is $65
  3323 F63B C9 65		                CMP     #$65
  3324 F63D D0 20		                BNE     LOAD_PART0              ; no, just load partition 0
  3325 F63F AD BD 07		                LDA     PART0-1                 ; check if partition ID2 is $02
  3326 F642 C9 02		                CMP     #$02
  3327 F644 D0 19		                BNE     LOAD_PART0              ; no, just load partition 0
  3328 F646 20 00 06		                JSR     MBR                     ; partition ID $65 $02 found. Call MBR code
  3329 F649 D0 02		                BNE     LOAD_PART1              ; is boot menu result 1,2,3, or 4 ?
  3330 F64B 18			                CLC                             ; no, ESC pressed or no valid partition found
  3331 F64C 60			LRP_END         RTS                             ; abort booting from SD-Card
  3332
  3333 F64D CA			LOAD_PART1      DEX                             ; set result to 0,1,2 or 3
  3334 F64E 8A			                TXA                             ; transfer result to Accu
  3335 F64F A8			                TAY                             ; and to Y-Register
  3336 F650 0A			                ASL                            ; multiply result by 16
  3337 F651 0A			                ASL     
  3338 F652 0A			                ASL     
  3339 F653 0A			                ASL     
  3340 F654 09 08		                ORA     #$08                    ; and add 8
  3341 F656 AA			                TAX                             ; move partition table index into X
  3342 F657 98			                TYA
  3343 F658 18			                CLC
  3344 F659 69 31		                ADC     #49                     ; convert partition number to ASCII char (+1)
  3345 F65B 85 EE		                STA     PSAV                    ; and store it to PSAV
  3346 F65D D0 0B		                BNE     LOAD_PART               ; branch always
  3347 F65F A2 08		LOAD_PART0      LDX     #$08                    ; for partition 0 the table index is 8
  3348 F661 A9 31		                LDA     #'1'                    ; partition 0 number as ASCII char (+1)
  3349 F663 85 EE		                STA     PSAV                    ; store it in PSAV
  3350 F665 AD BE 07		                LDA     PART0                   ; read boot indicator
  3351 F668 F0 75		                BEQ     SYS_MSG_ERR             ; if $00 then exit
  3352 F66A A0 08		LOAD_PART       LDY     #$08
  3353 F66C BD C6 07		SD_BOOT1        LDA     PART0_RS,X              ; load partition start and length
  3354 F66F 99 00 04		                STA     BOOT_PART,Y           	; and save it to boot device descriptor
  3355 F672 CA			                DEX
  3356 F673 88			                DEY
  3357 F674 10 F6		                BPL     SD_BOOT1
  3358 F676 A2 00		                LDX	#< BOOT_PART          	; read partition boot blk ptr
  3359 F678 A0 04				LDY	#> BOOT_PART
  3360 F67A 20 E7 F6				JSR     SYS_LD_BOOTBLK          ; load partition boot block
  3361 F67D 90 CD		                BCC     LRP_END                 ; block not found. Exit
  3362 F67F 4C 00 F7		                JMP     SYS_CHECK_OS            ; check OS OEM string C=0: wrong OEM string. And return
  3363 						
  3364 				;----------------------------------------------------------------------------
  3365 				; This routine prints a string to the terminal: A=LSB, Y=MSB
  3366 				;----------------------------------------------------------------------------
  3367 F682 86 CA		SPRINT		STX 	PRSTR	    	; LSB of text-pointer
  3368 F684 84 CB				STY 	PRSTR+1	    	; MSB of text-pointer
  3369 F686 20 4D FE				JSR 	SPROUT	    	; BIOS print string routine
  3370 F689 60					RTS
  3371 F68A EA					NOP			; maintain v1.1.4 compatibility
  3372 						
  3373 				; ******************************************************************************
  3374 				; Initialize Block Buffer Pointer, it must return with A = 0.
  3375 				; ******************************************************************************
  3376
  3377 F68B A9 06		INIT_BLKBUF	LDA	#> BLOCK_BUF         ; set pointer to standard block buffer
  3378 F68D 85 DD				STA	BLKBUFH
  3379 F68F A9 00				LDA	#$00
  3380 F691 85 DC				STA	BLKBUF
  3381 F693 60					RTS
  3382
  3383 				; ******************************************************************************
  3384 				; Load Logical Block Address into SD-card Command Address.
  3385 				; Swap Endian and Shift Bits if Desired
  3386 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
  3387 				; Output: ADR in SD_PB3..SD_PB0
  3388 				; ******************************************************************************
  3389
  3390 F694 86 E6		LOAD_LBA_SD	STX	PLBAL
  3391 F696 84 E7				STY	PLBAH
  3392 F698 A2 04				LDX	#$04
  3393 F69A A0 00				LDY	#$00
  3394 F69C A5 DB				LDA	SD_TYPE
  3395 F69E D0 0F				BNE	BLK_MODE
  3396 F6A0 18					CLC
  3397 F6A1 98					TYA
  3398 F6A2 95 DE		                STA	SD_CMD,X
  3399 F6A4 CA					DEX
  3400 F6A5 B1 E6		BIT_MODE	LDA	(PLBA),Y
  3401 F6A7 2A					ROL	
  3402 F6A8 95 DE		                STA	SD_CMD,X
  3403 F6AA C8					INY
  3404 F6AB CA					DEX
  3405 F6AC D0 F7				BNE	BIT_MODE
  3406 F6AE 60					RTS
  3407 F6AF B1 E6		BLK_MODE	LDA	(PLBA),Y
  3408 F6B1 95 DE				STA	SD_CMD,X
  3409 F6B3 C8					INY
  3410 F6B4 CA					DEX
  3411 F6B5 D0 F8				BNE	BLK_MODE
  3412 F6B7 60					RTS
  3413
  3414 				; ******************************************************************************
  3415 				; Boot Routines
  3416 				; ******************************************************************************
  3417
  3418 				; **** Main Boot Routine *******************************************************
  3419 				;
  3420 				; Find first bootable device
  3421 				; Output : C = 0 No Boot Device Found
  3422 				;          C = 1 Boot Device Found. Boot Code at $0600 Available
  3423 				;
  3424 				; ******************************************************************************
  3425
  3426 F6B8 A0 20		SYS_BOOT        LDY     #STORAGE_DEV            ; boot from storage device only
  3427 F6BA 84 F4		SYS_BOOT1       STY     YREG
  3428 F6BC 98			                TYA
  3429 F6BD 20 BE F7		                JSR     DEV_OPEN                ; open device descriptor
  3430 F6C0 90 0E		                BCC     SYS_BOOT2               ; device not found, try next one
  3431 F6C2 A9 00		                LDA     #CMD_INIT
  3432 F6C4 20 BA E0		                JSR     CMDDEV                  ; initialize device
  3433 F6C7 90 07		                BCC     SYS_BOOT2               ; could not initialize, try next one
  3434 F6C9 A9 24		                LDA     #CMD_BOOT
  3435 F6CB 20 BA E0		                JSR     CMDDEV                  ; can we boot from device?
  3436 F6CE B0 11		                BCS     SYS_BOOT_END            ; yes, exit
  3437 F6D0 A4 F4		SYS_BOOT2       LDY     YREG                    ; no, try next device
  3438 F6D2 C8			                INY
  3439 F6D3 C0 2F		                CPY     #$2F                    ; all devices checked?
  3440 F6D5 D0 E3		                BNE     SYS_BOOT1               ; no, try next one
  3441 F6D7 A0 30		                LDY     #NOBOOTDEV-STRINGP2     ; yes, no boot device found
  3442
  3443 				; ***** Show System Message ****************************************************
  3444 				;
  3445 				; Input:  Y - Index To Message String
  3446 				; Output: C = 0
  3447 				;
  3448 				; ******************************************************************************
  3449
  3450 F6D9 20 4C E5		SYS_MSG         JSR     LOADSTRING2
  3451 F6DC 20 85 E0		                JSR  	WRSTR                   ; show error message
  3452 F6DF 18			SYS_MSG_ERR     CLC
  3453 F6E0 60			SYS_MSG_END     RTS
  3454
  3455 				; ***** Finalize Boot Procedure ************************************************
  3456
  3457 F6E1 A9 B0		SYS_BOOT_END    LDA     #$B0                    ; boot block could be loaded
  3458 F6E3 8D 00 06		                STA     $0600                   ; modify jump opcode in boot block into BCS
  3459 F6E6 60			                RTS
  3460
  3461 				; ***** Load Boot Block From Device ********************************************
  3462 				;
  3463 				; Input:  X - Pointer to Boot Block Low Address
  3464 				;         Y - Pointer to Boot Block High Address
  3465 				; Output: C = 0 No Boot Block Found
  3466 				;         C = 1 Boot Block Loaded at $0600
  3467 				;
  3468 				; ******************************************************************************
  3469
  3470 F6E7 A9 25		SYS_LD_BOOTBLK  LDA     #CMD_READ_BUF
  3471 F6E9 20 BA E0		                JSR     CMDDEV                   ; load master boot block
  3472 F6EC 90 10		                BCC     SYS_TAG_ERR
  3473
  3474 				; ***** Check Boot Block ID Tag ($55 $AA) **************************************
  3475 				;
  3476 				; Output: C = 0 No Boot Block Tag Found
  3477 				;         C = 1 Boot Block Tag Found
  3478 				;
  3479 				; ******************************************************************************
  3480
  3481 F6EE AD FE 07		SYS_MBR_ID      LDA     BOOTBLK_TAG             ; check boot block ID tag
  3482 F6F1 C9 55		                CMP     #$55
  3483 F6F3 D0 09		                BNE     SYS_TAG_ERR
  3484 F6F5 AD FF 07		                LDA     BOOTBLK_TAG+1
  3485 F6F8 C9 AA		                CMP     #$AA
  3486 F6FA D0 02		                BNE     SYS_TAG_ERR
  3487 F6FC 38			                SEC
  3488 F6FD 60			                RTS
  3489 F6FE 18			SYS_TAG_ERR     CLC
  3490 F6FF 60			                RTS
  3491
  3492 				; ***** Check OS OEM String ****************************************************
  3493 				;
  3494 				; Output: C = 0 OS OEM String Not Found
  3495 				;         C = 1 OS OEM String Found
  3496 				;
  3497 				; ******************************************************************************
  3498
  3499 F700 A2 04		SYS_CHECK_OS    LDX     #04                     ; check four characters of OEM string
  3500 F702 BD 7D E8		SYS_ID_LOOP     LDA     OSID-1,X
  3501 F705 DD 02 06		                CMP     BLOCK_BUF+2,X
  3502 F708 18			                CLC
  3503 F709 D0 09		                BNE     SYS_CHECK_END           ; wrong OEM string
  3504 F70B CA			                DEX
  3505 F70C D0 F4		                BNE     SYS_ID_LOOP             ; more charactrs to check
  3506 F70E A0 20		                LDY     #BOOTDEV-STRINGP2
  3507 F710 20 D9 F6		SYS_BOOTMSG     JSR     SYS_MSG                 ; write boot message
  3508 F713 38			                SEC
  3509 F714 60			SYS_CHECK_END   RTS
  3510
  3511 				; ******************************************************************************
  3512 				; Miscellanious Routines
  3513 				; ******************************************************************************
  3514
  3515 				; **** Read Joystick Port ******************************************************
  3516
  3517 				; Output: A - button state (Bit 0 = Button 1, Bit 1 = Button 2, Bit 2 = Button 3)
  3518 				;         X - vertical joystick position 0 = Center, -1 ($FF) = Left, 1 = Right
  3519 				;         Y - horizontal joystick position 0 = Center, -1 ($FF) = Up, 1 = Down
  3520
  3521 				; ******************************************************************************
  3522
  3523 F715 A5 17		READ_JOY_PORT   LDA     FGCBASEH
  3524 F717 F0 47		                BEQ     NO_JOY_PORT             ; check if Floppy-/Graphisc-Controller installed
  3525 F719 A0 0D		                LDY     #PIA_PORTB
  3526 F71B B1 16		                LDA     (FGCBASE),Y             ; yes, read joystick port
  3527 F71D A2 00		DECODE_JOY_PORT LDX     #$00                    ; preset x position to CENTER
  3528 F71F A0 00		                LDY     #$00                    ; preset y position to CENTER
  3529 F721 86 FC		                STX     TEMP                    ; clear temp value
  3530 F723 4A			JP_UP           LSR                             ; get /UP flag
  3531 F724 B0 06		                BCS     JP_DOWN                 ; not set, check DOWN position
  3532 F726 A0 FF		                LDY     #$FF                    ; set y position to -1 (UP)
  3533 F728 4A			                LSR                             ; skip DOWN bit
  3534 F729 4C 31 F7		                JMP     JP_LEFT                 ; and test x position
  3535 F72C 4A			JP_DOWN         LSR                             ; get /DOWN flag
  3536 F72D B0 02		                BCS     JP_LEFT                 ; not set, test x position
  3537 F72F A0 01		                LDY     #$01                    ; set y position to 1 (DOWN)
  3538 F731 4A			JP_LEFT         LSR                             ; get /LEFT flag
  3539 F732 B0 06		                BCS     JP_RIGHT                ; not set, check RIGHT position
  3540 F734 A2 FF		                LDX     #$FF                    ; set x position to -1 (UP)
  3541 F736 4A			                LSR                             ; skip RIGHT bit
  3542 F737 4C 3F F7		                JMP     JP_BUTTON3              ; and test button 3
  3543 F73A 4A			JP_RIGHT        LSR                             ; get /RIGHT flag
  3544 F73B B0 02		                BCS     JP_BUTTON3              ; not set, test button 3
  3545 F73D A2 01		                LDX     #$01                    ; set x position to 1 (RIGHT)
  3546 F73F 4A			JP_BUTTON3      LSR                             ; get /BUTTON3 flag
  3547 F740 B0 06		                BCS     JP_BUTTON1              ; not set, test button 1
  3548 F742 48			                PHA                             ; save joystick port value
  3549 F743 A9 04		                LDA     #$04
  3550 F745 85 FC		                STA     TEMP                    ; set bit 2 of temp button result
  3551 F747 68			                PLA                             ; restore joystick port value
  3552 F748 4A			JP_BUTTON1      LSR                             ; get /BUTTON1 flag
  3553 F749 B0 08		                BCS     JP_BUTTON2              ; not set, test button 2
  3554 F74B 48			                PHA                             ; save joystick port value
  3555 F74C A9 01		                LDA     #$01
  3556 F74E 05 FC		                ORA     TEMP
  3557 F750 85 FC		                STA     TEMP                    ; set bit 0 of temp button result
  3558 F752 68			                PLA                             ; restore joystick port value
  3559 F753 4A			JP_BUTTON2      LSR                             ; get /BUTTON2 flag
  3560 F754 B0 06		                BCS     END_JOY_PORT            ; not set, exit
  3561 F756 A9 02		                LDA     #$02
  3562 F758 05 FC		                ORA     TEMP
  3563 F75A 85 FC		                STA     TEMP                    ; set bit 1 of temp button result
  3564 F75C A5 FC		END_JOY_PORT    LDA     TEMP                    ; load temp button result into A
  3565 F75E 38			                SEC                             ; data valid
  3566 F75F 60			                RTS
  3567 F760 AA			NO_JOY_PORT     TAX                             ; no joystick port available, clear X
  3568 F761 A8			                TAY                             ; and Y
  3569 F762 18			                CLC                             ; no joystick port available, data invalid
  3570 F763 60			                RTS
  3571
  3572 				; ******************************************************************************
  3573 				; Device Driver Routines
  3574 				; ******************************************************************************
  3575
  3576 				; **** Initialize Device Driver List *******************************************
  3577 				;
  3578 				; ******************************************************************************
  3579
  3580 F764 A0 3E		DEV_INIT	LDY	#$3E                    ; clear entire list
  3581 F766 A9 00		                LDA     #$00                    ; and fill it with zeros
  3582 F768 99 28 1A		DEV_INIT1       STA     DEVLIST,Y
  3583 F76B 88			                DEY
  3584 F76C 10 FA				BPL	DEV_INIT1
  3585 F76E 60			END_DEV_INIT	RTS
  3586
  3587 				; **** Add Device Driver *******************************************************
  3588 				;
  3589 				; Input  - X : Driver Descriptor Address Low Byte
  3590 				;          Y : Driver Descriptor Address High Byte
  3591 				; Output - C = 1 Success, C = 0 Error
  3592 				;          A = Device ID (0F = Too Many Devices, FF = Unknown Device Type)
  3593 				;
  3594 				; ******************************************************************************
  3595 F76F 86 DE		DEV_ADD		STX	PDEVL			; LSB of device driver descriptor
  3596 F771 84 DF				STY	PDEVH			; MSB of device driver descriptor
  3597 F773 A0 00				LDY	#$00
  3598 F775 B1 DE				LDA	(PDEV),Y                ; load device ID into A
  3599 F777 85 FC				STA     TEMP			; TEMP = Device ID
  3600 F779 20 B2 F7		                JSR     DEV_CHECK		; Check device ID
  3601 F77C 90 2F		                BCC     END_DEV_ADD		; Exit if device ID error
  3602 						
  3603 F77E 4A			                LSR     			; A = Device ID again
  3604 F77F 29 0F		                AND     #$0F			; Get ID-nr from Device ID
  3605 F781 C9 0F		                CMP     #$0F			; Device 15 ?
  3606 F783 D0 14		                BNE     ADD_DEV			; branch if not full yet
  3607 						
  3608 F785 98			FIND_FREE_DEV   TYA				; A now contains 2 * Device ID = $5E			
  3609 F786 29 E0		                AND     #$E0			; A = $50
  3610 F788 A8			                TAY				; Y = $50
  3611 F789 A2 00		                LDX     #$00			; init. X
  3612 F78B B9 08 1A		FIND_NEXT_DEV   LDA     DEVLIST-$20,Y		; Check if Device List entry is empty
  3613 F78E F0 0A		                BEQ     ADD_DEV1		; branch if it is empty
  3614 						
  3615 F790 C8			                INY				; Next entry in Device List
  3616 F791 C8			                INY
  3617 F792 E8			                INX				; Next device
  3618 F793 E0 0F		                CPX     #$0F			; 15 device entries checked?
  3619 F795 90 F4		                BCC     FIND_NEXT_DEV		; branch if not at end of list yet
  3620 						
  3621 F797 18			                CLC				; error
  3622 F798 60			                RTS				; return
  3623 						
  3624 F799 AA			ADD_DEV         TAX				; X = nr. of Device ID
  3625 F79A A5 DE		ADD_DEV1        LDA     PDEVL			; LSB of device driver descriptor
  3626 F79C 99 08 1A		                STA     DEVLIST-$20,Y		; Start of device driver list in RIOT memory
  3627 F79F A5 DF		                LDA     PDEVH			; MSB of device driver descriptor
  3628 F7A1 99 09 1A		                STA     DEVLIST-$1F,Y		;
  3629 F7A4 A5 FC		                LDA     TEMP			; Get Device ID back
  3630 F7A6 29 F0		                AND     #$F0			; A = $20
  3631 F7A8 86 FC		                STX     TEMP			; Temp = nr. of Device ID
  3632 F7AA 05 FC		                ORA     TEMP			; Original Device ID again
  3633 F7AC 38			                SEC				; No error
  3634 F7AD 60			END_DEV_ADD     RTS				; Return
  3635
  3636 F7AE A2 FF		DEV_ERR         LDX     #$FF			; Error, unknown Device Type
  3637 F7B0 18			                CLC
  3638 F7B1 60			               	RTS
  3639
  3640 				;----------------------------------------------------------------------
  3641 				; This functions checks if the Device ID is correct
  3642 				;----------------------------------------------------------------------
  3643 F7B2 C9 30		DEV_CHECK       CMP     #STORAGE_DEV+$10	; Not too many devices?
  3644 F7B4 B0 F8				BCS     DEV_ERR			; branch if so
  3645 						
  3646 F7B6 C9 10				CMP     #COM_DEV		; Device ID too small?
  3647 F7B8 90 F4		                BCC     DEV_ERR			; branch if so
  3648 						
  3649 F7BA 0A			                ASL     			; Why?
  3650 F7BB A8			                TAY				; y = ID * 2
  3651 F7BC 38			                SEC				; No error
  3652 F7BD 60			                RTS				; return
  3653
  3654 				; **** Open Device Driver ******************************************************
  3655 				;
  3656 				; Input  - A : Device ID
  3657 				; Output - C = 1 Success, C = 0 Error
  3658 				;          X : Descriptor Address Low Byte
  3659 				;          Y : Descriptor Address High Byte
  3660 				;
  3661 				; ******************************************************************************
  3662 F7BE 20 B2 F7		DEV_OPEN        JSR     DEV_CHECK		; Check Device ID
  3663 F7C1 90 26		                BCC     END_DEV_OPEN		; exit if ID error
  3664 						
  3665 F7C3 B9 08 1A		                LDA     DEVLIST-$20,Y		; DEVLIST = $1A28, Y=2*Device ID, $1A48 ???
  3666 F7C6 D0 02		                BNE     DEV_OPEN1		
  3667 						
  3668 F7C8 A9 80		                LDA	#< NULL_DEV   		; no device found use NULL device
  3669 F7CA 85 DE		DEV_OPEN1       STA     PDEVL
  3670 F7CC B9 09 1A		                LDA     DEVLIST-$1F,Y		; Get MSB
  3671 F7CF D0 02		                BNE     DEV_OPEN2
  3672 						
  3673 F7D1 A9 F9		                LDA	#> NULL_DEV  		; no device found use NULL device
  3674 F7D3 85 DF		DEV_OPEN2       STA     PDEVH
  3675 F7D5 A0 02				LDY	#$02
  3676 F7D7 A2 00				LDX	#$00
  3677 F7D9 B1 DE		DEV_OPEN3	LDA	(PDEV),Y		; Start Input vector LSB
  3678 F7DB 9D 68 1A				STA	DEVIN,X			
  3679 F7DE C8					INY
  3680 F7DF E8					INX
  3681 F7E0 E0 06				CPX	#$06			; Copy Input, Output & Command vector
  3682 F7E2 D0 F5				BNE	DEV_OPEN3		; branch if not done yet
  3683 						
  3684 F7E4 A6 DE				LDX	PDEVL			; X = LSB of Descriptor Address
  3685 F7E6 A4 DF				LDY	PDEVH			; Y = MSB of Descriptor Address
  3686 F7E8 38					SEC				; No error
  3687 F7E9 60			END_DEV_OPEN    RTS				; Return
  3688
  3689 				; ******************************************************************************
  3690 				; Standard Driver Command Routines
  3691 				; ******************************************************************************
  3692
  3693 				; ******************************************************************************
  3694 				; XModem Command Interpreter
  3695 				; ******************************************************************************
  3696
  3697 F7EA C9 20		XMODEM_CMD	CMP	#CMD_LOAD
  3698 F7EC D0 03				BNE	XM_SAVE
  3699 F7EE 4C 15 F0				JMP	XModemRcv
  3700 F7F1 C9 21		XM_SAVE  	CMP	#CMD_SAVE
  3701 F7F3 D0 45				BNE     COM_CMD
  3702 F7F5 4C 06 F1				JMP	XModemSnd
  3703
  3704 				; ******************************************************************************
  3705 				; Tape Device Command Interpreter (14 bytes, removed 24-07-25 Emile)
  3706 				; ******************************************************************************
  3707
  3708 F7F8					ORG	$F806		; maintain compatibilitywith v1.1.4
  3709 				; ******************************************************************************
  3710 				; XSD_Card Command Interpreter
  3711 				; ******************************************************************************
  3712
  3713 F806 C9 00		SDC_CMD         CMP     #CMD_INIT
  3714 F808 D0 03		                BNE     SDC_READ
  3715 F80A 4C 68 F4		                JMP     SD_INIT
  3716 F80D C9 22		SDC_READ        CMP     #CMD_READ
  3717 F80F D0 03		                BNE     SDC_WRITE
  3718 F811 4C 3E F5		                JMP     SD_RD_LBLK
  3719 F814 C9 23		SDC_WRITE       CMP     #CMD_WRITE
  3720 F816 D0 03		                BNE     SDC_RD_BUF
  3721 F818 4C 76 F5		                JMP     SD_WR_LBLK
  3722 F81B C9 25		SDC_RD_BUF      CMP     #CMD_READ_BUF
  3723 F81D D0 03		                BNE     SDC_WR_BUF
  3724 F81F 4C 3B F5		                JMP     SD_RD_LBLK_BUF
  3725 F822 C9 26		SDC_WR_BUF      CMP     #CMD_WRITE_BUF
  3726 F824 D0 03		                BNE     SDC_SETADR
  3727 F826 4C 73 F5		                JMP     SD_WR_LBLK_BUF
  3728 F829 C9 10		SDC_SETADR      CMP     #CMD_SETSTARTADR
  3729 F82B D0 06		                BNE     SDC_BOOT
  3730 F82D 86 DC		                STX     BLKBUFL
  3731 F82F 84 DD		                STY     BLKBUFH
  3732 F831 38			                SEC
  3733 F832 60			                RTS
  3734 F833 C9 24		SDC_BOOT        CMP     #CMD_BOOT
  3735 F835 D0 17		                BNE     _EMPTY_
  3736 F837 4C 21 F6		                JMP     SD_BOOT
  3737
  3738 				; ******************************************************************************
  3739 				; Common Command Interpreter
  3740 				; ******************************************************************************
  3741
  3742 F83A C9 10		COM_CMD	        CMP	#CMD_SETSTARTADR
  3743 F83C D0 06				BNE     COM_SETENDADR
  3744 F83E 86 FA				STX	ADRL
  3745 F840 84 FB				STY	ADRH
  3746 F842 38					SEC
  3747 F843 60					RTS
  3748 F844 C9 11		COM_SETENDADR	CMP	#CMD_SETENDADR
  3749 F846 D0 06		                BNE     _EMPTY_
  3750 F848 86 F8				STX	NUML
  3751 F84A 84 F9				STY	NUMH
  3752 F84C 38					SEC
  3753 F84D 60					RTS
  3754
  3755 				; EMPTY Command Handler ********************************************************
  3756 F84E 18			_EMPTY_         CLC
  3757 F84F 60			_HANDLER_       RTS
  3758
  3759 				; Command Handler For Floppy Drive 2 *******************************************
  3760 F850 09 80		FGC_FDC_CMD2    ORA     #$80            ; set bit 7 of command byte (drive 2 operation)
  3761 F852 4C 17 10		                JMP     FGC_FDC_CMD     ; call command handler
  3762
  3763 				;----------------------------------------------------------------------------
  3764 				; This routine contains the entry routines for the CF-card routines
  3765 				;----------------------------------------------------------------------------
  3766 F855 C9 00		CFC_CMD         CMP     #CMD_INIT
  3767 F857 D0 03		                BNE     CFC_READ
  3768 F859 4C 8D F8		                JMP     CF_INIT		; Init. CF-card with HW-reset
  3769 F85C C9 22		CFC_READ        CMP     #CMD_READ
  3770 F85E D0 03		                BNE     CFC_WRITE
  3771 F860 4C BF FC		                JMP     CF_RD_LBLK	; used a lot in boot.sys and mkboot.sys
  3772 F863 C9 23		CFC_WRITE       CMP     #CMD_WRITE
  3773 F865 D0 03		                BNE     CFC_RD_BUF
  3774 F867 4C F6 FC		                JMP     CF_WR_LBLK
  3775 F86A C9 25		CFC_RD_BUF      CMP     #CMD_READ_BUF
  3776 F86C D0 03		                BNE     CFC_WR_BUF
  3777 F86E 4C BC FC		                JMP     CF_RD_LBLK_BUF
  3778 F871 C9 26		CFC_WR_BUF      CMP     #CMD_WRITE_BUF
  3779 F873 D0 03		                BNE     CFC_LOAD
  3780 F875 4C F3 FC		                JMP     CF_WR_LBLK_BUF
  3781 F878 C9 20		CFC_LOAD	CMP	#CMD_LOAD
  3782 F87A D0 03				BNE	CFC_SAVE
  3783 F87C 6C 06 18				JMP	(CF_LOAD_VEC)	; Filled in by boot.sys
  3784 F87F C9 21		CFC_SAVE	CMP	#CMD_SAVE
  3785 F881 D0 03				BNE	CFC_BOOT
  3786 F883 6C 08 18				JMP	(CF_SAVE_VEC)	; Filled in by boot.sys
  3787 F886 C9 24		CFC_BOOT        CMP     #CMD_BOOT
  3788 F888 D0 C4		                BNE     _EMPTY_
  3789 F88A 4C 04 F9		                JMP     CF_BOOT
  3790
  3791 				; ******************************************************************************
  3792 				; CF-Card Driver Routines
  3793 				; ******************************************************************************
  3794 				;----------------------------------------------------------------------------
  3795 				; Command: CMD_INIT, Initialize CF-Card
  3796 				; Output : C = 1 Init OK, C = 0 Error
  3797 				;----------------------------------------------------------------------------
  3798 F88D A9 00		CF_INIT		LDA #$00		; Reset command
  3799 F88F 8D 88 0C		                STA CFREG8		; HW reset command
  3800 F892 A9 01				LDA #1
  3801 F894 85 D7				STA RSTACT		; 1 = Reset pending
  3802 F896 20 B5 F8				JSR CFWAIT
  3803 F899 B0 03				BCS INITOK		; branch if CF-card init OK
  3804 						
  3805 F89B A9 80		CF_ERR		LDA #$80
  3806 F89D 60					RTS			; return if error (C=0)
  3807 						
  3808 F89E A9 E0		INITOK		LDA #$E0		; LBA3=0, Master, Mode=LBA
  3809 F8A0 8D 86 0C				STA CFREG6
  3810 F8A3 A9 01				LDA #$01		; 8-bit transfers
  3811 F8A5 8D 81 0C				STA CFREG1
  3812 F8A8 A9 EF				LDA #$EF		; Set feature command
  3813 F8AA 8D 87 0C				STA CFREG7		; CF command register
  3814 F8AD 20 B5 F8				JSR CFWAIT		; Wait and return
  3815 F8B0 90 E9				BCC CF_ERR		; branch if Error
  3816 						
  3817 F8B2 4C 00 FC				JMP CF_INFO		; Print CF-Card Info, returns with C=1 (OK)
  3818
  3819 				;----------------------------------------------------------------------------
  3820 				; This routine waits until the CF-card is ready.
  3821 				;----------------------------------------------------------------------------
  3822 F8B5 A9 00		CFWAIT		LDA #0
  3823 F8B7 85 D6				STA MSEC		; msec counter
  3824 F8B9 A5 D7		CFWLP		LDA RSTACT		; 1 = Reset pending
  3825 F8BB F0 05				BEQ NO_DLY10		; branch if no 10 msec. delay needed
  3826 						
  3827 F8BD A9 0A				LDA #10			; delay = 10 msec.
  3828 F8BF 20 4D E1				JSR DELAY		; delay 10 msec.
  3829 F8C2 E6 D6		NO_DLY10	INC MSEC		; msec-counter
  3830 F8C4 A5 D6				LDA MSEC
  3831 F8C6 F0 2D				BEQ CFWLPTO		; branch after 2550 msec. and no reset
  3832 						
  3833 F8C8 AD 87 0C				LDA CFREG7		; read status register
  3834 F8CB 29 80				AND #$80		; check busy flag
  3835 F8CD D0 EA				BNE CFWLP		; branch if BSY flag is still set
  3836 						
  3837 						; Busy flag cleared
  3838 F8CF AD 87 0C				LDA CFREG7		; read status register
  3839 F8D2 29 50				AND #$50		; check for RDY and DSC flags
  3840 F8D4 C9 50				CMP #$50		; BSY and DSC flags both set?
  3841 F8D6 D0 E1				BNE CFWLP		; branch if RDY and DSC not both set
  3842
  3843 F8D8 A5 D7				LDA RSTACT		; 1 = Reset pending
  3844 F8DA F0 17				BEQ PRENDOK		; branch if no Reset pending
  3845 						
  3846 F8DC A9 00				LDA #0
  3847 F8DE 85 D7				STA RSTACT		; Reset no longer pending
  3848 F8E0 A2 32				LDX #<TXT_RSTOK     	; Print Reset OK + msec
  3849 F8E2 A0 F9				LDY #>TXT_RSTOK
  3850 F8E4 20 82 F6				JSR SPRINT	    	; print
  3851 F8E7 A5 D6				LDA MSEC		; #msec. * 10
  3852 F8E9 20 A7 E0				JSR NUMOUT		; Print decimal number
  3853 F8EC A2 3F				LDX #<TXT_MSEC     	; Print msec
  3854 F8EE A0 F9				LDY #>TXT_MSEC
  3855 F8F0 20 82 F6				JSR SPRINT	    	; print
  3856 F8F3 38			PRENDOK		SEC			; C=1, no error
  3857 F8F4 60					RTS			; return if BSY=0 and RDY=DSC=1
  3858 					
  3859 F8F5 A2 48		CFWLPTO		LDX #<TXT_HWERR     	; Print HW error
  3860 F8F7 A0 F9				LDY #>TXT_HWERR
  3861 F8F9 20 82 F6				JSR SPRINT	    	; print		
  3862 F8FC AD 87 0C				LDA CFREG7		; Status register
  3863 F8FF 20 91 E0				JSR HEXOUT		; Print and return
  3864 F902 18					CLC			; C=0, error
  3865 F903 60			CF_END		RTS			; return
  3866
  3867 				;-------------------------------------------------------------------------------
  3868 				; CF-Card Boot Routine
  3869 				;-------------------------------------------------------------------------------
  3870 F904 20 78 FC		CF_BOOT         JSR	INIT_LBA		; CFLBA0..CFLBA3 = 0 (MBR) and load into CF-card
  3871 F907 20 B7 FC				JSR	CF_RD_BLK_BUF		; Read MBR and store in BLOCK_BUF ($0600)
  3872 F90A 90 F7				BCC     CF_END                  ; error reading MBR. Exit
  3873 						
  3874 F90C 20 33 F6				JSR	LOAD_RUN_PART		; Load MBR and Volume ID
  3875 F90F 90 F2				BCC	CF_END			; branch if error
  3876 						
  3877 F911 A0 40				LDY     #CFCDEV-STRINGP2        ; load pointer to device name
  3878 F913 4C 23 F9		                JMP	DISP_DVC		; display device-name and return
  3879
  3880 				;-------------------------------------------------------------------------------
  3881 				; Init CFC-card, this is called from within MAIN loop.
  3882 				; The first instruction comes from the beginning of the MAIN routine and 
  3883 				; ensures that addresses do not change in a new firmware version
  3884 				;-------------------------------------------------------------------------------
  3885 F916 20 55 E5		INIT_CFC	JSR     WRITE_IO_INFO		; instruction from MAIN routine
  3886 F919 20 A1 FD				JSR	CHECK_ROMS		; Check ROM checksum
  3887 F91C A2 D0				LDX     #<CFC_DEV
  3888 F91E A0 F9		                LDY     #>CFC_DEV
  3889 F920 4C 6F F7		                JMP     DEV_ADD         	; add CF-card driver and return
  3890
  3891 				;----------------------------------------------------------------------------------		
  3892 				; This routine is the same for both the CF and SD cards. It displays the device ID
  3893 				;----------------------------------------------------------------------------------		
  3894 F923 20 D9 F6		DISP_DVC        JSR     SYS_MSG                 ; print device name to screen
  3895 F926 A9 5F		                LDA     #'_'
  3896 F928 20 52 E0		                JSR     COUT
  3897 F92B A5 EE		                LDA     PSAV                    ; add partition number to name (_1.._4)
  3898 F92D 20 52 E0		                JSR     COUT
  3899 F930 38			                SEC                             ; normal boot, set carry flag
  3900 F931 60			                RTS
  3901
  3902 F932 0D 20 43 46 20 52 + TXT_RSTOK       .by     CR ' CF Reset: ' $00
  3903 F93F 30 20 6D 73 65 63 + TXT_MSEC	.by	'0 msec.' CR $00
  3904 F948 4E 6F 20 43 46 20 + TXT_HWERR       .by     'No CF Reset, Status=$' $00
  3905
  3906 				; **** VPU IRQ Routine *********************************************************
  3907 				; ******************************************************************************
  3908 F95E			                ORG     $F960
  3909
  3910 F960 48			VPU_IRQ         PHA
  3911 F961 A9 00		                LDA     #VPU_STAT0
  3912 F963 8D 09 10		                STA     VPU_PORT1
  3913 F966 A9 8F		                LDA     #VPU_REG15
  3914 F968 8D 09 10		                STA     VPU_PORT1
  3915 F96B AD 09 10		                LDA     VPU_PORT1       ; is it a line interrupt?
  3916 F96E 10 08		                BPL     NO_VPU_IRQ      ; no, exit
  3917 F970 A5 DA		                LDA     TICKCNT         ; yes, load the tick counter
  3918 F972 F0 02				BEQ     IRQ_END         ; is it 0?
  3919 F974 C6 DA				DEC     TICKCNT         ; no, decrement tick counter
  3920 F976 68			IRQ_END         PLA
  3921 F977 40			                RTI
  3922 F978 68			NO_VPU_IRQ	PLA			; restore accumulator
  3923 F979 4C 18 F3				JMP	IRQ		; call user interrupt routine
  3924
  3925 				; ******************************************************************************
  3926 				; Standard Driver Descriptors
  3927 				; ******************************************************************************
  3928
  3929 F97C			                ORG     $FA00-16*8
  3930
  3931 F980 00 00		NULL_DEV	.byte	NULL_ID, $00     ; Null Device Driver Descriptor
  3932 F982 4E F8				.word	_EMPTY_
  3933 F984 4E F8				.word	_EMPTY_
  3934 F986 4E F8				.word	_EMPTY_
  3935
  3936 F988 10 00		TTY_DEV		.byte	TTY1_ID, $00     ; Terminal Driver Descriptor
  3937 F98A 75 F3				.word	SERIALIN
  3938 F98C 65 F3				.word	SERIALOUT
  3939 F98E E2 E1				.word	TTY_CMD
  3940
  3941 F990 11 00		PPRINT_DEV	.byte	PRINTER1_ID, $00 ; Parallel Printer Driver Descriptor
  3942 F992 4E F8				.word	_EMPTY_
  3943 F994 D2 F3				.word	PPORTOUT
  3944 F996 4E F8				.word	_EMPTY_
  3945
  3946 F998 13 00		KEYBD_DEV       .byte	KEYBD1_ID, $00   ; ASCII Keyboard Driver Descriptor
  3947 F99A 82 F3				.word	ASCIIKBD
  3948 F99C 4E F8				.word	_EMPTY_
  3949 F99E 4E F8				.word	_EMPTY_
  3950
  3951 F9A0 15 00		VDP_DEV         .byte	VDP1_ID, $00     ; Video Display Processor Driver Descriptor
  3952 F9A2 9A F3				.word   PS2KBD
  3953 F9A4 27 10		                .word   FGC_VPU_OUT
  3954 F9A6 1F 10				.word   FGC_VPU_CMD
  3955
  3956 F9A8 20 00		XMODEM_DEV	.byte	XMODEM1_ID, $00  ; XModem Device Driver Descriptor
  3957 F9AA 75 F3				.word	SERIALIN
  3958 F9AC 65 F3				.word	SERIALOUT
  3959 F9AE EA F7				.word	XMODEM_CMD
  3960
  3961 F9B0 21 00		TAPE_DEV	.byte	TAPE1_ID, $00    ; Tape Device Driver Descriptor
  3962 F9B2 4E F8				.word	_EMPTY_
  3963 F9B4 4E F8				.word	_EMPTY_
  3964 F9B6 4E F8				.word	_EMPTY_
  3965
  3966 F9B8 24 00		SDC_DEV	        .byte	SDC1_ID, $00     ; SD-Card Driver Descriptor
  3967 F9BA 4E F8				.word	_EMPTY_
  3968 F9BC 4E F8				.word	_EMPTY_
  3969 F9BE 06 F8				.word   SDC_CMD
  3970
  3971 F9C0 22 00		FDD1_DEV	.byte	FDD1_ID, $00     ; Floppy Disk Drive 1 Driver Descriptor
  3972 F9C2 4E F8				.word	_EMPTY_
  3973 F9C4 4E F8				.word	_EMPTY_
  3974 F9C6 17 10				.word   FGC_FDC_CMD
  3975
  3976 F9C8 23 00		FDD2_DEV	.byte	FDD2_ID, $00     ; Floppy Disk Drive 2 Driver Descriptor
  3977 F9CA 4E F8				.word	_EMPTY_
  3978 F9CC 4E F8				.word	_EMPTY_
  3979 F9CE 50 F8				.word   FGC_FDC_CMD2
  3980
  3981 F9D0 25 00		CFC_DEV	        .byte	HDD1_ID, $00     ; CF-Card Driver Descriptor
  3982 F9D2 4E F8				.word	_EMPTY_
  3983 F9D4 4E F8				.word	_EMPTY_
  3984 F9D6 55 F8				.word   CFC_CMD		 ; CF-card driver descriptor
  3985
  3986 				; ******************************************************************************
  3987 				; Low Byte CRC Lookup Table (XMODEM)
  3988 				; ******************************************************************************
  3989
  3990 F9D8			                ORG 	$FA00
  3991 FA00			CRCLO
  3992 FA00 00 21 42 63 84 A5 +  		.byte 	$00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
  3993 FA10 31 10 73 52 B5 94 +  		.byte 	$31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
  3994 FA20 62 43 20 01 E6 C7 +  		.byte 	$62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
  3995 FA30 53 72 11 30 D7 F6 +  		.byte 	$53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
  3996 FA40 C4 E5 86 A7 40 61 +  		.byte 	$C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
  3997 FA50 F5 D4 B7 96 71 50 +  		.byte 	$F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
  3998 FA60 A6 87 E4 C5 22 03 +  		.byte 	$A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
  3999 FA70 97 B6 D5 F4 13 32 +  		.byte 	$97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
  4000 FA80 88 A9 CA EB 0C 2D +  		.byte 	$88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
  4001 FA90 B9 98 FB DA 3D 1C +  		.byte 	$B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
  4002 FAA0 EA CB A8 89 6E 4F +  		.byte 	$EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
  4003 FAB0 DB FA 99 B8 5F 7E +  		.byte 	$DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
  4004 FAC0 4C 6D 0E 2F C8 E9 +  		.byte 	$4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
  4005 FAD0 7D 5C 3F 1E F9 D8 +  		.byte 	$7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
  4006 FAE0 2E 0F 6C 4D AA 8B +  		.byte 	$2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
  4007 FAF0 1F 3E 5D 7C 9B BA +  		.byte 	$1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0
  4008
  4009 				; ******************************************************************************
  4010 				; Hi Byte CRC Lookup Table (XMODEM)
  4011 				; ******************************************************************************
  4012
  4013 FB00			                ORG 	$FB00
  4014 FB00			CRCHI
  4015 FB00 00 10 20 30 40 50 +  		.byte 	$00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
  4016 FB10 12 02 32 22 52 42 +  		.byte 	$12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
  4017 FB20 24 34 04 14 64 74 +  		.byte 	$24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
  4018 FB30 36 26 16 06 76 66 +  		.byte 	$36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
  4019 FB40 48 58 68 78 08 18 +  		.byte 	$48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
  4020 FB50 5A 4A 7A 6A 1A 0A +  		.byte 	$5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
  4021 FB60 6C 7C 4C 5C 2C 3C +  		.byte 	$6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
  4022 FB70 7E 6E 5E 4E 3E 2E +  		.byte 	$7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
  4023 FB80 91 81 B1 A1 D1 C1 +  		.byte 	$91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
  4024 FB90 83 93 A3 B3 C3 D3 +  		.byte 	$83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
  4025 FBA0 B5 A5 95 85 F5 E5 +  		.byte 	$B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
  4026 FBB0 A7 B7 87 97 E7 F7 +  		.byte 	$A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
  4027 FBC0 D9 C9 F9 E9 99 89 +  		.byte 	$D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
  4028 FBD0 CB DB EB FB 8B 9B +  		.byte 	$CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
  4029 FBE0 FD ED DD CD BD AD +  		.byte 	$FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
  4030 FBF0 EF FF CF DF AF BF +  		.byte 	$EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E
    67
    68 FC00					ORG	$FC00			; start address of CF-IDE and MMU routines
    69 FC00					icl	"jc2_cf_ide.asm"	; cf-ide and MMU routines
Source: jc2_cf_ide.asm
     1 				;---------------------------------------------------------------------------
     2 				; JC2 CF-IDE Device Driver & MMU related functions.
     3 				; This program adds the necessary files for the CF-IDE Interface and the
     4 				; MMU related routines. 
     5 				;---------------------------------------------------------------------------
     6
     7 				;----------------------------------------------------------------------------
     8 				; This routine reads CF information and prints it.
     9 				;----------------------------------------------------------------------------
    10 FC00 20 B5 F8		CF_INFO		JSR CFWAIT	    	; Wait until CF-card ready
    11 FC03 A9 EC				LDA #$EC	    	; Drive ID command
    12 FC05 8D 87 0C				STA CFREG7		; CF command register
    13 FC08 20 8B F6				JSR INIT_BLKBUF		; Init. buffer-pointer
    14 FC0B 20 D6 FC				JSR CF_RD_INFO		; Read 512 bytes (= CF_RD_BLK without the Read 1 sector commands)
    15
    16 				; Print serial number
    17 FC0E A2 25				LDX #<TXT_SER     	; Print Serial text
    18 FC10 A0 FD				LDY #>TXT_SER
    19 FC12 20 82 F6				JSR SPRINT	    	; print
    20 FC15 A9 14				LDA #<(BLOCK_BUF+20)
    21 FC17 85 DC				STA BLKBUF
    22 FC19 A9 06				LDA #>(BLOCK_BUF+20)
    23 FC1B 85 DD				STA BLKBUF+1
    24 FC1D A2 14				LDX #20			; len = 20
    25 FC1F 20 4F FC				JSR PRTRSN		; Print serial-number info
    26
    27 				; Print Firmware revision
    28 FC22 A2 31				LDX #<TXT_FW     	; Print Firmware text
    29 FC24 A0 FD				LDY #>TXT_FW
    30 FC26 20 82 F6				JSR SPRINT	    	; print
    31 FC29 A9 2E				LDA #<(BLOCK_BUF+46)
    32 FC2B 85 DC				STA BLKBUF
    33 FC2D A9 06				LDA #>(BLOCK_BUF+46)
    34 FC2F 85 DD				STA BLKBUF+1
    35 FC31 A2 08				LDX #8			; len = 8
    36 FC33 20 4F FC				JSR PRTRSN		; Print firmware info
    37
    38 				; Print Model number
    39 FC36 A2 3E				LDX #<TXT_MOD     	; Print Model number text
    40 FC38 A0 FD				LDY #>TXT_MOD
    41 FC3A 20 82 F6				JSR SPRINT	    	; print
    42 FC3D A9 36				LDA #<(BLOCK_BUF+54)
    43 FC3F 85 DC				STA BLKBUF
    44 FC41 A9 06				LDA #>(BLOCK_BUF+54)
    45 FC43 85 DD				STA BLKBUF+1
    46 FC45 A2 28				LDX #40			; len = 40
    47 FC47 20 4F FC				JSR PRTRSN		; Print firmware info
    48 FC4A 20 5A E0				JSR CROUT		; Print CR
    49 FC4D 38					SEC			; C=1 (no error)
    50 FC4E 60					RTS
    51
    52 				;----------------------------------------------------------------------------
    53 				; This routine print a Big-Endian string of N characters, skipping all spaces.
    54 				; BUFPTR: points to begin of buffer to print
    55 				; X     : #bytes to print
    56 				;----------------------------------------------------------------------------
    57 FC4F A0 01		PRTRSN		LDY #1			; start at MSB
    58 FC51 B1 DC		PRTRSN1		LDA (BLKBUF),Y		; get MSB 		
    59 FC53 C9 20				CMP #' '		; skip if space
    60 FC55 F0 03				BEQ PRSNLP2		; branch if space
    61
    62 FC57 20 6C FC				JSR COUTXY		; output MSB to screen
    63 FC5A 88			PRSNLP2		DEY			; LSB now
    64 FC5B CA					DEX			; #bytes to print
    65 FC5C B1 DC				LDA (BLKBUF),Y		
    66 FC5E C9 20				CMP #' '		; skip if space
    67 FC60 F0 03				BEQ PRSNLP3		; branch if space
    68
    69 FC62 20 6C FC				JSR COUTXY		; output LSB to screen
    70 FC65 C8			PRSNLP3		INY			; 
    71 FC66 C8					INY			; points to next LSB
    72 FC67 C8					INY			; points to next MSB
    73 FC68 CA					DEX			; #bytes to print
    74 FC69 D0 E6				BNE PRTRSN1		; branch if more to print
    75 						
    76 FC6B 60					RTS			; return
    77
    78 				;----------------------------------------------------------------------------
    79 				; This routine calls COUT while preserving the values of X and Y
    80 				;----------------------------------------------------------------------------
    81 FC6C 86 D8		COUTXY		STX SAVEX		; Save X	
    82 FC6E 84 D9				STY SAVEY		; Save Y
    83 FC70 20 52 E0				JSR COUT		; Print char.
    84 FC73 A4 D9				LDY SAVEY		; Get Y back
    85 FC75 A6 D8				LDX SAVEX		; Get X back
    86 FC77 60					RTS			; return
    87
    88 				;----------------------------------------------------------------------------
    89 				; This routine sets the LBA for the CF-card to 0 (the MBR) and loads it
    90 				; into the CF-card.
    91 				;----------------------------------------------------------------------------
    92 FC78 A9 00		INIT_LBA	LDA #0
    93 FC7A 85 D2				STA CFLBA0	    	; LBA 0 (LSB)
    94 FC7C 85 D3				STA CFLBA1
    95 FC7E 85 D4				STA CFLBA2
    96 FC80 85 D5				STA CFLBA3		; LBA 3 (MSB)
    97 FC82 4C 9E FC				JMP LOAD_CFLBA		; Load into CF-card and return
    98
    99 				;----------------------------------------------------------------------------
   100 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   101 				; Input :  X,Y = Ptr[LO:HI] to 32 Bit LBA Address
   102 				; Output: LBA in CFLBA3..CFLBA0
   103 				;----------------------------------------------------------------------------
   104 FC85 86 E6		LOAD_LBA_CF	STX PLBA		; Store pointer
   105 FC87 84 E7				STY PLBA+1
   106 FC89 A0 00				LDY #0
   107 FC8B B1 E6				LDA (PLBA),Y		; LBA 0 (LSB)
   108 FC8D 85 D2				STA CFLBA0
   109 FC8F C8					INY
   110 FC90 B1 E6				LDA (PLBA),Y		; LBA 1
   111 FC92 85 D3				STA CFLBA1
   112 FC94 C8					INY
   113 FC95 B1 E6				LDA (PLBA),Y		; LBA 2
   114 FC97 85 D4				STA CFLBA2
   115 FC99 C8					INY
   116 FC9A B1 E6				LDA (PLBA),Y		; LBA 3 (MSB)
   117 FC9C 85 D5				STA CFLBA3
   118 						;JMP LOAD_CFLBA		; Load into CF-card and return
   119
   120 				;----------------------------------------------------------------------------
   121 				; This routine loads the Logical Block Address (LBA) into the CF-card.
   122 				; Input : CFLBA3..CFLBA0
   123 				; Output: -
   124 				;----------------------------------------------------------------------------
   125 FC9E A5 D2		LOAD_CFLBA	LDA CFLBA0		; CFLBA0 -> CFREG3
   126 FCA0 8D 83 0C				STA CFREG3		; 
   127 FCA3 A5 D3				LDA CFLBA1		; CFLBA1 -> CFREG4
   128 FCA5 8D 84 0C				STA CFREG4
   129 FCA8 A5 D4				LDA CFLBA2		; CFLBA2 -> CFREG5
   130 FCAA 8D 85 0C				STA CFREG5
   131 FCAD A5 D5				LDA CFLBA3		; CFLBA3 -> CFREG6
   132 FCAF 29 0F				AND #$0F		; Filter out LBA bits
   133 FCB1 09 E0				ORA #$E0		; Mode LBA, master dev
   134 FCB3 8D 86 0C				STA CFREG6		; Store in CFREG6
   135 FCB6 60					RTS
   136 						
   137 				;----------------------------------------------------------------------------
   138 				; Command: None, Read Single Data Block to Std. Block Buffer
   139 				; Input  : CFLBA3..CFLBA0 = 32 Bit Command Block Source Address. 
   140 				;          NOTE: These have to loaded prior to calling this function!!!
   141 				; Output : C = 0 Error, C = 1 Read OK
   142 				;	   A = Error Code
   143 				;----------------------------------------------------------------------------
   144 FCB7 20 8B F6		CF_RD_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   145 FCBA F0 0B				BEQ	CF_RD_BLK		; branch always
   146
   147 				;----------------------------------------------------------------------------
   148 				; Command: CMD_READ_BUF, Read Single Data Block from Logical Address to Std. Block Buffer
   149 				; Input  :  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   150 				; Output :  C   = 0 Error, C = 1 Data OK
   151 				;	    A   = Error Code
   152 				;----------------------------------------------------------------------------
   153 FCBC 20 8B F6		CF_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   154 										; fall through to CF_RD_LBLK
   155
   156 				;----------------------------------------------------------------------------
   157 				; Command: CMD_READ, Read Single Data Block from Logical Address
   158 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
   159 				;	   BLKBUF,BLKBUFH = 16 Bit Destination Address
   160 				; Output : C = 0 Error, C = 1 Data OK
   161 				;	   A = Error Code
   162 				;----------------------------------------------------------------------------
   163 FCBF 20 B5 F8		CF_RD_LBLK	JSR 	CFWAIT			; Wait until CF-card ready
   164 FCC2 90 29				BCC	CF_RD_END		; branch on error
   165 FCC4 20 85 FC				JSR	LOAD_LBA_CF		; Load LBA into CF-card
   166 										; fall through to CF_RD_BLK
   167
   168 				;----------------------------------------------------------------------------
   169 				; Read Single Data Block
   170 				; Input:  BLKBUF,BLKBUFH = 16 Bit Destination Address
   171 				; Output: C = 0 Error, C = 1 Read OK
   172 				;	  A = Error Code
   173 				;----------------------------------------------------------------------------
   174 FCC7 A9 01		CF_RD_BLK	LDA 	#$01
   175 FCC9 8D 82 0C				STA 	CFREG2			; Read one Sector
   176 FCCC A9 20				LDA 	#$20			; Read Sector Command
   177 FCCE 8D 87 0C				STA 	CFREG7			; CF command register
   178 FCD1 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   179 FCD4 90 17				BCC 	CF_RD_END		; branch on error
   180
   181 FCD6 A2 01		CF_RD_INFO	LDX	#$01			; initialize page counter
   182 FCD8 A0 00				LDY	#$00			; initialize byte counter
   183 FCDA 20 B5 F8		CF_RD_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   184 FCDD 90 0E				BCC	CF_RD_END		; Exit on CF-card error
   185
   186 FCDF AD 80 0C				LDA 	CFREG0			; read data-bytes
   187 FCE2 91 DC				STA 	(BLKBUF),Y		; store in buffer
   188 FCE4 C8					INY				; next byte
   189 FCE5 D0 F3				BNE 	CF_RD_BLK0		; branch if more bytes to read
   190
   191 FCE7 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   192 FCE9 CA					DEX
   193 FCEA 10 EE				BPL	CF_RD_BLK0		; two pages read? no, read next byte
   194 						
   195 FCEC 38					SEC				; yes, all data read, set C = 1 (no error)
   196 FCED 60			CF_RD_END	RTS				; C=0 (error), C=1 (ok)
   197
   198 				;----------------------------------------------------------------------------
   199 				; Command: None, Write Single Data Block from Std. Block Buffer
   200 				; Input  : CFLBA3..CFLBA0 = 32 Bit LBA Address to write to
   201 				;          NOTE: These have to loaded prior to calling this function!!!
   202 				; Output : C = 0 Error, C = 1 Read OK
   203 				;	   A = Error Code
   204 				;----------------------------------------------------------------------------
   205 FCEE 20 8B F6		CF_WR_BLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   206 FCF1 F0 0B				BEQ	CF_WR_BLK		; branch always
   207
   208 				;----------------------------------------------------------------------------
   209 				; Command: WRITE_BUF, Write Single Data Block from Std. Block Buffer to Logical Address
   210 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   211 				; Output : C = 0 Error, C = 1 Data OK
   212 				;	   A = Error Code
   213 				;----------------------------------------------------------------------------
   214 FCF3 20 8B F6		CF_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
   215 										; fall through to CF_WR_LBLK
   216
   217 				;----------------------------------------------------------------------------
   218 				; Command: CMD_WRITE, Write Single Data Block to Logical Address
   219 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
   220 				;	   BLKBUF,BLKBUFH = 16 Bit Source Address
   221 				; Output : C = 0 Error, C = 1 Data OK
   222 				;	   A = Error Code
   223 				;----------------------------------------------------------------------------
   224 FCF6 20 B5 F8		CF_WR_LBLK	JSR	CFWAIT			; Wait until CF-card ready
   225 FCF9 90 29				BCC	CF_WR_END		; Branch on error
   226 FCFB 20 85 FC				JSR	LOAD_LBA_CF		; Load LBA into CF-card
   227 										; fall through to CF_WR_BLK
   228
   229 				;----------------------------------------------------------------------------
   230 				; Write Single Data Block
   231 				; Input:  BLKBUF,BLKBUFH = 16 Bit Source Address
   232 				; Output: C = 0 Error, C = 1 Write OK
   233 				;	  A = Error Code
   234 				;----------------------------------------------------------------------------
   235 FCFE A9 01		CF_WR_BLK	LDA 	#$01
   236 FD00 8D 82 0C				STA 	CFREG2			; Read one Sector
   237 FD03 A9 30				LDA 	#$30			; Write Sector Command
   238 FD05 8D 87 0C				STA 	CFREG7			; CF command register
   239 FD08 20 B5 F8				JSR 	CFWAIT			; Wait until CF-card ready
   240 FD0B 90 17				BCC 	CF_WR_END		; branch on error
   241
   242 FD0D A2 01		CF_WR_INFO	LDX	#$01			; initialize page counter
   243 FD0F A0 00				LDY	#$00			; initialize byte counter
   244 FD11 20 B5 F8		CF_WR_BLK0	JSR	CFWAIT			; Wait until CF-card ready
   245 FD14 90 0E				BCC	CF_WR_END		; Exit on CF-card error
   246
   247 FD16 B1 DC				LDA 	(BLKBUF),Y		; read from buffer
   248 FD18 8D 80 0C				STA 	CFREG0			; Write to CF-card
   249 FD1B C8					INY				; next byte
   250 FD1C D0 F3				BNE 	CF_WR_BLK0		; branch if more bytes to write
   251
   252 FD1E E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
   253 FD20 CA					DEX
   254 FD21 10 EE				BPL	CF_WR_BLK0		; two pages read? no, read next byte
   255 						
   256 FD23 38					SEC				; yes, all data read, set C = 1 (no error)
   257 FD24 60			CF_WR_END	RTS				; C=0 (error), C=1 (ok)
   258
   259 				;----------------------------------------------------------------------------
   260 				; Text-strings needed for Printing
   261 				;----------------------------------------------------------------------------
   262 FD25 20 20 20 53 65 72 + TXT_SER		.by        '   Serial: ' $00
   263 FD31 0D 20 46 69 72 6D + TXT_FW		.by     CR ' Firmware: ' $00
   264 FD3E 0D 20 20 20 20 4D + TXT_MOD		.by     CR '    Model: ' $00
   265
   266 FD4B					ORG	$FD53		; maintain compatibility
   267
   268 				;----------------------------------------------------------------------------
   269 				; This function enables a RAM-bank at $4000-$7FFF.
   270 				; Input: X: the RAM-bank number to enable [0..28]. A RAM-bank starts at 4,
   271 				;           so 0..3 disables the RAM-banks and enables main-memory
   272 				;----------------------------------------------------------------------------
   273 FD53 AD 00 17		SET_RAMBANK	LDA	MMU		; Get MMU register
   274 FD56 29 83				AND	#$83		; Set RAM-bank bits 6..2 to 0
   275 FD58 8D 00 17				STA	MMU		; Update MMU register
   276 FD5B 8A					TXA			; A is now RAM-bank number
   277 FD5C C9 1D				CMP	#29		; RAM-bank 28 is the highest nr
   278 FD5E B0 04				BCS	SET_RAMB0	; branch if >= 29
   279 FD60 C9 04				CMP	#4		; <= 28, now check for >= 4
   280 FD62 B0 02				BCS	RAMBVLD		; branch if >= 4
   281 						
   282 FD64 A9 00		SET_RAMB0	LDA	#0		; set to no RAM-bank (main-memory)
   283 FD66 0A			RAMBVLD		ASL
   284 FD67 0A					ASL			; nr now in RAM-bank bits 6..2
   285 FD68 0D 00 17				ORA	MMU		; add to MMU-register
   286 FD6B 8D 00 17				STA	MMU		; Enable RAM-bank
   287 FD6E 60					RTS			; return
   288 						
   289 				;----------------------------------------------------------------------------
   290 				; This function returns the currently active RAM-bank at $4000-$7FFF.
   291 				; Output: A: the active RAM-bank number [4..28] or 0 if no RAM-bank is selected.
   292 				;----------------------------------------------------------------------------
   293 FD6F AD 00 17		GET_RAMBANK	LDA	MMU		; MMU-register
   294 FD72 29 7C				AND	#$7C		; Only RAM-bank bits
   295 FD74 4A					LSR
   296 FD75 4A					LSR			; Now in bits 4..0
   297 FD76 C9 04				CMP	#4		; Is it 4 or more?
   298 FD78 B0 02				BCS	RAMBX		; branch if >= 4, RAM-bank selected
   299 						
   300 FD7A A9 00				LDA	#0		; RAM-bank 0..3 => main memory
   301 FD7C 60			RAMBX		RTS			; return		
   302 						
   303 				;----------------------------------------------------------------------------
   304 				; This function enables Monitor-ROM at $1C00-$1FFF and disables the RAM behind it.
   305 				;----------------------------------------------------------------------------
   306 FD7D AD 00 17		MON2ROM		LDA	MMU		; MMU-register
   307 FD80 09 02				ORA	#MON_EN		; 1 = enable Monitor ROM
   308 FD82 8D 00 17				STA	MMU		; Activate Monitor ROM
   309 FD85 60					RTS			; return
   310 						
   311 				;----------------------------------------------------------------------------
   312 				; This function Enables Monitor-RAM at $1C00-$1FFF and disables Monitor-ROM.
   313 				;----------------------------------------------------------------------------
   314 FD86 AD 00 17		MON2RAM		LDA	MMU		; MMU-register
   315 FD89 29 FD				AND	#~MON_EN	; 0 = enable Monitor RAM, disable ROM
   316 FD8B 8D 00 17				STA	MMU		; Activate Monitor RAM
   317 FD8E 60					RTS			; return
   318
   319 				;----------------------------------------------------------------------------------		
   320 				; This routine disables the BASIC ROM and enables the RAM behind it.
   321 				;----------------------------------------------------------------------------------		
   322 FD8F AD 00 17		BAS2RAM		LDA	MMU			; MMU register		
   323 FD92 29 7F				AND 	#~BAS_EN		; Set bit to 0, disable BASIC ROM
   324 FD94 8D 00 17				STA 	MMU	   		; disable BASIC ROM, enable RAM behind it
   325 FD97 60					RTS				; return
   326
   327 				;----------------------------------------------------------------------------------		
   328 				; This routine enables the BASIC ROM and disables the RAM behind it.
   329 				;----------------------------------------------------------------------------------		
   330 FD98 AD 00 17		BAS2ROM		LDA	MMU			; MMU register		
   331 FD9B 09 80				ORA 	#BAS_EN			; Set bit to 1, enable BASIC ROM		   
   332 FD9D 8D 00 17				STA 	MMU	   		; enable BASIC ROM, disable RAM behind it
   333 FDA0 60					RTS				; return
   334
   335 				;----------------------------------------------------------------------------
   336 				; Check both ROMs: 
   337 				; 1) Monitor ROM at $1C00-$1FFF
   338 				; 2) BASIC + BIOS ROM at $B000-$FFF0
   339 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   340 				;        X: LSB of end-Address
   341 				;        Y: MSB of end-Address
   342 				;----------------------------------------------------------------------------
   343 FDA1 A9 1C		CHECK_ROMS	LDA	#$1C		; MSB of $1C00
   344 FDA3 A2 00				LDX	#$00		; LSB of $1FFF+1 (end-address)
   345 FDA5 A0 20				LDY	#$20		; MSB of $1FFF+1 (end-address)
   346 FDA7 20 B9 FD				JSR	CHECK_ROM_STRT	; Check Monitor ROM Checksum
   347 FDAA A9 B0				LDA	#$B0		; MSB of $B000
   348 FDAC A2 00				LDX	#$00		; LSB of $DFFF+1 (end-address)
   349 FDAE A0 E0				LDY	#$E0		; MSB of $DFFF+1 (end-address)
   350 FDB0 20 B9 FD				JSR	CHECK_ROM_STRT	; Check BASIC ROM Checksum
   351 FDB3 A9 E0				LDA	#$E0		; MSB of $B000
   352 FDB5 A2 F0				LDX	#$F0		; LSB of $FFF0 (end-address)
   353 FDB7 A0 FF				LDY	#$FF		; MSB of $FFF0 (end-address)
   354 						;JMP 	CHECK_ROM_STRT	; Check BIOS ROM checksum and return
   355 						
   356 				;----------------------------------------------------------------------------
   357 				; This routine is the entry-point for the ROM checksum routines.
   358 				; Input: A: MSB of ROM begin ($B0 for BIOS, $1C for Monitor).
   359 				;        X: LSB of end-Address
   360 				;        Y: MSB of end-Address
   361 				;----------------------------------------------------------------------------
   362 FDB9 86 CC		CHECK_ROM_STRT	STX	END_PTR		; LSB of end-address
   363 FDBB 84 CD				STY	END_PTR+1	; MSB of end-address
   364 FDBD A2 00				LDX	#0
   365 FDBF 86 D0				STX 	ROM_CS		; Init ROM checksum
   366 FDC1 86 D1				STX 	ROM_CS+1
   367 FDC3 86 CE				STX	ROM_PTR		; LSB of begin-address
   368 FDC5 85 CF				STA	ROM_PTR+1	; MSB of begin-address
   369 FDC7 C9 1C				CMP	#$1C		; Monitor ROM?
   370 FDC9 F0 10				BEQ	MON_CHK_ROM	; branch if Monitor ROM
   371 						
   372 FDCB C9 B0				CMP	#$B0		; BASIC ROM?
   373 FDCD F0 06				BEQ	BAS_CHK_ROM	; branch if BASIC ROM
   374
   375 FDCF A2 6E				LDX	#<TXT_ROM	; BIOS ROM
   376 FDD1 A0 FE				LDY	#>TXT_ROM
   377 FDD3 D0 0A				BNE 	PR_CHKROM_TXT	; branch always
   378 						
   379 FDD5 A2 64		BAS_CHK_ROM	LDX	#<TXT_BAS	; BASIC ROM
   380 FDD7 A0 FE				LDY	#>TXT_BAS
   381 FDD9 D0 04				BNE 	PR_CHKROM_TXT	; branch always
   382
   383 FDDB A2 5A		MON_CHK_ROM	LDX	#<TXT_MON	; Monitor ROM
   384 FDDD A0 FE				LDY	#>TXT_MON
   385 FDDF 20 82 F6		PR_CHKROM_TXT	JSR	SPRINT
   386 FDE2 A2 78				LDX	#<TXT_CS	; Print ' KB ROM '
   387 FDE4 A0 FE				LDY	#>TXT_CS
   388 FDE6 20 82 F6				JSR	SPRINT
   389 FDE9 A0 00				LDY	#0
   390 						;JMP	ROM_LP1		; fall-through to ROM_LP1
   391
   392 				;----------------------------------------------------------------------------
   393 				; This routine calculates the checksum of the entire ROM area from 
   394 				; ROM_PTR to END_PTR.
   395 				;----------------------------------------------------------------------------
   396 FDEB B1 CE		ROM_LP1		LDA 	(ROM_PTR),Y	; get byte from ROM
   397 FDED					ADCAW	ROM_CS		; ROM_CS = ROM_CS + A
Macro: ADCAW [Source: jc2_macros.inc]
     1 FDED 18					CLC
     2 FDEE 65 D0				ADC	ROM_CS
     3 FDF0 85 D0				STA	ROM_CS
     4 FDF2 A5 D1				LDA	ROM_CS+1
     5 FDF4 69 00				ADC	#0
     6 FDF6 85 D1				STA	ROM_CS+1
Source: jc2_cf_ide.asm
   398 FDF8 C8					INY			; next byte
   399 FDF9 D0 02				BNE	ROM_CHK_END	; branch if not on a new page
   400 						
   401 FDFB E6 CF				INC 	ROM_PTR+1	; MSB, next page
   402 FDFD A5 CF		ROM_CHK_END	LDA	ROM_PTR+1	; Current ROM address MSB
   403 FDFF C5 CD				CMP	END_PTR+1	; MSB of end-address
   404 FE01 D0 E8				BNE	ROM_LP1		; branch if not done yet
   405 						
   406 FE03 C4 CC				CPY	END_PTR		; End-address?
   407 FE05 D0 E4				BNE	ROM_LP1		; branch if not at end-address yet
   408 						
   409 FE07 A5 CD				LDA	END_PTR+1
   410 FE09 C9 FF				CMP	#$FF		; BIOS ROM?
   411 FE0B D0 10				BNE	ROM_CHK2	; branch if not BIOS ROM
   412 						
   413 FE0D A5 D1 CD F9 FF D0 + 		CPW	ROM_CS ROM_CS16	; Compare 2 words BIOS checksum
   414 FE19 D0 2B				BNE	ROM_CS_ERR	; branch if not the same
   415 FE1B F0 22				BEQ	ROM_CS_OK	; branch if the same
   416
   417 FE1D C9 E0		ROM_CHK2	CMP	#$E0		; BASIC ROM?
   418 FE1F D0 10				BNE	MON_ROM_CMP	; branch if Monitor ROM
   419 						
   420 FE21 A5 D1 CD F7 FF D0 + 		CPW	ROM_CS BAS_CS16	; Compare 2 words BASIC checksum
   421 FE2D D0 17				BNE	ROM_CS_ERR	; branch if not the same
   422 FE2F F0 0E				BEQ	ROM_CS_OK	; branch if the same
   423 						
   424 FE31 A5 D1 CD F5 FF D0 + MON_ROM_CMP	CPW	ROM_CS MON_CS16	; Compare 2 words Monitor checksum
   425 FE3D D0 07				BNE	ROM_CS_ERR	; branch if not the same
   426
   427 FE3F A2 81		ROM_CS_OK	LDX	#<TXT_CS_OK	; Print 'OKE'
   428 FE41 A0 FE				LDY	#>TXT_CS_OK
   429 FE43 4C 82 F6				JMP	SPRINT		; Print and return
   430 FE46 A2 85		ROM_CS_ERR	LDX	#<TXT_CS_ERR	; Print 'Error'
   431 FE48 A0 FE				LDY	#>TXT_CS_ERR
   432 FE4A 4C 82 F6				JMP	SPRINT		; Print and return
   433
   434 				;----------------------------------------------------------------------------
   435 				; This routine prints a string to the terminal: X=LSB, Y=MSB.
   436 				; In order not to interfere with the BIOS STROUT / WRSTR with PSTR, a copy
   437 				; of these routines is made with SPRINT and SPROUT.
   438 				;----------------------------------------------------------------------------
   439 FE4D A0 00		SPROUT		LDY  	#$00       	; index y is 0
   440 FE4F B1 CA		SPROUTLP	LDA  	(PRSTR),Y   	; load char at string pos y
   441 FE51 F0 06				BEQ  	ENDSPROUT  	; exit, if NULL char
   442 						
   443 FE53 20 52 E0				JSR  	COUT       	; write character
   444 FE56 C8					INY             	; next index
   445 FE57 D0 F6				BNE  	SPROUTLP	; branch always
   446 						
   447 FE59 60			ENDSPROUT	RTS			; return
   448
   449 FE5A 20 4A 43 2D 4D 4F + TXT_MON		.by	' JC-MON 1' $00
   450 FE64 20 42 41 53 49 43 + TXT_BAS		.by	' BASIC 12' $00
   451 FE6E 20 42 49 4F 53 20 + TXT_ROM		.by	' BIOS   8' $00
   452 FE78 20 4B 42 20 52 4F + TXT_CS		.by	' KB ROM ' $00
   453 FE81 4F 4B 0D 00		TXT_CS_OK	.by	'OK' CR $00
   454 FE85 45 72 72 6F 72 0D + TXT_CS_ERR	.by	'Error' CR $00		
   455 						
   456
   457 						
    70 						
    71 				;----------------------------------------------------------------------------
    72 				;       VECTORS AT THE END OF THE ROM AREA
    73 				;----------------------------------------------------------------------------
    74 FE8C					ORG	$FFEE
    75 FFEE 6C 7A 1A		NMI_JMP_VEC    	JMP     (NMIVECT)		; Jump to a user selectable NMI vector (moved from Monitor $1F2F)
    76 FFF1 6C 7E 1A		IRQ_JMP_VEC    	JMP     (IRQVECT)		; Jump to a user selectable IRQ vector (moved from Monitor $1F32)
    77 FFF4 00 00		MON_CS16	.word	$000			;  1 KB Monitor ROM checksum
    78 FFF6 00 00		BAS_CS16	.word	$000			; 12 KB BASIC ROM checksum
    79 FFF8 00 00		ROM_CS16	.word	$000			;  8 KB BIOS ROM checksum
    80 FFFA EE FF		NMI_VECTOR	.word	NMI_JMP_VEC		; This was $1F2F in Junior Computer Monitor program
    81 FFFC 00 E0		RESET_VECTOR	.word  	MON_COLD_START		; $E000 (was $1C1D in Junior Computer Monitor program)
    82 FFFE F1 FF		IRQ_BRK_VECTOR	.word	IRQ_JMP_VEC		; This was $1F32 in Junior Computer Monitor program
    83
    84 						END
