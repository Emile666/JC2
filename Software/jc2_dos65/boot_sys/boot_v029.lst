mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Disk Operating System for 6502 Microprocessors
     3 				;
     4 				; JC2 DOS65, Version 0.2.9 by Emile, original design (V0.2.0) by Joerg Walke
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; DOS65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0032			VERPSUB    	EQU     '2'    		; primary sub version
    24 = 0039			VERSSUB		EQU	'9'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; V0.2.4: - .BAS LOAD file now works, filename bug-fix and NUM32 bug-fix
    33 				;	  - Bug-fix MKDIR run after DIR command
    34 				;	  - SIS added + total KB printed with DIR command
    35 				; V0.2.5: - DEL command added.
    36 				; V0.2.6: - SAVE from BASIC added, CFC_SAVE, OS_CREATE, OS_CREATE_FILE changed,
    37 				;           OS_SAVE_FILE and LINK_FAT_ENTRY added.
    38 				;         - VER command added.
    39 				;         - Bug-fixes OS_LOAD_FILE when 1) #clusters = 1 2) sectors/cluster = 1
    40 				; V0.2.7: Couple of bug-fixes with path-name string and CD command.
    41 				; V0.2.8: Enabling RAM-BANK 4 for BASIC and RAM-BANK 0 for DOS. Now Basic programs
    42 				;         can load all the way up to $AFFF.
    43 				; V0.2.9: BASIC related DOS functions are now copied into Monitor RAM area.
    44 				; ******************************************************************************
    45 						OPT h- ; do not add file header
    46 						OPT f+ ; save as single block
    47
    48 				;------------------------------------------------------------------------------------------------
    49 				; TERMINOLOGY AND FORMULAS USED:
    50 				; 
    51 				; Sector                : A sector consists of 512 bytes.
    52 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    53 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    54 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    55 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    56 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    57 				; 
    58 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    59 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    60 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    61 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    62 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    63 				;------------------------------------------------------------------------------------------------
    64 						ICL "macros.inc"		; boot.sys macro definitions for MADS
Source: macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTR	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	PHX					; Push X-register
    88 					TXA
    89 					PHA
    90 				.endm
    91
    92 				.macro	PLX					; Pull X-register
    93 					PLA
    94 					TAX
    95 				.endm
    96
    97 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    98 					LDX	#:n-1
    99 				lp	MVA	:src,X :dst,X-
   100 					BPL	lp
   101 				.endm
   102 					
   103 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
   104 					LDY	#:n-1
   105 				lp	MVA	:src,Y :dst,Y-
   106 					BPL	lp
   107 				.endm
   108
   109 				; Macros used for printing a cluster nr, which consists of 2 words
   110 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   111 						LDA	(:c),Y
   112 					ift :0>1	; st also given?
   113 						STA	:st
   114 					eif	
   115 						JSR	HEXOUT			; changes Y!
   116 				.endm		
   117
   118 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   119 						LDY	#:indx+1		; Print MSB of word
   120 					ift :0>2	; stor also given?	
   121 						PRCLB	:curr_dir :stor+1
   122 					els	
   123 						PRCLB	:curr_dir
   124 					eif
   125 						LDY	#:indx			; Print LSB of word
   126 					ift :0>2	; stor also given?	
   127 						PRCLB	:curr_dir :stor
   128 					els	
   129 						PRCLB	:curr_dir
   130 					eif
   131 				.endm
   132
   133 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   134 					ift :b2>7
   135 						ERT "Only bits 7-0 allowed"
   136 					els
   137 						LDA	:b1
   138 						AND	#(1 << :b2)
   139 						BEQ	:lbl1
   140 					eif
   141 				.endm
   142 					
   143 				; ----------------------------------------------
   144 				; Compare + Branch Macros
   145 				; ----------------------------------------------
   146 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   147 						CMP	:b1
   148 						BEQ	:lbl
   149 				.endm		; A is now not equal to b1
   150 					
   151 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   152 						CMP	:b1
   153 						BNE	:lbl
   154 				.endm		; A is now equal to b1
   155
   156 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   157 				CMP.CC	.macro ' '	b1 lbl
   158 						CMP	:b1			; 
   159 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   160 				.endm		; C is now 1 (A-b1 is >= 0)
   161
   162 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   163 				CMP.CS	.macro ' '	b1 lbl
   164 						CMP	:b1			; 
   165 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   166 				.endm		; C is now 0 (A-b1 is < 0)
   167
   168 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   169 						CPX	:b1
   170 						BEQ	:lbl
   171 				.endm		; X is now not equal to b1
   172 					
   173 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   174 						CPX	:b1
   175 						BNE	:lbl
   176 				.endm		; X is now equal to b1
   177
   178 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   179 				CPX.CC	.macro ' '	b1 lbl
   180 						CPX	:b1			; 
   181 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   182 				.endm		; C is now 1 (X-b1 is >= 0)
   183
   184 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   185 				CPX.CS	.macro ' '	b1 lbl
   186 						CPX	:b1			; 
   187 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   188 				.endm		; C is now 0 (X-b1 is < 0)
   189
   190 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   191 						CPY	:b1
   192 						BEQ	:lbl
   193 				.endm		; Y is now not equal to b1
   194 					
   195 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   196 						CPY	:b1
   197 						BNE	:lbl
   198 				.endm		; Y is now equal to b1
   199
   200 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   201 				CPY.CC	.macro ' '	b1 lbl
   202 						CPY	:b1			; 
   203 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   204 				.endm		; C is now 1 (Y-b1 is >= 0)
   205
   206 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   207 				CPY.CS	.macro ' '	b1 lbl
   208 						CPY	:b1			; 
   209 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   210 				.endm		; C is now 0 (Y-b1 is < 0)
   211
   212 				; ----------------------------------------------
   213 				; Increment/Decrement + Branch Macros
   214 				; ----------------------------------------------
   215 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   216 						DEC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   221 						DEC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   226 						INC	:b1
   227 						BEQ	:lbl
   228 				.endm
   229
   230 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   231 						INC	:b1
   232 						BNE	:lbl
   233 				.endm
   234
   235 				; ----------------------------------------------
   236 				DEX.NE	.macro 	lbl				; DEX + BNE
   237 						DEX
   238 						BNE	:lbl
   239 				.endm
   240
   241 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   242 						DEX
   243 						BEQ	:lbl
   244 				.endm
   245
   246 				DEX.PL	.macro 	lbl				; DEX + BPL 
   247 						DEX
   248 						BPL	:lbl
   249 				.endm
   250
   251 				DEX.MI	.macro 	lbl				; DEX + BMI
   252 						DEX
   253 						BMI	:lbl
   254 				.endm
   255
   256 				DEX.CC	.macro 	lbl				; DEX + BCC 
   257 						DEX
   258 						BCC	:lbl
   259 				.endm
   260
   261 				DEX.CS	.macro 	lbl				; DEX + BCS
   262 						DEX
   263 						BCS	:lbl
   264 				.endm
   265
   266 				; ----------------------------------------------
   267 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   268 						DEY
   269 						BEQ	:lbl
   270 				.endm
   271
   272 				DEY.NE	.macro 	lbl				; DEY + BNE
   273 						DEY
   274 						BNE	:lbl
   275 				.endm
   276
   277 				DEY.PL	.macro 	lbl				; DEY + BPL 
   278 						DEY
   279 						BPL	:lbl
   280 				.endm
   281
   282 				DEY.MI	.macro 	lbl				; DEY + BMI
   283 						DEY
   284 						BMI	:lbl
   285 				.endm
   286
   287 				DEY.CC	.macro 	lbl				; DEY + BCC 
   288 						DEY
   289 						BCC	:lbl
   290 				.endm
   291
   292 				DEY.CS	.macro 	lbl				; DEY + BCS
   293 						DEY
   294 						BCS	:lbl
   295 				.endm
   296 				; ----------------------------------------------
   297
   298 				; ----------------------------------------------
   299 				; LOAD/STORE + Branch Macros
   300 				; ----------------------------------------------
   301 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   302 						LDA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   307 						LDA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   312 						STA	:b1
   313 						BEQ	:lbl
   314 				.endm
   315
   316 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   317 						STA	:b1
   318 						BNE	:lbl
   319 				.endm
   320
   321 				; ----------------------------------------------
   322 				; AND/OR + Branch Macros
   323 				; ----------------------------------------------
   324 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   325 					ift :0>2	; LDA + AND + BEQ	
   326 						LDA	:p1
   327 						AND	:p2
   328 						BEQ	:p3
   329 					els		; AND + BEQ
   330 						AND	:p1
   331 						BEQ	:p2
   332 					eif
   333 				.endm
   334
   335 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   336 					ift :0>2	; LDA + AND + BNE	
   337 						LDA	:p1
   338 						AND	:p2
   339 						BNE	:p3
   340 					els		; AND + BNE
   341 						AND	:p1
   342 						BNE	:p2
   343 					eif
   344 				.endm
    65 						ICL "defines.inc"		; boot.sys defines
Source: defines.inc
     1 				;-------------------------------------------------
     2 				; Register Definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------
     5
     6 				; Global Constants and Variables ***********************************************
     7 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
     8 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
     9 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    10 = B000			LAB_COLD	=	$B000		; BASIC cold START
    11
    12 = 00A0			ZP_BASE         EQU     $A0		; Reserved for DOS and boot.sys
    13 = 00A0			CURR_CLUSTER    EQU     ZP_BASE         ; $A0..$A3 (32 bit) - current addressed cluster
    14 = 00A4			CURR_FAT_BLK    EQU     ZP_BASE+4       ; $A4..$A7 (32 bit) - current loaded FAT LBA
    15 = 00A8			CURR_DIR_ENTRY  EQU     ZP_BASE+8       ; $A8..$A9 (16 bit) - pointer to current addressed directory entry
    16 = 00AA			MASK            EQU     ZP_BASE+10	; $AA Mask for FAT table
    17 = 00AB			BCNT            EQU     ZP_BASE+11      ; $AB Block Counter
    18 = 00AC			NCNT            EQU     ZP_BASE+12	; $AC
    19 = 00AD			SCNT            EQU     ZP_BASE+13	; $AD Sector counter within a cluster
    20 = 00AE			RES             EQU     ZP_BASE+14	; $AE
    21
    22 = 0078			ssptr_l		EQU	$78		; BASIC filename pointer LSB
    23 = 0079			ssptr_h		EQU	$79		; BASIC filename pointer MSB
    24
    25 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    26 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    27 = 00CC			END_PTR		EQU	$CC		; CFC_LOAD destination pointer, also used by BIOS ROM checksum routine
    28 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register (same as BIOS)
    29 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register (same as BIOS)
    30 = 00DC			BLKBUF		EQU	$DC
    31 = 00DC			BLKBUFL		EQU	$DC             ; Pointer to block buffer, same in BIOS
    32 = 00DD			BLKBUFH		EQU	$DD
    33
    34 = 00E8			STOL      	EQU   	$E8     	; Store address Low, same in BIOS
    35 = 00E9			STOH      	EQU   	$E9     	; Store address High
    36 = 00EA			PSTR            EQU     $EA		; 2-byte ACIA output pointer, same in BIOS
    37 = 00EE			PSAV            EQU     $EE             ; Saved Partition Number in ASCII, same in BIOS
    38
    39 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
    40 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
    41 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
    42
    43 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400 (same as BIOS)
    44
    45 = 1700			MMU		EQU	$1700		; ATF1504 Memory Management Unit (MMU) Register
    46
    47 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
    48 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
    49 = 180A			RETURN_VECT     EQU     $180A           ; return vector to monitor caller in V1.2.1 (was $0001 in V1.2.0)
    50
    51 = 1810			NEXTINDEX       EQU     $1810		; command index
    52 = 1811			TERM_CHAR       EQU     $1811
    53 = 1812			F_ATTRIBS       EQU     $1812
    54 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
    55 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
    56 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
    57 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
    58 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
    59 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
    60 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
    61 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
    62 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
    63 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
    64 = 1828			DBG_PRINT	EQU	$1828		; 1 = Print debug info
    65
    66 = 1C00			FILE_BUFF	EQU	$1C00		; 512 byte file buffer for .exe/.com/.bas in Monitor RAM
    67
    68 				; External Routines ************************************************************
    69
    70 = E003			MON_WARM_START  EQU     $E003
    71
    72 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    73 = E052			COUT            EQU     $E052
    74 = E05A			CROUT           EQU     $E05A
    75 = E05E			SPCOUT          EQU     $E05E
    76 = E047			CIN             EQU     $E047
    77 = E062			STRIN           EQU     $E062
    78 = E083			STROUT          EQU     $E083
    79 = E085			WRSTR           EQU     $E085
    80 = E091			HEXOUT          EQU     $E091
    81 = E09A			HEXDIG          EQU     $E09A
    82 = E0BD			DEC2STR         EQU     $E0BD
    83 = E0B5			CLRSCRN         EQU     $E0B5
    84 = E0BA			CMDDEV          EQU     $E0BA
    85 = E1AA			OPEN_DEVICE     EQU     $E1AA
    86 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    87 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    88 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    89 = FD53			SET_RAMBANK	EQU	$FD53			; BIOS v1.2.4
    90 = FD7D			MON2ROM		EQU	$FD7D			; Monitor to ROM
    91 = FD86			MON2RAM		EQU	$FD86			; Monitor to RAM, enable RAM behind it
    92
    93 				; Tables and Buffers ***********************************************************
    94 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
    95 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
    96 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
    97
    98 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor
    99 = 0420			FILE_TABLE      EQU     CURR_VOLUME+$20  	; File Descriptor Table
   100 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices
   101 = 0600			BLOCK_BUFF      EQU     $0600           	; Data Block Buffer
   102
   103 = 5930			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
   104
   105 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   106 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   107
   108 				; Device IDs *******************************************************************
   109 = 0000			NULL_ID		EQU	$00             	; the NULL device
   110 = 0022			FDD1_ID         EQU     $22             	; Floppy drive 1 device ID
   111 = 0023			FDD2_ID         EQU     $23             	; Floppy drive 2 device ID
   112 = 0024			SDC_ID		EQU     $24             	; SD-Card device ID
   113 = 0025			HDD1_ID		EQU     $25             	; CF-Card device ID
   114
   115 				; FAT Types ********************************************************************
   116 = 0002			FAT12_Type      EQU     $02
   117 = 0001			FAT16_Type      EQU     $01
   118 = 0000			FAT32_Type      EQU     $00
   119
   120 				; Device Driver Commands *******************************************************
   121 = 0022			CMD_READ	EQU	34              	; Read data block from device
   122 = 0023			CMD_WRITE	EQU	35              	; Write data block to device
   123 = 0025			CMD_READ_BUF	EQU	37              	; Read data block from device to standard buffer
   124 = 0026			CMD_WRITE_BUF	EQU	38              	; Write data block to device from standard buffer
   125
   126 				; Miscellaneous Constants ******************************************************
   127 = 000D			CR              EQU     $0D             	; Carriage Return ASCII Code
   128 = 0020			SPC             EQU     $20             	; Space ASCII Code
   129 = 005C			BSLASH          EQU     '\'             	; Backslash ASCII Code
   130 = 002F			FSLASH		EQU     '/'             	; Forward slash ASCII Code
   131 = 002E			DOT             EQU     '.'             	; Dot ASCII Code
   132 = 003A			COLON           EQU     ':'             	; Colon ASCII Code
   133 = 002C			COMMA           EQU     ','             	; Comma ASCII Code
   134 = 002D			MINUS           EQU     '-'             	; Minus ASCII Code
   135 = 005F			ULINE           EQU     '_'             	; Underline ASCII Code
   136
   137 				; Interchangeable Chars ********************************************************
   138 = 003E			PROMPT          EQU     '>'             	; Command Line Prompt Char
   139 = 002E			NUM_SEP         EQU     DOT	           	; Thousand Seperator Char
   140 = 005C			PATH_SEP        EQU     BSLASH          	; Path Seperator Char
   141 = 002F			OPT_SEP         EQU     FSLASH           	; Option Prefix Char
   142
   143 				; File Attributes **************************************************************
   144 = 0001			FA_READONLY     EQU     $01             	; file is read only
   145 = 0002			FA_HIDDEN       EQU     $02             	; file is hidden
   146 = 0004			FA_SYSTEM       EQU     $04             	; file is a system file
   147 = 0008			FA_LABEL        EQU     $08             	; file is a volume label
   148 = 0010			FA_DIRECTORY    EQU     $10             	; file is a directory
   149 = 0020			FA_ARCHIVE      EQU     $20             	; file is modified
   150 = 0040			FA_RESERVED1    EQU     $40
   151 = 0080			FA_LINK         EQU     $80             	; file is a link
   152
   153 				; Device Attributes ************************************************************
   154 = 0080			DA_DIRTY        EQU     $80             ; current FAT block is modified
   155
   156 				; Current Volume Descriptor (32 Bytes) *****************************************
   157 				; The BOOT routine in BIOS has already loaded the MBR into $0600, laoded the
   158 				; Volume-ID sector into $0400 and did set (most of) these variables.
   159 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   160 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   161 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   162 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte
   163 										;           or Partition Number in ASCII if harddisk
   164 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   165 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   166 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   167 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   168 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   169 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   170 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   171 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   172 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   173
   174 = 0420			D_SUBDIR_NAME	EQU	FILE_TABLE+$00		; 11 Bytes - Name of entire path (root dir is \)
   175 					
   176 				; Directory Descriptor (32 Bytes) **********************************************
   177
   178 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   179 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   180 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   181 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   182 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   183 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   184 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   185 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   186 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   187 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   188 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   189
   190
    66 						
    67 				.if	USE_XMODEM = 1
    68 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    69 				.endif
    70
    71 				; ******************************************************************************
    72 				; Start of 1st Block of BOOT.SYS ***********************************************
    73 				; ******************************************************************************
    74 = 4000			LOAD_ADDRESS	EQU	$4000
    75 						ORG	LOAD_ADDRESS		; the program start address
    76 				PROG_START					; Program Start Address
    77 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				;-------------------------------------------------------------------------------
    11
    12 				; subtract two clusters from START_CLUSTER address *****************************
    13 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    14 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    15 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    16 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    17 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    18 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    19 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    20 4012 A2 01		                LDX     #$01
    21 4014 A0 03		                LDY     #$03
    22 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    23 4019 E9 00		                SBC     #$00
    24 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    25 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    26 				                
    27 				; initialize current FAT block value with 0 ************************************
    28 4022 84 A4		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    29 4024 84 A5		                STY     CURR_FAT_BLK+1
    30 4026 84 A6		                STY     CURR_FAT_BLK+2
    31 4028 84 A7		                STY     CURR_FAT_BLK+3
    32 				                
    33 				; set first cluster of BOOT.SYS as the current cluster *************************
    34 402A A0 15		INIT3           LDY     #$15
    35 402C A2 03		                LDX     #$03
    36 402E 20 79 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    37 4031 A0 1B		                LDY     #$1B
    38 4033 20 79 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    39 				                
    40 				; calculate BOOTS.SYS file size in blocks **************************************
    41 4036 A9 58		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    42 4038 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    43 403B 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    44 403C 85 AB		                STA     BCNT                	; store result into block counter
    45 403E			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: macros.inc]
     1 403E A9 1F				LDA	#<BOOT_SYS_END
     2 4040 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    46 4042 E6 AB		                INC     BCNT                	; some bytes are left, so increment block counter
    47 				                
    48 				; load all blocks of BOOT.SYS file into memory *********************************
    49 4044			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 4044 C6 AB				DEC	BCNT
     2 4046 F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    50 4048 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    51 404D			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: macros.inc]
     1 404D C6 AD				DEC	SCNT
     2 404F F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    52 4051 20 86 41		                JSR     INC_32              	; no, increment block address
    53 4054			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: macros.inc]
     1 4054 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4056 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    54 4058 20 50 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    55 405B			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 405B C6 AB				DEC	BCNT
     2 405D F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    56 405F D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    57
    58 				; next cluster needs to be loaded considering the volume FAT type **************
    59 4061 20 83 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    60 4064 B0 0B		                BCS     OS_START            	; if EOF then start OS
    61 						
    62 4066 20 FD 40		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    63 4069 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    64 406E 4C 54 40		                JMP     LOAD_BLK            	; load first block of cluster
    65 				                
    66 4071 A9 00 8D 28 18	OS_START        MVA	#0 DBG_PRINT		; 0 = No debug print info
    67 4076 4C 22 42				JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 4079 20 7C 40		SET_WORD        JSR     SET_BYTE
    74 407C B1 EA 88 95 A0 CA	SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 4082 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 4083			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 4083 A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 4085 A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 4087 20 66 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 408A			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: macros.inc]
     1 408A AD 0A 04				LDA	D_FAT_TYPE
     2 408D F0 14				BEQ	FAT32
Source: boot_sys_block1.asm
    85 408F					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: macros.inc]
     1 408F C9 01				CMP	#FAT16_TYPE
     2 4091 F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 4093 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 4094 A6 A1		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 4096 20 88 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 4099 20 22 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 409C A5 A0		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 409E A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 40A0 4C C3 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 40A3			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: macros.inc]
     1 40A3 A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40A5 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40A7 20 60 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40AA A2 00 86 C7				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40AE A0 03		                LDY     #$03
   106 40B0 A5 A0		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40B2 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40B3 48			                PHA                         	; save entry index to stack
   109 40B4 36 C4 E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40B7			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 40B7 88					DEY
     2 40B8 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40BA 20 94 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40BD 20 22 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40C0 68			                PLA                         	; restore entry index
   116 40C1 A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40C3			READ_FAT_ENTRY  
   127 40C3 A0 FF 84 AA				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40C7 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40C8 A8			                TAY                         	; store entry index into Y
   130 40C9 86 AC		                STX     NCNT                	; store length of entry
   131 40CB A2 00 86 AE		                MVX     #$00 RES		;
   132 40CF 20 EF 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40D2 95 A0		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40D4 08			                PHP                         	; save carry flag
   135 40D5			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: macros.inc]
     1 40D5 E0 03				CPX	#$03
     2 40D7 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40D9 A2 0F 86 AA		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40DD			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: macros.inc]
     1 40DD C5 AA				CMP	MASK
     2 40DF D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40E1 85 AE		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40E3 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40E4 C8			                INY
   141 40E5 E8			                INX
   142 40E6			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 40E6 C6 AC				DEC	NCNT
     2 40E8 D0 E5				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40EA A5 AE		                LDA     RES
   144 40EC C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40EE 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40EF			READ_ENTRY_BYTE AND.NE  #$01 CURR_CLUSTER+1 RD_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 40EF A9 01				LDA	#$01
     3 40F1 25 A1				AND	CURR_CLUSTER+1
     4 40F3 D0 04				BNE	RD_UPPER_PAGE
Source: boot_sys_block1.asm
   152 40F5 B9 00 06		                LDA     BLOCK_BUFF,Y        			; read entry byte from lower half of block buffer
   153 40F8 60			                RTS			    			; return
   154 40F9 B9 00 07		RD_UPPER_PAGE   LDA     BLOCK_BUFF+256,Y    			; read entry byte from upper half of block buffer
   155 40FC 60			                RTS			    			; return
   156 				                
   157 				; **** Calculate LBA From Given Cluster Address ********************************
   158 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   159 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   160 				;
   161 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   162 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   163 				; ******************************************************************************
   164 40FD			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: macros.inc]
     1 40FD A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 40FF A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   165 4101 20 66 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   166 4104 AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   167 4107 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   168 4108 F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   169 						
   170 410A A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   171 410C A0 04		                LDY     #$04
   172 410E 18			                CLC
   173 410F 36 C0 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   174 4112			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 4112 88					DEY
     2 4113 D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   175 						
   176 4115 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   177 4116 D0 F2		                BNE     LOOP1		     	; 
   178 						
   179 4118			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: macros.inc]
     1 4118 A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 411A A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   180 411C 20 60 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   181 411F 4C 94 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   182
   183 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   184 				; Input: NUM32: LBA number of FAT sector to load
   185 				; ******************************************************************************
   186 4122 A2 03		LOAD_FAT_BLK    LDX     #$03
   187 4124 86 AE		                STX     RES                 	; initialize byte counter
   188 				                
   189 				; check if current FAT block and last loaded FAT block are identical ***********
   190 4126 B5 C0		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   191 4128			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: macros.inc]
     1 4128 D5 A4				CMP	CURR_FAT_BLK,X
     2 412A D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   192 						
   193 412C C6 AE		                DEC     RES                 	; if equal decrement number of unequal bytes
   194 412E 95 A4 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   195 4131 10 F3		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   196 						
   197 4133 A5 AE		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   198 4135 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   199 				                
   200 4137			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: macros.inc]
     1 4137 A5 DC			LDA	BLKBUF
     2 4139 48				PHA
     3 413A A5 DD			LDA	BLKBUF+1
     4 413C 48				PHA
Source: boot_sys_block1.asm
   201 413D			                LDXYI   NUM32
Macro: LDXYI [Source: macros.inc]
     1 413D A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 413F A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   202 4141 20 4B 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($0600)
   203 4144					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: macros.inc]
     1 4144 68				PLA
     2 4145 85 DD			STA	BLKBUF+1
     3 4147 68				PLA
     4 4148 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   204 414A 60			LOAD_FAT_END    RTS
   205 				                
   206 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   207 				; Input: [X,Y] points to 32-bit LBA
   208 				; ******************************************************************************
   209 414B A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   210 414D 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   211 				                
   212 				; **** Read Logical Block ******************************************************
   213 				; Input: [X,Y] points to 32-bit LBA
   214 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   215 				; ******************************************************************************
   216 4150 A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   217 4152 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   218 				                
   219 				; Arithmetic Functions *********************************************************
   220 				; ******************************************************************************
   221
   222 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   223 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   224 				; ******************************************************************************
   225 4155			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: macros.inc]
     1 4155 86 C0			STX	NUM32
     2 4157 84 C1			STY	NUM32+1
Source: boot_sys_block1.asm
   226 4159 A2 00 86 C2 86 C3			MWX	#0 NUM32+2		; Zero upper 16-bits
   227 415F 60			                RTS			   	; return
   228 				                
   229 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   230 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   231 				; ******************************************************************************
   232 4160 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   233 4162 A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   234 4164 D0 04		                BNE     LOAD_32_1	   	; branch always
   235
   236 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   237 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   238 				; ******************************************************************************
   239 4166 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   240 4168 A2 03		                LDX     #$03
   241 416A 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   242 416C A0 03		                LDY     #$03
   243 416E B1 E8 95 C0 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   244 4173			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 4173 88					DEY
     2 4174 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   245 4176 60			                RTS			   	; return
   246 				                
   247 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   248 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   249 				; ******************************************************************************
   250 4177			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: macros.inc]
     1 4177 86 E8			STX	STOL
     2 4179 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   251 417B A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   252 417D B9 C0 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   253 4183 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   254 4185 60			                RTS			   	; return
   255
   256 				; **** Increment a 32 Bit Value ************************************************
   257 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   258 				; ******************************************************************************
   259 4186 A2 01		INC_32          LDX     #$01
   260
   261 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   262 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   263 				; ******************************************************************************
   264 4188 A0 00		ADD_32_8        LDY     #$00
   265
   266 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   267 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   268 				; ******************************************************************************
   269 418A			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: macros.inc]
     1 418A 86 C4			STX	SUM32
     2 418C 84 C5			STY	SUM32+1
Source: boot_sys_block1.asm
   270 418E A2 00 86 C6 86 C7			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   271
   272 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   273 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   274 				; ******************************************************************************
   275 4194 18			ADD_32_32       CLC			   	; clear carry flag
   276 4195 A2 00		                LDX     #$00		   	; start with byte 0
   277 4197 08			                PHP			   	; save carry flag
   278 4198 28			ADD_LOOP        PLP			   	; get carry flag back
   279 4199 B5 C4		                LDA     SUM32,X		   	; Get SUM32 byte
   280 419B 75 C0 95 C0		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   281 419F 08			                PHP			   	; save carry flag
   282 41A0 E8			                INX			   	; next byte
   283 41A1			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: macros.inc]
     1 41A1 E0 04				CPX	#$04
     2 41A3 D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   284 41A5 28			                PLP			   	; restore stack
   285 41A6 60			                RTS			   	; return
    78 				               
    79 				; ******************************************************************************
    80 				; Start of remaining BOOT.SYS blocks *******************************************
    81 				; ******************************************************************************
    82 41A7					ORG     LOAD_ADDRESS + $0200
    83 4200			BLOCK_2
    84 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------------------------------------
     5
     6 				; ******************************************************************************
     7 				; NUM32 shl X
     8 				; ******************************************************************************
     9 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: macros.inc]
     1 4200 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4202 26 C1		        ROL     NUM32+1		  
     3 4204 26 C2		        ROL     NUM32+2
     4 4206 26 C3		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    10 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    11 420B 60			                RTS			  	; return
    12
    13 				; ******************************************************************************
    14 				; NUM32 shr X
    15 				; ******************************************************************************
    16 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: macros.inc]
     1 420C 46 C3			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 C2		        ROR     NUM32+2
     3 4210 66 C1		        ROR     NUM32+1
     4 4212 66 C0		        ROR     NUM32
Source: boot_sys_os.asm
    17 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    18 4217 60			                RTS			  	; return
    19 				                
    20 				; **** Write Logical Block From Standard Buffer ********************************
    21 				; Input: [X,Y] points to 32-bit LBA
    22 				; Note : Since this routine writes from Standard Buffer ($0600), it is not 
    23 				;        necessary to create a RAM-BANK save version of it. 
    24 				; It is called from OS_SAVE_FAT only.
    25 				; ******************************************************************************
    26 4218 A9 26		DEV_WR_LBLK_BUF  LDA    #CMD_WRITE_BUF	  	; Call Device-driver Write routine
    27 421A 4C BA E0		                 JMP    CMDDEV
    28
    29 				; **** Write Logical Block *****************************************************
    30 				; Input: [X,Y] points to 32-bit destination LBA
    31 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
    32 				; NOTE: there's also a RAM-BANK save version of this routine in Monitor RAM.
    33 				; ******************************************************************************
    34 421D A9 23		DEV_WR_LBLK	LDA     #CMD_WRITE			; Call Device-driver Write routine
    35 421F 4C BA E0		                JMP     CMDDEV				
    36
    37 				; ******************************************************************************
    38 				; *                               OS Entry Point                               *
    39 				; ******************************************************************************
    40 4222			OS_MAIN         PRSTR	MSG_BOOT			; Print boot-message
Macro: PRSTR [Source: macros.inc]
     1 4222 A2 3E			LDX	<MSG_BOOT				; MADS makes this immediate
     2 4224 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 4226 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    41 4229 20 47 49		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    42 				                
    43 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    44 422C A9 1E 8D 06 18 A9 + 		MWA	#MON_RAM_BLOCK.CFC_LOAD CF_LOAD_VEC	; CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    45 4236 A9 54 8D 08 18 A9 + 		MWA	#MON_RAM_BLOCK.CFC_SAVE CF_SAVE_VEC	; CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    46 4240 20 3D 53				JSR	CP_MON_RAM				; Copy BASIC related DOS functions to Monitor RAM
    47 4243 A9 18 8D 0A 18 A9 + 		MWA	#MON_RAM_BLOCK.DOS_JMP_RET RETURN_VECT	; Return-vector for Monitor and BASIC
    48 424D A2 00 86 01 86 02			MWX	#0 Wrmjpl				; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    49 				                
    50 				; Clear Mount Table ************************************************************
    51 4253 18			                CLC
    52 4254 A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    53 4259 8A					TXA                          		; index to mount table into A
    54 425A 69 20		                ADC     #$20                 		; set to next entry
    55 425C AA			                TAX
    56 425D 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    57 				                
    58 				; Set Boot Device As Current Device ********************************************
    59 425F A2 00		                LDX     #$00		     	; X=0
    60 4261 A0 00		                LDY     #$00                 	; set index to mount table = 0
    61 4263 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    62 4266			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: macros.inc]
     1 4266 C9 22				CMP	#FDD1_ID
     2 4268 F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    63 426A E8			                INX		     	     	; X=2
    64 426B A0 20		                LDY     #$20                 	; set index to mount table = 32
    65 426D			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: macros.inc]
     1 426D C9 23				CMP	#FDD2_ID
     2 426F F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    66 4271 E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    67 4272 A0 40		                LDY     #$40                 	; set index to mount table = 64
    68 4274 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    69
    70 				; Add Boot Device To Mount Table ***********************************************
    71 4277 A2 00		                LDX     #$00
    72 4279 BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    73 4281			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: macros.inc]
     1 4281 E0 20				CPX	#32
     2 4283 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    74 4285 A9 F8		                LDA     #$F8
    75 4287			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: macros.inc]
     1 4287 CD 09 04				CMP	D_MEDIUM_DESCR
     2 428A D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    76 428C A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    77 4291			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: macros.inc]
     1 4291 AD 0A 04				LDA	D_FAT_TYPE
     2 4294 F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    78 4296 A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    79 4298			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: macros.inc]
     1 4298 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 429B 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    80 429E					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 429E CA					DEX
     2 429F D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    81 				                
    82 				; TODO: ADD MORE DEVICES #######################################################
    83
    84 				; **** Shell Entry Point *******************************************************
    85 				; ******************************************************************************
    86 42A1 20 75 55		OS_SHELL_ENTRY  JSR	GET_SIS		     		; Get sys. info sector		
    87 42A4 4C B1 4B				JMP     SH_CMD_PROMPT			; start of command shell
    88
    89 				; **** Read First Block Of Actual Directory ************************************
    90 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    91 				; ******************************************************************************
    92 42A7			OS_FIRST_DIR_BLK
    93 42A7			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 42A7 AD 0A 04				LDA	D_FAT_TYPE
     2 42AA F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    94 42AC 20 36 49		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    95 42AF 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    96
    97 42B1					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: macros.inc]
     1 42B1 A2 03			LDX	#4-1
     2 42B3 BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42BA 10 F7			BPL	lp
Source: boot_sys_os.asm
    98 42BC AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    99 42BF D0 17		                BNE     SET_NUM_BLOCKS       		; branch always
   100
   101 42C1			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: macros.inc]
     1 42C1 A2 03			LDX	#4-1
     2 42C3 BD 04 04 95 A0 CA	lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C9 10 F8			BPL	lp
Source: boot_sys_os.asm
   102 42CB 20 FD 40		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
   103 42CE			                LDXYI   CURR_DIR_BLK			; LBA of current directory
Macro: LDXYI [Source: macros.inc]
     1 42CE A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42D0 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   104 42D2 20 77 41		                JSR     STORE_32             		; and save result as current directory block
   105 42D5 AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
   106 42D8 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
   107
   108 				; **** Load Directory Block ****************************************************
   109 				; This routine reads a directory block into DIR_BLK_BUF.
   110 				; It is called from OS_NEXT_DIR_BLK.
   111 				; ******************************************************************************
   112 42DB A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
   113 42E3					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: macros.inc]
     1 42E3 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42E5 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   114 42E7 4C 50 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
   115
   116 				; **** Read Next Directory Block ***********************************************
   117 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   118 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   119 				; ******************************************************************************
   120 42EA A2 00		OS_NEXT_DIR_BLK LDX     #$00
   121 42EC			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 42EC FE 24 18				INC	CURR_DIR_BLK,X
     2 42EF D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   122 42F1 E8			                INX                          		; overflow, increment next byte
   123 42F2			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: macros.inc]
     1 42F2 C9 04				CMP	#$04
     2 42F4 D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   124 42F6 F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   125
   126 				; **** Read Next Directory Cluster *********************************************
   127 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   128 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   129 				; ******************************************************************************
   130 42F8			OS_NEXT_DIR_CLSTR
   131 42F8 20 83 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   132 42FB 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   133 42FD 60			                RTS			     ; return
   134 				                
   135 				; **** Save Directory Block ****************************************************
   136 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   137 				; Input: X,Y = Pointer to LBA nr.
   138 				; ******************************************************************************
   139 42FE 86 D8		OS_SAVE_DIR     STX	SAVEX			; TODO: remove SAVEX, SAVEY ?
   140 4300 84 D9				STY	SAVEY
   141 4302 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; set source block buffer to DIR_BLK_BUF
   142 430A A6 D8		                LDX     SAVEX       		; pointer to block number (LBA) to be saved
   143 430C A4 D9		                LDY     SAVEY
   144 430E 4C 1D 42		                JMP     DEV_WR_LBLK          	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   145 				                
   146 				; **** Save FAT Block **********************************************************
   147 				; Write FAT table in BLOCK_BUFF ($0600) to disk with LBA nr in X,Y.
   148 				; Input: X,Y = Pointer to LBA nr.
   149 				; ******************************************************************************
   150 4311			OS_SAVE_FAT     LDXYI	CURR_FAT_BLK		; LBA nr of FAT
Macro: LDXYI [Source: macros.inc]
     1 4311 A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 4313 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   151 4315 4C 18 42		                JMP     DEV_WR_LBLK_BUF        	; write FAT buffer and return
   152
   153 				; **** Create New File on Disk *************************************************
   154 				; Input: FILENAME = String8_3
   155 				;        A        = File Attributes
   156 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   157 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   158 				; ******************************************************************************
   159 4318 AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   160 4319 A0 00		                LDY     #D_FILENAME         		; set index to filename
   161 431B B9 A5 4B 91 A8 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   162 4321			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: macros.inc]
     1 4321 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4323 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   163 						
   164 						; Write Attribute
   165 4325 8A			                TXA                         	; yes, get attribute back to A
   166 4326 91 A8		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   167 4328 A9 00		                LDA     #$00                	; and clear all following bytes to 0
   168 432A C8			                INY
   169 432B			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: macros.inc]
     1 432B C0 20				CPY	#$20			; 
     2 432D 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   170 						
   171 						; Write create-Date and Last-write Date
   172 432F 20 B9 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   173 4332 98			                TYA				; Y = MSB
   174 4333 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   175 4335 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   176 4337 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   177 4339 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   178 433C 8A			                TXA				; X = LSB
   179 433D 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   180 433F A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   181 4341 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   182
   183 						; Write create-Time and last-write Time
   184 4343 20 94 43		                JSR     OS_FILETIME         	; get current time as file time
   185 4346 98			                TYA				; Y = MSB
   186 4347 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   187 4349 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   188 434B A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   189 434D 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   190 4350 8A			                TXA				; X = LSB
   191 4351 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   192 4353 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   193 4355 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   194
   195 						; Write File Cluster Nr High and Low
   196 4357 A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   197 4359 AD 23 18 91 A8 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   198 435F AD 22 18 91 A8			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   199 4364 A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   200 4366 AD 21 18 91 A8 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   201 436C AD 20 18 91 A8			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   202 						
   203 4371 AD 12 18				LDA     F_ATTRIBS				; Get file/dir attributes again
   204 4374					AND.NE  #FA_DIRECTORY OS_CR_SAV			; create a dir? Branch if it is a dir
Macro: AND.NE [Source: macros.inc]
     6 4374 29 10				AND	#FA_DIRECTORY
     7 4376 D0 15				BNE	OS_CR_SAV
Source: boot_sys_os.asm
   205
   206 4378 A0 1C		                LDY     #D_FILE_SIZE      			; index to file size in dir. entry
   207 437A AD 66 54 91 A8 C8 + 		MWA	SAVE_LEN (CURR_DIR_ENTRY),Y+		; Save file-length in current dir. entry
   208 4386 A9 00 91 A8 C8 91 + 		MWA	#0 (CURR_DIR_ENTRY),Y			; Set high-word of file-size to 0
   209 						
   210 438D			OS_CR_SAV	LDXYI	CURR_DIR_BLK				; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: macros.inc]
     1 438D A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 438F A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   211 4391 4C FE 42		                JMP     OS_SAVE_DIR	    			; write this dir entry back to disk and return
   212 				                
   213 				; **** Get Current Time As File Time *******************************************
   214 				; Output: File Time = Word[X,Y]
   215 				; ******************************************************************************
   216 4394 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   217
   218 				; **** Convert Time To File Time ***********************************************
   219 				; Input:  A - HOUR 	in BCD ($00-$23)
   220 				;	  X - MINUTE 	in BCD ($00-$59)
   221 				;	  Y - SECONDS	in BCD ($00-$59)
   222 				; Output: File Time = Word[X,Y]
   223 				; ******************************************************************************
   224 4397			OS_TIME_TO_FILETIME
   225 4397 20 E0 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   226 439A 85 C0		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   227 439C A9 00 85 C1				MVA	#$00 NUM32+1	    ; clear upper byte of result
   228 43A0 A2 06		                LDX     #$06
   229 43A2 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   230 43A5 A5 C5		                LDA     SUM32+1             ; load MINUTE into A
   231 43A7 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   232 43AB A2 05		                LDX     #$05
   233 43AD 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   234 43B0 A5 C6		                LDA     SUM32+2             ; load SECONDS into A
   235 43B2 6A			                ROR                         ; divide SECONDS by 2
   236 43B3 05 C0		                ORA     NUM32               ; and add value into result
   237 43B5 AA			                TAX
   238 43B6 A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   239 43B8 60			                RTS
   240 				                
   241 				; **** Get Current Date As File Date *******************************************
   242 				; Output: File Date = Word[X,Y]
   243 				; ******************************************************************************
   244 43B9 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   245
   246 				; **** Convert Date To File Date ***********************************************
   247 				; Input:  A - YEAR 	in BCD ($00-$99)
   248 				; 	  X - MONTH 	in BCD ($01-$12)
   249 				; 	  Y - DAY	in BCD ($01-$31)
   250 				; Output: File Date = Word[X,Y]
   251 				; ******************************************************************************
   252 43BC			OS_DATE_TO_FILEDATE
   253 43BC 20 E0 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   254 43BF 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   255 43C2 85 C0		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   256 43C4 A9 00 85 C1		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   257 43C8 A2 04		                LDX     #$04
   258 43CA 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   259 43CD A5 C5		                LDA     SUM32+1             ; load MONTH into A
   260 43CF 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   261 43D3 A2 05		                LDX     #$05
   262 43D5 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   263 43D8 A5 C6		                LDA     SUM32+2             ; load DAY into A
   264 43DA 05 C0		                ORA     NUM32               ; and add value into result
   265 43DC AA			                TAX
   266 43DD A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   267 43DF 60			                RTS
   268 				                
   269 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   270 43E0			CONVERT_DATETIME
   271 43E0 85 C4		                STA     SUM32		    ; Year or Hour
   272 43E2					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: macros.inc]
     1 43E2 86 C5			STX	SUM32+1
     2 43E4 84 C6			STY	SUM32+1+1
Source: boot_sys_os.asm
   273 43E6 A0 02		                LDY     #$02		    ; 3 bytes to convert
   274 43E8 B9 C4 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   275 43EB 20 8F 4E		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   276 43EE 99 C4 00 88		                STA     SUM32,Y-	    ; Store result back
   277 43F2 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   278 43F4 60			                RTS			    ; return
   279
   280 				; **** Copy First block of File to memory **************************************
   281 				; Input:
   282 				; ******************************************************************************
   283 43F5 20 68 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   284 43F8					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: macros.inc]
     1 43F8 AD 5E 44				LDA	FTYPE
     2 43FB F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   285 43FD					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: macros.inc]
     1 43FD C9 01				CMP	#1
     2 43FF F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   286 						
   287 						; .EXE file (FTYPE=2)
   288 4401 AD 00 1C 8D 01 45			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   289 4407 85 CC				STA	END_PTR			; destination address LSB
   290 4409 AD 01 1C 8D 02 45			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   291 440F 85 CD				STA	END_PTR+1		; destination address MSB
   292 4411 A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   293 4415 D0 1C				BNE	COPY_BLK_DEST		; branch always
   294 						
   295 						; .COM file  (FTYPE=1)
   296 4417 A9 00 8D 01 45	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   297 441C 85 CC				STA	END_PTR			 ; destination address LSB
   298 441E A9 30 8D 02 45			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   299 4423 85 CD				STA	END_PTR+1		 ; destination address MSB
   300 4425 D0 0C				BNE	COPY_BLK_DEST		 ; branch always
   301 						
   302 						; .BAS file (FTYPE=0)
   303 4427 A9 00 85 CC A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR END_PTR	; destination = BAS_LOAD_ADDR, 1st 2 bytes contain end-address
   304 442F A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; skip first 2 bytes of .BAS file (contains $00 $20)
   305 						
   306 				; **** Copy Second and other blocks of File to Memory **************************
   307 				; Input: PSTR   : pointer to memory-source
   308 				;        END_PTR: pointer to memory-destination
   309 				; ******************************************************************************
   310 4433 AD 28 18		COPY_BLK_DEST	LDA	DBG_PRINT		; 1 = Debug print info
   311 4436 F0 23				BEQ	CPBD_NO_DBG
   312 4438					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 4438 A9 5B			LDA	#'['
     2 443A 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   313 443D					PRHEX16	PSTR
Macro: PRHEX16 [Source: macros.inc]
     1 443D A5 EB			LDA	PSTR+1				; print MSB
     2 443F 20 91 E0			JSR	HEXOUT
     3 4442 A5 EA			LDA	PSTR
     4 4444 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   314 4447					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 4447 A9 2C			LDA	#','
     2 4449 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   315 444C					PRHEX16	END_PTR
Macro: PRHEX16 [Source: macros.inc]
     1 444C A5 CD			LDA	END_PTR+1				; print MSB
     2 444E 20 91 E0			JSR	HEXOUT
     3 4451 A5 CC			LDA	END_PTR
     4 4453 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   316 4456					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4456 A9 5D			LDA	#']'
     2 4458 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   317 445B 4C 36 1E		CPBD_NO_DBG	JMP	MON_RAM_BLOCK.CP_BLK_DEST	; RAM-BANK save copy page (512 bytes)
   318 						
   319 445E 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   320
   321 				; **** Init File Buffer ********************************************************
   322 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   323 				; ******************************************************************************
   324 445F A9 00 85 DC A9 1C + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   325 4467 60					RTS				; return
   326 						
   327 				; **** Init File-buffer pointer ************************************************
   328 				; This routine sets PSTR to FILE_BUFF
   329 				; ******************************************************************************
   330 4468 A9 00 85 EA A9 1C + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   331 4470 60					RTS				; return
   332
   333 				; **** Load BAS/COM/EXE File ***************************************************
   334 				; Input: CURR_CLUSTER: cluster nr of file to load
   335 				; ******************************************************************************
   336 4471 20 49 48		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       		; check if filesize is 0
   337 4474 90 01		                BCC     OS_LOAD_COM2			; branch if file is not empty
   338 						
   339 4476 60			                RTS                         		; filesize is 0, just do nothing
   340 						
   341 4477			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      		; current cluster nr
Macro: LDXYI [Source: macros.inc]
     1 4477 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 4479 A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   342 447B 20 01 41		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   343 447E A9 00 85 AB		                MVA     #$00 BCNT              		; init. block counter
   344 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   345 4482 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   346 4487 A0 1D		                LDY     #D_FILE_SIZE+1      		; index to file size in dir. entry
   347 4489 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file size byte 1
   348 448B 4A			                LSR                         		; check if bit 0 is set (bytes 256-511 of buffer)
   349 448C 48			                PHA			    		; save byte: now contains file-size in blocks of 512 bytes
   350 448D B0 06		                BCS     LOAD_COM1           		; yes, add one block
   351 						
   352 448F 88			                DEY					; now points to D_FILE_SIZE LSB
   353 4490			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: macros.inc]
     1 4490 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4492 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   354 4494 38			                SEC                         		; yes, add one block
   355 4495 68			LOAD_COM1       PLA
   356 4496 65 AB 85 AB		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   357 449A			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: macros.inc]
     1 449A C9 59				CMP	#89			; 
     2 449C B0 28				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   358 						
   359 449E A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   360 44A0			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44A0 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44A2 D0 22				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   361 44A4 C8			                INY					; D_FILE_SIZE+3
   362 44A5			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44A5 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44A7 D0 1D				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   363 						
   364 						; Read first part of file into FILE_BUFF
   365 44A9 20 5F 44				JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   366 44AC			                LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44AC A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44AE A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   367 44B0 20 50 41		                JSR     DEV_RD_LBLK         		; Read first block of file into FILE_BUFF
   368 44B3 20 F5 43				JSR	COPY_BLK0_DEST			; Copy first block to destination
   369 44B6					DEC.EQ	BCNT OS_EXEC_CHK		; Branch if #blocks to read is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44B6 C6 AB				DEC	BCNT
     2 44B8 F0 3E				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   370 44BA					DEC.EQ  SCNT NEXT_CLUSTER0     		; Branch if sectors/cluster is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44BA C6 AD				DEC	SCNT
     2 44BC F0 2A				BEQ	NEXT_CLUSTER0
Source: boot_sys_os.asm
   371 						
   372 44BE 20 CD 44		                JSR     LOAD_NEXT_BLKS	    		; Load next blocks of file and execute it
   373 44C1 A9 25		                LDA     #HDD1_ID   	    		; Replace by D_DEV_ID?
   374 44C3 4C AA E1				JMP     OPEN_DEVICE			; Init. device driver again and return
   375 						
   376 44C6			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      		; load error message...
Macro: LDXYI [Source: macros.inc]
     1 44C6 A2 96			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 44C8 A0 4B			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   377 44CA 4C D0 49		                JMP     OS_PRINT_ERR			; Print it
   378
   379 				; **** Read Next File Blocks ***************************************************
   380 				; ******************************************************************************
   381 44CD 20 86 41		LOAD_NEXT_BLKS  JSR     INC_32              		; Increment LBA block address in NUM32
   382 44D0 20 5F 44		LOAD_BLK0       JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   383 44D3					LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44D3 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44D5 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   384 44D7 20 50 41		                JSR     DEV_RD_LBLK         		; and read next block of file into FILE_BUFF
   385 44DA 20 68 44				JSR	INIT_FBUF_PTR			; reset file-buffer pointer PSTR to FILE_BUFF again
   386 44DD 20 33 44				JSR	COPY_BLK_DEST	    		; Copy block to destination
   387 44E0			                DEC.EQ  BCNT OS_EXEC_CHK      		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 44E0 C6 AB				DEC	BCNT
     2 44E2 F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   388 44E4					DEC.NE  SCNT LOAD_NEXT_BLKS    		; branch if more blocks in cluster to read
Macro: DEC.NE [Source: macros.inc]
     1 44E4 C6 AD				DEC	SCNT
     2 44E6 D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   389
   390 				; next cluster needs to be loaded considering the volume FAT type **************
   391 44E8 20 83 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   		; Get next cluster from FAT table in CURR_CLUSTER.
   392 44EB B0 0B		                BCS     OS_EXEC_CHK	    		; C=1, EOF, go execute File
   393 							
   394 44ED 20 FD 40		                JSR     CLUSTER_TO_BLK	    		; convert CURR_CLUSTER to LBA number in NUM32.
   395 44F0 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   396 44F5 4C D0 44		                JMP     LOAD_BLK0	    		; branch always
   397 						
   398 				; Run file if needed ***********************************************************
   399 				; ******************************************************************************
   400 44F8			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: macros.inc]
     1 44F8 AD 5E 44				LDA	FTYPE
     2 44FB D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   401 44FD 60					RTS					; return in case of a .BAS file
   402
   403 				; **** Execute File ************************************************************
   404 				; Input:  Ptr[OS_PROG] to Start Address
   405 				; Output: A - Result Code
   406 				; ******************************************************************************
   407 44FE 6C 01 45		OS_EXECUTE      JMP     (OS_PROG)           		; run .com or .exe file
   408 4501 00 00		OS_PROG         .word      $0000
   409 				                
   410 				; **** Save the contents of a file to disk *************************************
   411 				; OS_CREATE/OS_CREATE_FILE has already created an entry in the current directory
   412 				; and allocated the first free cluster (in CURR_CLUSTER) to the file. If the file
   413 				; existed, it was deleted first, so you always have a new first cluster number. 
   414 				; This routine writes all sectors of this file and updates (=links clusters 
   415 				; together) the FAT table. 
   416 				; Input: FREE_CLUSTER: first cluster nr of file to save
   417 				; ******************************************************************************
   418 4503			OS_SAVE_FILE	LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 4503 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4505 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   419 4507 20 01 41		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   420 450A A9 FE 8D 92 45 A9 + 		MWA	#$1FFE FSAVE_PTR		; Init. BLKBUF to start of .BAS file to save
   421 4514 A9 00 8D FE 1F A9 + 		MWA	#$2000 $1FFE			; Set first word of Basic file to start-address
   422 451E AD 68 54 85 AB	                MVA     SAVE_SECS BCNT      		; init. block counter, SAVE_SECS was calculated by CFC_SAVE
   423 4523 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   424 4528 A9 01 8D 14 56			MVA	#1 SIS_CNT			; #clusters allocated
   425
   426 				; Write sectors/cluster until --BCNT = 0
   427 452D AD 92 45 85 DC AD + SAVE_NXT_BLK	MWA	FSAVE_PTR BLKBUF		; BLKBUF = FSAVE_PTR
   428 4537					LDXYI	NUM32				; LBA number
Macro: LDXYI [Source: macros.inc]
     1 4537 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4539 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   429 453B 20 5F 1E				JSR	MON_RAM_BLOCK.DEV_WR_LBLK	; Write another sector to disk (RAM-BANK save write)
   430 453E EE 93 45 EE 93 45		:2	INC	FSAVE_PTR+1			; BLKBUF += $0200, points to next block in memory to save
   431 4544			                DEC.EQ  BCNT OS_SAVE_X      		; branch if no more blocks to write
Macro: DEC.EQ [Source: macros.inc]
     1 4544 C6 AB				DEC	BCNT
     2 4546 F0 2F				BEQ	OS_SAVE_X
Source: boot_sys_os.asm
   432 4548					DEC.EQ  SCNT SAVE_NXT_CLSTR    		; branch if more blocks in cluster to write
Macro: DEC.EQ [Source: macros.inc]
     1 4548 C6 AD				DEC	SCNT
     2 454A F0 06				BEQ	SAVE_NXT_CLSTR
Source: boot_sys_os.asm
   433 454C 20 86 41				JSR     INC_32				; Increment LBA block address in NUM32
   434 454F 4C 2D 45				JMP	SAVE_NXT_BLK			; branch always
   435 						
   436 				; next cluster needs to be allocated considering the volume FAT type **************
   437 4552			SAVE_NXT_CLSTR	MVAX	4 FREE_CLUSTER PREV_CLUSTER	; PREV_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4552 A2 03			LDX	#4-1
     2 4554 BD 20 18 9D 78 45 + lp	MVA	FREE_CLUSTER,X PREV_CLUSTER,X-
     3 455B 10 F7			BPL	lp
Source: boot_sys_os.asm
   438 455D 20 99 47				JSR     OS_ADD_CLUSTER	   		; Find next free cluster in FAT and allocates it (does NOT write FAT back to disk)
   439 4560 20 94 45				JSR	LINK_FAT_ENTRY			; Link new FREE_CLUSTER to PREV_CLUSTER (does NOT write FAT back to disk)
   440 4563 20 11 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   441 4566 EE 14 56				INC	SIS_CNT				; #clusters allocated += 1
   442 4569					LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 4569 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 456B A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   443 456D 20 01 41		                JSR     CLSTR_TO_BLK	    		; convert FREE_CLUSTER to LBA number in NUM32.
   444 4570 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   445 4575 D0 B6		                BNE     SAVE_NXT_BLK	    		; branch always
   446
   447 4577 60			OS_SAVE_X	RTS					; Return
   448
   449 4578 00 00 00 00		PREV_CLUSTER	.dword 	$00000000			; Previous cluster nr of file
   450 457C 4C 69 6E 6B 5F 46 + TXT_LINK	.by	'Link_FAT_Entry: ' $00
   451 458D 20 74 6F 20 00	TXT_LINK2	.by	' to ' $00
   452 4592 00 00		FSAVE_PTR	.word	$0000				; File-save Pointer
   453
   454 				; ******************************************************************************
   455 				; Links a new cluster (FREE_CLUSTER) to the current cluster (PREV_CLUSTER) of a file.
   456 				; It also updates (writes) the FAT table.
   457 				; ******************************************************************************
   458 4594			LINK_FAT_ENTRY	PRSTR	TXT_LINK
Macro: PRSTR [Source: macros.inc]
     1 4594 A2 7C			LDX	<TXT_LINK				; MADS makes this immediate
     2 4596 A0 45			LDY	>TXT_LINK
Source: boot_sys_os.asm
     2 4598 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   459 459B					PRHEX32	PREV_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 459B AD 7B 45			LDA	PREV_CLUSTER+2+1				; print MSB
     2 459E 20 91 E0			JSR	HEXOUT
     3 45A1 AD 7A 45			LDA	PREV_CLUSTER+2
     4 45A4 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45A7 AD 79 45			LDA	PREV_CLUSTER+1				; print MSB
     2 45AA 20 91 E0			JSR	HEXOUT
     3 45AD AD 78 45			LDA	PREV_CLUSTER
     4 45B0 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   460 45B3					PRSTR	TXT_LINK2
Macro: PRSTR [Source: macros.inc]
     1 45B3 A2 8D			LDX	<TXT_LINK2				; MADS makes this immediate
     2 45B5 A0 45			LDY	>TXT_LINK2
Source: boot_sys_os.asm
     2 45B7 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   461 45BA					PRHEX32	FREE_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45BA AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 45BD 20 91 E0			JSR	HEXOUT
     3 45C0 AD 22 18			LDA	FREE_CLUSTER+2
     4 45C3 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45C6 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 45C9 20 91 E0			JSR	HEXOUT
     3 45CC AD 20 18			LDA	FREE_CLUSTER
     4 45CF 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   462 45D2 20 5A E0				JSR	CROUT				; Print CR
   463 45D5 AD 78 45				LDA	PREV_CLUSTER			; get LSB of PREV_CLUSTER
   464 45D8 0A 0A			:2	ASL					; SHL2, DWORD index in FAT page
   465 45DA A8					TAY					; Y = DWORD byte 0 in FAT page
   466 45DB AD 79 45				LDA	PREV_CLUSTER+1
   467 45DE 4A					LSR					; check bit 0 of PREV_CLUSTER[1]
   468 45DF B0 19				BCS	LINK_UPPER_PAGE			; if bit 0 = 1 then write byte to upper half of block
   469 						
   470 						; lower half block of Buffer
   471 45E1 AD 20 18 99 00 06 + 		MWA	FREE_CLUSTER   BLOCK_BUFF,Y	; Write CURR_CLUSTER nr into PREV_CLUSTER FAT entry
   472 45ED AD 22 18 99 02 06 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+2,Y
   473 45F9 60					RTS					; return
   474 						
   475 						; upper half block of Buffer
   476 45FA AD 20 18 99 00 07 + LINK_UPPER_PAGE	MWA	FREE_CLUSTER   BLOCK_BUFF+256,Y
   477 4606 AD 22 18 99 02 07 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+258,Y
   478 4612 60					RTS					; return
   479
   480 				; ******************************************************************************
   481 4613			INIT_FREE_CLUSTER
   482 4613 A9 02 8D 20 18 A9 + 		MWA	#$02 FREE_CLUSTER		; first data cluster is $000002
   483 461D 8D 22 18				STA     FREE_CLUSTER+2
   484 4620 8D 23 18		                STA     FREE_CLUSTER+3
   485 4623 60			                RTS
   486 				                
   487 				; ******************************************************************************
   488 				; Input: FREE_CLUSTER: number of possible free cluster
   489 				; Output: C=1: CURR_CLUSTER is free ; C=0: 
   490 				; ******************************************************************************
   491 4624			OS_NEXT_FREE_CLUSTER
   492 4624			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4624 A2 03			LDX	#4-1
     2 4626 BD 20 18 95 A0 CA	lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 462C 10 F8			BPL	lp
Source: boot_sys_os.asm
   493 462E 20 83 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   494 4631 A2 03		                LDX     #$03
   495 4633			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: macros.inc]
     1 4633 B5 A0				LDA	CURR_CLUSTER,X
     2 4635 D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   496 4637			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: macros.inc]
     1 4637 CA					DEX
     2 4638 10 F9				BPL	CHK_FREE
Source: boot_sys_os.asm
   497 463A 38			                SEC                         		; cluster is free, exit with C = 1
   498 463B 60			                RTS
   499
   500 				; ******************************************************************************
   501 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   502 				; ******************************************************************************
   503 463C A2 00		SET_NEXT_CLSTR  LDX     #$00
   504 463E			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 463E FE 20 18				INC	FREE_CLUSTER,X
     2 4641 D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   505 4643 E8			                INX						; next byte of FREE_CLUSTER
   506 4644			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4644 E0 04				CPX	#$04
     2 4646 D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   507 						
   508 4648 A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   509 464A B5 A4		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   510 464C			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: macros.inc]
     1 464C DD 18 04				CMP	D_START_FAT2,X			; 
     2 464F 90 D3				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   511 4651			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4651 CA					DEX
     2 4652 10 F6				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   512 4654 18			                CLC                         			; no emtpy cluster found, exit with error
   513 4655 60			                RTS
   514
   515 				; ******************************************************************************
   516 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   517 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   518 				; BLOCK_BUFF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   519 				; in FREE_CLUSTER needs to be allocated in the FAT table.
   520 				; ******************************************************************************
   521 4656			UPDATE_FAT_TABLE
   522 4656 AD 28 18				LDA	DBG_PRINT		; 1 = Print debug info
   523 4659 F0 16				BEQ	UPD_NO_DBG
   524 465B					PRCH	'['			; Print [
Macro: PRCH [Source: macros.inc]
     1 465B A9 5B			LDA	#'['
     2 465D 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   525 4660					PRHEX16	FREE_CLUSTER		; Print FREE_CLUSTER
Macro: PRHEX16 [Source: macros.inc]
     1 4660 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4663 20 91 E0			JSR	HEXOUT
     3 4666 AD 20 18			LDA	FREE_CLUSTER
     4 4669 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   526 466C					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 466C A9 5D			LDA	#']'
     2 466E 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   527 4671 AD 20 18		UPD_NO_DBG	LDA	FREE_CLUSTER		; get LSB of cluster nr
   528 4674 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   529 4676 A8					TAY				; Y = DWORD byte 0 in FAT page
   530 					.rept 3					; Write 3 x $FF into FAT entry
   531 						LDA	#$FF			
   532 						JSR	WRITE_ENTRY_BYTE	
   533 						INY				
   534 					.endr	
Source: REPT
   531 4677 A9 FF				LDA	#$FF			
   531 4679 20 8E 46				JSR	WRITE_ENTRY_BYTE	
   531 467C C8					INY				
   531 467D A9 FF				LDA	#$FF			
   531 467F 20 8E 46				JSR	WRITE_ENTRY_BYTE	
   531 4682 C8					INY				
   531 4683 A9 FF				LDA	#$FF			
   531 4685 20 8E 46				JSR	WRITE_ENTRY_BYTE	
   531 4688 C8					INY				
Source: boot_sys_os.asm
   535 4689 A9 0F				LDA	#$0F			; write end marker
   536 468B 4C 8E 46				JMP	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   537 						
   538 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   539 				; INPUT : A = Write Data
   540 				;         Y - Index To FAT Entry Byte
   541 				; ******************************************************************************
   542 468E			WRITE_ENTRY_BYTE
   543 468E AA					TAX
   544 468F AD 21 18		                LDA     FREE_CLUSTER+1
   545 4692 4A			                LSR				; check bit 0 of free_cluster[1]
   546 4693 8A			                TXA
   547 4694 B0 04		                BCS     WR_UPPER_PAGE       	; if bit 0 = 1 then write byte to upper half of block
   548 						
   549 4696 99 00 06		                STA     BLOCK_BUFF,Y		; write entry byte to lower half of block buffer
   550 4699 60					RTS				
   551 						
   552 469A 99 00 07		WR_UPPER_PAGE   STA     BLOCK_BUFF+256,Y	; write entry byte to upper half of block buffer
   553 469D 60					RTS
   554 				                
   555 				; **** Add Date and Time to subdir entry ***************************************
   556 				; ******************************************************************************
   557 469E			ADD_DATE_TIME	; Write create-Date and Last-write Date
   558 469E 20 B9 43				JSR     OS_FILEDATE         	; get current date as file date
   559 46A1 98			                TYA				; Y = MSB
   560 46A2 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   561 46A4 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   562 46A6 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   563 46A8 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   564 46AB 8A			                TXA				; X = LSB
   565 46AC 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   566 46AE A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   567 46B0 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   568
   569 						; Write create-Time and last-write Time
   570 46B2 20 94 43		                JSR     OS_FILETIME         	; get current time as file time
   571 46B5 98			                TYA				; Y = MSB
   572 46B6 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   573 46B8 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   574 46BA A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   575 46BC 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   576 46BF 8A			                TXA				; X = LSB
   577 46C0 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   578 46C2 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   579 46C4 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   580 46C6 60					RTS
   581 						
   582 				; **** Add new subdirectory entry to dir buffer ********************************
   583 				; Input: X=1: . subdir, X=2: .. subdir
   584 				; ******************************************************************************
   585 46C7 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   586 46C8 48					PHA					; save it
   587 46C9 A0 00				LDY	#D_FILENAME			; Filename entry
   588 46CB A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   589 46D0			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: macros.inc]
     1 46D0 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 46D2 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   590
   591 46D4 A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   592 46D8 A0 00				LDY	#D_FILENAME			; Filename entry
   593 46DA A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   594 46DC 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   595 46DF					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: macros.inc]
     1 46DF CA					DEX
     2 46E0 D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   596
   597 46E2 20 9E 46				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   598 46E5 68					PLA
   599 46E6					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: macros.inc]
     1 46E6 C9 01				CMP	#1
     2 46E8 D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   600 					
   601 						; Current subdir .: Write File Cluster Nr High and Low
   602 46EA A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   603 46EC AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   604 46F2 AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   605 46F7 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   606 46F9 AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   607 46FF AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   608 4704 60					RTS					; return
   609 						
   610 						; Parent subdir ..: Write File Cluster Nr High and Low
   611 4705 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   612 4707 AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   613 470D AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   614 4712 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   615 4714 AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   616 471A AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   617 471F 60					RTS
   618 						
   619 				; **** Add new Directory Cluster to Disk ***************************************
   620 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   621 				; ******************************************************************************
   622 4720			ADD_NEW_DIR_CLST
   623 4720 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   624 4728 A2 01				LDX	#1
   625 472A A9 00				LDA	#0
   626 472C			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: macros.inc]
     1 472C 91 DC C8				STA	(BLKBUF),Y+
     2 472F D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   627 4731 E6 DD				INC	BLKBUF+1		; next page
   628 4733					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: macros.inc]
     1 4733 CA					DEX
     2 4734 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   629 						
   630 4736 A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   631 473A A2 01				LDX	#1			; 1 = . subdir entry
   632 473C 20 C7 46				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   633 473F A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   634 4746 A2 02				LDX	#2			; 2 = .. subdir entry
   635 4748 20 C7 46				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   636
   637 						; and write it to disk
   638 474B AD 28 18				LDA	DBG_PRINT		; 1 = Debug print info
   639 474E F0 22				BEQ	AND_NO_DBG
   640 4750					PRSTR	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTR [Source: macros.inc]
     1 4750 A2 80			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 4752 A0 47			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 4754 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   641 4757					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: macros.inc]
     1 4757 AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 475A 20 91 E0			JSR	HEXOUT
     3 475D AD 22 18			LDA	FREE_CLUSTER+2
     4 4760 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 4763 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4766 20 91 E0			JSR	HEXOUT
     3 4769 AD 20 18			LDA	FREE_CLUSTER
     4 476C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   642 476F 20 5A E0				JSR	CROUT			; Print CR
   643
   644 4772			AND_NO_DBG	LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: macros.inc]
     1 4772 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4774 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   645 4776 20 01 41				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   646 4779					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: macros.inc]
     1 4779 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 477B A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   647 477D 4C FE 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   648 						
   649 4780 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   650
   651 				; **** Add First Cluster To Empty File *****************************************
   652 				; Note: does NOT write FAT table back to disk, only FAT table in memory is updated.
   653 				; ******************************************************************************
   654 4799 20 13 46		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   655 479C 20 24 46				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   656 479F 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   657 						
   658 47A1 20 56 46		                JSR     UPDATE_FAT_TABLE	; Allocate FREE_CLUSTER, does NOT write FAT block back to disk
   659 47A4 60			ADD_CLUSTER_END RTS
   660
   661 				; **** Create New File *********************************************************
   662 				; Input:  A = File Attributes
   663 				; Output: C = 0 - Error; C = 1 - No Error
   664 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   665 				; ******************************************************************************
   666 47A5 8D 12 18		OS_CREATE       STA     F_ATTRIBS           		; save attributes
   667 47A8			                AND.EQ  #FA_DIRECTORY ADD_FILE 		; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: macros.inc]
     6 47A8 29 10				AND	#FA_DIRECTORY
     7 47AA F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   668 						
   669 						; Find directory
   670 47AC 20 5E 48		                JSR     OS_DIR_EXISTS       		; C=1: dirname already exists
   671 47AF 90 21				BCC	OS_CREATE_CONT			; branch if dirname does not exist yet
   672 47B1 B0 53				BCS	OS_CREATE_ERR			; branch on error
   673
   674 						; Find file
   675 47B3 20 64 48		ADD_FILE        JSR     OS_FILE_EXISTS      		; check if file already exists
   676 47B6 90 1A				BCC	OS_CREATE_CONT			; branch if file does not exist
   677 						
   678 						; delete file (SH_DEL)	
   679 47B8					PRSTR	TXT_OVERWRITE			; Print 'File exists, overwrite (y/n)?'
Macro: PRSTR [Source: macros.inc]
     1 47B8 A2 08			LDX	<TXT_OVERWRITE				; MADS makes this immediate
     2 47BA A0 48			LDY	>TXT_OVERWRITE
Source: boot_sys_os.asm
     2 47BC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   680 47BF 20 47 E0				JSR 	CIN           			; get character
   681 47C2 29 DF				AND 	#$DF            		; uppercase chars only
   682 47C4					CMP.NE 	#'Y' OS_CREATE_ERR    		; if not Y then exit with error
Macro: CMP.NE [Source: macros.inc]
     1 47C4 C9 59				CMP	#'Y'
     2 47C6 D0 3E				BNE	OS_CREATE_ERR
Source: boot_sys_os.asm
   683 47C8					PRSTR	TXT_SH_DEL			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47C8 A2 37			LDX	<TXT_SH_DEL				; MADS makes this immediate
     2 47CA A0 48			LDY	>TXT_SH_DEL
Source: boot_sys_os.asm
     2 47CC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   684 47CF 20 B7 52				JSR	SH_DEL_FILE			; Delete file and update FAT table
   685
   686 47D2 20 99 47		OS_CREATE_CONT	JSR	OS_ADD_CLUSTER			; Return free cluster in FREE_CLUSTER (does NOT write FAT back to disk)
   687 47D5 20 11 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   688 						; Find a Free dir. entry and fill it with file info and save it to disk
   689 47D8 20 58 48				JSR 	OS_FIND_FREE			; Find a free directory entry in the current directory
   690
   691 47DB AD 28 18				LDA	DBG_PRINT			; 1 = Debug print info
   692 47DE F0 14				BEQ	OSCR_NO_DBG	
   693 47E0					PRSTR	TXT_FFREE1			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47E0 A2 26			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 47E2 A0 48			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 47E4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   694 47E7					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 47E7 A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 47E9 20 91 E0			JSR	HEXOUT
     3 47EC A5 A8			LDA	CURR_DIR_ENTRY
     4 47EE 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   695 47F1 20 5A E0				JSR	CROUT				; Print CR
   696 47F4			OSCR_NO_DBG
   697 47F4 AD 12 18		                LDA     F_ATTRIBS			; Get file/dir attributes
   698 47F7 20 18 43				JSR	OS_CREATE_FILE			; create the file/dir on disk
   699 47FA AD 12 18				LDA     F_ATTRIBS			; Get file/dir attributes again
   700 47FD					AND.EQ  #FA_DIRECTORY OS_CREATE_X	; create a file? Branch if it is a file
Macro: AND.EQ [Source: macros.inc]
     6 47FD 29 10				AND	#FA_DIRECTORY
     7 47FF F0 03				BEQ	OS_CREATE_X
Source: boot_sys_os.asm
   701 						
   702 4801 20 20 47				JSR	ADD_NEW_DIR_CLST		; Add new dir cluster with . and .. and save it to disk
   703 4804 38			OS_CREATE_X	SEC					; C=1, OK
   704 4805 60			                RTS					; and return
   705 4806 18			OS_CREATE_ERR   CLC					; C=0, error
   706 4807 60			OS_CREATE_END   RTS					; return
   707 				                
   708 4808 46 69 6C 65 20 65 + TXT_OVERWRITE	.by	'File exists, overwrite (y/n)?' $00
   709 4826 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   710 4837 44 65 6C 65 74 69 + TXT_SH_DEL	.by	'Deleting file...' CR $00
   711
   712 				; **** Test If File Is Empty ************** ************************************
   713 				; Input:  Ptr(CURR_DIR_ENTRY)
   714 				; Output: C = 1 - File is empty; C = 0 - File not empty
   715 				; ******************************************************************************
   716 4849 A2 04		OS_FILE_EMPTY   LDX     #$04
   717 484B A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   718 484D 18			                CLC
   719 484E			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: macros.inc]
     1 484E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4850 D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   720 4852 C8			                INY
   721 4853			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: macros.inc]
     1 4853 CA					DEX
     2 4854 D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   722 4856 38			                SEC			    			; C=1: File is empty
   723 4857 60			OS_FILE_EMPTY2  RTS			    			; return
   724
   725 				; **** Check If a directory entry is free or deleted ***************************
   726 				; ******************************************************************************
   727 4858			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: macros.inc]
     1 4858 A2 1E			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 485A A0 4B			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   728 485C D0 1A		                BNE     OS_FIND			; branch always
   729
   730 				; **** Check If Directory Already Exists ***************************************
   731 				; ******************************************************************************
   732 485E			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 485E A2 D2			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 4860 A0 4A			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   733 4862 D0 14		                BNE     OS_FIND			; branch always
   734 				                
   735 				; **** Check If Directory Is Available *****************************************
   736 				; ******************************************************************************
   737 4864			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 4864 A2 F6			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 4866 A0 4A			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   738 4868 D0 0E		                BNE     OS_FIND			; branch always
   739
   740 				; **** Find Directory **********************************************************
   741 				; ******************************************************************************
   742 486A			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 486A A2 D5			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 486C A0 4A			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   743 486E D0 08		                BNE     OS_FIND			; branch always
   744
   745 				; **** Find File ***************************************************************
   746 				; ******************************************************************************
   747 4870			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: macros.inc]
     1 4870 A2 F9			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 4872 A0 4A			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   748 				                                           ; fall through to OS_FIND
   749 				                                           
   750 				; **** Find All Files **********************************************************
   751 				; ******************************************************************************
   752 4874 A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   753 4876 D0 02		                BNE     OS_FIND2
   754
   755 				; **** Main Find Routine *******************************************************
   756 				; ******************************************************************************
   757 4878 A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   758 487A			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: macros.inc]
     1 487A 8E 3C 4B			STX	CMD_ADDR
     2 487D 8C 3D 4B			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   759 				                                            ; fall through to OS_DIR_LOOP
   760
   761 				; **** Loop Through Actual Directory *******************************************
   762 				; Input:  Ptr[X:Y] = Address to command specific function
   763 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   764 				; Output: C = 1 - Found; C = 0 - Not Found
   765 				; ******************************************************************************
   766 4880 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   767 4883 A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   768 488B 20 A7 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   769 488E			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 488E A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 4890 A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   770 4892			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: macros.inc]
     1 4892 86 A8			STX	CURR_DIR_ENTRY
     2 4894 84 A9			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   771 4896 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   772 4898 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   773 489A AA			                TAX                         			; load attributes into X
   774 489B A0 00		                LDY     #D_FILENAME         			; index to filename
   775 489D			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: macros.inc]
     1 489D B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 489F F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   776 48A1 20 D2 4B		                JSR     CMD_EXECUTE         			; call command routine
   777 48A4 B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   778 						
   779 48A6			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: macros.inc]
     1 48A6 AD 13 18				LDA	TERM_FLAG
     2 48A9 D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   780 48AB EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   781 48B3 A5 A8 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   782 48BA 90 DA		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   783 						
   784 48BC A9 00		                LDA     #$00
   785 48BE 65 A9 85 A9		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   786 48C2			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: macros.inc]
     1 48C2 C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 48C4 D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   787
   788 48C6			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: macros.inc]
     1 48C6 CE 1D 18				DEC	CURR_BLK_NUM
     2 48C9 D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   789 48CB			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 48CB AD 0A 04				LDA	D_FAT_TYPE
     2 48CE F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   790 48D0 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   791 48D2 B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   792
   793 48D4 20 F8 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   ; load next directory cluster from device
   794 48D7 90 B5		                BCC     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   795 48D9 B0 0D		                BCS     OS_DIR_LOOP_EOF     ; directory EOF reached. Exit
   796
   797 48DB 20 EA 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     ; load next directory block from device
   798 48DE 4C 8E 48		                JMP     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   799
   800 48E1			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        ; set pointer to upper page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 48E1 A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 48E3 A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   801 48E5 4C 92 48		                JMP     SET_CURR_ENTRY	    ; branch to begin of loop
   802
   803 48E8 18			OS_DIR_LOOP_EOF CLC			    ; C=1: not found
   804 48E9 60			OS_DIR_LOOP_END RTS			    ; return
   805
   806 				; **** Set Drive Command *******************************************************
   807 				; Input:  A = Drive Number (0..25)
   808 				; Output: C = 0 - Error
   809 				; ******************************************************************************
   810 48EA			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: macros.inc]
     1 48EA CD 1E 18				CMP	CURR_DRIVE
     2 48ED F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   811 48EF			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: macros.inc]
     1 48EF C9 08				CMP	#$08			; 
     2 48F1 B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   812 48F3 AA			                TAX                         		; save actual drive number to Y
   813 48F4 AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   814 48F7 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   815 48FC 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   816 48FE A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   817 4902					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: macros.inc]
     1 4902 A0 1F			LDY	#$20-1
     2 4904 B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 490A 10 F8			BPL	lp
Source: boot_sys_os.asm
   818 490C 8A			                TXA
   819 490D 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   820 4912 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   821 4914 A0 08		                LDY     #$08                		; set index to D_DEV_ID
   822 4916			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: macros.inc]
     1 4916 B1 E8				LDA	(STOL),Y
     2 4918 F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   823
   824 491A					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: macros.inc]
     1 491A A0 1F			LDY	#$20-1
     2 491C B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 4922 10 F8			BPL	lp
Source: boot_sys_os.asm
   825 4924 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   826 4927 AD 08 04		                LDA     D_DEV_ID            	; get current device id
   827 492A 20 AA E1		                JSR     OPEN_DEVICE         	; and open the device driver
   828 492D 38			SET_DRIVE_END   SEC			    	; C=1: no error
   829 492E 60			                RTS
   830
   831 492F			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: macros.inc]
     1 492F A2 D8			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 4931 A0 56			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   832 4933 4C D0 49		                JMP     OS_PRINT_ERR	    	; Print 'Drive not found'
   833
   834 				; **** Test If Root Directory **************************************************
   835 				; Input:
   836 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   837 				; ******************************************************************************
   838 4936 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   839 4938 B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   840 493B			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: macros.inc]
     1 493B D9 1C 04				CMP	D_START_DIR,Y
     2 493E D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   841 4940			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: macros.inc]
     1 4940 88					DEY
     2 4941 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   842 						
   843 4943 38			                SEC			     		; C=1 => is root dir.
   844 4944 60			                RTS
   845 4945 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   846 4946 60			                RTS
   847
   848 				; **** Set Root Directory Command **********************************************
   849 				; ******************************************************************************
   850 4947 A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   851 4949 BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   852 494F 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   853 4953 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   854 						
   855 4955 A9 5C 8D 20 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   856 495F 60					RTS					; return
   857
   858 				; **** Set Directory Command ***************************************************
   859 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   860 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   861 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   862 				; considered to be the root-dir and cluster number is set to 2.
   863 				; ******************************************************************************
   864 4960 AD 28 18		OS_SET_DIR      LDA	DBG_PRINT			; 1 Debug print info
   865 4963 F0 30				BEQ	SD_NO_DBG			; branch if no debug print info
   866 4965					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 4965 A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 4967 20 91 E0			JSR	HEXOUT
     3 496A A5 A8			LDA	CURR_DIR_ENTRY
     4 496C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   867 496F					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 496F A9 2C			LDA	#','
     2 4971 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   868 4974					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: macros.inc]
     1 4974 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4976 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4978 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 497B A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 497D B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 497F 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   869 4982					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: macros.inc]
     1 4982 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4984 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4986 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4989 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 498B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 498D 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   870 4990					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4990 A9 5D			LDA	#']'
     2 4992 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   871 4995 A0 15		SD_NO_DBG	LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   872 4997 A2 04		                LDX     #$04				; Copy 4 bytes
   873 4999 8E BE 49				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   874 499C CA					DEX					; Copy bytes 3..0
   875 499D 20 AB 49				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   876 49A0 A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   877 49A2 20 AB 49				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   878 49A5					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: macros.inc]
     1 49A5 AD BE 49				LDA	OS_DWORD0
     2 49A8 F0 9D				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   879 49AA 60			                RTS			     		; return
   880 				                
   881 				;-------------------------------------------------------------------------------------------------
   882 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   883 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   884 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   885 				;-------------------------------------------------------------------------------------------------
   886 49AB 20 AE 49		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   887 49AE B1 A8 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   888 49B3					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: macros.inc]
     1 49B3 9D 24 18				STA	CURR_DIR_BLK,X
     2 49B6 D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   889 49B8 CE BE 49				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   890 49BB 88			SET_BYTE_NOT0	DEY				
   891 49BC CA					DEX
   892 49BD 60					RTS				; return
   893 49BE 00			OS_DWORD0	.byte	$00
   894
   895 				; **** Read Input String *******************************************************
   896 				; Output: Null terminated string in STRBUF
   897 				; ******************************************************************************
   898 49BF 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   899 49C2 A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   900 49CA A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   901 49CF 60			                RTS
   902
   903 				; **** Print Error Message *****************************************************
   904 				; Input:  Ptr[X:Y] = Pointer to Error Message
   905 				; Output: C = 0
   906 				; ******************************************************************************
   907 49D0 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   908 49D3 18			                CLC
   909 49D4 60			                RTS
   910 				                
   911 				; **** Parse Full Path String **************************************************
   912 				; Input:  Ptr[X:Y] to Path String
   913 				; Output: C = 0 - Error; C = 1 - No Error
   914 				;         A = $00       - End Of String
   915 				;           = $FF       - Path Not Found
   916 				;           = ?         - Wildcard Included
   917 				;           = PATH_SEP  - No Trailing Name
   918 				; ******************************************************************************
   919 49D5			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: macros.inc]
     1 49D5 86 EA			STX	PSTR
     2 49D7 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   920 49D9 A0 00		                LDY     #$00
   921 49DB 8C 11 18		                STY     TERM_CHAR
   922 49DE A9 5C		                LDA     #PATH_SEP
   923 49E0			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: macros.inc]
     1 49E0 D1 EA				CMP	(PSTR),Y
     2 49E2 D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   924 49E4 20 47 49		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   925 49E7 A0 00		                LDY     #$00
   926 49E9 C8			PARSE_PATH      INY
   927 49EA			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: macros.inc]
     1 49EA B1 EA				LDA	(PSTR),Y
     2 49EC F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   928 49EE			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: macros.inc]
     1 49EE C9 20				CMP	#SPC
     2 49F0 F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   929 						
   930 49F2 20 1C 4A		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   931 49F5 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   932 						
   933 49F7			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: macros.inc]
     1 49F7 C9 5C				CMP	#PATH_SEP
     2 49F9 D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   934 49FB 84 EE		                STY     PSAV                ; save string index
   935 49FD 20 6A 48		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   936 4A00 A4 EE		                LDY     PSAV                ; restore string index
   937 4A02 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   938 4A04 B0 E3		                BCS     PARSE_PATH          ; branch always
   939 				                
   940 4A06 18			PARSE_TERM      CLC
   941 4A07			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: macros.inc]
     1 4A07 AD 11 18				LDA	TERM_CHAR
     2 4A0A D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   942 4A0C A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   943 4A11 D0 04		                BNE     PARSE_PATH_OK			; branch always
   944 				                
   945 4A13			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: macros.inc]
     1 4A13 A9 FF				LDA	#$FF
     2 4A15 D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   946 4A17 38			PARSE_PATH_OK   SEC
   947 4A18 AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   948 4A1B 60			PARSE_PATH_END2 RTS
   949
   950 				; **** Parse A Partial Path Name String ****************************************
   951 				; Input:  A = First Char Of Partial Path
   952 				;         Y = Index Into Path String
   953 				; Output: C = 0 - Error; C = 1 - No Error
   954 				;         TERM_CHAR = NULL      - Filename
   955 				;                   = ?         - Wildcard Chars Included
   956 				;                   = PATH_SEP  - Subdirectory Name
   957 				; ******************************************************************************
   958 4A1C A2 08		OS_PARSE_NAME   LDX     #8
   959 4A1E 86 AB		                STX     BCNT                	; set max char count to 8
   960 4A20 A2 00		                LDX     #$00                	; reset index to name string buffer
   961 4A22 8E 11 18		                STX     TERM_CHAR
   962 4A25			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A25 C9 2E				CMP	#DOT
     2 4A27 D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   963 4A29 9D A5 4B E8		                STA     FILENAME,X+         	; yes, store it
   964 4A2D C8			                INY
   965 4A2E B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   966 4A30			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A30 C9 2E				CMP	#DOT
     2 4A32 D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   967 4A34 9D A5 4B		SET_CHAR        STA     FILENAME,X          	; yes, store it
   968 4A37 E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   969 4A38 C8			NEXT_CHAR2      INY                         	; point to next char of input string
   970 4A39			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: macros.inc]
     1 4A39 B1 EA				LDA	(PSTR),Y
     2 4A3B F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   971 4A3D			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: macros.inc]
     1 4A3D C9 20				CMP	#SPC
     2 4A3F F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   972 4A41			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: macros.inc]
     1 4A41 C9 5C				CMP	#PATH_SEP
     2 4A43 F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   973 4A45			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: macros.inc]
     1 4A45 C9 2E				CMP	#DOT
     2 4A47 F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   974 4A49			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: macros.inc]
     1 4A49 C9 2A				CMP	#'*'
     2 4A4B F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   975
   976 4A4D			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: macros.inc]
     1 4A4D E4 AB				CPX	BCNT			; 
     2 4A4F B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   977 4A51 20 6D 4C		                JSR     UPPERCASE           	; convert chars to upper case
   978 4A54			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: macros.inc]
     1 4A54 C9 3F				CMP	#'?'
     2 4A56 D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   979 4A58 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   980 4A5B F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   981
   982 4A5D			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A5D C9 2D				CMP	#MINUS
     2 4A5F F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   983 4A61			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A61 C9 5F				CMP	#ULINE
     2 4A63 F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   984 4A65					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A65 C9 7E				CMP	#'~'
     2 4A67 F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   985 4A69					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A69 C9 30				CMP	#'0'			; 
     2 4A6B 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   986 4A6D			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A6D C9 3A				CMP	#':'			; 
     2 4A6F 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   987 4A71			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A71 C9 41				CMP	#'A'			; 
     2 4A73 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   988 4A75			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A75 C9 5B				CMP	#'['			; 
     2 4A77 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   989
   990 4A79 A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   991 4A7E 20 95 4A		                JSR     FILL_CHAR           ; fill with ? chars
   992 4A81 B0 B5		                BCS     NEXT_CHAR2          ; branch always
   993
   994 4A83 20 93 4A		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
   995 4A86 A9 0B 85 AB		                MVA     #11 BCNT            ; set max char count to 11
   996 4A8A B0 AC		                BCS     NEXT_CHAR2          ; branch always
   997
   998 4A8C 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
   999 4A8F A9 0B 85 AB		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
  1000 4A93 A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
  1001 4A95			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: macros.inc]
     1 4A95 E4 AB				CPX	BCNT			; 
     2 4A97 B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
  1002 4A99 9D A5 4B E8		                STA     FILENAME,X+         ; no, store char in name buffer
  1003 4A9D 90 F6		                BCC     FILL_CHAR           ; and repeat
  1004
  1005 4A9F AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
  1006 4AA2 60			                RTS
  1007 				                
  1008 				; **** Compare File Name With Mask *********************************************
  1009 				; Output: C = 0 - Names not equal; C = 1 - Names equal
  1010 				; ******************************************************************************
  1011 4AA3 A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
  1012 4AA5 B9 A5 4B		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
  1013 4AA8			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: macros.inc]
     1 4AA8 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4AAA D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1014 4AAC			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: macros.inc]
     1 4AAC 88					DEY
     2 4AAD 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
  1015 						
  1016 4AAF 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
  1017 4AB0 60			                RTS
  1018 4AB1 18			COMPARE_NEQ     CLC					; C=0, filename is different
  1019 4AB2 60			                RTS
  1020 				                
  1021 				; **** Delete File *************************************************************
  1022 				; Input : A - First character of filename
  1023 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
  1024 				; ******************************************************************************
  1025 4AB3			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: macros.inc]
     1 4AB3 C9 E5				CMP	#$E5
     2 4AB5 D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1026 4AB7 AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
  1027 4ABA D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
  1028
  1029 4ABC 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
  1030 4ABF					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: macros.inc]
     1 4ABF A0 05			LDY	#6-1
     2 4AC1 B9 24 18 99 CC 4A + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4AC8 10 F7			BPL	lp
Source: boot_sys_os.asm
  1031 4ACA 38			                SEC
  1032 4ACB 60			                RTS
  1033 				                
  1034 4ACC 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
  1035 4AD0 00 00		SEL_DIR_ENTRY   .byte $00, $00
  1036 				                
  1037 				; **** Directory Loop Call Back Functions **************************************
  1038 				; Input : A - First character of filename
  1039 				;         X - File Attributes
  1040 				; Output: C = 1 - File found; C = 0 - File not found
  1041 				; ******************************************************************************
  1042
  1043 				; **** Directory Exists - Call Back Routine ************************************
  1044 4AD2 20 B3 4A		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
  1045
  1046 				; **** Find Sub Directory Name - Call Back Routine *****************************
  1047 4AD5			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4AD5 E0 0F				CPX	#$0F
     2 4AD7 F0 43				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1048 4AD9 AD A5 4B		                LDA     FILENAME            	; do we search for the . directory?
  1049 4ADC			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: macros.inc]
     1 4ADC C9 2E				CMP	#DOT
     2 4ADE D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
  1050 						
  1051 4AE0 AD A6 4B		                LDA     FILENAME+1		; get next byte
  1052 4AE3			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: macros.inc]
     1 4AE3 C9 20				CMP	#SPC
     2 4AE5 F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
  1053 						
  1054 4AE7 8A			FIND_SUBDIR     TXA
  1055 4AE8			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: macros.inc]
     6 4AE8 29 10				AND	#FA_DIRECTORY
     7 4AEA F0 30				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1056 4AEC 20 A3 4A		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
  1057 4AEF 90 2C		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
  1058
  1059 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
  1060 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
  1061 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
  1062 						;    with $1C & $1D not being cluster nr bytes.
  1063 4AF1 20 60 49		                JSR     OS_SET_DIR          	; make this directory the actual directory
  1064 4AF4 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
  1065 4AF5 60			                RTS				; return
  1066 				                
  1067 				; **** File Exists - Call Back Routine *****************************************
  1068 4AF6 20 B3 4A		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
  1069
  1070 				; **** Find File Name - Call Back Routine **************************************
  1071 4AF9			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4AF9 E0 0F				CPX	#$0F
     2 4AFB F0 1F				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1072 4AFD 8A			                TXA
  1073 4AFE			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: macros.inc]
     6 4AFE 29 10				AND	#FA_DIRECTORY
     7 4B00 D0 1A				BNE	CB_FIND_END
Source: boot_sys_os.asm
  1074 4B02 20 A3 4A		                JSR     OS_COMP_NAME        			; compare name with search mask
  1075 4B05 90 16		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
  1076 						
  1077 4B07 A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
  1078 4B09 A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
  1079 4B0B B1 A8 C8 95 A0 E8	GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
  1080 4B11			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B11 E0 02				CPX	#$02			; 
     2 4B13 90 F6				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1081 4B15 A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
  1082 4B17			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B17 E0 04				CPX	#$04			; 
     2 4B19 90 F0				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1083 4B1B 60			                RTS                         			; yes, file found
  1084
  1085 4B1C 18			CB_FIND_END     CLC                         			; file not found
  1086 4B1D 60			CB_FIND_END2    RTS
  1087 				                
  1088 				; **** Find Free or Deleted Dir. Entry **************************************
  1089 4B1E			CB_FIND_FREE_DIR_ENTRY
  1090 4B1E A0 00				LDY	#D_FILENAME			; set index to filename
  1091 4B20 B1 A8				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
  1092 4B22					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: macros.inc]
     1 4B22 C9 E5				CMP	#$E5
     2 4B24 F0 09				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1093 4B26			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: macros.inc]
     1 4B26 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4B28 D0 10				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1094 4B2A C8					INY
  1095 4B2B			                CPY.CC  #D_ATTRIBUTES FFD_LP1  		; branch if not all characters copied
Macro: CPY.CC [Source: macros.inc]
     1 4B2B C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4B2D 90 F7				BCC	FFD_LP1			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
  1096 4B2F A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1097 4B31 91 A8 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1098 4B34					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: macros.inc]
     1 4B34 C0 20				CPY	#$20
     2 4B36 D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1099 						
  1100 4B38 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1101 4B39 60			                RTS                         		; return
  1102 4B3A 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1103 4B3B 60					RTS					; return
  1104
  1105 				; **** Data Area ***************************************************************
  1106 				; ******************************************************************************
  1107
  1108 				; Indirect Jump Pointer Of Current Command Address *****************************
  1109 4B3C 00 00		CMD_ADDR        .word      $0000
  1110 				                
  1111 				; String Data Area *************************************************************
  1112 4B3E 0D 20 57 65 6C 63 + MSG_BOOT        .by    CR ' Welcome to DOS65 for the JC2, V'
  1113 4B5F 30 2E 32 2E 39	                .byte  VERMAIN,DOT,VERPSUB,DOT,VERSSUB
  1114 4B64 2C 20 32 30 32 35 +                 .by    ', 2025 by Emile' CR
  1115 4B74 20 4F 72 69 67 69 + 		.by    ' Original design by Joerg Walke' CR CR $00
  1116 4B96 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1117 = 4BA5			FILENAME        .ds 	12
    85 4BB1					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------------------------------------
     5
     6 				; ******************************************************************************
     7 				; Main Loop Of Command Interpreter *********************************************
     8 				; ******************************************************************************
     9 4BB1 A9 6B 8D 3C 4B A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    10 4BBB 20 A9 4C		                JSR     PRINT_PROMPT
    11 4BBE 20 BF 49		                JSR  	OS_STRING_IN         ; read input string
    12 4BC1 20 D5 4B				JSR     GET_CMD              ; parse string
    13 4BC4 90 06				BCC     CMD_EXTERNAL
    14 						
    15 4BC6 20 D2 4B		                JSR     CMD_EXECUTE          ; execute internal command
    16 4BC9 4C B1 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    17 						
    18 4BCC 20 98 54		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    19 4BCF 4C B1 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    20 						
    21 4BD2 6C 3C 4B		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    22 						
    23 				; Get Command String ***********************************************************
    24 4BD5 20 F5 4E		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    25 4BD8 D0 03		                BNE     GET_CMD0
    26
    27 4BDA 4C 6B 4C		                JMP     CMD_FOUND            ; empty command if first char is NULL
    28
    29 4BDD 20 6D 4C		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    30 4BE0 AA			                TAX
    31 4BE1 A0 00		                LDY     #$00
    32 4BE3 8A			GET_CMD1        TXA                          	; try to find command in command table
    33 4BE4					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4BE4 D9 A2 57				CMP	CHARS,Y
     2 4BE7 F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    34 4BE9			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4BE9 B9 A2 57				LDA	CHARS,Y
     2 4BEC F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    35 4BEE 8A			                TXA
    36 4BEF C8 C8 C8		        :3      INY			     	; Y += 3
    37 4BF2 4C E3 4B		                JMP     GET_CMD1	     	; branch always
    38
    39 4BF5 C8			GET_CMD2        INY
    40 4BF6 B9 A2 57 C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    41 4BFC B9 A2 57 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    42 4C01 A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    43 4C06 A6 AC		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    44 4C08			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: macros.inc]
     1 4C08 B1 E8				LDA	(STOL),Y
     2 4C0A F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    45 4C0C 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    46 4C13 E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    47 4C14 C8			                INY                          	; point to next char in command table
    48 4C15			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: macros.inc]
     1 4C15 CC 10 18				CPY	NEXTINDEX
     2 4C18 F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    49
    50 4C1A BD 00 14		                LDA     STRBUF,X             	; load char from command string
    51 4C1D 20 6D 4C		                JSR     UPPERCASE	     	; and convert it to uppercase
    52 4C20					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4C20 D1 E8				CMP	(STOL),Y
     2 4C22 F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    53
    54 4C24 AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    55 4C27 C8 C8		        :2      INY			     	; Y += 2
    56 4C29 8C 10 18		                STY     NEXTINDEX
    57 4C2C 4C 06 4C		                JMP     GET_CMD_LOOP1	     	; branch always
    58
    59 4C2F B1 E8 8D 3C 4B C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    60 4C3A			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4C3A BD 00 14				LDA	STRBUF,X
     2 4C3D F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    61 4C3F			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: macros.inc]
     1 4C3F C9 20				CMP	#SPC
     2 4C41 F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    62 4C43 18			CMD_NOT_FOUND   CLC
    63 4C44 60			                RTS
    64 				                
    65 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    66 4C45 A6 AC		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    67 4C47 BD 00 14		                LDA     STRBUF,X
    68 4C4A 20 6D 4C		                JSR     UPPERCASE            ; convert it to upper case
    69 4C4D			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: macros.inc]
     1 4C4D C9 41				CMP	#'A'			; 
     2 4C4F 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    70 4C51			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: macros.inc]
     1 4C51 C9 5B				CMP	#'['			; 
     2 4C53 B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    71
    72 4C55 A8			                TAY
    73 4C56 BD 01 14		                LDA     STRBUF+1,X
    74 4C59			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: macros.inc]
     1 4C59 C9 3A				CMP	#':'
     2 4C5B D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    75 4C5D 38			                SEC
    76 4C5E 98			                TYA
    77 4C5F E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    78 4C61			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: macros.inc]
     1 4C61 A2 EA			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4C63 A0 48			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    79 4C65			                STXY    CMD_ADDR
Macro: STXY [Source: macros.inc]
     1 4C65 8E 3C 4B			STX	CMD_ADDR
     2 4C68 8C 3D 4B			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    80 4C6B 38			CMD_FOUND       SEC
    81 4C6C 60			                RTS
    82 				                
    83 				; **** Return Uppercase Character **********************************************
    84 				; Input:  A - Character
    85 				; Output: A - Uppercase Character
    86 				; ******************************************************************************
    87 4C6D			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: macros.inc]
     1 4C6D C9 61				CMP	#'a'			; 
     2 4C6F 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    88 4C71			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: macros.inc]
     1 4C71 C9 7B				CMP	#'z'+1			; 
     2 4C73 B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    89 4C75 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    90 4C77 60			UPPERCASE_END   RTS				; return
    91
    92 				; **** Print Two Digit Number **************************************************
    93 				; Input: A - Number (0..99)
    94 				; ******************************************************************************
    95 4C78 20 BD E0		NUMOUT          JSR     DEC2STR			; Converts into DIG0, DIG1 and DIG2
    96 4C7B A2 01		                LDX     #$01
    97 4C7D B5 F8		NEXT_NUMOUT     LDA     DIG0,X			
    98 4C7F 20 52 E0		                JSR     COUT
    99 4C82					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4C82 CA					DEX
     2 4C83 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   100 4C85 60			                RTS				; return
   101 				                
   102 				; **** Print Current Drive *****************************************************
   103 				;
   104 				; ******************************************************************************
   105 4C86 AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   106 4C89 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   107 4C8C 20 52 E0		                JSR     COUT		   ; print char
   108 4C8F A9 3A		                LDA     #COLON		   ; ':'
   109 4C91 4C 52 E0		                JMP     COUT		   ; print char and return
   110 				                
   111 				; **** Print Current Path ******************************************************
   112 				;
   113 				; ******************************************************************************
   114 4C94 A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   115 4C98 A6 D8		PR_PATH_LP	LDX	SAVEX
   116 4C9A BD 20 04				LDA     D_SUBDIR_NAME,X		; 
   117 4C9D 48					PHA
   118 4C9E 20 52 E0		                JSR     COUT		    	; print char
   119 4CA1 68					PLA
   120 4CA2 F0 04				BEQ	PR_PATH_DN		; End-of-String?
   121 						
   122 4CA4					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: macros.inc]
     1 4CA4 E6 D8				INC	SAVEX
     2 4CA6 D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   123 4CA8 60			PR_PATH_DN      RTS				; return
   124
   125 				; **** Print Drive and Path Prompt *********************************************
   126 				;
   127 				; ******************************************************************************
   128 4CA9 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   129 4CAC 20 86 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   130 4CAF 20 94 4C		                JSR     PRINT_PATH	   ; '\'
   131 4CB2 A9 3E		                LDA     #PROMPT		   ; '>'
   132 4CB4 4C 52 E0		                JMP     COUT		   ; print char and return
   133 				                
   134 				; **** Print Drive Label *******************************************************
   135 				;
   136 				; ******************************************************************************
   137 4CB7 48			PRINT_LABEL     PHA			   ; save A
   138 4CB8			                PHY			   ; save Y
Macro: PHY [Source: macros.inc]
     1 4CB8 98				TYA
     2 4CB9 48				PHA
Source: boot_sys_sh.asm
   139 4CBA			                PRSTR   MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTR [Source: macros.inc]
     1 4CBA A2 94			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4CBC A0 56			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4CBE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   140 4CC1 20 86 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   141 4CC4			                PRSTR   MSG_LABEL2	   ; ' is '
Macro: PRSTR [Source: macros.inc]
     1 4CC4 A2 A5			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4CC6 A0 56			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4CC8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4CCB 20 E1 4C		                JSR     PRINT_FILENAME1    ; print volume-label
   143 4CCE 20 5A E0		                JSR     CROUT		   ; CR 2x
   144 4CD1 20 5A E0		                JSR     CROUT
   145 4CD4					PLY			   ; restore Y
Macro: PLY [Source: macros.inc]
     1 4CD4 68				PLA
     2 4CD5 A8				TAY
Source: boot_sys_sh.asm
   146 4CD6 68			                PLA			   ; restore A
   147 4CD7 60			                RTS
   148 				                
   149 				; **** Print Filename **********************************************************
   150 				;
   151 				; ******************************************************************************
   152 4CD8 A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   153 4CDA					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CDA AD 12 18				LDA	F_ATTRIBS
     3 4CDD 29 10				AND	#FA_DIRECTORY
     4 4CDF F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   154 4CE1 A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   155 4CE3 A0 00		PRINT_FILENAME2 LDY     #$00
   156 4CE5			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: macros.inc]
     1 4CE5 C0 08				CPY	#$08
     2 4CE7 D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   157 4CE9 20 5E E0		                JSR     SPCOUT		    		; print space
   158 4CEC 8A			                TXA
   159 4CED 20 52 E0		                JSR     COUT                		; yes, print divider char
   160 4CF0 B1 A8		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   161 4CF2 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   162 4CF5 C8			                INY
   163 4CF6			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: macros.inc]
     1 4CF6 C0 0B				CPY	#D_ATTRIBUTES
     2 4CF8 D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   164 4CFA 60			                RTS			    		; return
   165 				                
   166 				; **** Print File Info *********************************************************
   167 				; Input: F_ATTRIBS = File Attributes
   168 				; ******************************************************************************
   169 4CFB			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CFB AD 12 18				LDA	F_ATTRIBS
     3 4CFE 29 10				AND	#FA_DIRECTORY
     4 4D00 F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   170 				                
   171 				; Print Directory Attribute ****************************************************
   172 4D02			                PRSTR   MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTR [Source: macros.inc]
     1 4D02 A2 AA			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4D04 A0 56			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4D06 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   173 4D09 EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   174 4D11 4C 3E 4D				JMP     PRINT_ATTRIB
   175
   176 				; Print File Size **************************************************************
   177 4D14 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   178 4D17 20 5E E0		                JSR     SPCOUT
   179 4D1A EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   180 4D22 A2 00		NO_FCNT_CARRY   LDX     #$00
   181 4D24 A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   182 4D26 18			                CLC
   183 4D27 08			                PHP
   184 4D28 28			LOAD_SIZE       PLP
   185 4D29 B1 A8 95 C0		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   186 4D2D 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   187 4D33 08			                PHP
   188 4D34 C8			                INY
   189 4D35 E8			                INX
   190 4D36					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4D36 E0 04				CPX	#$04
     2 4D38 D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   191 4D3A 28			                PLP
   192 4D3B 20 36 4E		                JSR     PRINT_INT32         		; print file size
   193 				                
   194 				; Print File Attributes ********************************************************
   195 4D3E 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   196 4D41					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: macros.inc]
     4 4D41 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4D44 29 02				AND	#(1 << 1)
     6 4D46 F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   197 4D48 A2 07		                LDX     #$07
   198 4D4A 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   199 4D4D			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: macros.inc]
     1 4D4D BD 76 57				LDA	ATTRIB_VAL,X
     2 4D50 F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   200 4D52 B0 02		                BCS     SET_ATTRIB			; branch if printable
   201
   202 4D54 A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   203 4D56 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   204 4D59			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: macros.inc]
     1 4D59 CA					DEX
     2 4D5A 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   205 4D5C 20 5E E0		                JSR     SPCOUT
   206 				                
   207 				; Print Date *******************************************************************
   208 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   209 				;              08-05 Month of year (1-12)
   210 				;              04-00 Day of month (1-32)
   211 				; ******************************************************************************
   212 4D5F A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   213 4D61 B1 A8 8D 2D 4E	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   214 4D66 29 1F		                AND     #$1F                		; mask day value
   215 4D68 8D 2E 4E		                STA     DAY
   216 4D6B C8			                INY
   217 4D6C B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   218 4D6E 4A			                LSR                         ; year in A
   219 4D6F 6E 2D 4E		                ROR     MONTH
   220 4D72 4E 2D 4E 4E 2D 4E +         :4      LSR     MONTH		    ; LSR 4
   221 4D7E 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   222 4D81 8D 2C 4E		                STA     YEAR
   223 4D84 AD 2E 4E		                LDA     DAY
   224 4D87 20 78 4C		                JSR     NUMOUT
   225 4D8A			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D8A A9 2E			LDA	#'.'
     2 4D8C 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   226 4D8F AD 2D 4E		                LDA     MONTH
   227 4D92 20 78 4C		                JSR     NUMOUT
   228 4D95			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D95 A9 2E			LDA	#'.'
     2 4D97 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   229 4D9A AC 2C 4E		                LDY     YEAR
   230 4D9D			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: macros.inc]
     1 4D9D C0 64				CPY	#100			; 
     2 4D9F 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   231
   232 4DA1 A9 14		                LDA     #20
   233 4DA3 20 78 4C		                JSR     NUMOUT
   234 4DA6 98			                TYA
   235 4DA7 38 E9 64				SUB	#100		    ; same as SEC + SBC
   236 4DAA 4C B3 4D		                JMP     PRINT_YEAR
   237
   238 4DAD A9 13		CENTURY_19      LDA     #19
   239 4DAF 20 78 4C		                JSR     NUMOUT
   240 4DB2 98			                TYA
   241 4DB3 20 78 4C		PRINT_YEAR      JSR     NUMOUT
   242 4DB6 20 5E E0		                JSR     SPCOUT
   243 				                
   244 				; Print Time *******************************************************************
   245 				; Time Format: 15-11 Hours (0-23)
   246 				;              10-05 Minutes (0-59)
   247 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   248 				; ******************************************************************************
   249 4DB9 A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   250 4DBB B1 A8 8D 2F 4E	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   251 4DC0 C8			                INY
   252 4DC1 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file last write time high byte
   253 				        .rept 3
   254 						LSR     
   255 				                ROR     MINUTE
   256 					.endr	
Source: REPT
   254 4DC3 4A					LSR     
   254 4DC4 6E 2F 4E		                ROR     MINUTE
   254 4DC7 4A					LSR     
   254 4DC8 6E 2F 4E		                ROR     MINUTE
   254 4DCB 4A					LSR     
   254 4DCC 6E 2F 4E		                ROR     MINUTE
Source: boot_sys_sh.asm
   257 4DCF 4E 2F 4E 4E 2F 4E	        :2      LSR     MINUTE
   258 4DD5 20 78 4C		                JSR     NUMOUT
   259 4DD8			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: macros.inc]
     1 4DD8 A9 3A			LDA	#':'
     2 4DDA 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   260 4DDD AD 2F 4E		                LDA     MINUTE
   261 4DE0 20 78 4C		                JSR     NUMOUT		    ; print minutes
   262
   263 				; Print Cluster Number *********************************************************
   264 				; Only with /C parameter: Prints Cluster number AND LBA number
   265 				; ******************************************************************************
   266 4DE3					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: macros.inc]
     4 4DE3 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DE6 29 08				AND	#(1 << 3)
     6 4DE8 F0 41				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   267 4DEA 20 5E E0		                JSR	SPCOUT		    			; Print space
   268 4DED					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DED A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4DEF B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DF1 85 C3				STA	NUM32+2+1
     5 4DF3 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DF6 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4DF8 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DFA 85 C2				STA	NUM32+2
     5 4DFC 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   269 4DFF					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DFF A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4E01 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4E03 85 C1				STA	NUM32+1
     5 4E05 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4E08 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4E0A B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4E0C 85 C0				STA	NUM32
     5 4E0E 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   270 4E11 20 5E E0				JSR	SPCOUT
   271 4E14 20 04 41				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   272 4E17					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 4E17 A5 C3			LDA	NUM32+2+1				; print MSB
     2 4E19 20 91 E0			JSR	HEXOUT
     3 4E1C A5 C2			LDA	NUM32+2
     4 4E1E 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4E21 A5 C1			LDA	NUM32+1				; print MSB
     2 4E23 20 91 E0			JSR	HEXOUT
     3 4E26 A5 C0			LDA	NUM32
     4 4E28 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   273 4E2B 60			PRINT_EXIT	RTS
   274
   275 4E2C 00			YEAR		.byte 	$00
   276 4E2D 00			MONTH		.byte 	$00
   277 4E2E 00			DAY 		.byte	$00
   278 4E2F 00			MINUTE		.byte 	$00
   279 				                
   280 				; **** Print 16 Bit Number *****************************************************
   281 				; Input: X,Y = Int16
   282 				; ******************************************************************************
   283 4E30 20 A4 4E		PRINT_INT16     JSR     BIN16_TO_BCD
   284 4E33 4C 39 4E		                JMP     PRINT_NUM
   285 				                
   286 				; **** Print 32 Bit Number *****************************************************
   287 				; Input: NUM32[0..3] = Int32
   288 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   289 				; ******************************************************************************
   290 4E36 20 AE 4E		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   291 4E39 A2 00		PRINT_NUM       LDX     #$00
   292 4E3B A0 0A		                LDY     #10
   293 4E3D 18			                CLC                         ; save status bits
   294 4E3E 08			PRINT_NUM1      PHP                         ; store current carry flag
   295 4E3F 20 75 4E		                JSR     PRINT_SEPARATOR
   296 4E42 BD 7E 57		                LDA     BCD_VAL,X           ; load two decimal digits
   297 4E45 48			                PHA                         ; store A
   298 4E46 98			                TYA                         ; move digit counter into A
   299 4E47 4A			                LSR                         ; bit one into carry
   300 4E48 68			                PLA                         ; restore A
   301 4E49 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   302 						
   303 4E4B E8			                INX                         ; no, process digit 2
   304 4E4C 29 0F		                AND     #$0F
   305 4E4E 10 04		                BPL     SET_DIGIT2
   306 4E50 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   307 4E54 28			SET_DIGIT2      PLP
   308 4E55 B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   309 						
   310 4E57			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: macros.inc]
     6 4E57 29 0F				AND	#$0F
     7 4E59 D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   311 4E5B 98			                TYA
   312 4E5C			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: macros.inc]
     1 4E5C C9 01				CMP	#1
     2 4E5E D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   313 4E60 A9 30		                LDA     #48                 ; yes, print 0
   314 4E62 20 9A E0		                JSR     HEXDIG
   315 4E65 18			                CLC                         ; number is 0
   316 4E66 60			                RTS
   317 						
   318 4E67 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   319 4E6A 18			                CLC
   320 4E6B 90 04		                BCC     NEXT_DIGIT	    ; branch always
   321 						
   322 4E6D 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   323 4E70 38			                SEC                         ; no more leading 0s
   324 4E71			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: macros.inc]
     1 4E71 88					DEY
     2 4E72 D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   325 4E74 60			                RTS
   326 				                
   327 				; Print Thousands Separator ****************************************************
   328 4E75 08			PRINT_SEPARATOR PHP                         ; save status bits
   329 4E76			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E76 C0 09				CPY	#$09
     2 4E78 F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   330 4E7A			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E7A C0 06				CPY	#$06
     2 4E7C F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   331 4E7E			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: macros.inc]
     1 4E7E C0 03				CPY	#$03
     2 4E80 D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   332 						
   333 4E82 28			PRINT_SEP       PLP                         ; restore status bits
   334 4E83 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   335 						
   336 4E85 A9 2E		                LDA     #NUM_SEP
   337 4E87 4C 52 E0		                JMP     COUT                ; print thousands seperator
   338 						
   339 4E8A 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   340 4E8D 28			NO_SEP          PLP                         ; clean up stack
   341 4E8E 60			                RTS
   342 				                
   343 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   344 				; INPUT:  A = BCD Number
   345 				; Output: A = Binary Number
   346 				; ******************************************************************************
   347 4E8F 85 C0		BCD_TO_BIN      STA     NUM32               ; save BCD number
   348 4E91 29 F0		                AND     #$F0                ; and clear ones digit in A
   349 4E93 4A			                LSR                         ; calc tens digit * 8
   350 4E94 85 C1		                STA     NUM32+1             ; and store result
   351 4E96 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   352 4E98 18 65 C1 85 C1			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   353 4E9D A5 C0		                LDA     NUM32               ; reload BCD number int A
   354 4E9F 29 0F		                AND     #$0F                ; and clear tens digit in A
   355 4EA1 65 C1		                ADC     NUM32+1             ; finally add both result
   356 4EA3 60			                RTS			    ; return
   357 				                
   358 				;**** Convert 16 Bit Binary Number To BCD **************************************
   359 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   360 				; OUTPUT: BCD_VAL[4..0] = Result
   361 				; ******************************************************************************
   362 4EA4			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: macros.inc]
     1 4EA4 86 C0			STX	NUM32
     2 4EA6 84 C1			STY	NUM32+1
Source: boot_sys_sh.asm
   363 4EA8 A2 00 86 C2 86 C3			MWX	#$00 NUM32+2	    ; clear upper word
   364 				                
   365 				;**** Convert 32 Bit Binary Number To BCD **************************************
   366 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   367 				; OUTPUT: BCD_VAL[4..0] = Result
   368 				;*******************************************************************************
   369 4EAE F8			BIN32_TO_BCD    SED                         ; set decimal mode
   370 4EAF A2 04		                LDX     #$04
   371 4EB1 A9 00		                LDA     #$00                ; clear BCD result value
   372 4EB3 9D 7E 57 CA		CLEAR_BCD       STA     BCD_VAL,X-
   373 4EB7 10 FA		                BPL     CLEAR_BCD
   374
   375 4EB9 A2 20		                LDX     #$20                ; 32 source bits
   376 4EBB			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: macros.inc]
     1 4EBB 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4EBD 26 C1		        ROL     NUM32+1		  
     3 4EBF 26 C2		        ROL     NUM32+2
     4 4EC1 26 C3		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   377 4EC3 AD 82 57 6D 82 57 + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   378 4ECC AD 81 57 6D 81 57 + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   379 4ED5 AD 80 57 6D 80 57 + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   380 4EDE AD 7F 57 6D 7F 57 + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   381 4EE7 AD 7E 57 6D 7E 57 + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   382 4EF0			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: macros.inc]
     1 4EF0 CA					DEX
     2 4EF1 D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   383 4EF3 D8			                CLD                         ; reset to binary mode
   384 4EF4 60			                RTS
   385
   386 				; **** Get Command String ******************************************************
   387 				;
   388 				; ******************************************************************************
   389 4EF5 A2 01		GET_CMD_STR     LDX     #$01
   390 4EF7			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4EF7 BD 00 14				LDA	STRBUF,X
     2 4EFA F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   391 4EFC			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: macros.inc]
     1 4EFC C9 20				CMP	#SPC
     2 4EFE D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   392 4F00 E8			SKIP_SPC_CHAR   INX
   393 4F01 4C F7 4E		                JMP     GET_CMD_CHAR
   394 				                
   395 				; **** Get Parameter String ****************************************************
   396 				; Output: C = 1: Parameter; C = 0: Path
   397 				;         A    = $00 : End of parameter string
   398 				;         NCNT = Index to parameter
   399 				; ******************************************************************************
   400 4F04 A6 AC		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   401 4F06 20 14 4F		                JSR     GET_PARM_CHAR
   402 4F09					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: macros.inc]
     1 4F09 C9 2F				CMP	#OPT_SEP
     2 4F0B D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   403 4F0D E8			                INX			    ; next char
   404 4F0E BD 00 14		                LDA     STRBUF,X	    ; load parameter
   405 4F11 4C 28 4F		                JMP     PARAM_STR	    ; OK and return
   406
   407 4F14			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4F14 BD 00 14				LDA	STRBUF,X
     2 4F17 F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   408 4F19					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: macros.inc]
     1 4F19 C9 20				CMP	#SPC
     2 4F1B F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   409 4F1D					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: macros.inc]
     1 4F1D C9 2F				CMP	#OPT_SEP
     2 4F1F F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   410 4F21 E8			                INX			    
   411 4F22 4C 14 4F		                JMP     GET_PARM_CHAR
   412
   413 4F25 18			PATH_STR        CLC			    ; C=0, it is a path
   414 4F26 90 01		                BCC     END_PARAM	    ; branch always
   415
   416 4F28 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   417 4F29 86 AC		END_PARAM       STX     NCNT		    ; save index in parameter string
   418 4F2B 48			                PHA
   419 4F2C 68			                PLA
   420 4F2D 60			                RTS			    ; return
   421
   422 				; **** Internal Command Handlers ***********************************************
   423
   424 				; **** Directory Loop Call Back Functions **************************************
   425 				; Input : A - First character of filename
   426 				;         X - File Attributes
   427 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   428 				; ******************************************************************************
   429
   430 				; **** Print Directory Entry - Call Back Routine *******************************
   431 4F2E			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4F2E E0 0F				CPX	#$0F
     2 4F30 F0 64				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   432 4F32					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: macros.inc]
     1 4F32 C9 E5				CMP	#$E5
     2 4F34 F0 60				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   433 4F36 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   434 4F39 8A			                TXA
   435 4F3A 4A			                LSR     
   436 4F3B 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   437 4F3C 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   438
   439 4F3E			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: macros.inc]
     4 4F3E AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F41 29 04				AND	#(1 << 2)
     6 4F43 F0 51				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   440 4F45 4A			CHK_SYSTEM      LSR                         		; check if system file
   441 4F46 4A			CHK_LABEL       LSR                         		; check if disk label
   442 				                ; #### PRINT LABEL DISABLED ####################################
   443 				                ;BCS     CB_PRINT_CONT       		; it's a label, skip to next entry
   444
   445 4F47 90 08		                BCC     PRINT_DIR_ENTRY
   446 4F49 20 B7 4C		                JSR     PRINT_LABEL         		; print disk label
   447 4F4C EE 14 18		                INC     LINE_CNT
   448 4F4F D0 2D		                BNE     CHK_LINE_COUNT     		 ; branch always
   449 				                ; ##############################################################
   450 4F51			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: macros.inc]
     1 4F51 AD 11 18				LDA	TERM_CHAR
     2 4F54 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   451 4F56 20 D5 4A		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   452 4F59 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   453
   454 4F5B A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   455 4F60 20 80 48		                JSR     OS_DIR_LOOP         		; list files of sub directory
   456 4F63 38			                SEC                         		; directory list finished
   457 4F64 60			                RTS                         		; exit
   458
   459 4F65 20 98 4F		COMP_MASK       JSR     SH_COMP_MASK
   460 4F68 90 2D		                BCC     CB_PRINT_END
   461
   462 4F6A A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   463 4F6E 20 D8 4C		                JSR     PRINT_FILENAME      		; print filename
   464 4F71 20 FB 4C		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   465 4F74 20 5A E0		                JSR     CROUT
   466 4F77			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: macros.inc]
     4 4F77 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F7A 29 01				AND	#(1 << 0)
     6 4F7C F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   467 4F7E EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   468 4F81 A9 19		                LDA     #25
   469 4F83					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: macros.inc]
     1 4F83 CD 14 18				CMP	LINE_CNT			; 
     2 4F86 B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   470 4F88 A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   471 4F8D 20 EE 52		                JSR     SH_PAUSE            		; wait for key press
   472 4F90			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4F90 C9 1B				CMP	#27
     2 4F92 D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   473 4F94 38			                SEC                         		; break dir loop
   474 4F95 60			                RTS
   475 4F96 18			CB_PRINT_CONT   CLC                         		; get next next entry
   476 4F97 60			CB_PRINT_END    RTS
   477
   478 				; **** Compare File Name With Mask Using Wildcards *****************************
   479 				;
   480 				; ******************************************************************************
   481 4F98			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: macros.inc]
     1 4F98 C9 5C				CMP	#PATH_SEP
     2 4F9A F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   482 4F9C A0 0A		                LDY     #10                 			; compare all characters
   483 4F9E B9 A5 4B		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   484 4FA1					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: macros.inc]
     1 4FA1 C9 3F				CMP	#'?'
     2 4FA3 F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   485 4FA5					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: macros.inc]
     1 4FA5 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4FA7 D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   486 						
   487 4FA9			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: macros.inc]
     1 4FA9 88					DEY
     2 4FAA 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   488 4FAC 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   489 4FAD 60			                RTS
   490 4FAE 18			COMP_NAME_NEQ   CLC
   491 4FAF 60			                RTS
   492
   493 				; ******************************************************************************
   494 				; ******************************************************************************
   495 4FB0 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   496 4FB4 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   497 				; + DRIVE
   498 				                
   499 4FB8 A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   500 4FBA B9 04 04 99 B0 4F	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   501 4FC0 B9 24 18 99 B4 4F + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   502 4FC7 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   503 4FC9 60			                RTS					; return
   504 				                
   505 4FCA A0 03		LOAD_ACT_DIR    LDY     #$03
   506 4FCC B9 B0 4F 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   507 4FD2 B9 B4 4F 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   508 4FD9 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   509 4FDB 60			                RTS					; return
   510 				                
   511 				; **** Get Parameters from Command Line ****************************************
   512 				; Input:  Ptr[X:Y] to Parameter String
   513 				; Output: C = 0 - Error; C = 1 - No Error
   514 				; ******************************************************************************
   515 4FDC 20 49 50		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   516 4FDF A9 00		                LDA     #$00                ; set current command parameter value to 0
   517 4FE1 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   518 4FE4 A0 01 84 AA		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   519 4FE8 88			                DEY                         ; param mask pointer is set to 0
   520 4FE9 20 04 4F		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   521 4FEC F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   522 4FEE B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   523 						
   524 4FF0 20 2B 50		                JSR     SH_GET_PATH         ; no, parse path parameter
   525 4FF3 B0 EF		                BCS     GET_PARM2           ; more parameters
   526
   527 4FF5 60			                RTS			    ; return
   528 						
   529 4FF6 20 6D 4C		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   530 4FF9 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   531 4FFC B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   532 4FFE			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: macros.inc]
     1 4FFE C9 20				CMP	#SPC
     2 5000 F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   533 5002					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: macros.inc]
     1 5002 CD 12 18				CMP	F_ATTRIBS
     2 5005 D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   534 5007 A5 AA		                LDA     MASK                ; load bit mask
   535 5009 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   536 500C 4C E1 4F		                JMP     GET_PARM            ; get next parameter from command line
   537
   538 500F C8			NEXT_MASK       INY                         ; point to next char in param mask
   539 5010 06 AA		                ASL     MASK                ; shift bit mask to next position
   540 5012 D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   541
   542 5014 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   543 5017			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: macros.inc]
     1 5017 A2 09			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 5019 A0 57			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   544 501B 20 D0 49		                JSR     OS_PRINT_ERR        ; and print it
   545 501E AD 12 18		                LDA     F_ATTRIBS
   546 5021 20 52 E0		                JSR     COUT                ; print unknown parameter char
   547 5024 20 5A E0		                JSR     CROUT		    ; print CR
   548 5027 18			                CLC			    ; C=0: error
   549 5028 60			                RTS
   550 5029 38			GET_PARMS_END   SEC			    ; C=1: OK
   551 502A 60			                RTS
   552 				                
   553 				; ******************************************************************************
   554 502B A6 AC		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   555 502D A0 14		                LDY     #> STRBUF
   556 502F 20 D5 49		                JSR     OS_PARSE_PATH
   557 5032 B0 14		                BCS     GET_PATH_END
   558 5034 D0 03		SH_ERROR        BNE     PARSE_ERR1
   559
   560 5036 4C 2D 55		                JMP     SH_NAME_ERR
   561
   562 5039			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: macros.inc]
     1 5039 C9 5C				CMP	#PATH_SEP
     2 503B D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   563 503D 4C 26 55		                JMP     SH_DIR_ERR
   564
   565 5040			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: macros.inc]
     1 5040 C9 FF				CMP	#$FF
     2 5042 D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   566 5044 4C 1F 55		                JMP     SH_PATH_ERR
   567 5047 18			GET_PATH_ERR    CLC
   568 5048 60			GET_PATH_END    RTS
   569
   570 				; **** Set Pointer To Parameter Mask *******************************************
   571 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   572 				; ******************************************************************************
   573 5049			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: macros.inc]
     1 5049 86 E8			STX	STOL
     2 504B 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   574 504D A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   575 5052 A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   576 5057 60			                RTS
   577
   578 				; Allowed Directory Options ****************************************************
   579 5058 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   580 505D 20			NO_PARMS        .by    ' '
   581
   582 				; **** DIR Command *************************************************************
   583 				; Prints a directory. The following optional parameters can be used:
   584 				; /P : 
   585 				; /A : Show attributes
   586 				; /H : Show hidden files
   587 				; /C : Show cluster number and LBA number
   588 				; ******************************************************************************
   589 505E 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   590 5061 20 B8 4F		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   591 5064			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: macros.inc]
     1 5064 A2 58			LDX	<DIR_PARMS				; MADS makes this immediate
     2 5066 A0 50			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   592 5068 20 DC 4F		                JSR     SH_GET_PARMS		; Get parameters from command-line
   593 506B B0 03		                BCS     SH_DIR_START		; branch if parameter found
   594
   595 506D 4C CA 4F		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   596
   597 5070 A2 00		SH_DIR_START    LDX     #$00
   598 5072 8A			                TXA
   599 5073 8D 14 18		                STA     LINE_CNT            	; reset line counter
   600 5076 85 EE		                STA     PSAV                	; reset file found flag
   601 5078 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   602 507C			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: macros.inc]
     1 507C E0 08				CPX	#$08
     2 507E D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   603 5080			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: macros.inc]
     1 5080 A2 2E			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 5082 A0 4F			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   604 5084 20 74 48		                JSR     OS_FIND_ALL         	; find and print directory entries
   605 5087 20 CA 4F		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   606 508A			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: macros.inc]
     1 508A A5 EE				LDA	PSAV
     2 508C D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   607 508E 4C 18 55		                JMP     SH_FILE_ERR         	; no, print error
   608
   609 5091 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   610 5094 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   611 509A 20 7E 4F		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   612 				                
   613 				; Print Total File Count
   614 509D			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: macros.inc]
     1 509D AE 15 18			LDX	CURR_FILE_CNT
     2 50A0 AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   615 50A3 20 30 4E		                JSR     PRINT_INT16		; print as word
   616 50A6			                PRSTR   MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTR [Source: macros.inc]
     1 50A6 A2 BA			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 50A8 A0 56			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 50AA 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   617
   618 				; Print Total Used Bytes In Directory
   619 50AD			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: macros.inc]
     1 50AD A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 50AF A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   620 50B1 20 66 41		                JSR     LOAD_32			; NUM32 = total filesize
   621 50B4 20 36 4E		                JSR     PRINT_INT32		; print as int32
   622 50B7			                PRSTR   MSG_BYTE_USED		; print ' bytes'
Macro: PRSTR [Source: macros.inc]
     1 50B7 A2 D0			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 50B9 A0 56			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 50BB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   623
   624 				; Print Total Directory Count
   625 50BE					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: macros.inc]
     1 50BE AE 17 18			LDX	CURR_DIR_CNT
     2 50C1 AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   626 50C4 20 30 4E		                JSR     PRINT_INT16		; Print as word
   627 50C7			                PRSTR   MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTR [Source: macros.inc]
     1 50C7 A2 C5			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 50C9 A0 56			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 50CB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   628 50CE					MVAX	4 FREE_KB NUM32		; NUM32 = #Free KB
Macro: MVAX [Source: macros.inc]
     1 50CE A2 03			LDX	#4-1
     2 50D0 BD F1 55 95 C0 CA	lp	MVA	FREE_KB,X NUM32,X-
     3 50D6 10 F8			BPL	lp
Source: boot_sys_sh.asm
   629 50D8 20 36 4E				JSR	PRINT_INT32		; Print as decimal number
   630 50DB					PRSTR	TXT_KB			; Print ' KB free'
Macro: PRSTR [Source: macros.inc]
     1 50DB A2 0A			LDX	<TXT_KB				; MADS makes this immediate
     2 50DD A0 56			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 50DF 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   631 50E2 60					RTS				; return
   632 						
   633 				; **** Create Directory (MKDIR) Command ****************************************
   634 				;
   635 				; ******************************************************************************
   636 50E3 20 B8 4F		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   637 50E6			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: macros.inc]
     1 50E6 A2 5D			LDX	<NO_PARMS				; MADS makes this immediate
     2 50E8 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   638 50EA 20 DC 4F		                JSR     SH_GET_PARMS        	; get path
   639 50ED 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   640
   641 50EF A9 10		                LDA     #FA_DIRECTORY		; create directory
   642 50F1 20 A5 47		                JSR     OS_CREATE           	; create directory
   643 50F4 B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   644
   645 50F6			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: macros.inc]
     1 50F6 C9 FF				CMP	#$FF
     2 50F8 F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   646
   647 50FA 20 3B 55		                JSR     SH_WRITE_ERR        	; it was a write error
   648 50FD 90 03		                BCC     SH_MKDIR_END        	; branch always
   649
   650 50FF 20 34 55		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   651 5102 4C CA 4F		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   652
   653 				; **** Check if Current Dir. ***************************************************
   654 				; Check if directory entered is current dir (..).
   655 				; Output: C=0: not a current dir, C=1: is current dir.
   656 				; ******************************************************************************
   657 5105 A0 00		IS_FNAME_CURDIR	LDY	#0
   658 5107 B9 A5 4B				LDA	FILENAME,Y
   659 510A					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 510A C9 2E				CMP	#'.'
     2 510C D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   660 510E C8					INY
   661 510F					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: macros.inc]
     1 510F B9 A5 4B				LDA	FILENAME,Y
     2 5112 D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   662 5114 F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   663
   664 				; **** Check if Parent Dir. ************************************************
   665 				; Check if current directory is parent dir (..).
   666 				; Output: C=0: not a parent dir, C=1: is parent dir.
   667 				; ******************************************************************************
   668 5116 A0 00		IS_FNAME_PARENT	LDY	#0
   669 5118 B9 A5 4B				LDA	FILENAME,Y
   670 511B					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 511B C9 2E				CMP	#'.'
     2 511D D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   671 511F C8					INY
   672 5120 B9 A5 4B				LDA	FILENAME,Y
   673 5123					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5123 C9 2E				CMP	#'.'
     2 5125 D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   674 5127 C8					INY
   675 5128					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: macros.inc]
     1 5128 B9 A5 4B				LDA	FILENAME,Y
     2 512B D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   676
   677 512D 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   678 512E 60					RTS
   679 512F 18			NOT_FNAME	CLC				; The filename is not . or ..
   680 5130 60					RTS
   681 						
   682 				; **** Convert filename to FN83 type filename **********************************
   683 				; INPUT: ssptr_l/ssptr_h pointer to filename
   684 				; OUTPUT: converted filename in FN83
   685 				; ******************************************************************************
   686 5131 A0 00		FNAME2FN83	LDY	#0
   687 5133 B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   688 5135					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: macros.inc]
     1 5135 C9 2E				CMP	#'.'
     2 5137 F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   689 						
   690 5139 C8			CPFNCNT		INY
   691 513A					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: macros.inc]
     1 513A C0 0B				CPY	#D_ATTRIBUTES
     2 513C D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   692 513E F0 18				BEQ	EXT_DN			; branch always if no dot was found
   693
   694 5140			FN83_DOTFND	; Found a dot
   695 5140 A2 08				LDX	#8
   696 5142 C8					INY				; points to char next to '.'
   697 5143 B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get char of extension
   698 5145 20 6D 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   699 5148					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: macros.inc]
     1 5148 9D A5 4B				STA	FILENAME,X
     2 514B F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   700 514D C8					INY
   701 514E E8					INX
   702 514F					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: macros.inc]
     1 514F E0 0B				CPX	#D_ATTRIBUTES
     2 5151 D0 F0				BNE	CPFN83_2
Source: boot_sys_sh.asm
   703 						
   704 5153 A9 00 9D A5 4B			MVA	#0 FILENAME,X		; Add '\0' to filename
   705 5158 A0 00		EXT_DN		LDY	#0
   706 515A B1 78		CPFN83_3	LDA	(ssptr_l),Y		; Get char of Filename
   707 515C 20 6D 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   708 515F 99 A5 4B				STA	FILENAME,Y		; Store in result
   709 5162					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: macros.inc]
     1 5162 C9 2E				CMP	#'.'
     2 5164 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   710 5166 C8					INY
   711 5167					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5167 C0 08				CPY	#8
     2 5169 D0 EF				BNE	CPFN83_3
Source: boot_sys_sh.asm
   712 516B 60					RTS				; return
   713 						
   714 516C A9 20 99 A5 4B C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   715 5172					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5172 C0 08				CPY	#8
     2 5174 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   716 5176 60			CPFN_DN		RTS				; return
   717 						
   718 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   719 				; Check if directory entered is current dir (..).
   720 				; Output: C=0: not a current dir, C=1: is current dir.
   721 				; ******************************************************************************
   722 5177 A0 00		ADD_SUBDIR_NAME	LDY	#0
   723 5179			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5179 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 517C F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   724 517E C8					INY
   725 517F D0 F8				BNE	FIND_EOS			; branch always
   726 5181 60					RTS
   727
   728 5182			SUBDIR_EOS	CPY.EQ	#1 CP_INIT			; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 5182 C0 01				CPY	#1
     2 5184 F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   729 5186 A9 5C 99 20 04			MVA	#BSLASH D_SUBDIR_NAME,Y		; add '\' to subdir name
   730 518B C8					INY
   731 518C A2 00		CP_INIT		LDX	#0
   732 518E BD A5 4B 99 20 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   733 5194 F0 06				BEQ	SUBDIR_X			; exit if $00 found
   734 						
   735 5196 C8					INY					; index in D_SUBDIR_NAME
   736 5197 E8					INX					; index in FILENAME
   737 5198					CPX.NE	#D_ATTRIBUTES CP_FNAME		; branch if not at max filename yet
Macro: CPX.NE [Source: macros.inc]
     1 5198 E0 0B				CPX	#D_ATTRIBUTES
     2 519A D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   738 519C 60			SUBDIR_X	RTS					; return if done
   739 						
   740 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   741 				; ******************************************************************************
   742 519D A0 00		DEL_SUBDIR_NAME	LDY	#0
   743 519F			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_LP1	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 519F B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 51A2 F0 04				BEQ	SUBDIR_LP1
Source: boot_sys_sh.asm
   744 51A4 C8					INY
   745 51A5 D0 F8				BNE	FIND_EOS2			; branch always
   746 51A7 60			DEL_SUBDIR_X	RTS
   747
   748 51A8 B9 20 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y			; get char from D_SUBDIR_NAME
   749 51AB					CMP.EQ	#BSLASH BSLASH_FND		; branch if filename separator found
Macro: CMP.EQ [Source: macros.inc]
     1 51AB C9 5C				CMP	#BSLASH
     2 51AD F0 04				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   750 51AF					DEY.NE	SUBDIR_LP1			; branch always
Macro: DEY.NE [Source: macros.inc]
     1 51AF 88					DEY
     2 51B0 D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   751 51B2 C8					INY					; Y = 0->1, leave '\' for root-dir
   752 51B3 A9 00 99 20 04	BSLASH_FND	MVA	#0 D_SUBDIR_NAME,Y		; Replace '\' with \0 for subdirs in D_SUBDIR_NAME
   753 51B8 60			DSNM_X		RTS					; and return
   754
   755 				; **** Change Directory Command ************************************************
   756 				;
   757 				; ******************************************************************************
   758 51B9 20 B8 4F		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   759 51BC			                LDXYI   NO_PARMS
Macro: LDXYI [Source: macros.inc]
     1 51BC A2 5D			LDX	<NO_PARMS				; MADS makes this immediate
     2 51BE A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   760 51C0 20 DC 4F		                JSR     SH_GET_PARMS		; get subdir name
   761 51C3 90 26		                BCC     SH_CD_END		; C=0: no name entered
   762
   763 51C5			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: macros.inc]
     1 51C5 AD 11 18				LDA	TERM_CHAR
     2 51C8 D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   764 51CA 20 6A 48		                JSR     OS_FIND_PATH		; loop through dir to find path
   765 51CD 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   766 						
   767 51CF A0 00				LDY	#0			; add '\0' to string
   768 51D1 B9 A5 4B		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   769 51D4					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: macros.inc]
     1 51D4 C9 20				CMP	#' '
     2 51D6 F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   770 51D8 C8					INY
   771 51D9					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: macros.inc]
     1 51D9 C0 0B				CPY	#D_ATTRIBUTES
     2 51DB D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   772 						
   773 51DD A9 00 99 A5 4B	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   774 51E2 20 16 51				JSR	IS_FNAME_PARENT		; is dir .. ?
   775 51E5 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   776 						
   777 51E7 20 9D 51				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   778 51EA 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   779 51EB 60			SH_CD_END	RTS
   780
   781 51EC 20 05 51		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   782 51EF B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   783 						
   784 51F1 20 77 51				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   785 51F4 4C EA 51				JMP	SH_CD_EXIT_OK		; branch always
   786 						
   787 51F7 20 CA 4F		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   788 51FA 20 5A E0		                JSR     CROUT			; print CR
   789 51FD 4C 1F 55		                JMP     SH_PATH_ERR		; Print 'Path not found'
   790
   791 				; **** Release the FAT clusters for a file  ************************************
   792 				; Algorithm:
   793 				;       SCNT = 1;
   794 				; loop: CURR_CLUSTER = FAT[CURR_CLUSTER];
   795 				;       FAT[CURR_CLUSTER] = 0L; // 0L = free entry
   796 				;       if (CURR_CLUSTER == 0FFFFFFF) SCNT++; goto loop;
   797 				; ******************************************************************************
   798 5200 A2 00 8E 14 56	CLR_FAT32_FILE 	MVX 	#0 SIS_CNT			; #clusters cleared
   799 5205			CLR_FAT32_LP1	LDXYI   D_START_FAT1      		; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 5205 A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 5207 A0 04			LDY	>D_START_FAT1
Source: boot_sys_sh.asm
   800 5209 20 66 41		                JSR     LOAD_32		    		; NUM32 = LBA nr. of FAT
   801 520C					LDXYI	(CURR_CLUSTER+1)			; SUM32 = CURR_CLUSTER into SUM32
Macro: LDXYI [Source: macros.inc]
     1 520C A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 520E A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_sh.asm
   802 5210 20 60 41				JSR     LOAD_S32            		; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   803 5213 20 75 52				JSR	PRTST1				; DEBUG
   804 5216 A2 00 86 C7				MVX	#$00 SUM32+3			; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   805 521A A0 03		                LDY     #$03
   806 521C A5 A0		                LDA     CURR_CLUSTER        		; load CURR_CLUSTER[0] = FAT entry index byte
   807 521E 0A			                ASL                         		; shift bit 7 into carry flag and multiply entry index by 2
   808 521F 48			                PHA                         		; save entry index to stack
   809 5220 36 C4 E8		CLR32_LP        ROL     SUM32,X+             		; shift bit 7 of entry index into bit 0 of block index
   810 5223			                DEY.NE  CLR32_LP	    		; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 5223 88					DEY
     2 5224 D0 FA				BNE	CLR32_LP
Source: boot_sys_sh.asm
   811 						
   812 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   813 5226 20 94 41		                JSR     ADD_32_32	    		; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   814 5229 20 22 41		                JSR     LOAD_FAT_BLK	    		; Load FAT sector into standard buffer ($600)
   815 522C 68			                PLA                         		; restore entry index
   816 522D A2 04		                LDX     #$04                		; four bytes to read for a FAT32 entry
   817 522F 0A			                ASL                         		; multiply entry index by 2 (4 in total now)
   818 5230 A8			                TAY                         		; store entry index into Y
   819 5231 20 91 E0				JSR	HEXOUT				; DEBUG
   820 5234 A2 04 86 AC		                MVX	#4 NCNT				; 1 FAT entry = 4 bytes
   821 5238 A2 00				LDX	#0				; init. CURR_CLUSTER index
   822 523A 20 EF 40		LP_FAT_ENTRY    JSR     READ_ENTRY_BYTE     		; read entry byte
   823 523D 9D 71 52				STA     TEMP_CLUSTER,X      		; store byte in TEMP_CLUSTER to follow link
   824 5240 20 94 52				JSR	WR_ENTRY_BYTE			; FAT[CURR_CLUSTER] = 0
   825 5243 C8					INY					; Increment FAT index counter
   826 5244 E8			                INX					; Increment CURR_CLUSTER counter
   827 5245			                DEC.NE  NCNT LP_FAT_ENTRY   		; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 5245 C6 AC				DEC	NCNT
     2 5247 D0 F1				BNE	LP_FAT_ENTRY
Source: boot_sys_sh.asm
   828 5249					MVAX	4 TEMP_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = TEMP_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 5249 A2 03			LDX	#4-1
     2 524B BD 71 52 95 A0 CA	lp	MVA	TEMP_CLUSTER,X CURR_CLUSTER,X-
     3 5251 10 F8			BPL	lp
Source: boot_sys_sh.asm
   829 5253 EE 14 56				INC	SIS_CNT				; #clusters cleared + 1
   830 5256 A9 0F C5 A3 D0 10 + 		CPD	#$0FFFFFFF CURR_CLUSTER		; CURR_CLUSTER == $0FFFFFFF ?
   831 526C D0 97				BNE	CLR_FAT32_LP1			; branch if file has more clusters to clear
   832 						
   833 526E 4C 11 43				JMP	OS_SAVE_FAT			; Write updated FAT buffer back to disk and return
   834
   835 5271 00 00 00 00		TEMP_CLUSTER	.dword	$00000000
   836 						
   837 5275			PRTST1		PRCH	'<'
Macro: PRCH [Source: macros.inc]
     1 5275 A9 3C			LDA	#'<'
     2 5277 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   838 527A					PRHEX32	CURR_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 527A A5 A3			LDA	CURR_CLUSTER+2+1				; print MSB
     2 527C 20 91 E0			JSR	HEXOUT
     3 527F A5 A2			LDA	CURR_CLUSTER+2
     4 5281 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5284 A5 A1			LDA	CURR_CLUSTER+1				; print MSB
     2 5286 20 91 E0			JSR	HEXOUT
     3 5289 A5 A0			LDA	CURR_CLUSTER
     4 528B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   839 528E					PRCH	'>'
Macro: PRCH [Source: macros.inc]
     1 528E A9 3E			LDA	#'>'
     2 5290 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   840 5293 60					RTS
   841
   842 				; **** Write a Single FAT Entry Byte From Block Buffer *************************
   843 				; INPUT : Y - Index To FAT Entry Byte
   844 				; OUTPUT: A = Read Byte from FAT table
   845 				; ******************************************************************************
   846 5294			WR_ENTRY_BYTE 	AND.NE  #$01 CURR_CLUSTER+1 CLR_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 5294 A9 01				LDA	#$01
     3 5296 25 A1				AND	CURR_CLUSTER+1
     4 5298 D0 06				BNE	CLR_UPPER_PAGE
Source: boot_sys_sh.asm
   847 529A A9 00 99 00 06	                MVA	#0 BLOCK_BUFF,Y				; write entry byte from lower half of block buffer
   848 529F 60			                RTS			    			; return
   849 52A0 A9 00 99 00 07	CLR_UPPER_PAGE  MVA     #0 BLOCK_BUFF+256,Y    			; write entry byte from upper half of block buffer
   850 52A5 60			                RTS			    			; return
   851
   852 				; **** Delete Command **********************************************************
   853 				;
   854 				; ******************************************************************************
   855 52A6 20 B8 4F		SH_DEL          JSR     SAVE_ACT_DIR        			; save actual directory LBA
   856 52A9			                LDXYI   NO_PARMS          			; we don't need parameters, just the filename
Macro: LDXYI [Source: macros.inc]
     1 52A9 A2 5D			LDX	<NO_PARMS				; MADS makes this immediate
     2 52AB A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   857 52AD 20 DC 4F		                JSR     SH_GET_PARMS        			; get path
   858 52B0 90 33		                BCC     SH_DEL_X	    			; branch if no filename was given
   859
   860 52B2 20 70 48		                JSR     OS_FIND_FILE				; Now find file to delete
   861 52B5 90 31		                BCC     SH_DEL_ERR				; branch if file not found
   862
   863 						; OS_FIND_FILE did already set CURR_CLUSTER to the file starting-cluster
   864 52B7 A0 00		SH_DEL_FILE	LDY	#D_FILENAME
   865 52B9 A9 E5 91 A8				MVA	#$E5 (CURR_DIR_ENTRY),Y			; $E5 first char. is a deleted file
   866 52BD A0 14				LDY	#D_START_CLSTH
   867 52BF A9 00 91 A8 C8 91 + 		MWA	#$00 (CURR_DIR_ENTRY),Y			; delete high word of file-size
   868 52C6					PRHEX16	CURR_DIR_BLK
Macro: PRHEX16 [Source: macros.inc]
     1 52C6 AD 25 18			LDA	CURR_DIR_BLK+1				; print MSB
     2 52C9 20 91 E0			JSR	HEXOUT
     3 52CC AD 24 18			LDA	CURR_DIR_BLK
     4 52CF 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   869 52D2					LDXYI	CURR_DIR_BLK				; CURR_DIR_BLK is LBA of current dir block
Macro: LDXYI [Source: macros.inc]
     1 52D2 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 52D4 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_sh.asm
   870 52D6 20 FE 42		                JSR     OS_SAVE_DIR	    			; write this dir entry back to disk
   871 						
   872 52D9 20 00 52				JSR	CLR_FAT32_FILE				; Set all FAT entries for this file to 00000000 (free)
   873 52DC 20 13 46				JSR	INIT_FREE_CLUSTER			; FREE_CLUSTER = 2L
   874 52DF 20 24 46				JSR     OS_NEXT_FREE_CLUSTER			; Get first free cluster in FREE_CLUSTER
   875
   876 						; Update SIS with #clusters freed and first-free cluster nr
   877 52E2 20 15 56				JSR	SIS_ADD					; Update SIS and write back
   878 52E5 4C CA 4F		SH_DEL_X        JMP     LOAD_ACT_DIR        			; error - restore actual directory LBA and return
   879
   880 52E8 4C 18 55		SH_DEL_ERR	JMP	SH_FILE_ERR				; Print 'File not found' and return
   881
   882 				; **** Clear Screen Command ****************************************************
   883 				;
   884 				; ******************************************************************************
   885 52EB 4C B5 E0		SH_CLS          JMP     CLRSCRN
   886
   887 				; **** Pause Command ***********************************************************
   888 				; Output: A - pressed key char
   889 				;         C = 0 ESC key pressed, C = 1 else
   890 				; ******************************************************************************
   891 52EE			SH_PAUSE        PRSTR   MSG_PAUSE          	; print pause message
Macro: PRSTR [Source: macros.inc]
     1 52EE A2 83			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 52F0 A0 56			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 52F2 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   892 52F5 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   893 52F8 48			                PHA
   894 52F9 20 5A E0		                JSR     CROUT
   895 52FC 68			                PLA
   896 52FD 60			                RTS
   897 				                
   898 				; **** Echo Command ************************************************************
   899 				;
   900 				; ******************************************************************************
   901 52FE			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 52FE BD 00 14				LDA	STRBUF,X
     2 5301 F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   902 5303 8A			                TXA
   903 5304 A8			                TAY
   904 5305 C8			                INY
   905 5306 20 85 E0		                JSR     WRSTR
   906 5309 20 5A E0		                JSR     CROUT
   907 530C 60			SH_ECHO_END     RTS
   908
   909 				; **** Goto Command ************************************************************
   910 				;
   911 				; ******************************************************************************
   912 530D 60			SH_GOTO         RTS
   913
   914 				; **** If Command **************************************************************
   915 				;
   916 				; ******************************************************************************
   917 530E 20 13 46		SH_IF           JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   918 5311 20 24 46		                JSR 	OS_NEXT_FREE_CLUSTER
   919 5314 A0 03				LDY 	#3
   920 5316			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: macros.inc]
     1 5316 98				TYA
     2 5317 48				PHA
Source: boot_sys_sh.asm
   921 5318 B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   922 531B 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   923 531E					PLY				; restore Y
Macro: PLY [Source: macros.inc]
     1 531E 68				PLA
     2 531F A8				TAY
Source: boot_sys_sh.asm
   924 5320					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5320 88					DEY
     2 5321 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   925 5323 60					RTS
   926
   927 				; **** Rem Command *************************************************************
   928 				;
   929 				; ******************************************************************************
   930 5324			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: macros.inc]
     1 5324 A5 DC			LDA	BLKBUF
     2 5326 48				PHA
     3 5327 A5 DD			LDA	BLKBUF+1
     4 5329 48				PHA
Source: boot_sys_sh.asm
   931 532A 20 75 55				JSR	GET_SIS
   932 532D					PLW	BLKBUF
Macro: PLW [Source: macros.inc]
     1 532D 68				PLA
     2 532E 85 DD			STA	BLKBUF+1
     3 5330 68				PLA
     4 5331 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
   933 5333 60			SH_REM_X	RTS
   934 				                
   935 				; **** BASIC Command ***********************************************************
   936 				; Executes Basic in ROM. Return with 'DOS' command.
   937 				; ******************************************************************************
   938 5334 20 86 FD		SH_BASIC        JSR	MON2RAM			; Select Monitor RAM, disable ROM
   939 5337 20 0A E0				JSR	SWITCH_TO_ROM		; Enable BASIC ROM
   940 533A 4C 09 1E				JMP	MON_RAM_BLOCK.BAS_JMP	; Run BAS_JMP_CODE from Monitor RAM area
   941
   942 				; ------------------------------------------------------------------------------
   943 				; This routine copies the MON_RAM_BLOCK code below to the Monitor RAM-area at 
   944 				; $1C00 - $1FFF. The entire boot.sys code (this code!) is stored in RAM-BANK 0
   945 				; (= DOS RAM-BANK) by the boot-loader.
   946 				; Note: MON_RAM_BLOCK code-size should be < 256 bytes!
   947 				; This routine is called by OS_MAIN, the DOS Entry-point.
   948 				; ------------------------------------------------------------------------------
   949 533D 20 86 FD		CP_MON_RAM	JSR	MON2RAM				; Select Monitor RAM, disable ROM
   950 						; Do not use RAMB_DOS here: 1) RAMB_DOS is default when starting boot.sys 2) is not yet copied to Monitor RAM
   951 5340 A2 00				LDX	#0				; Init index
   952 5342 BD 4E 53		SH_BAS_LP	LDA	MON_RAM_START,X			; Get byte to copy
   953 5345 9D 00 1E				STA	MON_RAM_BLOCK.RAMB_DOS,X	; Store in Monitor RAM area
   954 5348 E8					INX					; More bytes to copy?
   955 5349 E0 6E				CPX	#(MON_RAM_END - MON_RAM_START)	; Amount of bytes to copy to Monitor RAM
   956 534B D0 F5				BNE	SH_BAS_LP			; Branch if more bytes to copy
   957 534D 60					RTS					; Return
   958
   959 534E			MON_RAM_START
   960 				;-------------------------------------------------------------------------------------------------------
   961 1E00			MON_RAM_BLOCK	.local, $1E00			; Assemble into Monitor RAM ($1E00-$1FFD)
   962 				; Note that FILE_BUFF is located at $1C00-1DFF (512 bytes)!
   963 				;-------------------------------------------------------------------------------------------------------
   964 1E00 A2 00		RAMB_DOS	LDX	#0			; RAM-BANK 0 is the main RAM-BANK, used by DOS
   965 1E02 F0 02				BEQ	RAMB_JMP		; branch always
   966
   967 1E04 A2 04		RAMB_BAS	LDX	#4			; RAM-BANK 4 is the 1st RAM-BANK
   968 1E06 4C 53 FD		RAMB_JMP	JMP	SET_RAMBANK		; Enable RAM-BANK for BASIC-programs and return
   969
   970 				;--------------------------------------------------------------------------------
   971 				; This function gets copied to Monitor RAM, so that a possible RAM-BANK switch
   972 				; does not affect the boot.sys code (which is in page 0 of the RAM-BANK area).
   973 				;--------------------------------------------------------------------------------
   974 1E09 20 04 1E		BAS_JMP		JSR	RAMB_BAS		; Enable RAM-BANK for BASIC-programs
   975 1E0C A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
   976 1E0E					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: macros.inc]
     1 1E0E C9 B1				CMP	#$B1
     2 1E10 D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
   977 						
   978 1E12 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
   979 1E15 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
   980
   981 				;--------------------------------------------------------------------------------
   982 				; The RAM-BANK MUST be switched to MAIN RAM-bank 0, because the DOS code is there.
   983 				; If the switch back is not done, the return jump will crash.
   984 				;--------------------------------------------------------------------------------
   985 1E18 20 00 1E		DOS_JMP_RET	JSR	RAMB_DOS		; Enable main RAM-BANK for DOS
   986 1E1B 4C A1 42				JMP	OS_SHELL_ENTRY		; Default return for Monitor and BASIC
   987
   988 				; **** CFC_LOAD routine for CF-IDE driver **************************************
   989 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP (CF_LOAD_VEC).
   990 				; ******************************************************************************
   991 1E1E 20 00 1E		CFC_LOAD	JSR	RAMB_DOS		; Enable main RAM-BANK for DOS
   992 1E21					PRSTR	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTR [Source: macros.inc]
     1 1E21 A2 3E			LDX	<TXT_LOAD				; MADS makes this immediate
     2 1E23 A0 54			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 1E25 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   993 1E28 20 31 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   994 						;PRCH	'['
   995 						;LDXYI	FILENAME		; 
   996 						;JSR	OS_STRING_OUT		; Print FN83 filename
   997 						;PRCH	']'
   998 1E2B 20 B8 4F				JSR     SAVE_ACT_DIR        	; save actual directory LBA
   999 1E2E 20 A7 54				JSR	SH_LOAD_BAS		; Load .bas file in memory
  1000 1E31 20 04 1E				JSR	RAMB_BAS		; Enable BASIC RAM-BANK again
  1001 1E34 38					SEC				; C=1: OK
  1002 1E35 60					RTS				; return to BASIC
  1003
  1004 				; **** Copy Second and other blocks of File to Memory **************************
  1005 				; Input: PSTR   : pointer to memory-source
  1006 				;        END_PTR: pointer to memory-destination
  1007 				; This routine copies a page (512 B) from one memory-location to another.
  1008 				; Since this routines is in Monitor-RAM, it is save to switch RAM-Banks.
  1009 				; Call tree: CFC_LOAD -> SH_LOAD_BAS -> OS_LOAD_FILE -> LOAD_NEXT_BLKS -> COPY_BLK_DEST
  1010 				; ******************************************************************************
  1011 1E36 20 04 1E		CP_BLK_DEST	JSR	RAMB_BAS			; Select BASIC RAM-BANK
  1012 1E39 A0 00				LDY	#0				; Init. index
  1013 1E3B B1 EA 91 CC		CP_BLK0_LP	MVA	(PSTR),Y (END_PTR),Y		; Get byte from buffer and store in destination
  1014 1E3F E6 CC D0 02 E6 CD			INW	END_PTR				; Increment destination pointer (macro)
  1015 1E45 E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
  1016 1E4B A5 EB				LDA	PSTR+1				; MSB of buffer pointer
  1017 1E4D					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: macros.inc]
     1 1E4D C9 1E				CMP	#>FILE_BUFF+2
     2 1E4F D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_sh.asm
  1018 1E51 4C 00 1E				JMP	RAMB_DOS			; Select DOS RAM-BANK again and return
  1019
  1020 				; **** CFC_SAVE routine for CF-IDE driver **************************************
  1021 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP (CF_SAVE_VEC).
  1022 				; ******************************************************************************
  1023 1E54 20 00 1E		CFC_SAVE	JSR	RAMB_DOS			; Enable main RAM-BANK for DOS
  1024 1E57 20 BC 53				JSR	CFC_SAVE_CNT			; Call CFC_SAVE function in DOS RAM area
  1025 1E5A 20 04 1E				JSR	RAMB_BAS			; Switch back to BASIC RAM-BANK area
  1026 1E5D 38					SEC					; C=1: OK
  1027 1E5E 60					RTS					; return to BASIC
  1028
  1029 				; **** Write Logical Block *****************************************************
  1030 				; Input: [X,Y] points to 32-bit destination LBA
  1031 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
  1032 				; Routine is placed in Monitor RAM, because it may SAVE memory in the RAM-BANK area. 
  1033 				; Call-tree: CFC_SAVE -> CFC_SAVE_CNT -> OS_SAVE_FILE -> DEV_WR_LBLK
  1034 				; ******************************************************************************
  1035 1E5F			DEV_WR_LBLK	PHX					; Save X register
Macro: PHX [Source: macros.inc]
     1 1E5F 8A				TXA
     2 1E60 48				PHA
Source: boot_sys_sh.asm
  1036 1E61 20 04 1E				JSR	RAMB_BAS			; Switch to BASIC RAM-BANK area (disabling DOS area)
  1037 1E64					PLX					; Get X register back
Macro: PLX [Source: macros.inc]
     1 1E64 68				PLA
     2 1E65 AA				TAX
Source: boot_sys_sh.asm
  1038 1E66 A9 23				LDA     #CMD_WRITE			; Call Device-driver Write routine
  1039 1E68 20 BA E0		                JSR     CMDDEV
  1040 1E6B 4C 00 1E				JMP	RAMB_DOS			; Enable main RAM-BANK for DOS again and return
  1041
  1042 				;-------------------------------------------------------------------------------------------------------
  1043 				.endl
  1044 				;-------------------------------------------------------------------------------------------------------
  1045 53BC			MON_RAM_END
  1046
  1047 				; **** CFC_SAVE routine for CF-IDE driver **************************************
  1048 				; Called from CFC_SAVE which is located in Monitor RAM.
  1049 				; ******************************************************************************
  1050 53BC			CFC_SAVE_CNT	PRSTR	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTR [Source: macros.inc]
     1 53BC A2 49			LDX	<TXT_SAVE				; MADS makes this immediate
     2 53BE A0 54			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 53C0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1051 53C3					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: macros.inc]
     1 53C3 AD 01 20			LDA	$2000+1				; print MSB
     2 53C6 20 91 E0			JSR	HEXOUT
     3 53C9 AD 00 20			LDA	$2000
     4 53CC 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
  1052 53CF 20 5E E0				JSR	SPCOUT		
  1053 53D2 20 31 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
  1054 						;PRCH	'['
  1055 						;LDXYI	FILENAME		; 
  1056 						;JSR	OS_STRING_OUT		; Print FN83 filename
  1057 						;PRCH	']'
  1058 53D5 AD 00 20 8D 66 54 + 		MWA	$2000 SAVE_LEN		; SAVE_LEN = end-address
  1059 53E1 38 AD 66 54 E9 00 + 		SBW	SAVE_LEN #$2000		; Get net file-size
  1060 53F2 AD 67 54 8D 68 54			MVA	SAVE_LEN+1 SAVE_SECS	; SAVE_SECS now contains #pages of 256 bytes
  1061 53F8 4E 68 54				LSR	SAVE_SECS		; SAVE_SECS now contains #sectors of 512 bytes needed
  1062 53FB					LDA.EQ	SAVE_LEN NO_ADD_SEC	; branch if LSB of SAVE_LEN is 0
Macro: LDA.EQ [Source: macros.inc]
     1 53FB AD 66 54				LDA	SAVE_LEN
     2 53FE F0 03				BEQ	NO_ADD_SEC
Source: boot_sys_sh.asm
  1063
  1064 5400 EE 68 54				INC	SAVE_SECS		; Add 1 to SAVE_SECS if LSB of SAVE_LEN is not 0
  1065 5403			NO_ADD_SEC	PRSTR	TXT_SECND1		; Print ', size: '
Macro: PRSTR [Source: macros.inc]
     1 5403 A2 55			LDX	<TXT_SECND1				; MADS makes this immediate
     2 5405 A0 54			LDY	>TXT_SECND1
Source: boot_sys_sh.asm
     2 5407 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1066 540A					LDXY	SAVE_LEN		; Size in bytes
Macro: LDXY [Source: macros.inc]
     1 540A AE 66 54			LDX	SAVE_LEN
     2 540D AC 67 54			LDY	SAVE_LEN+1
Source: boot_sys_sh.asm
  1067 5410 20 30 4E				JSR	PRINT_INT16		; Print it
  1068 5413					PRSTR	TXT_SECND2		; Print ', sec: '
Macro: PRSTR [Source: macros.inc]
     1 5413 A2 5E			LDX	<TXT_SECND2				; MADS makes this immediate
     2 5415 A0 54			LDY	>TXT_SECND2
Source: boot_sys_sh.asm
     2 5417 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1069 541A AD 68 54				LDA	SAVE_SECS		; Get sector count
  1070 541D 20 78 4C				JSR	NUMOUT			; Print #sectors needed
  1071 5420 20 5A E0				JSR	CROUT			; Print CR
  1072 						
  1073 5423					PRSTR	TXT_OS_CREATE		; Print 'OS_CREATE'
Macro: PRSTR [Source: macros.inc]
     1 5423 A2 69			LDX	<TXT_OS_CREATE				; MADS makes this immediate
     2 5425 A0 54			LDY	>TXT_OS_CREATE
Source: boot_sys_sh.asm
     2 5427 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1074 542A A9 20				LDA	#FA_ARCHIVE		; File is modified 
  1075 542C 20 A5 47				JSR	OS_CREATE		; Create file in current dir. and update FAT
  1076 542F					PRSTR	TXT_OS_SAVFILE		; Print 'OS_SAVE_FILE'
Macro: PRSTR [Source: macros.inc]
     1 542F A2 74			LDX	<TXT_OS_SAVFILE				; MADS makes this immediate
     2 5431 A0 54			LDY	>TXT_OS_SAVFILE
Source: boot_sys_sh.asm
     2 5433 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1077 5436 20 03 45				JSR	OS_SAVE_FILE		; Save contents of file
  1078 5439 20 56 56				JSR	SIS_DEL			; Subtract #allocated clusters from SIS and write back to disk
  1079 543C 38					SEC				; C=1: OK
  1080 543D 60					RTS				; return
  1081
  1082 543E 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
  1083
  1084 5449 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
  1085 5455 2C 20 73 69 7A 65 + TXT_SECND1	.by	', size: ' $00
  1086 545E 2C 20 73 65 63 3A + TXT_SECND2	.by	', sec: ' $00
  1087 5466 00 00		SAVE_LEN	.word	$0000			; #bytes to save
  1088 5468 00			SAVE_SECS	.byte	$00			; #sectors (of 512 B) to save
  1089 5469 4F 53 5F 43 52 45 + TXT_OS_CREATE	.by	'OS_CREATE' CR $00
  1090 5474 4F 53 5F 53 41 56 + TXT_OS_SAVFILE 	.by	'OS_SAVE_FILE' CR $00
  1091
  1092 				; **** BRUN Command ************************************************************
  1093 				;
  1094 				; ******************************************************************************
  1095 5482 20 B8 4F		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1096 5485			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 5485 A2 5D			LDX	<NO_PARMS				; MADS makes this immediate
     2 5487 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1097 5489 20 DC 4F		                JSR     SH_GET_PARMS
  1098 548C 90 05		                BCC     SH_BRUN_END
  1099
  1100 548E 20 70 48		                JSR     OS_FIND_FILE
  1101 5491 90 00		                BCC     SH_BRUN_END		; branch if file not found
  1102
  1103 				                ;JSR     OS_LOAD_BIN
  1104 5493 20 CA 4F		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1105 5496 60			                RTS
  1106 				                
  1107 				; **** BLOAD Command ***********************************************************
  1108 				;
  1109 				; ******************************************************************************
  1110 5497 60			SH_BLOAD        RTS
  1111
  1112 				; ******************************************************************************
  1113 5498 20 B8 4F		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
  1114 549B			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 549B A2 5D			LDX	<NO_PARMS				; MADS makes this immediate
     2 549D A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1115 549F 20 49 50		                JSR     SET_PARM_MASK
  1116 54A2 20 2B 50		                JSR     SH_GET_PATH         ; get file path
  1117 54A5 90 5C		                BCC     SH_RUN_END
  1118
  1119 						; This is the entry-point for loading a .BAS file into memory
  1120 54A7 AD AD 4B		SH_LOAD_BAS     LDA     FILENAME+8
  1121 54AA			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: macros.inc]
     1 54AA C9 20				CMP	#SPC
     2 54AC D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
  1122 54AE					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: macros.inc]
     1 54AE A0 02			LDY	#3-1
     2 54B0 B9 99 57 99 AD 4B + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 54B7 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1123
  1124 						; Check for .COM file
  1125 54B9 A0 02		SH_RUN1         LDY     #$02
  1126 54BB B9 99 57		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
  1127 54BE					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: macros.inc]
     1 54BE D9 AD 4B				CMP	FILENAME+8,Y
     2 54C1 D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
  1128 54C3			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54C3 88					DEY
     2 54C4 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
  1129 				                
  1130 54C6 A9 01 8D 5E 44			MVA	#1 FTYPE	    	; 1 = .COM file
  1131 54CB D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
  1132
  1133 54CD A0 02		CHK_BASF	LDY     #$02
  1134 54CF B9 9F 57		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
  1135 54D2			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: macros.inc]
     1 54D2 D9 AD 4B				CMP	FILENAME+8,Y
     2 54D5 D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
  1136 54D7			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54D7 88					DEY
     2 54D8 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
  1137 				                
  1138 54DA A9 00 8D 5E 44			MVA	#0 FTYPE	    	; 0 = .BAS file
  1139 54DF F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
  1140
  1141 54E1 A0 02		CHK_EXEF	LDY     #$02
  1142 54E3 B9 9C 57		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
  1143 54E6			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: macros.inc]
     1 54E6 D9 AD 4B				CMP	FILENAME+8,Y
     2 54E9 D0 18				BNE	SH_RUN_END
Source: boot_sys_sh.asm
  1144 54EB			                DEY.PL	CMP_EXT_EXE	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54EB 88					DEY
     2 54EC 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
  1145 				                
  1146 54EE A9 02 8D 5E 44			MVA	#2 FTYPE	    	; 2 = .EXE file
  1147 54F3 20 70 48		SH_RUN_FF       JSR     OS_FIND_FILE        	; check if file with this extension exists
  1148 54F6 B0 08		                BCS     SH_RUN3             	; yes, load file
  1149
  1150 54F8 20 5A E0		SH_RUN_ERR      JSR     CROUT		    	; print CR
  1151 54FB 20 18 55		                JSR     SH_FILE_ERR         	; file does not exist
  1152 54FE 90 03		                BCC     SH_RUN_END	    	; branch always
  1153
  1154 5500 20 71 44		SH_RUN3         JSR     OS_LOAD_FILE	    	; Load .bas file or load/run .com/.exe file
  1155 5503 4C CA 4F		SH_RUN_END      JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
  1156 				                
  1157 				; **** Print version info  *****************************************************
  1158 				; Output: -
  1159 				; ******************************************************************************
  1160 5506			SH_VER		PRSTR	MSG_BOOT			; Print Title Info
Macro: PRSTR [Source: macros.inc]
     1 5506 A2 3E			LDX	<MSG_BOOT				; MADS makes this immediate
     2 5508 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_sh.asm
     2 550A 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1161 550D 60					RTS
  1162 						
  1163 				; **** Monitor call-back Routine ************************************************
  1164 550E			SH_MONITOR      PRSTR   MSG_MONITOR
Macro: PRSTR [Source: macros.inc]
     1 550E A2 5A			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 5510 A0 57			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 5512 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1165 5515 4C 03 E0		                JMP     MON_WARM_START
  1166 				                
  1167 				.macro	PR_ERR	msg
  1168 						LDXYI	:msg
  1169 						JMP	OS_PRINT_ERR
  1170 				.endm
  1171 				; **** Error Routines **********************************************************
  1172 5518			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5518 A2 E9			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 551A A0 56			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 551C 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1173 551F			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 551F A2 F9			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 5521 A0 56			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 5523 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1174 5526			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5526 A2 2C			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 5528 A0 57			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 552A 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1175 552D			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 552D A2 1A			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 552F A0 57			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 5531 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1176 5534			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5534 A2 3F			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 5536 A0 57			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 5538 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1177 553B			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 553B A2 68			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 553D A0 57			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 553F 4C D0 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1178 				                
  1179 				; Inits BLKBUF to SIS_BUFF **************************************
  1180 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1181 				; ***************************************************************
  1182 5542 A9 00 85 DC A9 59 + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1183 554A 60					RTS
  1184
  1185 				;-------------------------------------------------------------------------------
  1186 				; Convert #Clusters to KB in FREE_KB
  1187 				; D_SECT_PER_CLST = 1: 2 CL =  2 SEC = 1 KB: SHR 1
  1188 				;                   2: 2 CL =  4 SEC = 2 KB: -
  1189 				;		    4: 2 CL =  8 SEC = 4 KB: SHL 1
  1190 				;		    8: 2 CL = 16 SEC = 8 KB: SHL 2 etcetera
  1191 				;-------------------------------------------------------------------------------
  1192 554B AD 0B 04		CL2KB		LDA	D_SECT_PER_CLST			; #sectors per cluster
  1193 554E					CMP.EQ	#2 CL2KB_X			; 2 sec/cl, just exit
Macro: CMP.EQ [Source: macros.inc]
     1 554E C9 02				CMP	#2
     2 5550 F0 22				BEQ	CL2KB_X
Source: boot_sys_sh.asm
  1194 5552					CMP.EQ	#1 CL2KB_1			; 1 sec/cl, SHR 1
Macro: CMP.EQ [Source: macros.inc]
     1 5552 C9 01				CMP	#1
     2 5554 F0 12				BEQ	CL2KB_1
Source: boot_sys_sh.asm
  1195 5556 4A 4A			:2	LSR					; init nr of shifts		
  1196 5558			CL2KB_SHL	ASL32	FREE_KB				; SHL 1 of FREE_KB
Macro: ASL32 [Source: macros.inc]
     1 5558 0E F1 55			ASL     FREE_KB		  		; SHL with C=0
     2 555B 2E F2 55		        ROL     FREE_KB+1		  
     3 555E 2E F3 55		        ROL     FREE_KB+2
     4 5561 2E F4 55		        ROL     FREE_KB+3		  
Source: boot_sys_sh.asm
  1197 5564 4A					LSR
  1198 5565 D0 F1				BNE	CL2KB_SHL			; branch if not done with shifting
  1199 5567 60					RTS					; return
  1200 						
  1201 5568			CL2KB_1		LSR32	FREE_KB				; SHR 1 of FREE_KB
Macro: LSR32 [Source: macros.inc]
     1 5568 4E F4 55			LSR     FREE_KB+3		  		; SHR with C=0
     2 556B 6E F3 55		        ROR     FREE_KB+2
     3 556E 6E F2 55		        ROR     FREE_KB+1
     4 5571 6E F1 55		        ROR     FREE_KB
Source: boot_sys_sh.asm
  1202 5574 60			CL2KB_X		RTS					; return
  1203 						
  1204 				; Get Info from System Information Sector **************************************
  1205 5575 20 42 55		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1206 5578					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START ($0400)
Macro: LDXYI [Source: macros.inc]
     1 5578 A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 557A A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1207 557C 20 50 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1208 557F					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: macros.inc]
     1 557F A2 03			LDX	#4-1
     2 5581 BD 00 04 9D ED 55 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 5588 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1209 558A 18 AD ED 55 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1210 559D AD EF 55				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1211 55A0 69 00				ADC	#0
  1212 55A2 8D EF 55				STA	SYS_INFO_LBA+2
  1213 55A5 AD F0 55				LDA	SYS_INFO_LBA+3
  1214 55A8 69 00				ADC	#0
  1215 55AA 8D F0 55				STA	SYS_INFO_LBA+3
  1216 						
  1217 55AD 20 42 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1218 55B0					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: macros.inc]
     1 55B0 A2 ED			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 55B2 A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1219 55B4 20 50 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1220 55B7 AD 28 18				LDA	DBG_PRINT
  1221 55BA F0 22				BEQ	FREE_KB_UPDATE
  1222 55BC					PRSTR	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTR [Source: macros.inc]
     1 55BC A2 F5			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 55BE A0 55			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 55C0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1223 55C3					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: macros.inc]
     1 55C3 AD EF 5A			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 55C6 20 91 E0			JSR	HEXOUT
     3 55C9 AD EE 5A			LDA	SIS_BUFF+$01EC+2
     4 55CC 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 55CF AD ED 5A			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 55D2 20 91 E0			JSR	HEXOUT
     3 55D5 AD EC 5A			LDA	SIS_BUFF+$01EC
     4 55D8 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1224 55DB 20 5A E0				JSR	CROUT
  1225 55DE			FREE_KB_UPDATE	MVAX	4 SIS_BUFF+$01E8 FREE_KB	
Macro: MVAX [Source: macros.inc]
     1 55DE A2 03			LDX	#4-1
     2 55E0 BD E8 5A 9D F1 55 + lp	MVA	SIS_BUFF+$01E8,X FREE_KB,X-
     3 55E7 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1226 55E9 20 4B 55				JSR	CL2KB				; Convert #clusters to KB and store in FREE_KB
  1227 55EC 60					RTS
  1228 						
  1229 55ED 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1230 55F1 00 00 00 00		FREE_KB		.dword	$00000000
  1231 55F5 46 69 72 73 74 20 + TXT_FFREE_CLST	.by	'First free cluster:$' $00
  1232 560A 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1233 5614 00			SIS_CNT		.byte	$00				; SIS counter, counts #clusters freed or allocated
  1234
  1235 				; Write Info back to System Information Sector **************************************
  1236 5615			SIS_ADD		PRSTR	SISP
Macro: PRSTR [Source: macros.inc]
     1 5615 A2 79			LDX	<SISP				; MADS makes this immediate
     2 5617 A0 56			LDY	>SISP
Source: boot_sys_sh.asm
     2 5619 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1237 561C AD E8 5A 18 6D 14 + 		ADB	SIS_BUFF+$01E8 SIS_CNT		; add SIS_CNT to #free clusters in SIS-buffer
  1238 5626 90 03				SCC					; 'skip if C is clear' macro
  1239 5628 EE E9 5A				INC	SIS_BUFF+$01E9
  1240 562B 90 03				SCC	
  1241 562D EE EA 5A				INC	SIS_BUFF+$01EA
  1242 5630 90 03				SCC	
  1243 5632 EE EB 5A				INC	SIS_BUFF+$01EB
  1244 5635 AD 14 56		SIS_WRITE	LDA	SIS_CNT				; Print SIS_CNT
  1245 5638 20 91 E0				JSR	HEXOUT
  1246 563B 20 5A E0				JSR	CROUT
  1247 563E					MVAX	4 FREE_CLUSTER SIS_BUFF+$01EC	; SIS First free cluster = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 563E A2 03			LDX	#4-1
     2 5640 BD 20 18 9D EC 5A + lp	MVA	FREE_CLUSTER,X SIS_BUFF+$01EC,X-
     3 5647 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1248 5649 20 42 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_WRITE command
  1249 564C					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: macros.inc]
     1 564C A2 ED			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 564E A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1250 5650 20 1D 42				JSR 	DEV_WR_LBLK           		; Write SIS to disk, use non RAM-BANK version, since SIS_BUFF is here
  1251 5653 4C DE 55				JMP	FREE_KB_UPDATE			; Update FREE_KB and return
  1252
  1253 5656			SIS_DEL		PRSTR	SISM
Macro: PRSTR [Source: macros.inc]
     1 5656 A2 7E			LDX	<SISM				; MADS makes this immediate
     2 5658 A0 56			LDY	>SISM
Source: boot_sys_sh.asm
     2 565A 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1254 565D AD E8 5A 38 ED 14 + 		SBB	SIS_BUFF+$01E8 SIS_CNT		; subtract SIS_CNT from #free clusters in SIS-buffer
  1255 5667 B0 03				SCS					; 'skip if C is set' macro
  1256 5669 CE E9 5A				DEC	SIS_BUFF+$01E9
  1257 566C B0 03				SCS
  1258 566E CE EA 5A				DEC	SIS_BUFF+$01EA
  1259 5671 B0 03				SCS
  1260 5673 CE EB 5A				DEC	SIS_BUFF+$01EB
  1261 5676 4C 35 56				JMP	SIS_WRITE			; write back to disk
  1262 						
  1263 5679 53 49 53 2B 00	SISP		.by	'SIS+' $00
  1264 567E 53 49 53 2D 00	SISM		.by	'SIS-' $00
  1265 						
  1266 				; **** Data Area ***************************************************************
  1267 				; ******************************************************************************
  1268
  1269 				; String Data Area *************************************************************
  1270 5683 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1271 5694 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1272 56A5 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1273 56AA 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1274 56BA 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1275 56C5 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)   ' $00
  1276 56D0 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1277 56D8 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1278 56E9 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1279 56F9 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1280 5709 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1281 571A 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1282 572C 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1283 573F 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1284 575A 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1285 5768 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1286
  1287 				; ############################################
  1288 5776 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1289 577E 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1290 5783 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1291 578E 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1292 5799 43 4F 4D		EXT_COM         .by    'COM'
  1293 579C 45 58 45		EXT_EXE		.by    'EXE'
  1294 579F 42 41 53		EXT_BAS		.by    'BAS'
  1295 				                
  1296 				; Command Table ****************************************************************
  1297 57A2 42 C1 57		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1298 57A5 43 D6 57				dta	'C' , a(CMD_CD)		
  1299 57A8 44 E0 57				dta	'D' , a(CMD_DIR)		
  1300 57AB 45 EB 57				dta	'E' , a(CMD_ECHO)		
  1301 57AE 47 F2 57				dta	'G' , a(CMD_GOTO)		
  1302 57B1 49 F9 57				dta	'I' , a(CMD_IF)		
  1303 57B4 4D FE 57				dta	'M' , a(CMD_MKDIR)		
  1304 57B7 50 0B 58				dta	'P' , a(CMD_PAUSE)		
  1305 57BA 52 13 58				dta	'R' , a(CMD_REM)
  1306 57BD 56 19 58				dta	'V' , a(CMD_VER)
  1307 57C0 00					.byte 	$00
  1308
  1309 57C1 05 41 53 49 43 34 + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1310 57C8 05 4C 4F 41 44 97 + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1311 57CF 04 52 55 4E 82 54 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1312 57D6 02 44 B9 51		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1313 57DA 03 4C 53 EB 52 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1314 57E0 03 49 52 5E 50	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1315 57E5 03 45 4C A6 52 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1316 57EB 04 43 48 4F FE 52 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1317 57F2 04 4F 54 4F 0D 53 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1318 57F9 02 46 0E 53 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1319 57FE 05 4B 44 49 52 E3 + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1320 5805 03 4F 4E 0E 55 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1321 580B 05 41 55 53 45 EE + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1322 5813 03 45 4D 24 53 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
  1323 5819 03 45 52 06 55 00	CMD_VER		dta	3, c'ER'  , a(SH_VER)    , $00  ;
    86 				                
    87 				; End Of Program Marker ********************************************************
    88 581F 00			BOOT_SYS_END    BRK
    89 5820					ORG ((*/256)+1)*256		; next free page
    90 = 5900			SIS_BUFF	.ds 	512			; SIS Buffer 
    91 						END
