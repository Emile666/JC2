mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Disk Operating System for 6502 Microprocessors
     3 				;
     4 				; JC2 DOS65, Version 0.2.6 by Emile, original design (V0.2.0) by Joerg Walke
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; DOS65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0032			VERPSUB    	EQU     '2'    		; primary sub version
    24 = 0036			VERSSUB		EQU	'6'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; V0.2.4: - .BAS LOAD file now works, filename bug-fix and NUM32 bug-fix
    33 				;	  - Bug-fix MKDIR run after DIR command
    34 				;	  - SIS added + total KB printed with DIR command
    35 				; V0.2.5: - DEL command added.
    36 				; V0.2.6: - SAVE from BASIC added, CFC_SAVE, OS_CREATE, OS_CREATE_FILE changed,
    37 				;           OS_SAVE_FILE and LINK_FAT_ENTRY added.
    38 				;         - VER command added.
    39 				;         - Bug-fixes OS_LOAD_FILE when 1) #clusters = 1 2) sectors/cluster = 1
    40 				; ******************************************************************************
    41 						OPT h- ; do not add file header
    42 						OPT f+ ; save as single block
    43
    44 				;------------------------------------------------------------------------------------------------
    45 				; TERMINOLOGY AND FORMULAS USED:
    46 				; 
    47 				; Sector                : A sector consists of 512 bytes.
    48 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    49 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    50 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    51 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    52 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    53 				; 
    54 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    55 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    56 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    57 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    58 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    59 				;------------------------------------------------------------------------------------------------
    60
    61 = 0001			DBG_PRINT	EQU	1			; Set to 1 for debug print-outs
    62
    63 						ICL "macros.inc"		; boot.sys macro definitions for MADS
Source: macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTR	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    88 					LDX	#:n-1
    89 				lp	MVA	:src,X :dst,X-
    90 					BPL	lp
    91 				.endm
    92 					
    93 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
    94 					LDY	#:n-1
    95 				lp	MVA	:src,Y :dst,Y-
    96 					BPL	lp
    97 				.endm
    98
    99 				; Macros used for printing a cluster nr, which consists of 2 words
   100 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   101 						LDA	(:c),Y
   102 					ift :0>1	; st also given?
   103 						STA	:st
   104 					eif	
   105 						JSR	HEXOUT			; changes Y!
   106 				.endm		
   107
   108 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   109 						LDY	#:indx+1		; Print MSB of word
   110 					ift :0>2	; stor also given?	
   111 						PRCLB	:curr_dir :stor+1
   112 					els	
   113 						PRCLB	:curr_dir
   114 					eif
   115 						LDY	#:indx			; Print LSB of word
   116 					ift :0>2	; stor also given?	
   117 						PRCLB	:curr_dir :stor
   118 					els	
   119 						PRCLB	:curr_dir
   120 					eif
   121 				.endm
   122
   123 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   124 					ift :b2>7
   125 						ERT "Only bits 7-0 allowed"
   126 					els
   127 						LDA	:b1
   128 						AND	#(1 << :b2)
   129 						BEQ	:lbl1
   130 					eif
   131 				.endm
   132 					
   133 				; ----------------------------------------------
   134 				; Compare + Branch Macros
   135 				; ----------------------------------------------
   136 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   137 						CMP	:b1
   138 						BEQ	:lbl
   139 				.endm		; A is now not equal to b1
   140 					
   141 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   142 						CMP	:b1
   143 						BNE	:lbl
   144 				.endm		; A is now equal to b1
   145
   146 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   147 				CMP.CC	.macro ' '	b1 lbl
   148 						CMP	:b1			; 
   149 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   150 				.endm		; C is now 1 (A-b1 is >= 0)
   151
   152 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   153 				CMP.CS	.macro ' '	b1 lbl
   154 						CMP	:b1			; 
   155 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   156 				.endm		; C is now 0 (A-b1 is < 0)
   157
   158 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   159 						CPX	:b1
   160 						BEQ	:lbl
   161 				.endm		; X is now not equal to b1
   162 					
   163 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   164 						CPX	:b1
   165 						BNE	:lbl
   166 				.endm		; X is now equal to b1
   167
   168 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   169 				CPX.CC	.macro ' '	b1 lbl
   170 						CPX	:b1			; 
   171 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   172 				.endm		; C is now 1 (X-b1 is >= 0)
   173
   174 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   175 				CPX.CS	.macro ' '	b1 lbl
   176 						CPX	:b1			; 
   177 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   178 				.endm		; C is now 0 (X-b1 is < 0)
   179
   180 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   181 						CPY	:b1
   182 						BEQ	:lbl
   183 				.endm		; Y is now not equal to b1
   184 					
   185 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   186 						CPY	:b1
   187 						BNE	:lbl
   188 				.endm		; Y is now equal to b1
   189
   190 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   191 				CPY.CC	.macro ' '	b1 lbl
   192 						CPY	:b1			; 
   193 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   194 				.endm		; C is now 1 (Y-b1 is >= 0)
   195
   196 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   197 				CPY.CS	.macro ' '	b1 lbl
   198 						CPY	:b1			; 
   199 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   200 				.endm		; C is now 0 (Y-b1 is < 0)
   201
   202 				; ----------------------------------------------
   203 				; Increment/Decrement + Branch Macros
   204 				; ----------------------------------------------
   205 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   206 						DEC	:b1
   207 						BEQ	:lbl
   208 				.endm
   209
   210 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   211 						DEC	:b1
   212 						BNE	:lbl
   213 				.endm
   214
   215 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   216 						INC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   221 						INC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				; ----------------------------------------------
   226 				DEX.NE	.macro 	lbl				; DEX + BNE
   227 						DEX
   228 						BNE	:lbl
   229 				.endm
   230
   231 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   232 						DEX
   233 						BEQ	:lbl
   234 				.endm
   235
   236 				DEX.PL	.macro 	lbl				; DEX + BPL 
   237 						DEX
   238 						BPL	:lbl
   239 				.endm
   240
   241 				DEX.MI	.macro 	lbl				; DEX + BMI
   242 						DEX
   243 						BMI	:lbl
   244 				.endm
   245
   246 				DEX.CC	.macro 	lbl				; DEX + BCC 
   247 						DEX
   248 						BCC	:lbl
   249 				.endm
   250
   251 				DEX.CS	.macro 	lbl				; DEX + BCS
   252 						DEX
   253 						BCS	:lbl
   254 				.endm
   255
   256 				; ----------------------------------------------
   257 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   258 						DEY
   259 						BEQ	:lbl
   260 				.endm
   261
   262 				DEY.NE	.macro 	lbl				; DEY + BNE
   263 						DEY
   264 						BNE	:lbl
   265 				.endm
   266
   267 				DEY.PL	.macro 	lbl				; DEY + BPL 
   268 						DEY
   269 						BPL	:lbl
   270 				.endm
   271
   272 				DEY.MI	.macro 	lbl				; DEY + BMI
   273 						DEY
   274 						BMI	:lbl
   275 				.endm
   276
   277 				DEY.CC	.macro 	lbl				; DEY + BCC 
   278 						DEY
   279 						BCC	:lbl
   280 				.endm
   281
   282 				DEY.CS	.macro 	lbl				; DEY + BCS
   283 						DEY
   284 						BCS	:lbl
   285 				.endm
   286 				; ----------------------------------------------
   287
   288 				; ----------------------------------------------
   289 				; LOAD/STORE + Branch Macros
   290 				; ----------------------------------------------
   291 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   292 						LDA	:b1
   293 						BEQ	:lbl
   294 				.endm
   295
   296 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   297 						LDA	:b1
   298 						BNE	:lbl
   299 				.endm
   300
   301 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   302 						STA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   307 						STA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				; ----------------------------------------------
   312 				; AND/OR + Branch Macros
   313 				; ----------------------------------------------
   314 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   315 					ift :0>2	; LDA + AND + BEQ	
   316 						LDA	:p1
   317 						AND	:p2
   318 						BEQ	:p3
   319 					els		; AND + BEQ
   320 						AND	:p1
   321 						BEQ	:p2
   322 					eif
   323 				.endm
   324
   325 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   326 					ift :0>2	; LDA + AND + BNE	
   327 						LDA	:p1
   328 						AND	:p2
   329 						BNE	:p3
   330 					els		; AND + BNE
   331 						AND	:p1
   332 						BNE	:p2
   333 					eif
   334 				.endm
    64 						ICL "defines.inc"		; boot.sys defines
Source: defines.inc
     1 				;-------------------------------------------------
     2 				; Register Definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				; Global Constants and Variables ***********************************************
     8 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
     9 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    10 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    11 = B000			LAB_COLD	=	$B000		; BASIC cold START
    12
    13 = 00A0			ZP_BASE         EQU     $A0		; Reserved for DOS and boot.sys
    14 = 00A0			CURR_CLUSTER    EQU     ZP_BASE         ; $A0..$A3 (32 bit) - current addressed cluster
    15 = 00A4			CURR_FAT_BLK    EQU     ZP_BASE+4       ; $A4..$A7 (32 bit) - current loaded FAT LBA
    16 = 00A8			CURR_DIR_ENTRY  EQU     ZP_BASE+8       ; $A8..$A9 (16 bit) - pointer to current addressed directory entry
    17 = 00AA			MASK            EQU     ZP_BASE+10	; $AA Mask for FAT table
    18 = 00AB			BCNT            EQU     ZP_BASE+11      ; $AB Block Counter
    19 = 00AC			NCNT            EQU     ZP_BASE+12	; $AC
    20 = 00AD			SCNT            EQU     ZP_BASE+13	; $AD Sector counter within a cluster
    21 = 00AE			RES             EQU     ZP_BASE+14	; $AE
    22
    23 = 0078			ssptr_l		EQU	$78		; BASIC filename pointer LSB
    24 = 0079			ssptr_h		EQU	$79		; BASIC filename pointer MSB
    25
    26 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    27 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    28 = 00CC			END_PTR		EQU	$CC		; CFC_LOAD destination pointer, also used by BIOS ROM checksum routine
    29 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register (same as BIOS)
    30 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register (same as BIOS)
    31 = 00DC			BLKBUF		EQU	$DC
    32 = 00DC			BLKBUFL		EQU	$DC             ; Pointer to block buffer, same in BIOS
    33 = 00DD			BLKBUFH		EQU	$DD
    34
    35 = 00E8			STOL      	EQU   	$E8     	; Store address Low, same in BIOS
    36 = 00E9			STOH      	EQU   	$E9     	; Store address High
    37 = 00EA			PSTR            EQU     $EA		; 2-byte ACIA output pointer, same in BIOS
    38 = 00EE			PSAV            EQU     $EE             ; Saved Partition Number in ASCII, same in BIOS
    39
    40 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
    41 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
    42 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
    43
    44 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400 (same as BIOS)
    45
    46 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
    47 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
    48 = 180A			RETURN_VECT     EQU     $180A           ; return vector to monitor caller in V1.2.1 (was $0001 in V1.2.0)
    49
    50 = 1810			NEXTINDEX       EQU     $1810		; command index
    51 = 1811			TERM_CHAR       EQU     $1811
    52 = 1812			F_ATTRIBS       EQU     $1812
    53 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
    54 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
    55 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
    56 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
    57 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
    58 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
    59 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
    60 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
    61 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
    62 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
    63
    64 				; External Routines ************************************************************
    65
    66 = E003			MON_WARM_START  EQU     $E003
    67
    68 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    69 = E052			COUT            EQU     $E052
    70 = E05A			CROUT           EQU     $E05A
    71 = E05E			SPCOUT          EQU     $E05E
    72 = E047			CIN             EQU     $E047
    73 = E062			STRIN           EQU     $E062
    74 = E083			STROUT          EQU     $E083
    75 = E085			WRSTR           EQU     $E085
    76 = E091			HEXOUT          EQU     $E091
    77 = E09A			HEXDIG          EQU     $E09A
    78 = E0BD			DEC2STR         EQU     $E0BD
    79 = E0B5			CLRSCRN         EQU     $E0B5
    80 = E0BA			CMDDEV          EQU     $E0BA
    81 = E1AA			OPEN_DEVICE     EQU     $E1AA
    82 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    83 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    84 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    85 = FD7D			MON2ROM		EQU	$FD7D			; Monitor to ROM
    86 = FD86			MON2RAM		EQU	$FD86			; Monitor to RAM, enable RAM behind it
    87
    88 				; Tables and Buffers ***********************************************************
    89 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
    90 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
    91 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
    92
    93 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor
    94 = 0420			FILE_TABLE      EQU     CURR_VOLUME+$20  	; File Descriptor Table
    95 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices
    96 = 0600			BLOCK_BUFF      EQU     $0600           	; Data Block Buffer
    97
    98 = 5930			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
    99
   100 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   101 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   102
   103 				; Device IDs *******************************************************************
   104 = 0000			NULL_ID		EQU	$00             	; the NULL device
   105 = 0022			FDD1_ID         EQU     $22             	; Floppy drive 1 device ID
   106 = 0023			FDD2_ID         EQU     $23             	; Floppy drive 2 device ID
   107 = 0024			SDC_ID		EQU     $24             	; SD-Card device ID
   108 = 0025			HDD1_ID		EQU     $25             	; CF-Card device ID
   109
   110 				; FAT Types ********************************************************************
   111 = 0002			FAT12_Type      EQU     $02
   112 = 0001			FAT16_Type      EQU     $01
   113 = 0000			FAT32_Type      EQU     $00
   114
   115 				; Device Driver Commands *******************************************************
   116 = 0022			CMD_READ	EQU	34              	; Read data block from device
   117 = 0023			CMD_WRITE	EQU	35              	; Write data block to device
   118 = 0025			CMD_READ_BUF	EQU	37              	; Read data block from device to standard buffer
   119 = 0026			CMD_WRITE_BUF	EQU	38              	; Write data block to device from standard buffer
   120
   121 				; Miscellaneous Constants ******************************************************
   122 = 000D			CR              EQU     $0D             	; Carriage Return ASCII Code
   123 = 0020			SPC             EQU     $20             	; Space ASCII Code
   124 = 005C			BSLASH          EQU     '\'             	; Backslash ASCII Code
   125 = 002F			FSLASH		EQU     '/'             	; Forward slash ASCII Code
   126 = 002E			DOT             EQU     '.'             	; Dot ASCII Code
   127 = 003A			COLON           EQU     ':'             	; Colon ASCII Code
   128 = 002C			COMMA           EQU     ','             	; Comma ASCII Code
   129 = 002D			MINUS           EQU     '-'             	; Minus ASCII Code
   130 = 005F			ULINE           EQU     '_'             	; Underline ASCII Code
   131
   132 				; Interchangeable Chars ********************************************************
   133 = 003E			PROMPT          EQU     '>'             	; Command Line Prompt Char
   134 = 002E			NUM_SEP         EQU     DOT	           	; Thousand Seperator Char
   135 = 005C			PATH_SEP        EQU     BSLASH          	; Path Seperator Char
   136 = 002F			OPT_SEP         EQU     FSLASH           	; Option Prefix Char
   137
   138 				; File Attributes **************************************************************
   139 = 0001			FA_READONLY     EQU     $01             	; file is read only
   140 = 0002			FA_HIDDEN       EQU     $02             	; file is hidden
   141 = 0004			FA_SYSTEM       EQU     $04             	; file is a system file
   142 = 0008			FA_LABEL        EQU     $08             	; file is a volume label
   143 = 0010			FA_DIRECTORY    EQU     $10             	; file is a directory
   144 = 0020			FA_ARCHIVE      EQU     $20             	; file is modified
   145 = 0040			FA_RESERVED1    EQU     $40
   146 = 0080			FA_LINK         EQU     $80             	; file is a link
   147
   148 				; Device Attributes ************************************************************
   149 = 0080			DA_DIRTY        EQU     $80             ; current FAT block is modified
   150
   151 				; Current Volume Descriptor (32 Bytes) *****************************************
   152 				; The BOOT routine in BIOS has already loaded the MBR into $0600, laoded the
   153 				; Volume-ID sector into $0400 and did set (most of) these variables.
   154 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   155 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   156 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   157 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte
   158 										;           or Partition Number in ASCII if harddisk
   159 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   160 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   161 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   162 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   163 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   164 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   165 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   166 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   167 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   168
   169 = 0420			D_SUBDIR_NAME	EQU	FILE_TABLE+$00		; 11 Bytes - Name of entire path (root dir is \)
   170 					
   171 				; Directory Descriptor (32 Bytes) **********************************************
   172
   173 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   174 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   175 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   176 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   177 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   178 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   179 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   180 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   181 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   182 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   183 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   184
   185
    65 						
    66 				.if	USE_XMODEM = 1
    67 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    68 				.endif
    69
    70 				; ******************************************************************************
    71 				; Start of 1st Block of BOOT.SYS ***********************************************
    72 				; ******************************************************************************
    73 = 4000			LOAD_ADDRESS	EQU	$4000
    74 						ORG	LOAD_ADDRESS		; the program start address
    75 				PROG_START					; Program Start Address
    76 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				; V0.1: 22-05-25, Emile first version
    11 				;-------------------------------------------------------------------------------
    12
    13 				; subtract two clusters from START_CLUSTER address *****************************
    14 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    15 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    16 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    17 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    18 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    19 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    20 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    21 4012 A2 01		                LDX     #$01
    22 4014 A0 03		                LDY     #$03
    23 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    24 4019 E9 00		                SBC     #$00
    25 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    26 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    27 				                
    28 				; initialize current FAT block value with 0 ************************************
    29 4022 84 A4		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    30 4024 84 A5		                STY     CURR_FAT_BLK+1
    31 4026 84 A6		                STY     CURR_FAT_BLK+2
    32 4028 84 A7		                STY     CURR_FAT_BLK+3
    33 				                
    34 				; set first cluster of BOOT.SYS as the current cluster *************************
    35 402A A0 15		INIT3           LDY     #$15
    36 402C A2 03		                LDX     #$03
    37 402E 20 74 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    38 4031 A0 1B		                LDY     #$1B
    39 4033 20 74 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    40 				                
    41 				; calculate BOOTS.SYS file size in blocks **************************************
    42 4036 A9 58		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    43 4038 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    44 403B 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    45 403C 85 AB		                STA     BCNT                	; store result into block counter
    46 403E			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: macros.inc]
     1 403E A9 04				LDA	#<BOOT_SYS_END
     2 4040 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    47 4042 E6 AB		                INC     BCNT                	; some bytes are left, so increment block counter
    48 				                
    49 				; load all blocks of BOOT.SYS file into memory *********************************
    50 4044			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 4044 C6 AB				DEC	BCNT
     2 4046 F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    51 4048 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    52 404D			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: macros.inc]
     1 404D C6 AD				DEC	SCNT
     2 404F F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    53 4051 20 81 41		                JSR     INC_32              	; no, increment block address
    54 4054			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: macros.inc]
     1 4054 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4056 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    55 4058 20 4B 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    56 405B			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 405B C6 AB				DEC	BCNT
     2 405D F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    57 405F D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    58
    59 				; next cluster needs to be loaded considering the volume FAT type **************
    60 4061 20 7E 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    61 4064 B0 0B		                BCS     OS_START            	; if EOF then start OS
    62 						
    63 4066 20 F8 40		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    64 4069 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    65 406E 4C 54 40		                JMP     LOAD_BLK            	; load first block of cluster
    66 				                
    67 4071 4C 22 42		OS_START        JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 4074 20 77 40		SET_WORD        JSR     SET_BYTE
    74 4077 B1 EA 88 95 A0 CA	SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 407D 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 407E			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 407E A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 4080 A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 4082 20 61 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 4085			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: macros.inc]
     1 4085 AD 0A 04				LDA	D_FAT_TYPE
     2 4088 F0 14				BEQ	FAT32
Source: boot_sys_block1.asm
    85 408A					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: macros.inc]
     1 408A C9 01				CMP	#FAT16_TYPE
     2 408C F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 408E 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 408F A6 A1		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 4091 20 83 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 4094 20 1D 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 4097 A5 A0		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 4099 A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 409B 4C BE 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 409E			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: macros.inc]
     1 409E A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40A0 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40A2 20 5B 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40A5 A2 00 86 C7				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40A9 A0 03		                LDY     #$03
   106 40AB A5 A0		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40AD 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40AE 48			                PHA                         	; save entry index to stack
   109 40AF 36 C4 E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40B2			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 40B2 88					DEY
     2 40B3 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40B5 20 8F 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40B8 20 1D 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40BB 68			                PLA                         	; restore entry index
   116 40BC A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40BE			READ_FAT_ENTRY  
   127 40BE A0 FF 84 AA				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40C2 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40C3 A8			                TAY                         	; store entry index into Y
   130 40C4 86 AC		                STX     NCNT                	; store length of entry
   131 40C6 A2 00 86 AE		                MVX     #$00 RES		;
   132 40CA 20 EA 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40CD 95 A0		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40CF 08			                PHP                         	; save carry flag
   135 40D0			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: macros.inc]
     1 40D0 E0 03				CPX	#$03
     2 40D2 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40D4 A2 0F 86 AA		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40D8			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: macros.inc]
     1 40D8 C5 AA				CMP	MASK
     2 40DA D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40DC 85 AE		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40DE 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40DF C8			                INY
   141 40E0 E8			                INX
   142 40E1			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 40E1 C6 AC				DEC	NCNT
     2 40E3 D0 E5				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40E5 A5 AE		                LDA     RES
   144 40E7 C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40E9 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40EA			READ_ENTRY_BYTE AND.NE  #$01 CURR_CLUSTER+1 RD_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 40EA A9 01				LDA	#$01
     3 40EC 25 A1				AND	CURR_CLUSTER+1
     4 40EE D0 04				BNE	RD_UPPER_PAGE
Source: boot_sys_block1.asm
   152 40F0 B9 00 06		                LDA     BLOCK_BUFF,Y        			; read entry byte from lower half of block buffer
   153 40F3 60			                RTS			    			; return
   154 40F4 B9 00 07		RD_UPPER_PAGE   LDA     BLOCK_BUFF+256,Y    			; read entry byte from upper half of block buffer
   155 40F7 60			                RTS			    			; return
   156 				                
   157 				; **** Calculate LBA From Given Cluster Address ********************************
   158 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   159 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   160 				;
   161 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   162 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   163 				; ******************************************************************************
   164 40F8			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: macros.inc]
     1 40F8 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 40FA A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   165 40FC 20 61 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   166 40FF AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   167 4102 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   168 4103 F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   169 						
   170 4105 A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   171 4107 A0 04		                LDY     #$04
   172 4109 18			                CLC
   173 410A 36 C0 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   174 410D			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 410D 88					DEY
     2 410E D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   175 						
   176 4110 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   177 4111 D0 F2		                BNE     LOOP1		     	; 
   178 						
   179 4113			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: macros.inc]
     1 4113 A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 4115 A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   180 4117 20 5B 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   181 411A 4C 8F 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   182
   183 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   184 				; Input: NUM32: LBA number of FAT sector to load
   185 				; ******************************************************************************
   186 411D A2 03		LOAD_FAT_BLK    LDX     #$03
   187 411F 86 AE		                STX     RES                 	; initialize byte counter
   188 				                
   189 				; check if current FAT block and last loaded FAT block are identical ***********
   190 4121 B5 C0		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   191 4123			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: macros.inc]
     1 4123 D5 A4				CMP	CURR_FAT_BLK,X
     2 4125 D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   192 						
   193 4127 C6 AE		                DEC     RES                 	; if equal decrement number of unequal bytes
   194 4129 95 A4 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   195 412C 10 F3		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   196 						
   197 412E A5 AE		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   198 4130 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   199 				                
   200 4132			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: macros.inc]
     1 4132 A5 DC			LDA	BLKBUF
     2 4134 48				PHA
     3 4135 A5 DD			LDA	BLKBUF+1
     4 4137 48				PHA
Source: boot_sys_block1.asm
   201 4138			                LDXYI   NUM32
Macro: LDXYI [Source: macros.inc]
     1 4138 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 413A A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   202 413C 20 46 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($600)
   203 413F					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: macros.inc]
     1 413F 68				PLA
     2 4140 85 DD			STA	BLKBUF+1
     3 4142 68				PLA
     4 4143 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   204 4145 60			LOAD_FAT_END    RTS
   205 				                
   206 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   207 				; Input: [X,Y] points to 32-bit LBA
   208 				; ******************************************************************************
   209 4146 A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   210 4148 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   211 				                
   212 				; **** Read Logical Block ******************************************************
   213 				; Input: [X,Y] points to 32-bit LBA
   214 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   215 				; ******************************************************************************
   216 414B A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   217 414D 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   218 				                
   219 				; Arithmetic Functions *********************************************************
   220 				; ******************************************************************************
   221
   222 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   223 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   224 				; ******************************************************************************
   225 4150			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: macros.inc]
     1 4150 86 C0			STX	NUM32
     2 4152 84 C1			STY	NUM32+1
Source: boot_sys_block1.asm
   226 4154 A2 00 86 C2 86 C3			MWX	#0 NUM32+2		; Zero upper 16-bits
   227 415A 60			                RTS			   	; return
   228 				                
   229 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   230 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   231 				; ******************************************************************************
   232 415B 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   233 415D A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   234 415F D0 04		                BNE     LOAD_32_1	   	; branch always
   235
   236 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   237 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   238 				; ******************************************************************************
   239 4161 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   240 4163 A2 03		                LDX     #$03
   241 4165 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   242 4167 A0 03		                LDY     #$03
   243 4169 B1 E8 95 C0 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   244 416E			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 416E 88					DEY
     2 416F 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   245 4171 60			                RTS			   	; return
   246 				                
   247 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   248 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   249 				; ******************************************************************************
   250 4172			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: macros.inc]
     1 4172 86 E8			STX	STOL
     2 4174 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   251 4176 A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   252 4178 B9 C0 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   253 417E 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   254 4180 60			                RTS			   	; return
   255
   256 				; **** Increment a 32 Bit Value ************************************************
   257 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   258 				; ******************************************************************************
   259 4181 A2 01		INC_32          LDX     #$01
   260
   261 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   262 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   263 				; ******************************************************************************
   264 4183 A0 00		ADD_32_8        LDY     #$00
   265
   266 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   267 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   268 				; ******************************************************************************
   269 4185			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: macros.inc]
     1 4185 86 C4			STX	SUM32
     2 4187 84 C5			STY	SUM32+1
Source: boot_sys_block1.asm
   270 4189 A2 00 86 C6 86 C7			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   271
   272 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   273 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   274 				; ******************************************************************************
   275 418F 18			ADD_32_32       CLC			   	; clear carry flag
   276 4190 A2 00		                LDX     #$00		   	; start with byte 0
   277 4192 08			                PHP			   	; save carry flag
   278 4193 28			ADD_LOOP        PLP			   	; get carry flag back
   279 4194 B5 C4		                LDA     SUM32,X		   	; Get SUM32 byte
   280 4196 75 C0 95 C0		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   281 419A 08			                PHP			   	; save carry flag
   282 419B E8			                INX			   	; next byte
   283 419C			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: macros.inc]
     1 419C E0 04				CPX	#$04
     2 419E D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   284 41A0 28			                PLP			   	; restore stack
   285 41A1 60			                RTS			   	; return
    77 				               
    78 				; ******************************************************************************
    79 				; Start of remaining BOOT.SYS blocks *******************************************
    80 				; ******************************************************************************
    81 41A2					ORG     LOAD_ADDRESS + $0200
    82 4200			BLOCK_2
    83 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; NUM32 shl X
    10 				; ******************************************************************************
    11 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: macros.inc]
     1 4200 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4202 26 C1		        ROL     NUM32+1		  
     3 4204 26 C2		        ROL     NUM32+2
     4 4206 26 C3		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    12 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    13 420B 60			                RTS			  	; return
    14
    15 				; ******************************************************************************
    16 				; NUM32 shr X
    17 				; ******************************************************************************
    18 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: macros.inc]
     1 420C 46 C3			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 C2		        ROR     NUM32+2
     3 4210 66 C1		        ROR     NUM32+1
     4 4212 66 C0		        ROR     NUM32
Source: boot_sys_os.asm
    19 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    20 4217 60			                RTS			  	; return
    21 				                
    22 				; **** Write Logical Block From Standard Buffer ********************************
    23 				; Input: [X,Y] points to 32-bit LBA
    24 4218 A9 26		DEV_WR_LBLK_BUF  LDA    #CMD_WRITE_BUF	  	; Call Device-driver Write routine
    25 421A 4C BA E0		                 JMP    CMDDEV
    26
    27 				; **** Write Logical Block *****************************************************
    28 				; Input: [X,Y] points to 32-bit destination LBA
    29 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
    30 421D A9 23		DEV_WR_LBLK      LDA     #CMD_WRITE		; Call Device-driver Write routine
    31 421F 4C BA E0		                 JMP     CMDDEV
    32
    33 				; ******************************************************************************
    34 				; *                               OS Entry Point                               *
    35 				; ******************************************************************************
    36 4222			OS_MAIN         PRSTR	MSG_BOOT			; Print boot-message
Macro: PRSTR [Source: macros.inc]
     1 4222 A2 33			LDX	<MSG_BOOT				; MADS makes this immediate
     2 4224 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 4226 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    37 4229 20 41 49		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    38 				                
    39 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    40 422C A9 5C 8D 06 18 A9 + 		MWA	#CFC_LOAD CF_LOAD_VEC		; macro CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    41 4236 A9 92 8D 08 18 A9 + 		MWA	#CFC_SAVE CF_SAVE_VEC		; macro CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    42 4240 A9 9E 8D 0A 18 A9 + 		MWA	#OS_SHELL_ENTRY RETURN_VECT	; Return-vector for Monitor and BASIC
    43 424A A2 00 86 01 86 02			MWX	#0 Wrmjpl			; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    44 				                
    45 				; Clear Mount Table ************************************************************
    46 4250 18			                CLC
    47 4251 A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    48 4256 8A					TXA                          		; index to mount table into A
    49 4257 69 20		                ADC     #$20                 		; set to next entry
    50 4259 AA			                TAX
    51 425A 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    52 				                
    53 				; Set Boot Device As Current Device ********************************************
    54 425C A2 00		                LDX     #$00		     	; X=0
    55 425E A0 00		                LDY     #$00                 	; set index to mount table = 0
    56 4260 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    57 4263			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: macros.inc]
     1 4263 C9 22				CMP	#FDD1_ID
     2 4265 F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    58 4267 E8			                INX		     	     	; X=2
    59 4268 A0 20		                LDY     #$20                 	; set index to mount table = 32
    60 426A			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: macros.inc]
     1 426A C9 23				CMP	#FDD2_ID
     2 426C F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    61 426E E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    62 426F A0 40		                LDY     #$40                 	; set index to mount table = 64
    63 4271 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    64
    65 				; Add Boot Device To Mount Table ***********************************************
    66 4274 A2 00		                LDX     #$00
    67 4276 BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    68 427E			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: macros.inc]
     1 427E E0 20				CPX	#32
     2 4280 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    69 4282 A9 F8		                LDA     #$F8
    70 4284			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: macros.inc]
     1 4284 CD 09 04				CMP	D_MEDIUM_DESCR
     2 4287 D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    71 4289 A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    72 428E			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: macros.inc]
     1 428E AD 0A 04				LDA	D_FAT_TYPE
     2 4291 F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    73 4293 A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    74 4295			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: macros.inc]
     1 4295 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 4298 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    75 429B					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 429B CA					DEX
     2 429C D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    76 				                
    77 				; TODO: ADD MORE DEVICES #######################################################
    78
    79 				; **** Shell Entry Point *******************************************************
    80 				; ******************************************************************************
    81 429E 20 5F 55		OS_SHELL_ENTRY  JSR	GET_SIS		     		; Get sys. info sector		
    82 42A1 4C 9E 4B				JMP     SH_CMD_PROMPT			; start of command shell
    83
    84 				; **** Read First Block Of Actual Directory ************************************
    85 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    86 				; ******************************************************************************
    87 42A4			OS_FIRST_DIR_BLK
    88 42A4			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 42A4 AD 0A 04				LDA	D_FAT_TYPE
     2 42A7 F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    89 42A9 20 30 49		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    90 42AC 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    91
    92 42AE					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: macros.inc]
     1 42AE A2 03			LDX	#4-1
     2 42B0 BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42B7 10 F7			BPL	lp
Source: boot_sys_os.asm
    93 42B9 AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    94 42BC D0 17		                BNE     SET_NUM_BLOCKS       		; branch always
    95
    96 42BE			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: macros.inc]
     1 42BE A2 03			LDX	#4-1
     2 42C0 BD 04 04 95 A0 CA	lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C6 10 F8			BPL	lp
Source: boot_sys_os.asm
    97 42C8 20 F8 40		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
    98 42CB			                LDXYI   CURR_DIR_BLK			; LBA of current directory
Macro: LDXYI [Source: macros.inc]
     1 42CB A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42CD A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
    99 42CF 20 72 41		                JSR     STORE_32             		; and save result as current directory block
   100 42D2 AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
   101 42D5 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
   102
   103 				; **** Load Directory Block ****************************************************
   104 				; This routine reads a directory block into DIR_BLK_BUF.
   105 				; It is called from OS_NEXT_DIR_BLK.
   106 				; ******************************************************************************
   107 42D8 A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
   108 42E0					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: macros.inc]
     1 42E0 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42E2 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   109 42E4 4C 4B 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
   110
   111 				; **** Read Next Directory Block ***********************************************
   112 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   113 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   114 				; ******************************************************************************
   115 42E7 A2 00		OS_NEXT_DIR_BLK LDX     #$00
   116 42E9			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 42E9 FE 24 18				INC	CURR_DIR_BLK,X
     2 42EC D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   117 42EE E8			                INX                          		; overflow, increment next byte
   118 42EF			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: macros.inc]
     1 42EF C9 04				CMP	#$04
     2 42F1 D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   119 42F3 F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   120
   121 				; **** Read Next Directory Cluster *********************************************
   122 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   123 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   124 				; ******************************************************************************
   125 42F5			OS_NEXT_DIR_CLSTR
   126 42F5 20 7E 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   127 42F8 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   128 42FA 60			                RTS			     ; return
   129 				                
   130 				; **** Save Directory Block ****************************************************
   131 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   132 				; Input: X,Y = Pointer to LBA nr.
   133 				; ******************************************************************************
   134 42FB 86 D8		OS_SAVE_DIR     STX	SAVEX			; TODO: remove SAVEX, SAVEY ?
   135 42FD 84 D9				STY	SAVEY
   136 42FF A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; set source block buffer to DIR_BLK_BUF
   137 4307 A6 D8		                LDX     SAVEX       		; pointer to block number (LBA) to be saved
   138 4309 A4 D9		                LDY     SAVEY
   139 430B 4C 1D 42		                JMP     DEV_WR_LBLK          	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   140 				                
   141 				; **** Save FAT Block **********************************************************
   142 				; Write FAT table in BLOCK_BUFF ($0600) to disk with LBA nr in X,Y.
   143 				; Input: X,Y = Pointer to LBA nr.
   144 				; ******************************************************************************
   145 430E			OS_SAVE_FAT     LDXYI	CURR_FAT_BLK		; LBA nr of FAT
Macro: LDXYI [Source: macros.inc]
     1 430E A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 4310 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   146 4312 4C 18 42		                JMP     DEV_WR_LBLK_BUF        	; write FAT buffer and return
   147
   148 				; **** Create New File on Disk *************************************************
   149 				; Input: FILENAME = String8_3
   150 				;        A        = File Attributes
   151 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   152 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   153 				; ******************************************************************************
   154 4315 AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   155 4316 A0 00		                LDY     #D_FILENAME         		; set index to filename
   156 4318 B9 92 4B 91 A8 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   157 431E			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: macros.inc]
     1 431E C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4320 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   158 						
   159 						; Write Attribute
   160 4322 8A			                TXA                         	; yes, get attribute back to A
   161 4323 91 A8		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   162 4325 A9 00		                LDA     #$00                	; and clear all following bytes to 0
   163 4327 C8			                INY
   164 4328			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: macros.inc]
     1 4328 C0 20				CPY	#$20			; 
     2 432A 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   165 						
   166 						; Write create-Date and Last-write Date
   167 432C 20 B6 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   168 432F 98			                TYA				; Y = MSB
   169 4330 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   170 4332 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   171 4334 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   172 4336 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   173 4339 8A			                TXA				; X = LSB
   174 433A 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   175 433C A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   176 433E 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   177
   178 						; Write create-Time and last-write Time
   179 4340 20 91 43		                JSR     OS_FILETIME         	; get current time as file time
   180 4343 98			                TYA				; Y = MSB
   181 4344 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   182 4346 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   183 4348 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   184 434A 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   185 434D 8A			                TXA				; X = LSB
   186 434E 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   187 4350 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   188 4352 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   189
   190 						; Write File Cluster Nr High and Low
   191 4354 A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   192 4356 AD 23 18 91 A8 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   193 435C AD 22 18 91 A8			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   194 4361 A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   195 4363 AD 21 18 91 A8 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   196 4369 AD 20 18 91 A8			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   197 						
   198 436E AD 12 18				LDA     F_ATTRIBS				; Get file/dir attributes again
   199 4371					AND.NE  #FA_DIRECTORY OS_CR_SAV			; create a dir? Branch if it is a dir
Macro: AND.NE [Source: macros.inc]
     6 4371 29 10				AND	#FA_DIRECTORY
     7 4373 D0 15				BNE	OS_CR_SAV
Source: boot_sys_os.asm
   200
   201 4375 A0 1C		                LDY     #D_FILE_SIZE      			; index to file size in dir. entry
   202 4377 AD 48 52 91 A8 C8 + 		MWA	SAVE_LEN (CURR_DIR_ENTRY),Y+		; Save file-length in current dir. entry
   203 4383 A9 00 91 A8 C8 91 + 		MWA	#0 (CURR_DIR_ENTRY),Y			; Set high-word of file-size to 0
   204 						
   205 438A			OS_CR_SAV	LDXYI	CURR_DIR_BLK				; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: macros.inc]
     1 438A A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 438C A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   206 438E 4C FB 42		                JMP     OS_SAVE_DIR	    			; write this dir entry back to disk and return
   207 				                
   208 				; **** Get Current Time As File Time *******************************************
   209 				; Output: File Time = Word[X,Y]
   210 				; ******************************************************************************
   211 4391 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   212
   213 				; **** Convert Time To File Time ***********************************************
   214 				; Input:  A - HOUR 	in BCD ($00-$23)
   215 				;	  X - MINUTE 	in BCD ($00-$59)
   216 				;	  Y - SECONDS	in BCD ($00-$59)
   217 				; Output: File Time = Word[X,Y]
   218 				; ******************************************************************************
   219 4394			OS_TIME_TO_FILETIME
   220 4394 20 DD 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   221 4397 85 C0		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   222 4399 A9 00 85 C1				MVA	#$00 NUM32+1	    ; clear upper byte of result
   223 439D A2 06		                LDX     #$06
   224 439F 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   225 43A2 A5 C5		                LDA     SUM32+1             ; load MINUTE into A
   226 43A4 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   227 43A8 A2 05		                LDX     #$05
   228 43AA 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   229 43AD A5 C6		                LDA     SUM32+2             ; load SECONDS into A
   230 43AF 6A			                ROR                         ; divide SECONDS by 2
   231 43B0 05 C0		                ORA     NUM32               ; and add value into result
   232 43B2 AA			                TAX
   233 43B3 A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   234 43B5 60			                RTS
   235 				                
   236 				; **** Get Current Date As File Date *******************************************
   237 				; Output: File Date = Word[X,Y]
   238 				; ******************************************************************************
   239 43B6 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   240
   241 				; **** Convert Date To File Date ***********************************************
   242 				; Input:  A - YEAR 	in BCD ($00-$99)
   243 				; 	  X - MONTH 	in BCD ($01-$12)
   244 				; 	  Y - DAY	in BCD ($01-$31)
   245 				; Output: File Date = Word[X,Y]
   246 				; ******************************************************************************
   247 43B9			OS_DATE_TO_FILEDATE
   248 43B9 20 DD 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   249 43BC 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   250 43BF 85 C0		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   251 43C1 A9 00 85 C1		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   252 43C5 A2 04		                LDX     #$04
   253 43C7 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   254 43CA A5 C5		                LDA     SUM32+1             ; load MONTH into A
   255 43CC 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   256 43D0 A2 05		                LDX     #$05
   257 43D2 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   258 43D5 A5 C6		                LDA     SUM32+2             ; load DAY into A
   259 43D7 05 C0		                ORA     NUM32               ; and add value into result
   260 43D9 AA			                TAX
   261 43DA A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   262 43DC 60			                RTS
   263 				                
   264 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   265 43DD			CONVERT_DATETIME
   266 43DD 85 C4		                STA     SUM32		    ; Year or Hour
   267 43DF					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: macros.inc]
     1 43DF 86 C5			STX	SUM32+1
     2 43E1 84 C6			STY	SUM32+1+1
Source: boot_sys_os.asm
   268 43E3 A0 02		                LDY     #$02		    ; 3 bytes to convert
   269 43E5 B9 C4 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   270 43E8 20 7C 4E		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   271 43EB 99 C4 00 88		                STA     SUM32,Y-	    ; Store result back
   272 43EF 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   273 43F1 60			                RTS			    ; return
   274
   275 				; **** Copy First block of File to memory **************************************
   276 				; Input:
   277 				; ******************************************************************************
   278 43F2 20 76 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   279 43F5					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: macros.inc]
     1 43F5 AD 6C 44				LDA	FTYPE
     2 43F8 F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   280 43FA					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: macros.inc]
     1 43FA C9 01				CMP	#1
     2 43FC F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   281 						
   282 						; .EXE file (FTYPE=2)
   283 43FE AD 00 5B 8D 0F 45			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   284 4404 85 CC				STA	END_PTR			; destination address LSB
   285 4406 AD 01 5B 8D 10 45			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   286 440C 85 CD				STA	END_PTR+1		; destination address MSB
   287 440E A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   288 4412 D0 1C				BNE	COPY_BLK_DEST		; branch always
   289 						
   290 						; .COM file  (FTYPE=1)
   291 4414 A9 00 8D 0F 45	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   292 4419 85 CC				STA	END_PTR			 ; destination address LSB
   293 441B A9 30 8D 10 45			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   294 4420 85 CD				STA	END_PTR+1		 ; destination address MSB
   295 4422 D0 0C				BNE	COPY_BLK_DEST		 ; branch always
   296 						
   297 						; .BAS file (FTYPE=0)
   298 4424 A9 00 85 CC A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR END_PTR	; destination = BAS_LOAD_ADDR, 1st 2 bytes contain end-address
   299 442C A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; skip first 2 bytes of .BAS file (contains $00 $20)
   300 						
   301 				; **** Copy Second and other blocks of File to Memory **************************
   302 				; Input:
   303 				; ******************************************************************************
   304 4430			COPY_BLK_DEST	PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 4430 A9 5B			LDA	#'['
     2 4432 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   305 4435					PRHEX16	PSTR
Macro: PRHEX16 [Source: macros.inc]
     1 4435 A5 EB			LDA	PSTR+1				; print MSB
     2 4437 20 91 E0			JSR	HEXOUT
     3 443A A5 EA			LDA	PSTR
     4 443C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   306 443F					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 443F A9 2C			LDA	#','
     2 4441 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   307 4444					PRHEX16	END_PTR
Macro: PRHEX16 [Source: macros.inc]
     1 4444 A5 CD			LDA	END_PTR+1				; print MSB
     2 4446 20 91 E0			JSR	HEXOUT
     3 4449 A5 CC			LDA	END_PTR
     4 444B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   308 444E					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 444E A9 5D			LDA	#']'
     2 4450 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   309 4453 A0 00				LDY	#0
   310 4455 B1 EA 91 CC		CP_BLK0_LP	MVA	(PSTR),Y (END_PTR),Y		; Get byte from buffer and store in destination
   311 4459 E6 CC D0 02 E6 CD			INW	END_PTR				; Increment destination pointer (macro)
   312 445F E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
   313 4465 A5 EB				LDA	PSTR+1				; MSB of buffer pointer
   314 4467					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: macros.inc]
     1 4467 C9 5D				CMP	#>FILE_BUFF+2
     2 4469 D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_os.asm
   315 446B 60					RTS					; return
   316 						
   317 446C 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   318
   319 				; **** Init File Buffer ********************************************************
   320 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   321 				; ******************************************************************************
   322 446D A9 00 85 DC A9 5B + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   323 4475 60					RTS				; return
   324 						
   325 				; **** Init File-buffer pointer ************************************************
   326 				; This routine sets PSTR to FILE_BUFF
   327 				; ******************************************************************************
   328 4476 A9 00 85 EA A9 5B + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   329 447E 60					RTS				; return
   330
   331 				; **** Load BAS/COM/EXE File ***************************************************
   332 				; Input: CURR_CLUSTER: cluster nr of file to load
   333 				; ******************************************************************************
   334 447F 20 43 48		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       		; check if filesize is 0
   335 4482 90 01		                BCC     OS_LOAD_COM2			; branch if file is not empty
   336 						
   337 4484 60			                RTS                         		; filesize is 0, just do nothing
   338 						
   339 4485			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      		; current cluster nr
Macro: LDXYI [Source: macros.inc]
     1 4485 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 4487 A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   340 4489 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   341 448C A9 00 85 AB		                MVA     #$00 BCNT              		; init. block counter
   342 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   343 4490 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   344 4495 A0 1D		                LDY     #D_FILE_SIZE+1      		; index to file size in dir. entry
   345 4497 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file size byte 1
   346 4499 4A			                LSR                         		; check if bit 0 is set (bytes 256-511 of buffer)
   347 449A 48			                PHA			    		; save byte: now contains file-size in blocks of 512 bytes
   348 449B B0 06		                BCS     LOAD_COM1           		; yes, add one block
   349 						
   350 449D 88			                DEY					; now points to D_FILE_SIZE LSB
   351 449E			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: macros.inc]
     1 449E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44A0 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   352 44A2 38			                SEC                         		; yes, add one block
   353 44A3 68			LOAD_COM1       PLA
   354 44A4 65 AB 85 AB		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   355 44A8			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: macros.inc]
     1 44A8 C9 59				CMP	#89			; 
     2 44AA B0 28				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   356 						
   357 44AC A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   358 44AE			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44AE B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B0 D0 22				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   359 44B2 C8			                INY					; D_FILE_SIZE+3
   360 44B3			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44B3 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B5 D0 1D				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   361 						
   362 						; Read first part of file into FILE_BUFF
   363 44B7 20 6D 44				JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   364 44BA			                LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44BA A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44BC A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   365 44BE 20 4B 41		                JSR     DEV_RD_LBLK         		; Read first block of file into FILE_BUFF
   366 44C1 20 F2 43				JSR	COPY_BLK0_DEST			; Copy first block to destination
   367 44C4					DEC.EQ	BCNT OS_EXEC_CHK		; Branch if #blocks to read is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44C4 C6 AB				DEC	BCNT
     2 44C6 F0 3E				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   368 44C8					DEC.EQ  SCNT NEXT_CLUSTER0     		; Branch if sectors/cluster is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44C8 C6 AD				DEC	SCNT
     2 44CA F0 2A				BEQ	NEXT_CLUSTER0
Source: boot_sys_os.asm
   369 						
   370 44CC 20 DB 44		                JSR     LOAD_NEXT_BLKS	    		; Load next blocks of file and execute it
   371 44CF A9 25		                LDA     #HDD1_ID   	    		; Replace by D_DEV_ID?
   372 44D1 4C AA E1				JMP     OPEN_DEVICE			; Init. device driver again and return
   373 						
   374 44D4			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      		; load error message...
Macro: LDXYI [Source: macros.inc]
     1 44D4 A2 83			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 44D6 A0 4B			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   375 44D8 4C C5 49		                JMP     OS_PRINT_ERR			; Print it
   376
   377 				; **** Read Next File Blocks ***************************************************
   378 				; ******************************************************************************
   379 44DB 20 81 41		LOAD_NEXT_BLKS  JSR     INC_32              		; Increment LBA block address in NUM32
   380 44DE 20 6D 44		LOAD_BLK0       JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   381 44E1					LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44E1 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44E3 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   382 44E5 20 4B 41		                JSR     DEV_RD_LBLK         		; and read next block of file into FILE_BUFF
   383 44E8 20 76 44				JSR	INIT_FBUF_PTR			; reset file-buffer pointer PSTR to FILE_BUFF again
   384 44EB 20 30 44				JSR	COPY_BLK_DEST	    		; Copy block to destination
   385 44EE			                DEC.EQ  BCNT OS_EXEC_CHK      		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 44EE C6 AB				DEC	BCNT
     2 44F0 F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   386 44F2					DEC.NE  SCNT LOAD_NEXT_BLKS    		; branch if more blocks in cluster to read
Macro: DEC.NE [Source: macros.inc]
     1 44F2 C6 AD				DEC	SCNT
     2 44F4 D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   387
   388 				; next cluster needs to be loaded considering the volume FAT type **************
   389 44F6 20 7E 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   		; Get next cluster from FAT table in CURR_CLUSTER.
   390 44F9 B0 0B		                BCS     OS_EXEC_CHK	    		; C=1, EOF, go execute File
   391 							
   392 44FB 20 F8 40		                JSR     CLUSTER_TO_BLK	    		; convert CURR_CLUSTER to LBA number in NUM32.
   393 44FE AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   394 4503 4C DE 44		                JMP     LOAD_BLK0	    		; branch always
   395 						
   396 				; Run file if needed ***********************************************************
   397 				; ******************************************************************************
   398 4506			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: macros.inc]
     1 4506 AD 6C 44				LDA	FTYPE
     2 4509 D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   399 450B 60					RTS					; return in case of a .BAS file
   400
   401 				; **** Execute File ************************************************************
   402 				; Input:  Ptr[OS_PROG] to Start Address
   403 				; Output: A - Result Code
   404 				; ******************************************************************************
   405 450C 6C 0F 45		OS_EXECUTE      JMP     (OS_PROG)           		; run .com or .exe file
   406 450F 00 00		OS_PROG         .word      $0000
   407 				                
   408 				; **** Save the contents of a file to disk *************************************
   409 				; OS_CREATE/OS_CREATE_FILE has already created an entry in the current directory
   410 				; and allocated the first free cluster (in CURR_CLUSTER) to the file. If the file
   411 				; existed, it was deleted first, so you always have a new first cluster number. 
   412 				; This routine writes all sectors of this file and updates (=links clusters 
   413 				; together) the FAT table. 
   414 				; Input: FREE_CLUSTER: first cluster nr of file to save
   415 				; ******************************************************************************
   416 4511			OS_SAVE_FILE	LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 4511 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4513 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   417 4515 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   418 4518 A9 FE 8D A5 45 A9 + 		MWA	#$1FFE FSAVE_PTR		; Init. BLKBUF to start of .BAS file to save
   419 4522 20 86 FD				JSR	MON2RAM				; Enable RAM behind Monitor ROM ($1C00-$1FFF)
   420 4525 A9 00 8D FE 1F A9 + 		MWA	#$2000 $1FFE			; Set first word of Basic file to start-address
   421 452F AD 4A 52 85 AB	                MVA     SAVE_SECS BCNT      		; init. block counter, SAVE_SECS was calculated by CFC_SAVE
   422 4534 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   423 4539 A9 01 8D F9 55			MVA	#1 SIS_CNT			; #clusters allocated
   424
   425 				; Write sectors/cluster until --BCNT = 0
   426 453E AD A5 45 85 DC AD + SAVE_NXT_BLK	MWA	FSAVE_PTR BLKBUF		; BLKBUF = FSAVE_PTR
   427 4548					LDXYI	NUM32				; LBA number
Macro: LDXYI [Source: macros.inc]
     1 4548 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 454A A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   428 454C 20 1D 42				JSR	DEV_WR_LBLK			; Write another sector to disk
   429 454F EE A6 45 EE A6 45		:2	INC	FSAVE_PTR+1			; BLKBUF += $0200, points to next block in memory to save
   430 4555			                DEC.EQ  BCNT OS_SAVE_X      		; branch if no more blocks to write
Macro: DEC.EQ [Source: macros.inc]
     1 4555 C6 AB				DEC	BCNT
     2 4557 F0 2F				BEQ	OS_SAVE_X
Source: boot_sys_os.asm
   431 4559					DEC.EQ  SCNT SAVE_NXT_CLSTR    		; branch if more blocks in cluster to write
Macro: DEC.EQ [Source: macros.inc]
     1 4559 C6 AD				DEC	SCNT
     2 455B F0 06				BEQ	SAVE_NXT_CLSTR
Source: boot_sys_os.asm
   432 455D 20 81 41				JSR     INC_32				; Increment LBA block address in NUM32
   433 4560 4C 3E 45				JMP	SAVE_NXT_BLK			; branch always
   434 						
   435 				; next cluster needs to be allocated considering the volume FAT type **************
   436 4563			SAVE_NXT_CLSTR	MVAX	4 FREE_CLUSTER PREV_CLUSTER	; PREV_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4563 A2 03			LDX	#4-1
     2 4565 BD 20 18 9D 8B 45 + lp	MVA	FREE_CLUSTER,X PREV_CLUSTER,X-
     3 456C 10 F7			BPL	lp
Source: boot_sys_os.asm
   437 456E 20 A2 47				JSR     OS_ADD_CLUSTER	   		; Find next free cluster in FAT and allocates it (does NOT write FAT back to disk)
   438 4571 20 A7 45				JSR	LINK_FAT_ENTRY			; Link new FREE_CLUSTER to PREV_CLUSTER (does NOT write FAT back to disk)
   439 4574 20 0E 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   440 4577 EE F9 55				INC	SIS_CNT				; #clusters allocated += 1
   441 457A					LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 457A A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 457C A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   442 457E 20 FC 40		                JSR     CLSTR_TO_BLK	    		; convert FREE_CLUSTER to LBA number in NUM32.
   443 4581 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   444 4586 D0 B6		                BNE     SAVE_NXT_BLK	    		; branch always
   445
   446 4588 4C 7D FD		OS_SAVE_X	JMP	MON2ROM				; Switch back to Monitor ROM and return
   447
   448 458B 00 00 00 00		PREV_CLUSTER	.dword 	$00000000			; Previous cluster nr of file
   449 458F 4C 69 6E 6B 5F 46 + TXT_LINK	.by	'Link_FAT_Entry: ' $00
   450 45A0 20 74 6F 20 00	TXT_LINK2	.by	' to ' $00
   451 45A5 00 00		FSAVE_PTR	.word	$0000				; File-save Pointer
   452
   453 				; ******************************************************************************
   454 				; Links a new cluster (FREE_CLUSTER) to the current cluster (PREV_CLUSTER) of a file.
   455 				; It also updates (writes) the FAT table.
   456 				; ******************************************************************************
   457 45A7			LINK_FAT_ENTRY	PRSTR	TXT_LINK
Macro: PRSTR [Source: macros.inc]
     1 45A7 A2 8F			LDX	<TXT_LINK				; MADS makes this immediate
     2 45A9 A0 45			LDY	>TXT_LINK
Source: boot_sys_os.asm
     2 45AB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   458 45AE					PRHEX32	PREV_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45AE AD 8E 45			LDA	PREV_CLUSTER+2+1				; print MSB
     2 45B1 20 91 E0			JSR	HEXOUT
     3 45B4 AD 8D 45			LDA	PREV_CLUSTER+2
     4 45B7 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45BA AD 8C 45			LDA	PREV_CLUSTER+1				; print MSB
     2 45BD 20 91 E0			JSR	HEXOUT
     3 45C0 AD 8B 45			LDA	PREV_CLUSTER
     4 45C3 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   459 45C6					PRSTR	TXT_LINK2
Macro: PRSTR [Source: macros.inc]
     1 45C6 A2 A0			LDX	<TXT_LINK2				; MADS makes this immediate
     2 45C8 A0 45			LDY	>TXT_LINK2
Source: boot_sys_os.asm
     2 45CA 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   460 45CD					PRHEX32	FREE_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45CD AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 45D0 20 91 E0			JSR	HEXOUT
     3 45D3 AD 22 18			LDA	FREE_CLUSTER+2
     4 45D6 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45D9 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 45DC 20 91 E0			JSR	HEXOUT
     3 45DF AD 20 18			LDA	FREE_CLUSTER
     4 45E2 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   461 45E5 20 5A E0				JSR	CROUT				; Print CR
   462 45E8 AD 8B 45				LDA	PREV_CLUSTER			; get LSB of PREV_CLUSTER
   463 45EB 0A 0A			:2	ASL					; SHL2, DWORD index in FAT page
   464 45ED A8					TAY					; Y = DWORD byte 0 in FAT page
   465 45EE AD 8C 45				LDA	PREV_CLUSTER+1
   466 45F1 4A					LSR					; check bit 0 of PREV_CLUSTER[1]
   467 45F2 B0 19				BCS	LINK_UPPER_PAGE			; if bit 0 = 1 then write byte to upper half of block
   468 						
   469 						; lower half block of Buffer
   470 45F4 AD 20 18 99 00 06 + 		MWA	FREE_CLUSTER   BLOCK_BUFF,Y	; Write CURR_CLUSTER nr into PREV_CLUSTER FAT entry
   471 4600 AD 22 18 99 02 06 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+2,Y
   472 460C 60					RTS					; return
   473 						
   474 						; upper half block of Buffer
   475 460D AD 20 18 99 00 07 + LINK_UPPER_PAGE	MWA	FREE_CLUSTER   BLOCK_BUFF+256,Y
   476 4619 AD 22 18 99 02 07 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+258,Y
   477 4625 60					RTS					; return
   478
   479 				; ******************************************************************************
   480 4626			INIT_FREE_CLUSTER
   481 4626 A9 02 8D 20 18 A9 + 		MWA	#$02 FREE_CLUSTER		; first data cluster is $000002
   482 4630 8D 22 18				STA     FREE_CLUSTER+2
   483 4633 8D 23 18		                STA     FREE_CLUSTER+3
   484 4636 60			                RTS
   485 				                
   486 				; ******************************************************************************
   487 				; Input: FREE_CLUSTER: number of possible free cluster
   488 				; Output: C=1: CURR_CLUSTER is free ; C=0: 
   489 				; ******************************************************************************
   490 4637			OS_NEXT_FREE_CLUSTER
   491 4637			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4637 A2 03			LDX	#4-1
     2 4639 BD 20 18 95 A0 CA	lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 463F 10 F8			BPL	lp
Source: boot_sys_os.asm
   492 4641 20 7E 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   493 4644 A2 03		                LDX     #$03
   494 4646			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: macros.inc]
     1 4646 B5 A0				LDA	CURR_CLUSTER,X
     2 4648 D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   495 464A			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: macros.inc]
     1 464A CA					DEX
     2 464B 10 F9				BPL	CHK_FREE
Source: boot_sys_os.asm
   496 464D 38			                SEC                         		; cluster is free, exit with C = 1
   497 464E 60			                RTS
   498
   499 				; ******************************************************************************
   500 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   501 				; ******************************************************************************
   502 464F A2 00		SET_NEXT_CLSTR  LDX     #$00
   503 4651			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 4651 FE 20 18				INC	FREE_CLUSTER,X
     2 4654 D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   504 4656 E8			                INX						; next byte of FREE_CLUSTER
   505 4657			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4657 E0 04				CPX	#$04
     2 4659 D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   506 						
   507 465B A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   508 465D B5 A4		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   509 465F			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: macros.inc]
     1 465F DD 18 04				CMP	D_START_FAT2,X			; 
     2 4662 90 D3				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   510 4664			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4664 CA					DEX
     2 4665 10 F6				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   511 4667 18			                CLC                         			; no emtpy cluster found, exit with error
   512 4668 60			                RTS
   513
   514 				; ******************************************************************************
   515 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   516 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   517 				; BLOCK_BUFF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   518 				; in FREE_CLUSTER needs to be allocated in the FAT table.
   519 				; ******************************************************************************
   520 4669			UPDATE_FAT_TABLE
   521 4669					PRCH	'['			; Print [
Macro: PRCH [Source: macros.inc]
     1 4669 A9 5B			LDA	#'['
     2 466B 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   522 466E					PRHEX16	FREE_CLUSTER		; Print FREE_CLUSTER
Macro: PRHEX16 [Source: macros.inc]
     1 466E AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4671 20 91 E0			JSR	HEXOUT
     3 4674 AD 20 18			LDA	FREE_CLUSTER
     4 4677 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   523 467A					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 467A A9 5D			LDA	#']'
     2 467C 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   524 467F AD 20 18				LDA	FREE_CLUSTER		; get LSB of cluster nr
   525 4682 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   526 4684 A8					TAY				; Y = DWORD byte 0 in FAT page
   527 					.rept 3					; Write 3 x $FF into FAT entry
   528 						LDA	#$FF			
   529 						JSR	WRITE_ENTRY_BYTE	
   530 						INY				
   531 					.endr	
Source: REPT
   528 4685 A9 FF				LDA	#$FF			
   528 4687 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 468A C8					INY				
   528 468B A9 FF				LDA	#$FF			
   528 468D 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 4690 C8					INY				
   528 4691 A9 FF				LDA	#$FF			
   528 4693 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 4696 C8					INY				
Source: boot_sys_os.asm
   532 4697 A9 0F				LDA	#$0F			; write end marker
   533 4699 4C 9C 46				JMP	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   534 						
   535 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   536 				; INPUT : A = Write Data
   537 				;         Y - Index To FAT Entry Byte
   538 				; ******************************************************************************
   539 469C			WRITE_ENTRY_BYTE
   540 469C AA					TAX
   541 469D AD 21 18		                LDA     FREE_CLUSTER+1
   542 46A0 4A			                LSR				; check bit 0 of free_cluster[1]
   543 46A1 8A			                TXA
   544 46A2 B0 04		                BCS     WR_UPPER_PAGE       	; if bit 0 = 1 then write byte to upper half of block
   545 						
   546 46A4 99 00 06		                STA     BLOCK_BUFF,Y		; write entry byte to lower half of block buffer
   547 46A7 60					RTS				
   548 						
   549 46A8 99 00 07		WR_UPPER_PAGE   STA     BLOCK_BUFF+256,Y	; write entry byte to upper half of block buffer
   550 46AB 60					RTS
   551 				                
   552 				; **** Add Date and Time to subdir entry ***************************************
   553 				; ******************************************************************************
   554 46AC			ADD_DATE_TIME	; Write create-Date and Last-write Date
   555 46AC 20 B6 43				JSR     OS_FILEDATE         	; get current date as file date
   556 46AF 98			                TYA				; Y = MSB
   557 46B0 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   558 46B2 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   559 46B4 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   560 46B6 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   561 46B9 8A			                TXA				; X = LSB
   562 46BA 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   563 46BC A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   564 46BE 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   565
   566 						; Write create-Time and last-write Time
   567 46C0 20 91 43		                JSR     OS_FILETIME         	; get current time as file time
   568 46C3 98			                TYA				; Y = MSB
   569 46C4 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   570 46C6 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   571 46C8 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   572 46CA 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   573 46CD 8A			                TXA				; X = LSB
   574 46CE 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   575 46D0 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   576 46D2 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   577 46D4 60					RTS
   578 						
   579 				; **** Add new subdirectory entry to dir buffer ********************************
   580 				; Input: X=1: . subdir, X=2: .. subdir
   581 				; ******************************************************************************
   582 46D5 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   583 46D6 48					PHA					; save it
   584 46D7 A0 00				LDY	#D_FILENAME			; Filename entry
   585 46D9 A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   586 46DE			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: macros.inc]
     1 46DE C0 0B				CPY	#D_ATTRIBUTES			; 
     2 46E0 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   587
   588 46E2 A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   589 46E6 A0 00				LDY	#D_FILENAME			; Filename entry
   590 46E8 A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   591 46EA 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   592 46ED					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: macros.inc]
     1 46ED CA					DEX
     2 46EE D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   593
   594 46F0 20 AC 46				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   595 46F3 68					PLA
   596 46F4					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: macros.inc]
     1 46F4 C9 01				CMP	#1
     2 46F6 D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   597 					
   598 						; Current subdir .: Write File Cluster Nr High and Low
   599 46F8 A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   600 46FA AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   601 4700 AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   602 4705 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   603 4707 AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   604 470D AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   605 4712 60					RTS					; return
   606 						
   607 						; Parent subdir ..: Write File Cluster Nr High and Low
   608 4713 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   609 4715 AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   610 471B AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   611 4720 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   612 4722 AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   613 4728 AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   614 472D 60					RTS
   615 						
   616 				; **** Add new Directory Cluster to Disk ***************************************
   617 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   618 				; ******************************************************************************
   619 472E			ADD_NEW_DIR_CLST
   620 472E A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   621 4736 A2 01				LDX	#1
   622 4738 A9 00				LDA	#0
   623 473A			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: macros.inc]
     1 473A 91 DC C8				STA	(BLKBUF),Y+
     2 473D D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   624 473F E6 DD				INC	BLKBUF+1		; next page
   625 4741					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: macros.inc]
     1 4741 CA					DEX
     2 4742 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   626 						
   627 4744 A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   628 4748 A2 01				LDX	#1			; 1 = . subdir entry
   629 474A 20 D5 46				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   630 474D A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   631 4754 A2 02				LDX	#2			; 2 = .. subdir entry
   632 4756 20 D5 46				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   633
   634 						; and write it to disk
   635 				.if	DBG_PRINT = 1
   636 4759					PRSTR	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTR [Source: macros.inc]
     1 4759 A2 89			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 475B A0 47			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 475D 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   637 4760					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: macros.inc]
     1 4760 AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 4763 20 91 E0			JSR	HEXOUT
     3 4766 AD 22 18			LDA	FREE_CLUSTER+2
     4 4769 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 476C AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 476F 20 91 E0			JSR	HEXOUT
     3 4772 AD 20 18			LDA	FREE_CLUSTER
     4 4775 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   638 4778 20 5A E0				JSR	CROUT			; Print CR
   639 				.endif
   640 477B					LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: macros.inc]
     1 477B A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 477D A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   641 477F 20 FC 40				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   642 4782					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: macros.inc]
     1 4782 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4784 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   643 4786 4C FB 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   644 						
   645 4789 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   646
   647 				; **** Add First Cluster To Empty File *****************************************
   648 				; Note: does NOT write FAT table back to disk, only FAT table in memory is updated.
   649 				; ******************************************************************************
   650 47A2 20 26 46		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   651 47A5 20 37 46				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   652 47A8 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   653 						
   654 47AA 20 69 46		                JSR     UPDATE_FAT_TABLE	; Allocate FREE_CLUSTER, does NOT write FAT block back to disk
   655 47AD 60			ADD_CLUSTER_END RTS
   656
   657 				; **** Create New File *********************************************************
   658 				; Input:  A = File Attributes
   659 				; Output: C = 0 - Error; C = 1 - No Error
   660 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   661 				; ******************************************************************************
   662 47AE 8D 12 18		OS_CREATE       STA     F_ATTRIBS           		; save attributes
   663 47B1			                AND.EQ  #FA_DIRECTORY ADD_FILE 		; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: macros.inc]
     6 47B1 29 10				AND	#FA_DIRECTORY
     7 47B3 F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   664 						
   665 						; Find directory
   666 47B5 20 58 48		                JSR     OS_DIR_EXISTS       		; C=1: dirname already exists
   667 47B8 90 21				BCC	OS_CREATE_CONT			; branch if dirname does not exist yet
   668 47BA B0 4E				BCS	OS_CREATE_ERR			; branch on error
   669
   670 						; Find file
   671 47BC 20 5E 48		ADD_FILE        JSR     OS_FILE_EXISTS      		; check if file already exists
   672 47BF 90 1A				BCC	OS_CREATE_CONT			; branch if file does not exist
   673 						
   674 						; delete file (SH_DEL)	
   675 47C1					PRSTR	TXT_OVERWRITE			; Print 'File exists, overwrite (y/n)?'
Macro: PRSTR [Source: macros.inc]
     1 47C1 A2 0C			LDX	<TXT_OVERWRITE				; MADS makes this immediate
     2 47C3 A0 48			LDY	>TXT_OVERWRITE
Source: boot_sys_os.asm
     2 47C5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   676 47C8 20 47 E0				JSR 	CIN           			; get character
   677 47CB 29 DF				AND 	#$DF            		; uppercase chars only
   678 47CD					CMP.NE 	#'Y' OS_CREATE_ERR    		; if not Y then exit with error
Macro: CMP.NE [Source: macros.inc]
     1 47CD C9 59				CMP	#'Y'
     2 47CF D0 39				BNE	OS_CREATE_ERR
Source: boot_sys_os.asm
   679 47D1					PRSTR	TXT_SH_DEL			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47D1 A2 3B			LDX	<TXT_SH_DEL				; MADS makes this immediate
     2 47D3 A0 48			LDY	>TXT_SH_DEL
Source: boot_sys_os.asm
     2 47D5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   680 47D8 20 AC 53				JSR	SH_DEL_FILE			; Delete file and update FAT table
   681
   682 47DB 20 A2 47		OS_CREATE_CONT	JSR	OS_ADD_CLUSTER			; Return free cluster in FREE_CLUSTER (does NOT write FAT back to disk)
   683 47DE 20 0E 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   684 						; Find a Free dir. entry and fill it with file info and save it to disk
   685 47E1 20 52 48				JSR 	OS_FIND_FREE			; Find a free directory entry in the current directory
   686 				.if	DBG_PRINT = 1
   687 47E4					PRSTR	TXT_FFREE1			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47E4 A2 2A			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 47E6 A0 48			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 47E8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   688 47EB					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 47EB A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 47ED 20 91 E0			JSR	HEXOUT
     3 47F0 A5 A8			LDA	CURR_DIR_ENTRY
     4 47F2 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   689 47F5 20 5A E0				JSR	CROUT				; Print CR
   690 				.endif
   691 47F8 AD 12 18		                LDA     F_ATTRIBS			; Get file/dir attributes
   692 47FB 20 15 43				JSR	OS_CREATE_FILE			; create the file/dir on disk
   693 47FE AD 12 18				LDA     F_ATTRIBS			; Get file/dir attributes again
   694 4801					AND.EQ  #FA_DIRECTORY OS_CREATE_X	; create a file? Branch if it is a file
Macro: AND.EQ [Source: macros.inc]
     6 4801 29 10				AND	#FA_DIRECTORY
     7 4803 F0 03				BEQ	OS_CREATE_X
Source: boot_sys_os.asm
   695 						
   696 4805 20 2E 47				JSR	ADD_NEW_DIR_CLST		; Add new dir cluster with . and .. and save it to disk
   697 4808 38			OS_CREATE_X	SEC					; C=1, OK
   698 4809 60			                RTS					; and return
   699 480A 18			OS_CREATE_ERR   CLC					; C=0, error
   700 480B 60			OS_CREATE_END   RTS					; return
   701 				                
   702 480C 46 69 6C 65 20 65 + TXT_OVERWRITE	.by	'File exists, overwrite (y/n)?' $00
   703 482A 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   704 483B 53 48 5F 44 45 4C + TXT_SH_DEL	.by	'SH_DEL' CR $00
   705
   706 				; **** Test If File Is Empty ************** ************************************
   707 				; Input:  Ptr(CURR_DIR_ENTRY)
   708 				; Output: C = 1 - File is empty; C = 0 - File not empty
   709 				; ******************************************************************************
   710 4843 A2 04		OS_FILE_EMPTY   LDX     #$04
   711 4845 A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   712 4847 18			                CLC
   713 4848			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: macros.inc]
     1 4848 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 484A D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   714 484C C8			                INY
   715 484D			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: macros.inc]
     1 484D CA					DEX
     2 484E D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   716 4850 38			                SEC			    			; C=1: File is empty
   717 4851 60			OS_FILE_EMPTY2  RTS			    			; return
   718
   719 				; **** Check If a directory entry is free or deleted ***************************
   720 				; ******************************************************************************
   721 4852			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: macros.inc]
     1 4852 A2 13			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 4854 A0 4B			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   722 4856 D0 1A		                BNE     OS_FIND			; branch always
   723
   724 				; **** Check If Directory Already Exists ***************************************
   725 				; ******************************************************************************
   726 4858			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 4858 A2 C7			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 485A A0 4A			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   727 485C D0 14		                BNE     OS_FIND			; branch always
   728 				                
   729 				; **** Check If Directory Is Available *****************************************
   730 				; ******************************************************************************
   731 485E			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 485E A2 EB			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 4860 A0 4A			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   732 4862 D0 0E		                BNE     OS_FIND			; branch always
   733
   734 				; **** Find Directory **********************************************************
   735 				; ******************************************************************************
   736 4864			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 4864 A2 CA			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 4866 A0 4A			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   737 4868 D0 08		                BNE     OS_FIND			; branch always
   738
   739 				; **** Find File ***************************************************************
   740 				; ******************************************************************************
   741 486A			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: macros.inc]
     1 486A A2 EE			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 486C A0 4A			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   742 				                                           ; fall through to OS_FIND
   743 				                                           
   744 				; **** Find All Files **********************************************************
   745 				; ******************************************************************************
   746 486E A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   747 4870 D0 02		                BNE     OS_FIND2
   748
   749 				; **** Main Find Routine *******************************************************
   750 				; ******************************************************************************
   751 4872 A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   752 4874			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: macros.inc]
     1 4874 8E 31 4B			STX	CMD_ADDR
     2 4877 8C 32 4B			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   753 				                                            ; fall through to OS_DIR_LOOP
   754
   755 				; **** Loop Through Actual Directory *******************************************
   756 				; Input:  Ptr[X:Y] = Address to command specific function
   757 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   758 				; Output: C = 1 - Found; C = 0 - Not Found
   759 				; ******************************************************************************
   760 487A 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   761 487D A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   762 4885 20 A4 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   763 4888			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 4888 A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 488A A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   764 488C			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: macros.inc]
     1 488C 86 A8			STX	CURR_DIR_ENTRY
     2 488E 84 A9			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   765 4890 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   766 4892 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   767 4894 AA			                TAX                         			; load attributes into X
   768 4895 A0 00		                LDY     #D_FILENAME         			; index to filename
   769 4897			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: macros.inc]
     1 4897 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4899 F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   770 489B 20 BF 4B		                JSR     CMD_EXECUTE         			; call command routine
   771 489E B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   772 						
   773 48A0			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: macros.inc]
     1 48A0 AD 13 18				LDA	TERM_FLAG
     2 48A3 D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   774 48A5 EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   775 48AD A5 A8 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   776 48B4 90 DA		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   777 						
   778 48B6 A9 00		                LDA     #$00
   779 48B8 65 A9 85 A9		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   780 48BC			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: macros.inc]
     1 48BC C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 48BE D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   781
   782 48C0			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: macros.inc]
     1 48C0 CE 1D 18				DEC	CURR_BLK_NUM
     2 48C3 D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   783 48C5			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 48C5 AD 0A 04				LDA	D_FAT_TYPE
     2 48C8 F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   784 48CA 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   785 48CC B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   786
   787 48CE 20 F5 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   ; load next directory cluster from device
   788 48D1 90 B5		                BCC     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   789 48D3 B0 0D		                BCS     OS_DIR_LOOP_EOF     ; directory EOF reached. Exit
   790
   791 48D5 20 E7 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     ; load next directory block from device
   792 48D8 4C 88 48		                JMP     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   793
   794 48DB			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        ; set pointer to upper page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 48DB A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 48DD A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   795 48DF 4C 8C 48		                JMP     SET_CURR_ENTRY	    ; branch to begin of loop
   796
   797 48E2 18			OS_DIR_LOOP_EOF CLC			    ; C=1: not found
   798 48E3 60			OS_DIR_LOOP_END RTS			    ; return
   799
   800 				; **** Set Drive Command *******************************************************
   801 				; Input:  A = Drive Number (0..25)
   802 				; Output: C = 0 - Error
   803 				; ******************************************************************************
   804 48E4			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: macros.inc]
     1 48E4 CD 1E 18				CMP	CURR_DRIVE
     2 48E7 F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   805 48E9			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: macros.inc]
     1 48E9 C9 08				CMP	#$08			; 
     2 48EB B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   806 48ED AA			                TAX                         		; save actual drive number to Y
   807 48EE AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   808 48F1 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   809 48F6 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   810 48F8 A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   811 48FC					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: macros.inc]
     1 48FC A0 1F			LDY	#$20-1
     2 48FE B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 4904 10 F8			BPL	lp
Source: boot_sys_os.asm
   812 4906 8A			                TXA
   813 4907 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   814 490C 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   815 490E A0 08		                LDY     #$08                		; set index to D_DEV_ID
   816 4910			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: macros.inc]
     1 4910 B1 E8				LDA	(STOL),Y
     2 4912 F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   817
   818 4914					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: macros.inc]
     1 4914 A0 1F			LDY	#$20-1
     2 4916 B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 491C 10 F8			BPL	lp
Source: boot_sys_os.asm
   819 491E 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   820 4921 AD 08 04		                LDA     D_DEV_ID            	; get current device id
   821 4924 20 AA E1		                JSR     OPEN_DEVICE         	; and open the device driver
   822 4927 38			SET_DRIVE_END   SEC			    	; C=1: no error
   823 4928 60			                RTS
   824
   825 4929			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: macros.inc]
     1 4929 A2 BD			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 492B A0 56			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   826 492D 4C C5 49		                JMP     OS_PRINT_ERR	    	; Print 'Drive not found'
   827
   828 				; **** Test If Root Directory **************************************************
   829 				; Input:
   830 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   831 				; ******************************************************************************
   832 4930 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   833 4932 B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   834 4935			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: macros.inc]
     1 4935 D9 1C 04				CMP	D_START_DIR,Y
     2 4938 D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   835 493A			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: macros.inc]
     1 493A 88					DEY
     2 493B 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   836 						
   837 493D 38			                SEC			     		; C=1 => is root dir.
   838 493E 60			                RTS
   839 493F 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   840 4940 60			                RTS
   841
   842 				; **** Set Root Directory Command **********************************************
   843 				; ******************************************************************************
   844 4941 A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   845 4943 BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   846 4949 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   847 494D 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   848 						
   849 494F A9 5C 8D 20 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   850 4959 60					RTS					; return
   851
   852 				; **** Set Directory Command ***************************************************
   853 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   854 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   855 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   856 				; considered to be the root-dir and cluster number is set to 2.
   857 				; ******************************************************************************
   858 495A			OS_SET_DIR      PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 495A A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 495C 20 91 E0			JSR	HEXOUT
     3 495F A5 A8			LDA	CURR_DIR_ENTRY
     4 4961 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   859 4964					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 4964 A9 2C			LDA	#','
     2 4966 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   860 4969					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: macros.inc]
     1 4969 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 496B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 496D 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4970 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4972 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4974 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   861 4977					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: macros.inc]
     1 4977 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4979 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 497B 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 497E A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4980 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4982 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   862 4985					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4985 A9 5D			LDA	#']'
     2 4987 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   863 498A A0 15				LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   864 498C A2 04		                LDX     #$04				; Copy 4 bytes
   865 498E 8E B3 49				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   866 4991 CA					DEX					; Copy bytes 3..0
   867 4992 20 A0 49				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   868 4995 A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   869 4997 20 A0 49				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   870 499A					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: macros.inc]
     1 499A AD B3 49				LDA	OS_DWORD0
     2 499D F0 A2				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   871 499F 60			                RTS			     		; return
   872 				                
   873 				;-------------------------------------------------------------------------------------------------
   874 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   875 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   876 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   877 				;-------------------------------------------------------------------------------------------------
   878 49A0 20 A3 49		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   879 49A3 B1 A8 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   880 49A8					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: macros.inc]
     1 49A8 9D 24 18				STA	CURR_DIR_BLK,X
     2 49AB D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   881 49AD CE B3 49				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   882 49B0 88			SET_BYTE_NOT0	DEY				
   883 49B1 CA					DEX
   884 49B2 60					RTS				; return
   885 49B3 00			OS_DWORD0	.byte	$00
   886
   887 				; **** Read Input String *******************************************************
   888 				; Output: Null terminated string in STRBUF
   889 				; ******************************************************************************
   890 49B4 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   891 49B7 A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   892 49BF A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   893 49C4 60			                RTS
   894
   895 				; **** Print Error Message *****************************************************
   896 				; Input:  Ptr[X:Y] = Pointer to Error Message
   897 				; Output: C = 0
   898 				; ******************************************************************************
   899 49C5 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   900 49C8 18			                CLC
   901 49C9 60			                RTS
   902 				                
   903 				; **** Parse Full Path String **************************************************
   904 				; Input:  Ptr[X:Y] to Path String
   905 				; Output: C = 0 - Error; C = 1 - No Error
   906 				;         A = $00       - End Of String
   907 				;           = $FF       - Path Not Found
   908 				;           = ?         - Wildcard Included
   909 				;           = PATH_SEP  - No Trailing Name
   910 				; ******************************************************************************
   911 49CA			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: macros.inc]
     1 49CA 86 EA			STX	PSTR
     2 49CC 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   912 49CE A0 00		                LDY     #$00
   913 49D0 8C 11 18		                STY     TERM_CHAR
   914 49D3 A9 5C		                LDA     #PATH_SEP
   915 49D5			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: macros.inc]
     1 49D5 D1 EA				CMP	(PSTR),Y
     2 49D7 D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   916 49D9 20 41 49		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   917 49DC A0 00		                LDY     #$00
   918 49DE C8			PARSE_PATH      INY
   919 49DF			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: macros.inc]
     1 49DF B1 EA				LDA	(PSTR),Y
     2 49E1 F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   920 49E3			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: macros.inc]
     1 49E3 C9 20				CMP	#SPC
     2 49E5 F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   921 						
   922 49E7 20 11 4A		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   923 49EA 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   924 						
   925 49EC			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: macros.inc]
     1 49EC C9 5C				CMP	#PATH_SEP
     2 49EE D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   926 49F0 84 EE		                STY     PSAV                ; save string index
   927 49F2 20 64 48		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   928 49F5 A4 EE		                LDY     PSAV                ; restore string index
   929 49F7 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   930 49F9 B0 E3		                BCS     PARSE_PATH          ; branch always
   931 				                
   932 49FB 18			PARSE_TERM      CLC
   933 49FC			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: macros.inc]
     1 49FC AD 11 18				LDA	TERM_CHAR
     2 49FF D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   934 4A01 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   935 4A06 D0 04		                BNE     PARSE_PATH_OK			; branch always
   936 				                
   937 4A08			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: macros.inc]
     1 4A08 A9 FF				LDA	#$FF
     2 4A0A D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   938 4A0C 38			PARSE_PATH_OK   SEC
   939 4A0D AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   940 4A10 60			PARSE_PATH_END2 RTS
   941
   942 				; **** Parse A Partial Path Name String ****************************************
   943 				; Input:  A = First Char Of Partial Path
   944 				;         Y = Index Into Path String
   945 				; Output: C = 0 - Error; C = 1 - No Error
   946 				;         TERM_CHAR = NULL      - Filename
   947 				;                   = ?         - Wildcard Chars Included
   948 				;                   = PATH_SEP  - Subdirectory Name
   949 				; ******************************************************************************
   950 4A11 A2 08		OS_PARSE_NAME   LDX     #8
   951 4A13 86 AB		                STX     BCNT                	; set max char count to 8
   952 4A15 A2 00		                LDX     #$00                	; reset index to name string buffer
   953 4A17 8E 11 18		                STX     TERM_CHAR
   954 4A1A			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A1A C9 2E				CMP	#DOT
     2 4A1C D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   955 4A1E 9D 92 4B E8		                STA     FILENAME,X+         	; yes, store it
   956 4A22 C8			                INY
   957 4A23 B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   958 4A25			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A25 C9 2E				CMP	#DOT
     2 4A27 D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   959 4A29 9D 92 4B		SET_CHAR        STA     FILENAME,X          	; yes, store it
   960 4A2C E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   961 4A2D C8			NEXT_CHAR2      INY                         	; point to next char of input string
   962 4A2E			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: macros.inc]
     1 4A2E B1 EA				LDA	(PSTR),Y
     2 4A30 F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   963 4A32			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: macros.inc]
     1 4A32 C9 20				CMP	#SPC
     2 4A34 F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   964 4A36			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: macros.inc]
     1 4A36 C9 5C				CMP	#PATH_SEP
     2 4A38 F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   965 4A3A			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: macros.inc]
     1 4A3A C9 2E				CMP	#DOT
     2 4A3C F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   966 4A3E			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: macros.inc]
     1 4A3E C9 2A				CMP	#'*'
     2 4A40 F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   967
   968 4A42			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: macros.inc]
     1 4A42 E4 AB				CPX	BCNT			; 
     2 4A44 B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   969 4A46 20 5A 4C		                JSR     UPPERCASE           	; convert chars to upper case
   970 4A49			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: macros.inc]
     1 4A49 C9 3F				CMP	#'?'
     2 4A4B D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   971 4A4D 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   972 4A50 F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   973
   974 4A52			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A52 C9 2D				CMP	#MINUS
     2 4A54 F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   975 4A56			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A56 C9 5F				CMP	#ULINE
     2 4A58 F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   976 4A5A					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A5A C9 7E				CMP	#'~'
     2 4A5C F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   977 4A5E					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A5E C9 30				CMP	#'0'			; 
     2 4A60 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   978 4A62			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A62 C9 3A				CMP	#':'			; 
     2 4A64 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   979 4A66			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A66 C9 41				CMP	#'A'			; 
     2 4A68 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   980 4A6A			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A6A C9 5B				CMP	#'['			; 
     2 4A6C 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   981
   982 4A6E A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   983 4A73 20 8A 4A		                JSR     FILL_CHAR           ; fill with ? chars
   984 4A76 B0 B5		                BCS     NEXT_CHAR2          ; branch always
   985
   986 4A78 20 88 4A		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
   987 4A7B A9 0B 85 AB		                MVA     #11 BCNT            ; set max char count to 11
   988 4A7F B0 AC		                BCS     NEXT_CHAR2          ; branch always
   989
   990 4A81 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
   991 4A84 A9 0B 85 AB		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
   992 4A88 A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
   993 4A8A			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: macros.inc]
     1 4A8A E4 AB				CPX	BCNT			; 
     2 4A8C B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   994 4A8E 9D 92 4B E8		                STA     FILENAME,X+         ; no, store char in name buffer
   995 4A92 90 F6		                BCC     FILL_CHAR           ; and repeat
   996
   997 4A94 AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
   998 4A97 60			                RTS
   999 				                
  1000 				; **** Compare File Name With Mask *********************************************
  1001 				; Output: C = 0 - Names not equal; C = 1 - Names equal
  1002 				; ******************************************************************************
  1003 4A98 A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
  1004 4A9A B9 92 4B		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
  1005 4A9D			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: macros.inc]
     1 4A9D D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4A9F D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1006 4AA1			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: macros.inc]
     1 4AA1 88					DEY
     2 4AA2 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
  1007 						
  1008 4AA4 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
  1009 4AA5 60			                RTS
  1010 4AA6 18			COMPARE_NEQ     CLC					; C=0, filename is different
  1011 4AA7 60			                RTS
  1012 				                
  1013 				; **** Delete File *************************************************************
  1014 				; Input : A - First character of filename
  1015 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
  1016 				; ******************************************************************************
  1017 4AA8			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: macros.inc]
     1 4AA8 C9 E5				CMP	#$E5
     2 4AAA D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1018 4AAC AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
  1019 4AAF D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
  1020
  1021 4AB1 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
  1022 4AB4					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: macros.inc]
     1 4AB4 A0 05			LDY	#6-1
     2 4AB6 B9 24 18 99 C1 4A + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4ABD 10 F7			BPL	lp
Source: boot_sys_os.asm
  1023 4ABF 38			                SEC
  1024 4AC0 60			                RTS
  1025 				                
  1026 4AC1 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
  1027 4AC5 00 00		SEL_DIR_ENTRY   .byte $00, $00
  1028 				                
  1029 				; **** Directory Loop Call Back Functions **************************************
  1030 				; Input : A - First character of filename
  1031 				;         X - File Attributes
  1032 				; Output: C = 1 - File found; C = 0 - File not found
  1033 				; ******************************************************************************
  1034
  1035 				; **** Directory Exists - Call Back Routine ************************************
  1036 4AC7 20 A8 4A		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
  1037
  1038 				; **** Find Sub Directory Name - Call Back Routine *****************************
  1039 4ACA			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4ACA E0 0F				CPX	#$0F
     2 4ACC F0 43				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1040 4ACE AD 92 4B		                LDA     FILENAME            	; do we search for the . directory?
  1041 4AD1			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: macros.inc]
     1 4AD1 C9 2E				CMP	#DOT
     2 4AD3 D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
  1042 						
  1043 4AD5 AD 93 4B		                LDA     FILENAME+1		; get next byte
  1044 4AD8			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: macros.inc]
     1 4AD8 C9 20				CMP	#SPC
     2 4ADA F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
  1045 						
  1046 4ADC 8A			FIND_SUBDIR     TXA
  1047 4ADD			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: macros.inc]
     6 4ADD 29 10				AND	#FA_DIRECTORY
     7 4ADF F0 30				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1048 4AE1 20 98 4A		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
  1049 4AE4 90 2C		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
  1050
  1051 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
  1052 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
  1053 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
  1054 						;    with $1C & $1D not being cluster nr bytes.
  1055 4AE6 20 5A 49		                JSR     OS_SET_DIR          	; make this directory the actual directory
  1056 4AE9 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
  1057 4AEA 60			                RTS				; return
  1058 				                
  1059 				; **** File Exists - Call Back Routine *****************************************
  1060 4AEB 20 A8 4A		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
  1061
  1062 				; **** Find File Name - Call Back Routine **************************************
  1063 4AEE			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4AEE E0 0F				CPX	#$0F
     2 4AF0 F0 1F				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1064 4AF2 8A			                TXA
  1065 4AF3			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: macros.inc]
     6 4AF3 29 10				AND	#FA_DIRECTORY
     7 4AF5 D0 1A				BNE	CB_FIND_END
Source: boot_sys_os.asm
  1066 4AF7 20 98 4A		                JSR     OS_COMP_NAME        			; compare name with search mask
  1067 4AFA 90 16		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
  1068 						
  1069 4AFC A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
  1070 4AFE A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
  1071 4B00 B1 A8 C8 95 A0 E8	GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
  1072 4B06			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B06 E0 02				CPX	#$02			; 
     2 4B08 90 F6				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1073 4B0A A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
  1074 4B0C			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B0C E0 04				CPX	#$04			; 
     2 4B0E 90 F0				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1075 4B10 60			                RTS                         			; yes, file found
  1076
  1077 4B11 18			CB_FIND_END     CLC                         			; file not found
  1078 4B12 60			CB_FIND_END2    RTS
  1079 				                
  1080 				; **** Find Free or Deleted Dir. Entry **************************************
  1081 4B13			CB_FIND_FREE_DIR_ENTRY
  1082 4B13 A0 00				LDY	#D_FILENAME			; set index to filename
  1083 4B15 B1 A8				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
  1084 4B17					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: macros.inc]
     1 4B17 C9 E5				CMP	#$E5
     2 4B19 F0 09				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1085 4B1B			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: macros.inc]
     1 4B1B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4B1D D0 10				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1086 4B1F C8					INY
  1087 4B20			                CPY.CC  #D_ATTRIBUTES FFD_LP1  		; branch if not all characters copied
Macro: CPY.CC [Source: macros.inc]
     1 4B20 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4B22 90 F7				BCC	FFD_LP1			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
  1088 4B24 A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1089 4B26 91 A8 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1090 4B29					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: macros.inc]
     1 4B29 C0 20				CPY	#$20
     2 4B2B D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1091 						
  1092 4B2D 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1093 4B2E 60			                RTS                         		; return
  1094 4B2F 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1095 4B30 60					RTS					; return
  1096
  1097 				; **** Data Area ***************************************************************
  1098 				; ******************************************************************************
  1099
  1100 				; Indirect Jump Pointer Of Current Command Address *****************************
  1101 4B31 00 00		CMD_ADDR        .word      $0000
  1102 				                
  1103 				; String Data Area *************************************************************
  1104 4B33 0D 20 57 65 6C 63 + MSG_BOOT        .by    CR ' Welcome to JC2 DOS65, V'
  1105 4B4C 30 2E 32 2E 36 0D	                .byte  VERMAIN,DOT,VERPSUB,DOT,VERSSUB,CR
  1106 4B52 20 32 30 32 35 20 +                 .by    ' 2025 by Emile, original design by Joerg Walke' CR CR $00
  1107 4B83 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1108 = 4B92			FILENAME        .ds 	12
    84 4B9E					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; Main Loop Of Command Interpreter *********************************************
    10 				; ******************************************************************************
    11 4B9E A9 58 8D 31 4B A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    12 4BA8 20 96 4C		                JSR     PRINT_PROMPT
    13 4BAB 20 B4 49		                JSR  	OS_STRING_IN         ; read input string
    14 4BAE 20 C2 4B				JSR     GET_CMD              ; parse string
    15 4BB1 90 06				BCC     CMD_EXTERNAL
    16 						
    17 4BB3 20 BF 4B		                JSR     CMD_EXECUTE          ; execute internal command
    18 4BB6 4C 9E 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    19 						
    20 4BB9 20 4E 54		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    21 4BBC 4C 9E 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    22 						
    23 4BBF 6C 31 4B		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    24 						
    25 				; Get Command String ***********************************************************
    26 4BC2 20 E2 4E		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    27 4BC5 D0 03		                BNE     GET_CMD0
    28
    29 4BC7 4C 58 4C		                JMP     CMD_FOUND            ; empty command if first char is NULL
    30
    31 4BCA 20 5A 4C		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    32 4BCD AA			                TAX
    33 4BCE A0 00		                LDY     #$00
    34 4BD0 8A			GET_CMD1        TXA                          	; try to find command in command table
    35 4BD1					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4BD1 D9 87 57				CMP	CHARS,Y
     2 4BD4 F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    36 4BD6			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4BD6 B9 87 57				LDA	CHARS,Y
     2 4BD9 F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    37 4BDB 8A			                TXA
    38 4BDC C8 C8 C8		        :3      INY			     	; Y += 3
    39 4BDF 4C D0 4B		                JMP     GET_CMD1	     	; branch always
    40
    41 4BE2 C8			GET_CMD2        INY
    42 4BE3 B9 87 57 C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    43 4BE9 B9 87 57 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    44 4BEE A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    45 4BF3 A6 AC		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    46 4BF5			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: macros.inc]
     1 4BF5 B1 E8				LDA	(STOL),Y
     2 4BF7 F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    47 4BF9 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    48 4C00 E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    49 4C01 C8			                INY                          	; point to next char in command table
    50 4C02			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: macros.inc]
     1 4C02 CC 10 18				CPY	NEXTINDEX
     2 4C05 F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    51
    52 4C07 BD 00 14		                LDA     STRBUF,X             	; load char from command string
    53 4C0A 20 5A 4C		                JSR     UPPERCASE	     	; and convert it to uppercase
    54 4C0D					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4C0D D1 E8				CMP	(STOL),Y
     2 4C0F F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    55
    56 4C11 AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    57 4C14 C8 C8		        :2      INY			     	; Y += 2
    58 4C16 8C 10 18		                STY     NEXTINDEX
    59 4C19 4C F3 4B		                JMP     GET_CMD_LOOP1	     	; branch always
    60
    61 4C1C B1 E8 8D 31 4B C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    62 4C27			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4C27 BD 00 14				LDA	STRBUF,X
     2 4C2A F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    63 4C2C			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: macros.inc]
     1 4C2C C9 20				CMP	#SPC
     2 4C2E F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    64 4C30 18			CMD_NOT_FOUND   CLC
    65 4C31 60			                RTS
    66 				                
    67 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    68 4C32 A6 AC		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    69 4C34 BD 00 14		                LDA     STRBUF,X
    70 4C37 20 5A 4C		                JSR     UPPERCASE            ; convert it to upper case
    71 4C3A			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: macros.inc]
     1 4C3A C9 41				CMP	#'A'			; 
     2 4C3C 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    72 4C3E			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: macros.inc]
     1 4C3E C9 5B				CMP	#'['			; 
     2 4C40 B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    73
    74 4C42 A8			                TAY
    75 4C43 BD 01 14		                LDA     STRBUF+1,X
    76 4C46			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: macros.inc]
     1 4C46 C9 3A				CMP	#':'
     2 4C48 D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    77 4C4A 38			                SEC
    78 4C4B 98			                TYA
    79 4C4C E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    80 4C4E			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: macros.inc]
     1 4C4E A2 E4			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4C50 A0 48			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    81 4C52			                STXY    CMD_ADDR
Macro: STXY [Source: macros.inc]
     1 4C52 8E 31 4B			STX	CMD_ADDR
     2 4C55 8C 32 4B			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    82 4C58 38			CMD_FOUND       SEC
    83 4C59 60			                RTS
    84 				                
    85 				; **** Return Uppercase Character **********************************************
    86 				; Input:  A - Character
    87 				; Output: A - Uppercase Character
    88 				; ******************************************************************************
    89 4C5A			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: macros.inc]
     1 4C5A C9 61				CMP	#'a'			; 
     2 4C5C 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    90 4C5E			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: macros.inc]
     1 4C5E C9 7B				CMP	#'z'+1			; 
     2 4C60 B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    91 4C62 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    92 4C64 60			UPPERCASE_END   RTS				; return
    93
    94 				; **** Print Two Digit Number **************************************************
    95 				; Input: A - Number (0..99)
    96 				; ******************************************************************************
    97 4C65 20 BD E0		NUMOUT          JSR     DEC2STR			; Converts into DIG0, DIG1 and DIG2
    98 4C68 A2 01		                LDX     #$01
    99 4C6A B5 F8		NEXT_NUMOUT     LDA     DIG0,X			
   100 4C6C 20 52 E0		                JSR     COUT
   101 4C6F					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4C6F CA					DEX
     2 4C70 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   102 4C72 60			                RTS				; return
   103 				                
   104 				; **** Print Current Drive *****************************************************
   105 				;
   106 				; ******************************************************************************
   107 4C73 AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   108 4C76 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   109 4C79 20 52 E0		                JSR     COUT		   ; print char
   110 4C7C A9 3A		                LDA     #COLON		   ; ':'
   111 4C7E 4C 52 E0		                JMP     COUT		   ; print char and return
   112 				                
   113 				; **** Print Current Path ******************************************************
   114 				;
   115 				; ******************************************************************************
   116 4C81 A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   117 4C85 A6 D8		PR_PATH_LP	LDX	SAVEX
   118 4C87 BD 20 04				LDA     D_SUBDIR_NAME,X		; 
   119 4C8A 48					PHA
   120 4C8B 20 52 E0		                JSR     COUT		    	; print char
   121 4C8E 68					PLA
   122 4C8F F0 04				BEQ	PR_PATH_DN		; End-of-String?
   123 						
   124 4C91					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: macros.inc]
     1 4C91 E6 D8				INC	SAVEX
     2 4C93 D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   125 4C95 60			PR_PATH_DN      RTS				; return
   126
   127 				; **** Print Drive and Path Prompt *********************************************
   128 				;
   129 				; ******************************************************************************
   130 4C96 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   131 4C99 20 73 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   132 4C9C 20 81 4C		                JSR     PRINT_PATH	   ; '\'
   133 4C9F A9 3E		                LDA     #PROMPT		   ; '>'
   134 4CA1 4C 52 E0		                JMP     COUT		   ; print char and return
   135 				                
   136 				; **** Print Drive Label *******************************************************
   137 				;
   138 				; ******************************************************************************
   139 4CA4 48			PRINT_LABEL     PHA			   ; save A
   140 4CA5			                PHY			   ; save Y
Macro: PHY [Source: macros.inc]
     1 4CA5 98				TYA
     2 4CA6 48				PHA
Source: boot_sys_sh.asm
   141 4CA7			                PRSTR   MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTR [Source: macros.inc]
     1 4CA7 A2 79			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4CA9 A0 56			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4CAB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4CAE 20 73 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   143 4CB1			                PRSTR   MSG_LABEL2	   ; ' is '
Macro: PRSTR [Source: macros.inc]
     1 4CB1 A2 8A			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4CB3 A0 56			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4CB5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   144 4CB8 20 CE 4C		                JSR     PRINT_FILENAME1    ; print volume-label
   145 4CBB 20 5A E0		                JSR     CROUT		   ; CR 2x
   146 4CBE 20 5A E0		                JSR     CROUT
   147 4CC1					PLY			   ; restore Y
Macro: PLY [Source: macros.inc]
     1 4CC1 68				PLA
     2 4CC2 A8				TAY
Source: boot_sys_sh.asm
   148 4CC3 68			                PLA			   ; restore A
   149 4CC4 60			                RTS
   150 				                
   151 				; **** Print Filename **********************************************************
   152 				;
   153 				; ******************************************************************************
   154 4CC5 A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   155 4CC7					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CC7 AD 12 18				LDA	F_ATTRIBS
     3 4CCA 29 10				AND	#FA_DIRECTORY
     4 4CCC F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   156 4CCE A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   157 4CD0 A0 00		PRINT_FILENAME2 LDY     #$00
   158 4CD2			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: macros.inc]
     1 4CD2 C0 08				CPY	#$08
     2 4CD4 D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   159 4CD6 20 5E E0		                JSR     SPCOUT		    		; print space
   160 4CD9 8A			                TXA
   161 4CDA 20 52 E0		                JSR     COUT                		; yes, print divider char
   162 4CDD B1 A8		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   163 4CDF 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   164 4CE2 C8			                INY
   165 4CE3			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: macros.inc]
     1 4CE3 C0 0B				CPY	#D_ATTRIBUTES
     2 4CE5 D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   166 4CE7 60			                RTS			    		; return
   167 				                
   168 				; **** Print File Info *********************************************************
   169 				; Input: F_ATTRIBS = File Attributes
   170 				; ******************************************************************************
   171 4CE8			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CE8 AD 12 18				LDA	F_ATTRIBS
     3 4CEB 29 10				AND	#FA_DIRECTORY
     4 4CED F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   172 				                
   173 				; Print Directory Attribute ****************************************************
   174 4CEF			                PRSTR   MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTR [Source: macros.inc]
     1 4CEF A2 8F			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4CF1 A0 56			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4CF3 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   175 4CF6 EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   176 4CFE 4C 2B 4D				JMP     PRINT_ATTRIB
   177
   178 				; Print File Size **************************************************************
   179 4D01 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   180 4D04 20 5E E0		                JSR     SPCOUT
   181 4D07 EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   182 4D0F A2 00		NO_FCNT_CARRY   LDX     #$00
   183 4D11 A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   184 4D13 18			                CLC
   185 4D14 08			                PHP
   186 4D15 28			LOAD_SIZE       PLP
   187 4D16 B1 A8 95 C0		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   188 4D1A 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   189 4D20 08			                PHP
   190 4D21 C8			                INY
   191 4D22 E8			                INX
   192 4D23					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4D23 E0 04				CPX	#$04
     2 4D25 D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   193 4D27 28			                PLP
   194 4D28 20 23 4E		                JSR     PRINT_INT32         		; print file size
   195 				                
   196 				; Print File Attributes ********************************************************
   197 4D2B 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   198 4D2E					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: macros.inc]
     4 4D2E AD 1F 18				LDA	CURR_CMD_PARAM
     5 4D31 29 02				AND	#(1 << 1)
     6 4D33 F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   199 4D35 A2 07		                LDX     #$07
   200 4D37 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   201 4D3A			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: macros.inc]
     1 4D3A BD 5B 57				LDA	ATTRIB_VAL,X
     2 4D3D F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   202 4D3F B0 02		                BCS     SET_ATTRIB			; branch if printable
   203
   204 4D41 A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   205 4D43 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   206 4D46			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: macros.inc]
     1 4D46 CA					DEX
     2 4D47 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   207 4D49 20 5E E0		                JSR     SPCOUT
   208 				                
   209 				; Print Date *******************************************************************
   210 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   211 				;              08-05 Month of year (1-12)
   212 				;              04-00 Day of month (1-32)
   213 				; ******************************************************************************
   214 4D4C A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   215 4D4E B1 A8 8D 1A 4E	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   216 4D53 29 1F		                AND     #$1F                		; mask day value
   217 4D55 8D 1B 4E		                STA     DAY
   218 4D58 C8			                INY
   219 4D59 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   220 4D5B 4A			                LSR                         ; year in A
   221 4D5C 6E 1A 4E		                ROR     MONTH
   222 4D5F 4E 1A 4E 4E 1A 4E +         :4      LSR     MONTH		    ; LSR 4
   223 4D6B 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   224 4D6E 8D 19 4E		                STA     YEAR
   225 4D71 AD 1B 4E		                LDA     DAY
   226 4D74 20 65 4C		                JSR     NUMOUT
   227 4D77			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D77 A9 2E			LDA	#'.'
     2 4D79 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   228 4D7C AD 1A 4E		                LDA     MONTH
   229 4D7F 20 65 4C		                JSR     NUMOUT
   230 4D82			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D82 A9 2E			LDA	#'.'
     2 4D84 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   231 4D87 AC 19 4E		                LDY     YEAR
   232 4D8A			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: macros.inc]
     1 4D8A C0 64				CPY	#100			; 
     2 4D8C 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   233
   234 4D8E A9 14		                LDA     #20
   235 4D90 20 65 4C		                JSR     NUMOUT
   236 4D93 98			                TYA
   237 4D94 38 E9 64				SUB	#100		    ; same as SEC + SBC
   238 4D97 4C A0 4D		                JMP     PRINT_YEAR
   239
   240 4D9A A9 13		CENTURY_19      LDA     #19
   241 4D9C 20 65 4C		                JSR     NUMOUT
   242 4D9F 98			                TYA
   243 4DA0 20 65 4C		PRINT_YEAR      JSR     NUMOUT
   244 4DA3 20 5E E0		                JSR     SPCOUT
   245 				                
   246 				; Print Time *******************************************************************
   247 				; Time Format: 15-11 Hours (0-23)
   248 				;              10-05 Minutes (0-59)
   249 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   250 				; ******************************************************************************
   251 4DA6 A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   252 4DA8 B1 A8 8D 1C 4E	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   253 4DAD C8			                INY
   254 4DAE B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file last write time high byte
   255 				        .rept 3
   256 						LSR     
   257 				                ROR     MINUTE
   258 					.endr	
Source: REPT
   256 4DB0 4A					LSR     
   256 4DB1 6E 1C 4E		                ROR     MINUTE
   256 4DB4 4A					LSR     
   256 4DB5 6E 1C 4E		                ROR     MINUTE
   256 4DB8 4A					LSR     
   256 4DB9 6E 1C 4E		                ROR     MINUTE
Source: boot_sys_sh.asm
   259 4DBC 4E 1C 4E 4E 1C 4E	        :2      LSR     MINUTE
   260 4DC2 20 65 4C		                JSR     NUMOUT
   261 4DC5			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: macros.inc]
     1 4DC5 A9 3A			LDA	#':'
     2 4DC7 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   262 4DCA AD 1C 4E		                LDA     MINUTE
   263 4DCD 20 65 4C		                JSR     NUMOUT		    ; print minutes
   264
   265 				; Print Cluster Number *********************************************************
   266 				; Only with /C parameter: Prints Cluster number AND LBA number
   267 				; ******************************************************************************
   268 4DD0					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: macros.inc]
     4 4DD0 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DD3 29 08				AND	#(1 << 3)
     6 4DD5 F0 41				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   269 4DD7 20 5E E0		                JSR	SPCOUT		    			; Print space
   270 4DDA					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DDA A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4DDC B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DDE 85 C3				STA	NUM32+2+1
     5 4DE0 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DE3 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4DE5 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DE7 85 C2				STA	NUM32+2
     5 4DE9 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   271 4DEC					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DEC A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4DEE B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DF0 85 C1				STA	NUM32+1
     5 4DF2 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DF5 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4DF7 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DF9 85 C0				STA	NUM32
     5 4DFB 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   272 4DFE 20 5E E0				JSR	SPCOUT
   273 4E01 20 FF 40				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   274 4E04					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 4E04 A5 C3			LDA	NUM32+2+1				; print MSB
     2 4E06 20 91 E0			JSR	HEXOUT
     3 4E09 A5 C2			LDA	NUM32+2
     4 4E0B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4E0E A5 C1			LDA	NUM32+1				; print MSB
     2 4E10 20 91 E0			JSR	HEXOUT
     3 4E13 A5 C0			LDA	NUM32
     4 4E15 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   275 4E18 60			PRINT_EXIT	RTS
   276
   277 4E19 00			YEAR		.byte 	$00
   278 4E1A 00			MONTH		.byte 	$00
   279 4E1B 00			DAY 		.byte	$00
   280 4E1C 00			MINUTE		.byte 	$00
   281 				                
   282 				; **** Print 16 Bit Number *****************************************************
   283 				; Input: X,Y = Int16
   284 				; ******************************************************************************
   285 4E1D 20 91 4E		PRINT_INT16     JSR     BIN16_TO_BCD
   286 4E20 4C 26 4E		                JMP     PRINT_NUM
   287 				                
   288 				; **** Print 32 Bit Number *****************************************************
   289 				; Input: NUM32[0..3] = Int32
   290 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   291 				; ******************************************************************************
   292 4E23 20 9B 4E		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   293 4E26 A2 00		PRINT_NUM       LDX     #$00
   294 4E28 A0 0A		                LDY     #10
   295 4E2A 18			                CLC                         ; save status bits
   296 4E2B 08			PRINT_NUM1      PHP                         ; store current carry flag
   297 4E2C 20 62 4E		                JSR     PRINT_SEPARATOR
   298 4E2F BD 63 57		                LDA     BCD_VAL,X           ; load two decimal digits
   299 4E32 48			                PHA                         ; store A
   300 4E33 98			                TYA                         ; move digit counter into A
   301 4E34 4A			                LSR                         ; bit one into carry
   302 4E35 68			                PLA                         ; restore A
   303 4E36 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   304 						
   305 4E38 E8			                INX                         ; no, process digit 2
   306 4E39 29 0F		                AND     #$0F
   307 4E3B 10 04		                BPL     SET_DIGIT2
   308 4E3D 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   309 4E41 28			SET_DIGIT2      PLP
   310 4E42 B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   311 						
   312 4E44			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: macros.inc]
     6 4E44 29 0F				AND	#$0F
     7 4E46 D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   313 4E48 98			                TYA
   314 4E49			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: macros.inc]
     1 4E49 C9 01				CMP	#1
     2 4E4B D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   315 4E4D A9 30		                LDA     #48                 ; yes, print 0
   316 4E4F 20 9A E0		                JSR     HEXDIG
   317 4E52 18			                CLC                         ; number is 0
   318 4E53 60			                RTS
   319 						
   320 4E54 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   321 4E57 18			                CLC
   322 4E58 90 04		                BCC     NEXT_DIGIT	    ; branch always
   323 						
   324 4E5A 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   325 4E5D 38			                SEC                         ; no more leading 0s
   326 4E5E			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: macros.inc]
     1 4E5E 88					DEY
     2 4E5F D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   327 4E61 60			                RTS
   328 				                
   329 				; Print Thousands Separator ****************************************************
   330 4E62 08			PRINT_SEPARATOR PHP                         ; save status bits
   331 4E63			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E63 C0 09				CPY	#$09
     2 4E65 F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   332 4E67			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E67 C0 06				CPY	#$06
     2 4E69 F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   333 4E6B			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: macros.inc]
     1 4E6B C0 03				CPY	#$03
     2 4E6D D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   334 						
   335 4E6F 28			PRINT_SEP       PLP                         ; restore status bits
   336 4E70 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   337 						
   338 4E72 A9 2E		                LDA     #NUM_SEP
   339 4E74 4C 52 E0		                JMP     COUT                ; print thousands seperator
   340 						
   341 4E77 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   342 4E7A 28			NO_SEP          PLP                         ; clean up stack
   343 4E7B 60			                RTS
   344 				                
   345 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   346 				; INPUT:  A = BCD Number
   347 				; Output: A = Binary Number
   348 				; ******************************************************************************
   349 4E7C 85 C0		BCD_TO_BIN      STA     NUM32               ; save BCD number
   350 4E7E 29 F0		                AND     #$F0                ; and clear ones digit in A
   351 4E80 4A			                LSR                         ; calc tens digit * 8
   352 4E81 85 C1		                STA     NUM32+1             ; and store result
   353 4E83 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   354 4E85 18 65 C1 85 C1			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   355 4E8A A5 C0		                LDA     NUM32               ; reload BCD number int A
   356 4E8C 29 0F		                AND     #$0F                ; and clear tens digit in A
   357 4E8E 65 C1		                ADC     NUM32+1             ; finally add both result
   358 4E90 60			                RTS			    ; return
   359 				                
   360 				;**** Convert 16 Bit Binary Number To BCD **************************************
   361 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   362 				; OUTPUT: BCD_VAL[4..0] = Result
   363 				; ******************************************************************************
   364 4E91			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: macros.inc]
     1 4E91 86 C0			STX	NUM32
     2 4E93 84 C1			STY	NUM32+1
Source: boot_sys_sh.asm
   365 4E95 A2 00 86 C2 86 C3			MWX	#$00 NUM32+2	    ; clear upper word
   366 				                
   367 				;**** Convert 32 Bit Binary Number To BCD **************************************
   368 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   369 				; OUTPUT: BCD_VAL[4..0] = Result
   370 				;*******************************************************************************
   371 4E9B F8			BIN32_TO_BCD    SED                         ; set decimal mode
   372 4E9C A2 04		                LDX     #$04
   373 4E9E A9 00		                LDA     #$00                ; clear BCD result value
   374 4EA0 9D 63 57 CA		CLEAR_BCD       STA     BCD_VAL,X-
   375 4EA4 10 FA		                BPL     CLEAR_BCD
   376
   377 4EA6 A2 20		                LDX     #$20                ; 32 source bits
   378 4EA8			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: macros.inc]
     1 4EA8 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4EAA 26 C1		        ROL     NUM32+1		  
     3 4EAC 26 C2		        ROL     NUM32+2
     4 4EAE 26 C3		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   379 4EB0 AD 67 57 6D 67 57 + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   380 4EB9 AD 66 57 6D 66 57 + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   381 4EC2 AD 65 57 6D 65 57 + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   382 4ECB AD 64 57 6D 64 57 + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   383 4ED4 AD 63 57 6D 63 57 + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   384 4EDD			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: macros.inc]
     1 4EDD CA					DEX
     2 4EDE D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   385 4EE0 D8			                CLD                         ; reset to binary mode
   386 4EE1 60			                RTS
   387
   388 				; **** Get Command String ******************************************************
   389 				;
   390 				; ******************************************************************************
   391 4EE2 A2 01		GET_CMD_STR     LDX     #$01
   392 4EE4			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4EE4 BD 00 14				LDA	STRBUF,X
     2 4EE7 F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   393 4EE9			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: macros.inc]
     1 4EE9 C9 20				CMP	#SPC
     2 4EEB D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   394 4EED E8			SKIP_SPC_CHAR   INX
   395 4EEE 4C E4 4E		                JMP     GET_CMD_CHAR
   396 				                
   397 				; **** Get Parameter String ****************************************************
   398 				; Output: C = 1: Parameter; C = 0: Path
   399 				;         A    = $00 : End of parameter string
   400 				;         NCNT = Index to parameter
   401 				; ******************************************************************************
   402 4EF1 A6 AC		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   403 4EF3 20 01 4F		                JSR     GET_PARM_CHAR
   404 4EF6					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: macros.inc]
     1 4EF6 C9 2F				CMP	#OPT_SEP
     2 4EF8 D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   405 4EFA E8			                INX			    ; next char
   406 4EFB BD 00 14		                LDA     STRBUF,X	    ; load parameter
   407 4EFE 4C 15 4F		                JMP     PARAM_STR	    ; OK and return
   408
   409 4F01			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4F01 BD 00 14				LDA	STRBUF,X
     2 4F04 F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   410 4F06					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: macros.inc]
     1 4F06 C9 20				CMP	#SPC
     2 4F08 F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   411 4F0A					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: macros.inc]
     1 4F0A C9 2F				CMP	#OPT_SEP
     2 4F0C F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   412 4F0E E8			                INX			    
   413 4F0F 4C 01 4F		                JMP     GET_PARM_CHAR
   414
   415 4F12 18			PATH_STR        CLC			    ; C=0, it is a path
   416 4F13 90 01		                BCC     END_PARAM	    ; branch always
   417
   418 4F15 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   419 4F16 86 AC		END_PARAM       STX     NCNT		    ; save index in parameter string
   420 4F18 48			                PHA
   421 4F19 68			                PLA
   422 4F1A 60			                RTS			    ; return
   423
   424 				; **** Internal Command Handlers ***********************************************
   425
   426 				; **** Directory Loop Call Back Functions **************************************
   427 				; Input : A - First character of filename
   428 				;         X - File Attributes
   429 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   430 				; ******************************************************************************
   431
   432 				; **** Print Directory Entry - Call Back Routine *******************************
   433 4F1B			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4F1B E0 0F				CPX	#$0F
     2 4F1D F0 5C				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   434 4F1F					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: macros.inc]
     1 4F1F C9 E5				CMP	#$E5
     2 4F21 F0 58				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   435 4F23 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   436 4F26 8A			                TXA
   437 4F27 4A			                LSR     
   438 4F28 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   439 4F29 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   440
   441 4F2B			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: macros.inc]
     4 4F2B AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F2E 29 04				AND	#(1 << 2)
     6 4F30 F0 49				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   442 4F32 4A			CHK_SYSTEM      LSR                         		; check if system file
   443 4F33 4A			CHK_LABEL       LSR                         		; check if disk label
   444 				                ; #### PRINT LABEL DISABLED ####################################
   445 4F34 B0 45		                BCS     CB_PRINT_CONT       		; it's a label, skip to next entry
   446
   447 				                ;BCC     PRINT_DIR_ENTRY
   448 				                ;JSR     PRINT_LABEL         		; print disk label
   449 				                ;INC     LINE_CNT
   450 				                ;BNE     CHK_LINE_COUNT     		 ; branch always
   451 				                ; ##############################################################
   452 4F36			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: macros.inc]
     1 4F36 AD 11 18				LDA	TERM_CHAR
     2 4F39 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   453 4F3B 20 CA 4A		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   454 4F3E 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   455
   456 4F40 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   457 4F45 20 7A 48		                JSR     OS_DIR_LOOP         		; list files of sub directory
   458 4F48 38			                SEC                         		; directory list finished
   459 4F49 60			                RTS                         		; exit
   460
   461 4F4A 20 7D 4F		COMP_MASK       JSR     SH_COMP_MASK
   462 4F4D 90 2D		                BCC     CB_PRINT_END
   463
   464 4F4F A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   465 4F53 20 C5 4C		                JSR     PRINT_FILENAME      		; print filename
   466 4F56 20 E8 4C		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   467 4F59 20 5A E0		                JSR     CROUT
   468 4F5C			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: macros.inc]
     4 4F5C AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F5F 29 01				AND	#(1 << 0)
     6 4F61 F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   469 4F63 EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   470 4F66 A9 19		                LDA     #25
   471 4F68					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: macros.inc]
     1 4F68 CD 14 18				CMP	LINE_CNT			; 
     2 4F6B B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   472 4F6D A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   473 4F72 20 E3 53		                JSR     SH_PAUSE            		; wait for key press
   474 4F75			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4F75 C9 1B				CMP	#27
     2 4F77 D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   475 4F79 38			                SEC                         		; break dir loop
   476 4F7A 60			                RTS
   477 4F7B 18			CB_PRINT_CONT   CLC                         		; get next next entry
   478 4F7C 60			CB_PRINT_END    RTS
   479
   480 				; **** Compare File Name With Mask Using Wildcards *****************************
   481 				;
   482 				; ******************************************************************************
   483 4F7D			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: macros.inc]
     1 4F7D C9 5C				CMP	#PATH_SEP
     2 4F7F F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   484 4F81 A0 0A		                LDY     #10                 			; compare all characters
   485 4F83 B9 92 4B		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   486 4F86					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: macros.inc]
     1 4F86 C9 3F				CMP	#'?'
     2 4F88 F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   487 4F8A					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: macros.inc]
     1 4F8A D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4F8C D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   488 						
   489 4F8E			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: macros.inc]
     1 4F8E 88					DEY
     2 4F8F 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   490 4F91 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   491 4F92 60			                RTS
   492 4F93 18			COMP_NAME_NEQ   CLC
   493 4F94 60			                RTS
   494
   495 				; ******************************************************************************
   496 				; ******************************************************************************
   497 4F95 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   498 4F99 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   499 				; + DRIVE
   500 				                
   501 4F9D A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   502 4F9F B9 04 04 99 95 4F	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   503 4FA5 B9 24 18 99 99 4F + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   504 4FAC 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   505 4FAE 60			                RTS					; return
   506 				                
   507 4FAF A0 03		LOAD_ACT_DIR    LDY     #$03
   508 4FB1 B9 95 4F 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   509 4FB7 B9 99 4F 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   510 4FBE 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   511 4FC0 60			                RTS					; return
   512 				                
   513 				; **** Get Parameters from Command Line ****************************************
   514 				; Input:  Ptr[X:Y] to Parameter String
   515 				; Output: C = 0 - Error; C = 1 - No Error
   516 				; ******************************************************************************
   517 4FC1 20 2E 50		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   518 4FC4 A9 00		                LDA     #$00                ; set current command parameter value to 0
   519 4FC6 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   520 4FC9 A0 01 84 AA		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   521 4FCD 88			                DEY                         ; param mask pointer is set to 0
   522 4FCE 20 F1 4E		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   523 4FD1 F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   524 4FD3 B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   525 						
   526 4FD5 20 10 50		                JSR     SH_GET_PATH         ; no, parse path parameter
   527 4FD8 B0 EF		                BCS     GET_PARM2           ; more parameters
   528
   529 4FDA 60			                RTS			    ; return
   530 						
   531 4FDB 20 5A 4C		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   532 4FDE 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   533 4FE1 B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   534 4FE3			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: macros.inc]
     1 4FE3 C9 20				CMP	#SPC
     2 4FE5 F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   535 4FE7					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: macros.inc]
     1 4FE7 CD 12 18				CMP	F_ATTRIBS
     2 4FEA D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   536 4FEC A5 AA		                LDA     MASK                ; load bit mask
   537 4FEE 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   538 4FF1 4C C6 4F		                JMP     GET_PARM            ; get next parameter from command line
   539
   540 4FF4 C8			NEXT_MASK       INY                         ; point to next char in param mask
   541 4FF5 06 AA		                ASL     MASK                ; shift bit mask to next position
   542 4FF7 D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   543
   544 4FF9 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   545 4FFC			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: macros.inc]
     1 4FFC A2 EE			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 4FFE A0 56			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   546 5000 20 C5 49		                JSR     OS_PRINT_ERR        ; and print it
   547 5003 AD 12 18		                LDA     F_ATTRIBS
   548 5006 20 52 E0		                JSR     COUT                ; print unknown parameter char
   549 5009 20 5A E0		                JSR     CROUT		    ; print CR
   550 500C 18			                CLC			    ; C=0: error
   551 500D 60			                RTS
   552 500E 38			GET_PARMS_END   SEC			    ; C=1: OK
   553 500F 60			                RTS
   554 				                
   555 				; ******************************************************************************
   556 5010 A6 AC		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   557 5012 A0 14		                LDY     #> STRBUF
   558 5014 20 CA 49		                JSR     OS_PARSE_PATH
   559 5017 B0 14		                BCS     GET_PATH_END
   560 5019 D0 03		SH_ERROR        BNE     PARSE_ERR1
   561
   562 501B 4C 17 55		                JMP     SH_NAME_ERR
   563
   564 501E			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: macros.inc]
     1 501E C9 5C				CMP	#PATH_SEP
     2 5020 D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   565 5022 4C 10 55		                JMP     SH_DIR_ERR
   566
   567 5025			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: macros.inc]
     1 5025 C9 FF				CMP	#$FF
     2 5027 D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   568 5029 4C 09 55		                JMP     SH_PATH_ERR
   569 502C 18			GET_PATH_ERR    CLC
   570 502D 60			GET_PATH_END    RTS
   571
   572 				; **** Set Pointer To Parameter Mask *******************************************
   573 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   574 				; ******************************************************************************
   575 502E			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: macros.inc]
     1 502E 86 E8			STX	STOL
     2 5030 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   576 5032 A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   577 5037 A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   578 503C 60			                RTS
   579
   580 				; Allowed Directory Options ****************************************************
   581 503D 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   582 5042 20			NO_PARMS        .by    ' '
   583
   584 				; **** DIR Command *************************************************************
   585 				; Prints a directory. The following optional parameters can be used:
   586 				; /P : 
   587 				; /A : Show attributes
   588 				; /H : Show hidden files
   589 				; /C : Show cluster number and LBA number
   590 				; ******************************************************************************
   591 5043 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   592 5046 20 9D 4F		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   593 5049			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: macros.inc]
     1 5049 A2 3D			LDX	<DIR_PARMS				; MADS makes this immediate
     2 504B A0 50			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   594 504D 20 C1 4F		                JSR     SH_GET_PARMS		; Get parameters from command-line
   595 5050 B0 03		                BCS     SH_DIR_START		; branch if parameter found
   596
   597 5052 4C AF 4F		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   598
   599 5055 A2 00		SH_DIR_START    LDX     #$00
   600 5057 8A			                TXA
   601 5058 8D 14 18		                STA     LINE_CNT            	; reset line counter
   602 505B 85 EE		                STA     PSAV                	; reset file found flag
   603 505D 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   604 5061			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: macros.inc]
     1 5061 E0 08				CPX	#$08
     2 5063 D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   605 5065			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: macros.inc]
     1 5065 A2 1B			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 5067 A0 4F			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   606 5069 20 6E 48		                JSR     OS_FIND_ALL         	; find and print directory entries
   607 506C 20 AF 4F		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   608 506F			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: macros.inc]
     1 506F A5 EE				LDA	PSAV
     2 5071 D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   609 5073 4C 02 55		                JMP     SH_FILE_ERR         	; no, print error
   610
   611 5076 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   612 5079 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   613 507F 20 63 4F		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   614 				                
   615 				; Print Total File Count
   616 5082			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: macros.inc]
     1 5082 AE 15 18			LDX	CURR_FILE_CNT
     2 5085 AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   617 5088 20 1D 4E		                JSR     PRINT_INT16		; print as word
   618 508B			                PRSTR   MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTR [Source: macros.inc]
     1 508B A2 9F			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 508D A0 56			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 508F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   619
   620 				; Print Total Used Bytes In Directory
   621 5092			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: macros.inc]
     1 5092 A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 5094 A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   622 5096 20 61 41		                JSR     LOAD_32			; NUM32 = total filesize
   623 5099 20 23 4E		                JSR     PRINT_INT32		; print as int32
   624 509C			                PRSTR   MSG_BYTE_USED		; print ' bytes'
Macro: PRSTR [Source: macros.inc]
     1 509C A2 B5			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 509E A0 56			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 50A0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   625
   626 				; Print Total Directory Count
   627 50A3					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: macros.inc]
     1 50A3 AE 17 18			LDX	CURR_DIR_CNT
     2 50A6 AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   628 50A9 20 1D 4E		                JSR     PRINT_INT16		; Print as word
   629 50AC			                PRSTR   MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTR [Source: macros.inc]
     1 50AC A2 AA			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 50AE A0 56			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 50B0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   630 50B3					MVAX	4 FREE_KB NUM32		; NUM32 = #Free KB
Macro: MVAX [Source: macros.inc]
     1 50B3 A2 03			LDX	#4-1
     2 50B5 BD D6 55 95 C0 CA	lp	MVA	FREE_KB,X NUM32,X-
     3 50BB 10 F8			BPL	lp
Source: boot_sys_sh.asm
   631 50BD 20 23 4E				JSR	PRINT_INT32		; Print as decimal number
   632 50C0					PRSTR	TXT_KB			; Print ' KB free'
Macro: PRSTR [Source: macros.inc]
     1 50C0 A2 EF			LDX	<TXT_KB				; MADS makes this immediate
     2 50C2 A0 55			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 50C4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   633 50C7 60					RTS				; return
   634 						
   635 				; **** Create Directory (MKDIR) Command ****************************************
   636 				;
   637 				; ******************************************************************************
   638 50C8 20 9D 4F		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   639 50CB			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: macros.inc]
     1 50CB A2 42			LDX	<NO_PARMS				; MADS makes this immediate
     2 50CD A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   640 50CF 20 C1 4F		                JSR     SH_GET_PARMS        	; get path
   641 50D2 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   642
   643 50D4 A9 10		                LDA     #FA_DIRECTORY		; create directory
   644 50D6 20 AE 47		                JSR     OS_CREATE           	; create directory
   645 50D9 B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   646
   647 50DB			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: macros.inc]
     1 50DB C9 FF				CMP	#$FF
     2 50DD F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   648
   649 50DF 20 25 55		                JSR     SH_WRITE_ERR        	; it was a write error
   650 50E2 90 03		                BCC     SH_MKDIR_END        	; branch always
   651
   652 50E4 20 1E 55		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   653 50E7 4C AF 4F		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   654
   655 				; **** Check if Current Dir. ***************************************************
   656 				; Check if directory entered is current dir (..).
   657 				; Output: C=0: not a current dir, C=1: is current dir.
   658 				; ******************************************************************************
   659 50EA A0 00		IS_FNAME_CURDIR	LDY	#0
   660 50EC B9 92 4B				LDA	FILENAME,Y
   661 50EF					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 50EF C9 2E				CMP	#'.'
     2 50F1 D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   662 50F3 C8					INY
   663 50F4					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: macros.inc]
     1 50F4 B9 92 4B				LDA	FILENAME,Y
     2 50F7 D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   664 50F9 F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   665
   666 				; **** Check if Parent Dir. ************************************************
   667 				; Check if current directory is parent dir (..).
   668 				; Output: C=0: not a parent dir, C=1: is parent dir.
   669 				; ******************************************************************************
   670 50FB A0 00		IS_FNAME_PARENT	LDY	#0
   671 50FD B9 92 4B				LDA	FILENAME,Y
   672 5100					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5100 C9 2E				CMP	#'.'
     2 5102 D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   673 5104 C8					INY
   674 5105 B9 92 4B				LDA	FILENAME,Y
   675 5108					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5108 C9 2E				CMP	#'.'
     2 510A D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   676 510C C8					INY
   677 510D					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: macros.inc]
     1 510D B9 92 4B				LDA	FILENAME,Y
     2 5110 D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   678
   679 5112 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   680 5113 60					RTS
   681 5114 18			NOT_FNAME	CLC				; The filename is not . or ..
   682 5115 60					RTS
   683 						
   684 				; **** Convert filename to FN83 type filename **********************************
   685 				; INPUT: ssptr_l/ssptr_h pointer to filename
   686 				; OUTPUT: converted filename in FN83
   687 				; ******************************************************************************
   688 5116 A0 00		FNAME2FN83	LDY	#0
   689 5118 B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   690 511A					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: macros.inc]
     1 511A C9 2E				CMP	#'.'
     2 511C F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   691 						
   692 511E C8			CPFNCNT		INY
   693 511F					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: macros.inc]
     1 511F C0 0B				CPY	#D_ATTRIBUTES
     2 5121 D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   694 5123 F0 18				BEQ	EXT_DN			; branch always if no dot was found
   695
   696 5125			FN83_DOTFND	; Found a dot
   697 5125 A2 08				LDX	#8
   698 5127 C8					INY				; points to char next to '.'
   699 5128 B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get char of extension
   700 512A 20 5A 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   701 512D					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: macros.inc]
     1 512D 9D 92 4B				STA	FILENAME,X
     2 5130 F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   702 5132 C8					INY
   703 5133 E8					INX
   704 5134					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: macros.inc]
     1 5134 E0 0B				CPX	#D_ATTRIBUTES
     2 5136 D0 F0				BNE	CPFN83_2
Source: boot_sys_sh.asm
   705 						
   706 5138 A9 00 9D 92 4B			MVA	#0 FILENAME,X		; Add '\0' to filename
   707 513D A0 00		EXT_DN		LDY	#0
   708 513F B1 78		CPFN83_3	LDA	(ssptr_l),Y		; Get char of Filename
   709 5141 20 5A 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   710 5144 99 92 4B				STA	FILENAME,Y		; Store in result
   711 5147					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: macros.inc]
     1 5147 C9 2E				CMP	#'.'
     2 5149 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   712 514B C8					INY
   713 514C					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 514C C0 08				CPY	#8
     2 514E D0 EF				BNE	CPFN83_3
Source: boot_sys_sh.asm
   714 5150 60					RTS				; return
   715 						
   716 5151 A9 20 99 92 4B C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   717 5157					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5157 C0 08				CPY	#8
     2 5159 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   718 515B 60			CPFN_DN		RTS				; return
   719 						
   720 				; **** CFC_LOAD routine for CF-IDE driver **************************************
   721 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP CFC_LOAD_VEC.
   722 				; ******************************************************************************
   723 515C			CFC_LOAD	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 515C 8E 90 51			STX	FNAME_PTR
     2 515F 8C 91 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   724 5162					PRSTR	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTR [Source: macros.inc]
     1 5162 A2 85			LDX	<TXT_LOAD				; MADS makes this immediate
     2 5164 A0 51			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 5166 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   725 5169 20 16 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   726 516C					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 516C A9 5B			LDA	#'['
     2 516E 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   727 5171					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 5171 A2 92			LDX	<FILENAME				; MADS makes this immediate
     2 5173 A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   728 5175 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   729 5178					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 5178 A9 5D			LDA	#']'
     2 517A 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   730 517D 20 9D 4F				JSR     SAVE_ACT_DIR        	; save actual directory LBA
   731 5180 20 5D 54				JSR	SH_LOAD_BAS		; Load .bas file in memory
   732 5183 38					SEC				; C=1: OK
   733 5184 60					RTS				; return
   734
   735 5185 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
   736 5190 00 00		FNAME_PTR	.word 	$0000
   737
   738 				; **** CFC_SAVE routine for CF-IDE driver **************************************
   739 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP CFC_SAVE_VEC.
   740 				; ******************************************************************************
   741 5192			CFC_SAVE	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 5192 8E 90 51			STX	FNAME_PTR
     2 5195 8C 91 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   742 5198					PRSTR	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTR [Source: macros.inc]
     1 5198 A2 2B			LDX	<TXT_SAVE				; MADS makes this immediate
     2 519A A0 52			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 519C 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   743 519F					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: macros.inc]
     1 519F AD 01 20			LDA	$2000+1				; print MSB
     2 51A2 20 91 E0			JSR	HEXOUT
     3 51A5 AD 00 20			LDA	$2000
     4 51A8 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   744 51AB 20 5E E0				JSR	SPCOUT		
   745 51AE 20 16 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   746 51B1					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 51B1 A9 5B			LDA	#'['
     2 51B3 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   747 51B6					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 51B6 A2 92			LDX	<FILENAME				; MADS makes this immediate
     2 51B8 A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   748 51BA 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   749 51BD					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 51BD A9 5D			LDA	#']'
     2 51BF 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   750 51C2 AD 00 20 8D 48 52 + 		MWA	$2000 SAVE_LEN		; SAVE_LEN = end-address
   751 51CE 38 AD 48 52 E9 00 + 		SBW	SAVE_LEN #$2000		; Get net file-size
   752 51DF AD 49 52 8D 4A 52			MVA	SAVE_LEN+1 SAVE_SECS	; SAVE_SECS now contains #pages of 256 bytes
   753 51E5 4E 4A 52				LSR	SAVE_SECS		; SAVE_SECS now contains #sectors of 512 bytes needed
   754 51E8					LDA.EQ	SAVE_LEN NO_ADD_SEC	; branch if LSB of SAVE_LEN is 0
Macro: LDA.EQ [Source: macros.inc]
     1 51E8 AD 48 52				LDA	SAVE_LEN
     2 51EB F0 03				BEQ	NO_ADD_SEC
Source: boot_sys_sh.asm
   755
   756 51ED EE 4A 52				INC	SAVE_SECS		; Add 1 to SAVE_SECS if LSB of SAVE_LEN is not 0
   757 51F0			NO_ADD_SEC	PRSTR	TXT_SECND1		; Print ', size: '
Macro: PRSTR [Source: macros.inc]
     1 51F0 A2 37			LDX	<TXT_SECND1				; MADS makes this immediate
     2 51F2 A0 52			LDY	>TXT_SECND1
Source: boot_sys_sh.asm
     2 51F4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   758 51F7					LDXY	SAVE_LEN		; Size in bytes
Macro: LDXY [Source: macros.inc]
     1 51F7 AE 48 52			LDX	SAVE_LEN
     2 51FA AC 49 52			LDY	SAVE_LEN+1
Source: boot_sys_sh.asm
   759 51FD 20 1D 4E				JSR	PRINT_INT16		; Print it
   760 5200					PRSTR	TXT_SECND2		; Print ', sec: '
Macro: PRSTR [Source: macros.inc]
     1 5200 A2 40			LDX	<TXT_SECND2				; MADS makes this immediate
     2 5202 A0 52			LDY	>TXT_SECND2
Source: boot_sys_sh.asm
     2 5204 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   761 5207 AD 4A 52				LDA	SAVE_SECS		; Get sector count
   762 520A 20 65 4C				JSR	NUMOUT			; Print #sectors needed
   763 520D 20 5A E0				JSR	CROUT			; Print CR
   764 						
   765 5210					PRSTR	TXT_OS_CREATE		; Print 'OS_CREATE'
Macro: PRSTR [Source: macros.inc]
     1 5210 A2 4B			LDX	<TXT_OS_CREATE				; MADS makes this immediate
     2 5212 A0 52			LDY	>TXT_OS_CREATE
Source: boot_sys_sh.asm
     2 5214 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   766 5217 A9 20				LDA	#FA_ARCHIVE		; File is modified 
   767 5219 20 AE 47				JSR	OS_CREATE		; Create file in current dir. and update FAT
   768 521C					PRSTR	TXT_OS_SAVFILE		; Print 'OS_SAVE_FILE'
Macro: PRSTR [Source: macros.inc]
     1 521C A2 56			LDX	<TXT_OS_SAVFILE				; MADS makes this immediate
     2 521E A0 52			LDY	>TXT_OS_SAVFILE
Source: boot_sys_sh.asm
     2 5220 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   769 5223 20 11 45				JSR	OS_SAVE_FILE		; Save contents of file
   770 5226 20 3B 56				JSR	SIS_DEL			; Subtract #allocated clusters from SIS and write back to disk
   771 5229 38					SEC				; C=1: OK
   772 522A 60					RTS				; return
   773
   774 522B 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
   775 5237 2C 20 73 69 7A 65 + TXT_SECND1	.by	', size: ' $00
   776 5240 2C 20 73 65 63 3A + TXT_SECND2	.by	', sec: ' $00
   777 5248 00 00		SAVE_LEN	.word	$0000			; #bytes to save
   778 524A 00			SAVE_SECS	.byte	$00			; #sectors (of 512 B) to save
   779 524B 4F 53 5F 43 52 45 + TXT_OS_CREATE	.by	'OS_CREATE' CR $00
   780 5256 4F 53 5F 53 41 56 + TXT_OS_SAVFILE 	.by	'OS_SAVE_FILE' CR $00
   781
   782 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   783 				; Check if directory entered is current dir (..).
   784 				; Output: C=0: not a current dir, C=1: is current dir.
   785 				; ******************************************************************************
   786 5264 A0 00		ADD_SUBDIR_NAME	LDY	#0
   787 5266			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5266 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5269 F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   788 526B C8					INY
   789 526C D0 F8				BNE	FIND_EOS			; branch always
   790 526E 60					RTS
   791
   792 526F			SUBDIR_EOS	CPY.EQ	#1 CP_INIT		; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 526F C0 01				CPY	#1
     2 5271 F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   793 5273 A9 5C 99 20 04			MVA	#BSLASH D_SUBDIR_NAME,Y	; add '\' to subdir name
   794 5278 C8					INY
   795 5279 A2 00		CP_INIT		LDX	#0
   796 527B BD 92 4B 99 20 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   797 5281 F0 06				BEQ	SUBDIR_X		; exit if $00 found
   798 						
   799 5283 C8					INY				; index in D_SUBDIR_NAME
   800 5284 E8					INX				; index in FILENAME
   801 5285					CPX.NE	#D_ATTRIBUTES CP_FNAME	; branch if not at max filename yet
Macro: CPX.NE [Source: macros.inc]
     1 5285 E0 0B				CPX	#D_ATTRIBUTES
     2 5287 D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   802 5289 60			SUBDIR_X	RTS				; return if done
   803 						
   804 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   805 				; ******************************************************************************
   806 528A A0 00		DEL_SUBDIR_NAME	LDY	#0
   807 528C			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS2	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 528C B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 528F F0 04				BEQ	SUBDIR_EOS2
Source: boot_sys_sh.asm
   808 5291 C8					INY
   809 5292 D0 F8				BNE	FIND_EOS2			; branch always
   810 5294 60			DEL_SUBDIR_X	RTS
   811
   812 5295 88			SUBDIR_EOS2	DEY				; goto last char before $00
   813 5296 B9 20 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y		; get char from D_SUBDIR_NAME
   814 5299					CMP.EQ	#BSLASH BSLASH_FND	; branch if filename separator found
Macro: CMP.EQ [Source: macros.inc]
     1 5299 C9 5C				CMP	#BSLASH
     2 529B F0 03				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   815 529D					DEY.NE	SUBDIR_LP1		; branch always
Macro: DEY.NE [Source: macros.inc]
     1 529D 88					DEY
     2 529E D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   816
   817 52A0			BSLASH_FND	CPY.EQ	#0 DSNM_X		; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 52A0 C0 00				CPY	#0
     2 52A2 F0 05				BEQ	DSNM_X
Source: boot_sys_sh.asm
   818 52A4 A9 00 99 20 04			MVA	#0 D_SUBDIR_NAME,Y	; replace '\' with '\0' in D_SUBDIR_NAME
   819 52A9 60			DSNM_X		RTS				; and return
   820
   821 				; **** Change Directory Command ************************************************
   822 				;
   823 				; ******************************************************************************
   824 52AA 20 9D 4F		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   825 52AD			                LDXYI   NO_PARMS
Macro: LDXYI [Source: macros.inc]
     1 52AD A2 42			LDX	<NO_PARMS				; MADS makes this immediate
     2 52AF A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   826 52B1 20 C1 4F		                JSR     SH_GET_PARMS		; get subdir name
   827 52B4 90 26		                BCC     SH_CD_END		; C=0: no name entered
   828
   829 52B6			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: macros.inc]
     1 52B6 AD 11 18				LDA	TERM_CHAR
     2 52B9 D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   830 52BB 20 64 48		                JSR     OS_FIND_PATH		; loop through dir to find path
   831 52BE 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   832 						
   833 52C0 A0 00				LDY	#0			; add '\0' to string
   834 52C2 B9 92 4B		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   835 52C5					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: macros.inc]
     1 52C5 C9 20				CMP	#' '
     2 52C7 F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   836 52C9 C8					INY
   837 52CA					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: macros.inc]
     1 52CA C0 0B				CPY	#D_ATTRIBUTES
     2 52CC D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   838 						
   839 52CE A9 00 99 92 4B	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   840 52D3 20 FB 50				JSR	IS_FNAME_PARENT		; is dir .. ?
   841 52D6 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   842 						
   843 52D8 20 8A 52				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   844 52DB 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   845 52DC 60			SH_CD_END	RTS
   846
   847 52DD 20 EA 50		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   848 52E0 B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   849 						
   850 52E2 20 64 52				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   851 52E5 4C DB 52				JMP	SH_CD_EXIT_OK		; branch always
   852 						
   853 52E8 20 AF 4F		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   854 52EB 20 5A E0		                JSR     CROUT			; print CR
   855 52EE 4C 09 55		                JMP     SH_PATH_ERR		; Print 'Path not found'
   856
   857 				; **** Release the FAT clusters for a file  ************************************
   858 				; Algorithm:
   859 				;       SCNT = 1;
   860 				; loop: CURR_CLUSTER = FAT[CURR_CLUSTER];
   861 				;       FAT[CURR_CLUSTER] = 0L; // 0L = free entry
   862 				;       if (CURR_CLUSTER == 0FFFFFFF) SCNT++; goto loop;
   863 				; ******************************************************************************
   864 52F1 A2 00 8E F9 55	CLR_FAT32_FILE 	MVX 	#0 SIS_CNT			; #clusters cleared
   865 52F6			CLR_FAT32_LP1	LDXYI   D_START_FAT1      		; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 52F6 A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 52F8 A0 04			LDY	>D_START_FAT1
Source: boot_sys_sh.asm
   866 52FA 20 61 41		                JSR     LOAD_32		    		; NUM32 = LBA nr. of FAT
   867 52FD					LDXYI	(CURR_CLUSTER+1)			; SUM32 = CURR_CLUSTER into SUM32
Macro: LDXYI [Source: macros.inc]
     1 52FD A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 52FF A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_sh.asm
   868 5301 20 5B 41				JSR     LOAD_S32            		; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   869 5304 20 6A 53				JSR	PRTST1				; DEBUG
   870 5307 A2 00 86 C7				MVX	#$00 SUM32+3			; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   871 530B A0 03		                LDY     #$03
   872 530D A5 A0		                LDA     CURR_CLUSTER        		; load CURR_CLUSTER[0] = FAT entry index byte
   873 530F 0A			                ASL                         		; shift bit 7 into carry flag and multiply entry index by 2
   874 5310 48			                PHA                         		; save entry index to stack
   875 5311 36 C4 E8		CLR32_LP        ROL     SUM32,X+             		; shift bit 7 of entry index into bit 0 of block index
   876 5314			                DEY.NE  CLR32_LP	    		; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 5314 88					DEY
     2 5315 D0 FA				BNE	CLR32_LP
Source: boot_sys_sh.asm
   877 						
   878 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   879 5317 20 8F 41		                JSR     ADD_32_32	    		; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   880 531A 20 1D 41		                JSR     LOAD_FAT_BLK	    		; Load FAT sector into standard buffer ($600)
   881 531D 68			                PLA                         		; restore entry index
   882 531E A2 04		                LDX     #$04                		; four bytes to read for a FAT32 entry
   883 5320 0A			                ASL                         		; multiply entry index by 2 (4 in total now)
   884 5321 A8			                TAY                         		; store entry index into Y
   885 5322 20 91 E0				JSR	HEXOUT				; DEBUG
   886 5325 A2 04 86 AC		                MVX	#4 NCNT				; 1 FAT entry = 4 bytes
   887 5329 A2 00				LDX	#0				; init. CURR_CLUSTER index
   888 532B 20 EA 40		LP_FAT_ENTRY    JSR     READ_ENTRY_BYTE     		; read entry byte
   889 532E 9D 66 53				STA     TEMP_CLUSTER,X      		; store byte in TEMP_CLUSTER to follow link
   890 5331 20 89 53				JSR	WR_ENTRY_BYTE			; FAT[CURR_CLUSTER] = 0
   891 5334 C8					INY					; Increment FAT index counter
   892 5335 E8			                INX					; Increment CURR_CLUSTER counter
   893 5336			                DEC.NE  NCNT LP_FAT_ENTRY   		; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 5336 C6 AC				DEC	NCNT
     2 5338 D0 F1				BNE	LP_FAT_ENTRY
Source: boot_sys_sh.asm
   894 533A					MVAX	4 TEMP_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = TEMP_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 533A A2 03			LDX	#4-1
     2 533C BD 66 53 95 A0 CA	lp	MVA	TEMP_CLUSTER,X CURR_CLUSTER,X-
     3 5342 10 F8			BPL	lp
Source: boot_sys_sh.asm
   895 5344 EE F9 55				INC	SIS_CNT				; #clusters cleared + 1
   896 5347 A9 0F C5 A3 D0 10 + 		CPD	#$0FFFFFFF CURR_CLUSTER		; CURR_CLUSTER == $0FFFFFFF ?
   897 535D D0 97				BNE	CLR_FAT32_LP1			; branch if file has more clusters to clear
   898 						
   899 535F					LDXYI	CURR_FAT_BLK			; LBA of current FAT block
Macro: LDXYI [Source: macros.inc]
     1 535F A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 5361 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_sh.asm
   900 5363 4C 18 42				JMP	DEV_WR_LBLK_BUF			; write FAT block back to disk and return
   901
   902 5366 00 00 00 00		TEMP_CLUSTER	.dword	$00000000
   903 						
   904 536A			PRTST1		PRCH	'<'
Macro: PRCH [Source: macros.inc]
     1 536A A9 3C			LDA	#'<'
     2 536C 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   905 536F					PRHEX32	CURR_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 536F A5 A3			LDA	CURR_CLUSTER+2+1				; print MSB
     2 5371 20 91 E0			JSR	HEXOUT
     3 5374 A5 A2			LDA	CURR_CLUSTER+2
     4 5376 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5379 A5 A1			LDA	CURR_CLUSTER+1				; print MSB
     2 537B 20 91 E0			JSR	HEXOUT
     3 537E A5 A0			LDA	CURR_CLUSTER
     4 5380 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   906 5383					PRCH	'>'
Macro: PRCH [Source: macros.inc]
     1 5383 A9 3E			LDA	#'>'
     2 5385 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   907 5388 60					RTS
   908
   909 				; **** Write a Single FAT Entry Byte From Block Buffer *************************
   910 				; INPUT : Y - Index To FAT Entry Byte
   911 				; OUTPUT: A = Read Byte from FAT table
   912 				; ******************************************************************************
   913 5389			WR_ENTRY_BYTE 	AND.NE  #$01 CURR_CLUSTER+1 CLR_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 5389 A9 01				LDA	#$01
     3 538B 25 A1				AND	CURR_CLUSTER+1
     4 538D D0 06				BNE	CLR_UPPER_PAGE
Source: boot_sys_sh.asm
   914 538F A9 00 99 00 06	                MVA	#0 BLOCK_BUFF,Y				; write entry byte from lower half of block buffer
   915 5394 60			                RTS			    			; return
   916 5395 A9 00 99 00 07	CLR_UPPER_PAGE  MVA     #0 BLOCK_BUFF+256,Y    			; write entry byte from upper half of block buffer
   917 539A 60			                RTS			    			; return
   918
   919 				; **** Delete Command **********************************************************
   920 				;
   921 				; ******************************************************************************
   922 539B 20 9D 4F		SH_DEL          JSR     SAVE_ACT_DIR        			; save actual directory LBA
   923 539E			                LDXYI   NO_PARMS          			; we don't need parameters, just the filename
Macro: LDXYI [Source: macros.inc]
     1 539E A2 42			LDX	<NO_PARMS				; MADS makes this immediate
     2 53A0 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   924 53A2 20 C1 4F		                JSR     SH_GET_PARMS        			; get path
   925 53A5 90 33		                BCC     SH_DEL_X	    			; branch if no filename was given
   926
   927 53A7 20 6A 48		                JSR     OS_FIND_FILE				; Now find file to delete
   928 53AA 90 31		                BCC     SH_DEL_ERR				; branch if file not found
   929
   930 						; OS_FIND_FILE did already set CURR_CLUSTER to the file starting-cluster
   931 53AC A0 00		SH_DEL_FILE	LDY	#D_FILENAME
   932 53AE A9 E5 91 A8				MVA	#$E5 (CURR_DIR_ENTRY),Y			; $E5 first char. is a deleted file
   933 53B2 A0 14				LDY	#D_START_CLSTH
   934 53B4 A9 00 91 A8 C8 91 + 		MWA	#$00 (CURR_DIR_ENTRY),Y			; delete high word of file-size
   935 53BB					PRHEX16	CURR_DIR_BLK
Macro: PRHEX16 [Source: macros.inc]
     1 53BB AD 25 18			LDA	CURR_DIR_BLK+1				; print MSB
     2 53BE 20 91 E0			JSR	HEXOUT
     3 53C1 AD 24 18			LDA	CURR_DIR_BLK
     4 53C4 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   936 53C7					LDXYI	CURR_DIR_BLK				; CURR_DIR_BLK is LBA of current dir block
Macro: LDXYI [Source: macros.inc]
     1 53C7 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 53C9 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_sh.asm
   937 53CB 20 FB 42		                JSR     OS_SAVE_DIR	    			; write this dir entry back to disk
   938 						
   939 53CE 20 F1 52				JSR	CLR_FAT32_FILE				; Set all FAT entries for this file to 00000000 (free)
   940 53D1 20 26 46				JSR	INIT_FREE_CLUSTER			; FREE_CLUSTER = 2L
   941 53D4 20 37 46				JSR     OS_NEXT_FREE_CLUSTER			; Get first free cluster in FREE_CLUSTER
   942
   943 						; Update SIS with #clusters freed and first-free cluster nr
   944 53D7 20 FA 55				JSR	SIS_ADD					; Update SIS and write back
   945 53DA 4C AF 4F		SH_DEL_X        JMP     LOAD_ACT_DIR        			; error - restore actual directory LBA and return
   946
   947 53DD 4C 02 55		SH_DEL_ERR	JMP	SH_FILE_ERR				; Print 'File not found' and return
   948
   949 				; **** Clear Screen Command ****************************************************
   950 				;
   951 				; ******************************************************************************
   952 53E0 4C B5 E0		SH_CLS          JMP     CLRSCRN
   953
   954 				; **** Pause Command ***********************************************************
   955 				; Output: A - pressed key char
   956 				;         C = 0 ESC key pressed, C = 1 else
   957 				; ******************************************************************************
   958 53E3			SH_PAUSE        PRSTR   MSG_PAUSE          	; print pause message
Macro: PRSTR [Source: macros.inc]
     1 53E3 A2 68			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 53E5 A0 56			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 53E7 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   959 53EA 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   960 53ED 48			                PHA
   961 53EE 20 5A E0		                JSR     CROUT
   962 53F1 68			                PLA
   963 53F2 60			                RTS
   964 				                
   965 				; **** Echo Command ************************************************************
   966 				;
   967 				; ******************************************************************************
   968 53F3			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 53F3 BD 00 14				LDA	STRBUF,X
     2 53F6 F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   969 53F8 8A			                TXA
   970 53F9 A8			                TAY
   971 53FA C8			                INY
   972 53FB 20 85 E0		                JSR     WRSTR
   973 53FE 20 5A E0		                JSR     CROUT
   974 5401 60			SH_ECHO_END     RTS
   975
   976 				; **** Goto Command ************************************************************
   977 				;
   978 				; ******************************************************************************
   979 5402 60			SH_GOTO         RTS
   980
   981 				; **** If Command **************************************************************
   982 				;
   983 				; ******************************************************************************
   984 5403 20 26 46		SH_IF           JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   985 5406 20 37 46		                JSR 	OS_NEXT_FREE_CLUSTER
   986 5409 A0 03				LDY 	#3
   987 540B			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: macros.inc]
     1 540B 98				TYA
     2 540C 48				PHA
Source: boot_sys_sh.asm
   988 540D B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   989 5410 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   990 5413					PLY				; restore Y
Macro: PLY [Source: macros.inc]
     1 5413 68				PLA
     2 5414 A8				TAY
Source: boot_sys_sh.asm
   991 5415					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5415 88					DEY
     2 5416 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   992 5418 60					RTS
   993
   994 				; **** Rem Command *************************************************************
   995 				;
   996 				; ******************************************************************************
   997 5419			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: macros.inc]
     1 5419 A5 DC			LDA	BLKBUF
     2 541B 48				PHA
     3 541C A5 DD			LDA	BLKBUF+1
     4 541E 48				PHA
Source: boot_sys_sh.asm
   998 541F 20 5F 55				JSR	GET_SIS
   999 5422					PLW	BLKBUF
Macro: PLW [Source: macros.inc]
     1 5422 68				PLA
     2 5423 85 DD			STA	BLKBUF+1
     3 5425 68				PLA
     4 5426 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
  1000 5428 60			SH_REM_X	RTS
  1001 				                
  1002 				; **** BASIC Command ***********************************************************
  1003 				; Executes Basic in ROM. Return with 'DOS' command. 
  1004 				; ******************************************************************************
  1005 5429 20 0A E0		SH_BASIC        JSR	SWITCH_TO_ROM		; Make sure BASIC ROM is enabled
  1006 542C A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
  1007 542E					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: macros.inc]
     1 542E C9 B1				CMP	#$B1
     2 5430 D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
  1008 						
  1009 5432 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
  1010 5435 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
  1011
  1012 				; **** BRUN Command ************************************************************
  1013 				;
  1014 				; ******************************************************************************
  1015 5438 20 9D 4F		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1016 543B			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 543B A2 42			LDX	<NO_PARMS				; MADS makes this immediate
     2 543D A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1017 543F 20 C1 4F		                JSR     SH_GET_PARMS
  1018 5442 90 05		                BCC     SH_BRUN_END
  1019
  1020 5444 20 6A 48		                JSR     OS_FIND_FILE
  1021 5447 90 00		                BCC     SH_BRUN_END		; branch if file not found
  1022
  1023 				                ;JSR     OS_LOAD_BIN
  1024 5449 20 AF 4F		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1025 544C 60			                RTS
  1026 				                
  1027 				; **** BLOAD Command ***********************************************************
  1028 				;
  1029 				; ******************************************************************************
  1030 544D 60			SH_BLOAD        RTS
  1031
  1032 				; ******************************************************************************
  1033 544E 20 9D 4F		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
  1034 5451			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 5451 A2 42			LDX	<NO_PARMS				; MADS makes this immediate
     2 5453 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1035 5455 20 2E 50		                JSR     SET_PARM_MASK
  1036 5458 20 10 50		                JSR     SH_GET_PATH         ; get file path
  1037 545B 90 66		                BCC     SH_RUN_END
  1038
  1039 						; This is the entry-point for loading a .BAS file into memory
  1040 545D AD 9A 4B		SH_LOAD_BAS     LDA     FILENAME+8
  1041 5460			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: macros.inc]
     1 5460 C9 20				CMP	#SPC
     2 5462 D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
  1042 5464					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: macros.inc]
     1 5464 A0 02			LDY	#3-1
     2 5466 B9 7E 57 99 9A 4B + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 546D 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1043
  1044 						; Check for .COM file
  1045 546F A0 02		SH_RUN1         LDY     #$02
  1046 5471 B9 7E 57		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
  1047 5474					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: macros.inc]
     1 5474 D9 9A 4B				CMP	FILENAME+8,Y
     2 5477 D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
  1048 5479			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5479 88					DEY
     2 547A 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
  1049 				                
  1050 547C A9 01 8D 6C 44			MVA	#1 FTYPE	    	; 1 = .COM file
  1051 5481 D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
  1052
  1053 5483 A0 02		CHK_BASF	LDY     #$02
  1054 5485 B9 84 57		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
  1055 5488			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: macros.inc]
     1 5488 D9 9A 4B				CMP	FILENAME+8,Y
     2 548B D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
  1056 548D			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 548D 88					DEY
     2 548E 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
  1057 				                
  1058 5490 A9 00 8D 6C 44			MVA	#0 FTYPE	    	; 0 = .BAS file
  1059 5495 F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
  1060
  1061 5497 A0 02		CHK_EXEF	LDY     #$02
  1062 5499 B9 81 57		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
  1063 549C			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: macros.inc]
     1 549C D9 9A 4B				CMP	FILENAME+8,Y
     2 549F D0 22				BNE	SH_RUN_END
Source: boot_sys_sh.asm
  1064 54A1			                DEY.PL	CMP_EXT_EXE	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54A1 88					DEY
     2 54A2 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
  1065 				                
  1066 54A4 A9 02 8D 6C 44			MVA	#2 FTYPE	    	; 2 = .EXE file
  1067 54A9 20 6A 48		SH_RUN_FF       JSR     OS_FIND_FILE        	; check if file with this extension exists
  1068 54AC B0 12		                BCS     SH_RUN3             	; yes, load file
  1069
  1070 54AE 20 C6 54		                JSR     SH_SET_SYS_DIR      	; no, search in system directory
  1071 54B1 90 05		                BCC     SH_RUN_ERR          	; system directory does not exist
  1072
  1073 54B3 20 6A 48		SH_RUN2         JSR     OS_FIND_FILE	    	; find file with this extension in root-dir
  1074 54B6 B0 08		                BCS     SH_RUN3		    	; branch if found
  1075
  1076 54B8 20 5A E0		SH_RUN_ERR      JSR     CROUT		    	; print CR
  1077 54BB 20 02 55		                JSR     SH_FILE_ERR         	; file does not exist
  1078 54BE 90 03		                BCC     SH_RUN_END	    	; branch always
  1079
  1080 54C0 20 7F 44		SH_RUN3         JSR     OS_LOAD_FILE	    	; Load .bas file or load/run .com/.exe file
  1081 54C3 4C AF 4F		SH_RUN_END      JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
  1082 				                
  1083 				; **** Set System Directory ****************************************************
  1084 				; Output: C = 0 - Error
  1085 				; ******************************************************************************
  1086 54C6 A2 0A		SH_SET_SYS_DIR  LDX     #10
  1087 54C8 BD 92 4B 9D 73 57	SAVE_NAME       MVA	FILENAME,X   NAME_SAVE,X	; NAME_SAVE = FILENAME
  1088 54CE BD 68 57 9D 92 4B + 		MVA	SYSTEM_DIR,X FILENAME,X-	; FILENAME = SYSTEM_DIR
  1089 54D5 10 F1		                BPL     SAVE_NAME			; branch if not done
  1090
  1091 54D7 20 41 49		                JSR     OS_SET_ROOT_DIR
  1092 54DA					LDXYI	CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 54DA A2 CA			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 54DC A0 4A			LDY	>CB_FIND_SUBDIR
Source: boot_sys_sh.asm
  1093 54DE 20 72 48		                JSR     OS_FIND             		; find subdirectory
  1094 54E1 90 0C		                BCC     SH_SYS_DIR_END
  1095
  1096 54E3			                MVAX	11 NAME_SAVE FILENAME		; FILENAME = NAME_SAVE
Macro: MVAX [Source: macros.inc]
     1 54E3 A2 0A			LDX	#11-1
     2 54E5 BD 73 57 9D 92 4B + lp	MVA	NAME_SAVE,X FILENAME,X-
     3 54EC 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1097 54EE 38			                SEC
  1098 54EF 60			SH_SYS_DIR_END  RTS
  1099
  1100 				; **** Print version info  *****************************************************
  1101 				; Output: -
  1102 				; ******************************************************************************
  1103 54F0			SH_VER		PRSTR	MSG_BOOT			; Print Title Info
Macro: PRSTR [Source: macros.inc]
     1 54F0 A2 33			LDX	<MSG_BOOT				; MADS makes this immediate
     2 54F2 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_sh.asm
     2 54F4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1104 54F7 60					RTS
  1105 						
  1106 				; **** Monitor call-back Routine ************************************************
  1107 54F8			SH_MONITOR      PRSTR   MSG_MONITOR
Macro: PRSTR [Source: macros.inc]
     1 54F8 A2 3F			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 54FA A0 57			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 54FC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1108 54FF 4C 03 E0		                JMP     MON_WARM_START
  1109 				                
  1110 				.macro	PR_ERR	msg
  1111 						LDXYI	:msg
  1112 						JMP	OS_PRINT_ERR
  1113 				.endm
  1114 				; **** Error Routines **********************************************************
  1115 5502			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5502 A2 CE			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 5504 A0 56			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 5506 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1116 5509			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5509 A2 DE			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 550B A0 56			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 550D 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1117 5510			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5510 A2 11			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 5512 A0 57			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 5514 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1118 5517			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5517 A2 FF			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 5519 A0 56			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 551B 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1119 551E			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 551E A2 24			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 5520 A0 57			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 5522 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1120 5525			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5525 A2 4D			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 5527 A0 57			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 5529 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1121 				                
  1122 				; Inits BLKBUF to SIS_BUFF **************************************
  1123 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1124 				; ***************************************************************
  1125 552C A9 00 85 DC A9 59 + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1126 5534 60					RTS
  1127
  1128 				;-------------------------------------------------------------------------------
  1129 				; Convert #Clusters to KB in FREE_KB
  1130 				; D_SECT_PER_CLST = 1: 2 CL =  2 SEC = 1 KB: SHR 1
  1131 				;                   2: 2 CL =  4 SEC = 2 KB: -
  1132 				;		    4: 2 CL =  8 SEC = 4 KB: SHL 1
  1133 				;		    8: 2 CL = 16 SEC = 8 KB: SHL 2 etcetera
  1134 				;-------------------------------------------------------------------------------
  1135 5535 AD 0B 04		CL2KB		LDA	D_SECT_PER_CLST			; #sectors per cluster
  1136 5538					CMP.EQ	#2 CL2KB_X			; 2 sec/cl, just exit
Macro: CMP.EQ [Source: macros.inc]
     1 5538 C9 02				CMP	#2
     2 553A F0 22				BEQ	CL2KB_X
Source: boot_sys_sh.asm
  1137 553C					CMP.EQ	#1 CL2KB_1			; 1 sec/cl, SHR 1
Macro: CMP.EQ [Source: macros.inc]
     1 553C C9 01				CMP	#1
     2 553E F0 12				BEQ	CL2KB_1
Source: boot_sys_sh.asm
  1138 5540 4A 4A			:2	LSR					; init nr of shifts		
  1139 5542			CL2KB_SHL	ASL32	FREE_KB				; SHL 1 of FREE_KB
Macro: ASL32 [Source: macros.inc]
     1 5542 0E D6 55			ASL     FREE_KB		  		; SHL with C=0
     2 5545 2E D7 55		        ROL     FREE_KB+1		  
     3 5548 2E D8 55		        ROL     FREE_KB+2
     4 554B 2E D9 55		        ROL     FREE_KB+3		  
Source: boot_sys_sh.asm
  1140 554E 4A					LSR
  1141 554F D0 F1				BNE	CL2KB_SHL			; branch if not done with shifting
  1142 5551 60					RTS					; return
  1143 						
  1144 5552			CL2KB_1		LSR32	FREE_KB				; SHR 1 of FREE_KB
Macro: LSR32 [Source: macros.inc]
     1 5552 4E D9 55			LSR     FREE_KB+3		  		; SHR with C=0
     2 5555 6E D8 55		        ROR     FREE_KB+2
     3 5558 6E D7 55		        ROR     FREE_KB+1
     4 555B 6E D6 55		        ROR     FREE_KB
Source: boot_sys_sh.asm
  1145 555E 60			CL2KB_X		RTS					; return
  1146 						
  1147 				; Get Info from System Information Sector **************************************
  1148 555F 20 2C 55		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1149 5562					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START
Macro: LDXYI [Source: macros.inc]
     1 5562 A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 5564 A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1150 5566 20 4B 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1151 5569					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: macros.inc]
     1 5569 A2 03			LDX	#4-1
     2 556B BD 00 04 9D D2 55 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 5572 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1152 5574 18 AD D2 55 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1153 5587 AD D4 55				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1154 558A 69 00				ADC	#0
  1155 558C 8D D4 55				STA	SYS_INFO_LBA+2
  1156 558F AD D5 55				LDA	SYS_INFO_LBA+3
  1157 5592 69 00				ADC	#0
  1158 5594 8D D5 55				STA	SYS_INFO_LBA+3
  1159 						
  1160 5597 20 2C 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1161 559A					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: macros.inc]
     1 559A A2 D2			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 559C A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1162 559E 20 4B 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1163 55A1					PRSTR	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTR [Source: macros.inc]
     1 55A1 A2 DA			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 55A3 A0 55			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 55A5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1164 55A8					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: macros.inc]
     1 55A8 AD EF 5A			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 55AB 20 91 E0			JSR	HEXOUT
     3 55AE AD EE 5A			LDA	SIS_BUFF+$01EC+2
     4 55B1 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 55B4 AD ED 5A			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 55B7 20 91 E0			JSR	HEXOUT
     3 55BA AD EC 5A			LDA	SIS_BUFF+$01EC
     4 55BD 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1165 55C0 20 5A E0				JSR	CROUT
  1166 55C3			FREE_KB_UPDATE	MVAX	4 SIS_BUFF+$01E8 FREE_KB	
Macro: MVAX [Source: macros.inc]
     1 55C3 A2 03			LDX	#4-1
     2 55C5 BD E8 5A 9D D6 55 + lp	MVA	SIS_BUFF+$01E8,X FREE_KB,X-
     3 55CC 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1167 55CE 20 35 55				JSR	CL2KB				; Convert #clusters to KB and store in FREE_KB
  1168 55D1 60					RTS
  1169 						
  1170 55D2 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1171 55D6 00 00 00 00		FREE_KB		.dword	$00000000
  1172 55DA 46 69 72 73 74 20 + TXT_FFREE_CLST	.by	'First free cluster:$' $00
  1173 55EF 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1174 55F9 00			SIS_CNT		.byte	$00				; SIS counter, counts #clusters freed or allocated
  1175
  1176 				; Write Info back to System Information Sector **************************************
  1177 55FA			SIS_ADD		PRSTR	SISP
Macro: PRSTR [Source: macros.inc]
     1 55FA A2 5E			LDX	<SISP				; MADS makes this immediate
     2 55FC A0 56			LDY	>SISP
Source: boot_sys_sh.asm
     2 55FE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1178 5601 AD E8 5A 18 6D F9 + 		ADB	SIS_BUFF+$01E8 SIS_CNT		; add SIS_CNT to #free clusters in SIS-buffer
  1179 560B 90 03				SCC					; 'skip if C is clear' macro
  1180 560D EE E9 5A				INC	SIS_BUFF+$01E9
  1181 5610 90 03				SCC	
  1182 5612 EE EA 5A				INC	SIS_BUFF+$01EA
  1183 5615 90 03				SCC	
  1184 5617 EE EB 5A				INC	SIS_BUFF+$01EB
  1185 561A AD F9 55		SIS_WRITE	LDA	SIS_CNT				; Print SIS_CNT
  1186 561D 20 91 E0				JSR	HEXOUT
  1187 5620 20 5A E0				JSR	CROUT
  1188 5623					MVAX	4 FREE_CLUSTER SIS_BUFF+$01EC	; SIS First free cluster = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 5623 A2 03			LDX	#4-1
     2 5625 BD 20 18 9D EC 5A + lp	MVA	FREE_CLUSTER,X SIS_BUFF+$01EC,X-
     3 562C 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1189 562E 20 2C 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_WRITE command
  1190 5631					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: macros.inc]
     1 5631 A2 D2			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5633 A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1191 5635 20 1D 42				JSR 	DEV_WR_LBLK           		; Write SIS to disk
  1192 5638 4C C3 55				JMP	FREE_KB_UPDATE			; Update FREE_KB and return
  1193
  1194 563B			SIS_DEL		PRSTR	SISM
Macro: PRSTR [Source: macros.inc]
     1 563B A2 63			LDX	<SISM				; MADS makes this immediate
     2 563D A0 56			LDY	>SISM
Source: boot_sys_sh.asm
     2 563F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1195 5642 AD E8 5A 38 ED F9 + 		SBB	SIS_BUFF+$01E8 SIS_CNT		; subtract SIS_CNT from #free clusters in SIS-buffer
  1196 564C B0 03				SCS					; 'skip if C is set' macro
  1197 564E CE E9 5A				DEC	SIS_BUFF+$01E9
  1198 5651 B0 03				SCS
  1199 5653 CE EA 5A				DEC	SIS_BUFF+$01EA
  1200 5656 B0 03				SCS
  1201 5658 CE EB 5A				DEC	SIS_BUFF+$01EB
  1202 565B 4C 1A 56				JMP	SIS_WRITE			; write back to disk
  1203 						
  1204 565E 53 49 53 2B 00	SISP		.by	'SIS+' $00
  1205 5663 53 49 53 2D 00	SISM		.by	'SIS-' $00
  1206 						
  1207 				; **** Data Area ***************************************************************
  1208 				; ******************************************************************************
  1209
  1210 				; String Data Area *************************************************************
  1211 5668 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1212 5679 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1213 568A 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1214 568F 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1215 569F 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1216 56AA 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)   ' $00
  1217 56B5 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1218 56BD 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1219 56CE 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1220 56DE 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1221 56EE 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1222 56FF 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1223 5711 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1224 5724 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1225 573F 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1226 574D 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1227
  1228 				; ############################################
  1229 575B 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1230 5763 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1231 5768 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1232 5773 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1233 577E 43 4F 4D		EXT_COM         .by    'COM'
  1234 5781 45 58 45		EXT_EXE		.by    'EXE'
  1235 5784 42 41 53		EXT_BAS		.by    'BAS'
  1236 				                
  1237 				; Command Table ****************************************************************
  1238 5787 42 A6 57		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1239 578A 43 BB 57				dta	'C' , a(CMD_CD)		
  1240 578D 44 C5 57				dta	'D' , a(CMD_DIR)		
  1241 5790 45 D0 57				dta	'E' , a(CMD_ECHO)		
  1242 5793 47 D7 57				dta	'G' , a(CMD_GOTO)		
  1243 5796 49 DE 57				dta	'I' , a(CMD_IF)		
  1244 5799 4D E3 57				dta	'M' , a(CMD_MKDIR)		
  1245 579C 50 F0 57				dta	'P' , a(CMD_PAUSE)		
  1246 579F 52 F8 57				dta	'R' , a(CMD_REM)
  1247 57A2 56 FE 57				dta	'V' , a(CMD_VER)
  1248 57A5 00					.byte 	$00
  1249
  1250 57A6 05 41 53 49 43 29 + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1251 57AD 05 4C 4F 41 44 4D + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1252 57B4 04 52 55 4E 38 54 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1253 57BB 02 44 AA 52		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1254 57BF 03 4C 53 E0 53 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1255 57C5 03 49 52 43 50	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1256 57CA 03 45 4C 9B 53 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1257 57D0 04 43 48 4F F3 53 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1258 57D7 04 4F 54 4F 02 54 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1259 57DE 02 46 03 54 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1260 57E3 05 4B 44 49 52 C8 + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1261 57EA 03 4F 4E F8 54 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1262 57F0 05 41 55 53 45 E3 + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1263 57F8 03 45 4D 19 54 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
  1264 57FE 03 45 52 F0 54 00	CMD_VER		dta	3, c'ER'  , a(SH_VER)    , $00  ;
    85 				                
    86 				; End Of Program Marker ********************************************************
    87 5804 00			BOOT_SYS_END    BRK
    88 5805					ORG ((*/256)+1)*256		; next free page
    89 = 5900			SIS_BUFF	.ds 	512			; SIS Buffer 
    90 = 5B00			FILE_BUFF	.ds	512			; .exe file buffer
    91 						END
