mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Micro (Disk) Operating System for 6502 Microprocessors
     3 				;
     4 				; M/OS-65 System I, Version 0.2.3 by Joerg Walke, CF-IDE updates by Emile
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; M/OS-65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0032			VERPSUB    	EQU     '2'    		; primary sub version
    24 = 0033			VERSSUB		EQU	'3'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; ******************************************************************************
    33 						OPT h- ; do not add file header
    34 						OPT f+ ; save as single block
    35
    36 				;------------------------------------------------------------------------------------------------
    37 				; TERMINOLOGY AND FORMULAS USED:
    38 				; 
    39 				; Sector                : A sector consists of 512 bytes.
    40 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    41 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    42 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    43 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    44 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    45 				; 
    46 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    47 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    48 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    49 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    50 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    51 				;------------------------------------------------------------------------------------------------
    52
    53 = 0001			DBG_PRINT	EQU	1			; Set to 1 for debug print-outs
    54
    55 						ICL "macros.inc"		; boot.sys macro definitions for MADS
Source: macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTR	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    88 					LDX	#:n-1
    89 				lp	MVA	:src,X :dst,X-
    90 					BPL	lp
    91 				.endm
    92 					
    93 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
    94 					LDY	#:n-1
    95 				lp	MVA	:src,Y :dst,Y-
    96 					BPL	lp
    97 				.endm
    98
    99 				; Macros used for printing a cluster nr, which consists of 2 words
   100 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   101 						LDA	(:c),Y
   102 					ift :0>1	; st also given?
   103 						STA	:st
   104 					eif	
   105 						JSR	HEXOUT			; changes Y!
   106 				.endm		
   107
   108 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   109 						LDY	#:indx+1		; Print MSB of word
   110 					ift :0>2	; stor also given?	
   111 						PRCLB	:curr_dir :stor+1
   112 					els	
   113 						PRCLB	:curr_dir
   114 					eif
   115 						LDY	#:indx			; Print LSB of word
   116 					ift :0>2	; stor also given?	
   117 						PRCLB	:curr_dir :stor
   118 					els	
   119 						PRCLB	:curr_dir
   120 					eif
   121 				.endm
   122
   123 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   124 					ift :b2>7
   125 						ERT "Only bits 7-0 allowed"
   126 					els
   127 						LDA	:b1
   128 						AND	#(1 << :b2)
   129 						BEQ	:lbl1
   130 					eif
   131 				.endm
   132 					
   133 				; ----------------------------------------------
   134 				; Compare + Branch Macros
   135 				; ----------------------------------------------
   136 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   137 						CMP	:b1
   138 						BEQ	:lbl
   139 				.endm		; A is now not equal to b1
   140 					
   141 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   142 						CMP	:b1
   143 						BNE	:lbl
   144 				.endm		; A is now equal to b1
   145
   146 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   147 				CMP.CC	.macro ' '	b1 lbl
   148 						CMP	:b1			; 
   149 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   150 				.endm		; C is now 1 (A-b1 is >= 0)
   151
   152 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   153 				CMP.CS	.macro ' '	b1 lbl
   154 						CMP	:b1			; 
   155 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   156 				.endm		; C is now 0 (A-b1 is < 0)
   157
   158 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   159 						CPX	:b1
   160 						BEQ	:lbl
   161 				.endm		; X is now not equal to b1
   162 					
   163 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   164 						CPX	:b1
   165 						BNE	:lbl
   166 				.endm		; X is now equal to b1
   167
   168 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   169 				CPX.CC	.macro ' '	b1 lbl
   170 						CPX	:b1			; 
   171 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   172 				.endm		; C is now 1 (X-b1 is >= 0)
   173
   174 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   175 				CPX.CS	.macro ' '	b1 lbl
   176 						CPX	:b1			; 
   177 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   178 				.endm		; C is now 0 (X-b1 is < 0)
   179
   180 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   181 						CPY	:b1
   182 						BEQ	:lbl
   183 				.endm		; Y is now not equal to b1
   184 					
   185 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   186 						CPY	:b1
   187 						BNE	:lbl
   188 				.endm		; Y is now equal to b1
   189
   190 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   191 				CPY.CC	.macro ' '	b1 lbl
   192 						CPY	:b1			; 
   193 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   194 				.endm		; C is now 1 (Y-b1 is >= 0)
   195
   196 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   197 				CPY.CS	.macro ' '	b1 lbl
   198 						CPY	:b1			; 
   199 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   200 				.endm		; C is now 0 (Y-b1 is < 0)
   201
   202 				; ----------------------------------------------
   203 				; Increment/Decrement + Branch Macros
   204 				; ----------------------------------------------
   205 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   206 						DEC	:b1
   207 						BEQ	:lbl
   208 				.endm
   209
   210 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   211 						DEC	:b1
   212 						BNE	:lbl
   213 				.endm
   214
   215 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   216 						INC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   221 						INC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				; ----------------------------------------------
   226 				DEX.NE	.macro 	lbl				; DEX + BNE
   227 						DEX
   228 						BNE	:lbl
   229 				.endm
   230
   231 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   232 						DEX
   233 						BEQ	:lbl
   234 				.endm
   235
   236 				DEX.PL	.macro 	lbl				; DEX + BPL 
   237 						DEX
   238 						BPL	:lbl
   239 				.endm
   240
   241 				DEX.MI	.macro 	lbl				; DEX + BMI
   242 						DEX
   243 						BMI	:lbl
   244 				.endm
   245
   246 				DEX.CC	.macro 	lbl				; DEX + BCC 
   247 						DEX
   248 						BCC	:lbl
   249 				.endm
   250
   251 				DEX.CS	.macro 	lbl				; DEX + BCS
   252 						DEX
   253 						BCS	:lbl
   254 				.endm
   255
   256 				; ----------------------------------------------
   257 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   258 						DEY
   259 						BEQ	:lbl
   260 				.endm
   261
   262 				DEY.NE	.macro 	lbl				; DEY + BNE
   263 						DEY
   264 						BNE	:lbl
   265 				.endm
   266
   267 				DEY.PL	.macro 	lbl				; DEY + BPL 
   268 						DEY
   269 						BPL	:lbl
   270 				.endm
   271
   272 				DEY.MI	.macro 	lbl				; DEY + BMI
   273 						DEY
   274 						BMI	:lbl
   275 				.endm
   276
   277 				DEY.CC	.macro 	lbl				; DEY + BCC 
   278 						DEY
   279 						BCC	:lbl
   280 				.endm
   281
   282 				DEY.CS	.macro 	lbl				; DEY + BCS
   283 						DEY
   284 						BCS	:lbl
   285 				.endm
   286 				; ----------------------------------------------
   287
   288 				; ----------------------------------------------
   289 				; LOAD/STORE + Branch Macros
   290 				; ----------------------------------------------
   291 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   292 						LDA	:b1
   293 						BEQ	:lbl
   294 				.endm
   295
   296 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   297 						LDA	:b1
   298 						BNE	:lbl
   299 				.endm
   300
   301 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   302 						STA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   307 						STA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				; ----------------------------------------------
   312 				; AND/OR + Branch Macros
   313 				; ----------------------------------------------
   314 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   315 					ift :0>2	; LDA + AND + BEQ	
   316 						LDA	:p1
   317 						AND	:p2
   318 						BEQ	:p3
   319 					els		; AND + BEQ
   320 						AND	:p1
   321 						BEQ	:p2
   322 					eif
   323 				.endm
   324
   325 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   326 					ift :0>2	; LDA + AND + BNE	
   327 						LDA	:p1
   328 						AND	:p2
   329 						BNE	:p3
   330 					els		; AND + BNE
   331 						AND	:p1
   332 						BNE	:p2
   333 					eif
   334 				.endm
    56 						ICL "defines.inc"		; boot.sys defines
Source: defines.inc
     1 				;-------------------------------------------------
     2 				; Register Definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				; Global Constants and Variables ***********************************************
     8 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
     9 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    10 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    11 = B000			LAB_COLD	=	$B000		; BASIC cold START
    12
    13 = 00A0			ZP_BASE         EQU     $A0		; Reserved for DOS and boot.sys
    14 = 00A0			CURR_CLUSTER    EQU     ZP_BASE         ; $A0..$A3 (32 bit) - current addressed cluster
    15 = 00A4			CURR_FAT_BLK    EQU     ZP_BASE+4       ; $A4..$A7 (32 bit) - current loaded FAT LBA
    16 = 00A8			CURR_DIR_ENTRY  EQU     ZP_BASE+8       ; $A8..$A9 (16 bit) - pointer to current addressed directory entry
    17 = 00AA			MASK            EQU     ZP_BASE+10	; $AA Mask for FAT table
    18 = 00AB			BCNT            EQU     ZP_BASE+11      ; $AB Block Counter
    19 = 00AC			NCNT            EQU     ZP_BASE+12	; $AC
    20 = 00AD			SCNT            EQU     ZP_BASE+13	; $AD Sector counter within a cluster
    21 = 00AE			RES             EQU     ZP_BASE+14	; $AE
    22
    23 = 0078			ssptr_l		EQU	$78		; BASIC filename pointer LSB
    24 = 0079			ssptr_h		EQU	$79		; BASIC filename pointer MSB
    25
    26 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register (same as BIOS)
    27 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register (same as BIOS)
    28 = 00DC			BLKBUF		EQU	$DC
    29 = 00DC			BLKBUFL		EQU	$DC             ; Pointer to block buffer, same in BIOS
    30 = 00DD			BLKBUFH		EQU	$DD
    31
    32 = 00E8			STOL      	EQU   	$E8     	; Store address Low, same in BIOS
    33 = 00E9			STOH      	EQU   	$E9     	; Store address High
    34 = 00EA			PSTR            EQU     $EA		; 2-byte ACIA output pointer, same in BIOS
    35 = 00EE			PSAV            EQU     $EE             ; Saved Partition Number in ASCII, same in BIOS
    36
    37 = 00F8			NUM32      	EQU   	$F8     	; low 32 bit number byte
    38 = 00FC			SUM32           EQU     $FC             ; low 32 bit number byte
    39
    40 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400 (same as BIOS)
    41
    42 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
    43 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
    44 = 180A			RETURN_VECT     EQU     $180A           ; return vector to monitor caller in V1.2.1 (was $0001 in V1.2.0)
    45
    46 = 1810			NEXTINDEX       EQU     $1810		; command index
    47 = 1811			TERM_CHAR       EQU     $1811
    48 = 1812			F_ATTRIBS       EQU     $1812
    49 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
    50 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
    51 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
    52 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
    53 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
    54 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
    55 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
    56 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
    57 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
    58 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
    59
    60 				; External Routines ************************************************************
    61
    62 = E003			MON_WARM_START  EQU     $E003
    63
    64 = E052			COUT            EQU     $E052
    65 = E05A			CROUT           EQU     $E05A
    66 = E05E			SPCOUT          EQU     $E05E
    67 = E047			CIN             EQU     $E047
    68 = E062			STRIN           EQU     $E062
    69 = E083			STROUT          EQU     $E083
    70 = E085			WRSTR           EQU     $E085
    71 = E091			HEXOUT          EQU     $E091
    72 = E09A			HEXDIG          EQU     $E09A
    73 = E0BD			DEC2STR         EQU     $E0BD
    74 = E0B5			CLRSCRN         EQU     $E0B5
    75 = E0BA			CMDDEV          EQU     $E0BA
    76 = E1AA			OPEN_DEVICE     EQU     $E1AA
    77 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    78 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    79 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    80 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    81
    82 				; Tables and Buffers ***********************************************************
    83 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
    84 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
    85 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
    86
    87 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor
    88 = 0420			FILE_TABLE      EQU     CURR_VOLUME+$20  	; File Descriptor Table
    89 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices
    90 = 0600			BLOCK_BUFF      EQU     $0600           	; Data Block Buffer
    91
    92 = 5530			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
    93
    94 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
    95 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
    96
    97 				; Device IDs *******************************************************************
    98 = 0000			NULL_ID		EQU	$00             	; the NULL device
    99 = 0022			FDD1_ID         EQU     $22             	; Floppy drive 1 device ID
   100 = 0023			FDD2_ID         EQU     $23             	; Floppy drive 2 device ID
   101 = 0024			SDC_ID		EQU     $24             	; SD-Card device ID
   102 = 0025			HDD1_ID		EQU     $25             	; CF-Card device ID
   103
   104 				; FAT Types ********************************************************************
   105 = 0002			FAT12_Type      EQU     $02
   106 = 0001			FAT16_Type      EQU     $01
   107 = 0000			FAT32_Type      EQU     $00
   108
   109 				; Device Driver Commands *******************************************************
   110 = 0022			CMD_READ	EQU	34              	; Read data block from device
   111 = 0023			CMD_WRITE	EQU	35              	; Write data block to device
   112 = 0025			CMD_READ_BUF	EQU	37              	; Read data block from device to standard buffer
   113 = 0026			CMD_WRITE_BUF	EQU	38              	; Write data block to device from standard buffer
   114
   115 				; Miscellaneous Constants ******************************************************
   116 = 000D			CR              EQU     $0D             	; Carriage Return ASCII Code
   117 = 0020			SPC             EQU     $20             	; Space ASCII Code
   118 = 005C			BSLASH          EQU     '\'             	; Backslash ASCII Code
   119 = 002F			FSLASH		EQU     '/'             	; Forward slash ASCII Code
   120 = 002E			DOT             EQU     '.'             	; Dot ASCII Code
   121 = 003A			COLON           EQU     ':'             	; Colon ASCII Code
   122 = 002C			COMMA           EQU     ','             	; Comma ASCII Code
   123 = 002D			MINUS           EQU     '-'             	; Minus ASCII Code
   124 = 005F			ULINE           EQU     '_'             	; Underline ASCII Code
   125
   126 				; Interchangeable Chars ********************************************************
   127 = 003E			PROMPT          EQU     '>'             	; Command Line Prompt Char
   128 = 002E			NUM_SEP         EQU     DOT	           	; Thousand Seperator Char
   129 = 005C			PATH_SEP        EQU     BSLASH          	; Path Seperator Char
   130 = 002F			OPT_SEP         EQU     FSLASH           	; Option Prefix Char
   131
   132 				; File Attributes **************************************************************
   133 = 0001			FA_READONLY     EQU     $01             	; file is read only
   134 = 0002			FA_HIDDEN       EQU     $02             	; file is hidden
   135 = 0004			FA_SYSTEM       EQU     $04             	; file is a system file
   136 = 0008			FA_LABEL        EQU     $08             	; file is a volume label
   137 = 0010			FA_DIRECTORY    EQU     $10             	; file is a directory
   138 = 0020			FA_ARCHIVE      EQU     $20             	; file is modified
   139 = 0040			FA_RESERVED1    EQU     $40
   140 = 0080			FA_LINK         EQU     $80             	; file is a link
   141
   142 				; Device Attributes ************************************************************
   143 = 0080			DA_DIRTY        EQU     $80             ; current FAT block is modified
   144
   145 				; Current Volume Descriptor (32 Bytes) *****************************************
   146 				; The BOOT routine in BIOS has already loaded the MBR into $0600, laoded the
   147 				; Volume-ID sector into $0400 and did set (most of) these variables.
   148 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   149 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   150 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   151 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte
   152 										;           or Partition Number in ASCII if harddisk
   153 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   154 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   155 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   156 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   157 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   158 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   159 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   160 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   161 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   162
   163 = 0420			D_SUBDIR_NAME	EQU	FILE_TABLE+$00		; 11 Bytes - Name of entire path (root dir is \)
   164 					
   165 				; Directory Descriptor (32 Bytes) **********************************************
   166
   167 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   168 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   169 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   170 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   171 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   172 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   173 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   174 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   175 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   176 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   177 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   178
   179
    57 						
    58 				.if	USE_XMODEM = 1
    59 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    60 				.endif
    61
    62 				; ******************************************************************************
    63 				; Start of 1st Block of BOOT.SYS ***********************************************
    64 				; ******************************************************************************
    65 = 4000			LOAD_ADDRESS	EQU	$4000
    66 						ORG	LOAD_ADDRESS		; the program start address
    67 				PROG_START					; Program Start Address
    68 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				; V0.1: 22-05-25, Emile first version
    11 				;-------------------------------------------------------------------------------
    12
    13 				; subtract two clusters from START_CLUSTER address *****************************
    14 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    15 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    16 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    17 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    18 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    19 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    20 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    21 4012 A2 01		                LDX     #$01
    22 4014 A0 03		                LDY     #$03
    23 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    24 4019 E9 00		                SBC     #$00
    25 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    26 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    27 				                
    28 				; initialize current FAT block value with 0 ************************************
    29 4022 84 A4		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    30 4024 84 A5		                STY     CURR_FAT_BLK+1
    31 4026 84 A6		                STY     CURR_FAT_BLK+2
    32 4028 84 A7		                STY     CURR_FAT_BLK+3
    33 				                
    34 				; set first cluster of BOOT.SYS as the current cluster *************************
    35 402A A0 15		INIT3           LDY     #$15
    36 402C A2 03		                LDX     #$03
    37 402E 20 74 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    38 4031 A0 1B		                LDY     #$1B
    39 4033 20 74 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    40 				                
    41 				; calculate BOOTS.SYS file size in blocks **************************************
    42 4036 A9 54		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    43 4038 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    44 403B 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    45 403C 85 AB		                STA     BCNT                	; store result into block counter
    46 403E			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: macros.inc]
     1 403E A9 AC				LDA	#<BOOT_SYS_END
     2 4040 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    47 4042 E6 AB		                INC     BCNT                	; some bytes are left, so increment block counter
    48 				                
    49 				; load all blocks of BOOT.SYS file into memory *********************************
    50 4044			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 4044 C6 AB				DEC	BCNT
     2 4046 F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    51 4048 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    52 404D			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: macros.inc]
     1 404D C6 AD				DEC	SCNT
     2 404F F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    53 4051 20 81 41		                JSR     INC_32              	; no, increment block address
    54 4054			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: macros.inc]
     1 4054 A2 F8			LDX	<NUM32				; MADS makes this immediate
     2 4056 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    55 4058 20 4B 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    56 405B			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 405B C6 AB				DEC	BCNT
     2 405D F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    57 405F D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    58
    59 				; next cluster needs to be loaded considering the volume FAT type **************
    60 4061 20 7E 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    61 4064 B0 0B		                BCS     OS_START            	; if EOF then start OS
    62 						
    63 4066 20 F8 40		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    64 4069 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    65 406E 4C 54 40		                JMP     LOAD_BLK            	; load first block of cluster
    66 				                
    67 4071 4C 22 42		OS_START        JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 4074 20 77 40		SET_WORD        JSR     SET_BYTE
    74 4077 B1 EA 88 95 A0 CA	SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 407D 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 407E			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 407E A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 4080 A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 4082 20 61 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 4085			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: macros.inc]
     1 4085 AD 0A 04				LDA	D_FAT_TYPE
     2 4088 F0 14				BEQ	FAT32
Source: boot_sys_block1.asm
    85 408A					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: macros.inc]
     1 408A C9 01				CMP	#FAT16_TYPE
     2 408C F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 408E 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 408F A6 A1		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 4091 20 83 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 4094 20 1D 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 4097 A5 A0		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 4099 A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 409B 4C BE 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 409E			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: macros.inc]
     1 409E A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40A0 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40A2 20 5B 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40A5 A2 00 86 FF				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40A9 A0 03		                LDY     #$03
   106 40AB A5 A0		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40AD 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40AE 48			                PHA                         	; save entry index to stack
   109 40AF 36 FC E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40B2			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 40B2 88					DEY
     2 40B3 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40B5 20 8F 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40B8 20 1D 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40BB 68			                PLA                         	; restore entry index
   116 40BC A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40BE			READ_FAT_ENTRY  
   127 40BE A0 FF 84 AA				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40C2 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40C3 A8			                TAY                         	; store entry index into Y
   130 40C4 86 AC		                STX     NCNT                	; store length of entry
   131 40C6 A2 00 86 AE		                MVX     #$00 RES		;
   132 40CA 20 EA 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40CD 95 A0		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40CF 08			                PHP                         	; save carry flag
   135 40D0			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: macros.inc]
     1 40D0 E0 03				CPX	#$03
     2 40D2 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40D4 A2 0F 86 AA		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40D8			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: macros.inc]
     1 40D8 C5 AA				CMP	MASK
     2 40DA D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40DC 85 AE		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40DE 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40DF C8			                INY
   141 40E0 E8			                INX
   142 40E1			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 40E1 C6 AC				DEC	NCNT
     2 40E3 D0 E5				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40E5 A5 AE		                LDA     RES
   144 40E7 C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40E9 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40EA			READ_ENTRY_BYTE AND.NE  #$01 CURR_CLUSTER+1 RD_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 40EA A9 01				LDA	#$01
     3 40EC 25 A1				AND	CURR_CLUSTER+1
     4 40EE D0 04				BNE	RD_UPPER_PAGE
Source: boot_sys_block1.asm
   152 40F0 B9 00 06		                LDA     BLOCK_BUFF,Y        			; read entry byte from lower half of block buffer
   153 40F3 60			                RTS			    			; return
   154 40F4 B9 00 07		RD_UPPER_PAGE   LDA     BLOCK_BUFF+256,Y    			; read entry byte from upper half of block buffer
   155 40F7 60			                RTS			    			; return
   156 				                
   157 				; **** Calculate LBA From Given Cluster Address ********************************
   158 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   159 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   160 				;
   161 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   162 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   163 				; ******************************************************************************
   164 40F8			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: macros.inc]
     1 40F8 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 40FA A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   165 40FC 20 61 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   166 40FF AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   167 4102 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   168 4103 F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   169 						
   170 4105 A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   171 4107 A0 04		                LDY     #$04
   172 4109 18			                CLC
   173 410A 36 F8 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   174 410D			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 410D 88					DEY
     2 410E D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   175 						
   176 4110 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   177 4111 D0 F2		                BNE     LOOP1		     	; 
   178 						
   179 4113			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: macros.inc]
     1 4113 A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 4115 A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   180 4117 20 5B 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   181 411A 4C 8F 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   182
   183 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   184 				; Input: NUM32: LBA number of FAT sector to load
   185 				; ******************************************************************************
   186 411D A2 03		LOAD_FAT_BLK    LDX     #$03
   187 411F 86 AE		                STX     RES                 	; initialize byte counter
   188 				                
   189 				; check if current FAT block and last loaded FAT block are identical ***********
   190 4121 B5 F8		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   191 4123			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: macros.inc]
     1 4123 D5 A4				CMP	CURR_FAT_BLK,X
     2 4125 D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   192 						
   193 4127 C6 AE		                DEC     RES                 	; if equal decrement number of unequal bytes
   194 4129 95 A4 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   195 412C 10 F3		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   196 						
   197 412E A5 AE		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   198 4130 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   199 				                
   200 4132			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: macros.inc]
     1 4132 A5 DC			LDA	BLKBUF
     2 4134 48				PHA
     3 4135 A5 DD			LDA	BLKBUF+1
     4 4137 48				PHA
Source: boot_sys_block1.asm
   201 4138			                LDXYI   NUM32
Macro: LDXYI [Source: macros.inc]
     1 4138 A2 F8			LDX	<NUM32				; MADS makes this immediate
     2 413A A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   202 413C 20 46 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($600)
   203 413F					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: macros.inc]
     1 413F 68				PLA
     2 4140 85 DD			STA	BLKBUF+1
     3 4142 68				PLA
     4 4143 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   204 4145 60			LOAD_FAT_END    RTS
   205 				                
   206 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   207 				; Input: [X,Y] points to 32-bit LBA
   208 				; ******************************************************************************
   209 4146 A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   210 4148 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   211 				                
   212 				; **** Read Logical Block ******************************************************
   213 				; Input: [X,Y] points to 32-bit LBA
   214 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   215 				; ******************************************************************************
   216 414B A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   217 414D 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   218 				                
   219 				; Arithmetic Functions *********************************************************
   220 				; ******************************************************************************
   221
   222 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   223 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   224 				; ******************************************************************************
   225 4150			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: macros.inc]
     1 4150 86 F8			STX	NUM32
     2 4152 84 F9			STY	NUM32+1
Source: boot_sys_block1.asm
   226 4154 A2 00 86 FA 86 FB			MWX	#0 NUM32+2		; Zero upper 16-bits
   227 415A 60			                RTS			   	; return
   228 				                
   229 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   230 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   231 				; ******************************************************************************
   232 415B 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   233 415D A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   234 415F D0 04		                BNE     LOAD_32_1	   	; branch always
   235
   236 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   237 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   238 				; ******************************************************************************
   239 4161 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   240 4163 A2 03		                LDX     #$03
   241 4165 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   242 4167 A0 03		                LDY     #$03
   243 4169 B1 E8 95 F8 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   244 416E			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 416E 88					DEY
     2 416F 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   245 4171 60			                RTS			   	; return
   246 				                
   247 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   248 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   249 				; ******************************************************************************
   250 4172			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: macros.inc]
     1 4172 86 E8			STX	STOL
     2 4174 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   251 4176 A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   252 4178 B9 F8 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   253 417E 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   254 4180 60			                RTS			   	; return
   255
   256 				; **** Increment a 32 Bit Value ************************************************
   257 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   258 				; ******************************************************************************
   259 4181 A2 01		INC_32          LDX     #$01
   260
   261 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   262 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   263 				; ******************************************************************************
   264 4183 A0 00		ADD_32_8        LDY     #$00
   265
   266 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   267 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   268 				; ******************************************************************************
   269 4185			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: macros.inc]
     1 4185 86 FC			STX	SUM32
     2 4187 84 FD			STY	SUM32+1
Source: boot_sys_block1.asm
   270 4189 A2 00 86 FE 86 FF			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   271
   272 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   273 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   274 				; ******************************************************************************
   275 418F 18			ADD_32_32       CLC			   	; clear carry flag
   276 4190 A2 00		                LDX     #$00		   	; start with byte 0
   277 4192 08			                PHP			   	; save carry flag
   278 4193 28			ADD_LOOP        PLP			   	; get carry flag back
   279 4194 B5 FC		                LDA     SUM32,X		   	; Get SUM32 byte
   280 4196 75 F8 95 F8		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   281 419A 08			                PHP			   	; save carry flag
   282 419B E8			                INX			   	; next byte
   283 419C			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: macros.inc]
     1 419C E0 04				CPX	#$04
     2 419E D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   284 41A0 28			                PLP			   	; restore stack
   285 41A1 60			                RTS			   	; return
    69 				               
    70 				; ******************************************************************************
    71 				; Start of remaining BOOT.SYS blocks *******************************************
    72 				; ******************************************************************************
    73 41A2					ORG     LOAD_ADDRESS + $0200
    74 4200			BLOCK_2
    75 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; NUM32 shl X
    10 				; ******************************************************************************
    11 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: macros.inc]
     1 4200 06 F8			ASL     NUM32		  		; SHL with C=0
     2 4202 26 F9		        ROL     NUM32+1		  
     3 4204 26 FA		        ROL     NUM32+2
     4 4206 26 FB		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    12 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    13 420B 60			                RTS			  	; return
    14
    15 				; ******************************************************************************
    16 				; NUM32 shr X
    17 				; ******************************************************************************
    18 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: macros.inc]
     1 420C 46 FB			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 FA		        ROR     NUM32+2
     3 4210 66 F9		        ROR     NUM32+1
     4 4212 66 F8		        ROR     NUM32
Source: boot_sys_os.asm
    19 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    20 4217 60			                RTS			  	; return
    21 				                
    22 				; **** Write Logical Block From Standard Buffer ********************************
    23 				; Input: [X,Y] points to 32-bit LBA
    24 4218 A9 26		DEV_WR_LBLK_BUF  LDA    #CMD_WRITE_BUF	  	; Call Device-driver Write routine
    25 421A 4C BA E0		                 JMP    CMDDEV
    26
    27 				; **** Write Logical Block *****************************************************
    28 				; Input: [X,Y] points to 32-bit destination LBA
    29 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
    30 421D A9 23		DEV_WR_LBLK      LDA     #CMD_WRITE		; Call Device-driver Write routine
    31 421F 4C BA E0		                 JMP     CMDDEV
    32
    33 				; ******************************************************************************
    34 				; *                               OS Entry Point                               *
    35 				; ******************************************************************************
    36 4222			OS_MAIN         PRSTR	MSG_BOOT			; Print boot-message
Macro: PRSTR [Source: macros.inc]
     1 4222 A2 8C			LDX	<MSG_BOOT				; MADS makes this immediate
     2 4224 A0 49			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 4226 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    37 4229 20 9A 47		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    38 				                
    39 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    40 422C A9 98 8D 06 18 A9 + 		MWA	#CFC_LOAD CF_LOAD_VEC		; macro CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    41 4236 A9 D8 8D 08 18 A9 + 		MWA	#CFC_SAVE CF_SAVE_VEC		; macro CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    42 4240 A9 9E 8D 0A 18 A9 + 		MWA	#OS_SHELL_ENTRY RETURN_VECT	; Return-vector for Monitor and BASIC
    43 424A A2 00 86 01 86 02			MWX	#0 Wrmjpl			; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    44 				                
    45 				; Clear Mount Table ************************************************************
    46 4250 18			                CLC
    47 4251 A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    48 4256 8A					TXA                          		; index to mount table into A
    49 4257 69 20		                ADC     #$20                 		; set to next entry
    50 4259 AA			                TAX
    51 425A 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    52 				                
    53 				; Set Boot Device As Current Device ********************************************
    54 425C A2 00		                LDX     #$00		     	; X=0
    55 425E A0 00		                LDY     #$00                 	; set index to mount table = 0
    56 4260 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    57 4263			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: macros.inc]
     1 4263 C9 22				CMP	#FDD1_ID
     2 4265 F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    58 4267 E8			                INX		     	     	; X=2
    59 4268 A0 20		                LDY     #$20                 	; set index to mount table = 32
    60 426A			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: macros.inc]
     1 426A C9 23				CMP	#FDD2_ID
     2 426C F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    61 426E E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    62 426F A0 40		                LDY     #$40                 	; set index to mount table = 64
    63 4271 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    64
    65 				; Add Boot Device To Mount Table ***********************************************
    66 4274 A2 00		                LDX     #$00
    67 4276 BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    68 427E			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: macros.inc]
     1 427E E0 20				CPX	#32
     2 4280 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    69 4282 A9 F8		                LDA     #$F8
    70 4284			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: macros.inc]
     1 4284 CD 09 04				CMP	D_MEDIUM_DESCR
     2 4287 D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    71 4289 A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    72 428E			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: macros.inc]
     1 428E AD 0A 04				LDA	D_FAT_TYPE
     2 4291 F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    73 4293 A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    74 4295			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: macros.inc]
     1 4295 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 4298 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    75 429B					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 429B CA					DEX
     2 429C D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    76 				                
    77 				; TODO: ADD MORE DEVICES #######################################################
    78
    79 				; **** Shell Entry Point *******************************************************
    80 				; ******************************************************************************
    81 429E 4C F2 49		OS_SHELL_ENTRY  JMP     SH_CMD_PROMPT
    82
    83 				; **** Read First Block Of Actual Directory ************************************
    84 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    85 				; ******************************************************************************
    86 42A1			OS_FIRST_DIR_BLK
    87 42A1			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 42A1 AD 0A 04				LDA	D_FAT_TYPE
     2 42A4 F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    88 42A6 20 89 47		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    89 42A9 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    90
    91 42AB					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: macros.inc]
     1 42AB A2 03			LDX	#4-1
     2 42AD BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42B4 10 F7			BPL	lp
Source: boot_sys_os.asm
    92 42B6 AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    93 42B9 D0 17		                BNE     SET_NUM_BLOCKS       		; branch always
    94
    95 42BB			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: macros.inc]
     1 42BB A2 03			LDX	#4-1
     2 42BD BD 04 04 95 A0 CA	lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C3 10 F8			BPL	lp
Source: boot_sys_os.asm
    96 42C5 20 F8 40		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
    97 42C8			                LDXYI   CURR_DIR_BLK
Macro: LDXYI [Source: macros.inc]
     1 42C8 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42CA A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
    98 42CC 20 72 41		                JSR     STORE_32             		; and save result as current directory block
    99 42CF AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
   100 42D2 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
   101
   102 				; **** Load Directory Block ****************************************************
   103 				; This routine reads a directory block into DIR_BLK_BUF.
   104 				; It is called from OS_NEXT_DIR_BLK.
   105 				; ******************************************************************************
   106 42D5 A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
   107 42DD					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: macros.inc]
     1 42DD A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42DF A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   108 42E1 4C 4B 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
   109
   110 				; **** Read Next Directory Block ***********************************************
   111 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   112 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   113 				; ******************************************************************************
   114 42E4 A2 00		OS_NEXT_DIR_BLK LDX     #$00
   115 42E6			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 42E6 FE 24 18				INC	CURR_DIR_BLK,X
     2 42E9 D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   116 42EB E8			                INX                          		; overflow, increment next byte
   117 42EC			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: macros.inc]
     1 42EC C9 04				CMP	#$04
     2 42EE D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   118 42F0 F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   119
   120 				; **** Read Next Directory Cluster *********************************************
   121 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   122 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   123 				; ******************************************************************************
   124 42F2			OS_NEXT_DIR_CLSTR
   125 42F2 20 7E 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   126 42F5 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   127 42F7 60			                RTS			     ; return
   128 				                
   129 				; **** Save Directory Block ****************************************************
   130 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   131 				; Input: X,Y = Pointer to LBA nr.
   132 				; ******************************************************************************
   133 42F8 86 D8		OS_SAVE_DIR     STX	SAVEX
   134 42FA 84 D9				STY	SAVEY
   135 42FC A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; set source block buffer to DIR_BLK_BUF
   136 4304 A6 D8		                LDX     SAVEX       		; pointer to block number (LBA) to be saved
   137 4306 A4 D9		                LDY     SAVEY
   138 4308 4C 1D 42		                JMP     DEV_WR_LBLK          	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   139 				                
   140 				; **** Create New File on Disk *************************************************
   141 				; Input: FILENAME = String8_3
   142 				;        A        = File Attributes
   143 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   144 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   145 				; ******************************************************************************
   146 430B AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   147 430C A0 00		                LDY     #D_FILENAME         		; set index to filename
   148 430E B9 E6 49 91 A8 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   149 4314			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: macros.inc]
     1 4314 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4316 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   150 						
   151 						; Write Attribute
   152 4318 8A			                TXA                         	; yes, get attribute back to A
   153 4319 91 A8		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   154 431B A9 00		                LDA     #$00                	; and clear all following bytes to 0
   155 431D C8			                INY
   156 431E			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: macros.inc]
     1 431E C0 20				CPY	#$20			; 
     2 4320 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   157 						
   158 						; Write create-Date and Last-write Date
   159 4322 20 90 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   160 4325 98			                TYA				; Y = MSB
   161 4326 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   162 4328 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   163 432A A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   164 432C 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   165 432F 8A			                TXA				; X = LSB
   166 4330 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   167 4332 A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   168 4334 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   169
   170 						; Write create-Time and last-write Time
   171 4336 20 6B 43		                JSR     OS_FILETIME         	; get current time as file time
   172 4339 98			                TYA				; Y = MSB
   173 433A A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   174 433C 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   175 433E A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   176 4340 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   177 4343 8A			                TXA				; X = LSB
   178 4344 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   179 4346 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   180 4348 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   181
   182 						; Write File Cluster Nr High and Low
   183 434A A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   184 434C AD 23 18 91 A8 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   185 4352 AD 22 18 91 A8			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   186 4357 A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   187 4359 AD 21 18 91 A8 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   188 435F AD 20 18 91 A8			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   189 						
   190 4364					LDXYI	CURR_DIR_BLK		; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: macros.inc]
     1 4364 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 4366 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   191 4368 4C F8 42		                JMP     OS_SAVE_DIR	    	; write this dir entry back to disk and return
   192 				                
   193 				; **** Get Current Time As File Time *******************************************
   194 				; Output: File Time = Word[X,Y]
   195 				; ******************************************************************************
   196 436B 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   197
   198 				; **** Convert Time To File Time ***********************************************
   199 				; Input:  A - HOUR 	in BCD ($00-$23)
   200 				;	  X - MINUTE 	in BCD ($00-$59)
   201 				;	  Y - SECONDS	in BCD ($00-$59)
   202 				; Output: File Time = Word[X,Y]
   203 				; ******************************************************************************
   204 436E			OS_TIME_TO_FILETIME
   205 436E 20 B7 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   206 4371 85 F8		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   207 4373 A9 00 85 F9				MVA	#$00 NUM32+1	    ; clear upper byte of result
   208 4377 A2 06		                LDX     #$06
   209 4379 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   210 437C A5 FD		                LDA     SUM32+1             ; load MINUTE into A
   211 437E 05 F8 85 F8		                ORA:STA NUM32               ; and add value into result
   212 4382 A2 05		                LDX     #$05
   213 4384 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   214 4387 A5 FE		                LDA     SUM32+2             ; load SECONDS into A
   215 4389 6A			                ROR                         ; divide SECONDS by 2
   216 438A 05 F8		                ORA     NUM32               ; and add value into result
   217 438C AA			                TAX
   218 438D A4 F9		                LDY     NUM32+1             ; result is in Word[X,Y]
   219 438F 60			                RTS
   220 				                
   221 				; **** Get Current Date As File Date *******************************************
   222 				; Output: File Date = Word[X,Y]
   223 				; ******************************************************************************
   224 4390 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   225
   226 				; **** Convert Date To File Date ***********************************************
   227 				; Input:  A - YEAR 	in BCD ($00-$99)
   228 				; 	  X - MONTH 	in BCD ($01-$12)
   229 				; 	  Y - DAY	in BCD ($01-$31)
   230 				; Output: File Date = Word[X,Y]
   231 				; ******************************************************************************
   232 4393			OS_DATE_TO_FILEDATE
   233 4393 20 B7 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   234 4396 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   235 4399 85 F8		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   236 439B A9 00 85 F9		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   237 439F A2 04		                LDX     #$04
   238 43A1 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   239 43A4 A5 FD		                LDA     SUM32+1             ; load MONTH into A
   240 43A6 05 F8 85 F8		                ORA:STA NUM32               ; and add value into result
   241 43AA A2 05		                LDX     #$05
   242 43AC 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   243 43AF A5 FE		                LDA     SUM32+2             ; load DAY into A
   244 43B1 05 F8		                ORA     NUM32               ; and add value into result
   245 43B3 AA			                TAX
   246 43B4 A4 F9		                LDY     NUM32+1             ; result is in Word[X,Y]
   247 43B6 60			                RTS
   248 				                
   249 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   250 43B7			CONVERT_DATETIME
   251 43B7 85 FC		                STA     SUM32		    ; Year or Hour
   252 43B9					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: macros.inc]
     1 43B9 86 FD			STX	SUM32+1
     2 43BB 84 FE			STY	SUM32+1+1
Source: boot_sys_os.asm
   253 43BD A0 02		                LDY     #$02		    ; 3 bytes to convert
   254 43BF B9 FC 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   255 43C2 20 D3 4C		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   256 43C5 99 FC 00 88		                STA     SUM32,Y-	    ; Store result back
   257 43C9 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   258 43CB 60			                RTS			    ; return
   259
   260 				; **** Copy First block of File to memory **************************************
   261 				; Input:
   262 				; ******************************************************************************
   263 43CC 20 29 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   264 43CF					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: macros.inc]
     1 43CF AD 1F 44				LDA	FTYPE
     2 43D2 F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   265 43D4					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: macros.inc]
     1 43D4 C9 01				CMP	#1
     2 43D6 F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   266 						
   267 						; .EXE file (FTYPE=2)
   268 43D8 AD 00 57 8D BE 44			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   269 43DE 85 E8				STA	STOL			; destination address LSB
   270 43E0 AD 01 57 8D BF 44			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   271 43E6 85 E9				STA	STOH			; destination address MSB
   272 43E8 A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   273 43EC D0 18				BNE	COPY_BLK_DEST		; branch always
   274 						
   275 						; .COM file  (FTYPE=1)
   276 43EE A9 00 8D BE 44	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   277 43F3 85 E8				STA	STOL			 ; destination address LSB
   278 43F5 A9 30 8D BF 44			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   279 43FA 85 E9				STA	STOH			 ; destination address MSB
   280 43FC D0 08				BNE	COPY_BLK_DEST		 ; branch always
   281 						
   282 						; .BAS file (FTYPE=0)
   283 43FE A9 00 85 E8 A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR STOL	; destination = BAS_LOAD_ADDR
   284
   285 				; **** Copy Second and other blocks of File to Memory **************************
   286 				; Input:
   287 				; ******************************************************************************
   288 4406 A0 00		COPY_BLK_DEST	LDY	#0
   289 4408 B1 EA 91 E8		CP_BLK0_LP	MVA	(PSTR),Y (STOL),Y		; Get byte from buffer and store in destination
   290 440C E6 E8 D0 02 E6 E9			INW	STOL				; Increment destination pointer (macro)
   291 4412 E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
   292 4418 A5 EB				LDA	PSTR+1				; MSB of buffer pointer
   293 441A					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: macros.inc]
     1 441A C9 59				CMP	#>FILE_BUFF+2
     2 441C D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_os.asm
   294 441E 60					RTS					; return
   295 						
   296 441F 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   297
   298 				; **** Init File Buffer ********************************************************
   299 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   300 				; ******************************************************************************
   301 4420 A9 00 85 DC A9 57 + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   302 4428 60					RTS				; return
   303 						
   304 				; **** Init File-buffer pointer ************************************************
   305 				; This routine sets PSTR to FILE_BUFF
   306 				; ******************************************************************************
   307 4429 A9 00 85 EA A9 57 + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   308 4431 60					RTS				; return
   309
   310 				; **** Load BAS/COM/EXE File ***************************************************
   311 				; Input: CURR_CLUSTER: cluster nr of file to load
   312 				; ******************************************************************************
   313 4432 20 9C 46		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       	; check if filesize is 0
   314 4435 90 01		                BCC     OS_LOAD_COM2		; branch if file is not empty
   315 						
   316 4437 60			                RTS                         	; filesize is 0, just do nothing
   317 						
   318 4438			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      	; current cluster nr
Macro: LDXYI [Source: macros.inc]
     1 4438 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 443A A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   319 443C 20 FC 40		                JSR     CLSTR_TO_BLK        	; convert cluster number to LBA number in NUM32
   320 443F A9 00 85 AB		                MVA     #$00 BCNT              	; init. block counter
   321 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   322 4443 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   	; SCNT = numbers of sectors per cluster
   323 4448 A0 1D		                LDY     #D_FILE_SIZE+1      	; index to file size in dir. entry
   324 444A B1 A8		                LDA     (CURR_DIR_ENTRY),Y  	; load file size byte 1
   325 444C 4A			                LSR                         	; check if bit 0 is set (bytes 256-511 of buffer)
   326 444D 48			                PHA			    	; save byte: now contains file-size in blocks of 512 bytes
   327 444E B0 06		                BCS     LOAD_COM1           	; yes, add one block
   328 						
   329 4450 88			                DEY					; now points to D_FILE_SIZE LSB
   330 4451			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: macros.inc]
     1 4451 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4453 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   331 4455 38			                SEC                         		; yes, add one block
   332 4456 68			LOAD_COM1       PLA
   333 4457 65 AB 85 AB		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   334 445B			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: macros.inc]
     1 445B C9 59				CMP	#89			; 
     2 445D B0 24				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   335 						
   336 445F A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   337 4461			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 4461 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4463 D0 1E				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   338 4465 C8			                INY					; D_FILE_SIZE+3
   339 4466			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 4466 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4468 D0 19				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   340 						
   341 						; Read first part of file into FILE_BUFF
   342 446A 20 20 44				JSR	INIT_FILE_BUFF		; Set BLKBUF pointer to FILE_BUFF
   343 446D			                LDXYI   NUM32		    	; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 446D A2 F8			LDX	<NUM32				; MADS makes this immediate
     2 446F A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   344 4471 20 4B 41		                JSR     DEV_RD_LBLK         	; Read first block of file into FILE_BUFF
   345 4474 C6 AD				DEC     SCNT                	; First block is already read in
   346 4476 C6 AB				DEC	BCNT			; Number of blocks to read
   347 4478 20 CC 43				JSR	COPY_BLK0_DEST		; Copy first block to destination
   348 						
   349 447B 20 8A 44		                JSR     LOAD_NEXT_BLKS	    	; Load next blocks of file and execute it
   350 447E A9 25		                LDA     #HDD1_ID   	    	; Replace by D_DEV_ID?
   351 4480 4C AA E1				JMP     OPEN_DEVICE		; Init. device driver again and return
   352 						
   353 4483			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      	; load error message...
Macro: LDXYI [Source: macros.inc]
     1 4483 A2 D7			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 4485 A0 49			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   354 4487 4C 1E 48		                JMP     OS_PRINT_ERR		; Print it
   355
   356 				; **** Read Next File Blocks ***************************************************
   357 				; ******************************************************************************
   358 448A 20 81 41		LOAD_NEXT_BLKS  JSR     INC_32              	; Increment LBA block address in NUM32
   359 448D 20 20 44		LOAD_BLK0       JSR	INIT_FILE_BUFF		; Set BLKBUF pointer to FILE_BUFF
   360 4490					LDXYI   NUM32		    	; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 4490 A2 F8			LDX	<NUM32				; MADS makes this immediate
     2 4492 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   361 4494 20 4B 41		                JSR     DEV_RD_LBLK         	; and read next block of file into FILE_BUFF
   362 4497 20 29 44				JSR	INIT_FBUF_PTR		; reset file-buffer pointer PSTR to FILE_BUFF again
   363 449A 20 06 44				JSR	COPY_BLK_DEST	    	; Copy block to destination
   364 449D			                DEC.EQ  BCNT OS_EXEC_CHK      	; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 449D C6 AB				DEC	BCNT
     2 449F F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   365 44A1					DEC.NE  SCNT LOAD_NEXT_BLKS    	; branch if more blocks in cluster to read
Macro: DEC.NE [Source: macros.inc]
     1 44A1 C6 AD				DEC	SCNT
     2 44A3 D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   366
   367 				; next cluster needs to be loaded considering the volume FAT type **************
   368 44A5 20 7E 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   	; Get next cluster from FAT table in CURR_CLUSTER
   369 44A8 B0 0B		                BCS     OS_EXEC_CHK	    	; C=1, EOF, go execute File
   370 							
   371 44AA 20 F8 40		                JSR     CLUSTER_TO_BLK	    	; convert CURR_CLUSTER to LBA number in NUM32
   372 44AD AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   	; SCNT = numbers of sectors per cluster
   373 44B2 4C 8D 44		                JMP     LOAD_BLK0	    	; branch always
   374 						
   375 				; Run file if needed ***********************************************************
   376 				; ******************************************************************************
   377 44B5			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE	; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: macros.inc]
     1 44B5 AD 1F 44				LDA	FTYPE
     2 44B8 D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   378 44BA 60					RTS				; return in case of a .BAS file
   379
   380 				; **** Execute File ************************************************************
   381 				; Input:  Ptr[OS_PROG] to Start Address
   382 				; Output: A - Result Code
   383 				; ******************************************************************************
   384 44BB 6C BE 44		OS_EXECUTE      JMP     (OS_PROG)           	; run .com or .exe file
   385 44BE 00 00		OS_PROG         .word      $0000
   386 				                
   387 				; ******************************************************************************
   388 44C0			INIT_FREE_CLUSTER
   389 44C0 A9 02 8D 20 18			MVA     #$02 FREE_CLUSTER       ; first data cluster is $000002
   390 44C5 A9 00 8D 21 18	                MVA     #$00 FREE_CLUSTER+1
   391 44CA 8D 22 18				STA     FREE_CLUSTER+2
   392 44CD 8D 23 18		                STA     FREE_CLUSTER+3
   393 44D0 60			                RTS
   394 				                
   395 				; ******************************************************************************
   396 				; Input: FREE_CLUSTER: number of possible free cluster
   397 				; Output: C=1: cluster is free ; C=0: 
   398 				; ******************************************************************************
   399 44D1			OS_NEXT_FREE_CLUSTER
   400 44D1			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 44D1 A2 03			LDX	#4-1
     2 44D3 BD 20 18 95 A0 CA	lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 44D9 10 F8			BPL	lp
Source: boot_sys_os.asm
   401 44DB 20 7E 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   402 44DE A2 03		                LDX     #$03
   403 44E0			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: macros.inc]
     1 44E0 B5 A0				LDA	CURR_CLUSTER,X
     2 44E2 D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   404 44E4			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: macros.inc]
     1 44E4 CA					DEX
     2 44E5 10 F9				BPL	CHK_FREE
Source: boot_sys_os.asm
   405 44E7 38			                SEC                         		; cluster is free, exit with C = 1
   406 44E8 60			                RTS
   407
   408 				; ******************************************************************************
   409 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   410 				; ******************************************************************************
   411 44E9 A2 00		SET_NEXT_CLSTR  LDX     #$00
   412 44EB			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 44EB FE 20 18				INC	FREE_CLUSTER,X
     2 44EE D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   413 44F0 E8			                INX						; next byte of FREE_CLUSTER
   414 44F1			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 44F1 E0 04				CPX	#$04
     2 44F3 D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   415 						
   416 44F5 A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   417 44F7 B5 A4		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   418 44F9			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: macros.inc]
     1 44F9 DD 18 04				CMP	D_START_FAT2,X			; 
     2 44FC 90 D3				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   419 44FE			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 44FE CA					DEX
     2 44FF 10 F6				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   420 4501 18			                CLC                         			; no emtpy cluster found, exit with error
   421 4502 60			                RTS
   422
   423 				; ******************************************************************************
   424 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   425 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   426 				; BLOCK_BUFF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   427 				; in CURR_CLUSTER needs to be allocated in the FAT table.
   428 				; ******************************************************************************
   429 4503			WRITE_FAT_ENTRY	PRCH	'['			; Print [
Macro: PRCH [Source: macros.inc]
     1 4503 A9 5B			LDA	#'['
     2 4505 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   430 4508					PRHEX16	CURR_CLUSTER		; Print CURR_CLUSTER
Macro: PRHEX16 [Source: macros.inc]
     1 4508 A5 A1			LDA	CURR_CLUSTER+1				; print MSB
     2 450A 20 91 E0			JSR	HEXOUT
     3 450D A5 A0			LDA	CURR_CLUSTER
     4 450F 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   431 4512					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4512 A9 5D			LDA	#']'
     2 4514 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   432 4517 A5 A0				LDA	CURR_CLUSTER		; get LSB of cluster nr
   433 4519 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   434 451B A8					TAY				; Y = DWORD byte 0 in FAT page
   435 					.rept 3					; Write 3 x $FF into FAT entry
   436 						LDA	#$FF			
   437 						JSR	WRITE_ENTRY_BYTE	
   438 						INY				
   439 					.endr	
Source: REPT
   436 451C A9 FF				LDA	#$FF			
   436 451E 20 3A 45				JSR	WRITE_ENTRY_BYTE	
   436 4521 C8					INY				
   436 4522 A9 FF				LDA	#$FF			
   436 4524 20 3A 45				JSR	WRITE_ENTRY_BYTE	
   436 4527 C8					INY				
   436 4528 A9 FF				LDA	#$FF			
   436 452A 20 3A 45				JSR	WRITE_ENTRY_BYTE	
   436 452D C8					INY				
Source: boot_sys_os.asm
   440 452E A9 0F				LDA	#$0F			; write end marker
   441 4530 20 3A 45				JSR	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   442 4533					LDXYI	CURR_FAT_BLK		; LBA of current FAT block
Macro: LDXYI [Source: macros.inc]
     1 4533 A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 4535 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   443 4537 4C 18 42				JMP	DEV_WR_LBLK_BUF		; write FAT block back to disk and return
   444 						
   445 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   446 				; INPUT : A = Write Data
   447 				;         Y - Index To FAT Entry Byte
   448 				; ******************************************************************************
   449 453A			WRITE_ENTRY_BYTE
   450 453A AA					TAX
   451 453B A5 A1		                LDA     CURR_CLUSTER+1
   452 453D 4A			                LSR				; check bit 0 of free_cluster[1]
   453 453E 8A			                TXA
   454 453F B0 04		                BCS     WR_UPPER_PAGE       	; if bit 0 = 1 then write byte to upper half of block
   455 						
   456 4541 99 00 06		                STA     BLOCK_BUFF,Y		; write entry byte to lower half of block buffer
   457 4544 60					RTS				
   458 						
   459 4545 99 00 07		WR_UPPER_PAGE   STA     BLOCK_BUFF+256,Y	; write entry byte to upper half of block buffer
   460 4548 60					RTS
   461 				                
   462 				; **** Add Date and Time to subdir entry ***************************************
   463 				; ******************************************************************************
   464 4549			ADD_DATE_TIME	; Write create-Date and Last-write Date
   465 4549 20 90 43				JSR     OS_FILEDATE         	; get current date as file date
   466 454C 98			                TYA				; Y = MSB
   467 454D A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   468 454F 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   469 4551 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   470 4553 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   471 4556 8A			                TXA				; X = LSB
   472 4557 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   473 4559 A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   474 455B 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   475
   476 						; Write create-Time and last-write Time
   477 455D 20 6B 43		                JSR     OS_FILETIME         	; get current time as file time
   478 4560 98			                TYA				; Y = MSB
   479 4561 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   480 4563 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   481 4565 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   482 4567 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   483 456A 8A			                TXA				; X = LSB
   484 456B 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   485 456D A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   486 456F 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   487 4571 60					RTS
   488 						
   489 				; **** Add new subdirectory entry to dir buffer ********************************
   490 				; Input: X=1: . subdir, X=2: .. subdir
   491 				; ******************************************************************************
   492 4572 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   493 4573 48					PHA					; save it
   494 4574 A0 00				LDY	#D_FILENAME			; Filename entry
   495 4576 A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   496 457B			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: macros.inc]
     1 457B C0 0B				CPY	#D_ATTRIBUTES			; 
     2 457D 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   497
   498 457F A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   499 4583 A0 00				LDY	#D_FILENAME			; Filename entry
   500 4585 A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   501 4587 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   502 458A					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: macros.inc]
     1 458A CA					DEX
     2 458B D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   503
   504 458D 20 49 45				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   505 4590 68					PLA
   506 4591					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: macros.inc]
     1 4591 C9 01				CMP	#1
     2 4593 D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   507 					
   508 						; Current subdir .: Write File Cluster Nr High and Low
   509 4595 A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   510 4597 AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   511 459D AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   512 45A2 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   513 45A4 AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   514 45AA AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   515 45AF 60					RTS					; return
   516 						
   517 						; Parent subdir ..: Write File Cluster Nr High and Low
   518 45B0 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   519 45B2 AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   520 45B8 AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   521 45BD A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   522 45BF AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   523 45C5 AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   524 45CA 60					RTS
   525 						
   526 				; **** Add new Directory Cluster to Disk ***************************************
   527 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   528 				; ******************************************************************************
   529 45CB			ADD_NEW_DIR_CLST
   530 45CB A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   531 45D3 A2 01				LDX	#1
   532 45D5 A9 00				LDA	#0
   533 45D7			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: macros.inc]
     1 45D7 91 DC C8				STA	(BLKBUF),Y+
     2 45DA D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   534 45DC E6 DD				INC	BLKBUF+1		; next page
   535 45DE					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: macros.inc]
     1 45DE CA					DEX
     2 45DF 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   536 						
   537 45E1 A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   538 45E5 A2 01				LDX	#1			; 1 = . subdir entry
   539 45E7 20 72 45				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   540 45EA A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   541 45F1 A2 02				LDX	#2			; 2 = .. subdir entry
   542 45F3 20 72 45				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   543
   544 						; and write it to disk
   545 				.if	DBG_PRINT = 1
   546 45F6					PRSTR	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTR [Source: macros.inc]
     1 45F6 A2 26			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 45F8 A0 46			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 45FA 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   547 45FD					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: macros.inc]
     1 45FD AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 4600 20 91 E0			JSR	HEXOUT
     3 4603 AD 22 18			LDA	FREE_CLUSTER+2
     4 4606 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 4609 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 460C 20 91 E0			JSR	HEXOUT
     3 460F AD 20 18			LDA	FREE_CLUSTER
     4 4612 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   548 4615 20 5A E0				JSR	CROUT			; Print CR
   549 				.endif
   550 4618					LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: macros.inc]
     1 4618 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 461A A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   551 461C 20 FC 40				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   552 461F					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: macros.inc]
     1 461F A2 F8			LDX	<NUM32				; MADS makes this immediate
     2 4621 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   553 4623 4C F8 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   554 						
   555 4626 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   556
   557 				; **** Add First Cluster To Empty File *****************************************
   558 				; ******************************************************************************
   559 463F 20 C0 44		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 0L
   560 4642 20 D1 44				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   561 4645 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   562 						
   563 4647 20 03 45		                JSR     WRITE_FAT_ENTRY	    	; Allocate CURR_CLUSTER, also writes FAT block back to disk
   564 464A 60			ADD_CLUSTER_END RTS
   565
   566 				; **** Create New File *********************************************************
   567 				; Input:  A = File Attributes
   568 				; Output: C = 0 - Error; C = 1 - No Error
   569 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   570 				; ******************************************************************************
   571 464B 8D 12 18		OS_CREATE       STA     F_ATTRIBS           	; save attributes
   572 464E			                AND.EQ  #FA_DIRECTORY ADD_FILE 	; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: macros.inc]
     6 464E 29 10				AND	#FA_DIRECTORY
     7 4650 F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   573 4652 20 B1 46		                JSR     OS_DIR_EXISTS       	; C=1: dirname already exists
   574 4655 90 05				BCC	OS_CREATE_CONT		; branch if dirname does not exist yet
   575 4657 B0 2C				BCS	OS_CREATE_ERR		; branch on error
   576
   577 4659 20 B7 46		ADD_FILE        JSR     OS_FILE_EXISTS      	; check if file already exists
   578 465C			OS_CREATE_CONT	
   579 465C A9 FF				LDA     #$FF                	; error result -1 if file/dir exists
   580 465E B0 25		                BCS     OS_CREATE_ERR       	; file already exists, exit with error $FF
   581
   582 4660 20 3F 46				JSR	OS_ADD_CLUSTER		; Return free cluster in CURR_CLUSTER and write FAT
   583 						
   584 						; Find a Free dir. entry and fill it with file info and save it to disk
   585 4663 20 AB 46				JSR 	OS_FIND_FREE		; Find a free directory entry in the current directory
   586 				.if	DBG_PRINT = 1
   587 4666					PRSTR	TXT_FFREE1		; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 4666 A2 87			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 4668 A0 46			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 466A 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   588 466D					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 466D A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 466F 20 91 E0			JSR	HEXOUT
     3 4672 A5 A8			LDA	CURR_DIR_ENTRY
     4 4674 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   589 4677 20 5A E0				JSR	CROUT			; Print CR
   590 				.endif
   591 467A AD 12 18		                LDA     F_ATTRIBS		; Get file/dir attributes
   592 467D 20 0B 43				JSR	OS_CREATE_FILE		; create the file/dir on disk
   593 						
   594 4680 20 CB 45				JSR	ADD_NEW_DIR_CLST	; Add new dir cluster with . and .. and save it to disk
   595 4683 38					SEC				; C=1, OK
   596 4684 60			                RTS
   597 4685 18			OS_CREATE_ERR   CLC				; C=0, error
   598 4686 60			OS_CREATE_END   RTS				; return
   599 				                
   600 4687 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   601
   602 				; **** Open File ***************************************************************
   603 				; ******************************************************************************
   604 4698 60			OS_OPEN         RTS
   605
   606 				; **** Close File **************************************************************
   607 				; ******************************************************************************
   608 4699 60			OS_CLOSE        RTS
   609
   610 				; **** Set File Size ***********************************************************
   611 				; ******************************************************************************
   612 469A 60			OS_SET_SIZE     RTS
   613
   614 				; **** Delete File *************************************************************
   615 				; ******************************************************************************
   616 469B 60			OS_DELETE       RTS
   617
   618 				; **** Test If File Is Empty ************** ************************************
   619 				; Input:  Ptr(CURR_DIR_ENTRY)
   620 				; Output: C = 1 - File is empty; C = 0 - File not empty
   621 				; ******************************************************************************
   622 469C A2 04		OS_FILE_EMPTY   LDX     #$04
   623 469E A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   624 46A0 18			                CLC
   625 46A1			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: macros.inc]
     1 46A1 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 46A3 D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   626 46A5 C8			                INY
   627 46A6			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: macros.inc]
     1 46A6 CA					DEX
     2 46A7 D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   628 46A9 38			                SEC			    			; C=1: File is empty
   629 46AA 60			OS_FILE_EMPTY2  RTS			    			; return
   630
   631 				; **** Check If a directory entry is free or deleted ***************************
   632 				; ******************************************************************************
   633 46AB			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: macros.inc]
     1 46AB A2 6C			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 46AD A0 49			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   634 46AF D0 1A		                BNE     OS_FIND			; branch always
   635
   636 				; **** Check If Directory Already Exists ***************************************
   637 				; ******************************************************************************
   638 46B1			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 46B1 A2 20			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 46B3 A0 49			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   639 46B5 D0 14		                BNE     OS_FIND			; branch always
   640 				                
   641 				; **** Check If Directory Is Available *****************************************
   642 				; ******************************************************************************
   643 46B7			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 46B7 A2 44			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 46B9 A0 49			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   644 46BB D0 0E		                BNE     OS_FIND			; branch always
   645
   646 				; **** Find Directory **********************************************************
   647 				; ******************************************************************************
   648 46BD			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 46BD A2 23			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 46BF A0 49			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   649 46C1 D0 08		                BNE     OS_FIND			; branch always
   650
   651 				; **** Find File ***************************************************************
   652 				; ******************************************************************************
   653 46C3			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: macros.inc]
     1 46C3 A2 47			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 46C5 A0 49			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   654 				                                           ; fall through to OS_FIND
   655 				                                           
   656 				; **** Find All Files **********************************************************
   657 				; ******************************************************************************
   658 46C7 A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   659 46C9 D0 02		                BNE     OS_FIND2
   660
   661 				; **** Main Find Routine *******************************************************
   662 				; ******************************************************************************
   663 46CB A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   664 46CD			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: macros.inc]
     1 46CD 8E 8A 49			STX	CMD_ADDR
     2 46D0 8C 8B 49			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   665 				                                            ; fall through to OS_DIR_LOOP
   666
   667 				; **** Loop Through Actual Directory *******************************************
   668 				; Input:  Ptr[X:Y] = Address to command specific function
   669 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   670 				; Output: C = 1 - Found; C = 0 - Not Found
   671 				; ******************************************************************************
   672 46D3 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   673 46D6 A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   674 46DE 20 A1 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   675 46E1			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 46E1 A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 46E3 A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   676 46E5			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: macros.inc]
     1 46E5 86 A8			STX	CURR_DIR_ENTRY
     2 46E7 84 A9			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   677 46E9 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   678 46EB B1 A8		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   679 46ED AA			                TAX                         			; load attributes into X
   680 46EE A0 00		                LDY     #D_FILENAME         			; index to filename
   681 46F0			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: macros.inc]
     1 46F0 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 46F2 F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   682 46F4 20 13 4A		                JSR     CMD_EXECUTE         			; call command routine
   683 46F7 B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   684 						
   685 46F9			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: macros.inc]
     1 46F9 AD 13 18				LDA	TERM_FLAG
     2 46FC D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   686 46FE EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   687 4706 A5 A8 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   688 470D 90 DA		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   689 						
   690 470F A9 00		                LDA     #$00
   691 4711 65 A9 85 A9		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   692 4715			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: macros.inc]
     1 4715 C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 4717 D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   693
   694 4719			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: macros.inc]
     1 4719 CE 1D 18				DEC	CURR_BLK_NUM
     2 471C D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   695 471E			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 471E AD 0A 04				LDA	D_FAT_TYPE
     2 4721 F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   696 4723 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   697 4725 B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   698
   699 4727 20 F2 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   ; load next directory cluster from device
   700 472A 90 B5		                BCC     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   701 472C B0 0D		                BCS     OS_DIR_LOOP_EOF     ; directory EOF reached. Exit
   702
   703 472E 20 E4 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     ; load next directory block from device
   704 4731 4C E1 46		                JMP     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   705
   706 4734			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        ; set pointer to upper page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 4734 A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 4736 A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   707 4738 4C E5 46		                JMP     SET_CURR_ENTRY	    ; branch to begin of loop
   708
   709 473B 18			OS_DIR_LOOP_EOF CLC			    ; C=1: not found
   710 473C 60			OS_DIR_LOOP_END RTS			    ; return
   711
   712 				; **** Set Drive Command *******************************************************
   713 				; Input:  A = Drive Number (0..25)
   714 				; Output: C = 0 - Error
   715 				; ******************************************************************************
   716 473D			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: macros.inc]
     1 473D CD 1E 18				CMP	CURR_DRIVE
     2 4740 F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   717 4742			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: macros.inc]
     1 4742 C9 08				CMP	#$08			; 
     2 4744 B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   718 4746 AA			                TAX                         		; save actual drive number to Y
   719 4747 AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   720 474A 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   721 474F 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   722 4751 A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   723 4755					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: macros.inc]
     1 4755 A0 1F			LDY	#$20-1
     2 4757 B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 475D 10 F8			BPL	lp
Source: boot_sys_os.asm
   724 475F 8A			                TXA
   725 4760 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   726 4765 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   727 4767 A0 08		                LDY     #$08                		; set index to D_DEV_ID
   728 4769			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: macros.inc]
     1 4769 B1 E8				LDA	(STOL),Y
     2 476B F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   729
   730 476D					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: macros.inc]
     1 476D A0 1F			LDY	#$20-1
     2 476F B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 4775 10 F8			BPL	lp
Source: boot_sys_os.asm
   731 4777 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   732
   733 				; TODO: Invalidate Block Buffers ###########################################################################
   734
   735 477A AD 08 04		                LDA     D_DEV_ID            ; get current device id
   736 477D 20 AA E1		                JSR     OPEN_DEVICE         ; and open the device driver
   737 4780 38			SET_DRIVE_END   SEC			    ; C=1: no error
   738 4781 60			                RTS
   739
   740 4782			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: macros.inc]
     1 4782 A2 6E			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 4784 A0 53			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   741 4786 4C 1E 48		                JMP     OS_PRINT_ERR	    ; Print 'Drive not found'
   742
   743 				; **** Test If Root Directory **************************************************
   744 				; Input:
   745 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   746 				; ******************************************************************************
   747 4789 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   748 478B B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   749 478E			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: macros.inc]
     1 478E D9 1C 04				CMP	D_START_DIR,Y
     2 4791 D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   750 4793			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: macros.inc]
     1 4793 88					DEY
     2 4794 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   751 						
   752 4796 38			                SEC			     		; C=1 => is root dir.
   753 4797 60			                RTS
   754 4798 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   755 4799 60			                RTS
   756
   757 				; **** Set Root Directory Command **********************************************
   758 				; ******************************************************************************
   759 479A A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   760 479C BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   761 47A2 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   762 47A6 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   763 						
   764 47A8 A9 5C 8D 20 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   765 47B2 60					RTS					; return
   766
   767 				; **** Set Directory Command ***************************************************
   768 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   769 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   770 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   771 				; considered to be the root-dir and cluster number is set to 2.
   772 				; ******************************************************************************
   773 47B3			OS_SET_DIR      PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 47B3 A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 47B5 20 91 E0			JSR	HEXOUT
     3 47B8 A5 A8			LDA	CURR_DIR_ENTRY
     4 47BA 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   774 47BD					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 47BD A9 2C			LDA	#','
     2 47BF 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   775 47C2					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: macros.inc]
     1 47C2 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 47C4 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 47C6 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 47C9 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 47CB B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 47CD 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   776 47D0					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: macros.inc]
     1 47D0 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 47D2 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 47D4 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 47D7 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 47D9 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 47DB 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   777 47DE					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 47DE A9 5D			LDA	#']'
     2 47E0 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   778 47E3 A0 15				LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   779 47E5 A2 04		                LDX     #$04				; Copy 4 bytes
   780 47E7 8E 0C 48				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   781 47EA CA					DEX					; Copy bytes 3..0
   782 47EB 20 F9 47				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   783 47EE A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   784 47F0 20 F9 47				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   785 47F3					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: macros.inc]
     1 47F3 AD 0C 48				LDA	OS_DWORD0
     2 47F6 F0 A2				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   786 47F8 60			                RTS			     		; return
   787 				                
   788 				;-------------------------------------------------------------------------------------------------
   789 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   790 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   791 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   792 				;-------------------------------------------------------------------------------------------------
   793 47F9 20 FC 47		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   794 47FC B1 A8 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   795 4801					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: macros.inc]
     1 4801 9D 24 18				STA	CURR_DIR_BLK,X
     2 4804 D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   796 4806 CE 0C 48				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   797 4809 88			SET_BYTE_NOT0	DEY				
   798 480A CA					DEX
   799 480B 60					RTS				; return
   800 480C 00			OS_DWORD0	.byte	$00
   801
   802 				; **** Read Input String *******************************************************
   803 				; Output: Null terminated string in STRBUF
   804 				; ******************************************************************************
   805 480D 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   806 4810 A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   807 4818 A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   808 481D 60			                RTS
   809
   810 				; **** Print Error Message *****************************************************
   811 				; Input:  Ptr[X:Y] = Pointer to Error Message
   812 				; Output: C = 0
   813 				; ******************************************************************************
   814 481E 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   815 4821 18			                CLC
   816 4822 60			                RTS
   817 				                
   818 				; **** Parse Full Path String **************************************************
   819 				; Input:  Ptr[X:Y] to Path String
   820 				; Output: C = 0 - Error; C = 1 - No Error
   821 				;         A = $00       - End Of String
   822 				;           = $FF       - Path Not Found
   823 				;           = ?         - Wildcard Included
   824 				;           = PATH_SEP  - No Trailing Name
   825 				; ******************************************************************************
   826 4823			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: macros.inc]
     1 4823 86 EA			STX	PSTR
     2 4825 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   827 4827 A0 00		                LDY     #$00
   828 4829 8C 11 18		                STY     TERM_CHAR
   829 482C A9 5C		                LDA     #PATH_SEP
   830 482E			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: macros.inc]
     1 482E D1 EA				CMP	(PSTR),Y
     2 4830 D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   831 4832 20 9A 47		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   832 4835 A0 00		                LDY     #$00
   833 4837 C8			PARSE_PATH      INY
   834 4838			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: macros.inc]
     1 4838 B1 EA				LDA	(PSTR),Y
     2 483A F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   835 483C			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: macros.inc]
     1 483C C9 20				CMP	#SPC
     2 483E F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   836 						
   837 4840 20 6A 48		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   838 4843 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   839 						
   840 4845			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: macros.inc]
     1 4845 C9 5C				CMP	#PATH_SEP
     2 4847 D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   841 4849 84 EE		                STY     PSAV                ; save string index
   842 484B 20 BD 46		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   843 484E A4 EE		                LDY     PSAV                ; restore string index
   844 4850 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   845 4852 B0 E3		                BCS     PARSE_PATH          ; branch always
   846 				                
   847 4854 18			PARSE_TERM      CLC
   848 4855			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: macros.inc]
     1 4855 AD 11 18				LDA	TERM_CHAR
     2 4858 D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   849 485A A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   850 485F D0 04		                BNE     PARSE_PATH_OK			; branch always
   851 				                
   852 4861			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: macros.inc]
     1 4861 A9 FF				LDA	#$FF
     2 4863 D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   853 4865 38			PARSE_PATH_OK   SEC
   854 4866 AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   855 4869 60			PARSE_PATH_END2 RTS
   856
   857 				; **** Parse A Partial Path Name String ****************************************
   858 				; Input:  A = First Char Of Partial Path
   859 				;         Y = Index Into Path String
   860 				; Output: C = 0 - Error; C = 1 - No Error
   861 				;         TERM_CHAR = NULL      - Filename
   862 				;                   = ?         - Wildcard Chars Included
   863 				;                   = PATH_SEP  - Subdirectory Name
   864 				; ******************************************************************************
   865 486A A2 08		OS_PARSE_NAME   LDX     #8
   866 486C 86 AB		                STX     BCNT                	; set max char count to 8
   867 486E A2 00		                LDX     #$00                	; reset index to name string buffer
   868 4870 8E 11 18		                STX     TERM_CHAR
   869 4873			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4873 C9 2E				CMP	#DOT
     2 4875 D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   870 4877 9D E6 49 E8		                STA     FILENAME,X+         	; yes, store it
   871 487B C8			                INY
   872 487C B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   873 487E			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 487E C9 2E				CMP	#DOT
     2 4880 D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   874 4882 9D E6 49		SET_CHAR        STA     FILENAME,X          	; yes, store it
   875 4885 E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   876 4886 C8			NEXT_CHAR2      INY                         	; point to next char of input string
   877 4887			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: macros.inc]
     1 4887 B1 EA				LDA	(PSTR),Y
     2 4889 F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   878 488B			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: macros.inc]
     1 488B C9 20				CMP	#SPC
     2 488D F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   879 488F			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: macros.inc]
     1 488F C9 5C				CMP	#PATH_SEP
     2 4891 F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   880 4893			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: macros.inc]
     1 4893 C9 2E				CMP	#DOT
     2 4895 F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   881 4897			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: macros.inc]
     1 4897 C9 2A				CMP	#'*'
     2 4899 F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   882
   883 489B			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: macros.inc]
     1 489B E4 AB				CPX	BCNT			; 
     2 489D B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   884 489F 20 AE 4A		                JSR     UPPERCASE           	; convert chars to upper case
   885 48A2			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: macros.inc]
     1 48A2 C9 3F				CMP	#'?'
     2 48A4 D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   886 48A6 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   887 48A9 F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   888
   889 48AB			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 48AB C9 2D				CMP	#MINUS
     2 48AD F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   890 48AF			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 48AF C9 5F				CMP	#ULINE
     2 48B1 F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   891 48B3					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 48B3 C9 7E				CMP	#'~'
     2 48B5 F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   892 48B7					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 48B7 C9 30				CMP	#'0'			; 
     2 48B9 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   893 48BB			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 48BB C9 3A				CMP	#':'			; 
     2 48BD 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   894 48BF			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 48BF C9 41				CMP	#'A'			; 
     2 48C1 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   895 48C3			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 48C3 C9 5B				CMP	#'['			; 
     2 48C5 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   896
   897 48C7 A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   898 48CC 20 E3 48		                JSR     FILL_CHAR           ; fill with ? chars
   899 48CF B0 B5		                BCS     NEXT_CHAR2          ; branch always
   900
   901 48D1 20 E1 48		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
   902 48D4 A9 0B 85 AB		                MVA     #11 BCNT            ; set max char count to 11
   903 48D8 B0 AC		                BCS     NEXT_CHAR2          ; branch always
   904
   905 48DA 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
   906 48DD A9 0B 85 AB		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
   907 48E1 A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
   908 48E3			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: macros.inc]
     1 48E3 E4 AB				CPX	BCNT			; 
     2 48E5 B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   909 48E7 9D E6 49 E8		                STA     FILENAME,X+         ; no, store char in name buffer
   910 48EB 90 F6		                BCC     FILL_CHAR           ; and repeat
   911
   912 48ED AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
   913 48F0 60			                RTS
   914 				                
   915 				; **** Compare File Name With Mask *********************************************
   916 				; Output: C = 0 - Names not equal; C = 1 - Names equal
   917 				; ******************************************************************************
   918 48F1 A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
   919 48F3 B9 E6 49		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
   920 48F6			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: macros.inc]
     1 48F6 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 48F8 D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
   921 48FA			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: macros.inc]
     1 48FA 88					DEY
     2 48FB 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
   922 						
   923 48FD 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
   924 48FE 60			                RTS
   925 48FF 18			COMPARE_NEQ     CLC					; C=0, filename is different
   926 4900 60			                RTS
   927 				                
   928 				; **** Delete File *************************************************************
   929 				; Input : A - First character of filename
   930 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
   931 				; ******************************************************************************
   932 4901			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: macros.inc]
     1 4901 C9 E5				CMP	#$E5
     2 4903 D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
   933 4905 AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
   934 4908 D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
   935
   936 490A 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
   937 490D					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: macros.inc]
     1 490D A0 05			LDY	#6-1
     2 490F B9 24 18 99 1A 49 + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4916 10 F7			BPL	lp
Source: boot_sys_os.asm
   938 4918 38			                SEC
   939 4919 60			                RTS
   940 				                
   941 491A 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
   942 491E 00 00		SEL_DIR_ENTRY   .byte $00, $00
   943 				                
   944 				; **** Directory Loop Call Back Functions **************************************
   945 				; Input : A - First character of filename
   946 				;         X - File Attributes
   947 				; Output: C = 1 - File found; C = 0 - File not found
   948 				; ******************************************************************************
   949
   950 				; **** Directory Exists - Call Back Routine ************************************
   951 4920 20 01 49		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
   952
   953 				; **** Find Sub Directory Name - Call Back Routine *****************************
   954 4923			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4923 E0 0F				CPX	#$0F
     2 4925 F0 43				BEQ	CB_FIND_END
Source: boot_sys_os.asm
   955 4927 AD E6 49		                LDA     FILENAME            	; do we search for the . directory?
   956 492A			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: macros.inc]
     1 492A C9 2E				CMP	#DOT
     2 492C D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
   957 						
   958 492E AD E7 49		                LDA     FILENAME+1		; get next byte
   959 4931			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: macros.inc]
     1 4931 C9 20				CMP	#SPC
     2 4933 F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
   960 						
   961 4935 8A			FIND_SUBDIR     TXA
   962 4936			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: macros.inc]
     6 4936 29 10				AND	#FA_DIRECTORY
     7 4938 F0 30				BEQ	CB_FIND_END
Source: boot_sys_os.asm
   963 493A 20 F1 48		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
   964 493D 90 2C		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
   965
   966 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
   967 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
   968 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
   969 						;    with $1C & $1D not being cluster nr bytes.
   970 493F 20 B3 47		                JSR     OS_SET_DIR          	; make this directory the actual directory
   971 4942 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
   972 4943 60			                RTS				; return
   973 				                
   974 				; **** File Exists - Call Back Routine *****************************************
   975 4944 20 01 49		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
   976
   977 				; **** Find File Name - Call Back Routine **************************************
   978 4947			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4947 E0 0F				CPX	#$0F
     2 4949 F0 1F				BEQ	CB_FIND_END
Source: boot_sys_os.asm
   979 494B 8A			                TXA
   980 494C			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: macros.inc]
     6 494C 29 10				AND	#FA_DIRECTORY
     7 494E D0 1A				BNE	CB_FIND_END
Source: boot_sys_os.asm
   981 4950 20 F1 48		                JSR     OS_COMP_NAME        			; compare name with search mask
   982 4953 90 16		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
   983 						
   984 4955 A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
   985 4957 A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
   986 4959 B1 A8 C8 95 A0 E8	GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
   987 495F			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: macros.inc]
     1 495F E0 02				CPX	#$02			; 
     2 4961 90 F6				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
   988 4963 A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
   989 4965			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4965 E0 04				CPX	#$04			; 
     2 4967 90 F0				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
   990 4969 60			                RTS                         			; yes, file found
   991
   992 496A 18			CB_FIND_END     CLC                         			; file not found
   993 496B 60			CB_FIND_END2    RTS
   994 				                
   995 				; **** Find Free or Deleted Dir. Entry **************************************
   996 496C			CB_FIND_FREE_DIR_ENTRY
   997 496C A0 00				LDY	#D_FILENAME			; set index to filename
   998 496E B1 A8				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
   999 4970					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: macros.inc]
     1 4970 C9 E5				CMP	#$E5
     2 4972 F0 09				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1000 4974			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: macros.inc]
     1 4974 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4976 D0 10				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1001 4978 C8					INY
  1002 4979			                CPY.CC  #D_ATTRIBUTES FFD_LP1  		; branch if not all characters copied
Macro: CPY.CC [Source: macros.inc]
     1 4979 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 497B 90 F7				BCC	FFD_LP1			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
  1003 497D A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1004 497F 91 A8 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1005 4982					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: macros.inc]
     1 4982 C0 20				CPY	#$20
     2 4984 D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1006 						
  1007 4986 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1008 4987 60			                RTS                         		; return
  1009 4988 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1010 4989 60					RTS					; return
  1011
  1012 				; **** Data Area ***************************************************************
  1013 				; ******************************************************************************
  1014
  1015 				; Indirect Jump Pointer Of Current Command Address *****************************
  1016 498A 00 00		CMD_ADDR        .word      $0000
  1017 				                
  1018 				; String Data Area *************************************************************
  1019 498C 2E 2E 2E 0D 0D	MSG_BOOT        .by    '...' CR CR
  1020 4991 20 57 65 6C 63 6F +                 .by    ' Welcome to DOS-65 System I, Version '
  1021 49B6 30 2E 32 2E 33 0D +                 .byte      VERMAIN,DOT,VERPSUB,DOT,VERSSUB,CR,CR
  1022 49BD 20 32 30 32 33 2F +                 .by    ' 2023/25 by Joerg Walke' CR CR $00
  1023 49D7 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1024 = 49E6			FILENAME        .ds 	12
    76 49F2					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; Main Loop Of Command Interpreter *********************************************
    10 				; ******************************************************************************
    11 49F2 A9 AC 8D 8A 49 A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    12 49FC 20 EA 4A		                JSR     PRINT_PROMPT
    13 49FF 20 0D 48		                JSR  	OS_STRING_IN         ; read input string
    14 4A02 20 16 4A				JSR     GET_CMD              ; parse string
    15 4A05 90 06				BCC     CMD_EXTERNAL
    16 						
    17 4A07 20 13 4A		                JSR     CMD_EXECUTE          ; execute internal command
    18 4A0A 4C F2 49		                JMP     SH_CMD_PROMPT        ; endless loop
    19 						
    20 4A0D 20 0A 51		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    21 4A10 4C F2 49		                JMP     SH_CMD_PROMPT        ; endless loop
    22 						
    23 4A13 6C 8A 49		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    24 						
    25 				; Get Command String ***********************************************************
    26 4A16 20 39 4D		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    27 4A19 D0 03		                BNE     GET_CMD0
    28
    29 4A1B 4C AC 4A		                JMP     CMD_FOUND            ; empty command if first char is NULL
    30
    31 4A1E 20 AE 4A		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    32 4A21 AA			                TAX
    33 4A22 A0 00		                LDY     #$00
    34 4A24 8A			GET_CMD1        TXA                          	; try to find command in command table
    35 4A25					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4A25 D9 38 54				CMP	CHARS,Y
     2 4A28 F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    36 4A2A			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4A2A B9 38 54				LDA	CHARS,Y
     2 4A2D F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    37 4A2F 8A			                TXA
    38 4A30 C8 C8 C8		        :3      INY			     	; Y += 3
    39 4A33 4C 24 4A		                JMP     GET_CMD1	     	; branch always
    40
    41 4A36 C8			GET_CMD2        INY
    42 4A37 B9 38 54 C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    43 4A3D B9 38 54 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    44 4A42 A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    45 4A47 A6 AC		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    46 4A49			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: macros.inc]
     1 4A49 B1 E8				LDA	(STOL),Y
     2 4A4B F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    47 4A4D 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    48 4A54 E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    49 4A55 C8			                INY                          	; point to next char in command table
    50 4A56			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: macros.inc]
     1 4A56 CC 10 18				CPY	NEXTINDEX
     2 4A59 F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    51
    52 4A5B BD 00 14		                LDA     STRBUF,X             	; load char from command string
    53 4A5E 20 AE 4A		                JSR     UPPERCASE	     	; and convert it to uppercase
    54 4A61					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4A61 D1 E8				CMP	(STOL),Y
     2 4A63 F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    55
    56 4A65 AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    57 4A68 C8 C8		        :2      INY			     	; Y += 2
    58 4A6A 8C 10 18		                STY     NEXTINDEX
    59 4A6D 4C 47 4A		                JMP     GET_CMD_LOOP1	     	; branch always
    60
    61 4A70 B1 E8 8D 8A 49 C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    62 4A7B			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4A7B BD 00 14				LDA	STRBUF,X
     2 4A7E F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    63 4A80			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: macros.inc]
     1 4A80 C9 20				CMP	#SPC
     2 4A82 F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    64 4A84 18			CMD_NOT_FOUND   CLC
    65 4A85 60			                RTS
    66 				                
    67 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    68 4A86 A6 AC		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    69 4A88 BD 00 14		                LDA     STRBUF,X
    70 4A8B 20 AE 4A		                JSR     UPPERCASE            ; convert it to upper case
    71 4A8E			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: macros.inc]
     1 4A8E C9 41				CMP	#'A'			; 
     2 4A90 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    72 4A92			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: macros.inc]
     1 4A92 C9 5B				CMP	#'['			; 
     2 4A94 B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    73
    74 4A96 A8			                TAY
    75 4A97 BD 01 14		                LDA     STRBUF+1,X
    76 4A9A			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: macros.inc]
     1 4A9A C9 3A				CMP	#':'
     2 4A9C D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    77 4A9E 38			                SEC
    78 4A9F 98			                TYA
    79 4AA0 E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    80 4AA2			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: macros.inc]
     1 4AA2 A2 3D			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4AA4 A0 47			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    81 4AA6			                STXY    CMD_ADDR
Macro: STXY [Source: macros.inc]
     1 4AA6 8E 8A 49			STX	CMD_ADDR
     2 4AA9 8C 8B 49			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    82 4AAC 38			CMD_FOUND       SEC
    83 4AAD 60			                RTS
    84 				                
    85 				; **** Return Uppercase Character **********************************************
    86 				; Input:  A - Character
    87 				; Output: A - Uppercase Character
    88 				; ******************************************************************************
    89 4AAE			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: macros.inc]
     1 4AAE C9 61				CMP	#'a'			; 
     2 4AB0 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    90 4AB2			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: macros.inc]
     1 4AB2 C9 7B				CMP	#'z'+1			; 
     2 4AB4 B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    91 4AB6 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    92 4AB8 60			UPPERCASE_END   RTS				; return
    93
    94 				; **** Print Two Digit Number **************************************************
    95 				; Input: A - Number (0..99)
    96 				; ******************************************************************************
    97 4AB9 20 BD E0		NUMOUT          JSR     DEC2STR
    98 4ABC A2 01		                LDX     #$01
    99 4ABE B5 F8		NEXT_NUMOUT     LDA     NUM32,X
   100 4AC0 20 52 E0		                JSR     COUT
   101 4AC3					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4AC3 CA					DEX
     2 4AC4 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   102 4AC6 60			                RTS				; return
   103 				                
   104 				; **** Print Current Drive *****************************************************
   105 				;
   106 				; ******************************************************************************
   107 4AC7 AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   108 4ACA 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   109 4ACD 20 52 E0		                JSR     COUT		   ; print char
   110 4AD0 A9 3A		                LDA     #COLON		   ; ':'
   111 4AD2 4C 52 E0		                JMP     COUT		   ; print char and return
   112 				                
   113 				; **** Print Current Path ******************************************************
   114 				;
   115 				; ******************************************************************************
   116 4AD5 A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   117 4AD9 A6 D8		PR_PATH_LP	LDX	SAVEX
   118 4ADB BD 20 04				LDA     D_SUBDIR_NAME,X		; 
   119 4ADE 48					PHA
   120 4ADF 20 52 E0		                JSR     COUT		    	; print char
   121 4AE2 68					PLA
   122 4AE3 F0 04				BEQ	PR_PATH_DN		; End-of-String?
   123 						
   124 4AE5					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: macros.inc]
     1 4AE5 E6 D8				INC	SAVEX
     2 4AE7 D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   125 4AE9 60			PR_PATH_DN      RTS				; return
   126
   127 				; **** Print Drive and Path Prompt *********************************************
   128 				;
   129 				; ******************************************************************************
   130 4AEA 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   131 4AED 20 C7 4A		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   132 4AF0 20 D5 4A		                JSR     PRINT_PATH	   ; '\'
   133 4AF3 A9 3E		                LDA     #PROMPT		   ; '>'
   134 4AF5 4C 52 E0		                JMP     COUT		   ; print char and return
   135 				                
   136 				; **** Print Drive Label *******************************************************
   137 				;
   138 				; ******************************************************************************
   139 4AF8 48			PRINT_LABEL     PHA			   ; save A
   140 4AF9			                PHY			   ; save Y
Macro: PHY [Source: macros.inc]
     1 4AF9 98				TYA
     2 4AFA 48				PHA
Source: boot_sys_sh.asm
   141 4AFB			                PRSTR   MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTR [Source: macros.inc]
     1 4AFB A2 2A			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4AFD A0 53			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4AFF 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4B02 20 C7 4A		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   143 4B05			                PRSTR   MSG_LABEL2	   ; ' is '
Macro: PRSTR [Source: macros.inc]
     1 4B05 A2 3B			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4B07 A0 53			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4B09 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   144 4B0C 20 22 4B		                JSR     PRINT_FILENAME1    ; print volume-label
   145 4B0F 20 5A E0		                JSR     CROUT		   ; CR 2x
   146 4B12 20 5A E0		                JSR     CROUT
   147 4B15					PLY			   ; restore Y
Macro: PLY [Source: macros.inc]
     1 4B15 68				PLA
     2 4B16 A8				TAY
Source: boot_sys_sh.asm
   148 4B17 68			                PLA			   ; restore A
   149 4B18 60			                RTS
   150 				                
   151 				; **** Print Filename **********************************************************
   152 				;
   153 				; ******************************************************************************
   154 4B19 A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   155 4B1B					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4B1B AD 12 18				LDA	F_ATTRIBS
     3 4B1E 29 10				AND	#FA_DIRECTORY
     4 4B20 F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   156 4B22 A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   157 4B24 A0 00		PRINT_FILENAME2 LDY     #$00
   158 4B26			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: macros.inc]
     1 4B26 C0 08				CPY	#$08
     2 4B28 D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   159 4B2A 20 5E E0		                JSR     SPCOUT		    		; print space
   160 4B2D 8A			                TXA
   161 4B2E 20 52 E0		                JSR     COUT                		; yes, print divider char
   162 4B31 B1 A8		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   163 4B33 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   164 4B36 C8			                INY
   165 4B37			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: macros.inc]
     1 4B37 C0 0B				CPY	#D_ATTRIBUTES
     2 4B39 D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   166 4B3B 60			                RTS			    		; return
   167 				                
   168 				; **** Print File Info *********************************************************
   169 				; Input: F_ATTRIBS = File Attributes
   170 				; ******************************************************************************
   171 4B3C			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4B3C AD 12 18				LDA	F_ATTRIBS
     3 4B3F 29 10				AND	#FA_DIRECTORY
     4 4B41 F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   172 				                
   173 				; Print Directory Attribute ****************************************************
   174 4B43			                PRSTR   MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTR [Source: macros.inc]
     1 4B43 A2 40			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4B45 A0 53			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4B47 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   175 4B4A EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   176 4B52 4C 7F 4B				JMP     PRINT_ATTRIB
   177
   178 				; Print File Size **************************************************************
   179 4B55 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   180 4B58 20 5E E0		                JSR     SPCOUT
   181 4B5B EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   182 4B63 A2 00		NO_FCNT_CARRY   LDX     #$00
   183 4B65 A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   184 4B67 18			                CLC
   185 4B68 08			                PHP
   186 4B69 28			LOAD_SIZE       PLP
   187 4B6A B1 A8 95 F8		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   188 4B6E 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   189 4B74 08			                PHP
   190 4B75 C8			                INY
   191 4B76 E8			                INX
   192 4B77					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4B77 E0 04				CPX	#$04
     2 4B79 D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   193 4B7B 28			                PLP
   194 4B7C 20 7A 4C		                JSR     PRINT_INT32         		; print file size
   195 				                
   196 				; Print File Attributes ********************************************************
   197 4B7F 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   198 4B82					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: macros.inc]
     4 4B82 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4B85 29 02				AND	#(1 << 1)
     6 4B87 F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   199 4B89 A2 07		                LDX     #$07
   200 4B8B 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   201 4B8E			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: macros.inc]
     1 4B8E BD 0C 54				LDA	ATTRIB_VAL,X
     2 4B91 F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   202 4B93 B0 02		                BCS     SET_ATTRIB			; branch if printable
   203
   204 4B95 A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   205 4B97 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   206 4B9A			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: macros.inc]
     1 4B9A CA					DEX
     2 4B9B 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   207 4B9D 20 5E E0		                JSR     SPCOUT
   208 				                
   209 				; Print Date *******************************************************************
   210 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   211 				;              08-05 Month of year (1-12)
   212 				;              04-00 Day of month (1-32)
   213 				; ******************************************************************************
   214 4BA0 A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   215 4BA2 B1 A8 8D 71 4C	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   216 4BA7 29 1F		                AND     #$1F                		; mask day value
   217 4BA9 8D 72 4C		                STA     DAY
   218 4BAC C8			                INY
   219 4BAD B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   220 4BAF 4A			                LSR                         ; year in A
   221 4BB0 6E 71 4C		                ROR     MONTH
   222 4BB3 4E 71 4C 4E 71 4C +         :4      LSR     MONTH		    ; LSR 4
   223 4BBF 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   224 4BC2 8D 70 4C		                STA     YEAR
   225 4BC5 AD 72 4C		                LDA     DAY
   226 4BC8 20 B9 4A		                JSR     NUMOUT
   227 4BCB			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4BCB A9 2E			LDA	#'.'
     2 4BCD 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   228 4BD0 AD 71 4C		                LDA     MONTH
   229 4BD3 20 B9 4A		                JSR     NUMOUT
   230 4BD6			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4BD6 A9 2E			LDA	#'.'
     2 4BD8 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   231 4BDB AC 70 4C		                LDY     YEAR
   232 4BDE			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: macros.inc]
     1 4BDE C0 64				CPY	#100			; 
     2 4BE0 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   233
   234 4BE2 A9 14		                LDA     #20
   235 4BE4 20 B9 4A		                JSR     NUMOUT
   236 4BE7 98			                TYA
   237 4BE8 38 E9 64				SUB	#100		    ; same as SEC + SBC
   238 4BEB 4C F4 4B		                JMP     PRINT_YEAR
   239
   240 4BEE A9 13		CENTURY_19      LDA     #19
   241 4BF0 20 B9 4A		                JSR     NUMOUT
   242 4BF3 98			                TYA
   243 4BF4 20 B9 4A		PRINT_YEAR      JSR     NUMOUT
   244 4BF7 20 5E E0		                JSR     SPCOUT
   245 				                
   246 				; Print Time *******************************************************************
   247 				; Time Format: 15-11 Hours (0-23)
   248 				;              10-05 Minutes (0-59)
   249 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   250 				; ******************************************************************************
   251 4BFA A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   252 4BFC B1 A8 8D 73 4C	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   253 4C01 8D 73 4C		                STA     MINUTE
   254 4C04 C8			                INY
   255 4C05 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file last write time high byte
   256 				        .rept 3
   257 						LSR     
   258 				                ROR     MINUTE
   259 					.endr	
Source: REPT
   257 4C07 4A					LSR     
   257 4C08 6E 73 4C		                ROR     MINUTE
   257 4C0B 4A					LSR     
   257 4C0C 6E 73 4C		                ROR     MINUTE
   257 4C0F 4A					LSR     
   257 4C10 6E 73 4C		                ROR     MINUTE
Source: boot_sys_sh.asm
   260 4C13 4E 73 4C 4E 73 4C	        :2      LSR     MINUTE
   261 4C19 20 B9 4A		                JSR     NUMOUT
   262 4C1C			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: macros.inc]
     1 4C1C A9 3A			LDA	#':'
     2 4C1E 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   263 4C21 AD 73 4C		                LDA     MINUTE
   264 4C24 20 B9 4A		                JSR     NUMOUT		    ; print minutes
   265
   266 				; Print Cluster Number *********************************************************
   267 				; Only with /C parameter: Prints Cluster number AND LBA number
   268 				; ******************************************************************************
   269 4C27					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: macros.inc]
     4 4C27 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4C2A 29 08				AND	#(1 << 3)
     6 4C2C F0 41				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   270 4C2E 20 5E E0		                JSR	SPCOUT		    			; Print space
   271 4C31					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: macros.inc]
     1 4C31 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4C33 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4C35 85 FB				STA	NUM32+2+1
     5 4C37 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4C3A A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4C3C B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4C3E 85 FA				STA	NUM32+2
     5 4C40 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   272 4C43					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: macros.inc]
     1 4C43 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4C45 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4C47 85 F9				STA	NUM32+1
     5 4C49 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4C4C A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4C4E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4C50 85 F8				STA	NUM32
     5 4C52 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   273 4C55 20 5E E0				JSR	SPCOUT
   274 4C58 20 FF 40				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   275 4C5B					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 4C5B A5 FB			LDA	NUM32+2+1				; print MSB
     2 4C5D 20 91 E0			JSR	HEXOUT
     3 4C60 A5 FA			LDA	NUM32+2
     4 4C62 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4C65 A5 F9			LDA	NUM32+1				; print MSB
     2 4C67 20 91 E0			JSR	HEXOUT
     3 4C6A A5 F8			LDA	NUM32
     4 4C6C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   276 4C6F 60			PRINT_EXIT	RTS
   277
   278 4C70 00			YEAR		.byte 	$00
   279 4C71 00			MONTH		.byte 	$00
   280 4C72 00			DAY 		.byte	$00
   281 4C73 00			MINUTE		.byte 	$00
   282 				                
   283 				; **** Print 16 Bit Number *****************************************************
   284 				; Input: X,Y = Int16
   285 				; ******************************************************************************
   286 4C74 20 E8 4C		PRINT_INT16     JSR     BIN16_TO_BCD
   287 4C77 4C 7D 4C		                JMP     PRINT_NUM
   288 				                
   289 				; **** Print 32 Bit Number *****************************************************
   290 				; Input: NUM32[0..3] = Int32
   291 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   292 				; ******************************************************************************
   293 4C7A 20 F2 4C		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   294 4C7D A2 00		PRINT_NUM       LDX     #$00
   295 4C7F A0 0A		                LDY     #10
   296 4C81 18			                CLC                         ; save status bits
   297 4C82 08			PRINT_NUM1      PHP                         ; store current carry flag
   298 4C83 20 B9 4C		                JSR     PRINT_SEPARATOR
   299 4C86 BD 14 54		                LDA     BCD_VAL,X           ; load two decimal digits
   300 4C89 48			                PHA                         ; store A
   301 4C8A 98			                TYA                         ; move digit counter into A
   302 4C8B 4A			                LSR                         ; bit one into carry
   303 4C8C 68			                PLA                         ; restore A
   304 4C8D 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   305 						
   306 4C8F E8			                INX                         ; no, process digit 2
   307 4C90 29 0F		                AND     #$0F
   308 4C92 10 04		                BPL     SET_DIGIT2
   309 4C94 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   310 4C98 28			SET_DIGIT2      PLP
   311 4C99 B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   312 						
   313 4C9B			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: macros.inc]
     6 4C9B 29 0F				AND	#$0F
     7 4C9D D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   314 4C9F 98			                TYA
   315 4CA0			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: macros.inc]
     1 4CA0 C9 01				CMP	#1
     2 4CA2 D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   316 4CA4 A9 30		                LDA     #48                 ; yes, print 0
   317 4CA6 20 9A E0		                JSR     HEXDIG
   318 4CA9 18			                CLC                         ; number is 0
   319 4CAA 60			                RTS
   320 						
   321 4CAB 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   322 4CAE 18			                CLC
   323 4CAF 90 04		                BCC     NEXT_DIGIT	    ; 
   324 						
   325 4CB1 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   326 4CB4 38			                SEC                         ; no more leading 0s
   327 4CB5			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: macros.inc]
     1 4CB5 88					DEY
     2 4CB6 D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   328 4CB8 60			                RTS
   329 				                
   330 				; Print Thousands Separator ****************************************************
   331 4CB9 08			PRINT_SEPARATOR PHP                         ; save status bits
   332 4CBA			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4CBA C0 09				CPY	#$09
     2 4CBC F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   333 4CBE			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4CBE C0 06				CPY	#$06
     2 4CC0 F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   334 4CC2			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: macros.inc]
     1 4CC2 C0 03				CPY	#$03
     2 4CC4 D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   335 						
   336 4CC6 28			PRINT_SEP       PLP                         ; restore status bits
   337 4CC7 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   338 						
   339 4CC9 A9 2E		                LDA     #NUM_SEP
   340 4CCB 4C 52 E0		                JMP     COUT                ; print thousands seperator
   341 						
   342 4CCE 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   343 4CD1 28			NO_SEP          PLP                         ; clean up stack
   344 4CD2 60			                RTS
   345 				                
   346 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   347 				; INPUT:  A = BCD Number
   348 				; Output: A = Binary Number
   349 				; ******************************************************************************
   350 4CD3 85 F8		BCD_TO_BIN      STA     NUM32               ; save BCD number
   351 4CD5 29 F0		                AND     #$F0                ; and clear ones digit in A
   352 4CD7 4A			                LSR                         ; calc tens digit * 8
   353 4CD8 85 F9		                STA     NUM32+1             ; and store result
   354 4CDA 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   355 4CDC 18 65 F9 85 F9			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   356 4CE1 A5 F8		                LDA     NUM32               ; reload BCD number int A
   357 4CE3 29 0F		                AND     #$0F                ; and clear tens digit in A
   358 4CE5 65 F9		                ADC     NUM32+1             ; finally add both result
   359 4CE7 60			                RTS			    ; return
   360 				                
   361 				;**** Convert 16 Bit Binary Number To BCD **************************************
   362 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   363 				; OUTPUT: BCD_VAL[4..0] = Result
   364 				; ******************************************************************************
   365 4CE8			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: macros.inc]
     1 4CE8 86 F8			STX	NUM32
     2 4CEA 84 F9			STY	NUM32+1
Source: boot_sys_sh.asm
   366 4CEC A2 00 86 FA 86 FB			MWX	#$00 NUM32+2	    ; clear upper word
   367 				                
   368 				;**** Convert 32 Bit Binary Number To BCD **************************************
   369 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   370 				; OUTPUT: BCD_VAL[4..0] = Result
   371 				;*******************************************************************************
   372 4CF2 F8			BIN32_TO_BCD    SED                         ; set decimal mode
   373 4CF3 A2 04		                LDX     #$04
   374 4CF5 A9 00		                LDA     #$00                ; clear BCD result value
   375 4CF7 9D 14 54 CA		CLEAR_BCD       STA     BCD_VAL,X-
   376 4CFB 10 FA		                BPL     CLEAR_BCD
   377
   378 4CFD A2 20		                LDX     #$20                ; 32 source bits
   379 4CFF			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: macros.inc]
     1 4CFF 06 F8			ASL     NUM32		  		; SHL with C=0
     2 4D01 26 F9		        ROL     NUM32+1		  
     3 4D03 26 FA		        ROL     NUM32+2
     4 4D05 26 FB		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   380 4D07 AD 18 54 6D 18 54 + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   381 4D10 AD 17 54 6D 17 54 + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   382 4D19 AD 16 54 6D 16 54 + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   383 4D22 AD 15 54 6D 15 54 + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   384 4D2B AD 14 54 6D 14 54 + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   385 4D34			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: macros.inc]
     1 4D34 CA					DEX
     2 4D35 D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   386 4D37 D8			                CLD                         ; reset to binary mode
   387 4D38 60			                RTS
   388
   389 				; **** Get Command String ******************************************************
   390 				;
   391 				; ******************************************************************************
   392 4D39 A2 01		GET_CMD_STR     LDX     #$01
   393 4D3B			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4D3B BD 00 14				LDA	STRBUF,X
     2 4D3E F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   394 4D40			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: macros.inc]
     1 4D40 C9 20				CMP	#SPC
     2 4D42 D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   395 4D44 E8			SKIP_SPC_CHAR   INX
   396 4D45 4C 3B 4D		                JMP     GET_CMD_CHAR
   397 				                
   398 				; **** Get Parameter String ****************************************************
   399 				; Output: C = 1: Parameter; C = 0: Path
   400 				;         A    = $00 : End of parameter string
   401 				;         NCNT = Index to parameter
   402 				; ******************************************************************************
   403 4D48 A6 AC		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   404 4D4A 20 58 4D		                JSR     GET_PARM_CHAR
   405 4D4D					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: macros.inc]
     1 4D4D C9 2F				CMP	#OPT_SEP
     2 4D4F D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   406 4D51 E8			                INX			    ; next char
   407 4D52 BD 00 14		                LDA     STRBUF,X	    ; load parameter
   408 4D55 4C 6C 4D		                JMP     PARAM_STR	    ; OK and return
   409
   410 4D58			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4D58 BD 00 14				LDA	STRBUF,X
     2 4D5B F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   411 4D5D					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: macros.inc]
     1 4D5D C9 20				CMP	#SPC
     2 4D5F F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   412 4D61					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: macros.inc]
     1 4D61 C9 2F				CMP	#OPT_SEP
     2 4D63 F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   413 4D65 E8			                INX			    
   414 4D66 4C 58 4D		                JMP     GET_PARM_CHAR
   415
   416 4D69 18			PATH_STR        CLC			    ; C=0, it is a path
   417 4D6A 90 01		                BCC     END_PARAM	    ; branch always
   418
   419 4D6C 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   420 4D6D 86 AC		END_PARAM       STX     NCNT		    ; save index in parameter string
   421 4D6F 48			                PHA
   422 4D70 68			                PLA
   423 4D71 60			                RTS			    ; return
   424
   425 				; **** Internal Command Handlers ***********************************************
   426
   427 				; **** Directory Loop Call Back Functions **************************************
   428 				; Input : A - First character of filename
   429 				;         X - File Attributes
   430 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   431 				; ******************************************************************************
   432
   433 				; **** Print Directory Entry - Call Back Routine *******************************
   434 4D72			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4D72 E0 0F				CPX	#$0F
     2 4D74 F0 5C				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   435 4D76					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: macros.inc]
     1 4D76 C9 E5				CMP	#$E5
     2 4D78 F0 58				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   436 4D7A 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   437 4D7D 8A			                TXA
   438 4D7E 4A			                LSR     
   439 4D7F 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   440 4D80 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   441
   442 4D82			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: macros.inc]
     4 4D82 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4D85 29 04				AND	#(1 << 2)
     6 4D87 F0 49				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   443 4D89 4A			CHK_SYSTEM      LSR                         		; check if system file
   444 4D8A 4A			CHK_LABEL       LSR                         		; check if disk label
   445 				                ; #### PRINT LABEL DISABLED ####################################
   446 4D8B B0 45		                BCS     CB_PRINT_CONT       		; it's a label, skip to next entry
   447
   448 				                ;BCC     PRINT_DIR_ENTRY
   449 				                ;JSR     PRINT_LABEL         		; print disk label
   450 				                ;INC     LINE_CNT
   451 				                ;BNE     CHK_LINE_COUNT     		 ; branch always
   452 				                ; ##############################################################
   453 4D8D			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: macros.inc]
     1 4D8D AD 11 18				LDA	TERM_CHAR
     2 4D90 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   454 4D92 20 23 49		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   455 4D95 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   456
   457 4D97 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   458 4D9C 20 D3 46		                JSR     OS_DIR_LOOP         		; list files of sub directory
   459 4D9F 38			                SEC                         		; directory list finished
   460 4DA0 60			                RTS                         		; exit
   461
   462 4DA1 20 D4 4D		COMP_MASK       JSR     SH_COMP_MASK
   463 4DA4 90 2D		                BCC     CB_PRINT_END
   464
   465 4DA6 A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   466 4DAA 20 19 4B		                JSR     PRINT_FILENAME      		; print filename
   467 4DAD 20 3C 4B		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   468 4DB0 20 5A E0		                JSR     CROUT
   469 4DB3			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: macros.inc]
     4 4DB3 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DB6 29 01				AND	#(1 << 0)
     6 4DB8 F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   470 4DBA EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   471 4DBD A9 19		                LDA     #25
   472 4DBF					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: macros.inc]
     1 4DBF CD 14 18				CMP	LINE_CNT			; 
     2 4DC2 B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   473 4DC4 A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   474 4DC9 20 B4 50		                JSR     SH_PAUSE            		; wait for key press
   475 4DCC			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4DCC C9 1B				CMP	#27
     2 4DCE D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   476 4DD0 38			                SEC                         		; break dir loop
   477 4DD1 60			                RTS
   478 4DD2 18			CB_PRINT_CONT   CLC                         		; get next next entry
   479 4DD3 60			CB_PRINT_END    RTS
   480
   481 				; **** Compare File Name With Mask Using Wildcards *****************************
   482 				;
   483 				; ******************************************************************************
   484 4DD4			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: macros.inc]
     1 4DD4 C9 5C				CMP	#PATH_SEP
     2 4DD6 F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   485 4DD8 A0 0A		                LDY     #10                 			; compare all characters
   486 4DDA B9 E6 49		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   487 4DDD					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: macros.inc]
     1 4DDD C9 3F				CMP	#'?'
     2 4DDF F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   488 4DE1					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: macros.inc]
     1 4DE1 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4DE3 D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   489 						
   490 4DE5			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: macros.inc]
     1 4DE5 88					DEY
     2 4DE6 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   491 4DE8 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   492 4DE9 60			                RTS
   493 4DEA 18			COMP_NAME_NEQ   CLC
   494 4DEB 60			                RTS
   495
   496 				; ******************************************************************************
   497 				; ******************************************************************************
   498 4DEC 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   499 4DF0 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   500 				; + DRIVE
   501 				                
   502 4DF4 A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   503 4DF6 B9 04 04 99 EC 4D	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   504 4DFC B9 24 18 99 F0 4D + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   505 4E03 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   506 4E05 60			                RTS					; return
   507 				                
   508 4E06 A0 03		LOAD_ACT_DIR    LDY     #$03
   509 4E08 B9 EC 4D 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   510 4E0E B9 F0 4D 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   511 4E15 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   512 4E17 60			                RTS					; return
   513 				                
   514 				; **** Get Parameters from Command Line ****************************************
   515 				; Input:  Ptr[X:Y] to Parameter String
   516 				; Output: C = 0 - Error; C = 1 - No Error
   517 				; ******************************************************************************
   518 4E18 20 85 4E		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   519 4E1B A9 00		                LDA     #$00                ; set current command parameter value to 0
   520 4E1D 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   521 4E20 A0 01 84 AA		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   522 4E24 88			                DEY                         ; param mask pointer is set to 0
   523 4E25 20 48 4D		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   524 4E28 F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   525 4E2A B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   526 						
   527 4E2C 20 67 4E		                JSR     SH_GET_PATH         ; no, parse path parameter
   528 4E2F B0 EF		                BCS     GET_PARM2           ; more parameters
   529
   530 4E31 60			                RTS			    ; return
   531 						
   532 4E32 20 AE 4A		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   533 4E35 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   534 4E38 B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   535 4E3A			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: macros.inc]
     1 4E3A C9 20				CMP	#SPC
     2 4E3C F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   536 4E3E					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: macros.inc]
     1 4E3E CD 12 18				CMP	F_ATTRIBS
     2 4E41 D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   537 4E43 A5 AA		                LDA     MASK                ; load bit mask
   538 4E45 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   539 4E48 4C 1D 4E		                JMP     GET_PARM            ; get next parameter from command line
   540
   541 4E4B C8			NEXT_MASK       INY                         ; point to next char in param mask
   542 4E4C 06 AA		                ASL     MASK                ; shift bit mask to next position
   543 4E4E D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   544
   545 4E50 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   546 4E53			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: macros.inc]
     1 4E53 A2 9F			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 4E55 A0 53			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   547 4E57 20 1E 48		                JSR     OS_PRINT_ERR        ; and print it
   548 4E5A AD 12 18		                LDA     F_ATTRIBS
   549 4E5D 20 52 E0		                JSR     COUT                ; print unknown parameter char
   550 4E60 20 5A E0		                JSR     CROUT		    ; print CR
   551 4E63 18			                CLC			    ; C=0: error
   552 4E64 60			                RTS
   553 4E65 38			GET_PARMS_END   SEC			    ; C=1: OK
   554 4E66 60			                RTS
   555 				                
   556 				; ******************************************************************************
   557 4E67 A6 AC		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   558 4E69 A0 14		                LDY     #> STRBUF
   559 4E6B 20 23 48		                JSR     OS_PARSE_PATH
   560 4E6E B0 14		                BCS     GET_PATH_END
   561 4E70 D0 03		SH_ERROR        BNE     PARSE_ERR1
   562
   563 4E72 4C CB 51		                JMP     SH_NAME_ERR
   564
   565 4E75			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: macros.inc]
     1 4E75 C9 5C				CMP	#PATH_SEP
     2 4E77 D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   566 4E79 4C C4 51		                JMP     SH_DIR_ERR
   567
   568 4E7C			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: macros.inc]
     1 4E7C C9 FF				CMP	#$FF
     2 4E7E D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   569 4E80 4C BD 51		                JMP     SH_PATH_ERR
   570 4E83 18			GET_PATH_ERR    CLC
   571 4E84 60			GET_PATH_END    RTS
   572
   573 				; **** Set Pointer To Parameter Mask *******************************************
   574 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   575 				; ******************************************************************************
   576 4E85			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: macros.inc]
     1 4E85 86 E8			STX	STOL
     2 4E87 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   577 4E89 A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   578 4E8E A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   579 4E93 60			                RTS
   580
   581 				; Allowed Directory Options ****************************************************
   582 4E94 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   583 4E99 20			NO_PARMS        .by    ' '
   584
   585 				; **** DIR Command *************************************************************
   586 				; Prints a directory. The following optional parameters can be used:
   587 				; /P : 
   588 				; /A : Show attributes
   589 				; /H : Show hidden files
   590 				; /C : Show cluster number and LBA number
   591 				; ******************************************************************************
   592 4E9A 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   593 4E9D 20 F4 4D		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   594 4EA0			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: macros.inc]
     1 4EA0 A2 94			LDX	<DIR_PARMS				; MADS makes this immediate
     2 4EA2 A0 4E			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   595 4EA4 20 18 4E		                JSR     SH_GET_PARMS		; Get parameters from command-line
   596 4EA7 B0 03		                BCS     SH_DIR_START		; branch if parameter found
   597
   598 4EA9 4C 06 4E		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   599
   600 4EAC A2 00		SH_DIR_START    LDX     #$00
   601 4EAE 8A			                TXA
   602 4EAF 8D 14 18		                STA     LINE_CNT            	; reset line counter
   603 4EB2 85 EE		                STA     PSAV                	; reset file found flag
   604 4EB4 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   605 4EB8			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: macros.inc]
     1 4EB8 E0 08				CPX	#$08
     2 4EBA D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   606 4EBC			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: macros.inc]
     1 4EBC A2 72			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 4EBE A0 4D			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   607 4EC0 20 C7 46		                JSR     OS_FIND_ALL         	; find and print directory entries
   608 4EC3 20 06 4E		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   609 4EC6			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: macros.inc]
     1 4EC6 A5 EE				LDA	PSAV
     2 4EC8 D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   610 4ECA 4C B6 51		                JMP     SH_FILE_ERR         	; no, print error
   611
   612 4ECD 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   613 4ED0 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   614 4ED6 20 BA 4D		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   615 				                
   616 				; Print Total File Count
   617 4ED9			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: macros.inc]
     1 4ED9 AE 15 18			LDX	CURR_FILE_CNT
     2 4EDC AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   618 4EDF 20 74 4C		                JSR     PRINT_INT16		; print as word
   619 4EE2			                PRSTR   MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTR [Source: macros.inc]
     1 4EE2 A2 50			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 4EE4 A0 53			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 4EE6 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   620
   621 				; Print Total Used Bytes In Directory
   622 4EE9			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: macros.inc]
     1 4EE9 A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 4EEB A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   623 4EED 20 61 41		                JSR     LOAD_32			; NUM32 = total filesize
   624 4EF0 20 7A 4C		                JSR     PRINT_INT32		; print as int32
   625 4EF3			                PRSTR   MSG_BYTE_USED		; print ' bytes'
Macro: PRSTR [Source: macros.inc]
     1 4EF3 A2 66			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 4EF5 A0 53			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 4EF7 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   626
   627 				; Print Total Directory Count
   628 4EFA					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: macros.inc]
     1 4EFA AE 17 18			LDX	CURR_DIR_CNT
     2 4EFD AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   629 4F00 20 74 4C		                JSR     PRINT_INT16		; Print as word
   630 4F03			                PRSTR   MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTR [Source: macros.inc]
     1 4F03 A2 5B			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 4F05 A0 53			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 4F07 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   631
   632 				; **** Create Directory (MKDIR) Command ****************************************
   633 				;
   634 				; ******************************************************************************
   635 4F0A 20 F4 4D		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   636 4F0D			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: macros.inc]
     1 4F0D A2 99			LDX	<NO_PARMS				; MADS makes this immediate
     2 4F0F A0 4E			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   637 4F11 20 18 4E		                JSR     SH_GET_PARMS        	; get path
   638 4F14 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   639
   640 4F16 A9 10		                LDA     #FA_DIRECTORY		; create directory
   641 4F18 20 4B 46		                JSR     OS_CREATE           	; create directory
   642 4F1B B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   643
   644 4F1D			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: macros.inc]
     1 4F1D C9 FF				CMP	#$FF
     2 4F1F F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   645
   646 4F21 20 D9 51		                JSR     SH_WRITE_ERR        	; it was a write error
   647 4F24 90 03		                BCC     SH_MKDIR_END        	; branch always
   648
   649 4F26 20 D2 51		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   650 4F29 4C 06 4E		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   651
   652 				; **** Check if Current Dir. ***************************************************
   653 				; Check if directory entered is current dir (..).
   654 				; Output: C=0: not a current dir, C=1: is current dir.
   655 				; ******************************************************************************
   656 4F2C A0 00		IS_FNAME_CURDIR	LDY	#0
   657 4F2E B9 E6 49				LDA	FILENAME,Y
   658 4F31					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 4F31 C9 2E				CMP	#'.'
     2 4F33 D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   659 4F35 C8					INY
   660 4F36					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: macros.inc]
     1 4F36 B9 E6 49				LDA	FILENAME,Y
     2 4F39 D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   661 4F3B F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   662
   663 				; **** Check if Parent Dir. ************************************************
   664 				; Check if current directory is parent dir (..).
   665 				; Output: C=0: not a parent dir, C=1: is parent dir.
   666 				; ******************************************************************************
   667 4F3D A0 00		IS_FNAME_PARENT	LDY	#0
   668 4F3F B9 E6 49				LDA	FILENAME,Y
   669 4F42					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 4F42 C9 2E				CMP	#'.'
     2 4F44 D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   670 4F46 C8					INY
   671 4F47 B9 E6 49				LDA	FILENAME,Y
   672 4F4A					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 4F4A C9 2E				CMP	#'.'
     2 4F4C D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   673 4F4E C8					INY
   674 4F4F					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: macros.inc]
     1 4F4F B9 E6 49				LDA	FILENAME,Y
     2 4F52 D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   675
   676 4F54 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   677 4F55 60					RTS
   678 4F56 18			NOT_FNAME	CLC				; The filename is not . or ..
   679 4F57 60					RTS
   680 						
   681 				; **** Convert filename to FN83 type filename **********************************
   682 				; INPUT: ssptr_l/ssptr_h pointer to filename
   683 				; OUTPUT: converted filename in FN83
   684 				; ******************************************************************************
   685 4F58 A0 00		FNAME2FN83	LDY	#0
   686 4F5A B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   687 4F5C					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: macros.inc]
     1 4F5C C9 2E				CMP	#'.'
     2 4F5E F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   688 						
   689 4F60 C8			CPFNCNT		INY
   690 4F61					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: macros.inc]
     1 4F61 C0 0B				CPY	#D_ATTRIBUTES
     2 4F63 D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   691 4F65 F0 15				BEQ	EXT_DN			; branch always if no dot was found
   692
   693 4F67			FN83_DOTFND	; Found a dot
   694 4F67 A2 08				LDX	#8
   695 4F69 C8					INY				; points to char next to '.'
   696 4F6A B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get extension char.
   697 4F6C					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: macros.inc]
     1 4F6C 9D E6 49				STA	FILENAME,X
     2 4F6F F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   698 4F71 C8					INY
   699 4F72 E8					INX
   700 4F73					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: macros.inc]
     1 4F73 E0 0B				CPX	#D_ATTRIBUTES
     2 4F75 D0 F3				BNE	CPFN83_2
Source: boot_sys_sh.asm
   701 						
   702 4F77 A9 00 9D E6 49			MVA	#0 FILENAME,X		; Add '\0' to filename
   703 4F7C A0 00		EXT_DN		LDY	#0
   704 4F7E B1 78 99 E6 49	CPFN83_3	MVA	(ssptr_l),Y FILENAME,Y
   705 4F83					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: macros.inc]
     1 4F83 C9 2E				CMP	#'.'
     2 4F85 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   706 						
   707 4F87 C8					INY
   708 4F88					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 4F88 C0 08				CPY	#8
     2 4F8A D0 F2				BNE	CPFN83_3
Source: boot_sys_sh.asm
   709 4F8C 60					RTS				; return
   710 						
   711 4F8D A9 20 99 E6 49 C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   712 4F93					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 4F93 C0 08				CPY	#8
     2 4F95 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   713 4F97 60			CPFN_DN		RTS				; return
   714 						
   715 				; **** CFC_LOAD routine for CF-IDE driver **************************************
   716 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP CFC_LOAD_VEC.
   717 				; ******************************************************************************
   718 4F98			CFC_LOAD	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 4F98 8E D6 4F			STX	FNAME_PTR
     2 4F9B 8C D7 4F			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   719 4F9E					PRSTR	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTR [Source: macros.inc]
     1 4F9E A2 CB			LDX	<TXT_LOAD				; MADS makes this immediate
     2 4FA0 A0 4F			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 4FA2 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   720 						;LDXY	FNAME_PTR
   721 4FA5					LDXY	ssptr_l
Macro: LDXY [Source: macros.inc]
     1 4FA5 A6 78			LDX	SSPTR_L
     2 4FA7 A4 79			LDY	SSPTR_L+1
Source: boot_sys_sh.asm
   722 4FA9 20 82 F6				JSR	OS_STRING_OUT		; Print filename
   723 4FAC 20 5E E0				JSR	SPCOUT			; Print CR
   724 4FAF 20 58 4F				JSR	FNAME2FN83		; Convert filename to FN83 filename
   725 4FB2					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 4FB2 A9 5B			LDA	#'['
     2 4FB4 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   726 4FB7					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 4FB7 A2 E6			LDX	<FILENAME				; MADS makes this immediate
     2 4FB9 A0 49			LDY	>FILENAME
Source: boot_sys_sh.asm
   727 4FBB 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   728 4FBE					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4FBE A9 5D			LDA	#']'
     2 4FC0 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   729 4FC3 20 F4 4D				JSR     SAVE_ACT_DIR        	; save actual directory LBA
   730 4FC6 20 19 51				JSR	SH_LOAD_BAS		; Load .bas file in memory
   731 4FC9 38					SEC				; C=1: OK
   732 4FCA 60					RTS				; return
   733
   734 4FCB 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
   735 4FD6 00 00		FNAME_PTR	.word 	$0000
   736
   737 				; **** CFC_SAVE routine for CF-IDE driver **************************************
   738 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP CFC_SAVE_VEC.
   739 				; ******************************************************************************
   740 4FD8			CFC_SAVE	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 4FD8 8E D6 4F			STX	FNAME_PTR
     2 4FDB 8C D7 4F			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   741 4FDE					PRSTR	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTR [Source: macros.inc]
     1 4FDE A2 02			LDX	<TXT_SAVE				; MADS makes this immediate
     2 4FE0 A0 50			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 4FE2 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   742 4FE5					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: macros.inc]
     1 4FE5 AD 01 20			LDA	$2000+1				; print MSB
     2 4FE8 20 91 E0			JSR	HEXOUT
     3 4FEB AD 00 20			LDA	$2000
     4 4FEE 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   743 4FF1 20 5E E0				JSR	SPCOUT		
   744 4FF4					LDXY	FNAME_PTR
Macro: LDXY [Source: macros.inc]
     1 4FF4 AE D6 4F			LDX	FNAME_PTR
     2 4FF7 AC D7 4F			LDY	FNAME_PTR+1
Source: boot_sys_sh.asm
   745 4FFA 20 82 F6				JSR	OS_STRING_OUT		; Print filename
   746 4FFD 20 5A E0				JSR	CROUT
   747 5000 38					SEC				; C=1: OK
   748 5001 60					RTS				; return
   749
   750 5002 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
   751
   752 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   753 				; Check if directory entered is current dir (..).
   754 				; Output: C=0: not a current dir, C=1: is current dir.
   755 				; ******************************************************************************
   756 500E A0 00		ADD_SUBDIR_NAME	LDY	#0
   757 5010			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5010 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5013 F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   758 5015 C8					INY
   759 5016 D0 F8				BNE	FIND_EOS			; branch always
   760 5018 60					RTS
   761
   762 5019			SUBDIR_EOS	CPY.EQ	#1 CP_INIT		; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 5019 C0 01				CPY	#1
     2 501B F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   763 501D A9 5C 99 20 04			MVA	#BSLASH D_SUBDIR_NAME,Y	; add '\' to subdir name
   764 5022 C8					INY
   765 5023 A2 00		CP_INIT		LDX	#0
   766 5025 BD E6 49 99 20 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   767 502B F0 06				BEQ	SUBDIR_X		; exit if $00 found
   768 						
   769 502D C8					INY				; index in D_SUBDIR_NAME
   770 502E E8					INX				; index in FILENAME
   771 502F					CPX.NE	#D_ATTRIBUTES CP_FNAME	; branch if not at max filename yet
Macro: CPX.NE [Source: macros.inc]
     1 502F E0 0B				CPX	#D_ATTRIBUTES
     2 5031 D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   772 5033 60			SUBDIR_X	RTS				; return if done
   773 						
   774 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   775 				; ******************************************************************************
   776 5034 A0 00		DEL_SUBDIR_NAME	LDY	#0
   777 5036			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS2	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5036 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5039 F0 04				BEQ	SUBDIR_EOS2
Source: boot_sys_sh.asm
   778 503B C8					INY
   779 503C D0 F8				BNE	FIND_EOS2			; branch always
   780 503E 60			DEL_SUBDIR_X	RTS
   781
   782 503F 88			SUBDIR_EOS2	DEY				; goto last char before $00
   783 5040 B9 20 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y		; get char from D_SUBDIR_NAME
   784 5043					CMP.EQ	#BSLASH BSLASH_FND	; branch if filename separator found
Macro: CMP.EQ [Source: macros.inc]
     1 5043 C9 5C				CMP	#BSLASH
     2 5045 F0 03				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   785 5047					DEY.NE	SUBDIR_LP1		; branch always
Macro: DEY.NE [Source: macros.inc]
     1 5047 88					DEY
     2 5048 D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   786
   787 504A			BSLASH_FND	CPY.EQ	#0 DSNM_X		; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 504A C0 00				CPY	#0
     2 504C F0 05				BEQ	DSNM_X
Source: boot_sys_sh.asm
   788 504E A9 00 99 20 04			MVA	#0 D_SUBDIR_NAME,Y	; replace '\' with '\0' in D_SUBDIR_NAME
   789 5053 60			DSNM_X		RTS				; and return
   790
   791 				; **** Change Directory Command ************************************************
   792 				;
   793 				; ******************************************************************************
   794 5054 20 F4 4D		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   795 5057			                LDXYI   NO_PARMS
Macro: LDXYI [Source: macros.inc]
     1 5057 A2 99			LDX	<NO_PARMS				; MADS makes this immediate
     2 5059 A0 4E			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   796 505B 20 18 4E		                JSR     SH_GET_PARMS		; get subdir name
   797 505E 90 26		                BCC     SH_CD_END		; C=0: no name entered
   798
   799 5060			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: macros.inc]
     1 5060 AD 11 18				LDA	TERM_CHAR
     2 5063 D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   800 5065 20 BD 46		                JSR     OS_FIND_PATH		; loop through dir to find path
   801 5068 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   802 						
   803 506A A0 00				LDY	#0			; add '\0' to string
   804 506C B9 E6 49		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   805 506F					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: macros.inc]
     1 506F C9 20				CMP	#' '
     2 5071 F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   806 5073 C8					INY
   807 5074					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: macros.inc]
     1 5074 C0 0B				CPY	#D_ATTRIBUTES
     2 5076 D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   808 						
   809 5078 A9 00 99 E6 49	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   810 507D 20 3D 4F				JSR	IS_FNAME_PARENT		; is dir .. ?
   811 5080 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   812 						
   813 5082 20 34 50				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   814 5085 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   815 5086 60			SH_CD_END	RTS
   816
   817 5087 20 2C 4F		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   818 508A B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   819 						
   820 508C 20 0E 50				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   821 508F 4C 85 50				JMP	SH_CD_EXIT_OK		; branch always
   822 						
   823 5092 20 06 4E		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   824 5095 20 5A E0		                JSR     CROUT			; print CR
   825 5098 4C BD 51		                JMP     SH_PATH_ERR		; Print 'Path not found'
   826
   827 				; **** Delete Command **********************************************************
   828 				;
   829 				; ******************************************************************************
   830
   831 				; ########## TEMP Checking for first free cluster #################
   832 509B 20 C0 44		SH_DEL          JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 0L
   833 509E 20 D1 44		                JSR 	OS_NEXT_FREE_CLUSTER
   834 50A1 A0 03				LDY 	#3
   835 50A3			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: macros.inc]
     1 50A3 98				TYA
     2 50A4 48				PHA
Source: boot_sys_sh.asm
   836 50A5 B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   837 50A8 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   838 50AB					PLY				; restore Y
Macro: PLY [Source: macros.inc]
     1 50AB 68				PLA
     2 50AC A8				TAY
Source: boot_sys_sh.asm
   839 50AD					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 50AD 88					DEY
     2 50AE 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   840 50B0 60			                RTS
   841
   842 				; **** Clear Screen Command ****************************************************
   843 				;
   844 				; ******************************************************************************
   845 50B1 4C B5 E0		SH_CLS          JMP     CLRSCRN
   846
   847 				; **** Pause Command ***********************************************************
   848 				; Output: A - pressed key char
   849 				;         C = 0 ESC key pressed, C = 1 else
   850 				; ******************************************************************************
   851 50B4			SH_PAUSE        PRSTR   MSG_PAUSE          	; print pause message
Macro: PRSTR [Source: macros.inc]
     1 50B4 A2 19			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 50B6 A0 53			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 50B8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   852 50BB 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   853 50BE 48			                PHA
   854 50BF 20 5A E0		                JSR     CROUT
   855 50C2 68			                PLA
   856 50C3 60			                RTS
   857 				                
   858 				; **** Echo Command ************************************************************
   859 				;
   860 				; ******************************************************************************
   861 50C4			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 50C4 BD 00 14				LDA	STRBUF,X
     2 50C7 F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   862 50C9 8A			                TXA
   863 50CA A8			                TAY
   864 50CB C8			                INY
   865 50CC 20 85 E0		                JSR     WRSTR
   866 50CF 20 5A E0		                JSR     CROUT
   867 50D2 60			SH_ECHO_END     RTS
   868
   869 				; **** Goto Command ************************************************************
   870 				;
   871 				; ******************************************************************************
   872 50D3 60			SH_GOTO         RTS
   873
   874 				; **** If Command **************************************************************
   875 				;
   876 				; ******************************************************************************
   877 50D4 60			SH_IF           RTS
   878
   879 				; **** Rem Command *************************************************************
   880 				;
   881 				; ******************************************************************************
   882 50D5			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: macros.inc]
     1 50D5 A5 DC			LDA	BLKBUF
     2 50D7 48				PHA
     3 50D8 A5 DD			LDA	BLKBUF+1
     4 50DA 48				PHA
Source: boot_sys_sh.asm
   883 50DB 20 E9 51				JSR	GET_SIS
   884 50DE					PLW	BLKBUF
Macro: PLW [Source: macros.inc]
     1 50DE 68				PLA
     2 50DF 85 DD			STA	BLKBUF+1
     3 50E1 68				PLA
     4 50E2 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
   885 50E4 60					RTS
   886 				                
   887 				; **** BASIC Command ***********************************************************
   888 				; Executes Basic in ROM. Return with 'DOS' command. 
   889 				; ******************************************************************************
   890 50E5 20 0A E0		SH_BASIC        JSR	SWITCH_TO_ROM		; Make sure BASIC ROM is enabled
   891 50E8 A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
   892 50EA					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: macros.inc]
     1 50EA C9 B1				CMP	#$B1
     2 50EC D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
   893 						
   894 50EE 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
   895 50F1 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
   896
   897 				; **** BRUN Command ************************************************************
   898 				;
   899 				; ******************************************************************************
   900 50F4 20 F4 4D		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
   901 50F7			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 50F7 A2 99			LDX	<NO_PARMS				; MADS makes this immediate
     2 50F9 A0 4E			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   902 50FB 20 18 4E		                JSR     SH_GET_PARMS
   903 50FE 90 05		                BCC     SH_BRUN_END
   904
   905 5100 20 C3 46		                JSR     OS_FIND_FILE
   906 5103 90 00		                BCC     SH_BRUN_END
   907
   908 				                ;JSR     OS_LOAD_BIN
   909 5105 20 06 4E		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   910 5108 60			                RTS
   911 				                
   912 				; **** BLOAD Command ***********************************************************
   913 				;
   914 				; ******************************************************************************
   915 5109 60			SH_BLOAD        RTS
   916
   917 				; ******************************************************************************
   918 510A 20 F4 4D		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
   919 510D			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 510D A2 99			LDX	<NO_PARMS				; MADS makes this immediate
     2 510F A0 4E			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   920 5111 20 85 4E		                JSR     SET_PARM_MASK
   921 5114 20 67 4E		                JSR     SH_GET_PATH         ; get file path
   922 5117 90 66		                BCC     SH_RUN_END
   923
   924 						; This is the entry-point for loading a .BAS file into memory
   925 5119 AD EE 49		SH_LOAD_BAS     LDA     FILENAME+8
   926 511C			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: macros.inc]
     1 511C C9 20				CMP	#SPC
     2 511E D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
   927 5120					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: macros.inc]
     1 5120 A0 02			LDY	#3-1
     2 5122 B9 2F 54 99 EE 49 + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 5129 10 F7			BPL	lp
Source: boot_sys_sh.asm
   928
   929 						; Check for .COM file
   930 512B A0 02		SH_RUN1         LDY     #$02
   931 512D B9 2F 54		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
   932 5130					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: macros.inc]
     1 5130 D9 EE 49				CMP	FILENAME+8,Y
     2 5133 D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
   933 5135			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5135 88					DEY
     2 5136 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
   934 				                
   935 5138 A9 01 8D 1F 44			MVA	#1 FTYPE	    	; 1 = .COM file
   936 513D D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
   937
   938 513F A0 02		CHK_BASF	LDY     #$02
   939 5141 B9 35 54		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
   940 5144			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: macros.inc]
     1 5144 D9 EE 49				CMP	FILENAME+8,Y
     2 5147 D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
   941
   942 5149			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5149 88					DEY
     2 514A 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
   943 				                
   944 514C A9 00 8D 1F 44			MVA	#0 FTYPE	    	; 0 = .BAS file
   945 5151 F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
   946
   947 5153 A0 02		CHK_EXEF	LDY     #$02
   948 5155 B9 32 54		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
   949 5158			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: macros.inc]
     1 5158 D9 EE 49				CMP	FILENAME+8,Y
     2 515B D0 22				BNE	SH_RUN_END
Source: boot_sys_sh.asm
   950
   951 515D			                DEY.PL	CMP_EXT_EXE	    ; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 515D 88					DEY
     2 515E 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
   952 				                
   953 5160 A9 02 8D 1F 44			MVA	#2 FTYPE	    ; 2 = .EXE file
   954 5165 20 C3 46		SH_RUN_FF       JSR     OS_FIND_FILE        ; check if file with this extension exists
   955 5168 B0 12		                BCS     SH_RUN3             ; yes, load file
   956
   957 516A 20 82 51		                JSR     SH_SET_SYS_DIR      ; no, search in system directory
   958 516D 90 05		                BCC     SH_RUN_ERR          ; system directory does not exist
   959
   960 516F 20 C3 46		SH_RUN2         JSR     OS_FIND_FILE	    ; find file with this extension in root-dir
   961 5172 B0 08		                BCS     SH_RUN3		    ; branch if found
   962
   963 5174 20 5A E0		SH_RUN_ERR      JSR     CROUT		    ; print CR
   964 5177 20 B6 51		                JSR     SH_FILE_ERR         ; file does not exist
   965 517A 90 03		                BCC     SH_RUN_END	    ; branch always
   966
   967 517C 20 32 44		SH_RUN3         JSR     OS_LOAD_FILE	    ; Load .bas file or load/run .com/.exe file
   968 517F 4C 06 4E		SH_RUN_END      JMP     LOAD_ACT_DIR        ; restore actual directory LBA and return
   969 				                
   970 				; **** Set System Directory ****************************************************
   971 				; Output: C = 0 - Error
   972 				; ******************************************************************************
   973 5182 A2 0A		SH_SET_SYS_DIR  LDX     #10
   974 5184 BD E6 49 9D 24 54	SAVE_NAME       MVA	FILENAME,X   NAME_SAVE,X	; NAME_SAVE = FILENAME
   975 518A BD 19 54 9D E6 49 + 		MVA	SYSTEM_DIR,X FILENAME,X-	; FILENAME = SYSTEM_DIR
   976 5191 10 F1		                BPL     SAVE_NAME			; branch if not done
   977
   978 5193 20 9A 47		                JSR     OS_SET_ROOT_DIR
   979 5196					LDXYI	CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 5196 A2 23			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 5198 A0 49			LDY	>CB_FIND_SUBDIR
Source: boot_sys_sh.asm
   980 519A 20 CB 46		                JSR     OS_FIND             		; find subdirectory
   981 519D 90 0C		                BCC     SH_SYS_DIR_END
   982
   983 519F			                MVAX	11 NAME_SAVE FILENAME		; FILENAME = NAME_SAVE
Macro: MVAX [Source: macros.inc]
     1 519F A2 0A			LDX	#11-1
     2 51A1 BD 24 54 9D E6 49 + lp	MVA	NAME_SAVE,X FILENAME,X-
     3 51A8 10 F7			BPL	lp
Source: boot_sys_sh.asm
   984 51AA 38			                SEC
   985 51AB 60			SH_SYS_DIR_END  RTS
   986
   987 				; **** Monitor call-back Routine ************************************************
   988 51AC			SH_MONITOR      PRSTR   MSG_MONITOR
Macro: PRSTR [Source: macros.inc]
     1 51AC A2 F0			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 51AE A0 53			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 51B0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   989 51B3 4C 03 E0		                JMP     MON_WARM_START
   990 				                
   991 				.macro	PR_ERR	msg
   992 						LDXYI	:msg
   993 						JMP	OS_PRINT_ERR
   994 				.endm
   995 				; **** Error Routines **********************************************************
   996 51B6			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51B6 A2 7F			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 51B8 A0 53			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 51BA 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
   997 51BD			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51BD A2 8F			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 51BF A0 53			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 51C1 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
   998 51C4			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51C4 A2 C2			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 51C6 A0 53			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 51C8 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
   999 51CB			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51CB A2 B0			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 51CD A0 53			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 51CF 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1000 51D2			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51D2 A2 D5			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 51D4 A0 53			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 51D6 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1001 51D9			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 51D9 A2 FE			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 51DB A0 53			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 51DD 4C 1E 48				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1002 				                
  1003 				; Inits BLKBUF to SIS_BUFF **************************************
  1004 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1005 				; ***************************************************************
  1006 51E0 A9 00 85 DC A9 55 + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1007 51E8 60					RTS
  1008
  1009
  1010 				; Get Info from System Information Sector **************************************
  1011 51E9 20 E0 51		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1012 51EC					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START
Macro: LDXYI [Source: macros.inc]
     1 51EC A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 51EE A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1013 51F0 20 4B 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1014 51F3					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: macros.inc]
     1 51F3 A2 03			LDX	#4-1
     2 51F5 BD 00 04 9D C3 52 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 51FC 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1015 51FE					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 51FE A9 5B			LDA	#'['
     2 5200 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1016 5203					PRHEX32	SYS_INFO_LBA			; print SYS_INFO_LBA as 32 bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 5203 AD C6 52			LDA	SYS_INFO_LBA+2+1				; print MSB
     2 5206 20 91 E0			JSR	HEXOUT
     3 5209 AD C5 52			LDA	SYS_INFO_LBA+2
     4 520C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 520F AD C4 52			LDA	SYS_INFO_LBA+1				; print MSB
     2 5212 20 91 E0			JSR	HEXOUT
     3 5215 AD C3 52			LDA	SYS_INFO_LBA
     4 5218 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1017 521B					PRCH	'|'
Macro: PRCH [Source: macros.inc]
     1 521B A9 7C			LDA	#'|'
     2 521D 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1018 5220					PRHEX16	SIS_OFFSET			; print SIS_OFFSET as 16 bit hex number
Macro: PRHEX16 [Source: macros.inc]
     1 5220 AD 31 55			LDA	SIS_OFFSET+1				; print MSB
     2 5223 20 91 E0			JSR	HEXOUT
     3 5226 AD 30 55			LDA	SIS_OFFSET
     4 5229 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
  1019 522C					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 522C A9 5D			LDA	#']'
     2 522E 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1020 						
  1021 5231 18 AD C3 52 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1022 5244 AD C5 52				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1023 5247 69 00				ADC	#0
  1024 5249 8D C5 52				STA	SYS_INFO_LBA+2
  1025 524C AD C6 52				LDA	SYS_INFO_LBA+3
  1026 524F 69 00				ADC	#0
  1027 5251 8D C6 52				STA	SYS_INFO_LBA+3
  1028 						
  1029 5254					PRSTR	TXT_SYS_INFO			; print SYS_INFO_LBA
Macro: PRSTR [Source: macros.inc]
     1 5254 A2 C7			LDX	<TXT_SYS_INFO				; MADS makes this immediate
     2 5256 A0 52			LDY	>TXT_SYS_INFO
Source: boot_sys_sh.asm
     2 5258 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1030 525B					PRHEX32	SYS_INFO_LBA			; macro print SYS_INFO_LBA as 32 bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 525B AD C6 52			LDA	SYS_INFO_LBA+2+1				; print MSB
     2 525E 20 91 E0			JSR	HEXOUT
     3 5261 AD C5 52			LDA	SYS_INFO_LBA+2
     4 5264 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5267 AD C4 52			LDA	SYS_INFO_LBA+1				; print MSB
     2 526A 20 91 E0			JSR	HEXOUT
     3 526D AD C3 52			LDA	SYS_INFO_LBA
     4 5270 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1031
  1032 5273 20 E0 51				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1033 5276					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: macros.inc]
     1 5276 A2 C3			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5278 A0 52			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1034 527A 20 4B 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1035 527D					PRSTR	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTR [Source: macros.inc]
     1 527D A2 D6			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 527F A0 52			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 5281 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1036 5284					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: macros.inc]
     1 5284 AD EF 56			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 5287 20 91 E0			JSR	HEXOUT
     3 528A AD EE 56			LDA	SIS_BUFF+$01EC+2
     4 528D 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5290 AD ED 56			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 5293 20 91 E0			JSR	HEXOUT
     3 5296 AD EC 56			LDA	SIS_BUFF+$01EC
     4 5299 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1037 529C					PRSTR	TXT_FREE_KB			; print 'Free Clusters:'
Macro: PRSTR [Source: macros.inc]
     1 529C A2 EB			LDX	<TXT_FREE_KB				; MADS makes this immediate
     2 529E A0 52			LDY	>TXT_FREE_KB
Source: boot_sys_sh.asm
     2 52A0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1038 				;		PRHEX32	SIS_BUFF+$01E8
  1039 52A3					MVAX	4 SIS_BUFF+$01E8 NUM32		; NUM32 = #Free Clusters
Macro: MVAX [Source: macros.inc]
     1 52A3 A2 03			LDX	#4-1
     2 52A5 BD E8 56 95 F8 CA	lp	MVA	SIS_BUFF+$01E8,X NUM32,X-
     3 52AB 10 F8			BPL	lp
Source: boot_sys_sh.asm
  1040 52AD 20 7A 4C				JSR	PRINT_INT32			; Print as decimal number
  1041 52B0					PRSTR	TXT_KB
Macro: PRSTR [Source: macros.inc]
     1 52B0 A2 FC			LDX	<TXT_KB				; MADS makes this immediate
     2 52B2 A0 52			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 52B4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1042
  1043 52B7					LDXYI	TXT_FBAS
Macro: LDXYI [Source: macros.inc]
     1 52B7 A2 06			LDX	<TXT_FBAS				; MADS makes this immediate
     2 52B9 A0 53			LDY	>TXT_FBAS
Source: boot_sys_sh.asm
  1044 52BB					STXY	ssptr_l				; simulate BASIC call
Macro: STXY [Source: macros.inc]
     1 52BB 86 78			STX	SSPTR_L
     2 52BD 84 79			STY	SSPTR_L+1
Source: boot_sys_sh.asm
  1045 52BF 20 98 4F				JSR	CFC_LOAD			; DEBUG TEST
  1046 52C2 60					RTS
  1047 						
  1048 52C3 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1049 52C7 53 59 53 5F 49 4E + TXT_SYS_INFO	.by	'SYS_INFO_LBA:$' $00
  1050 52D6 2C 20 31 73 74 20 + TXT_FFREE_CLST	.by	', 1st Free Cluster:$' $00
  1051 52EB 2C 20 46 72 65 65 + TXT_FREE_KB	.by	', Free Clusters:' $00
  1052 52FC 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1053 5306 74 65 73 74 2E 62 + TXT_FBAS	.by	'test.bas' $00
  1054
  1055 530F 20 E0 51		WRITE_SIS	JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1056 5312					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: macros.inc]
     1 5312 A2 C3			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5314 A0 52			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1057 5316 4C 1D 42				JMP 	DEV_WR_LBLK           		; Write SIS to disk and return
  1058
  1059 				; **** Data Area ***************************************************************
  1060 				; ******************************************************************************
  1061
  1062 				; String Data Area *************************************************************
  1063 5319 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1064 532A 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1065 533B 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1066 5340 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1067 5350 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1068 535B 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)  ' CR $00
  1069 5366 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1070 536E 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1071 537F 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1072 538F 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1073 539F 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1074 53B0 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1075 53C2 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1076 53D5 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1077 53F0 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1078 53FE 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1079
  1080 				; ############################################
  1081 540C 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1082 5414 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1083 5419 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1084 5424 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1085 542F 43 4F 4D		EXT_COM         .by    'COM'
  1086 5432 45 58 45		EXT_EXE		.by    'EXE'
  1087 5435 42 41 53		EXT_BAS		.by    'BAS'
  1088 				                
  1089 				; Command Table ****************************************************************
  1090 5438 42 54 54		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1091 543B 43 69 54				dta	'C' , a(CMD_CD)		
  1092 543E 44 73 54				dta	'D' , a(CMD_DIR)		
  1093 5441 45 7E 54				dta	'E' , a(CMD_ECHO)		
  1094 5444 47 85 54				dta	'G' , a(CMD_GOTO)		
  1095 5447 49 8C 54				dta	'I' , a(CMD_IF)		
  1096 544A 4D 91 54				dta	'M' , a(CMD_MKDIR)		
  1097 544D 50 9E 54				dta	'P' , a(CMD_PAUSE)		
  1098 5450 52 A6 54				dta	'R' , a(CMD_REM)		
  1099 5453 00					.byte 	$00
  1100
  1101 5454 05 41 53 49 43 E5 + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1102 545B 05 4C 4F 41 44 09 + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1103 5462 04 52 55 4E F4 50 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1104 5469 02 44 54 50		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1105 546D 03 4C 53 B1 50 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1106 5473 03 49 52 9A 4E	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1107 5478 03 45 4C 9B 50 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1108 547E 04 43 48 4F C4 50 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1109 5485 04 4F 54 4F D3 50 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1110 548C 02 46 D4 50 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1111 5491 05 4B 44 49 52 0A + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1112 5498 03 4F 4E AC 51 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1113 549E 05 41 55 53 45 B4 + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1114 54A6 03 45 4D D5 50 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
    77 				                
    78 				; End Of Program Marker ********************************************************
    79 54AC 00			BOOT_SYS_END    BRK
    80 54AD					ORG ((*/256)+1)*256		; next free page
    81 = 5500			SIS_BUFF	.ds 	512			; SIS Buffer 
    82 = 5700			FILE_BUFF	.ds	512			; .exe file buffer
    83 						END
