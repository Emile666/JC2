mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Disk Operating System for 6502 Microprocessors
     3 				;
     4 				; JC2 DOS65, Version 0.3.2 by Emile, original design (V0.2.0) by Joerg Walke
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; DOS65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0033			VERPSUB    	EQU     '3'    		; primary sub version
    24 = 0032			VERSSUB		EQU	'2'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; V0.2.4: - .BAS LOAD file now works, filename bug-fix and NUM32 bug-fix
    33 				;	  - Bug-fix MKDIR run after DIR command
    34 				;	  - SIS added + total KB printed with DIR command
    35 				; V0.2.5: - DEL command added.
    36 				; V0.2.6: - SAVE from BASIC added, CFC_SAVE, OS_CREATE, OS_CREATE_FILE changed,
    37 				;           OS_SAVE_FILE and LINK_FAT_ENTRY added.
    38 				;         - VER command added.
    39 				;         - Bug-fixes OS_LOAD_FILE when 1) #clusters = 1 2) sectors/cluster = 1
    40 				; V0.2.7: Couple of bug-fixes with path-name string and CD command.
    41 				; V0.2.8: Enabling RAM-BANK 4 for BASIC and RAM-BANK 0 for DOS. Now Basic programs
    42 				;         can load all the way up to $AFFF.
    43 				; V0.2.9: BASIC related DOS functions are now copied into Monitor RAM area.
    44 				; V0.3.0: - Improved CF-card error-checking & handling
    45 				;         - Volume-label added for root-dir
    46 				;         - CF device-driver routines now in Monitor RAM
    47 				; V0.3.1: - Bug-fix mkdir buffer not cleared.
    48 				;         - Bug-fix update_fat_table, link_fat_entry and read_fat_entry
    49 				; V0.3.2: - .inc files reorganised.
    50 				; ******************************************************************************
    51 						OPT h- ; do not add file header
    52 						OPT f+ ; save as single block
    53
    54 				;------------------------------------------------------------------------------------------------
    55 				; TERMINOLOGY AND FORMULAS USED:
    56 				; 
    57 				; Sector                : A sector consists of 512 bytes.
    58 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    59 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    60 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    61 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    62 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    63 				; 
    64 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    65 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    66 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    67 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    68 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    69 				;------------------------------------------------------------------------------------------------
    70 						ICL "jc2_defines.inc"		; JC2 system-wide defines
Source: jc2_defines.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor ADDRESS DEFINES
     3 				;------------------------------------------------------------------------------
     4
     5 				;------------------------------------------------------------------------------
     6 				; $00 - $FF, Zero-Page Address Defines
     7 				; - Addresses from $00 up to $9C are in use by BASIC
     8 				; - Addresses from $A0 up to $AF are in use by DOS and boot.sys
     9 				;------------------------------------------------------------------------------ 
    10 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
    11 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    12 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    13
    14 = 0003			FREE1		EQU	$03		; Not in use
    15
    16 				; ------------------------------------------------------
    17 				; BASIC variables: $04 to $13, see jc2_basic_zp_vars.inc
    18 				; ------------------------------------------------------
    19
    20 				; Card Base Addresses **********************************************************
    21 = 0014			IOBASE		EQU	$14		; pointer to IO card base
    22 = 0014			IOBASEL		EQU	$14		; always $00
    23 = 0015			IOBASEH		EQU	$15		; K2 = $08, K3 = $0C, K4 = $10
    24 = 0016			FGCBASE	        EQU	$16		; pointer to Floppy-/Graphics-Controller card base
    25 = 0016			FGCBASEL	EQU	$16		; always $00
    26 = 0017			FGCBASEH	EQU	$17		; (K2 = $08, K3 = $0C,) should always be K4 = $10
    27 = 0018			CARD3BASE	EQU	$18		; reserved (controller base)
    28 = 0018			CARD3BASEL	EQU	$18		; always $00
    29 = 0019			CARD3BASEH	EQU	$19		; K2 = $08, K3 = $0C, K4 = $10
    30
    31 				; -------------------------------------------------------
    32 				; BASIC variables: $1A to $97, see jc2_basic_zp_vars.inc
    33 				; -------------------------------------------------------
    34 						ICL "jc2_basic_zp_vars.inc"	; JC2 BASIC variables
Source: jc2_basic_zp_vars.inc
     1 				;-------------------------------------------------
     2 				; JC2 BASIC Zero-Page variables.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------
     5
     6 = 0004			Decss			= $04		; BASIC number to decimal string start LSB (moved from $EF)
     7 = 0005			Decssp1			= $05		; BASIC number to decimal string start MSB (moved from $F0)
     8 									; $06..$09 also reserved for Decss
     9 									
    10 = 000A			Usrjmp			= $0A		; USR function JMP address
    11 = 000B			Usrjpl			= Usrjmp+1	; USR function JMP vector low byte
    12 = 000C			Usrjph			= Usrjmp+2	; USR function JMP vector high byte
    13 = 000D			Nullct			= $0D		; nulls output after each line
    14 = 000E			TPos			= $0E		; BASIC terminal position byte
    15 = 000F			TWidth			= $0F		; BASIC terminal width byte
    16 = 0010			Iclim			= $10		; input column limit
    17 = 0011			Itempl			= $11		; temporary integer low byte
    18 = 0012			Itemph			= Itempl+1	; temporary integer high byte
    19
    20 = 0011			nums_1			= Itempl	; number to bin/hex string convert MSB
    21 = 0012			nums_2			= nums_1+1	; number to bin/hex string convert
    22 = 0013			nums_3			= nums_1+2	; number to bin/hex string convert LSB
    23
    24 				; *** free space **********************************************************
    25 				;			= $14		; *used by JC2 system
    26 				;			= $15		; *used by JC2 system
    27 				;			= $16		; *used by JC2 system
    28 				;			= $17		; *used by JC2 system
    29 				;			= $18		; *used by JC2 system
    30 				;			= $19		; *used by JC2 system 
    31 				; *************************************************************************
    32
    33 = 001A			Temp1			= $1A		; temporary byte for free use
    34
    35 = 001B			Srchc			= $1B		; search character
    36 = 001B			Temp3			= Srchc		; temp byte used in number routines
    37 = 001C			Scnquo			= $1C		; scan-between-quotes flag
    38 = 001C			Asrch			= Scnquo	; alt search character
    39
    40 = 001B			XOAw_l			= Srchc		; eXclusive OR, OR and AND word low byte
    41 = 001C			XOAw_h			= Scnquo	; eXclusive OR, OR and AND word high byte
    42
    43 = 001D			Ibptr			= $1D		; input buffer pointer
    44 = 001D			Dimcnt			= Ibptr		; # of dimensions
    45
    46 = 001E			Defdim			= $1E		; default DIM flag
    47 = 001F			Dtypef			= $1F		; data type flag, $FF=string, $00=numeric
    48 = 0020			Oquote			= $20		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
    49 = 0020			Gclctd			= $20		; garbage collected flag
    50 = 0021			Sufnxf			= $21		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    51 = 0022			Imode			= $22		; input mode flag, $00=INPUT, $80=READ
    52
    53 = 0023			Cflag			= $23		; comparison evaluation flag
    54
    55 = 0024			TabSiz			= $24		; TAB step size (was input flag)
    56
    57 = 0025			next_s			= $25		; next descriptor stack address
    58
    59 									; these two bytes form a word pointer to the item
    60 									; currently on top of the descriptor stack
    61
    62 = 0026			last_sl			= $26		; last descriptor stack address low byte
    63 = 0027			last_sh			= $27		; last descriptor stack address high byte (always $00)
    64
    65 = 0028			des_sk			= $28		; descriptor stack start address (temp strings)
    66
    67 				;			= $30		; End of descriptor stack
    68
    69 = 0031			ut1_pl			= $31		; utility pointer 1 low byte
    70 = 0032			ut1_ph			= ut1_pl+1	; utility pointer 1 high byte
    71 = 0033			ut2_pl			= $33		; utility pointer 2 low byte
    72 = 0034			ut2_ph			= ut2_pl+1	; utility pointer 2 high byte
    73
    74 = 0035			FACt_1			= $35		; FAC temp mantissa1
    75 = 0036			FACt_2			= FACt_1+1	; FAC temp mantissa2
    76 = 0037			FACt_3			= FACt_2+1	; FAC temp mantissa3
    77
    78 = 0036			dims_l			= FACt_2	; array dimension size low byte
    79 = 0037			dims_h			= FACt_3	; array dimension size high byte
    80
    81 = 0038			TempB			= $38		; temp page 0 byte
    82
    83 = 0039			Smeml			= $39		; start of mem low byte		(Start-of-Basic)
    84 = 003A			Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
    85 = 003B			Svarl			= $3B		; start of vars low byte	(Start-of-Variables)
    86 = 003C			Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
    87 = 003D			Sarryl			= $3D		; var mem end low byte		(Start-of-Arrays)
    88 = 003E			Sarryh			= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
    89 = 003F			Earryl			= $3F		; array mem end low byte	(End-of-Arrays)
    90 = 0040			Earryh			= Earryl+1	; array mem end high byte	(End-of-Arrays)
    91 = 0041			Sstorl			= $41		; string storage low byte	(String storage (moving down))
    92 = 0042			Sstorh			= Sstorl+1	; string storage high byte	(String storage (moving down))
    93 = 0043			Sutill			= $43		; string utility ptr low byte
    94 = 0044			Sutilh			= Sutill+1	; string utility ptr high byte
    95 = 0045			Ememl			= $45		; end of mem low byte		(Limit-of-memory)
    96 = 0046			Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
    97 = 0047			Clinel			= $47		; current line low byte		(Basic line number)
    98 = 0048			Clineh			= Clinel+1	; current line high byte	(Basic line number)
    99 = 0049			Blinel			= $49		; break line low byte		(Previous Basic line number)
   100 = 004A			Blineh			= Blinel+1	; break line high byte		(Previous Basic line number)
   101
   102 = 004B			Cpntrl			= $4B		; continue pointer low byte
   103 = 004C			Cpntrh			= Cpntrl+1	; continue pointer high byte
   104
   105 = 004D			Dlinel			= $4D		; current DATA line low byte
   106 = 004E			Dlineh			= Dlinel+1	; current DATA line high byte
   107
   108 = 004F			Dptrl			= $4F		; DATA pointer low byte
   109 = 0050			Dptrh			= Dptrl+1	; DATA pointer high byte
   110
   111 = 0051			Rdptrl			= $51		; read pointer low byte
   112 = 0052			Rdptrh			= Rdptrl+1	; read pointer high byte
   113
   114 = 0053			Varnm1			= $53		; current var name 1st byte
   115 = 0054			Varnm2			= Varnm1+1	; current var name 2nd byte
   116
   117 = 0055			Cvaral			= $55		; current var address low byte
   118 = 0056			Cvarah			= Cvaral+1	; current var address high byte
   119
   120 = 0057			Frnxtl			= $57		; var pointer for FOR/NEXT low byte
   121 = 0058			Frnxth			= Frnxtl+1	; var pointer for FOR/NEXT high byte
   122
   123 = 0057			Tidx1			= Frnxtl	; temp line index
   124
   125 = 0057			Lvarpl			= Frnxtl	; let var pointer low byte
   126 = 0058			Lvarph			= Frnxth	; let var pointer high byte
   127
   128 = 0059			prstk			= $59		; precedence stacked flag
   129
   130 = 005B			comp_f			= $5B		; compare function flag, bits 0,1 and 2 used
   131 									; bit 2 set if >
   132 									; bit 1 set if =
   133 									; bit 0 set if <
   134
   135 = 005C			func_l			= $5C		; function pointer low byte
   136 = 005D			func_h			= func_l+1	; function pointer high byte
   137
   138 = 005C			garb_l			= func_l	; garbage collection working pointer low byte
   139 = 005D			garb_h			= func_h	; garbage collection working pointer high byte
   140
   141 = 005E			des_2l			= $5E		; string descriptor_2 pointer low byte
   142 = 005F			des_2h			= des_2l+1	; string descriptor_2 pointer high byte
   143
   144 = 0060			g_step			= $60		; garbage collect step size
   145
   146 = 0061			Fnxjmp			= $61		; jump vector for functions
   147 = 0062			Fnxjpl			= Fnxjmp+1	; functions jump vector low byte
   148 = 0063			Fnxjph			= Fnxjmp+2	; functions jump vector high byte
   149
   150 = 0062			g_indx			= Fnxjpl	; garbage collect temp index
   151 					
   152 = 0063			FAC2_r			= $63		; FAC2 rounding byte
   153
   154 = 0064			Adatal			= $64		; array data pointer low byte
   155 = 0065			Adatah			= Adatal+1	; array data pointer high  byte
   156
   157 = 0064			Nbendl			= Adatal	; new block end pointer low byte
   158 = 0065			Nbendh			= Adatah	; new block end pointer high  byte
   159
   160 = 0066			Obendl			= $66		; old block end pointer low byte
   161 = 0067			Obendh			= Obendl+1	; old block end pointer high  byte
   162
   163 = 0068			numexp			= $68		; string to float number exponent count
   164 = 0069			expcnt			= $69		; string to float exponent count
   165
   166 = 0068			numbit			= numexp	; bit count for array element calculations
   167
   168 = 006A			numdpf			= $6A		; string to float decimal point flag
   169 = 006B			expneg			= $6B		; string to float eval exponent -ve flag
   170
   171 = 006A			Astrtl			= numdpf	; array start pointer low byte
   172 = 006B			Astrth			= expneg	; array start pointer high  byte
   173
   174 = 006A			Histrl			= numdpf	; highest string low byte
   175 = 006B			Histrh			= expneg	; highest string high  byte
   176
   177 = 006A			Baslnl			= numdpf	; BASIC search line pointer low byte
   178 = 006B			Baslnh			= expneg	; BASIC search line pointer high  byte
   179
   180 = 006A			Fvar_l			= numdpf	; find/found variable pointer low byte
   181 = 006B			Fvar_h			= expneg	; find/found variable pointer high  byte
   182
   183 = 006A			Ostrtl			= numdpf	; old block start pointer low byte
   184 = 006B			Ostrth			= expneg	; old block start pointer high  byte
   185
   186 = 006A			Vrschl			= numdpf	; variable search pointer low byte
   187 = 006B			Vrschh			= expneg	; variable search pointer high  byte
   188
   189 = 006C			FAC1_e			= $6C		; FAC1 exponent
   190 = 006D			FAC1_1			= FAC1_e+1	; FAC1 mantissa1
   191 = 006E			FAC1_2			= FAC1_e+2	; FAC1 mantissa2
   192 = 006F			FAC1_3			= FAC1_e+3	; FAC1 mantissa3
   193 = 0070			FAC1_s			= FAC1_e+4	; FAC1 sign (b7)
   194
   195 = 006C			str_ln			= FAC1_e	; string length
   196 = 006D			str_pl			= FAC1_1	; string pointer low byte
   197 = 006E			str_ph			= FAC1_2	; string pointer high byte
   198
   199 = 006E			des_pl			= FAC1_2	; string descriptor pointer low byte
   200 = 006F			des_ph			= FAC1_3	; string descriptor pointer high byte
   201
   202 = 006F			mids_l			= FAC1_3	; MID$ string temp length byte
   203
   204 = 0071			negnum			= $71		; string to float eval -ve flag
   205 = 0071			numcon			= $71		; series evaluation constant count
   206
   207 = 0072			FAC1_o			= $72		; FAC1 overflow byte
   208
   209 = 0073			FAC2_e			= $73		; FAC2 exponent
   210 = 0074			FAC2_1			= FAC2_e+1	; FAC2 mantissa1
   211 = 0075			FAC2_2			= FAC2_e+2	; FAC2 mantissa2
   212 = 0076			FAC2_3			= FAC2_e+3	; FAC2 mantissa3
   213 = 0077			FAC2_s			= FAC2_e+4	; FAC2 sign (b7)
   214
   215 = 0078			FAC_sc			= $78		; FAC sign comparison, Acc#1 vs #2
   216 = 0079			FAC1_r			= $79		; FAC1 rounding byte
   217
   218 = 0078			ssptr_l			= FAC_sc	; string start pointer low byte
   219 = 0079			ssptr_h			= FAC1_r	; string start pointer high byte
   220
   221 = 0078			sdescr			= FAC_sc	; string descriptor pointer
   222
   223 = 007A			csidx			= $7A		; line crunch save index
   224 = 007A			Asptl			= csidx		; array size/pointer low byte
   225 = 007B			Aspth			= $7B		; array size/pointer high byte
   226
   227 = 007A			Btmpl			= Asptl		; BASIC pointer temp low byte
   228 = 007B			Btmph			= Aspth		; BASIC pointer temp low byte
   229
   230 = 007A			Cptrl			= Asptl		; BASIC pointer temp low byte
   231 = 007B			Cptrh			= Aspth		; BASIC pointer temp low byte
   232
   233 = 007A			Sendl			= Asptl		; BASIC pointer temp low byte
   234 = 007B			Sendh			= Aspth		; BASIC pointer temp low byte
   235
   236 = 007C			LAB_IGBY		= $7C		; get next BASIC byte subroutine
   237
   238 = 0082			LAB_GBYT		= $82		; get current BASIC byte subroutine
   239 = 0083			Bpntrl			= $83		; BASIC execute (get byte) pointer low byte
   240 = 0084			Bpntrh			= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   241
   242 				;			= $97		; end of get BASIC char subroutine
   243
   244 				; Rbyte4,1,2,3 are moved to $1860 to free up ZP-use
   245 				; I2Cstat is moved to $180F
    35
    36 				; ------------------------------------------------
    37 				; DOS variables: $A0 to $A6, see boot.sys files
    38 				; ------------------------------------------------
    39 = 00A0			ZP_DOS          EQU     $A0		; Reserved for DOS and boot.sys
    40 = 00A0			CURR_DIR_ENTRY  EQU     ZP_DOS+$00      ; $A0..$A1 (16 bit) - pointer to current addressed directory entry
    41 = 00A2			MASK            EQU     ZP_DOS+$02	; $A2 Mask for FAT table
    42 = 00A3			BCNT            EQU     ZP_DOS+$03      ; $A3 Block Counter
    43 = 00A4			NCNT            EQU     ZP_DOS+$04	; $A4
    44 = 00A5			SCNT            EQU     ZP_DOS+$05	; $A5 Sector counter within a cluster
    45 = 00A6			RES             EQU     ZP_DOS+$06	; $A6
    46
    47 				; ------------------------------------------------
    48 				; FGC variables: $A8 to $BB, see FGC .asm files
    49 				; ------------------------------------------------
    50 = 00A8			ZP_FGC          EQU     $A8             ; Zero Page Base Address
    51 = 00A8			VPUMODE         EQU     ZP_FGC+$00      ; current VPU mode
    52 = 00A9			MAX_X           EQU     ZP_FGC+$01      ; max characters per line
    53 = 00AA			CURSOR_TICKS    EQU     ZP_FGC+$02      ; blink frequency in ticks (1/60 sec or 1/50 sec)
    54 = 00AB			CURSOR          EQU     ZP_FGC+$03      ; character under the cursor
    55 = 00AC			BUFFSIZE        EQU     ZP_FGC+$04      ; actual scroll buffer size
    56 = 00AD			PAGECNT         EQU     ZP_FGC+$05      ; page buffer counter
    57 = 00AE			TXTCOLOR        EQU     ZP_FGC+$06
    58 = 00AF			COLOR           EQU     ZP_FGC+$07
    59 = 00B2			POS_X           EQU     ZP_FGC+$0A      ; cursor X position (2-bytes)
    60 = 00B4			POS_Y           EQU     ZP_FGC+$0C      ; cursor Y position
    61 = 00B5			ADR_CHAR        EQU     ZP_FGC+$0D 	; 2-byte pointer
    62 = 00B7			FGC_ADR         EQU     ZP_FGC+$0F
    63 = 00B7			FGC_ADRL        EQU	ZP_FGC+$0F   	; last address Low
    64 = 00B8			FGC_ADRH      	EQU   	ZP_FGC+$10  	; last address High
    65 = 00B9			FGC_XREG        EQU     ZP_FGC+$11      ; current saved X register
    66 = 00BA			FGC_YREG        EQU     ZP_FGC+$12      ; current saved Y register
    67 = 00BB			VARSAV          EQU     ZP_FGC+$13      ; saved variable
    68
    69 				; ------------------------------------------------
    70 				; BIOS variables: $C0 to $FF
    71 				; ------------------------------------------------
    72 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    73 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    74 = 00C9			DEVID		EQU	$C9		; 1-byte temp device id (moved from $03 to avoid Basic collision)
    75 = 00CA			PRSTR		EQU	$CA		; 2-bytes replacement for PSTR
    76 = 00CC			END_PTR		EQU	$CC		; ROM end-pointer (2 bytes), also used by boot.sys
    77 = 00CE			ROM_PTR		EQU	$CE		; ROM pointer (2 bytes)
    78 = 00D0			ROM_CS		EQU	$D0		; ROM checksum counter (2 bytes)
    79 = 00D2			CFLBA0          EQU     $D2		; CF-card LBA 0 [0:7]
    80 = 00D3			CFLBA1          EQU     $D3		; CF-card LBA 1 [8:15]
    81 = 00D4			CFLBA2          EQU     $D4		; CF-card LBA 2 [16:23]
    82 = 00D5			CFLBA3          EQU     $D5		; CF-card LBA 3 [24:27]
    83 = 00D6			MSEC		EQU	$D6		; msec time-out counter
    84 = 00D7			RSTACT		EQU	$D7		; 1 = Reset Pending
    85 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register
    86 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register
    87 = 00DA			TICKCNT         EQU     $DA             ; current tick counter
    88 = 00DB			SD_TYPE		EQU	$DB		; SD Card Type: $00 Byte mode, $40 LBA mode
    89 = 00DC			BLKBUF		EQU	$DC             ; pointer to block buffer
    90 = 00DC			BLKBUFL		EQU	$DC             ; lower byte of block buffer pointer
    91 = 00DC			CRCL      	EQU   	$DC      	; XModem CRC lo byte
    92 = 00DD			BLKBUFH		EQU	$DD             ; upper byte of block buffer pointer
    93 = 00DD			CRCH      	EQU   	$DD     	; XModem CRC hi byte
    94 = 00DE			SD_CMD		EQU	$DE		; SD-Card CMD Byte
    95 = 00DE			RETRYL    	EQU   	$DE      	; XModem retry counter lo byte
    96 = 00DE			PDEV		EQU	$DE		; device descriptor pointer
    97 = 00DE			PDEVL    	EQU   	$DE      	; device descriptor pointer lo byte
    98 = 00DF			SD_PB3      	EQU   	$DF   		; SD-Card Parameter Byte 3
    99 = 00DF			RETRYH    	EQU   	$DF      	; XModem retry counter hi byte
   100 = 00DF			PDEVH    	EQU   	$DF      	; device descriptor pointer hi byte
   101
   102 = 00E0			SD_PB2		EQU   	$E0   		; SD-Card Parameter Byte 2
   103 = 00E0			BAUDRATE  	EQU   	$E0    		; ACIA current baud rate
   104 = 00E0			OPCODE		EQU	$E0		; DISASSEM current opcode
   105 = 00E0			I2C_DATA	EQU	$E0		; I2C current I2C data byte
   106 = 00E0			BLKEND      	EQU     $E0		; XModem block end flag
   107 = 00E1			KEY     	EQU     $E1   		; MON 1-byte Editor 
   108 = 00E1			SD_PB1      	EQU   	$E1   		; SD-Card Parameter Byte 1
   109 = 00E1			LINECNT		EQU	$E1		; DISASSEM number of disassembled lines
   110 = 00E1			BFLAG     	EQU   	$E1      	; XModem block flag
   111 = 00E2			BEGADR  	EQU     $E2   		; MON 2-byte Editor Begin Address Pointer
   112 = 00E2			SD_PB0		EQU	$E2   		; SD-Card Parameter Byte 0
   113 = 00E2			ADRMODE		EQU	$E2		; DISASSEM addressing mode
   114 = 00E2			BLKNO     	EQU   	$E2      	; XModem block number
   115 = 00E3			SD_CRC		EQU	$E3   		; SD-Card CRC Byte
   116 = 00E3			IBYTES		EQU	$E3		; DISASSEM instruction byte count
   117 = 00E3			ERRCNT    	EQU   	$E3      	; XModem error counter 10 is the limit
   118 = 00E4			ENDADR  	EQU     $E4   		; MON 2-byte Editor End Address Pointer
   119 = 00E4			VIA_STATUS 	EQU	$E4 		; VIA2 current VIA2 PortB output status
   120
   121 = 00E6			CURADR  	EQU     $E6   		; MON 2-byte Editor Current Address Pointer
   122 = 00E6			ASCL	  	EQU   	$E6     	; MON ASCII list start address low
   123 = 00E6			PLBA		EQU	$E6		; LBA pointer
   124 = 00E6			PLBAL		EQU	$E6		; LBA pointer low byte
   125 = 00E7			ASCH      	EQU   	$E7     	; MON ASCII list start address high
   126 = 00E7			PLBAH		EQU	$E7		; LBA pointer high byte
   127 = 00E8			CENDADR 	EQU     $E8   		; MON 2-byte Editor Current End Address Pointer
   128 = 00E8			STOL      	EQU   	$E8     	; MON store address Low
   129 = 00E9			STOH      	EQU   	$E9     	; MON store address High
   130 = 00EA			MOVADR  	EQU     $EA   		; MON 2-byte Editor 
   131 = 00EA			PSTR      	EQU   	$EA      	; ACIA output string Pointer
   132 = 00EA			PSTRL     	EQU   	$EA      	; ACIA lower address byte of output string pointer
   133 = 00EB			PSTRH     	EQU   	$EB      	; ACIA upper address byte of output string pointer
   134 = 00EC			TABLEA  	EQU     $EC   		; MON 2-byte Editor 
   135 = 00EC			WBUF      	EQU   	$EC      	; ACIA character output buffer
   136
   137 = 00EE			LABELS  	EQU     $EE   		; MON 1-byte Editor 
   138 = 00EE			PSAV            EQU     $EE		; Saved Partition Number in ASCII
   139 = 00EF			PCL		EQU	$EF		; CPU program counter Low
   140
   141 = 00F0			PCH		EQU	$F0		; CPU program counter High
   142 = 00F1			PREG		EQU	$F1		; CPU processor status register
   143 = 00F2			SPUSER		EQU	$F2		; CPU stack pointer
   144 = 00F2			DIVCHAR		EQU	$F2             ; CLOCK current divider char (. or / for date : for time)
   145 = 00F3			ACC		EQU	$F3		; CPU accumulator
   146 = 00F4			YREG		EQU	$F4		; CPU y-register
   147 = 00F5			XREG		EQU	$F5		; CPU x-register
   148 = 00F6			BYTES   	EQU     $F6   		; MON 1-byte Number of bytes to be displayed
   149 = 00F7			COUNT   	EQU     $F7   		; MON 1-byte
   150 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
   151 = 00F8			NUML      	EQU   	$F8     	; MON low number byte
   152 = 00F8			INL     	EQU     $F8   		; MON 1-byte hex display buffer
   153 = 00F9			INH     	EQU     $F9   		; MON 1-byte hex display buffer
   154 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
   155 = 00F9			NUMH	  	EQU   	$F9	 	; MON high number byte
   156 = 00FA			POINT   	EQU     $FA   		; MON 2-byte
   157 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
   158 = 00FA			ADRL      	EQU   	$FA     	; MON last address Low
   159 = 00FB			ADRH      	EQU   	$FB     	; MON last address High
   160 = 00FC			TEMP      	EQU   	$FC     	; MON temp storage
   161 = 00FD			TEMPX   	EQU     $FD   		; MON 1-byte temp. data-buffer
   162 = 00FD			YSAV      	EQU   	$FD     	; MON Y register storage
   163 = 00FE			NIBBLE  	EQU     $FE   		; MON 1-byte temp. data-buffer
   164 = 00FE			PDBCNT    	EQU   	$FE     	; MON number of printed data bytes
   165 = 00FF			MODE      	EQU   	$FF     	; MON current edit mode
   166
   167 				;------------------------------------------------------------------------------
   168 				; Junior Computer ][ BIOS & Monitor ADDRESS DEFINES
   169 				; $0100 - $01FF is reserved for the 6502 Stack
   170 				;------------------------------------------------------------------------------ 
   171
   172 				;----------------------------------------------------------------------------
   173 				; Block Device / Tables and Buffer Addresses
   174 				;----------------------------------------------------------------------------
   175 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
   176 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
   177 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
   178
   179 				; Current Volume Descriptor (32 Bytes) -----------------------------------------
   180 				; The BOOT routine in BIOS has already loaded the MBR into $0600, loaded the
   181 				; Volume-ID sector into $0400 and did set (most of) these variables.
   182 				; ------------------------------------------------------------------------------
   183 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor, used by boot.sys and mkbootcf
   184 = 0400			BOOT_PART       EQU     CURR_VOLUME     	; Boot Medium Descriptor: used by bios and mkbootcf
   185 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   186 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   187 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   188 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte or Partition Number in ASCII if harddisk
   189 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   190 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   191 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   192 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   193 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   194 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   195 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   196 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   197 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   198 = 0420			CURR_CLUSTER    EQU     CURR_VOLUME+$20         ; 4 Bytes - current addressed cluster in boot.sys
   199 = 0424			CURR_FAT_BLK    EQU     CURR_VOLUME+$24         ; 4 Bytes - current loaded FAT LBA in boot.sys
   200 = 0428			D_SUBDIR_NAME	EQU	CURR_VOLUME+$28		; ? Bytes - Name of entire path (root dir is \)
   201
   202 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices, used by boot.sys
   203
   204 = 0600			FAT_BUF		EQU	$0600           	; Buffer for FAT32 sector
   205 = 0600			BLOCK_BUF	EQU	$0600			; 1st sector of boot.sys is also stored here
   206 = 0600			MBR             EQU     BLOCK_BUF      		; Master Boot Block Code, contains a BNE to boot-code
   207 = 07BE			PART0		EQU	MBR + $01BE		; Partition 0 start
   208 = 07C6			PART0_RS	EQU	PART0 + 8 		; Partition 0 relative sector field
   209 = 07CE			PART0_SIZE	EQU	PART0 + 16		; Partition 0 sector size field
   210 = 07FE			BOOTBLK_TAG     EQU     MBR + $01FE           	; Address of Boot Block Tag ($55 $AA)
   211
   212 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   213 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   214
   215 				; IO Base Addresses ---------------------------------------------------------
   216 				;----------------------------------------------------------------------------
   217 = 0800			K2		EQU	$0800		; Base address of IO select K2
   218 = 0C00			K3		EQU	$0C00		; Base address of IO select K3 = IO2-card
   219 = 1000			K4		EQU	$1000		; Base address of IO select K4 = FGC-card
   220
   221 				;----------------------------------------------------------------------------
   222 				; CF-IDE Hardware Registers (on stand-alone card or IO2-board)
   223 				;----------------------------------------------------------------------------
   224 = 0C80			CFBASE		EQU 	K3 + $80	; Base card-address for CF card
   225 = 0C80			CFREG0		EQU	CFBASE+0	; Data port
   226 = 0C81			CFREG1		EQU	CFBASE+1	; Read: error-code, write: feature
   227 = 0C82			CFREG2		EQU	CFBASE+2	; Number of sectors to transfer
   228 = 0C83			CFREG3		EQU	CFBASE+3	; Sector address LBA 0 [0:7] (LSB)
   229 = 0C84			CFREG4		EQU	CFBASE+4	; Sector address LBA 1 [8:15]
   230 = 0C85			CFREG5		EQU	CFBASE+5	; Sector address LBA 2 [16:23]
   231 = 0C86			CFREG6		EQU	CFBASE+6	; Sector address LBA 3 [24:27] (MSB)
   232 = 0C87			CFREG7		EQU	CFBASE+7	; Read: Status, Write: Command
   233 = 0C88			CFREG8		EQU	CFBASE+8	; A write with 0x00 is a HW reset
   234
   235 				;----------------------------------------------------------------------------
   236 				; FGC / VIDEO Card Hardware Registers
   237 				;----------------------------------------------------------------------------
   238 = 1000			FGC_BASE        EQU     K4		; K4 base-address (fixed)
   239 = 1006			FGC_START_CONF  EQU     FGC_BASE+$06  	; prepare for DIP Switch reading
   240 = 1007			FGC_END_CONF    EQU     FGC_BASE+$07  	; read keyboard layout from DIP Switch settings
   241 = 1008			VPU_BASE        EQU     FGC_BASE+$08  	; VPU Register Base
   242 = 1008			VPU_PORT0       EQU     VPU_BASE      	; Data Port
   243 = 1009			VPU_PORT1       EQU     VPU_BASE+1    	; Control Port
   244 = 100A			VPU_PORT2       EQU     VPU_BASE+2    	; Color Pallete Port
   245 = 100B			VPU_PORT3       EQU     VPU_BASE+3    	; Indirect Register Port
   246 = 100C			PPI_PORTA       EQU     FGC_BASE+$0C  	; PIA Port A register
   247 = 100E			PPI_PORTC       EQU     FGC_BASE+$0E  	; PIA Port C
   248 = 100F			PPI_CONTROL     EQU     FGC_BASE+$0F  	; PIA Control register
   249
   250 = 1010			FGC_INFO        EQU     FGC_BASE+$10
   251 = 1013			FGC_SET_PAGE    EQU     FGC_BASE+$13
   252 = 1017			FGC_FDC_CMD     EQU     FGC_BASE+$17
   253 = 101F			FGC_VPU_CMD     EQU     FGC_BASE+$1F
   254 = 1027			FGC_VPU_OUT     EQU     FGC_BASE+$27
   255
   256 				; Buffers **********************************************************************
   257 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400
   258 = 1500			RBUFF     	EQU   	$1500    	; xmodem receive buffer at $1500
   259
   260 				; ACIA Registers ***************************************************************
   261 = 1600			DATA_REG  	EQU   	$1600    	; ACIA Data Register
   262 = 1601			STAT_REG  	EQU   	$1601    	; ACIA Status Register
   263 = 1602			COMM_REG  	EQU   	$1602    	; ACIA Command Register
   264 = 1603			CTRL_REG  	EQU   	$1603    	; ACIA Control Register
   265
   266 				; ATF1504 Memory Management Unit (MMU) Register ********************************
   267 = 1700			MMU		EQU	$1700		; MMU Register
   268
   269 				;------------------------------------------------------------------------------
   270 				; $1800 - $19FF 512 Bytes, previously unused, on JC2 v4.1 this has become RAM.
   271 				;------------------------------------------------------------------------------
   272 = 1800			PPORTLOAD	EQU	$1800		; jump location for test code
   273 = 1803			PPORTSAVE	EQU	$1803		; jump location for test code
   274 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
   275 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
   276 = 180A			RETURN_VECT     EQU     $180A           ; 2-byte return vector to monitor caller (moved from $01 to avoid Basic collision)
   277 = 180C			I2Cstat		EQU	$180C		; BASIC I2C read byte or ACK/NACK bit (moved from Basic $9C) 
   278 = 180D			KBD_LANG        EQU     $180D         	; Current selected keyboard language for FGC-card
   279 = 180E			FLOPPY_TYPE     EQU     $180E     	; floppy type settings for FGC-card
   280
   281 = 1810			NEXTINDEX       EQU     $1810		; command index
   282 = 1811			TERM_CHAR       EQU     $1811
   283 = 1812			F_ATTRIBS       EQU     $1812
   284 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
   285 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
   286 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
   287 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
   288 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
   289 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
   290 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
   291 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
   292 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
   293 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
   294 = 1828			DBG_PRINT	EQU	$1828		; 1 = Print debug info
   295
   296 				; INPBUF is the BASIC Input Buffer. It is defined from $1868 - $18FF
   297 				; Rbytes are moved from Basic $98..$9B to free up ZP-space
   298 = 1860			Rbyte4		EQU	$1860		; extra PRNG byte
   299 = 1861			Rbyte1		EQU	$1861		; most significant PRNG byte
   300 = 1862			Rbyte2		EQU	$1862		; middle PRNG byte
   301 = 1863			Rbyte3		EQU	$1863		; least significant PRNG byte
   302
   303 = 1868			INPBUF	  	EQU 	$1868		; change input buffer to last 151 bytes in page
   304 = 1868			ccflag		EQU	INPBUF		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   305 = 1869			ccbyte		EQU 	ccflag+1	; BASIC CTRL-C byte
   306 = 186A			ccnull		EQU 	ccbyte+1	; BASIC CTRL-C byte timeout
   307 = 186B			VEC_CC		EQU 	ccnull+1	; ctrl c check vector
   308
   309 				; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   310 = 187F			Ibuffs		EQU 	VEC_CC+$14	; start of input buffer after IRQ/NMI code
   311 = 18FE			Ibuffe		EQU 	Ibuffs+$7F	; end of input buffer
   312
   313 				;------------------------------------------------------------------------------
   314 				; $1A00 - $1AFF 256 Bytes, RIOT RAM area
   315 				;------------------------------------------------------------------------------
   316 = 1A00			IO_INFO         EQU     $1A00           ; Initialization info call for IO card
   317
   318 = 1A24			KEY_HANDLER     EQU     $1A24           ; character input handler
   319 = 1A26			NKEY_HANDLER    EQU     $1A26           ; no character input handler
   320 = 1A28			DEVLIST		EQU	$1A28		; start of device driver list
   321
   322 = 1A66			STDBEEP		EQU	$1A66		; current standard beep routine
   323 = 1A68			DEVIN		EQU	$1A68		; current opened device input routine
   324 = 1A6A			DEVOUT		EQU	$1A6A		; current opened device output routine
   325 = 1A6C			DEVCMD		EQU	$1A6C		; current opened device command routine
   326 = 1A6E			STDIN		EQU	$1A6E		; current standard input routine
   327 = 1A70			STDOUT		EQU	$1A70		; current standard output routine
   328 = 1A72			STDCMD		EQU	$1A72		; current standard command routine
   329 = 1A74			STDINDEV  	EQU   	$1A74    	; absolut standard input device id
   330 = 1A75			STDOUTDEV  	EQU   	$1A75    	; absolut standard output device id
   331 = 1A76			STDPRINTDEV	EQU	$1A76		; absolutstandard printer device id
   332 = 1A77			STOACC		EQU	$1A77		; last accumulator before interrupt
   333
   334 				; Interrupt Vectors ************************************************************
   335 = 1A78			BRKUSR		EQU	$1A78		; address of user BREAK vector
   336 = 1A7A			NMIVECT		EQU     $1A7A           ; address of NMI vector
   337 = 1A7C			IRQUSR  	EQU   	$1A7C    	; address of user IRQ vector
   338 = 1A7E			IRQVECT  	EQU   	$1A7E    	; address of main IRQ vector
   339
   340 				; Port Register ****************************************************************
   341 = 1A80			PAD		EQU     $1A80		; Port A Data Register
   342 = 1A81			PADD		EQU	$1A81		; Port A Data Direction Register
   343 = 1A82			PBD		EQU	$1A82		; Port B Data Register
   344 = 1A83			PBDD		EQU	$1A83		; Port B Data Direction Register
   345
   346 = 1A85			WRDC		EQU	$1A85		; Write = set positive edge detection, no int.
   347 									; Read = get Edge Control Interrupt Register
   348
   349 				; Timer Register ***************************************************************
   350 = 1A94			CNTA	  	EQU	$1A94	 	; CLK/1T no interrupt
   351 = 1A95			CNTB	  	EQU	$1A95	 	; CLK/8T no interrupt
   352 = 1A96			CNTC	  	EQU	$1A96	 	; CLK/64T no interrupt
   353 = 1A97			CNTD	  	EQU	$1A97    	; CLK/1024T no interrupt
   354 = 1A9F			CNTIRQ		EQU	$1A9F		; Timer Interrupt Register
   355
   356 				;------------------------------------------------------------------------------
   357 				; $1B00 - $1BFF 256 Bytes, previously unused, on JC2 v4.1 this has become RAM.
   358 				;------------------------------------------------------------------------------
   359
   360 				;------------------------------------------------------------------------------
   361 				; $1C00 - $1FFF 1 KB, Monitor RAM area.
   362 				;------------------------------------------------------------------------------
   363 = 1C00			FILE_BUFF	EQU	$1C00		; 512 byte file buffer for .exe/.com/.bas in Monitor RAM
   364
   365 = 4000			BOOT_CODE       EQU 	$4000		; boot.sys address of 1st sector, used by mkboot and boot.sys
    71 						ICL "jc2_constants.inc"		; JC2 constants
Source: jc2_constants.inc
     1 				;------------------------------------------------------------------------------
     2 				; Junior Computer ][ BIOS & Monitor CONSTANTS
     3 				;------------------------------------------------------------------------------ 
     4
     5 				; PIA Register Indices *********************************************************
     6 = 000C			PIA_PORTA       EQU     $0C             ; Port A input/output register
     7 = 000D			PIA_PORTB       EQU     $0D             ; Port B input/output register
     8 = 000E			PIA_PORTC       EQU     $0E             ; Port C input/output register
     9 = 000F			PIA_CONTROL     EQU     $0F             ; Control/Setup register
    10
    11 				; Memory Management Unit (MMU) Register Indices ********************************
    12 = 0001			BIOS_EN		EQU	$01		; PORTB bit 0: 1 = enable BIOS at $E000
    13 = 0002			MON_EN		EQU	$02		; PORTB bit 1: 1 = enable Monitor at $1C00
    14 = 0080			BAS_EN		EQU	$80		; PORTB bit 7: 1 = enable BASIC at $B000
    15
    16 				; MCP23017 I2C GPIO constants
    17 = 0040			MCP23017_I2C_0	EQU	$40		; I2C address of 1st MCP23017 on IO2 board
    18 = 0042			MCP23017_I2C_1	EQU	$42		; I2C address of 2nd MCP23017 on IO2 board
    19 = 0044			MCP23017_I2C_2	EQU	$44		; I2C address of 3rd MCP23017 on IO2 board
    20 = 0000			IODIRA		EQU	$00		; IO Direction register Port A (1=input, 0=output)
    21 = 0001			IODIRB		EQU	$01		; IO Direction register Port B (1=input, 0=output)
    22 = 0012			GPIOA		EQU	$12		; IO Port A, read and write
    23 = 0013			GPIOB		EQU	$13		; IO Port B, read and write
    24
    25 = 0068			I2C_RTC_ADR	EQU	$68		; I2C address of DS1307 Real Time Clock
    26
    27 				; VIA 1 Register Indices ********************************************************
    28 = 0000			VIA_PORTB     	EQU  	$00  		; Port B input/output register
    29 = 0001			VIA_PORTA     	EQU  	$01  		; Port A input/output register
    30 = 0002			VIA_DDRB   	EQU  	$02		; Port B data direction register
    31 = 0003			VIA_DDRA   	EQU  	$03		; Port A data direction register
    32 = 0004			VIA_T1CL   	EQU  	$04		; Timer 1 counter low byte register
    33 = 0005			VIA_T1CH   	EQU  	$05		; Timer 1 counter high byte register
    34 = 0006			VIA_T1LL   	EQU  	$06		; Timer 1 latched counter low byte register
    35 = 0007			VIA_T1LH   	EQU  	$07		; Timer 1 latched counter high byte register
    36 = 0008			VIA_T2CL   	EQU  	$08		; Timer 2 counter low byte register
    37 = 0009			VIA_T2CH   	EQU  	$09		; Timer 2 counter high byte register
    38 = 000A			VIA_SR     	EQU  	$0A		; Shift register
    39 = 000B			VIA_ACR    	EQU  	$0B		; Auxilary control register
    40 = 000C			VIA_PCR    	EQU  	$0C		; Periheral control register
    41 = 000D			VIA_IFR    	EQU  	$0D		; Interrupt flag register
    42 = 000E			VIA_IER    	EQU  	$0E		; Interrupt enable register
    43 = 000F			VIA_PANOHS 	EQU  	$0F
    44
    45 				; VIA 2 Register Indices (IO2 board: SD-card, sound, etc.) *************************
    46 = 0010			PORTB     	EQU  	$10  		; Port B input/output register
    47 = 0011			PORTA     	EQU  	$11  		; Port A input/output register
    48 = 0012			DDRB   		EQU  	$12		; Port B data direction register
    49 = 0013			DDRA   		EQU  	$13		; Port A data direction register
    50 = 0014			T1CL   		EQU  	$14		; Timer 1 counter low byte register
    51 = 0015			T1CH   		EQU  	$15		; Timer 1 counter high byte register
    52 = 0016			T1LL   		EQU  	$16		; Timer 1 latched counter low byte register
    53 = 0017			T1LH   		EQU  	$17		; Timer 1 latched counter high byte register
    54 = 0018			T2CL   		EQU  	$18		; Timer 2 counter low byte register
    55 = 0019			T2CH   		EQU  	$19		; Timer 2 counter high byte register
    56 = 001A			SR     		EQU  	$1A		; Shift register
    57 = 001B			ACR    		EQU  	$1B		; Auxilary control register
    58 = 001C			PCR    		EQU  	$1C		; Peripheral control register
    59 = 001D			IFR    		EQU  	$1D		; Interrupt flag register
    60 = 001E			IER    		EQU  	$1E		; Interrupt enable register
    61 = 001F			PANOHS 		EQU  	$1F
    62
    63 = 0020			CENTURY		EQU	$20		; the 20th century. change to travel in time
    64 = 002E			DATEDIV		EQU	'.'		; divider char for date string
    65 = 003A			TIMEDIV		EQU	':'		; divider char for time string
    66 = 002A			MON_PROMPT    	EQU     '*'    		; prompt character for Monitor
    67 = 002D			ADIV      	EQU     '-'    		; address divider
    68
    69 = 005C			BSLASH          EQU     '\'             ; Backslash ASCII Code
    70 = 002F			FSLASH		EQU     '/'             ; Forward slash ASCII Code
    71 = 002E			DOT             EQU     '.'             ; Dot ASCII Code
    72 = 003A			COLON           EQU     ':'             ; Colon ASCII Code
    73 = 002C			COMMA           EQU     ','             ; Comma ASCII Code
    74 = 002D			MINUS           EQU     '-'             ; Minus ASCII Code
    75 = 005F			ULINE           EQU     '_'             ; Underline ASCII Code
    76
    77 				; Interchangeable Chars ********************************************************
    78 = 003E			DOS_PROMPT      EQU     '>'             ; Command Line Prompt Char
    79 = 002E			NUM_SEP         EQU     DOT	        ; Thousand Seperator Char
    80 = 005C			PATH_SEP        EQU     BSLASH          ; Path Separator Char
    81 = 002F			OPT_SEP         EQU     FSLASH          ; Option Prefix Char
    82
    83 = 0001			CRSR            EQU     $01             ; Cursor
    84 = 0001			SOH       	EQU     $01    		; start of header
    85 = 0004			EOT       	EQU     $04    		; end of text
    86 = 0006			ACK       	EQU     $06    		; acknowledged
    87 = 0008			BS        	EQU     $08    		; backspace key
    88 = 0009			TAB             EQU     $09             ; Horizontal Tab
    89 = 000B			UP              EQU     $0B             ; Up Arrow
    90 = 000D			CR        	EQU     $0D    		; carriage return
    91 = 000A			LF	  	EQU     $0A    		; line feed
    92 = 0015			RIGHT           EQU     $15             ; Right Arrow
    93 = 0015			NAK       	EQU     $15    		; not acknowledged
    94 = 0018			CAN		EQU     $18		; Cancel
    95 = 001B			ESC       	EQU     $1B    		; ESC
    96 = 0020			SPC		EQU     $20		; space char
    97 = 007F			DEL             EQU     $7F             ; Delete
    98
    99 				; Tape Reader/Writer Constants *************************************************
   100 = 0031			RPTIME		EQU	49		; read point time   49x8uS     = 392uS
   101
   102 				; Device Driver Constants ******************************************************
   103 = 0081			KBD_MAGIC_NUM   EQU	129             ; magic number of keyboard ROM
   104
   105 = 0010			COM_DEV	        EQU	$10             ; COM devices base ID
   106 = 0020			STORAGE_DEV	EQU	$20             ; STORAGE devices base ID
   107
   108 = 0000			NULL_ID		EQU	$00             ; the NULL device
   109
   110 = 0010			TTY1_ID		EQU	COM_DEV+0       ; TTY 1 device ID
   111 = 0011			PRINTER1_ID	EQU	COM_DEV+1       ; Printer 1 device ID
   112 = 0012			PRINTER2_ID	EQU	COM_DEV+2       ; Printer 2 device ID
   113 = 0013			KEYBD1_ID	EQU	COM_DEV+3       ; Keyboard 1 device ID (ASCII Keyboard)
   114 = 0014			KEYBD2_ID	EQU	COM_DEV+4       ; Keyboard 2 device ID (PS/2 Keyboard)
   115 = 0015			VDP1_ID         EQU     COM_DEV+5       ; Video Display Processor device ID
   116
   117 = 0020			XMODEM1_ID	EQU	STORAGE_DEV+0   ; XModem device ID
   118 = 0021			TAPE1_ID	EQU	STORAGE_DEV+1   ; Tape 1 device ID
   119 = 0022			FDD1_ID         EQU     STORAGE_DEV+2   ; Floppy drive 1 device ID
   120 = 0023			FDD2_ID         EQU     STORAGE_DEV+3   ; Floppy drive 2 device ID
   121 = 0024			SDC1_ID		EQU	STORAGE_DEV+4   ; SD-Card device ID
   122 = 0025			HDD1_ID		EQU	STORAGE_DEV+5   ; Harddisk 1 device ID (CF-card)
   123 = 0026			HDD2_ID		EQU	STORAGE_DEV+6   ; Harddisk 2 device ID
   124
   125 				; Device Command Constants *****************************************************
   126 = 0000			CMD_INIT	EQU	0               ; Init device
   127 = 0001			CMD_IDENTIFY	EQU	1               ; Identify device
   128 = 0002			CMD_NORMAL	EQU	2               ; Set normal text
   129 = 0003			CMD_INVERSE	EQU	3               ; Set inverse text
   130 = 0004			CMD_FLASH	EQU	4               ; Set blinking text
   131 = 0005			CMD_HOME	EQU	5               ; Set cursor to home position
   132 = 0006			CMD_CLRLINE	EQU	6               ; Clear line at cursor
   133 = 0007			CMD_CLRSCRN	EQU	7               ; Clear screen
   134 = 0008			CMD_SETCURSOR	EQU	8               ; Set cursor position X,Y
   135
   136 = 0010			CMD_SETSTARTADR	EQU	16              ; Set start address [X:Y]
   137 = 0011			CMD_SETENDADR	EQU	17              ; Set end address [X:Y]
   138
   139 = 0020			CMD_LOAD	EQU	32              ; Load data byte from device
   140 = 0021			CMD_SAVE	EQU	33              ; Save data byte to device
   141 = 0022			CMD_READ	EQU	34              ; Read data block from device
   142 = 0023			CMD_WRITE	EQU	35              ; Write data block to device
   143 = 0024			CMD_BOOT        EQU     36              ; Boot from device
   144 = 0025			CMD_READ_BUF	EQU	37              ; Read data block from device to standard buffer
   145 = 0026			CMD_WRITE_BUF	EQU	38              ; Write data block to device from standard buffer
   146
   147 				; File Attributes **************************************************************
   148 = 0001			FA_READONLY     EQU     $01            	; file is read only
   149 = 0002			FA_HIDDEN       EQU     $02            	; file is hidden
   150 = 0004			FA_SYSTEM       EQU     $04            	; file is a system file
   151 = 0008			FA_LABEL        EQU     $08            	; file is a volume label
   152 = 0010			FA_DIRECTORY    EQU     $10            	; file is a directory
   153 = 0020			FA_ARCHIVE      EQU     $20            	; file is modified
   154 = 0040			FA_RESERVED1    EQU     $40
   155 = 0080			FA_LINK         EQU     $80            	; file is a link
   156
   157 				; SD Command Constants *********************************************************
   158 = 0040			CMD0		EQU	$40		; Reset SD-Card
   159 = 0041			CMD1		EQU	CMD0 + 1	; Initialize MMC/SDC
   160 = 0048			CMD8		EQU	CMD0 + 8	; Check voltage range
   161 = 004D			CMD13		EQU	CMD0 + 13	;
   162 = 0050			CMD16		EQU	CMD0 + 16	; Change block size
   163 = 0051			CMD17		EQU	CMD0 + 17	; Read single block
   164 = 0058			CMD24		EQU	CMD0 + 24	; Write single block
   165 = 0077			CMD55		EQU	CMD0 + 55	; Application command prefix
   166 = 007A			CMD58		EQU	CMD0 + 58	; Get OCR
   167 = 0069			ACMD41		EQU	CMD0 + 41	; Initialize SDC
   168
   169 = 00FE			DATA_TOKEN	EQU	$FE             ; SD-Card Data Token
   170
   171 				; FAT Types ********************************************************************
   172 = 0002			FAT12_Type      EQU     $02
   173 = 0001			FAT16_Type      EQU     $01
   174 = 0000			FAT32_Type      EQU     $00
   175
   176 				; Directory Descriptor (32 Bytes) **********************************************
   177 				; Index of fields in a directory entry
   178 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   179 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   180 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   181 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   182 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   183 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   184 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   185 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   186 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   187 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   188 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   189
   190 				; FGC VPU Constants ************************************************************
   191
   192 				; Mode Registers
   193 = 0080			VPU_REG0        EQU     $80           ; Mode Register 0
   194 = 0081			VPU_REG1        EQU     VPU_REG0+1    ; Mode Register 1
   195 = 0088			VPU_REG8        EQU     VPU_REG0+8    ; Mode Register 2
   196 = 0089			VPU_REG9        EQU     VPU_REG0+9    ; Mode Register 3
   197
   198 				; Table Base Address Registers
   199 = 0082			VPU_REG2        EQU     VPU_REG0+2    ; Pattern name table base address register
   200 = 0083			VPU_REG3        EQU     VPU_REG0+3    ; Color table base address register low
   201 = 008A			VPU_REG10       EQU     VPU_REG0+10   ; Color table base address register high
   202 = 0084			VPU_REG4        EQU     VPU_REG0+4    ; Pattern generator table base address register
   203 = 0085			VPU_REG5        EQU     VPU_REG0+5    ; Sprite attribute table base address register low
   204 = 008B			VPU_REG11       EQU     VPU_REG0+11   ; Sprite attribute table base address register high
   205 = 0086			VPU_REG6        EQU     VPU_REG0+6    ; Sprite pattern generator table base address register
   206
   207 				; Color Registers
   208
   209 = 0087			VPU_REG7        EQU     VPU_REG0+7    ; Text color/Back drop color register
   210 = 008C			VPU_REG12       EQU     VPU_REG0+12   ; Text blink color/Back blink color register
   211 = 008D			VPU_REG13       EQU     VPU_REG0+13   ; Blinking period register
   212 = 0094			VPU_REG20       EQU     VPU_REG0+20   ; Color burst register 1
   213 = 0095			VPU_REG21       EQU     VPU_REG0+21   ; Color burst register 2
   214 = 0096			VPU_REG22       EQU     VPU_REG0+22   ; Color burst register 3
   215
   216 				; Display Registers
   217
   218 = 0092			VPU_REG18       EQU     VPU_REG0+18   ; Display adjust register
   219 = 0097			VPU_REG23       EQU     VPU_REG0+23   ; Display offset register
   220 = 0093			VPU_REG19       EQU     VPU_REG0+19   ; Interrupt line register
   221
   222 				; Access Registers
   223
   224 = 008E			VPU_REG14       EQU     VPU_REG0+14   ; VRAM Access base address register
   225 = 008F			VPU_REG15       EQU     VPU_REG0+15   ; Status register pointer
   226 = 0090			VPU_REG16       EQU     VPU_REG0+16   ; Color pallete address register
   227 = 0091			VPU_REG17       EQU     VPU_REG0+17   ; Control register pointer
   228
   229 				; Command Registers
   230
   231 = 00A0			VPU_REG32       EQU     VPU_REG0+32   ; Source X low register
   232 = 00A1			VPU_REG33       EQU     VPU_REG0+33   ; Source X high register
   233 = 00A2			VPU_REG34       EQU     VPU_REG0+34   ; Source Y low register
   234 = 00A3			VPU_REG35       EQU     VPU_REG0+35   ; Source Y high register
   235
   236 = 00A4			VPU_REG36       EQU     VPU_REG0+36   ; Destination X low register
   237 = 00A5			VPU_REG37       EQU     VPU_REG0+37   ; Destination X high register
   238 = 00A6			VPU_REG38       EQU     VPU_REG0+38   ; Destination Y low register
   239 = 00A7			VPU_REG39       EQU     VPU_REG0+39   ; Destination Y high register
   240
   241 = 00A8			VPU_REG40       EQU     VPU_REG0+40   ; Number of dots X low register
   242 = 00A9			VPU_REG41       EQU     VPU_REG0+41   ; Number of dots X high register
   243 = 00AA			VPU_REG42       EQU     VPU_REG0+42   ; Number of dots Y low register
   244 = 00AB			VPU_REG43       EQU     VPU_REG0+43   ; Number of dots Y high register
   245
   246 = 00AC			VPU_REG44       EQU     VPU_REG0+44   ; Color register
   247 = 00AD			VPU_REG45       EQU     VPU_REG0+45   ; Argument register
   248 = 00AE			VPU_REG46       EQU     VPU_REG0+46   ; Command register
   249
   250 				; Status Registers
   251
   252 = 0000			VPU_STAT0       EQU     0             ; Status register 0
   253 = 0001			VPU_STAT1       EQU     1             ; Status register 1
   254 = 0002			VPU_STAT2       EQU     2             ; Status register 2
   255 = 0003			VPU_STAT3       EQU     3             ; Status register 3
   256 = 0004			VPU_STAT4       EQU     4             ; Status register 4
   257 = 0005			VPU_STAT5       EQU     5             ; Status register 5
   258 = 0006			VPU_STAT6       EQU     6             ; Status register 6
   259 = 0007			VPU_STAT7       EQU     7             ; Status register 7
   260 = 0008			VPU_STAT8       EQU     8             ; Status register 8
   261 = 0009			VPU_STAT9       EQU     9             ; Status register 9
   262
   263 				; Basic Mode Settings
   264
   265 = 0000			VPU_MODE_REG0   EQU     $00           ; DG = 0, IE2 = 0, IE1 = 0, M3..5 = xxx
   266 = 0042			VPU_MODE_REG1   EQU     $42           ; BL = 1, IE0 = 0, M1..2 = xx, SI = 1, MA = 0,
   267 = 000A			VPU_MODE_REG2   EQU     $0A           ; MS = 0, LP = 0, CB = 0, VR = 1, SPD = 1, BW = 0
   268 = 0002			VPU_MODE_REG3   EQU     $02           ; LN = 0, S1 = 0, S0 = 0, IL = 0, E = 0,NT = 1, DC = 0
   269
   270 = 0010			VPU_MODE0       EQU     $10
   271 = 0012			VPU_MODE1       EQU     $12
   272 = 0003			VPU_MODE4       EQU     $03
   273 = 0004			VPU_MODE5       EQU     $04
   274 = 0005			VPU_MODE6       EQU     $05
   275 = 0007			VPU_MODE7       EQU     $07
   276
   277 						
    72 						ICL "jc2_macros.inc"		; JC2 macro definitions for MADS
Source: jc2_macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTRM	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	PHX					; Push X-register
    88 					TXA
    89 					PHA
    90 				.endm
    91
    92 				.macro	PLX					; Pull X-register
    93 					PLA
    94 					TAX
    95 				.endm
    96
    97 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    98 					LDX	#:n-1
    99 				lp	MVA	:src,X :dst,X-
   100 					BPL	lp
   101 				.endm
   102 					
   103 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
   104 					LDY	#:n-1
   105 				lp	MVA	:src,Y :dst,Y-
   106 					BPL	lp
   107 				.endm
   108
   109 				; Macros used for printing a cluster nr, which consists of 2 words
   110 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   111 						LDA	(:c),Y
   112 					ift :0>1	; st also given?
   113 						STA	:st
   114 					eif	
   115 						JSR	HEXOUT			; changes Y!
   116 				.endm		
   117
   118 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   119 						LDY	#:indx+1		; Print MSB of word
   120 					ift :0>2	; stor also given?	
   121 						PRCLB	:curr_dir :stor+1
   122 					els	
   123 						PRCLB	:curr_dir
   124 					eif
   125 						LDY	#:indx			; Print LSB of word
   126 					ift :0>2	; stor also given?	
   127 						PRCLB	:curr_dir :stor
   128 					els	
   129 						PRCLB	:curr_dir
   130 					eif
   131 				.endm
   132
   133 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   134 					ift :b2>7
   135 						ERT "Only bits 7-0 allowed"
   136 					els
   137 						LDA	:b1
   138 						AND	#(1 << :b2)
   139 						BEQ	:lbl1
   140 					eif
   141 				.endm
   142 					
   143 				; ----------------------------------------------
   144 				; Compare + Branch Macros
   145 				; ----------------------------------------------
   146 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   147 						CMP	:b1
   148 						BEQ	:lbl
   149 				.endm		; A is now not equal to b1
   150 					
   151 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   152 						CMP	:b1
   153 						BNE	:lbl
   154 				.endm		; A is now equal to b1
   155
   156 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   157 				CMP.CC	.macro ' '	b1 lbl
   158 						CMP	:b1			; 
   159 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   160 				.endm		; C is now 1 (A-b1 is >= 0)
   161
   162 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   163 				CMP.CS	.macro ' '	b1 lbl
   164 						CMP	:b1			; 
   165 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   166 				.endm		; C is now 0 (A-b1 is < 0)
   167
   168 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   169 						CPX	:b1
   170 						BEQ	:lbl
   171 				.endm		; X is now not equal to b1
   172 					
   173 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   174 						CPX	:b1
   175 						BNE	:lbl
   176 				.endm		; X is now equal to b1
   177
   178 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   179 				CPX.CC	.macro ' '	b1 lbl
   180 						CPX	:b1			; 
   181 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   182 				.endm		; C is now 1 (X-b1 is >= 0)
   183
   184 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   185 				CPX.CS	.macro ' '	b1 lbl
   186 						CPX	:b1			; 
   187 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   188 				.endm		; C is now 0 (X-b1 is < 0)
   189
   190 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   191 						CPY	:b1
   192 						BEQ	:lbl
   193 				.endm		; Y is now not equal to b1
   194 					
   195 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   196 						CPY	:b1
   197 						BNE	:lbl
   198 				.endm		; Y is now equal to b1
   199
   200 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   201 				CPY.CC	.macro ' '	b1 lbl
   202 						CPY	:b1			; 
   203 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   204 				.endm		; C is now 1 (Y-b1 is >= 0)
   205
   206 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   207 				CPY.CS	.macro ' '	b1 lbl
   208 						CPY	:b1			; 
   209 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   210 				.endm		; C is now 0 (Y-b1 is < 0)
   211
   212 				; ----------------------------------------------
   213 				; Increment/Decrement + Branch Macros
   214 				; ----------------------------------------------
   215 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   216 						DEC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   221 						DEC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   226 						INC	:b1
   227 						BEQ	:lbl
   228 				.endm
   229
   230 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   231 						INC	:b1
   232 						BNE	:lbl
   233 				.endm
   234
   235 				; ----------------------------------------------
   236 				DEX.NE	.macro 	lbl				; DEX + BNE
   237 						DEX
   238 						BNE	:lbl
   239 				.endm
   240
   241 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   242 						DEX
   243 						BEQ	:lbl
   244 				.endm
   245
   246 				DEX.PL	.macro 	lbl				; DEX + BPL 
   247 						DEX
   248 						BPL	:lbl
   249 				.endm
   250
   251 				DEX.MI	.macro 	lbl				; DEX + BMI
   252 						DEX
   253 						BMI	:lbl
   254 				.endm
   255
   256 				DEX.CC	.macro 	lbl				; DEX + BCC 
   257 						DEX
   258 						BCC	:lbl
   259 				.endm
   260
   261 				DEX.CS	.macro 	lbl				; DEX + BCS
   262 						DEX
   263 						BCS	:lbl
   264 				.endm
   265
   266 				; ----------------------------------------------
   267 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   268 						DEY
   269 						BEQ	:lbl
   270 				.endm
   271
   272 				DEY.NE	.macro 	lbl				; DEY + BNE
   273 						DEY
   274 						BNE	:lbl
   275 				.endm
   276
   277 				DEY.PL	.macro 	lbl				; DEY + BPL 
   278 						DEY
   279 						BPL	:lbl
   280 				.endm
   281
   282 				DEY.MI	.macro 	lbl				; DEY + BMI
   283 						DEY
   284 						BMI	:lbl
   285 				.endm
   286
   287 				DEY.CC	.macro 	lbl				; DEY + BCC 
   288 						DEY
   289 						BCC	:lbl
   290 				.endm
   291
   292 				DEY.CS	.macro 	lbl				; DEY + BCS
   293 						DEY
   294 						BCS	:lbl
   295 				.endm
   296 				; ----------------------------------------------
   297
   298 				; ----------------------------------------------
   299 				; LOAD/STORE + Branch Macros
   300 				; ----------------------------------------------
   301 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   302 						LDA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   307 						LDA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   312 						STA	:b1
   313 						BEQ	:lbl
   314 				.endm
   315
   316 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   317 						STA	:b1
   318 						BNE	:lbl
   319 				.endm
   320
   321 				; ----------------------------------------------
   322 				; AND/OR + Branch Macros
   323 				; ----------------------------------------------
   324 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   325 					ift :0>2	; LDA + AND + BEQ	
   326 						LDA	:p1
   327 						AND	:p2
   328 						BEQ	:p3
   329 					els		; AND + BEQ
   330 						AND	:p1
   331 						BEQ	:p2
   332 					eif
   333 				.endm
   334
   335 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   336 					ift :0>2	; LDA + AND + BNE	
   337 						LDA	:p1
   338 						AND	:p2
   339 						BNE	:p3
   340 					els		; AND + BNE
   341 						AND	:p1
   342 						BNE	:p2
   343 					eif
   344 				.endm
   345
   346 				.macro		ADCAW			; Add A to word and store in word
   347 						CLC
   348 						ADC	:1
   349 						STA	:1
   350 						LDA	:1+1
   351 						ADC	#0
   352 						STA	:1+1
   353 				.endm
    73 						ICL "jc2_bios_calls.inc"	; JC2 BIOS routines
Source: jc2_bios_calls.inc
     1 				;-------------------------------------------------
     2 				; JC2 BIOS Calls, checked for: V1.2.5
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------
     5
     6 = B000			LAB_COLD	=	$B000			; BASIC cold START
     7 = E000			MON_COLD_START  EQU     $E000
     8 = E003			MON_WARM_START  EQU     $E003
     9 = E006			SWITCH_TO_RAM	EQU	$E006			; Switch Basic to RAM Page ($B000-$DFFF)
    10 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    11 = E00E			_NO_HANDLER_	EQU	$E00E			; Just RTS
    12 = E047			CIN             EQU     $E047
    13 = E052			COUT            EQU     $E052
    14 = E05A			CROUT           EQU     $E05A
    15 = E05E			SPCOUT          EQU     $E05E
    16 = E062			STRIN           EQU     $E062
    17 = E083			STROUT          EQU     $E083
    18 = E085			WRSTR           EQU     $E085
    19 = E091			HEXOUT          EQU     $E091
    20 = E09A			HEXDIG          EQU     $E09A
    21 = E0B5			CLRSCRN         EQU     $E0B5
    22 = E0BD			DEC2STR         EQU     $E0BD
    23 = E0BA			CMDDEV          EQU     $E0BA
    24 = E1A7			ADD_DEVICE	EQU	$E1A7
    25 = E14D			DELAY		EQU	$E14D
    26 = E167			BEEP            EQU     $E167
    27 = E1AA			OPEN_DEVICE     EQU     $E1AA
    28 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    29 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    30
    31 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    32 = F68B			INIT_BLKBUF	EQU	$F68B
    33 = F8B5			CFWAIT		EQU	$F8B5
    34 = F960			VPU_IRQ		EQU	$F960
    35 = F9A0			VDP_DEV		EQU	$F9A0
    36 = FC85			LOAD_LBA_CF	EQU	$FC85
    37 = FD53			SET_RAMBANK	EQU	$FD53			; BIOS v1.2.4
    38 = FD7D			MON2ROM		EQU	$FD7D			; Monitor to ROM
    39 = FD86			MON2RAM		EQU	$FD86			; Monitor to RAM, enable RAM behind it
    40
    41
    74 						
    75 				.if	USE_XMODEM = 1
    76 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    77 				.endif
    78
    79 				; ******************************************************************************
    80 				; Start of 1st Block of BOOT.SYS ***********************************************
    81 				; ******************************************************************************
    82 = 4000			LOAD_ADDRESS	EQU	$4000
    83 						ORG	LOAD_ADDRESS		; the program start address
    84 				PROG_START					; Program Start Address
    85 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				;-------------------------------------------------------------------------------
    11
    12 				; subtract two clusters from START_CLUSTER address *****************************
    13 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    14 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    15 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    16 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    17 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    18 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    19 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    20 4012 A2 01		                LDX     #$01
    21 4014 A0 03		                LDY     #$03
    22 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    23 4019 E9 00		                SBC     #$00
    24 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    25 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: jc2_macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    26 				                
    27 				; initialize current FAT block value with 0 ************************************
    28 4022 8C 24 04		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    29 4025 8C 25 04		                STY     CURR_FAT_BLK+1
    30 4028 8C 26 04		                STY     CURR_FAT_BLK+2
    31 402B 8C 27 04		                STY     CURR_FAT_BLK+3
    32 				                
    33 				; set first cluster of BOOT.SYS as the current cluster *************************
    34 402E A0 15		INIT3           LDY     #$15
    35 4030 A2 03		                LDX     #$03
    36 4032 20 7D 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    37 4035 A0 1B		                LDY     #$1B
    38 4037 20 7D 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    39 				                
    40 				; calculate BOOTS.SYS file size in blocks **************************************
    41 403A A9 5A		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    42 403C 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    43 403F 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    44 4040 85 A3		                STA     BCNT                	; store result into block counter
    45 4042			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4042 A9 AD				LDA	#<BOOT_SYS_END
     2 4044 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    46 4046 E6 A3		                INC     BCNT                	; some bytes are left, so increment block counter
    47 				                
    48 				; load all blocks of BOOT.SYS file into memory *********************************
    49 4048			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 4048 C6 A3				DEC	BCNT
     2 404A F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    50 404C AD 0B 04 85 A5	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    51 4051			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 4051 C6 A5				DEC	SCNT
     2 4053 F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    52 4055 20 8D 41		                JSR     INC_32              	; no, increment block address
    53 4058			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: jc2_macros.inc]
     1 4058 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 405A A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    54 405C 20 57 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    55 405F			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 405F C6 A3				DEC	BCNT
     2 4061 F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    56 4063 D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    57
    58 				; next cluster needs to be loaded considering the volume FAT type **************
    59 4065 20 88 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    60 4068 B0 0B		                BCS     OS_START            	; if EOF then start OS
    61 						
    62 406A 20 02 41		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    63 406D AD 0B 04 85 A5	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    64 4072 4C 58 40		                JMP     LOAD_BLK            	; load first block of cluster
    65 				                
    66 4075 A9 00 8D 28 18	OS_START        MVA	#0 DBG_PRINT		; 0 = No debug print info
    67 407A 4C 18 42				JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 407D 20 80 40		SET_WORD        JSR     SET_BYTE
    74 4080 B1 EA 88 9D 20 04 + SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 4087 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 4088			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: jc2_macros.inc]
     1 4088 A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 408A A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 408C 20 6D 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 408F			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 408F AD 0A 04				LDA	D_FAT_TYPE
     2 4092 F0 16				BEQ	FAT32
Source: boot_sys_block1.asm
    85 4094					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4094 C9 01				CMP	#FAT16_TYPE
     2 4096 F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 4098 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 4099 AE 21 04		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 409C 20 8F 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 409F 20 27 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 40A2 AD 20 04		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 40A5 A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 40A7 4C CB 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 40AA			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: jc2_macros.inc]
     1 40AA A2 21			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40AC A0 04			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40AE 20 67 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40B1 A2 00 86 C7				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40B5 A0 03		                LDY     #$03
   106 40B7 AD 20 04		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40BA 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40BB 48			                PHA                         	; save entry index to stack
   109 40BC 36 C4 E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40BF			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: jc2_macros.inc]
     1 40BF 88					DEY
     2 40C0 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40C2 20 9B 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40C5 20 27 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40C8 68			                PLA                         	; restore entry index
   116 40C9 A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40CB			READ_FAT_ENTRY  
   127 40CB A0 FF 84 A2				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40CF 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40D0 A8			                TAY                         	; store entry index into Y
   130 40D1 86 A4		                STX     NCNT                	; store length of entry
   131 40D3 A2 00 86 A6		                MVX     #$00 RES		;
   132 40D7 20 F8 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40DA 9D 20 04		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40DD 08			                PHP                         	; save carry flag
   135 40DE			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: jc2_macros.inc]
     1 40DE E0 03				CPX	#$03
     2 40E0 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40E2 A2 0F 86 A2		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40E6			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: jc2_macros.inc]
     1 40E6 C5 A2				CMP	MASK
     2 40E8 D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40EA 85 A6		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40EC 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40ED C8			                INY
   141 40EE E8			                INX
   142 40EF			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: jc2_macros.inc]
     1 40EF C6 A4				DEC	NCNT
     2 40F1 D0 E4				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40F3 A5 A6		                LDA     RES
   144 40F5 C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40F7 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40F8 B0 04		READ_ENTRY_BYTE BCS	RD_UPPER_PAGE				; if $40..$7F then read byte from upper half of block
   152
   153 40FA B9 00 06		                LDA     FAT_BUF,Y        			; read entry byte from lower half of block buffer
   154 40FD 60			                RTS			    			; return
   155 40FE B9 00 07		RD_UPPER_PAGE   LDA     FAT_BUF+256,Y    			; read entry byte from upper half of block buffer
   156 4101 60			                RTS			    			; return
   157 				                
   158 				; **** Calculate LBA From Given Cluster Address ********************************
   159 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   160 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   161 				;
   162 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   163 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   164 				; ******************************************************************************
   165 4102			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: jc2_macros.inc]
     1 4102 A2 20			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 4104 A0 04			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   166 4106 20 6D 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   167 4109 AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   168 410C 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   169 410D F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   170 						
   171 410F A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   172 4111 A0 04		                LDY     #$04
   173 4113 18			                CLC
   174 4114 36 C0 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   175 4117			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: jc2_macros.inc]
     1 4117 88					DEY
     2 4118 D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   176 						
   177 411A 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   178 411B D0 F2		                BNE     LOOP1		     	; 
   179 						
   180 411D			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: jc2_macros.inc]
     1 411D A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 411F A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   181 4121 20 67 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   182 4124 4C 9B 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   183
   184 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   185 				; Input: NUM32: LBA number of FAT sector to load
   186 				; ******************************************************************************
   187 4127 A2 03		LOAD_FAT_BLK    LDX     #$03
   188 4129 86 A6		                STX     RES                 	; initialize byte counter
   189 				                
   190 				; check if current FAT block and last loaded FAT block are identical ***********
   191 412B B5 C0		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   192 412D			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: jc2_macros.inc]
     1 412D DD 24 04				CMP	CURR_FAT_BLK,X
     2 4130 D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   193 						
   194 4132 C6 A6		                DEC     RES                 	; if equal decrement number of unequal bytes
   195 4134 9D 24 04 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   196 4138 10 F1		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   197 						
   198 413A A5 A6		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   199 413C 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   200 				                
   201 413E			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: jc2_macros.inc]
     1 413E A5 DC			LDA	BLKBUF
     2 4140 48				PHA
     3 4141 A5 DD			LDA	BLKBUF+1
     4 4143 48				PHA
Source: boot_sys_block1.asm
   202 4144			                LDXYI   NUM32
Macro: LDXYI [Source: jc2_macros.inc]
     1 4144 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4146 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   203 4148 20 52 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($0600)
   204 414B					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: jc2_macros.inc]
     1 414B 68				PLA
     2 414C 85 DD			STA	BLKBUF+1
     3 414E 68				PLA
     4 414F 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   205 4151 60			LOAD_FAT_END    RTS
   206 				                
   207 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   208 				; Input: [X,Y] points to 32-bit LBA
   209 				; ******************************************************************************
   210 4152 A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   211 4154 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   212 				                
   213 				; **** Read Logical Block ******************************************************
   214 				; Input: [X,Y] points to 32-bit LBA
   215 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   216 				; ******************************************************************************
   217 4157 A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   218 4159 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   219 				                
   220 				; Arithmetic Functions *********************************************************
   221 				; ******************************************************************************
   222
   223 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   224 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   225 				; ******************************************************************************
   226 415C			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: jc2_macros.inc]
     1 415C 86 C0			STX	NUM32
     2 415E 84 C1			STY	NUM32+1
Source: boot_sys_block1.asm
   227 4160 A2 00 86 C2 86 C3			MWX	#0 NUM32+2		; Zero upper 16-bits
   228 4166 60			                RTS			   	; return
   229 				                
   230 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   231 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   232 				; ******************************************************************************
   233 4167 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   234 4169 A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   235 416B D0 04		                BNE     LOAD_32_1	   	; branch always
   236
   237 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   238 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   239 				; ******************************************************************************
   240 416D 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   241 416F A2 03		                LDX     #$03
   242 4171 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   243 4173 A0 03		                LDY     #$03
   244 4175 B1 E8 95 C0 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   245 417A			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: jc2_macros.inc]
     1 417A 88					DEY
     2 417B 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   246 417D 60			                RTS			   	; return
   247 				                
   248 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   249 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   250 				; ******************************************************************************
   251 417E			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: jc2_macros.inc]
     1 417E 86 E8			STX	STOL
     2 4180 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   252 4182 A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   253 4184 B9 C0 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   254 418A 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   255 418C 60			                RTS			   	; return
   256
   257 				; **** Increment a 32 Bit Value ************************************************
   258 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   259 				; ******************************************************************************
   260 418D A2 01		INC_32          LDX     #$01
   261
   262 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   263 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   264 				; ******************************************************************************
   265 418F A0 00		ADD_32_8        LDY     #$00
   266
   267 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   268 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   269 				; ******************************************************************************
   270 4191			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: jc2_macros.inc]
     1 4191 86 C4			STX	SUM32
     2 4193 84 C5			STY	SUM32+1
Source: boot_sys_block1.asm
   271 4195 A2 00 86 C6 86 C7			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   272
   273 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   274 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   275 				; ******************************************************************************
   276 419B 18			ADD_32_32       CLC			   	; clear carry flag
   277 419C A2 00		                LDX     #$00		   	; start with byte 0
   278 419E 08			                PHP			   	; save carry flag
   279 419F 28			ADD_LOOP        PLP			   	; get carry flag back
   280 41A0 B5 C4		                LDA     SUM32,X		   	; Get SUM32 byte
   281 41A2 75 C0 95 C0		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   282 41A6 08			                PHP			   	; save carry flag
   283 41A7 E8			                INX			   	; next byte
   284 41A8			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: jc2_macros.inc]
     1 41A8 E0 04				CPX	#$04
     2 41AA D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   285 41AC 28			                PLP			   	; restore stack
   286 41AD 60			                RTS			   	; return
    86 				               
    87 				; ******************************************************************************
    88 				; Start of remaining BOOT.SYS blocks *******************************************
    89 				; ******************************************************************************
    90 41AE					ORG     LOAD_ADDRESS + $0200
    91 4200			BLOCK_2
    92 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------------------------------------
     5
     6 				; ******************************************************************************
     7 				; NUM32 shl X
     8 				; ******************************************************************************
     9 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: jc2_macros.inc]
     1 4200 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4202 26 C1		        ROL     NUM32+1		  
     3 4204 26 C2		        ROL     NUM32+2
     4 4206 26 C3		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    10 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: jc2_macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    11 420B 60			                RTS			  	; return
    12
    13 				; ******************************************************************************
    14 				; NUM32 shr X
    15 				; ******************************************************************************
    16 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: jc2_macros.inc]
     1 420C 46 C3			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 C2		        ROR     NUM32+2
     3 4210 66 C1		        ROR     NUM32+1
     4 4212 66 C0		        ROR     NUM32
Source: boot_sys_os.asm
    17 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: jc2_macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    18 4217 60			                RTS			  	; return
    19 				                
    20 				; ******************************************************************************
    21 				; *                               OS Entry Point                               *
    22 				; ******************************************************************************
    23 4218			OS_MAIN         PRSTRM	MSG_BOOT			; Print boot-message
Macro: PRSTRM [Source: jc2_macros.inc]
     1 4218 A2 D7			LDX	<MSG_BOOT				; MADS makes this immediate
     2 421A A0 4B			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 421C 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    24 421F 20 E3 49		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    25 				                
    26 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    27 4222 A9 20 8D 06 18 A9 + 		MWA	#MON_RAM_BLOCK.CFC_LOAD CF_LOAD_VEC	; CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    28 422C A9 5B 8D 08 18 A9 + 		MWA	#MON_RAM_BLOCK.CFC_SAVE CF_SAVE_VEC	; CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    29 4236 20 28 54				JSR	CP_MON_RAM				; Copy BASIC related DOS functions to Monitor RAM
    30 4239 A9 1A 8D 0A 18 A9 + 		MWA	#MON_RAM_BLOCK.DOS_JMP_RET RETURN_VECT	; Return-vector for Monitor and BASIC
    31 4243 A2 00 86 01 86 02			MWX	#0 Wrmjpl				; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    32 				                
    33 				; Clear Mount Table ************************************************************
    34 4249 18			                CLC
    35 424A A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    36 424F 8A					TXA                          		; index to mount table into A
    37 4250 69 20		                ADC     #$20                 		; set to next entry
    38 4252 AA			                TAX
    39 4253 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    40 				                
    41 				; Set Boot Device As Current Device ********************************************
    42 4255 A2 00		                LDX     #$00		     	; X=0
    43 4257 A0 00		                LDY     #$00                 	; set index to mount table = 0
    44 4259 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    45 425C			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 425C C9 22				CMP	#FDD1_ID
     2 425E F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    46 4260 E8			                INX		     	     	; X=2
    47 4261 A0 20		                LDY     #$20                 	; set index to mount table = 32
    48 4263			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4263 C9 23				CMP	#FDD2_ID
     2 4265 F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    49 4267 E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    50 4268 A0 40		                LDY     #$40                 	; set index to mount table = 64
    51 426A 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    52
    53 				; Add Boot Device To Mount Table ***********************************************
    54 426D A2 00		                LDX     #$00
    55 426F BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    56 4277			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: jc2_macros.inc]
     1 4277 E0 20				CPX	#32
     2 4279 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    57 427B A9 F8		                LDA     #$F8
    58 427D			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: jc2_macros.inc]
     1 427D CD 09 04				CMP	D_MEDIUM_DESCR
     2 4280 D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    59 4282 A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    60 4287			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4287 AD 0A 04				LDA	D_FAT_TYPE
     2 428A F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    61 428C A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    62 428E			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: jc2_macros.inc]
     1 428E 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 4291 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    63 4294					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: jc2_macros.inc]
     1 4294 CA					DEX
     2 4295 D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    64 				                
    65 				; TODO: ADD MORE DEVICES #######################################################
    66
    67 				; **** Shell Entry Point *******************************************************
    68 				; ******************************************************************************
    69 4297 20 F9 57		OS_SHELL_ENTRY  JSR	GET_SIS		     		; Get sys. info sector		
    70 429A 4C 4A 4C				JMP     SH_CMD_PROMPT			; start of command shell
    71
    72 				; **** Read First Block Of Actual Directory ************************************
    73 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    74 				; ******************************************************************************
    75 429D			OS_FIRST_DIR_BLK
    76 429D			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 429D AD 0A 04				LDA	D_FAT_TYPE
     2 42A0 F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    77 42A2 20 D2 49		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    78 42A5 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    79
    80 42A7					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: jc2_macros.inc]
     1 42A7 A2 03			LDX	#4-1
     2 42A9 BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42B0 10 F7			BPL	lp
Source: boot_sys_os.asm
    81 42B2 AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    82 42B5 D0 18		                BNE     SET_NUM_BLOCKS       		; branch always
    83
    84 42B7			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: jc2_macros.inc]
     1 42B7 A2 03			LDX	#4-1
     2 42B9 BD 04 04 9D 20 04 + lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C0 10 F7			BPL	lp
Source: boot_sys_os.asm
    85 42C2 20 02 41		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
    86 42C5			                LDXYI   CURR_DIR_BLK			; LBA of current directory
Macro: LDXYI [Source: jc2_macros.inc]
     1 42C5 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42C7 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
    87 42C9 20 7E 41		                JSR     STORE_32             		; and save result as current directory block
    88 42CC AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
    89 42CF 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
    90
    91 				; **** Load Directory Block ****************************************************
    92 				; This routine reads a directory block into DIR_BLK_BUF.
    93 				; It is called from OS_NEXT_DIR_BLK.
    94 				; ******************************************************************************
    95 42D2 A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
    96 42DA					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: jc2_macros.inc]
     1 42DA A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42DC A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
    97 42DE 4C 57 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
    98
    99 				; **** Read Next Directory Block ***********************************************
   100 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   101 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   102 				; ******************************************************************************
   103 42E1 A2 00		OS_NEXT_DIR_BLK LDX     #$00
   104 42E3			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: jc2_macros.inc]
     1 42E3 FE 24 18				INC	CURR_DIR_BLK,X
     2 42E6 D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   105 42E8 E8			                INX                          		; overflow, increment next byte
   106 42E9			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: jc2_macros.inc]
     1 42E9 C9 04				CMP	#$04
     2 42EB D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   107 42ED F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   108
   109 				; **** Read Next Directory Cluster *********************************************
   110 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   111 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   112 				; ******************************************************************************
   113 42EF			OS_NEXT_DIR_CLSTR
   114 42EF 20 88 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   115 42F2 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   116 42F4 60			                RTS			     ; return
   117 				                
   118 				; **** Save Directory Block ****************************************************
   119 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   120 				; Input: X,Y = Pointer to LBA nr.
   121 				; ******************************************************************************
   122 42F5 86 D8		OS_SAVE_DIR     STX	SAVEX				; TODO: remove SAVEX, SAVEY ?
   123 42F7 84 D9				STY	SAVEY
   124 42F9 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF		; set source block buffer to DIR_BLK_BUF
   125 4301 A6 D8		                LDX     SAVEX       			; pointer to block number (LBA) to be saved
   126 4303 A4 D9		                LDY     SAVEY
   127 4305 4C 98 1E		                JMP     MON_RAM_BLOCK.DEV_WR_LBLK	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   128 				                
   129 				; **** Save FAT Block **********************************************************
   130 				; Write FAT table in FAT_BUF ($0600) to disk with LBA nr in X,Y.
   131 				; Input: X,Y = Pointer to LBA nr.
   132 				; ******************************************************************************
   133 4308			OS_SAVE_FAT     LDXYI	CURR_FAT_BLK			; LBA nr of FAT
Macro: LDXYI [Source: jc2_macros.inc]
     1 4308 A2 24			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 430A A0 04			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   134 430C 4C AD 1E		                JMP     MON_RAM_BLOCK.DEV_WR_LBLK_BUF   ; write FAT buffer and return
   135
   136 				; **** Create New File on Disk *************************************************
   137 				; Input: FILENAME = String8_3
   138 				;        A        = File Attributes
   139 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   140 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   141 				; ******************************************************************************
   142 430F AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   143 4310 A0 00		                LDY     #D_FILENAME         		; set index to filename
   144 4312 B9 3E 4C 91 A0 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   145 4318			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: jc2_macros.inc]
     1 4318 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 431A 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   146 						
   147 						; Write Attribute
   148 431C 8A			                TXA                         	; yes, get attribute back to A
   149 431D 91 A0		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   150 431F A9 00		                LDA     #$00                	; and clear all following bytes to 0
   151 4321 C8			                INY
   152 4322			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: jc2_macros.inc]
     1 4322 C0 20				CPY	#$20			; 
     2 4324 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   153 						
   154 						; Write create-Date and Last-write Date
   155 4326 20 B0 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   156 4329 98			                TYA				; Y = MSB
   157 432A A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   158 432C 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   159 432E A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   160 4330 91 A0 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   161 4333 8A			                TXA				; X = LSB
   162 4334 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   163 4336 A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   164 4338 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   165
   166 						; Write create-Time and last-write Time
   167 433A 20 8B 43		                JSR     OS_FILETIME         	; get current time as file time
   168 433D 98			                TYA				; Y = MSB
   169 433E A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   170 4340 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   171 4342 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   172 4344 91 A0 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   173 4347 8A			                TXA				; X = LSB
   174 4348 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   175 434A A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   176 434C 91 A0		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   177
   178 						; Write File Cluster Nr High and Low
   179 434E A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   180 4350 AD 23 18 91 A0 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   181 4356 AD 22 18 91 A0			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   182 435B A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   183 435D AD 21 18 91 A0 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   184 4363 AD 20 18 91 A0			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   185 						
   186 4368 AD 12 18				LDA     F_ATTRIBS				; Get file/dir attributes again
   187 436B					AND.NE  #FA_DIRECTORY OS_CR_SAV			; create a dir? Branch if it is a dir
Macro: AND.NE [Source: jc2_macros.inc]
     6 436B 29 10				AND	#FA_DIRECTORY
     7 436D D0 15				BNE	OS_CR_SAV
Source: boot_sys_os.asm
   188
   189 436F A0 1C		                LDY     #D_FILE_SIZE      			; index to file size in dir. entry
   190 4371 AD D3 56 91 A0 C8 + 		MWA	SAVE_LEN (CURR_DIR_ENTRY),Y+		; Save file-length in current dir. entry
   191 437D A9 00 91 A0 C8 91 + 		MWA	#0 (CURR_DIR_ENTRY),Y			; Set high-word of file-size to 0
   192 						
   193 4384			OS_CR_SAV	LDXYI	CURR_DIR_BLK				; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: jc2_macros.inc]
     1 4384 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 4386 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   194 4388 4C F5 42		                JMP     OS_SAVE_DIR	    			; write this dir entry back to disk and return
   195 				                
   196 				; **** Get Current Time As File Time *******************************************
   197 				; Output: File Time = Word[X,Y]
   198 				; ******************************************************************************
   199 438B 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   200
   201 				; **** Convert Time To File Time ***********************************************
   202 				; Input:  A - HOUR 	in BCD ($00-$23)
   203 				;	  X - MINUTE 	in BCD ($00-$59)
   204 				;	  Y - SECONDS	in BCD ($00-$59)
   205 				; Output: File Time = Word[X,Y]
   206 				; ******************************************************************************
   207 438E			OS_TIME_TO_FILETIME
   208 438E 20 D7 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   209 4391 85 C0		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   210 4393 A9 00 85 C1				MVA	#$00 NUM32+1	    ; clear upper byte of result
   211 4397 A2 06		                LDX     #$06
   212 4399 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   213 439C A5 C5		                LDA     SUM32+1             ; load MINUTE into A
   214 439E 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   215 43A2 A2 05		                LDX     #$05
   216 43A4 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   217 43A7 A5 C6		                LDA     SUM32+2             ; load SECONDS into A
   218 43A9 6A			                ROR                         ; divide SECONDS by 2
   219 43AA 05 C0		                ORA     NUM32               ; and add value into result
   220 43AC AA			                TAX
   221 43AD A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   222 43AF 60			                RTS
   223 				                
   224 				; **** Get Current Date As File Date *******************************************
   225 				; Output: File Date = Word[X,Y]
   226 				; ******************************************************************************
   227 43B0 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   228
   229 				; **** Convert Date To File Date ***********************************************
   230 				; Input:  A - YEAR 	in BCD ($00-$99)
   231 				; 	  X - MONTH 	in BCD ($01-$12)
   232 				; 	  Y - DAY	in BCD ($01-$31)
   233 				; Output: File Date = Word[X,Y]
   234 				; ******************************************************************************
   235 43B3			OS_DATE_TO_FILEDATE
   236 43B3 20 D7 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   237 43B6 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   238 43B9 85 C0		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   239 43BB A9 00 85 C1		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   240 43BF A2 04		                LDX     #$04
   241 43C1 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   242 43C4 A5 C5		                LDA     SUM32+1             ; load MONTH into A
   243 43C6 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   244 43CA A2 05		                LDX     #$05
   245 43CC 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   246 43CF A5 C6		                LDA     SUM32+2             ; load DAY into A
   247 43D1 05 C0		                ORA     NUM32               ; and add value into result
   248 43D3 AA			                TAX
   249 43D4 A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   250 43D6 60			                RTS
   251 				                
   252 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   253 43D7			CONVERT_DATETIME
   254 43D7 85 C4		                STA     SUM32		    ; Year or Hour
   255 43D9					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: jc2_macros.inc]
     1 43D9 86 C5			STX	SUM32+1
     2 43DB 84 C6			STY	SUM32+1+1
Source: boot_sys_os.asm
   256 43DD A0 02		                LDY     #$02		    ; 3 bytes to convert
   257 43DF B9 C4 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   258 43E2 20 44 4F		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   259 43E5 99 C4 00 88		                STA     SUM32,Y-	    ; Store result back
   260 43E9 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   261 43EB 60			                RTS			    ; return
   262
   263 				; **** Copy First block of File to memory **************************************
   264 				; Input:
   265 				; ******************************************************************************
   266 43EC 20 5F 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   267 43EF					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 43EF AD 55 44				LDA	FTYPE
     2 43F2 F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   268 43F4					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 43F4 C9 01				CMP	#1
     2 43F6 F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   269 						
   270 						; .EXE file (FTYPE=2)
   271 43F8 AD 00 1C 8D F8 44			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   272 43FE 85 CC				STA	END_PTR			; destination address LSB
   273 4400 AD 01 1C 8D F9 44			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   274 4406 85 CD				STA	END_PTR+1		; destination address MSB
   275 4408 A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   276 440C D0 1C				BNE	COPY_BLK_DEST		; branch always
   277 						
   278 						; .COM file  (FTYPE=1)
   279 440E A9 00 8D F8 44	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   280 4413 85 CC				STA	END_PTR			 ; destination address LSB
   281 4415 A9 30 8D F9 44			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   282 441A 85 CD				STA	END_PTR+1		 ; destination address MSB
   283 441C D0 0C				BNE	COPY_BLK_DEST		 ; branch always
   284 						
   285 						; .BAS file (FTYPE=0)
   286 441E A9 00 85 CC A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR END_PTR	; destination = BAS_LOAD_ADDR, 1st 2 bytes contain end-address
   287 4426 A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; skip first 2 bytes of .BAS file (contains $00 $20)
   288 						
   289 				; **** Copy Second and other blocks of File to Memory **************************
   290 				; Input: PSTR   : pointer to memory-source
   291 				;        END_PTR: pointer to memory-destination
   292 				; ******************************************************************************
   293 442A AD 28 18		COPY_BLK_DEST	LDA	DBG_PRINT		; 1 = Debug print info
   294 442D F0 23				BEQ	CPBD_NO_DBG
   295 442F					PRCH	'['
Macro: PRCH [Source: jc2_macros.inc]
     1 442F A9 5B			LDA	#'['
     2 4431 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   296 4434					PRHEX16	PSTR
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 4434 A5 EB			LDA	PSTR+1				; print MSB
     2 4436 20 91 E0			JSR	HEXOUT
     3 4439 A5 EA			LDA	PSTR
     4 443B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   297 443E					PRCH	','
Macro: PRCH [Source: jc2_macros.inc]
     1 443E A9 2C			LDA	#','
     2 4440 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   298 4443					PRHEX16	END_PTR
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 4443 A5 CD			LDA	END_PTR+1				; print MSB
     2 4445 20 91 E0			JSR	HEXOUT
     3 4448 A5 CC			LDA	END_PTR
     4 444A 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   299 444D					PRCH	']'
Macro: PRCH [Source: jc2_macros.inc]
     1 444D A9 5D			LDA	#']'
     2 444F 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   300 4452 4C 38 1E		CPBD_NO_DBG	JMP	MON_RAM_BLOCK.CP_BLK_DEST	; RAM-BANK save copy page (512 bytes)
   301 						
   302 4455 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   303
   304 				; **** Init File Buffer ********************************************************
   305 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   306 				; ******************************************************************************
   307 4456 A9 00 85 DC A9 1C + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   308 445E 60					RTS				; return
   309 						
   310 				; **** Init File-buffer pointer ************************************************
   311 				; This routine sets PSTR to FILE_BUFF
   312 				; ******************************************************************************
   313 445F A9 00 85 EA A9 1C + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   314 4467 60					RTS				; return
   315
   316 				; **** Load BAS/COM/EXE File ***************************************************
   317 				; Input: CURR_CLUSTER: cluster nr of file to load
   318 				; ******************************************************************************
   319 4468 20 D7 48		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       		; check if filesize is 0
   320 446B 90 01		                BCC     OS_LOAD_COM2			; branch if file is not empty
   321 						
   322 446D 60			                RTS                         		; filesize is 0, just do nothing
   323 						
   324 446E			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      		; current cluster nr
Macro: LDXYI [Source: jc2_macros.inc]
     1 446E A2 20			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 4470 A0 04			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   325 4472 20 06 41		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   326 4475 A9 00 85 A3		                MVA     #$00 BCNT              		; init. block counter
   327 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   328 4479 AD 0B 04 85 A5	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   329 447E A0 1D		                LDY     #D_FILE_SIZE+1      		; index to file size in dir. entry
   330 4480 B1 A0		                LDA     (CURR_DIR_ENTRY),Y  		; load file size byte 1
   331 4482 4A			                LSR                         		; check if bit 0 is set (bytes 256-511 of buffer)
   332 4483 48			                PHA			    		; save byte: now contains file-size in blocks of 512 bytes
   333 4484 B0 06		                BCS     LOAD_COM1           		; yes, add one block
   334 						
   335 4486 88			                DEY					; now points to D_FILE_SIZE LSB
   336 4487			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4487 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 4489 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   337 448B 38			                SEC                         		; yes, add one block
   338 448C 68			LOAD_COM1       PLA
   339 448D 65 A3 85 A3		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   340 4491			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: jc2_macros.inc]
     1 4491 C9 59				CMP	#89			; 
     2 4493 B0 28				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   341 						
   342 4495 A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   343 4497			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: jc2_macros.inc]
     1 4497 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 4499 D0 22				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   344 449B C8			                INY					; D_FILE_SIZE+3
   345 449C			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: jc2_macros.inc]
     1 449C B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 449E D0 1D				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   346 						
   347 						; Read first part of file into FILE_BUFF
   348 44A0 20 56 44				JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   349 44A3			                LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: jc2_macros.inc]
     1 44A3 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44A5 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   350 44A7 20 57 41		                JSR     DEV_RD_LBLK         		; Read first block of file into FILE_BUFF
   351 44AA 20 EC 43				JSR	COPY_BLK0_DEST			; Copy first block to destination
   352 44AD					DEC.EQ	BCNT OS_EXEC_CHK		; Branch if #blocks to read is 1
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 44AD C6 A3				DEC	BCNT
     2 44AF F0 3E				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   353 44B1					DEC.EQ  SCNT NEXT_CLUSTER0     		; Branch if sectors/cluster is 1
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 44B1 C6 A5				DEC	SCNT
     2 44B3 F0 2A				BEQ	NEXT_CLUSTER0
Source: boot_sys_os.asm
   354 						
   355 44B5 20 C4 44		                JSR     LOAD_NEXT_BLKS	    		; Load next blocks of file and execute it
   356 44B8 A9 25		                LDA     #HDD1_ID   	    		; Replace by D_DEV_ID?
   357 44BA 4C AA E1				JMP     OPEN_DEVICE			; Init. device driver again and return
   358 						
   359 44BD			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      		; load error message...
Macro: LDXYI [Source: jc2_macros.inc]
     1 44BD A2 2F			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 44BF A0 4C			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   360 44C1 4C 6C 4A		                JMP     OS_PRINT_ERR			; Print it
   361
   362 				; **** Read Next File Blocks ***************************************************
   363 				; ******************************************************************************
   364 44C4 20 8D 41		LOAD_NEXT_BLKS  JSR     INC_32              		; Increment LBA block address in NUM32
   365 44C7 20 56 44		LOAD_BLK0       JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   366 44CA					LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: jc2_macros.inc]
     1 44CA A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44CC A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   367 44CE 20 57 41		                JSR     DEV_RD_LBLK         		; and read next block of file into FILE_BUFF
   368 44D1 20 5F 44				JSR	INIT_FBUF_PTR			; reset file-buffer pointer PSTR to FILE_BUFF again
   369 44D4 20 2A 44				JSR	COPY_BLK_DEST	    		; Copy block to destination
   370 44D7			                DEC.EQ  BCNT OS_EXEC_CHK      		; branch if no more blocks to read
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 44D7 C6 A3				DEC	BCNT
     2 44D9 F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   371 44DB					DEC.NE  SCNT LOAD_NEXT_BLKS    		; branch if more blocks in cluster to read
Macro: DEC.NE [Source: jc2_macros.inc]
     1 44DB C6 A5				DEC	SCNT
     2 44DD D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   372
   373 				; next cluster needs to be loaded considering the volume FAT type **************
   374 44DF 20 88 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   		; Get next cluster from FAT table in CURR_CLUSTER.
   375 44E2 B0 0B		                BCS     OS_EXEC_CHK	    		; C=1, EOF, go execute File
   376 							
   377 44E4 20 02 41		                JSR     CLUSTER_TO_BLK	    		; convert CURR_CLUSTER to LBA number in NUM32.
   378 44E7 AD 0B 04 85 A5	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   379 44EC 4C C7 44		                JMP     LOAD_BLK0	    		; branch always
   380 						
   381 				; Run file if needed ***********************************************************
   382 				; ******************************************************************************
   383 44EF			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: jc2_macros.inc]
     1 44EF AD 55 44				LDA	FTYPE
     2 44F2 D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   384 44F4 60					RTS					; return in case of a .BAS file
   385
   386 				; **** Execute File ************************************************************
   387 				; Input:  Ptr[OS_PROG] to Start Address
   388 				; Output: A - Result Code
   389 				; ******************************************************************************
   390 44F5 6C F8 44		OS_EXECUTE      JMP     (OS_PROG)           		; run .com or .exe file
   391 44F8 00 00		OS_PROG         .word      $0000
   392 				                
   393 				; **** Save the contents of a file to disk *************************************
   394 				; OS_CREATE/OS_CREATE_FILE has already created an entry in the current directory
   395 				; and allocated the first free cluster (in CURR_CLUSTER) to the file. If the file
   396 				; existed, it was deleted first, so you always have a new first cluster number. 
   397 				; This routine writes all sectors of this file and updates (=links clusters 
   398 				; together) the FAT table. 
   399 				; Input: FREE_CLUSTER: first cluster nr of file to save
   400 				; ******************************************************************************
   401 44FA			OS_SAVE_FILE	LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: jc2_macros.inc]
     1 44FA A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 44FC A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   402 44FE 20 06 41		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   403 4501 A9 FE 8D D4 45 A9 + 		MWA	#$1FFE FSAVE_PTR		; Init. BLKBUF to start of .BAS file to save
   404 450B A9 00 8D FE 1F A9 + 		MWA	#$2000 $1FFE			; Set first word of Basic file to start-address
   405 4515 AD D5 56 85 A3	                MVA     SAVE_SECS BCNT      		; init. block counter, SAVE_SECS was calculated by CFC_SAVE
   406 451A AD 0B 04 85 A5	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   407 451F A9 01 8D 98 58			MVA	#1 SIS_CNT			; #clusters allocated
   408
   409 				; Write sectors/cluster until --BCNT = 0
   410 4524 AD D4 45 85 DC AD + SAVE_NXT_BLK	MWA	FSAVE_PTR BLKBUF		; BLKBUF = FSAVE_PTR
   411 452E					LDXYI	NUM32				; LBA number
Macro: LDXYI [Source: jc2_macros.inc]
     1 452E A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4530 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   412 4532 20 98 1E				JSR	MON_RAM_BLOCK.DEV_WR_LBLK	; Write another sector to disk (RAM-BANK save write)
   413 4535					LDXYI	OS_SV_ERR1			; 'OS_SAVE_FILE: Write error'
Macro: LDXYI [Source: jc2_macros.inc]
     1 4535 A2 85			LDX	<OS_SV_ERR1				; MADS makes this immediate
     2 4537 A0 45			LDY	>OS_SV_ERR1
Source: boot_sys_os.asm
   414 4539 90 3F				BCC	OS_SAVE_ERR			; Branch on error
   415 						
   416 453B EE D5 45 EE D5 45		:2	INC	FSAVE_PTR+1			; BLKBUF += $0200, points to next block in memory to save
   417 4541			                DEC.EQ  BCNT OS_SAVE_X      		; branch if no more blocks to write
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 4541 C6 A3				DEC	BCNT
     2 4543 F0 3A				BEQ	OS_SAVE_X
Source: boot_sys_os.asm
   418 4545					DEC.EQ  SCNT SAVE_NXT_CLSTR    		; branch if more blocks in cluster to write
Macro: DEC.EQ [Source: jc2_macros.inc]
     1 4545 C6 A5				DEC	SCNT
     2 4547 F0 06				BEQ	SAVE_NXT_CLSTR
Source: boot_sys_os.asm
   419 4549 20 8D 41				JSR     INC_32				; Increment LBA block address in NUM32
   420 454C 4C 24 45				JMP	SAVE_NXT_BLK			; branch always
   421 						
   422 				; next cluster needs to be allocated considering the volume FAT type **************
   423 454F			SAVE_NXT_CLSTR	MVAX	4 FREE_CLUSTER PREV_CLUSTER	; PREV_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: jc2_macros.inc]
     1 454F A2 03			LDX	#4-1
     2 4551 BD 20 18 9D 81 45 + lp	MVA	FREE_CLUSTER,X PREV_CLUSTER,X-
     3 4558 10 F7			BPL	lp
Source: boot_sys_os.asm
   424 455A 20 BD 47				JSR     OS_ADD_CLUSTER	   		; Find next free cluster in FAT and allocates it (does NOT write FAT back to disk)
   425 455D 20 D6 45				JSR	LINK_FAT_ENTRY			; Link new FREE_CLUSTER to PREV_CLUSTER (does NOT write FAT back to disk)
   426 4560 20 08 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   427 4563					LDXYI	OS_SV_ERR2			; 'FAT write error'
Macro: LDXYI [Source: jc2_macros.inc]
     1 4563 A2 A5			LDX	<OS_SV_ERR2				; MADS makes this immediate
     2 4565 A0 45			LDY	>OS_SV_ERR2
Source: boot_sys_os.asm
   428 4567 90 11				BCC	OS_SAVE_ERR			; Branch on error
   429 						
   430 4569 EE 98 58				INC	SIS_CNT				; #clusters allocated += 1
   431 456C					LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: jc2_macros.inc]
     1 456C A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 456E A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   432 4570 20 06 41		                JSR     CLSTR_TO_BLK	    		; convert FREE_CLUSTER to LBA number in NUM32.
   433 4573 AD 0B 04 85 A5	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   434 4578 D0 AA		                BNE     SAVE_NXT_BLK	    		; branch always
   435
   436 457A 20 82 F6		OS_SAVE_ERR	JSR	OS_STRING_OUT			; Print error message
   437 457D 18					CLC					; C=0, error
   438 457E 60					RTS					; return
   439 457F 38			OS_SAVE_X	SEC					; C=1, oke
   440 4580 60					RTS					; return
   441
   442 4581 00 00 00 00		PREV_CLUSTER	.dword 	$00000000			; Previous cluster nr of file
   443 4585 4F 53 5F 53 41 56 + OS_SV_ERR1	.by	'OS_SAVE_FILE: File write error' CR $00
   444 45A5 4F 53 5F 53 41 56 + OS_SV_ERR2	.by	'OS_SAVE_FILE: FAT write error' CR $00
   445 45C4 46 41 54 20 4C 69 + TXT_LINK	.by	'FAT Link: ' $00
   446 45CF 20 74 6F 20 00	TXT_LINK2	.by	' to ' $00
   447 45D4 00 00		FSAVE_PTR	.word	$0000				; File-save Pointer
   448
   449 				; ******************************************************************************
   450 				; Links a new cluster (FREE_CLUSTER) to the current cluster (PREV_CLUSTER) of a file.
   451 				; It also updates (writes) the FAT table.
   452 				; ******************************************************************************
   453 45D6			LINK_FAT_ENTRY	PRSTRM	TXT_LINK
Macro: PRSTRM [Source: jc2_macros.inc]
     1 45D6 A2 C4			LDX	<TXT_LINK				; MADS makes this immediate
     2 45D8 A0 45			LDY	>TXT_LINK
Source: boot_sys_os.asm
     2 45DA 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   454 45DD					PRHEX16	PREV_CLUSTER
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 45DD AD 82 45			LDA	PREV_CLUSTER+1				; print MSB
     2 45E0 20 91 E0			JSR	HEXOUT
     3 45E3 AD 81 45			LDA	PREV_CLUSTER
     4 45E6 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   455 45E9					PRSTRM	TXT_LINK2
Macro: PRSTRM [Source: jc2_macros.inc]
     1 45E9 A2 CF			LDX	<TXT_LINK2				; MADS makes this immediate
     2 45EB A0 45			LDY	>TXT_LINK2
Source: boot_sys_os.asm
     2 45ED 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   456 45F0					PRHEX16	FREE_CLUSTER
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 45F0 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 45F3 20 91 E0			JSR	HEXOUT
     3 45F6 AD 20 18			LDA	FREE_CLUSTER
     4 45F9 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   457 45FC 20 5A E0				JSR	CROUT				; Print CR
   458 45FF AD 81 45				LDA	PREV_CLUSTER			; get LSB of PREV_CLUSTER
   459 4602 0A 0A			:2	ASL					; SHL2, DWORD index in FAT page
   460 4604 A8					TAY					; Y = DWORD byte 0 in FAT page
   461 4605 B0 19				BCS	LINK_UPPER_PAGE			; if $40..$7F then write byte to upper half of block
   462 						
   463 						; lower half block of Buffer
   464 4607 AD 20 18 99 00 06 + 		MWA	FREE_CLUSTER   FAT_BUF,Y	; Write CURR_CLUSTER nr into PREV_CLUSTER FAT entry
   465 4613 AD 22 18 99 02 06 + 		MWA	FREE_CLUSTER+2 FAT_BUF+2,Y
   466 461F 60					RTS					; return
   467 						
   468 						; upper half block of Buffer
   469 4620 AD 20 18 99 00 07 + LINK_UPPER_PAGE	MWA	FREE_CLUSTER   FAT_BUF+256,Y
   470 462C AD 22 18 99 02 07 + 		MWA	FREE_CLUSTER+2 FAT_BUF+258,Y
   471 4638 60					RTS					; return
   472
   473 				; ******************************************************************************
   474 4639			INIT_FREE_CLUSTER
   475 4639 A9 02 8D 20 18 A9 + 		MWA	#$02 FREE_CLUSTER		; first data cluster is $000002
   476 4643 8D 22 18				STA     FREE_CLUSTER+2
   477 4646 8D 23 18		                STA     FREE_CLUSTER+3
   478 4649 60			                RTS
   479 				                
   480 				; ******************************************************************************
   481 				; Input: FREE_CLUSTER: number of possible free cluster
   482 				; Output: C=1: CURR_CLUSTER is free ; C=0: 
   483 				; ******************************************************************************
   484 464A			OS_NEXT_FREE_CLUSTER
   485 464A			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: jc2_macros.inc]
     1 464A A2 03			LDX	#4-1
     2 464C BD 20 18 9D 20 04 + lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 4653 10 F7			BPL	lp
Source: boot_sys_os.asm
   486 4655 20 88 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   487 4658 A2 03		                LDX     #$03
   488 465A			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: jc2_macros.inc]
     1 465A BD 20 04				LDA	CURR_CLUSTER,X
     2 465D D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   489 465F			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: jc2_macros.inc]
     1 465F CA					DEX
     2 4660 10 F8				BPL	CHK_FREE
Source: boot_sys_os.asm
   490 4662 38			                SEC                         		; cluster is free, exit with C = 1
   491 4663 60			                RTS
   492
   493 				; ******************************************************************************
   494 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   495 				; ******************************************************************************
   496 4664 A2 00		SET_NEXT_CLSTR  LDX     #$00
   497 4666			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: jc2_macros.inc]
     1 4666 FE 20 18				INC	FREE_CLUSTER,X
     2 4669 D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   498 466B E8			                INX						; next byte of FREE_CLUSTER
   499 466C			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: jc2_macros.inc]
     1 466C E0 04				CPX	#$04
     2 466E D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   500 						
   501 4670 A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   502 4672 BD 24 04		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   503 4675			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4675 DD 18 04				CMP	D_START_FAT2,X			; 
     2 4678 90 D0				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   504 467A			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: jc2_macros.inc]
     1 467A CA					DEX
     2 467B 10 F5				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   505 467D 18			                CLC                         			; no emtpy cluster found, exit with error
   506 467E 60			                RTS
   507
   508 				; ******************************************************************************
   509 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   510 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   511 				; FAT_BUF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   512 				; in FREE_CLUSTER needs to be allocated in the FAT table.
   513 				; ******************************************************************************
   514 467F			UPDATE_FAT_TABLE
   515 467F AD 28 18				LDA	DBG_PRINT		; 1 = Print debug info
   516 4682 F0 16				BEQ	UPD_NO_DBG
   517 4684					PRCH	'['			; Print [
Macro: PRCH [Source: jc2_macros.inc]
     1 4684 A9 5B			LDA	#'['
     2 4686 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   518 4689					PRHEX16	FREE_CLUSTER		; Print FREE_CLUSTER
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 4689 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 468C 20 91 E0			JSR	HEXOUT
     3 468F AD 20 18			LDA	FREE_CLUSTER
     4 4692 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   519 4695					PRCH	']'
Macro: PRCH [Source: jc2_macros.inc]
     1 4695 A9 5D			LDA	#']'
     2 4697 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   520 469A AD 20 18		UPD_NO_DBG	LDA	FREE_CLUSTER		; get LSB of cluster nr
   521 469D 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   522 469F A8					TAY				; Y = DWORD byte 0 in FAT page
   523 					.rept 3					; Write 3 x $FF into FAT entry
   524 						LDA	#$FF			
   525 						JSR	WRITE_ENTRY_BYTE	
   526 						INY				
   527 					.endr	
Source: REPT
   524 46A0 A9 FF				LDA	#$FF			
   524 46A2 20 B7 46				JSR	WRITE_ENTRY_BYTE	
   524 46A5 C8					INY				
   524 46A6 A9 FF				LDA	#$FF			
   524 46A8 20 B7 46				JSR	WRITE_ENTRY_BYTE	
   524 46AB C8					INY				
   524 46AC A9 FF				LDA	#$FF			
   524 46AE 20 B7 46				JSR	WRITE_ENTRY_BYTE	
   524 46B1 C8					INY				
Source: boot_sys_os.asm
   528 46B2 A9 0F				LDA	#$0F			; write end marker
   529 46B4 4C B7 46				JMP	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   530 						
   531 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   532 				; INPUT : A = Write Data
   533 				;         Y - Index To FAT Entry Byte
   534 				; ******************************************************************************
   535 46B7			WRITE_ENTRY_BYTE
   536 46B7 B0 04		                BCS     WR_UPPER_PAGE       	; if $40..$7F then write byte to upper half of block
   537 						
   538 46B9 99 00 06		                STA     FAT_BUF,Y		; write entry byte to lower half of block buffer ($00..$3F)
   539 46BC 60					RTS				
   540 						
   541 46BD 99 00 07		WR_UPPER_PAGE   STA     FAT_BUF+256,Y		; write entry byte to upper half of block buffer ($40..$7F)
   542 46C0 60					RTS
   543 				                
   544 				; **** Add Date and Time to subdir entry ***************************************
   545 				; ******************************************************************************
   546 46C1			ADD_DATE_TIME	; Write create-Date and Last-write Date
   547 46C1 20 B0 43				JSR     OS_FILEDATE         	; get current date as file date
   548 46C4 98			                TYA				; Y = MSB
   549 46C5 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   550 46C7 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   551 46C9 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   552 46CB 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   553 46CE 8A			                TXA				; X = LSB
   554 46CF 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   555 46D1 A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   556 46D3 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   557
   558 						; Write create-Time and last-write Time
   559 46D5 20 8B 43		                JSR     OS_FILETIME         	; get current time as file time
   560 46D8 98			                TYA				; Y = MSB
   561 46D9 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   562 46DB 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   563 46DD A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   564 46DF 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   565 46E2 8A			                TXA				; X = LSB
   566 46E3 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   567 46E5 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   568 46E7 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   569 46E9 60					RTS
   570 						
   571 				; **** Add new subdirectory entry to dir buffer ********************************
   572 				; Input: X=1: . subdir, X=2: .. subdir
   573 				; ******************************************************************************
   574 46EA 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   575 46EB 48					PHA					; save it
   576 46EC A0 00				LDY	#D_FILENAME			; Filename entry
   577 46EE A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   578 46F3			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: jc2_macros.inc]
     1 46F3 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 46F5 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   579
   580 46F7 A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   581 46FB A0 00				LDY	#D_FILENAME			; Filename entry
   582 46FD A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   583 46FF 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   584 4702					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: jc2_macros.inc]
     1 4702 CA					DEX
     2 4703 D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   585
   586 4705 20 C1 46				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   587 4708 68					PLA
   588 4709					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4709 C9 01				CMP	#1
     2 470B D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   589 					
   590 						; Current subdir .: Write File Cluster Nr High and Low
   591 470D A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   592 470F AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   593 4715 AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   594 471A A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   595 471C AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   596 4722 AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   597 4727 60					RTS					; return
   598 						
   599 						; Parent subdir ..: Write File Cluster Nr High and Low
   600 4728 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   601 472A AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   602 4730 AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   603 4735 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   604 4737 AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   605 473D AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   606 4742 60					RTS
   607 						
   608 				; **** Add new Directory Cluster to Disk ***************************************
   609 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   610 				; ******************************************************************************
   611 4743			ADD_NEW_DIR_CLST
   612 4743 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   613 474B A2 01				LDX	#1			; X = 1
   614 474D A9 00				LDA	#0			; A = 0
   615 474F A8					TAY				; Y = 0
   616 4750			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: jc2_macros.inc]
     1 4750 91 DC C8				STA	(BLKBUF),Y+
     2 4753 D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   617 4755 E6 DD				INC	BLKBUF+1		; next page
   618 4757					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: jc2_macros.inc]
     1 4757 CA					DEX
     2 4758 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   619 						
   620 475A A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   621 475E A2 01				LDX	#1			; 1 = . subdir entry
   622 4760 20 EA 46				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   623 4763 A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   624 476A A2 02				LDX	#2			; 2 = .. subdir entry
   625 476C 20 EA 46				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   626
   627 						; and write it to disk
   628 476F AD 28 18				LDA	DBG_PRINT		; 1 = Debug print info
   629 4772 F0 22				BEQ	AND_NO_DBG
   630 4774					PRSTRM	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 4774 A2 A4			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 4776 A0 47			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 4778 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   631 477B					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: jc2_macros.inc]
     1 477B AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 477E 20 91 E0			JSR	HEXOUT
     3 4781 AD 22 18			LDA	FREE_CLUSTER+2
     4 4784 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 4787 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 478A 20 91 E0			JSR	HEXOUT
     3 478D AD 20 18			LDA	FREE_CLUSTER
     4 4790 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   632 4793 20 5A E0				JSR	CROUT			; Print CR
   633
   634 4796			AND_NO_DBG	LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: jc2_macros.inc]
     1 4796 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4798 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   635 479A 20 06 41				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   636 479D					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: jc2_macros.inc]
     1 479D A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 479F A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   637 47A1 4C F5 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   638 						
   639 47A4 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   640
   641 				; **** Add First Cluster To Empty File *****************************************
   642 				; Note: does NOT write FAT table back to disk, only FAT table in memory is updated.
   643 				; ******************************************************************************
   644 47BD 20 39 46		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   645 47C0 20 4A 46				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   646 47C3 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   647 						
   648 47C5 20 7F 46		                JSR     UPDATE_FAT_TABLE	; Allocate FREE_CLUSTER, does NOT write FAT block back to disk
   649 47C8 60			ADD_CLUSTER_END RTS
   650
   651 				; **** Create New File *********************************************************
   652 				; Input:  A = File Attributes
   653 				; Output: C = 0 - Error; C = 1 - No Error
   654 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   655 				; ******************************************************************************
   656 47C9 8D 12 18		OS_CREATE       STA     F_ATTRIBS           		; save attributes
   657 47CC			                AND.EQ  #FA_DIRECTORY ADD_FILE 		; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: jc2_macros.inc]
     6 47CC 29 10				AND	#FA_DIRECTORY
     7 47CE F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   658 						
   659 						; Find directory
   660 47D0 20 EC 48		                JSR     OS_DIR_EXISTS       		; C=1: dirname already exists
   661 47D3 90 21				BCC	OS_CREATE_CONT			; branch if dirname does not exist yet
   662 47D5 B0 62				BCS	OS_CREATE_ERR			; branch on error
   663
   664 						; Find file
   665 47D7 20 F2 48		ADD_FILE        JSR     OS_FILE_EXISTS      		; check if file already exists
   666 47DA 90 1A				BCC	OS_CREATE_CONT			; branch if file does not exist
   667 						
   668 						; delete file (SH_DEL)	
   669 47DC					PRSTRM	TXT_OVERWRITE			; Print 'File exists, overwrite (y/n)?'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 47DC A2 3E			LDX	<TXT_OVERWRITE				; MADS makes this immediate
     2 47DE A0 48			LDY	>TXT_OVERWRITE
Source: boot_sys_os.asm
     2 47E0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   670 47E3 20 47 E0				JSR 	CIN           			; get character
   671 47E6 29 DF				AND 	#$DF            		; uppercase chars only
   672 47E8					CMP.NE 	#'Y' OS_CREATE_ERR    		; if not Y then exit with error
Macro: CMP.NE [Source: jc2_macros.inc]
     1 47E8 C9 59				CMP	#'Y'
     2 47EA D0 4D				BNE	OS_CREATE_ERR
Source: boot_sys_os.asm
   673 47EC					PRSTRM	TXT_SH_DEL			; DEBUG
Macro: PRSTRM [Source: jc2_macros.inc]
     1 47EC A2 6D			LDX	<TXT_SH_DEL				; MADS makes this immediate
     2 47EE A0 48			LDY	>TXT_SH_DEL
Source: boot_sys_os.asm
     2 47F0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   674 47F3 20 64 53				JSR	SH_DEL_FILE			; Delete file and update FAT table
   675
   676 47F6 20 BD 47		OS_CREATE_CONT	JSR	OS_ADD_CLUSTER			; Return free cluster in FREE_CLUSTER (does NOT write FAT back to disk)
   677 47F9 20 08 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   678 47FC					LDXYI	TXT_CR_ERR1			; 'FAT Save Error'
Macro: LDXYI [Source: jc2_macros.inc]
     1 47FC A2 7F			LDX	<TXT_CR_ERR1				; MADS makes this immediate
     2 47FE A0 48			LDY	>TXT_CR_ERR1
Source: boot_sys_os.asm
   679 4800 90 37				BCC	OS_CREATE_ERR			; Branch on error
   680 						
   681 						; Find a Free dir. entry and fill it with file info and save it to disk
   682 4802 20 E6 48				JSR 	OS_FIND_FREE			; Find a free directory entry in the current directory
   683 4805					LDXYI	TXT_CR_ERR2			; 'No free dir. entry'
Macro: LDXYI [Source: jc2_macros.inc]
     1 4805 A2 9A			LDX	<TXT_CR_ERR2				; MADS makes this immediate
     2 4807 A0 48			LDY	>TXT_CR_ERR2
Source: boot_sys_os.asm
   684 4809 90 2E				BCC	OS_CREATE_ERR			; Branch if no free dir entry was found
   685 						
   686 						;LDA	DBG_PRINT			; 1 = Debug print info
   687 						;BEQ	OSCR_NO_DBG			; 0 = no debug
   688 480B					PRSTRM	TXT_FFREE1			; DEBUG
Macro: PRSTRM [Source: jc2_macros.inc]
     1 480B A2 5C			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 480D A0 48			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 480F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   689 4812					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 4812 A5 A1			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 4814 20 91 E0			JSR	HEXOUT
     3 4817 A5 A0			LDA	CURR_DIR_ENTRY
     4 4819 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   690 481C 20 5A E0				JSR	CROUT				; Print CR
   691 481F AD 12 18		OSCR_NO_DBG	LDA     F_ATTRIBS			; Get file/dir attributes
   692 4822 20 0F 43				JSR	OS_CREATE_FILE			; create the file/dir on disk
   693 4825					LDXYI	TXT_CR_ERR3			; 'OS_CREATE: File create error'
Macro: LDXYI [Source: jc2_macros.inc]
     1 4825 A2 B9			LDX	<TXT_CR_ERR3				; MADS makes this immediate
     2 4827 A0 48			LDY	>TXT_CR_ERR3
Source: boot_sys_os.asm
   694 4829 90 0E				BCC	OS_CREATE_ERR			; Branch on error
   695 						
   696 482B AD 12 18				LDA     F_ATTRIBS			; Get file/dir attributes again
   697 482E					AND.EQ  #FA_DIRECTORY OS_CREATE_X	; create a file? Branch if it is a file
Macro: AND.EQ [Source: jc2_macros.inc]
     6 482E 29 10				AND	#FA_DIRECTORY
     7 4830 F0 05				BEQ	OS_CREATE_X
Source: boot_sys_os.asm
   698 						
   699 4832 20 43 47				JSR	ADD_NEW_DIR_CLST		; Add new dir cluster with . and .. and save it to disk
   700 4835 90 02				BCC	OS_CREATE_ERR			; Branch on error
   701 						
   702 4837 38			OS_CREATE_X	SEC					; C=1, OK
   703 4838 60			                RTS					; and return
   704 4839 20 82 F6		OS_CREATE_ERR   JSR	OS_STRING_OUT			; Print error message
   705 483C 18					CLC					; C=0, error
   706 483D 60			OS_CREATE_END   RTS					; return
   707 				                
   708 483E 46 69 6C 65 20 65 + TXT_OVERWRITE	.by	'File exists, overwrite (y/n)?' $00
   709 485C 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   710 486D 44 65 6C 65 74 69 + TXT_SH_DEL	.by	'Deleting file...' CR $00
   711 487F 4F 53 5F 43 52 45 + TXT_CR_ERR1	.by	'OS_CREATE: FAT Save Error' CR $00
   712 489A 4F 53 5F 43 52 45 + TXT_CR_ERR2	.by	'OS_CREATE: No free dir. error' CR $00
   713 48B9 4F 53 5F 43 52 45 + TXT_CR_ERR3	.by	'OS_CREATE: File create error' CR $00
   714
   715 				; **** Test If File Is Empty ************** ************************************
   716 				; Input:  Ptr(CURR_DIR_ENTRY)
   717 				; Output: C = 1 - File is empty; C = 0 - File not empty
   718 				; ******************************************************************************
   719 48D7 A2 04		OS_FILE_EMPTY   LDX     #$04
   720 48D9 A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   721 48DB 18			                CLC
   722 48DC			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: jc2_macros.inc]
     1 48DC B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 48DE D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   723 48E0 C8			                INY
   724 48E1			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: jc2_macros.inc]
     1 48E1 CA					DEX
     2 48E2 D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   725 48E4 38			                SEC			    			; C=1: File is empty
   726 48E5 60			OS_FILE_EMPTY2  RTS			    			; return
   727
   728 				; **** Check If a directory entry is free or deleted ***************************
   729 				; ******************************************************************************
   730 48E6			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: jc2_macros.inc]
     1 48E6 A2 BB			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 48E8 A0 4B			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   731 48EA D0 1A		                BNE     OS_FIND			; branch always
   732
   733 				; **** Check If Directory Already Exists ***************************************
   734 				; ******************************************************************************
   735 48EC			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: jc2_macros.inc]
     1 48EC A2 6E			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 48EE A0 4B			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   736 48F0 D0 14		                BNE     OS_FIND			; branch always
   737 				                
   738 				; **** Check If Directory Is Available *****************************************
   739 				; ******************************************************************************
   740 48F2			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: jc2_macros.inc]
     1 48F2 A2 92			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 48F4 A0 4B			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   741 48F6 D0 0E		                BNE     OS_FIND			; branch always
   742
   743 				; **** Find Directory **********************************************************
   744 				; ******************************************************************************
   745 48F8			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: jc2_macros.inc]
     1 48F8 A2 71			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 48FA A0 4B			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   746 48FC D0 08		                BNE     OS_FIND			; branch always
   747
   748 				; **** Find File ***************************************************************
   749 				; ******************************************************************************
   750 48FE			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: jc2_macros.inc]
     1 48FE A2 95			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 4900 A0 4B			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   751 				                                           ; fall through to OS_FIND
   752 				                                           
   753 				; **** Find All Files **********************************************************
   754 				; ******************************************************************************
   755 4902 A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   756 4904 D0 02		                BNE     OS_FIND2
   757
   758 				; **** Main Find Routine *******************************************************
   759 				; ******************************************************************************
   760 4906 A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   761 4908			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: jc2_macros.inc]
     1 4908 8E D5 4B			STX	CMD_ADDR
     2 490B 8C D6 4B			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   762 				                                            ; fall through to OS_DIR_LOOP
   763
   764 				; **** Loop Through Actual Directory *******************************************
   765 				; Input:  Ptr[X:Y] = Address to command specific function
   766 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   767 				; Output: C = 1 - Found; C = 0 - Not Found
   768 				; ******************************************************************************
   769 490E 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   770 4911 A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   771 4919 20 9D 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   772 491C			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: jc2_macros.inc]
     1 491C A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 491E A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   773 4920			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: jc2_macros.inc]
     1 4920 86 A0			STX	CURR_DIR_ENTRY
     2 4922 84 A1			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   774 4924 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   775 4926 B1 A0		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   776 4928 AA			                TAX                         			; load attributes into X
   777 4929 A0 00		                LDY     #D_FILENAME         			; index to filename
   778 492B A9 4B CD D6 4B D0 + 		CPW	#CB_FIND_FREE_DIR_ENTRY CMD_ADDR	; Is it OS_FIND_FREE ?
   779 4937 F0 04				BEQ	OS_DIR_CONT				; Branch if so (NULL also means a free dir entry is found)
   780 						
   781 4939			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4939 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 493B F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   782 493D 20 6B 4C		OS_DIR_CONT     JSR     CMD_EXECUTE         			; call command routine
   783 4940 B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   784 						
   785 4942			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: jc2_macros.inc]
     1 4942 AD 13 18				LDA	TERM_FLAG
     2 4945 D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   786 4947 EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   787 494F A5 A0 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   788 4956 90 CC		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   789 						
   790 4958 A9 00		                LDA     #$00
   791 495A 65 A1 85 A1		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   792 495E			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: jc2_macros.inc]
     1 495E C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 4960 D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   793
   794 4962			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: jc2_macros.inc]
     1 4962 CE 1D 18				DEC	CURR_BLK_NUM
     2 4965 D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   795 4967			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4967 AD 0A 04				LDA	D_FAT_TYPE
     2 496A F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   796 496C 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   797 496E B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   798
   799 4970 20 EF 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   			; load next directory cluster from device
   800 4973 90 A7		                BCC     LOWER_DIR_BLK       			; and reset read pointer to lower page of block buffer
   801 4975 B0 0D		                BCS     OS_DIR_LOOP_EOF     			; directory EOF reached. Exit
   802
   803 4977 20 E1 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     			; load next directory block from device
   804 497A 4C 1C 49		                JMP     LOWER_DIR_BLK       			; and reset read pointer to lower page of block buffer
   805
   806 497D			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        			; set pointer to upper page of block buffer
Macro: LDXYI [Source: jc2_macros.inc]
     1 497D A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 497F A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   807 4981 4C 20 49		                JMP     SET_CURR_ENTRY	    			; branch to begin of loop
   808
   809 4984 18			OS_DIR_LOOP_EOF CLC			    			; C=1: not found
   810 4985 60			OS_DIR_LOOP_END RTS			    			; return
   811
   812 				; **** Set Drive Command *******************************************************
   813 				; Input:  A = Drive Number (0..25)
   814 				; Output: C = 0 - Error
   815 				; ******************************************************************************
   816 4986			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4986 CD 1E 18				CMP	CURR_DRIVE
     2 4989 F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   817 498B			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: jc2_macros.inc]
     1 498B C9 08				CMP	#$08			; 
     2 498D B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   818 498F AA			                TAX                         		; save actual drive number to Y
   819 4990 AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   820 4993 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   821 4998 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   822 499A A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   823 499E					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: jc2_macros.inc]
     1 499E A0 1F			LDY	#$20-1
     2 49A0 B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 49A6 10 F8			BPL	lp
Source: boot_sys_os.asm
   824 49A8 8A			                TXA
   825 49A9 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   826 49AE 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   827 49B0 A0 08		                LDY     #$08                		; set index to D_DEV_ID
   828 49B2			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 49B2 B1 E8				LDA	(STOL),Y
     2 49B4 F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   829
   830 49B6					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: jc2_macros.inc]
     1 49B6 A0 1F			LDY	#$20-1
     2 49B8 B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 49BE 10 F8			BPL	lp
Source: boot_sys_os.asm
   831 49C0 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   832 49C3 AD 08 04		                LDA     D_DEV_ID            	; get current device id
   833 49C6 20 AA E1		                JSR     OPEN_DEVICE         	; and open the device driver
   834 49C9 38			SET_DRIVE_END   SEC			    	; C=1: no error
   835 49CA 60			                RTS
   836
   837 49CB			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: jc2_macros.inc]
     1 49CB A2 5C			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 49CD A0 59			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   838 49CF 4C 6C 4A		                JMP     OS_PRINT_ERR	    	; Print 'Drive not found'
   839
   840 				; **** Test If Root Directory **************************************************
   841 				; Input:
   842 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   843 				; ******************************************************************************
   844 49D2 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   845 49D4 B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   846 49D7			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: jc2_macros.inc]
     1 49D7 D9 1C 04				CMP	D_START_DIR,Y
     2 49DA D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   847 49DC			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: jc2_macros.inc]
     1 49DC 88					DEY
     2 49DD 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   848 						
   849 49DF 38			                SEC			     		; C=1 => is root dir.
   850 49E0 60			                RTS
   851 49E1 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   852 49E2 60			                RTS
   853
   854 				; **** Set Root Directory Command **********************************************
   855 				; ******************************************************************************
   856 49E3 A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   857 49E5 BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   858 49EB 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   859 49EF 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   860 						
   861 49F1 A9 5C 8D 28 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   862 49FB 60					RTS					; return
   863
   864 				; **** Set Directory Command ***************************************************
   865 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   866 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   867 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   868 				; considered to be the root-dir and cluster number is set to 2.
   869 				; ******************************************************************************
   870 49FC AD 28 18		OS_SET_DIR      LDA	DBG_PRINT			; 1 Debug print info
   871 49FF F0 30				BEQ	SD_NO_DBG			; branch if no debug print info
   872 4A01					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 4A01 A5 A1			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 4A03 20 91 E0			JSR	HEXOUT
     3 4A06 A5 A0			LDA	CURR_DIR_ENTRY
     4 4A08 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   873 4A0B					PRCH	','
Macro: PRCH [Source: jc2_macros.inc]
     1 4A0B A9 2C			LDA	#','
     2 4A0D 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   874 4A10					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: jc2_macros.inc]
     1 4A10 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4A12 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     5 4A14 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4A17 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4A19 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     5 4A1B 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   875 4A1E					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: jc2_macros.inc]
     1 4A1E A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4A20 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     5 4A22 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4A25 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4A27 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     5 4A29 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   876 4A2C					PRCH	']'
Macro: PRCH [Source: jc2_macros.inc]
     1 4A2C A9 5D			LDA	#']'
     2 4A2E 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   877 4A31 A0 15		SD_NO_DBG	LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   878 4A33 A2 04		                LDX     #$04				; Copy 4 bytes
   879 4A35 8E 5A 4A				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   880 4A38 CA					DEX					; Copy bytes 3..0
   881 4A39 20 47 4A				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   882 4A3C A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   883 4A3E 20 47 4A				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   884 4A41					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4A41 AD 5A 4A				LDA	OS_DWORD0
     2 4A44 F0 9D				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   885 4A46 60			                RTS			     		; return
   886 				                
   887 				;-------------------------------------------------------------------------------------------------
   888 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   889 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   890 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   891 				;-------------------------------------------------------------------------------------------------
   892 4A47 20 4A 4A		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   893 4A4A B1 A0 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   894 4A4F					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: jc2_macros.inc]
     1 4A4F 9D 24 18				STA	CURR_DIR_BLK,X
     2 4A52 D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   895 4A54 CE 5A 4A				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   896 4A57 88			SET_BYTE_NOT0	DEY				
   897 4A58 CA					DEX
   898 4A59 60					RTS				; return
   899 4A5A 00			OS_DWORD0	.byte	$00
   900
   901 				; **** Read Input String *******************************************************
   902 				; Output: Null terminated string in STRBUF
   903 				; ******************************************************************************
   904 4A5B 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   905 4A5E A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   906 4A66 A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   907 4A6B 60			                RTS
   908
   909 				; **** Print Error Message *****************************************************
   910 				; Input:  Ptr[X:Y] = Pointer to Error Message
   911 				; Output: C = 0
   912 				; ******************************************************************************
   913 4A6C 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   914 4A6F 18			                CLC
   915 4A70 60			                RTS
   916 				                
   917 				; **** Parse Full Path String **************************************************
   918 				; Input:  Ptr[X:Y] to Path String
   919 				; Output: C = 0 - Error; C = 1 - No Error
   920 				;         A = $00       - End Of String
   921 				;           = $FF       - Path Not Found
   922 				;           = ?         - Wildcard Included
   923 				;           = PATH_SEP  - No Trailing Name
   924 				; ******************************************************************************
   925 4A71			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: jc2_macros.inc]
     1 4A71 86 EA			STX	PSTR
     2 4A73 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   926 4A75 A0 00		                LDY     #$00
   927 4A77 8C 11 18		                STY     TERM_CHAR
   928 4A7A A9 5C		                LDA     #PATH_SEP
   929 4A7C			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4A7C D1 EA				CMP	(PSTR),Y
     2 4A7E D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   930 4A80 20 E3 49		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   931 4A83 A0 00		                LDY     #$00
   932 4A85 C8			PARSE_PATH      INY
   933 4A86			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4A86 B1 EA				LDA	(PSTR),Y
     2 4A88 F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   934 4A8A			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4A8A C9 20				CMP	#SPC
     2 4A8C F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   935 						
   936 4A8E 20 B8 4A		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   937 4A91 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   938 						
   939 4A93			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4A93 C9 5C				CMP	#PATH_SEP
     2 4A95 D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   940 4A97 84 EE		                STY     PSAV                ; save string index
   941 4A99 20 F8 48		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   942 4A9C A4 EE		                LDY     PSAV                ; restore string index
   943 4A9E 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   944 4AA0 B0 E3		                BCS     PARSE_PATH          ; branch always
   945 				                
   946 4AA2 18			PARSE_TERM      CLC
   947 4AA3			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: jc2_macros.inc]
     1 4AA3 AD 11 18				LDA	TERM_CHAR
     2 4AA6 D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   948 4AA8 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   949 4AAD D0 04		                BNE     PARSE_PATH_OK			; branch always
   950 				                
   951 4AAF			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: jc2_macros.inc]
     1 4AAF A9 FF				LDA	#$FF
     2 4AB1 D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   952 4AB3 38			PARSE_PATH_OK   SEC
   953 4AB4 AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   954 4AB7 60			PARSE_PATH_END2 RTS
   955
   956 				; **** Parse A Partial Path Name String ****************************************
   957 				; Input:  A = First Char Of Partial Path
   958 				;         Y = Index Into Path String
   959 				; Output: C = 0 - Error; C = 1 - No Error
   960 				;         TERM_CHAR = NULL      - Filename
   961 				;                   = ?         - Wildcard Chars Included
   962 				;                   = PATH_SEP  - Subdirectory Name
   963 				; ******************************************************************************
   964 4AB8 A2 08		OS_PARSE_NAME   LDX     #8
   965 4ABA 86 A3		                STX     BCNT                	; set max char count to 8
   966 4ABC A2 00		                LDX     #$00                	; reset index to name string buffer
   967 4ABE 8E 11 18		                STX     TERM_CHAR
   968 4AC1			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4AC1 C9 2E				CMP	#DOT
     2 4AC3 D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   969 4AC5 9D 3E 4C E8		                STA     FILENAME,X+         	; yes, store it
   970 4AC9 C8			                INY
   971 4ACA B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   972 4ACC			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4ACC C9 2E				CMP	#DOT
     2 4ACE D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   973 4AD0 9D 3E 4C		SET_CHAR        STA     FILENAME,X          	; yes, store it
   974 4AD3 E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   975 4AD4 C8			NEXT_CHAR2      INY                         	; point to next char of input string
   976 4AD5			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4AD5 B1 EA				LDA	(PSTR),Y
     2 4AD7 F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   977 4AD9			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4AD9 C9 20				CMP	#SPC
     2 4ADB F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   978 4ADD			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4ADD C9 5C				CMP	#PATH_SEP
     2 4ADF F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   979 4AE1			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4AE1 C9 2E				CMP	#DOT
     2 4AE3 F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   980 4AE5			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4AE5 C9 2A				CMP	#'*'
     2 4AE7 F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   981
   982 4AE9			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: jc2_macros.inc]
     1 4AE9 E4 A3				CPX	BCNT			; 
     2 4AEB B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   983 4AED 20 06 4D		                JSR     UPPERCASE           	; convert chars to upper case
   984 4AF0			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4AF0 C9 3F				CMP	#'?'
     2 4AF2 D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   985 4AF4 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   986 4AF7 F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   987
   988 4AF9			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4AF9 C9 2D				CMP	#MINUS
     2 4AFB F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   989 4AFD			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4AFD C9 5F				CMP	#ULINE
     2 4AFF F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   990 4B01					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4B01 C9 7E				CMP	#'~'
     2 4B03 F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   991 4B05					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4B05 C9 30				CMP	#'0'			; 
     2 4B07 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   992 4B09			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4B09 C9 3A				CMP	#':'			; 
     2 4B0B 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   993 4B0D			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4B0D C9 41				CMP	#'A'			; 
     2 4B0F 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   994 4B11			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4B11 C9 5B				CMP	#'['			; 
     2 4B13 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   995
   996 4B15 A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   997 4B1A 20 31 4B		                JSR     FILL_CHAR           ; fill with ? chars
   998 4B1D B0 B5		                BCS     NEXT_CHAR2          ; branch always
   999
  1000 4B1F 20 2F 4B		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
  1001 4B22 A9 0B 85 A3		                MVA     #11 BCNT            ; set max char count to 11
  1002 4B26 B0 AC		                BCS     NEXT_CHAR2          ; branch always
  1003
  1004 4B28 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
  1005 4B2B A9 0B 85 A3		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
  1006 4B2F A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
  1007 4B31			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: jc2_macros.inc]
     1 4B31 E4 A3				CPX	BCNT			; 
     2 4B33 B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
  1008 4B35 9D 3E 4C E8		                STA     FILENAME,X+         ; no, store char in name buffer
  1009 4B39 90 F6		                BCC     FILL_CHAR           ; and repeat
  1010
  1011 4B3B AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
  1012 4B3E 60			                RTS
  1013 				                
  1014 				; **** Compare File Name With Mask *********************************************
  1015 				; Output: C = 0 - Names not equal; C = 1 - Names equal
  1016 				; ******************************************************************************
  1017 4B3F A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
  1018 4B41 B9 3E 4C		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
  1019 4B44			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4B44 D1 A0				CMP	(CURR_DIR_ENTRY),Y
     2 4B46 D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1020 4B48			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: jc2_macros.inc]
     1 4B48 88					DEY
     2 4B49 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
  1021 						
  1022 4B4B 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
  1023 4B4C 60			                RTS
  1024 4B4D 18			COMPARE_NEQ     CLC					; C=0, filename is different
  1025 4B4E 60			                RTS
  1026 				                
  1027 				; **** Delete File *************************************************************
  1028 				; Input : A - First character of filename
  1029 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
  1030 				; ******************************************************************************
  1031 4B4F			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4B4F C9 E5				CMP	#$E5
     2 4B51 D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1032 4B53 AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
  1033 4B56 D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
  1034
  1035 4B58 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
  1036 4B5B					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: jc2_macros.inc]
     1 4B5B A0 05			LDY	#6-1
     2 4B5D B9 24 18 99 68 4B + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4B64 10 F7			BPL	lp
Source: boot_sys_os.asm
  1037 4B66 38			                SEC
  1038 4B67 60			                RTS
  1039 				                
  1040 4B68 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
  1041 4B6C 00 00		SEL_DIR_ENTRY   .byte $00, $00
  1042 				                
  1043 				; **** Directory Loop Call Back Functions **************************************
  1044 				; Input : A - First character of filename
  1045 				;         X - File Attributes
  1046 				; Output: C = 1 - File found; C = 0 - File not found
  1047 				; ******************************************************************************
  1048
  1049 				; **** Directory Exists - Call Back Routine ************************************
  1050 4B6E 20 4F 4B		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
  1051
  1052 				; **** Find Sub Directory Name - Call Back Routine *****************************
  1053 4B71			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: jc2_macros.inc]
     1 4B71 E0 0F				CPX	#$0F
     2 4B73 F0 44				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1054 4B75 AD 3E 4C		                LDA     FILENAME            	; do we search for the . directory?
  1055 4B78			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4B78 C9 2E				CMP	#DOT
     2 4B7A D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
  1056 						
  1057 4B7C AD 3F 4C		                LDA     FILENAME+1		; get next byte
  1058 4B7F			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4B7F C9 20				CMP	#SPC
     2 4B81 F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
  1059 						
  1060 4B83 8A			FIND_SUBDIR     TXA
  1061 4B84			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: jc2_macros.inc]
     6 4B84 29 10				AND	#FA_DIRECTORY
     7 4B86 F0 31				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1062 4B88 20 3F 4B		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
  1063 4B8B 90 2D		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
  1064
  1065 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
  1066 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
  1067 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
  1068 						;    with $1C & $1D not being cluster nr bytes.
  1069 4B8D 20 FC 49		                JSR     OS_SET_DIR          	; make this directory the actual directory
  1070 4B90 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
  1071 4B91 60			                RTS				; return
  1072 				                
  1073 				; **** File Exists - Call Back Routine *****************************************
  1074 4B92 20 4F 4B		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
  1075
  1076 				; **** Find File Name - Call Back Routine **************************************
  1077 4B95			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: jc2_macros.inc]
     1 4B95 E0 0F				CPX	#$0F
     2 4B97 F0 20				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1078 4B99 8A			                TXA
  1079 4B9A			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: jc2_macros.inc]
     6 4B9A 29 10				AND	#FA_DIRECTORY
     7 4B9C D0 1B				BNE	CB_FIND_END
Source: boot_sys_os.asm
  1080 4B9E 20 3F 4B		                JSR     OS_COMP_NAME        			; compare name with search mask
  1081 4BA1 90 17		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
  1082 						
  1083 4BA3 A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
  1084 4BA5 A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
  1085 4BA7 B1 A0 C8 9D 20 04 + GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
  1086 4BAE			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: jc2_macros.inc]
     1 4BAE E0 02				CPX	#$02			; 
     2 4BB0 90 F5				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1087 4BB2 A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
  1088 4BB4			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: jc2_macros.inc]
     1 4BB4 E0 04				CPX	#$04			; 
     2 4BB6 90 EF				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1089 4BB8 60			                RTS                         			; yes, file found
  1090
  1091 4BB9 18			CB_FIND_END     CLC                         			; file not found
  1092 4BBA 60			CB_FIND_END2    RTS
  1093 				                
  1094 				; **** Find Free or Deleted Dir. Entry **************************************
  1095 4BBB			CB_FIND_FREE_DIR_ENTRY
  1096 4BBB A0 00				LDY	#D_FILENAME			; set index to filename
  1097 4BBD B1 A0				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
  1098 4BBF					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4BBF C9 E5				CMP	#$E5
     2 4BC1 F0 05				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1099 						
  1100 4BC3			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: jc2_macros.inc]
     1 4BC3 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     2 4BC5 D0 0C				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1101 4BC7 C8					INY
  1102 4BC8 A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1103 4BCA 91 A0 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1104 4BCD					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: jc2_macros.inc]
     1 4BCD C0 20				CPY	#$20
     2 4BCF D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1105 						
  1106 4BD1 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1107 4BD2 60			                RTS                         		; return
  1108 4BD3 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1109 4BD4 60					RTS					; return
  1110
  1111 				; **** Data Area ***************************************************************
  1112 				; ******************************************************************************
  1113
  1114 				; Indirect Jump Pointer Of Current Command Address *****************************
  1115 4BD5 00 00		CMD_ADDR        .word      $0000
  1116 				                
  1117 				; String Data Area *************************************************************
  1118 4BD7 0D 20 57 65 6C 63 + MSG_BOOT        .by    CR ' Welcome to DOS65 for the JC2, V'
  1119 4BF8 30 2E 33 2E 32	                .byte  VERMAIN,DOT,VERPSUB,DOT,VERSSUB
  1120 4BFD 2C 20 32 30 32 35 +                 .by    ', 2025 by Emile' CR
  1121 4C0D 20 4F 72 69 67 69 + 		.by    ' Original design by Joerg Walke' CR CR $00
  1122 4C2F 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1123 = 4C3E			FILENAME        .ds 	12
    93 4C4A					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				;-------------------------------------------------------------------------------
     5
     6 				; ******************************************************************************
     7 				; Main Loop Of Command Interpreter *********************************************
     8 				; ******************************************************************************
     9 4C4A A9 04 8D D5 4B A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    10 4C54 20 42 4D		                JSR     PRINT_PROMPT
    11 4C57 20 5B 4A		                JSR  	OS_STRING_IN         ; read input string
    12 4C5A 20 6E 4C				JSR     GET_CMD              ; parse string
    13 4C5D 90 06				BCC     CMD_EXTERNAL
    14 						
    15 4C5F 20 6B 4C		                JSR     CMD_EXECUTE          ; execute internal command
    16 4C62 4C 4A 4C		                JMP     SH_CMD_PROMPT        ; endless loop
    17 						
    18 4C65 20 07 57		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    19 4C68 4C 4A 4C		                JMP     SH_CMD_PROMPT        ; endless loop
    20 						
    21 4C6B 6C D5 4B		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    22 						
    23 				; Get Command String ***********************************************************
    24 4C6E 20 AA 4F		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    25 4C71 D0 03		                BNE     GET_CMD0
    26
    27 4C73 4C 04 4D		                JMP     CMD_FOUND            ; empty command if first char is NULL
    28
    29 4C76 20 06 4D		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    30 4C79 AA			                TAX
    31 4C7A A0 00		                LDY     #$00
    32 4C7C 8A			GET_CMD1        TXA                          	; try to find command in command table
    33 4C7D					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4C7D D9 26 5A				CMP	CHARS,Y
     2 4C80 F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    34 4C82			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4C82 B9 26 5A				LDA	CHARS,Y
     2 4C85 F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    35 4C87 8A			                TXA
    36 4C88 C8 C8 C8		        :3      INY			     	; Y += 3
    37 4C8B 4C 7C 4C		                JMP     GET_CMD1	     	; branch always
    38
    39 4C8E C8			GET_CMD2        INY
    40 4C8F B9 26 5A C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    41 4C95 B9 26 5A 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    42 4C9A A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    43 4C9F A6 A4		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    44 4CA1			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4CA1 B1 E8				LDA	(STOL),Y
     2 4CA3 F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    45 4CA5 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    46 4CAC E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    47 4CAD C8			                INY                          	; point to next char in command table
    48 4CAE			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: jc2_macros.inc]
     1 4CAE CC 10 18				CPY	NEXTINDEX
     2 4CB1 F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    49
    50 4CB3 BD 00 14		                LDA     STRBUF,X             	; load char from command string
    51 4CB6 20 06 4D		                JSR     UPPERCASE	     	; and convert it to uppercase
    52 4CB9					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4CB9 D1 E8				CMP	(STOL),Y
     2 4CBB F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    53
    54 4CBD AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    55 4CC0 C8 C8		        :2      INY			     	; Y += 2
    56 4CC2 8C 10 18		                STY     NEXTINDEX
    57 4CC5 4C 9F 4C		                JMP     GET_CMD_LOOP1	     	; branch always
    58
    59 4CC8 B1 E8 8D D5 4B C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    60 4CD3			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4CD3 BD 00 14				LDA	STRBUF,X
     2 4CD6 F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    61 4CD8			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4CD8 C9 20				CMP	#SPC
     2 4CDA F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    62 4CDC 18			CMD_NOT_FOUND   CLC
    63 4CDD 60			                RTS
    64 				                
    65 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    66 4CDE A6 A4		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    67 4CE0 BD 00 14		                LDA     STRBUF,X
    68 4CE3 20 06 4D		                JSR     UPPERCASE            ; convert it to upper case
    69 4CE6			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4CE6 C9 41				CMP	#'A'			; 
     2 4CE8 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    70 4CEA			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: jc2_macros.inc]
     1 4CEA C9 5B				CMP	#'['			; 
     2 4CEC B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    71
    72 4CEE A8			                TAY
    73 4CEF BD 01 14		                LDA     STRBUF+1,X
    74 4CF2			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4CF2 C9 3A				CMP	#':'
     2 4CF4 D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    75 4CF6 38			                SEC
    76 4CF7 98			                TYA
    77 4CF8 E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    78 4CFA			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: jc2_macros.inc]
     1 4CFA A2 86			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4CFC A0 49			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    79 4CFE			                STXY    CMD_ADDR
Macro: STXY [Source: jc2_macros.inc]
     1 4CFE 8E D5 4B			STX	CMD_ADDR
     2 4D01 8C D6 4B			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    80 4D04 38			CMD_FOUND       SEC
    81 4D05 60			                RTS
    82 				                
    83 				; **** Return Uppercase Character **********************************************
    84 				; Input:  A - Character
    85 				; Output: A - Uppercase Character
    86 				; ******************************************************************************
    87 4D06			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: jc2_macros.inc]
     1 4D06 C9 61				CMP	#'a'			; 
     2 4D08 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    88 4D0A			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: jc2_macros.inc]
     1 4D0A C9 7B				CMP	#'z'+1			; 
     2 4D0C B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    89 4D0E 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    90 4D10 60			UPPERCASE_END   RTS				; return
    91
    92 				; **** Print Two Digit Number **************************************************
    93 				; Input: A - Number (0..99)
    94 				; ******************************************************************************
    95 4D11 20 BD E0		NUMOUT          JSR     DEC2STR			; Converts into DIG0, DIG1 and DIG2
    96 4D14 A2 01		                LDX     #$01
    97 4D16 B5 F8		NEXT_NUMOUT     LDA     DIG0,X			
    98 4D18 20 52 E0		                JSR     COUT
    99 4D1B					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: jc2_macros.inc]
     1 4D1B CA					DEX
     2 4D1C 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   100 4D1E 60			                RTS				; return
   101 				                
   102 				; **** Print Current Drive *****************************************************
   103 				;
   104 				; ******************************************************************************
   105 4D1F AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   106 4D22 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   107 4D25 20 52 E0		                JSR     COUT		   ; print char
   108 4D28 A9 3A		                LDA     #COLON		   ; ':'
   109 4D2A 4C 52 E0		                JMP     COUT		   ; print char and return
   110 				                
   111 				; **** Print Current Path ******************************************************
   112 				;
   113 				; ******************************************************************************
   114 4D2D A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   115 4D31 A6 D8		PR_PATH_LP	LDX	SAVEX
   116 4D33 BD 28 04				LDA     D_SUBDIR_NAME,X		; 
   117 4D36 48					PHA
   118 4D37 20 52 E0		                JSR     COUT		    	; print char
   119 4D3A 68					PLA
   120 4D3B F0 04				BEQ	PR_PATH_DN		; End-of-String?
   121 						
   122 4D3D					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: jc2_macros.inc]
     1 4D3D E6 D8				INC	SAVEX
     2 4D3F D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   123 4D41 60			PR_PATH_DN      RTS				; return
   124
   125 				; **** Print Drive and Path Prompt *********************************************
   126 				;
   127 				; ******************************************************************************
   128 4D42 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   129 4D45 20 1F 4D		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   130 4D48 20 2D 4D		                JSR     PRINT_PATH	   ; '\'
   131 4D4B A9 3E		                LDA     #DOS_PROMPT	   ; '>'
   132 4D4D 4C 52 E0		                JMP     COUT		   ; print char and return
   133 				                
   134 				; **** Print Drive Label *******************************************************
   135 				;
   136 				; ******************************************************************************
   137 4D50 48			PRINT_LABEL     PHA			   ; save A
   138 4D51			                PHY			   ; save Y
Macro: PHY [Source: jc2_macros.inc]
     1 4D51 98				TYA
     2 4D52 48				PHA
Source: boot_sys_sh.asm
   139 4D53			                PRSTRM  MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTRM [Source: jc2_macros.inc]
     1 4D53 A2 18			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4D55 A0 59			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4D57 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   140 4D5A 20 1F 4D		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   141 4D5D			                PRSTRM  MSG_LABEL2	   ; ' is '
Macro: PRSTRM [Source: jc2_macros.inc]
     1 4D5D A2 29			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4D5F A0 59			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4D61 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4D64 20 7A 4D		                JSR     PRINT_FILENAME1    ; print volume-label
   143 4D67 20 5A E0		                JSR     CROUT		   ; CR 2x
   144 4D6A 20 5A E0		                JSR     CROUT
   145 4D6D					PLY			   ; restore Y
Macro: PLY [Source: jc2_macros.inc]
     1 4D6D 68				PLA
     2 4D6E A8				TAY
Source: boot_sys_sh.asm
   146 4D6F 68			                PLA			   ; restore A
   147 4D70 60			                RTS
   148 				                
   149 				; **** Print Filename **********************************************************
   150 				;
   151 				; ******************************************************************************
   152 4D71 A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   153 4D73					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: jc2_macros.inc]
     2 4D73 AD 12 18				LDA	F_ATTRIBS
     3 4D76 29 10				AND	#FA_DIRECTORY
     4 4D78 F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   154 4D7A A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   155 4D7C A0 00		PRINT_FILENAME2 LDY     #$00
   156 4D7E			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: jc2_macros.inc]
     1 4D7E C0 08				CPY	#$08
     2 4D80 D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   157 4D82 20 5E E0		                JSR     SPCOUT		    		; print space
   158 4D85 8A			                TXA
   159 4D86 20 52 E0		                JSR     COUT                		; yes, print divider char
   160 4D89 B1 A0		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   161 4D8B 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   162 4D8E C8			                INY
   163 4D8F			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: jc2_macros.inc]
     1 4D8F C0 0B				CPY	#D_ATTRIBUTES
     2 4D91 D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   164 4D93 60			                RTS			    		; return
   165 				                
   166 				; **** Print File Info *********************************************************
   167 				; Input: F_ATTRIBS = File Attributes
   168 				; ******************************************************************************
   169 4D94			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: jc2_macros.inc]
     2 4D94 AD 12 18				LDA	F_ATTRIBS
     3 4D97 29 10				AND	#FA_DIRECTORY
     4 4D99 F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   170 				                
   171 				; Print Directory Attribute ****************************************************
   172 4D9B			                PRSTRM  MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTRM [Source: jc2_macros.inc]
     1 4D9B A2 2E			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4D9D A0 59			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4D9F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   173 4DA2 EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   174 4DAA 4C D7 4D				JMP     PRINT_ATTRIB
   175
   176 				; Print File Size **************************************************************
   177 4DAD 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   178 4DB0 20 5E E0		                JSR     SPCOUT
   179 4DB3 EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   180 4DBB A2 00		NO_FCNT_CARRY   LDX     #$00
   181 4DBD A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   182 4DBF 18			                CLC
   183 4DC0 08			                PHP
   184 4DC1 28			LOAD_SIZE       PLP
   185 4DC2 B1 A0 95 C0		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   186 4DC6 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   187 4DCC 08			                PHP
   188 4DCD C8			                INY
   189 4DCE E8			                INX
   190 4DCF					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: jc2_macros.inc]
     1 4DCF E0 04				CPX	#$04
     2 4DD1 D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   191 4DD3 28			                PLP
   192 4DD4 20 EB 4E		                JSR     PRINT_INT32         		; print file size
   193 				                
   194 				; Print File Attributes ********************************************************
   195 4DD7 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   196 4DDA					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: jc2_macros.inc]
     4 4DDA AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DDD 29 02				AND	#(1 << 1)
     6 4DDF F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   197 4DE1 A2 07		                LDX     #$07
   198 4DE3 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   199 4DE6			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4DE6 BD FA 59				LDA	ATTRIB_VAL,X
     2 4DE9 F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   200 4DEB B0 02		                BCS     SET_ATTRIB			; branch if printable
   201
   202 4DED A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   203 4DEF 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   204 4DF2			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: jc2_macros.inc]
     1 4DF2 CA					DEX
     2 4DF3 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   205 4DF5 20 5E E0		                JSR     SPCOUT
   206 				                
   207 				; Print Date *******************************************************************
   208 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   209 				;              08-05 Month of year (1-12)
   210 				;              04-00 Day of month (1-32)
   211 				; ******************************************************************************
   212 4DF8 A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   213 4DFA B1 A0 8D E2 4E	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   214 4DFF 29 1F		                AND     #$1F                		; mask day value
   215 4E01 8D E3 4E		                STA     DAY
   216 4E04 C8			                INY
   217 4E05 B1 A0		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   218 4E07 4A			                LSR                         ; year in A
   219 4E08 6E E2 4E		                ROR     MONTH
   220 4E0B 4E E2 4E 4E E2 4E +         :4      LSR     MONTH		    ; LSR 4
   221 4E17 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   222 4E1A 8D E1 4E		                STA     YEAR
   223 4E1D AD E3 4E		                LDA     DAY
   224 4E20 20 11 4D		                JSR     NUMOUT
   225 4E23			                PRCH    '.'
Macro: PRCH [Source: jc2_macros.inc]
     1 4E23 A9 2E			LDA	#'.'
     2 4E25 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   226 4E28 AD E2 4E		                LDA     MONTH
   227 4E2B 20 11 4D		                JSR     NUMOUT
   228 4E2E			                PRCH    '.'
Macro: PRCH [Source: jc2_macros.inc]
     1 4E2E A9 2E			LDA	#'.'
     2 4E30 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   229 4E33 AC E1 4E		                LDY     YEAR
   230 4E36			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: jc2_macros.inc]
     1 4E36 C0 64				CPY	#100			; 
     2 4E38 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   231
   232 4E3A A9 14		                LDA     #20
   233 4E3C 20 11 4D		                JSR     NUMOUT
   234 4E3F 98			                TYA
   235 4E40 38 E9 64				SUB	#100		    ; same as SEC + SBC
   236 4E43 4C 4C 4E		                JMP     PRINT_YEAR
   237
   238 4E46 A9 13		CENTURY_19      LDA     #19
   239 4E48 20 11 4D		                JSR     NUMOUT
   240 4E4B 98			                TYA
   241 4E4C 20 11 4D		PRINT_YEAR      JSR     NUMOUT
   242 4E4F 20 5E E0		                JSR     SPCOUT
   243 				                
   244 				; Print Time *******************************************************************
   245 				; Time Format: 15-11 Hours (0-23)
   246 				;              10-05 Minutes (0-59)
   247 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   248 				; ******************************************************************************
   249 4E52 A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   250 4E54 B1 A0 8D E4 4E	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   251 4E59 C8			                INY
   252 4E5A B1 A0		                LDA     (CURR_DIR_ENTRY),Y  		; load file last write time high byte
   253 				        .rept 3
   254 						LSR     
   255 				                ROR     MINUTE
   256 					.endr	
Source: REPT
   254 4E5C 4A					LSR     
   254 4E5D 6E E4 4E		                ROR     MINUTE
   254 4E60 4A					LSR     
   254 4E61 6E E4 4E		                ROR     MINUTE
   254 4E64 4A					LSR     
   254 4E65 6E E4 4E		                ROR     MINUTE
Source: boot_sys_sh.asm
   257 4E68 4E E4 4E 4E E4 4E	        :2      LSR     MINUTE
   258 4E6E 20 11 4D		                JSR     NUMOUT
   259 4E71			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: jc2_macros.inc]
     1 4E71 A9 3A			LDA	#':'
     2 4E73 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   260 4E76 AD E4 4E		                LDA     MINUTE
   261 4E79 20 11 4D		                JSR     NUMOUT		    ; print minutes
   262
   263 				; Print Cluster Number *********************************************************
   264 				; Only with /C parameter: Prints Cluster number AND LBA number
   265 				; ******************************************************************************
   266 4E7C					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: jc2_macros.inc]
     4 4E7C AD 1F 18				LDA	CURR_CMD_PARAM
     5 4E7F 29 08				AND	#(1 << 3)
     6 4E81 F0 5D				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   267 4E83 20 5E E0		                JSR	SPCOUT		    			; Print space
   268 4E86					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: jc2_macros.inc]
     1 4E86 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4E88 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     3 4E8A 85 C3				STA	NUM32+2+1
     5 4E8C 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4E8F A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4E91 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     3 4E93 85 C2				STA	NUM32+2
     5 4E95 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   269 4E98					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: jc2_macros.inc]
     1 4E98 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4E9A B1 A0				LDA	(CURR_DIR_ENTRY),Y
     3 4E9C 85 C1				STA	NUM32+1
     5 4E9E 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4EA1 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4EA3 B1 A0				LDA	(CURR_DIR_ENTRY),Y
     3 4EA5 85 C0				STA	NUM32
     5 4EA7 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   270 4EAA A9 00 C5 C3 D0 10 + 		CPD	#$00000000 NUM32			; NUM32 = 0L ?
   271 4EC0 D0 04				BNE	CLNRNOT0				; Branch if cluster nr > 0
   272 						
   273 4EC2 A9 02 85 C0				MVA	#2 NUM32				; If boot-sector then Cluster nr = 2
   274 4EC6 20 5E E0		CLNRNOT0	JSR	SPCOUT
   275 4EC9 20 09 41				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   276 4ECC					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: jc2_macros.inc]
     1 4ECC A5 C3			LDA	NUM32+2+1				; print MSB
     2 4ECE 20 91 E0			JSR	HEXOUT
     3 4ED1 A5 C2			LDA	NUM32+2
     4 4ED3 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4ED6 A5 C1			LDA	NUM32+1				; print MSB
     2 4ED8 20 91 E0			JSR	HEXOUT
     3 4EDB A5 C0			LDA	NUM32
     4 4EDD 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   277 4EE0 60			PRINT_EXIT	RTS
   278
   279 4EE1 00			YEAR		.byte 	$00
   280 4EE2 00			MONTH		.byte 	$00
   281 4EE3 00			DAY 		.byte	$00
   282 4EE4 00			MINUTE		.byte 	$00
   283 				                
   284 				; **** Print 16 Bit Number *****************************************************
   285 				; Input: X,Y = Int16
   286 				; ******************************************************************************
   287 4EE5 20 59 4F		PRINT_INT16     JSR     BIN16_TO_BCD
   288 4EE8 4C EE 4E		                JMP     PRINT_NUM
   289 				                
   290 				; **** Print 32 Bit Number *****************************************************
   291 				; Input: NUM32[0..3] = Int32
   292 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   293 				; ******************************************************************************
   294 4EEB 20 63 4F		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   295 4EEE A2 00		PRINT_NUM       LDX     #$00
   296 4EF0 A0 0A		                LDY     #10
   297 4EF2 18			                CLC                         ; save status bits
   298 4EF3 08			PRINT_NUM1      PHP                         ; store current carry flag
   299 4EF4 20 2A 4F		                JSR     PRINT_SEPARATOR
   300 4EF7 BD 02 5A		                LDA     BCD_VAL,X           ; load two decimal digits
   301 4EFA 48			                PHA                         ; store A
   302 4EFB 98			                TYA                         ; move digit counter into A
   303 4EFC 4A			                LSR                         ; bit one into carry
   304 4EFD 68			                PLA                         ; restore A
   305 4EFE 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   306 						
   307 4F00 E8			                INX                         ; no, process digit 2
   308 4F01 29 0F		                AND     #$0F
   309 4F03 10 04		                BPL     SET_DIGIT2
   310 4F05 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   311 4F09 28			SET_DIGIT2      PLP
   312 4F0A B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   313 						
   314 4F0C			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: jc2_macros.inc]
     6 4F0C 29 0F				AND	#$0F
     7 4F0E D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   315 4F10 98			                TYA
   316 4F11			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4F11 C9 01				CMP	#1
     2 4F13 D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   317 4F15 A9 30		                LDA     #48                 ; yes, print 0
   318 4F17 20 9A E0		                JSR     HEXDIG
   319 4F1A 18			                CLC                         ; number is 0
   320 4F1B 60			                RTS
   321 						
   322 4F1C 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   323 4F1F 18			                CLC
   324 4F20 90 04		                BCC     NEXT_DIGIT	    ; branch always
   325 						
   326 4F22 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   327 4F25 38			                SEC                         ; no more leading 0s
   328 4F26			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: jc2_macros.inc]
     1 4F26 88					DEY
     2 4F27 D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   329 4F29 60			                RTS
   330 				                
   331 				; Print Thousands Separator ****************************************************
   332 4F2A 08			PRINT_SEPARATOR PHP                         ; save status bits
   333 4F2B			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: jc2_macros.inc]
     1 4F2B C0 09				CPY	#$09
     2 4F2D F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   334 4F2F			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: jc2_macros.inc]
     1 4F2F C0 06				CPY	#$06
     2 4F31 F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   335 4F33			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: jc2_macros.inc]
     1 4F33 C0 03				CPY	#$03
     2 4F35 D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   336 						
   337 4F37 28			PRINT_SEP       PLP                         ; restore status bits
   338 4F38 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   339 						
   340 4F3A A9 2E		                LDA     #NUM_SEP
   341 4F3C 4C 52 E0		                JMP     COUT                ; print thousands seperator
   342 						
   343 4F3F 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   344 4F42 28			NO_SEP          PLP                         ; clean up stack
   345 4F43 60			                RTS
   346 				                
   347 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   348 				; INPUT:  A = BCD Number
   349 				; Output: A = Binary Number
   350 				; ******************************************************************************
   351 4F44 85 C0		BCD_TO_BIN      STA     NUM32               ; save BCD number
   352 4F46 29 F0		                AND     #$F0                ; and clear ones digit in A
   353 4F48 4A			                LSR                         ; calc tens digit * 8
   354 4F49 85 C1		                STA     NUM32+1             ; and store result
   355 4F4B 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   356 4F4D 18 65 C1 85 C1			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   357 4F52 A5 C0		                LDA     NUM32               ; reload BCD number int A
   358 4F54 29 0F		                AND     #$0F                ; and clear tens digit in A
   359 4F56 65 C1		                ADC     NUM32+1             ; finally add both result
   360 4F58 60			                RTS			    ; return
   361 				                
   362 				;**** Convert 16 Bit Binary Number To BCD **************************************
   363 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   364 				; OUTPUT: BCD_VAL[4..0] = Result
   365 				; ******************************************************************************
   366 4F59			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: jc2_macros.inc]
     1 4F59 86 C0			STX	NUM32
     2 4F5B 84 C1			STY	NUM32+1
Source: boot_sys_sh.asm
   367 4F5D A2 00 86 C2 86 C3			MWX	#$00 NUM32+2	    ; clear upper word
   368 				                
   369 				;**** Convert 32 Bit Binary Number To BCD **************************************
   370 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   371 				; OUTPUT: BCD_VAL[4..0] = Result
   372 				;*******************************************************************************
   373 4F63 F8			BIN32_TO_BCD    SED                         ; set decimal mode
   374 4F64 A2 04		                LDX     #$04
   375 4F66 A9 00		                LDA     #$00                ; clear BCD result value
   376 4F68 9D 02 5A CA		CLEAR_BCD       STA     BCD_VAL,X-
   377 4F6C 10 FA		                BPL     CLEAR_BCD
   378
   379 4F6E A2 20		                LDX     #$20                ; 32 source bits
   380 4F70			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: jc2_macros.inc]
     1 4F70 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4F72 26 C1		        ROL     NUM32+1		  
     3 4F74 26 C2		        ROL     NUM32+2
     4 4F76 26 C3		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   381 4F78 AD 06 5A 6D 06 5A + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   382 4F81 AD 05 5A 6D 05 5A + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   383 4F8A AD 04 5A 6D 04 5A + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   384 4F93 AD 03 5A 6D 03 5A + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   385 4F9C AD 02 5A 6D 02 5A + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   386 4FA5			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: jc2_macros.inc]
     1 4FA5 CA					DEX
     2 4FA6 D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   387 4FA8 D8			                CLD                         ; reset to binary mode
   388 4FA9 60			                RTS
   389
   390 				; **** Get Command String ******************************************************
   391 				;
   392 				; ******************************************************************************
   393 4FAA A2 01		GET_CMD_STR     LDX     #$01
   394 4FAC			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4FAC BD 00 14				LDA	STRBUF,X
     2 4FAF F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   395 4FB1			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4FB1 C9 20				CMP	#SPC
     2 4FB3 D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   396 4FB5 E8			SKIP_SPC_CHAR   INX
   397 4FB6 4C AC 4F		                JMP     GET_CMD_CHAR
   398 				                
   399 				; **** Get Parameter String ****************************************************
   400 				; Output: C = 1: Parameter; C = 0: Path
   401 				;         A    = $00 : End of parameter string
   402 				;         NCNT = Index to parameter
   403 				; ******************************************************************************
   404 4FB9 A6 A4		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   405 4FBB 20 C9 4F		                JSR     GET_PARM_CHAR
   406 4FBE					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: jc2_macros.inc]
     1 4FBE C9 2F				CMP	#OPT_SEP
     2 4FC0 D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   407 4FC2 E8			                INX			    ; next char
   408 4FC3 BD 00 14		                LDA     STRBUF,X	    ; load parameter
   409 4FC6 4C DD 4F		                JMP     PARAM_STR	    ; OK and return
   410
   411 4FC9			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 4FC9 BD 00 14				LDA	STRBUF,X
     2 4FCC F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   412 4FCE					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4FCE C9 20				CMP	#SPC
     2 4FD0 F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   413 4FD2					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4FD2 C9 2F				CMP	#OPT_SEP
     2 4FD4 F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   414 4FD6 E8			                INX			    
   415 4FD7 4C C9 4F		                JMP     GET_PARM_CHAR
   416
   417 4FDA 18			PATH_STR        CLC			    ; C=0, it is a path
   418 4FDB 90 01		                BCC     END_PARAM	    ; branch always
   419
   420 4FDD 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   421 4FDE 86 A4		END_PARAM       STX     NCNT		    ; save index in parameter string
   422 4FE0 48			                PHA
   423 4FE1 68			                PLA
   424 4FE2 60			                RTS			    ; return
   425
   426 				; **** Internal Command Handlers ***********************************************
   427
   428 				; **** Directory Loop Call Back Functions **************************************
   429 				; Input : A - First character of filename
   430 				;         X - File Attributes
   431 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   432 				; ******************************************************************************
   433
   434 				; **** Print Directory Entry - Call Back Routine *******************************
   435 4FE3			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: jc2_macros.inc]
     1 4FE3 E0 0F				CPX	#$0F
     2 4FE5 F0 64				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   436 4FE7					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 4FE7 C9 E5				CMP	#$E5
     2 4FE9 F0 60				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   437 4FEB 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   438 4FEE 8A			                TXA
   439 4FEF 4A			                LSR     
   440 4FF0 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   441 4FF1 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   442
   443 4FF3			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: jc2_macros.inc]
     4 4FF3 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4FF6 29 04				AND	#(1 << 2)
     6 4FF8 F0 51				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   444 4FFA 4A			CHK_SYSTEM      LSR                         		; check if system file
   445 4FFB 4A			CHK_LABEL       LSR                         		; check if disk label
   446 4FFC 90 08		                BCC     PRINT_DIR_ENTRY			; branch if not a volume label
   447
   448 						; Print Volume Label
   449 4FFE 20 50 4D		                JSR     PRINT_LABEL         		; print disk label
   450 5001 EE 14 18		                INC     LINE_CNT
   451 5004 D0 2D		                BNE     CHK_LINE_COUNT     		 ; branch always
   452
   453 5006			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: jc2_macros.inc]
     1 5006 AD 11 18				LDA	TERM_CHAR
     2 5009 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   454 500B 20 71 4B		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   455 500E 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   456
   457 5010 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   458 5015 20 0E 49		                JSR     OS_DIR_LOOP         		; list files of sub directory
   459 5018 38			                SEC                         		; directory list finished
   460 5019 60			                RTS                         		; exit
   461
   462 501A 20 4D 50		COMP_MASK       JSR     SH_COMP_MASK
   463 501D 90 2D		                BCC     CB_PRINT_END
   464
   465 501F A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   466 5023 20 71 4D		                JSR     PRINT_FILENAME      		; print filename
   467 5026 20 94 4D		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   468 5029 20 5A E0		                JSR     CROUT
   469 502C			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: jc2_macros.inc]
     4 502C AD 1F 18				LDA	CURR_CMD_PARAM
     5 502F 29 01				AND	#(1 << 0)
     6 5031 F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   470 5033 EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   471 5036 A9 19		                LDA     #25
   472 5038					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: jc2_macros.inc]
     1 5038 CD 14 18				CMP	LINE_CNT			; 
     2 503B B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   473 503D A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   474 5042 20 D9 53		                JSR     SH_PAUSE            		; wait for key press
   475 5045			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: jc2_macros.inc]
     1 5045 C9 1B				CMP	#27
     2 5047 D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   476 5049 38			                SEC                         		; break dir loop
   477 504A 60			                RTS
   478 504B 18			CB_PRINT_CONT   CLC                         		; get next next entry
   479 504C 60			CB_PRINT_END    RTS
   480
   481 				; **** Compare File Name With Mask Using Wildcards *****************************
   482 				;
   483 				; ******************************************************************************
   484 504D			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 504D C9 5C				CMP	#PATH_SEP
     2 504F F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   485 5051 A0 0A		                LDY     #10                 			; compare all characters
   486 5053 B9 3E 4C		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   487 5056					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 5056 C9 3F				CMP	#'?'
     2 5058 F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   488 505A					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: jc2_macros.inc]
     1 505A D1 A0				CMP	(CURR_DIR_ENTRY),Y
     2 505C D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   489 						
   490 505E			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: jc2_macros.inc]
     1 505E 88					DEY
     2 505F 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   491 5061 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   492 5062 60			                RTS
   493 5063 18			COMP_NAME_NEQ   CLC
   494 5064 60			                RTS
   495
   496 				; ******************************************************************************
   497 				; ******************************************************************************
   498 5065 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   499 5069 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   500 				; + DRIVE
   501 				                
   502 506D A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   503 506F B9 04 04 99 65 50	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   504 5075 B9 24 18 99 69 50 + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   505 507C 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   506 507E 60			                RTS					; return
   507 				                
   508 507F A0 03		LOAD_ACT_DIR    LDY     #$03
   509 5081 B9 65 50 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   510 5087 B9 69 50 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   511 508E 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   512 5090 60			                RTS					; return
   513 				                
   514 				; **** Get Parameters from Command Line ****************************************
   515 				; Input:  Ptr[X:Y] to Parameter String
   516 				; Output: C = 0 - Error; C = 1 - No Error
   517 				; ******************************************************************************
   518 5091 20 FE 50		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   519 5094 A9 00		                LDA     #$00                ; set current command parameter value to 0
   520 5096 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   521 5099 A0 01 84 A2		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   522 509D 88			                DEY                         ; param mask pointer is set to 0
   523 509E 20 B9 4F		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   524 50A1 F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   525 50A3 B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   526 						
   527 50A5 20 E0 50		                JSR     SH_GET_PATH         ; no, parse path parameter
   528 50A8 B0 EF		                BCS     GET_PARM2           ; more parameters
   529
   530 50AA 60			                RTS			    ; return
   531 						
   532 50AB 20 06 4D		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   533 50AE 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   534 50B1 B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   535 50B3			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 50B3 C9 20				CMP	#SPC
     2 50B5 F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   536 50B7					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: jc2_macros.inc]
     1 50B7 CD 12 18				CMP	F_ATTRIBS
     2 50BA D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   537 50BC A5 A2		                LDA     MASK                ; load bit mask
   538 50BE 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   539 50C1 4C 96 50		                JMP     GET_PARM            ; get next parameter from command line
   540
   541 50C4 C8			NEXT_MASK       INY                         ; point to next char in param mask
   542 50C5 06 A2		                ASL     MASK                ; shift bit mask to next position
   543 50C7 D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   544
   545 50C9 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   546 50CC			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: jc2_macros.inc]
     1 50CC A2 8D			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 50CE A0 59			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   547 50D0 20 6C 4A		                JSR     OS_PRINT_ERR        ; and print it
   548 50D3 AD 12 18		                LDA     F_ATTRIBS
   549 50D6 20 52 E0		                JSR     COUT                ; print unknown parameter char
   550 50D9 20 5A E0		                JSR     CROUT		    ; print CR
   551 50DC 18			                CLC			    ; C=0: error
   552 50DD 60			                RTS
   553 50DE 38			GET_PARMS_END   SEC			    ; C=1: OK
   554 50DF 60			                RTS
   555 				                
   556 				; ******************************************************************************
   557 50E0 A6 A4		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   558 50E2 A0 14		                LDY     #> STRBUF
   559 50E4 20 71 4A		                JSR     OS_PARSE_PATH
   560 50E7 B0 14		                BCS     GET_PATH_END
   561 50E9 D0 03		SH_ERROR        BNE     PARSE_ERR1
   562
   563 50EB 4C B1 57		                JMP     SH_NAME_ERR
   564
   565 50EE			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: jc2_macros.inc]
     1 50EE C9 5C				CMP	#PATH_SEP
     2 50F0 D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   566 50F2 4C AA 57		                JMP     SH_DIR_ERR
   567
   568 50F5			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: jc2_macros.inc]
     1 50F5 C9 FF				CMP	#$FF
     2 50F7 D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   569 50F9 4C A3 57		                JMP     SH_PATH_ERR
   570 50FC 18			GET_PATH_ERR    CLC
   571 50FD 60			GET_PATH_END    RTS
   572
   573 				; **** Set Pointer To Parameter Mask *******************************************
   574 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   575 				; ******************************************************************************
   576 50FE			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: jc2_macros.inc]
     1 50FE 86 E8			STX	STOL
     2 5100 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   577 5102 A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   578 5107 A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   579 510C 60			                RTS
   580
   581 				; Allowed Directory Options ****************************************************
   582 510D 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   583 5112 20			NO_PARMS        .by    ' '
   584
   585 				; **** DIR Command *************************************************************
   586 				; Prints a directory. The following optional parameters can be used:
   587 				; /P : 
   588 				; /A : Show attributes
   589 				; /H : Show hidden files
   590 				; /C : Show cluster number and LBA number
   591 				; ******************************************************************************
   592 5113 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   593 5116 20 6D 50		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   594 5119			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: jc2_macros.inc]
     1 5119 A2 0D			LDX	<DIR_PARMS				; MADS makes this immediate
     2 511B A0 51			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   595 511D 20 91 50		                JSR     SH_GET_PARMS		; Get parameters from command-line
   596 5120 B0 03		                BCS     SH_DIR_START		; branch if parameter found
   597
   598 5122 4C 7F 50		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   599
   600 5125 A2 00		SH_DIR_START    LDX     #$00
   601 5127 8A			                TXA
   602 5128 8D 14 18		                STA     LINE_CNT            	; reset line counter
   603 512B 85 EE		                STA     PSAV                	; reset file found flag
   604 512D 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   605 5131			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: jc2_macros.inc]
     1 5131 E0 08				CPX	#$08
     2 5133 D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   606 5135			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: jc2_macros.inc]
     1 5135 A2 E3			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 5137 A0 4F			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   607 5139 20 02 49		                JSR     OS_FIND_ALL         	; find and print directory entries
   608 513C 20 7F 50		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   609 513F			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: jc2_macros.inc]
     1 513F A5 EE				LDA	PSAV
     2 5141 D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   610 5143 4C 9C 57		                JMP     SH_FILE_ERR         	; no, print error
   611
   612 5146 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   613 5149 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   614 514F 20 33 50		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   615 				                
   616 				; Print Total File Count
   617 5152			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: jc2_macros.inc]
     1 5152 AE 15 18			LDX	CURR_FILE_CNT
     2 5155 AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   618 5158 20 E5 4E		                JSR     PRINT_INT16		; print as word
   619 515B			                PRSTRM  MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTRM [Source: jc2_macros.inc]
     1 515B A2 3E			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 515D A0 59			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 515F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   620
   621 				; Print Total Used Bytes In Directory
   622 5162			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: jc2_macros.inc]
     1 5162 A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 5164 A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   623 5166 20 6D 41		                JSR     LOAD_32			; NUM32 = total filesize
   624 5169 20 EB 4E		                JSR     PRINT_INT32		; print as int32
   625 516C			                PRSTRM  MSG_BYTE_USED		; print ' bytes'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 516C A2 54			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 516E A0 59			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 5170 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   626
   627 				; Print Total Directory Count
   628 5173					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: jc2_macros.inc]
     1 5173 AE 17 18			LDX	CURR_DIR_CNT
     2 5176 AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   629 5179 20 E5 4E		                JSR     PRINT_INT16		; Print as word
   630 517C			                PRSTRM  MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 517C A2 49			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 517E A0 59			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 5180 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   631 5183					MVAX	4 FREE_KB NUM32		; NUM32 = #Free KB
Macro: MVAX [Source: jc2_macros.inc]
     1 5183 A2 03			LDX	#4-1
     2 5185 BD 75 58 95 C0 CA	lp	MVA	FREE_KB,X NUM32,X-
     3 518B 10 F8			BPL	lp
Source: boot_sys_sh.asm
   632 518D 20 EB 4E				JSR	PRINT_INT32		; Print as decimal number
   633 5190					PRSTRM	TXT_KB			; Print ' KB free'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5190 A2 8E			LDX	<TXT_KB				; MADS makes this immediate
     2 5192 A0 58			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 5194 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   634 5197 60					RTS				; return
   635 						
   636 				; **** Create Directory (MKDIR) Command ****************************************
   637 				;
   638 				; ******************************************************************************
   639 5198 20 6D 50		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   640 519B			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: jc2_macros.inc]
     1 519B A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 519D A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   641 519F 20 91 50		                JSR     SH_GET_PARMS        	; get path
   642 51A2 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   643
   644 51A4 A9 10		                LDA     #FA_DIRECTORY		; create directory
   645 51A6 20 C9 47		                JSR     OS_CREATE           	; create directory
   646 51A9 B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   647
   648 51AB			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 51AB C9 FF				CMP	#$FF
     2 51AD F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   649
   650 51AF 20 BF 57		                JSR     SH_WRITE_ERR        	; it was a write error
   651 51B2 90 03		                BCC     SH_MKDIR_END        	; branch always
   652
   653 51B4 20 B8 57		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   654 51B7 4C 7F 50		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   655
   656 				; **** Check if Current Dir. ***************************************************
   657 				; Check if directory entered is current dir (..).
   658 				; Output: C=0: not a current dir, C=1: is current dir.
   659 				; ******************************************************************************
   660 51BA A0 00		IS_FNAME_CURDIR	LDY	#0
   661 51BC B9 3E 4C				LDA	FILENAME,Y
   662 51BF					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: jc2_macros.inc]
     1 51BF C9 2E				CMP	#'.'
     2 51C1 D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   663 51C3 C8					INY
   664 51C4					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: jc2_macros.inc]
     1 51C4 B9 3E 4C				LDA	FILENAME,Y
     2 51C7 D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   665 51C9 F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   666
   667 				; **** Check if Parent Dir. ************************************************
   668 				; Check if current directory is parent dir (..).
   669 				; Output: C=0: not a parent dir, C=1: is parent dir.
   670 				; ******************************************************************************
   671 51CB A0 00		IS_FNAME_PARENT	LDY	#0
   672 51CD B9 3E 4C				LDA	FILENAME,Y
   673 51D0					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: jc2_macros.inc]
     1 51D0 C9 2E				CMP	#'.'
     2 51D2 D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   674 51D4 C8					INY
   675 51D5 B9 3E 4C				LDA	FILENAME,Y
   676 51D8					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: jc2_macros.inc]
     1 51D8 C9 2E				CMP	#'.'
     2 51DA D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   677 51DC C8					INY
   678 51DD					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: jc2_macros.inc]
     1 51DD B9 3E 4C				LDA	FILENAME,Y
     2 51E0 D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   679
   680 51E2 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   681 51E3 60					RTS
   682 51E4 18			NOT_FNAME	CLC				; The filename is not . or ..
   683 51E5 60					RTS
   684 						
   685 				; **** Convert filename to FN83 type filename **********************************
   686 				; INPUT: ssptr_l/ssptr_h pointer to filename
   687 				; OUTPUT: converted filename in FN83
   688 				; ******************************************************************************
   689 51E6 A0 00		FNAME2FN83	LDY	#0
   690 51E8 B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   691 51EA					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 51EA C9 2E				CMP	#'.'
     2 51EC F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   692 						
   693 51EE C8			CPFNCNT		INY
   694 51EF					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: jc2_macros.inc]
     1 51EF C0 0B				CPY	#D_ATTRIBUTES
     2 51F1 D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   695 51F3 F0 18				BEQ	EXT_DN			; branch always if no dot was found
   696
   697 51F5			FN83_DOTFND	; Found a dot
   698 51F5 A2 08				LDX	#8
   699 51F7 C8					INY				; points to char next to '.'
   700 51F8 B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get char of extension
   701 51FA 20 06 4D				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   702 51FD					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: jc2_macros.inc]
     1 51FD 9D 3E 4C				STA	FILENAME,X
     2 5200 F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   703 5202 C8					INY
   704 5203 E8					INX
   705 5204					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: jc2_macros.inc]
     1 5204 E0 0B				CPX	#D_ATTRIBUTES
     2 5206 D0 F0				BNE	CPFN83_2
Source: boot_sys_sh.asm
   706 						
   707 5208 A9 00 9D 3E 4C			MVA	#0 FILENAME,X		; Add '\0' to filename
   708 520D A0 00		EXT_DN		LDY	#0
   709 520F B1 78		CPFN83_3	LDA	(ssptr_l),Y		; Get char of Filename
   710 5211 20 06 4D				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   711 5214 99 3E 4C				STA	FILENAME,Y		; Store in result
   712 5217					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 5217 C9 2E				CMP	#'.'
     2 5219 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   713 521B C8					INY
   714 521C					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: jc2_macros.inc]
     1 521C C0 08				CPY	#8
     2 521E D0 EF				BNE	CPFN83_3
Source: boot_sys_sh.asm
   715 5220 60					RTS				; return
   716 						
   717 5221 A9 20 99 3E 4C C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   718 5227					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: jc2_macros.inc]
     1 5227 C0 08				CPY	#8
     2 5229 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   719 522B 60			CPFN_DN		RTS				; return
   720 						
   721 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   722 				; Check if directory entered is current dir (..).
   723 				; Output: C=0: not a current dir, C=1: is current dir.
   724 				; ******************************************************************************
   725 522C A0 00		ADD_SUBDIR_NAME	LDY	#0
   726 522E			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 522E B9 28 04				LDA	D_SUBDIR_NAME,Y
     2 5231 F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   727 5233 C8					INY
   728 5234 D0 F8				BNE	FIND_EOS			; branch always
   729 5236 60					RTS
   730
   731 5237			SUBDIR_EOS	CPY.EQ	#1 CP_INIT			; branch if root-dir
Macro: CPY.EQ [Source: jc2_macros.inc]
     1 5237 C0 01				CPY	#1
     2 5239 F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   732 523B A9 5C 99 28 04			MVA	#BSLASH D_SUBDIR_NAME,Y		; add '\' to subdir name
   733 5240 C8					INY
   734 5241 A2 00		CP_INIT		LDX	#0
   735 5243 BD 3E 4C 99 28 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   736 5249 F0 06				BEQ	SUBDIR_X			; exit if $00 found
   737 						
   738 524B C8					INY					; index in D_SUBDIR_NAME
   739 524C E8					INX					; index in FILENAME
   740 524D					CPX.NE	#D_ATTRIBUTES CP_FNAME		; branch if not at max filename yet
Macro: CPX.NE [Source: jc2_macros.inc]
     1 524D E0 0B				CPX	#D_ATTRIBUTES
     2 524F D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   741 5251 60			SUBDIR_X	RTS					; return if done
   742 						
   743 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   744 				; ******************************************************************************
   745 5252 A0 00		DEL_SUBDIR_NAME	LDY	#0
   746 5254			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_LP1	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 5254 B9 28 04				LDA	D_SUBDIR_NAME,Y
     2 5257 F0 04				BEQ	SUBDIR_LP1
Source: boot_sys_sh.asm
   747 5259 C8					INY
   748 525A D0 F8				BNE	FIND_EOS2			; branch always
   749 525C 60			DEL_SUBDIR_X	RTS
   750
   751 525D B9 28 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y			; get char from D_SUBDIR_NAME
   752 5260					CMP.EQ	#BSLASH BSLASH_FND		; branch if filename separator found
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 5260 C9 5C				CMP	#BSLASH
     2 5262 F0 04				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   753 5264					DEY.NE	SUBDIR_LP1			; branch always
Macro: DEY.NE [Source: jc2_macros.inc]
     1 5264 88					DEY
     2 5265 D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   754 5267 C8					INY					; Y = 0->1, leave '\' for root-dir
   755 5268 A9 00 99 28 04	BSLASH_FND	MVA	#0 D_SUBDIR_NAME,Y		; Replace '\' with \0 for subdirs in D_SUBDIR_NAME
   756 526D 60			DSNM_X		RTS					; and return
   757
   758 				; **** Change Directory Command ************************************************
   759 				;
   760 				; ******************************************************************************
   761 526E 20 6D 50		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   762 5271			                LDXYI   NO_PARMS
Macro: LDXYI [Source: jc2_macros.inc]
     1 5271 A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 5273 A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   763 5275 20 91 50		                JSR     SH_GET_PARMS		; get subdir name
   764 5278 90 26		                BCC     SH_CD_END		; C=0: no name entered
   765
   766 527A			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: jc2_macros.inc]
     1 527A AD 11 18				LDA	TERM_CHAR
     2 527D D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   767 527F 20 F8 48		                JSR     OS_FIND_PATH		; loop through dir to find path
   768 5282 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   769 						
   770 5284 A0 00				LDY	#0			; add '\0' to string
   771 5286 B9 3E 4C		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   772 5289					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 5289 C9 20				CMP	#' '
     2 528B F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   773 528D C8					INY
   774 528E					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: jc2_macros.inc]
     1 528E C0 0B				CPY	#D_ATTRIBUTES
     2 5290 D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   775 						
   776 5292 A9 00 99 3E 4C	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   777 5297 20 CB 51				JSR	IS_FNAME_PARENT		; is dir .. ?
   778 529A 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   779 						
   780 529C 20 52 52				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   781 529F 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   782 52A0 60			SH_CD_END	RTS
   783
   784 52A1 20 BA 51		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   785 52A4 B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   786 						
   787 52A6 20 2C 52				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   788 52A9 4C 9F 52				JMP	SH_CD_EXIT_OK		; branch always
   789 						
   790 52AC 20 7F 50		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   791 52AF 20 5A E0		                JSR     CROUT			; print CR
   792 52B2 4C A3 57		                JMP     SH_PATH_ERR		; Print 'Path not found'
   793
   794 				; **** Release the FAT clusters for a file  ************************************
   795 				; Algorithm:
   796 				;       SCNT = 1;
   797 				; loop: CURR_CLUSTER = FAT[CURR_CLUSTER];
   798 				;       FAT[CURR_CLUSTER] = 0L; // 0L = free entry
   799 				;       if (CURR_CLUSTER == 0FFFFFFF) SCNT++; goto loop;
   800 				; ******************************************************************************
   801 52B5 A2 00 8E 98 58	CLR_FAT32_FILE 	MVX 	#0 SIS_CNT			; #clusters cleared
   802 52BA			CLR_FAT32_LP1	LDXYI   D_START_FAT1      		; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: jc2_macros.inc]
     1 52BA A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 52BC A0 04			LDY	>D_START_FAT1
Source: boot_sys_sh.asm
   803 52BE 20 6D 41		                JSR     LOAD_32		    		; NUM32 = LBA nr. of FAT
   804 52C1					LDXYI	(CURR_CLUSTER+1)			; SUM32 = CURR_CLUSTER into SUM32
Macro: LDXYI [Source: jc2_macros.inc]
     1 52C1 A2 21			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 52C3 A0 04			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_sh.asm
   805 52C5 20 67 41				JSR     LOAD_S32            		; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   806 52C8 20 2D 53				JSR	PRTST1				; DEBUG
   807 52CB A2 00 86 C7				MVX	#$00 SUM32+3			; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   808 52CF A0 03		                LDY     #$03
   809 52D1 AD 20 04		                LDA     CURR_CLUSTER        		; load CURR_CLUSTER[0] = FAT entry index byte
   810 52D4 0A			                ASL                         		; shift bit 7 into carry flag and multiply entry index by 2
   811 52D5 48			                PHA                         		; save entry index to stack
   812 52D6 36 C4 E8		CLR32_LP        ROL     SUM32,X+             		; shift bit 7 of entry index into bit 0 of block index
   813 52D9			                DEY.NE  CLR32_LP	    		; branch if not done yet
Macro: DEY.NE [Source: jc2_macros.inc]
     1 52D9 88					DEY
     2 52DA D0 FA				BNE	CLR32_LP
Source: boot_sys_sh.asm
   814 						
   815 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   816 52DC 20 9B 41		                JSR     ADD_32_32	    		; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   817 52DF 20 27 41		                JSR     LOAD_FAT_BLK	    		; Load FAT sector into standard buffer ($600)
   818 52E2 68			                PLA                         		; restore entry index
   819 52E3 0A			                ASL                         		; multiply entry index by 2 (4 in total now), C=1 for $40..$7F
   820 52E4 A8			                TAY                         		; store entry index into Y
   821 52E5 A2 04 86 A4		                MVX	#4 NCNT				; 1 FAT32 entry = 4 bytes
   822 52E9 A2 00				LDX	#0				; init. CURR_CLUSTER index
   823 						
   824 						; For this to work, C needs to be set (C=0 for $00..$3F, C=1 for $40..$7F) and Y = curr_cluster mod 256
   825 52EB 20 F8 40		LP_FAT_ENTRY    JSR     READ_ENTRY_BYTE     		; read entry byte
   826 52EE 9D 29 53				STA     TEMP_CLUSTER,X      		; store byte in TEMP_CLUSTER to follow link
   827 52F1 A9 00				LDA	#$00				; A = 0
   828 52F3 20 B7 46				JSR	WRITE_ENTRY_BYTE		; FAT[CURR_CLUSTER] = 0
   829 52F6 C8					INY					; Increment FAT index counter
   830 52F7 E8			                INX					; Increment CURR_CLUSTER counter
   831 52F8			                DEC.NE  NCNT LP_FAT_ENTRY   		; loop until all bytes copied
Macro: DEC.NE [Source: jc2_macros.inc]
     1 52F8 C6 A4				DEC	NCNT
     2 52FA D0 EF				BNE	LP_FAT_ENTRY
Source: boot_sys_sh.asm
   832 						
   833 52FC					MVAX	4 TEMP_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = TEMP_CLUSTER
Macro: MVAX [Source: jc2_macros.inc]
     1 52FC A2 03			LDX	#4-1
     2 52FE BD 29 53 9D 20 04 + lp	MVA	TEMP_CLUSTER,X CURR_CLUSTER,X-
     3 5305 10 F7			BPL	lp
Source: boot_sys_sh.asm
   834 5307 EE 98 58				INC	SIS_CNT				; #clusters cleared + 1
   835 530A A9 0F CD 23 04 D0 + 		CPD	#$0FFFFFFF CURR_CLUSTER		; CURR_CLUSTER == $0FFFFFFF ?
   836 5324 D0 94				BNE	CLR_FAT32_LP1			; branch if file has more clusters to clear
   837 						
   838 5326 4C 08 43				JMP	OS_SAVE_FAT			; Write updated FAT buffer back to disk and return
   839
   840 5329 00 00 00 00		TEMP_CLUSTER	.dword	$00000000
   841 						
   842 532D			PRTST1		PRCH	'['
Macro: PRCH [Source: jc2_macros.inc]
     1 532D A9 5B			LDA	#'['
     2 532F 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   843 5332					PRHEX16	CURR_CLUSTER
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 5332 AD 21 04			LDA	CURR_CLUSTER+1				; print MSB
     2 5335 20 91 E0			JSR	HEXOUT
     3 5338 AD 20 04			LDA	CURR_CLUSTER
     4 533B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   844 533E					PRCH	']'
Macro: PRCH [Source: jc2_macros.inc]
     1 533E A9 5D			LDA	#']'
     2 5340 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   845 5343					PRCH	'='
Macro: PRCH [Source: jc2_macros.inc]
     1 5343 A9 3D			LDA	#'='
     2 5345 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   846 5348					PRCH	'0'
Macro: PRCH [Source: jc2_macros.inc]
     1 5348 A9 30			LDA	#'0'
     2 534A 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   847 534D					PRCH	'L'
Macro: PRCH [Source: jc2_macros.inc]
     1 534D A9 4C			LDA	#'L'
     2 534F 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   848 5352 60					RTS
   849
   850 				; **** Delete Command **********************************************************
   851 				;
   852 				; ******************************************************************************
   853 5353 20 6D 50		SH_DEL          JSR     SAVE_ACT_DIR        			; save actual directory LBA
   854 5356			                LDXYI   NO_PARMS          			; we don't need parameters, just the filename
Macro: LDXYI [Source: jc2_macros.inc]
     1 5356 A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 5358 A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   855 535A 20 91 50		                JSR     SH_GET_PARMS        			; get path
   856 535D 90 63		                BCC     SH_DEL_X	    			; branch if no filename was given
   857
   858 535F 20 FE 48		                JSR     OS_FIND_FILE				; Now find file to delete
   859 5362 90 61		                BCC     SH_DEL_ERR				; branch if file not found
   860
   861 						; OS_FIND_FILE did already set CURR_CLUSTER to the file starting-cluster
   862 5364 A0 00		SH_DEL_FILE	LDY	#D_FILENAME
   863 5366 A9 E5 91 A0				MVA	#$E5 (CURR_DIR_ENTRY),Y			; $E5 first char. is a deleted file
   864 536A A0 14				LDY	#D_START_CLSTH
   865 536C A9 00 91 A0 C8 91 + 		MWA	#$00 (CURR_DIR_ENTRY),Y			; delete high word of file-size
   866
   867 5373 AD 28 18				LDA	DBG_PRINT				; 1 = Print debug info
   868 5376 F0 35				BEQ	SH_DEL_NO_DBG				; branch if no debug
   869
   870 5378					PRSTRM	TXT_SH_DEL1
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5378 A2 C8			LDX	<TXT_SH_DEL1				; MADS makes this immediate
     2 537A A0 53			LDY	>TXT_SH_DEL1
Source: boot_sys_sh.asm
     2 537C 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   871 537F					PRHEX16	CURR_DIR_BLK
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 537F AD 25 18			LDA	CURR_DIR_BLK+1				; print MSB
     2 5382 20 91 E0			JSR	HEXOUT
     3 5385 AD 24 18			LDA	CURR_DIR_BLK
     4 5388 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   872 538B					PRSTRM	TXT_SH_DEL2
Macro: PRSTRM [Source: jc2_macros.inc]
     1 538B A2 D2			LDX	<TXT_SH_DEL2				; MADS makes this immediate
     2 538D A0 53			LDY	>TXT_SH_DEL2
Source: boot_sys_sh.asm
     2 538F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   873 5392					PRHEX32	CURR_CLUSTER
Macro: PRHEX32 [Source: jc2_macros.inc]
     1 5392 AD 23 04			LDA	CURR_CLUSTER+2+1				; print MSB
     2 5395 20 91 E0			JSR	HEXOUT
     3 5398 AD 22 04			LDA	CURR_CLUSTER+2
     4 539B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 539E AD 21 04			LDA	CURR_CLUSTER+1				; print MSB
     2 53A1 20 91 E0			JSR	HEXOUT
     3 53A4 AD 20 04			LDA	CURR_CLUSTER
     4 53A7 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   874 53AA 20 5A E0				JSR	CROUT
   875 53AD			SH_DEL_NO_DBG	LDXYI	CURR_DIR_BLK				; CURR_DIR_BLK is LBA of current dir block
Macro: LDXYI [Source: jc2_macros.inc]
     1 53AD A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 53AF A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_sh.asm
   876 53B1 20 F5 42		                JSR     OS_SAVE_DIR	    			; write this dir entry back to disk
   877 53B4 90 0C				BCC	SH_DEL_X				; Branch on error
   878 						
   879 53B6 20 B5 52		SH_DEL_CONT	JSR	CLR_FAT32_FILE				; Set all FAT entries for this file to 00000000 (free)
   880 53B9 20 39 46				JSR	INIT_FREE_CLUSTER			; FREE_CLUSTER = 2L
   881 53BC 20 4A 46				JSR     OS_NEXT_FREE_CLUSTER			; Get first free cluster in FREE_CLUSTER
   882
   883 						; Update SIS with #clusters freed and first-free cluster nr
   884 53BF 20 99 58				JSR	SIS_ADD					; Update SIS and write back
   885 53C2 4C 7F 50		SH_DEL_X        JMP     LOAD_ACT_DIR        			; error - restore actual directory LBA and return
   886
   887 53C5 4C 9C 57		SH_DEL_ERR	JMP	SH_FILE_ERR				; Print 'File not found' and return
   888
   889 53C8 53 48 5F 44 45 4C + TXT_SH_DEL1	.by	'SH_DEL: $' $00
   890 53D2 2C 20 24 00		TXT_SH_DEL2	.by	', $' $00
   891
   892 				; **** Clear Screen Command ****************************************************
   893 				;
   894 				; ******************************************************************************
   895 53D6 4C B5 E0		SH_CLS          JMP     CLRSCRN
   896
   897 				; **** Pause Command ***********************************************************
   898 				; Output: A - pressed key char
   899 				;         C = 0 ESC key pressed, C = 1 else
   900 				; ******************************************************************************
   901 53D9			SH_PAUSE        PRSTRM  MSG_PAUSE          	; print pause message
Macro: PRSTRM [Source: jc2_macros.inc]
     1 53D9 A2 07			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 53DB A0 59			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 53DD 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   902 53E0 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   903 53E3 48			                PHA
   904 53E4 20 5A E0		                JSR     CROUT
   905 53E7 68			                PLA
   906 53E8 60			                RTS
   907 				                
   908 				; **** Echo Command ************************************************************
   909 				;
   910 				; ******************************************************************************
   911 53E9			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 53E9 BD 00 14				LDA	STRBUF,X
     2 53EC F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   912 53EE 8A			                TXA
   913 53EF A8			                TAY
   914 53F0 C8			                INY
   915 53F1 20 85 E0		                JSR     WRSTR
   916 53F4 20 5A E0		                JSR     CROUT
   917 53F7 60			SH_ECHO_END     RTS
   918
   919 				; **** Goto Command ************************************************************
   920 				;
   921 				; ******************************************************************************
   922 53F8 60			SH_GOTO         RTS
   923
   924 				; **** If Command **************************************************************
   925 				;
   926 				; ******************************************************************************
   927 53F9 20 39 46		SH_IF           JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   928 53FC 20 4A 46		                JSR 	OS_NEXT_FREE_CLUSTER
   929 53FF A0 03				LDY 	#3
   930 5401			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: jc2_macros.inc]
     1 5401 98				TYA
     2 5402 48				PHA
Source: boot_sys_sh.asm
   931 5403 B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   932 5406 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   933 5409					PLY				; restore Y
Macro: PLY [Source: jc2_macros.inc]
     1 5409 68				PLA
     2 540A A8				TAY
Source: boot_sys_sh.asm
   934 540B					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: jc2_macros.inc]
     1 540B 88					DEY
     2 540C 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   935 540E 60					RTS
   936
   937 				; **** Rem Command *************************************************************
   938 				;
   939 				; ******************************************************************************
   940 540F			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: jc2_macros.inc]
     1 540F A5 DC			LDA	BLKBUF
     2 5411 48				PHA
     3 5412 A5 DD			LDA	BLKBUF+1
     4 5414 48				PHA
Source: boot_sys_sh.asm
   941 5415 20 F9 57				JSR	GET_SIS
   942 5418					PLW	BLKBUF
Macro: PLW [Source: jc2_macros.inc]
     1 5418 68				PLA
     2 5419 85 DD			STA	BLKBUF+1
     3 541B 68				PLA
     4 541C 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
   943 541E 60			SH_REM_X	RTS
   944 				                
   945 				; **** BASIC Command ***********************************************************
   946 				; Executes Basic in ROM. Return with 'DOS' command.
   947 				; ******************************************************************************
   948 541F 20 86 FD		SH_BASIC        JSR	MON2RAM			; Select Monitor RAM, disable ROM
   949 5422 20 0A E0				JSR	SWITCH_TO_ROM		; Enable BASIC ROM
   950 5425 4C 0B 1E				JMP	MON_RAM_BLOCK.BAS_JMP	; Run BAS_JMP_CODE from Monitor RAM area
   951
   952 				; ------------------------------------------------------------------------------
   953 				; This routine copies the MON_RAM_BLOCK code below to the Monitor RAM-area at 
   954 				; $1C00 - $1FFF. The entire boot.sys code (this code!) is stored in RAM-BANK 0
   955 				; (= DOS RAM-BANK) by the boot-loader.
   956 				; Note: MON_RAM_BLOCK code-size should be < 256 bytes!
   957 				; This routine is called by OS_MAIN, the DOS Entry-point.
   958 				; ------------------------------------------------------------------------------
   959 5428 20 86 FD		CP_MON_RAM	JSR	MON2RAM				; Select Monitor RAM, disable ROM
   960 						; Do not use RAMB_DOS here: 1) RAMB_DOS is default when starting boot.sys 2) is not yet copied to Monitor RAM
   961 542B A9 6E 85 E8 A9 54 + 		MWA	#MON_RAM_START STOL		; Start of bytes to copy
   962 5433 A9 00 85 CC A9 1E + 		MWA	#MON_RAM_BLOCK.RAMB_DOS END_PTR	; Store in Monitor RAM area
   963 543B A0 00				LDY	#0
   964 543D B1 E8		MON_RAM_LP	LDA	(STOL),Y			; Get byte from MON_RAM_BLOCK
   965 543F 91 CC				STA	(END_PTR),Y			; Store in Monitor RAM area
   966 5441 E6 CC D0 02 E6 CD			INW	END_PTR				; END_PTR++
   967 5447 E6 E8 D0 02 E6 E9			INW	STOL				; STOL/STOH ++
   968 544D A5 E9 C9 55 D0 04 + 		CPW	STOL #MON_RAM_END		; End-address reached?
   969 5457 90 E4				BCC	MON_RAM_LP			; Branch if STOL < end-address
   970
   971 						; ----------------------------------------------------------------------------------------------
   972 						; This PATCH does the following:
   973 						; - Copy the address of OWN_RD_LBLK_BUF into the JMP CMDDEV of DEV_RD_LBLK_BUF (replaces CMDDEV)
   974 						; - Copy the address of OWN_RD_LBLK     into the JMP CMDDEV of DEV_RD_LBLK (replaces CMDDEV)
   975 						; This ensures that the first blocks of boot.sys are read in using the BIOS CF routines,
   976 						; but any subsequent read uses the new routines in MON_RAM_BLOCK.
   977 						; A permanent solution would be to replace the BIOS routines with the ones in MON_RAM_BLOCK.
   978 						;
   979 						; NOTE: This is necessary because at boot, only the first block (with DEV_RD_LBLK(_BUF)) is
   980 						;       loaded, but there's not enough space in this first block for the updated routines.
   981 						; ----------------------------------------------------------------------------------------------
   982 5459 A9 66 8D 55 41 A9 + 		MWA	#MON_RAM_BLOCK.OWN_RD_LBLK_BUF DEV_RD_LBLK_BUF+3
   983 5463 A9 69 8D 5A 41 A9 + 		MWA	#MON_RAM_BLOCK.OWN_RD_LBLK     DEV_RD_LBLK+3
   984 546D 60					RTS					; Return
   985
   986 546E			MON_RAM_START	; Start of Code-block that should be copied into Monitor RAM.
   987 				;-------------------------------------------------------------------------------------------------------
   988 1E00			MON_RAM_BLOCK	.local, $1E00			; Assemble into Monitor RAM ($1E00-$1FFD)
   989 				; Note that FILE_BUFF is located at $1C00-1DFF (512 bytes)!
   990 				;-------------------------------------------------------------------------------------------------------
   991 1E00 A2 00		RAMB_DOS	LDX	#0			; RAM-BANK 0 is the main RAM-BANK, used by DOS
   992 1E02 F0 02				BEQ	RAMB_JMP		; branch always
   993
   994 1E04 A2 04		RAMB_BAS	LDX	#4			; RAM-BANK 4 is the 1st RAM-BANK
   995 1E06 20 53 FD		RAMB_JMP	JSR	SET_RAMBANK		; Enable RAM-BANK for BASIC-programs and return
   996 1E09 EA					NOP
   997 1E0A 60					RTS
   998
   999 				;--------------------------------------------------------------------------------
  1000 				; This function gets copied to Monitor RAM, so that a possible RAM-BANK switch
  1001 				; does not affect the boot.sys code (which is in page 0 of the RAM-BANK area).
  1002 				;--------------------------------------------------------------------------------
  1003 1E0B 20 04 1E		BAS_JMP		JSR	RAMB_BAS		; Enable RAM-BANK for BASIC-programs
  1004 1E0E A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
  1005 1E10					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: jc2_macros.inc]
     1 1E10 C9 B1				CMP	#$B1
     2 1E12 D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
  1006 						
  1007 1E14 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
  1008 1E17 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
  1009
  1010 				;--------------------------------------------------------------------------------
  1011 				; The RAM-BANK MUST be switched to MAIN RAM-bank 0, because the DOS code is there.
  1012 				; If the switch back is not done, the return jump will crash.
  1013 				;--------------------------------------------------------------------------------
  1014 1E1A 20 00 1E		DOS_JMP_RET	JSR	RAMB_DOS		; Enable main RAM-BANK for DOS
  1015 1E1D 4C 97 42				JMP	OS_SHELL_ENTRY		; Default return for Monitor and BASIC
  1016
  1017 				; **** CFC_LOAD routine for CF-IDE driver **************************************
  1018 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP (CF_LOAD_VEC).
  1019 				; ******************************************************************************
  1020 1E20 20 00 1E		CFC_LOAD	JSR	RAMB_DOS		; Enable main RAM-BANK for DOS
  1021 1E23					PRSTRM	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 1E23 A2 AB			LDX	<TXT_LOAD				; MADS makes this immediate
     2 1E25 A0 56			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 1E27 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1022 1E2A 20 E6 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
  1023 						;PRCH	'['
  1024 						;LDXYI	FILENAME		; 
  1025 						;JSR	OS_STRING_OUT		; Print FN83 filename
  1026 						;PRCH	']'
  1027 1E2D 20 6D 50				JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1028 1E30 20 16 57				JSR	SH_LOAD_BAS		; Load .bas file in memory
  1029 1E33 20 04 1E				JSR	RAMB_BAS		; Enable BASIC RAM-BANK again
  1030 1E36 38					SEC				; C=1: OK
  1031 1E37 60					RTS				; return to BASIC
  1032
  1033 				; **** Copy Second and other blocks of File to Memory **************************
  1034 				; Input: PSTR   : pointer to memory-source
  1035 				;        END_PTR: pointer to memory-destination
  1036 				; This routine copies a page (512 B) from one memory-location to another.
  1037 				; Since this routines is in Monitor-RAM, it is save to switch RAM-Banks.
  1038 				; Call tree: CFC_LOAD -> SH_LOAD_BAS -> OS_LOAD_FILE -> LOAD_NEXT_BLKS -> COPY_BLK_DEST
  1039 				; ******************************************************************************
  1040 1E38 20 04 1E		CP_BLK_DEST	JSR	RAMB_BAS			; Select BASIC RAM-BANK
  1041 1E3B A0 00				LDY	#0				; Init. index
  1042 1E3D B1 EA 91 CC		CP_BLK0_LP	MVA	(PSTR),Y (END_PTR),Y		; Get byte from buffer and store in destination
  1043 1E41 E6 CC D0 02 E6 CD			INW	END_PTR				; Increment destination pointer (macro)
  1044 1E47 E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
  1045 1E4D A5 EB				LDA	PSTR+1				; MSB of buffer pointer
  1046 1E4F					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: jc2_macros.inc]
     1 1E4F C9 1E				CMP	#>FILE_BUFF+2
     2 1E51 D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_sh.asm
  1047 1E53					PRCH	'.'
Macro: PRCH [Source: jc2_macros.inc]
     1 1E53 A9 2E			LDA	#'.'
     2 1E55 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1048 1E58 4C 00 1E				JMP	RAMB_DOS			; Select DOS RAM-BANK again and return
  1049
  1050 				; **** CFC_SAVE routine for CF-IDE driver **************************************
  1051 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP (CF_SAVE_VEC).
  1052 				; ******************************************************************************
  1053 1E5B 20 00 1E		CFC_SAVE	JSR	RAMB_DOS			; Enable main RAM-BANK for DOS
  1054 1E5E 20 14 56				JSR	CFC_SAVE_CNT			; Call CFC_SAVE function in DOS RAM area
  1055 1E61 20 04 1E				JSR	RAMB_BAS			; Switch back to BASIC RAM-BANK area
  1056 1E64 38					SEC					; C=1: OK
  1057 1E65 60					RTS					; return to BASIC
  1058
  1059 				;----------------------------------------------------------------------------
  1060 				; Command: CMD_READ_BUF, Read Single Data Block from Logical Address to Std. Block Buffer
  1061 				; Input  :  X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  1062 				; Output :  C   = 0 Error, C = 1 Data OK
  1063 				;	    A   = Error Code
  1064 				;----------------------------------------------------------------------------
  1065 1E66 20 8B F6		OWN_RD_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  1066 										; fall through to CF_RD_LBLK
  1067
  1068 				;----------------------------------------------------------------------------
  1069 				; Command: CMD_READ, Read Single Data Block from Logical Address
  1070 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Source Address
  1071 				;	   BLKBUF,BLKBUFH = 16 Bit Destination Address
  1072 				; Output : C = 0 Error, C = 1 Data OK
  1073 				;	   A = Error Code
  1074 				;----------------------------------------------------------------------------
  1075 1E69 20 E4 1E		OWN_RD_LBLK	JSR	CF_WAIT_BSY0		; Wait until BSY = 0
  1076 1E6C 90 29				BCC	OWN_RD_X		; Branch on error
  1077 1E6E 20 85 FC				JSR	LOAD_LBA_CF		; Load LBA into CF-card
  1078 										; fall through to OWN_RD_BLK
  1079
  1080 				;----------------------------------------------------------------------------
  1081 				; Read Single Data Block
  1082 				; Input:  BLKBUF,BLKBUFH = 16 Bit Destination Address
  1083 				; Output: C = 0 Error, C = 1 Read OK
  1084 				;	  A = Error Code
  1085 				;----------------------------------------------------------------------------
  1086 1E71 A9 01		OWN_RD_BLK	LDA 	#$01
  1087 1E73 8D 82 0C				STA 	CFREG2			; Read one Sector
  1088 1E76 A9 20				LDA 	#$20			; Read Sector Command
  1089 1E78 8D 87 0C				STA 	CFREG7			; CF command register
  1090 1E7B 20 E4 1E				JSR	CF_WAIT_BSY0		; Wait until BSY = 0
  1091 1E7E 90 17				BCC	OWN_RD_X		; Branch on error
  1092 						
  1093 1E80 A2 01		CF_RD_INFO	LDX	#$01			; initialize page counter
  1094 1E82 A0 00				LDY	#$00			; initialize byte counter
  1095 1E84 20 2D 1F		CF_RD_BLK0	JSR	CF_WAIT_DRQ1		; Wait until DRQ and RDY are set
  1096 1E87 90 0E				BCC	OWN_RD_X		; Branch on timeout error
  1097 						
  1098 1E89 AD 80 0C				LDA 	CFREG0			; read data-bytes
  1099 1E8C 91 DC				STA 	(BLKBUF),Y		; store in buffer
  1100 1E8E C8					INY				; next byte
  1101 1E8F D0 F3				BNE 	CF_RD_BLK0		; branch if more bytes to read
  1102
  1103 1E91 E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
  1104 1E93 CA					DEX
  1105 1E94 10 EE				BPL	CF_RD_BLK0		; two pages read? no, read next byte
  1106 						
  1107 1E96 38					SEC				; yes, all data read, set C = 1 (no error)
  1108 1E97 60			OWN_RD_X	RTS
  1109
  1110 				; **** Write Logical Block *****************************************************
  1111 				; Input: [X,Y] points to 32-bit destination LBA
  1112 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
  1113 				; Routine is placed in Monitor RAM, because it may SAVE memory in the RAM-BANK area. 
  1114 				; Call-tree: CFC_SAVE -> CFC_SAVE_CNT -> OS_SAVE_FILE -> DEV_WR_LBLK
  1115 				; ******************************************************************************
  1116 1E98 20 C1 55		DEV_WR_LBLK	JSR	CHECK_LBA			; Check for LBA errors
  1117 1E9B 90 0F				BCC	DEV_NO_WR			; branch if LBA error
  1118 1E9D					PHX					; Save X register
Macro: PHX [Source: jc2_macros.inc]
     1 1E9D 8A				TXA
     2 1E9E 48				PHA
Source: boot_sys_sh.asm
  1119 1E9F 20 04 1E				JSR	RAMB_BAS			; Switch to BASIC RAM-BANK area (disabling DOS area)
  1120 1EA2					PLX					; Get X register back
Macro: PLX [Source: jc2_macros.inc]
     1 1EA2 68				PLA
     2 1EA3 AA				TAX
Source: boot_sys_sh.asm
  1121 1EA4 20 B5 1E				JSR	OWN_WR_LBLK
  1122 1EA7 08					PHP					; Save Carry flag
  1123 1EA8 20 00 1E				JSR	RAMB_DOS			; Enable main RAM-BANK for DOS again and return
  1124 1EAB 28					PLP					; Get Carry flag
  1125 1EAC 60			DEV_NO_WR	RTS					; Return
  1126
  1127 				; **** Write Logical Block From Standard Buffer ********************************
  1128 				; Input: [X,Y] points to 32-bit LBA
  1129 				; It is called from OS_SAVE_FAT only.
  1130 				; ******************************************************************************
  1131 1EAD 20 C1 55		DEV_WR_LBLK_BUF JSR	CHECK_LBA			; Check for LBA errors
  1132 1EB0 90 FA				BCC	DEV_NO_WR			; branch if LBA error
  1133 						; Fall-through to OWN_WR_LBLK_BUF
  1134 						
  1135 				;----------------------------------------------------------------------------
  1136 				; Command: WRITE_BUF, Write Single Data Block from Std. Block Buffer to Logical Address
  1137 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  1138 				; Output : C = 0 Error, C = 1 Data OK
  1139 				;	   A = Error Code
  1140 				;----------------------------------------------------------------------------
  1141 1EB2 20 8B F6		OWN_WR_LBLK_BUF	JSR	INIT_BLKBUF		; set pointer to block buffer
  1142 										; fall through to CR_WR_LBLK
  1143
  1144 				;----------------------------------------------------------------------------
  1145 				; Command: CMD_WRITE, Write Single Data Block to Logical Address
  1146 				; Input  : X,Y = Ptr[LO:HI] to 32 Bit LBA Destination Address
  1147 				;	   BLKBUF,BLKBUFH = 16 Bit Source Address
  1148 				; Output : C = 0 Error, C = 1 Data OK
  1149 				;	   A = Error Code
  1150 				;----------------------------------------------------------------------------
  1151 1EB5 20 E4 1E		OWN_WR_LBLK	JSR	CF_WAIT_BSY0		; Wait until BSY = 0
  1152 1EB8 90 29				BCC	OWN_WR_X		; Branch on error
  1153 1EBA 20 85 FC				JSR	LOAD_LBA_CF		; Load LBA into CF-card
  1154 										; fall through to CF_WR_BLK
  1155
  1156 				;----------------------------------------------------------------------------
  1157 				; Write Single Data Block
  1158 				; Input:  BLKBUF,BLKBUFH = 16 Bit Source Address
  1159 				; Output: C = 0 Error, C = 1 Write OK
  1160 				;	  A = Error Code
  1161 				;----------------------------------------------------------------------------
  1162 1EBD A9 01		OWN_WR_BLK	LDA 	#$01
  1163 1EBF 8D 82 0C				STA 	CFREG2			; Read one Sector
  1164 1EC2 A9 30				LDA 	#$30			; Write Sector Command
  1165 1EC4 8D 87 0C				STA 	CFREG7			; CF command register
  1166 1EC7 20 E4 1E				JSR	CF_WAIT_BSY0		; Wait until BSY = 0
  1167 1ECA 90 17				BCC	OWN_WR_X		; Branch on timeout error
  1168 1ECC A2 01		CF_WR_INFO	LDX	#$01			; initialize page counter
  1169 1ECE A0 00				LDY	#$00			; initialize byte counter
  1170 1ED0 20 2D 1F		CF_WR_BLK0	JSR	CF_WAIT_DRQ1		; Wait until DRQ and RDY are set
  1171 1ED3 90 0E				BCC	OWN_WR_X		; Branch on timeout error
  1172
  1173 1ED5 B1 DC				LDA 	(BLKBUF),Y		; read from buffer
  1174 1ED7 8D 80 0C				STA 	CFREG0			; Write to CF-card
  1175 1EDA C8					INY				; next byte
  1176 1EDB D0 F3				BNE 	CF_WR_BLK0		; branch if more bytes to write
  1177
  1178 1EDD E6 DD				INC	BLKBUF+1		; yes, increment block buffer page
  1179 1EDF CA					DEX
  1180 1EE0 10 EE				BPL	CF_WR_BLK0		; two pages read? no, read next byte
  1181 						
  1182 1EE2 38					SEC				; yes, all data read, set C = 1 (no error)
  1183 1EE3 60			OWN_WR_X	RTS
  1184 						
  1185 				;----------------------------------------------------------------------------
  1186 				; This routine waits until the CF-card is ready.
  1187 				;----------------------------------------------------------------------------
  1188 1EE4 A9 00		CF_WAIT_BSY0	LDA 	#0
  1189 1EE6 85 D6				STA 	MSEC		; msec counter
  1190
  1191 1EE8 AD 87 0C		CF_BSY_LP	LDA 	CFREG7		; read status register
  1192 1EEB 29 80				AND 	#$80		; check busy flag
  1193 1EED F0 0D				BEQ 	CF_OKE		; branch if BSY flag is cleared
  1194 						
  1195 1EEF A9 0A				LDA 	#10		; delay = 10 msec.
  1196 1EF1 20 4D E1				JSR 	DELAY		; delay 10 msec.
  1197 1EF4 E6 D6				INC 	MSEC		; msec-counter
  1198 1EF6 A5 D6				LDA 	MSEC
  1199 1EF8 F0 04				BEQ 	CFBTO		; branch after 2550 msec. and no reset
  1200 1EFA D0 EC				BNE 	CF_BSY_LP	; branch always
  1201 						
  1202 1EFC 38			CF_OKE		SEC			; C=1, OK
  1203 1EFD 60					RTS			; BSY = 0, just return
  1204 					
  1205 1EFE 8E 2B 1F		CFBTO		STX 	SAVX		; Save X register
  1206 1F01 8C 2C 1F				STY 	SAVY		; Save Y register
  1207 1F04 A2 19				LDX 	#<TXT_HWERR    	; Print HW error
  1208 1F06 A0 1F				LDY 	#>TXT_HWERR
  1209 1F08 20 82 F6		CFPRIT		JSR 	OS_STRING_OUT  	; print		
  1210 1F0B AD 87 0C				LDA 	CFREG7		; Status register
  1211 1F0E 20 91 E0				JSR 	HEXOUT		; Print and return
  1212 1F11 AE 2B 1F				LDX	SAVX		; Restore X register
  1213 1F14 AC 2C 1F				LDY	SAVY		; Restore Y register
  1214 1F17 18					CLC			; C=0, error
  1215 1F18 60			CF_END		RTS			; return
  1216
  1217 1F19 42 53 59 3D 31 2C + TXT_HWERR       .by     'BSY=1, $' $00
  1218 1F22 44 52 51 3D 30 2C + TXT_HWERR2      .by     'DRQ=0, $' $00
  1219 1F2B 00			SAVX		.byte	$00
  1220 1F2C 00			SAVY		.byte	$00
  1221
  1222 				; -------------------------------------------------------------------------------------
  1223 1F2D A9 00		CF_WAIT_DRQ1	LDA 	#0
  1224 1F2F 85 D6				STA 	MSEC		; msec counter
  1225
  1226 1F31 AD 87 0C		CF_DRQ_LP	LDA 	CFREG7		; read status register
  1227 1F34 29 50				AND 	#$50		; check for RDY and DSC flags
  1228 1F36 C9 50				CMP 	#$50		; BSY and DSC flags both set?
  1229 1F38 F0 C2				BEQ 	CF_OKE		; branch if RDY and DSC are both set
  1230
  1231 1F3A A9 01				LDA 	#1		; delay = 1 msec.
  1232 1F3C 20 4D E1				JSR 	DELAY		; delay 1 msec.
  1233 1F3F E6 D6				INC 	MSEC		; msec-counter
  1234 1F41 A5 D6				LDA 	MSEC
  1235 1F43 F0 02				BEQ 	CFDRQTO		; branch after 255 msec. and no RDY/DRQ set
  1236 1F45 D0 EA				BNE 	CF_DRQ_LP	; branch always
  1237
  1238 1F47 8E 2B 1F		CFDRQTO		STX 	SAVX		; Save X register
  1239 1F4A 8C 2C 1F				STY 	SAVY		; Save Y register
  1240 1F4D A2 22				LDX 	#<TXT_HWERR2   	; Print HW error
  1241 1F4F A0 1F				LDY 	#>TXT_HWERR2
  1242 1F51 D0 B5				BNE	CFPRIT		; branch always
  1243
  1244 				;-------------------------------------------------------------------------------------------------------
  1245 				.endl		; MON_RAM_BLOCK
  1246 				;-------------------------------------------------------------------------------------------------------
  1247 55C1			MON_RAM_END
  1248
  1249 				;-------------------------------------------------------------------------------------------------------
  1250 				; Checks if LBA to write to is < $20, which means boot-sector area.
  1251 				; This indicates an error and should not happen.
  1252 				; Input : [X,Y] points to 32-bit LBA
  1253 				; Output: C=1, LBA >= $20. C=0, LBA < $20, error 
  1254 				;-------------------------------------------------------------------------------------------------------
  1255 55C1 86 D8		CHECK_LBA	STX	SAVEX			; ZP-var
  1256 55C3 84 D9				STY	SAVEY			; ZP-var, SAVEY = SAVEX + 1
  1257 55C5 A0 03				LDY	#3
  1258 						
  1259 55C7			CHK_LBA_LP	LDA.NE	(SAVEX),Y CHK_LBA_OK	; Branch if LBA >= $20
Macro: LDA.NE [Source: jc2_macros.inc]
     1 55C7 B1 D8				LDA	(SAVEX),Y
     2 55C9 D0 16				BNE	CHK_LBA_OK
Source: boot_sys_sh.asm
  1260 55CB					DEY.NE	CHK_LBA_LP		; Branch if not all LBA-bytes checked
Macro: DEY.NE [Source: jc2_macros.inc]
     1 55CB 88					DEY
     2 55CC D0 F9				BNE	CHK_LBA_LP
Source: boot_sys_sh.asm
  1261 55CE B1 D8				LDA	(SAVEX),Y		; LBA LSB
  1262 55D0					CMP.CS	#$20 CHK_LBA_X		; Branch if LBA LSB >= $20
Macro: CMP.CS [Source: jc2_macros.inc]
     1 55D0 C9 20				CMP	#$20			; 
     2 55D2 B0 0E				BCS	CHK_LBA_X			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
  1263
  1264 55D4					PRSTRM	TXT_LBA_ERR
Macro: PRSTRM [Source: jc2_macros.inc]
     1 55D4 A2 E7			LDX	<TXT_LBA_ERR				; MADS makes this immediate
     2 55D6 A0 55			LDY	>TXT_LBA_ERR
Source: boot_sys_sh.asm
     2 55D8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1265 55DB 20 FB 55				JSR	STACK_DUMP		; Print stack-dump
  1266 55DE 18					CLC
  1267 55DF 90 01				BCC	CHK_LBA_X		; Branch always
  1268 						
  1269 55E1 38			CHK_LBA_OK	SEC				; C=1, LBA oke
  1270 55E2 A6 D8		CHK_LBA_X	LDX	SAVEX
  1271 55E4 A4 D9				LDY	SAVEY
  1272 55E6 60					RTS
  1273
  1274 55E7 45 72 72 6F 72 3A + TXT_LBA_ERR	.by	'Error: LBA < $20!' CR $00
  1275 55FA 00			SAVX		.byte	$00			; SAVEX = ZP, SAVX is RAM-BANK RAM
  1276
  1277 55FB BA			STACK_DUMP	TSX
  1278 55FC E8					INX
  1279 55FD BD 00 01		STRACE		LDA	$100,X			; stack trace
  1280 5600 8E FA 55				STX	SAVX
  1281 5603 20 91 E0				JSR	HEXOUT
  1282 5606 A9 2C				LDA	#','
  1283 5608 20 52 E0				JSR	COUT
  1284 560B AE FA 55				LDX	SAVX
  1285 560E E8					INX
  1286 560F D0 EC				BNE	STRACE
  1287 5611 4C 5A E0				JMP	CROUT			; Print CR and return
  1288
  1289 				; **** CFC_SAVE routine for CF-IDE driver **************************************
  1290 				; Called from CFC_SAVE which is located in Monitor RAM.
  1291 				; ******************************************************************************
  1292 5614			CFC_SAVE_CNT	PRSTRM	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5614 A2 B6			LDX	<TXT_SAVE				; MADS makes this immediate
     2 5616 A0 56			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 5618 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1293 561B					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: jc2_macros.inc]
     1 561B AD 01 20			LDA	$2000+1				; print MSB
     2 561E 20 91 E0			JSR	HEXOUT
     3 5621 AD 00 20			LDA	$2000
     4 5624 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
  1294 5627 20 5E E0				JSR	SPCOUT		
  1295 562A 20 E6 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
  1296 562D					PRCH	'['
Macro: PRCH [Source: jc2_macros.inc]
     1 562D A9 5B			LDA	#'['
     2 562F 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1297 5632					LDXYI	FILENAME		; 
Macro: LDXYI [Source: jc2_macros.inc]
     1 5632 A2 3E			LDX	<FILENAME				; MADS makes this immediate
     2 5634 A0 4C			LDY	>FILENAME
Source: boot_sys_sh.asm
  1298 5636 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
  1299 5639					PRCH	']'
Macro: PRCH [Source: jc2_macros.inc]
     1 5639 A9 5D			LDA	#']'
     2 563B 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
  1300 563E AD 00 20 8D D3 56 + 		MWA	$2000 SAVE_LEN		; SAVE_LEN = end-address
  1301 564A 38 AD D3 56 E9 00 + 		SBW	SAVE_LEN #$2000		; Get net file-size
  1302 565B AD D4 56 8D D5 56			MVA	SAVE_LEN+1 SAVE_SECS	; SAVE_SECS now contains #pages of 256 bytes
  1303 5661 4E D5 56				LSR	SAVE_SECS		; SAVE_SECS now contains #sectors of 512 bytes needed
  1304 5664					LDA.EQ	SAVE_LEN NO_ADD_SEC	; branch if LSB of SAVE_LEN is 0
Macro: LDA.EQ [Source: jc2_macros.inc]
     1 5664 AD D3 56				LDA	SAVE_LEN
     2 5667 F0 03				BEQ	NO_ADD_SEC
Source: boot_sys_sh.asm
  1305
  1306 5669 EE D5 56				INC	SAVE_SECS		; Add 1 to SAVE_SECS if LSB of SAVE_LEN is not 0
  1307 566C			NO_ADD_SEC	PRSTRM	TXT_SECND1		; Print ', size: '
Macro: PRSTRM [Source: jc2_macros.inc]
     1 566C A2 C2			LDX	<TXT_SECND1				; MADS makes this immediate
     2 566E A0 56			LDY	>TXT_SECND1
Source: boot_sys_sh.asm
     2 5670 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1308 5673					LDXY	SAVE_LEN		; Size in bytes
Macro: LDXY [Source: jc2_macros.inc]
     1 5673 AE D3 56			LDX	SAVE_LEN
     2 5676 AC D4 56			LDY	SAVE_LEN+1
Source: boot_sys_sh.asm
  1309 5679 20 E5 4E				JSR	PRINT_INT16		; Print it
  1310 567C					PRSTRM	TXT_SECND2		; Print ', sec: '
Macro: PRSTRM [Source: jc2_macros.inc]
     1 567C A2 CB			LDX	<TXT_SECND2				; MADS makes this immediate
     2 567E A0 56			LDY	>TXT_SECND2
Source: boot_sys_sh.asm
     2 5680 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1311 5683 AD D5 56				LDA	SAVE_SECS		; Get sector count
  1312 5686 20 11 4D				JSR	NUMOUT			; Print #sectors needed
  1313 5689 20 5A E0				JSR	CROUT			; Print CR
  1314 						
  1315 568C					PRSTRM	TXT_OS_CREATE		; Print 'OS_CREATE'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 568C A2 D6			LDX	<TXT_OS_CREATE				; MADS makes this immediate
     2 568E A0 56			LDY	>TXT_OS_CREATE
Source: boot_sys_sh.asm
     2 5690 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1316 5693 A9 20				LDA	#FA_ARCHIVE		; File is modified 
  1317 5695 20 C9 47				JSR	OS_CREATE		; Create file in current dir. and update FAT
  1318 5698 90 10				BCC	SV_CNT_X		; Branch (exit) on error
  1319 						
  1320 569A					PRSTRM	TXT_OS_SAVFILE		; Print 'OS_SAVE_FILE'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 569A A2 E2			LDX	<TXT_OS_SAVFILE				; MADS makes this immediate
     2 569C A0 56			LDY	>TXT_OS_SAVFILE
Source: boot_sys_sh.asm
     2 569E 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1321 56A1 20 FA 44				JSR	OS_SAVE_FILE		; Save contents of file
  1322 56A4 90 04				BCC	SV_CNT_X		; Branch if error
  1323 						
  1324 56A6 20 DA 58				JSR	SIS_DEL			; Subtract #allocated clusters from SIS and write back to disk
  1325 56A9 38					SEC				; C=1: OK
  1326 56AA 60			SV_CNT_X	RTS				; return
  1327
  1328 56AB 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
  1329 56B6 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
  1330 56C2 2C 20 73 69 7A 65 + TXT_SECND1	.by	', size: ' $00
  1331 56CB 2C 20 73 65 63 3A + TXT_SECND2	.by	', sec: ' $00
  1332 56D3 00 00		SAVE_LEN	.word	$0000			; #bytes to save
  1333 56D5 00			SAVE_SECS	.byte	$00			; #sectors (of 512 B) to save
  1334 56D6 4F 53 5F 43 52 45 + TXT_OS_CREATE	.by	'OS_CREATE:' CR $00
  1335 56E2 4F 53 5F 53 41 56 + TXT_OS_SAVFILE 	.by	'OS_SAVE_FILE:' CR $00
  1336
  1337 				; **** BRUN Command ************************************************************
  1338 				;
  1339 				; ******************************************************************************
  1340 56F1 20 6D 50		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1341 56F4			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: jc2_macros.inc]
     1 56F4 A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 56F6 A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1342 56F8 20 91 50		                JSR     SH_GET_PARMS
  1343 56FB 90 05		                BCC     SH_BRUN_END
  1344
  1345 56FD 20 FE 48		                JSR     OS_FIND_FILE
  1346 5700 90 00		                BCC     SH_BRUN_END		; branch if file not found
  1347
  1348 				                ;JSR     OS_LOAD_BIN
  1349 5702 20 7F 50		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1350 5705 60			                RTS
  1351 				                
  1352 				; **** BLOAD Command ***********************************************************
  1353 				;
  1354 				; ******************************************************************************
  1355 5706 60			SH_BLOAD        RTS
  1356
  1357 				; ******************************************************************************
  1358 5707 20 6D 50		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
  1359 570A			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: jc2_macros.inc]
     1 570A A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 570C A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1360 570E 20 FE 50		                JSR     SET_PARM_MASK
  1361 5711 20 E0 50		                JSR     SH_GET_PATH         ; get file path
  1362 5714 90 5C		                BCC     SH_RUN_END
  1363
  1364 						; This is the entry-point for loading a .BAS file into memory
  1365 5716 AD 46 4C		SH_LOAD_BAS     LDA     FILENAME+8
  1366 5719			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: jc2_macros.inc]
     1 5719 C9 20				CMP	#SPC
     2 571B D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
  1367 571D					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: jc2_macros.inc]
     1 571D A0 02			LDY	#3-1
     2 571F B9 1D 5A 99 46 4C + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 5726 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1368
  1369 						; Check for .COM file
  1370 5728 A0 02		SH_RUN1         LDY     #$02
  1371 572A B9 1D 5A		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
  1372 572D					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: jc2_macros.inc]
     1 572D D9 46 4C				CMP	FILENAME+8,Y
     2 5730 D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
  1373 5732			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: jc2_macros.inc]
     1 5732 88					DEY
     2 5733 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
  1374 				                
  1375 5735 A9 01 8D 55 44			MVA	#1 FTYPE	    	; 1 = .COM file
  1376 573A D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
  1377
  1378 573C A0 02		CHK_BASF	LDY     #$02
  1379 573E B9 23 5A		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
  1380 5741			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: jc2_macros.inc]
     1 5741 D9 46 4C				CMP	FILENAME+8,Y
     2 5744 D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
  1381 5746			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: jc2_macros.inc]
     1 5746 88					DEY
     2 5747 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
  1382 				                
  1383 5749 A9 00 8D 55 44			MVA	#0 FTYPE	    	; 0 = .BAS file
  1384 574E F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
  1385
  1386 5750 A0 02		CHK_EXEF	LDY     #$02
  1387 5752 B9 20 5A		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
  1388 5755			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: jc2_macros.inc]
     1 5755 D9 46 4C				CMP	FILENAME+8,Y
     2 5758 D0 18				BNE	SH_RUN_END
Source: boot_sys_sh.asm
  1389 575A			                DEY.PL	CMP_EXT_EXE	    	; branch if not done yet
Macro: DEY.PL [Source: jc2_macros.inc]
     1 575A 88					DEY
     2 575B 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
  1390 				                
  1391 575D A9 02 8D 55 44			MVA	#2 FTYPE	    	; 2 = .EXE file
  1392 5762 20 FE 48		SH_RUN_FF       JSR     OS_FIND_FILE        	; check if file with this extension exists
  1393 5765 B0 08		                BCS     SH_RUN3             	; yes, load file
  1394
  1395 5767 20 5A E0		SH_RUN_ERR      JSR     CROUT		    	; print CR
  1396 576A 20 9C 57		                JSR     SH_FILE_ERR         	; file does not exist
  1397 576D 90 03		                BCC     SH_RUN_END	    	; branch always
  1398
  1399 576F 20 68 44		SH_RUN3         JSR     OS_LOAD_FILE	    	; Load .bas file or load/run .com/.exe file
  1400 5772 4C 7F 50		SH_RUN_END      JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
  1401 				                
  1402 				; **** Print version info  *****************************************************
  1403 				; Output: -
  1404 				; ******************************************************************************
  1405 5775			SH_VER		PRSTRM	MSG_BOOT			; Print Title Info
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5775 A2 D7			LDX	<MSG_BOOT				; MADS makes this immediate
     2 5777 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_sh.asm
     2 5779 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1406 577C 60					RTS
  1407 						
  1408 				; **** List a file *************************************************************
  1409 				; Output: -
  1410 				; ******************************************************************************
  1411 577D 20 6D 50		SH_LIST		JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1412 5780			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: jc2_macros.inc]
     1 5780 A2 12			LDX	<NO_PARMS				; MADS makes this immediate
     2 5782 A0 51			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1413 5784 20 91 50		                JSR     SH_GET_PARMS
  1414 5787 90 05		                BCC     SH_LIST_END
  1415
  1416 5789 20 FE 48		                JSR     OS_FIND_FILE		; If found, CURR_CLUSTER contains cluster number
  1417 578C 90 00		                BCC     SH_LIST_END		; branch if file not found
  1418
  1419 						;JSR	OS_LIST_FILE		; List file
  1420 578E 20 7F 50		SH_LIST_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1421 5791 60			                RTS
  1422
  1423
  1424 				; **** Monitor call-back Routine ************************************************
  1425 5792			SH_MONITOR      PRSTRM   MSG_MONITOR
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5792 A2 DE			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 5794 A0 59			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 5796 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1426 5799 4C 03 E0		                JMP     MON_WARM_START
  1427 				                
  1428 				.macro	PR_ERR	msg
  1429 						LDXYI	:msg
  1430 						JMP	OS_PRINT_ERR
  1431 				.endm
  1432 				; **** Error Routines **********************************************************
  1433 579C			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 579C A2 6D			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 579E A0 59			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 57A0 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1434 57A3			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 57A3 A2 7D			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 57A5 A0 59			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 57A7 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1435 57AA			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 57AA A2 B0			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 57AC A0 59			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 57AE 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1436 57B1			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 57B1 A2 9E			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 57B3 A0 59			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 57B5 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1437 57B8			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 57B8 A2 C3			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 57BA A0 59			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 57BC 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1438 57BF			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 57BF A2 EC			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 57C1 A0 59			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 57C3 4C 6C 4A				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1439 				                
  1440 				; Inits BLKBUF to SIS_BUFF **************************************
  1441 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1442 				; ***************************************************************
  1443 57C6 A9 00 85 DC A9 5B + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1444 57CE 60					RTS
  1445
  1446 				;-------------------------------------------------------------------------------
  1447 				; Convert #Clusters to KB in FREE_KB
  1448 				; D_SECT_PER_CLST = 1: 2 CL =  2 SEC = 1 KB: SHR 1
  1449 				;                   2: 2 CL =  4 SEC = 2 KB: -
  1450 				;		    4: 2 CL =  8 SEC = 4 KB: SHL 1
  1451 				;		    8: 2 CL = 16 SEC = 8 KB: SHL 2 etcetera
  1452 				;-------------------------------------------------------------------------------
  1453 57CF AD 0B 04		CL2KB		LDA	D_SECT_PER_CLST			; #sectors per cluster
  1454 57D2					CMP.EQ	#2 CL2KB_X			; 2 sec/cl, just exit
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 57D2 C9 02				CMP	#2
     2 57D4 F0 22				BEQ	CL2KB_X
Source: boot_sys_sh.asm
  1455 57D6					CMP.EQ	#1 CL2KB_1			; 1 sec/cl, SHR 1
Macro: CMP.EQ [Source: jc2_macros.inc]
     1 57D6 C9 01				CMP	#1
     2 57D8 F0 12				BEQ	CL2KB_1
Source: boot_sys_sh.asm
  1456 57DA 4A 4A			:2	LSR					; init nr of shifts		
  1457 57DC			CL2KB_SHL	ASL32	FREE_KB				; SHL 1 of FREE_KB
Macro: ASL32 [Source: jc2_macros.inc]
     1 57DC 0E 75 58			ASL     FREE_KB		  		; SHL with C=0
     2 57DF 2E 76 58		        ROL     FREE_KB+1		  
     3 57E2 2E 77 58		        ROL     FREE_KB+2
     4 57E5 2E 78 58		        ROL     FREE_KB+3		  
Source: boot_sys_sh.asm
  1458 57E8 4A					LSR
  1459 57E9 D0 F1				BNE	CL2KB_SHL			; branch if not done with shifting
  1460 57EB 60					RTS					; return
  1461 						
  1462 57EC			CL2KB_1		LSR32	FREE_KB				; SHR 1 of FREE_KB
Macro: LSR32 [Source: jc2_macros.inc]
     1 57EC 4E 78 58			LSR     FREE_KB+3		  		; SHR with C=0
     2 57EF 6E 77 58		        ROR     FREE_KB+2
     3 57F2 6E 76 58		        ROR     FREE_KB+1
     4 57F5 6E 75 58		        ROR     FREE_KB
Source: boot_sys_sh.asm
  1463 57F8 60			CL2KB_X		RTS					; return
  1464 						
  1465 				; Get Info from System Information Sector **************************************
  1466 57F9 20 C6 57		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1467 57FC					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START ($0400)
Macro: LDXYI [Source: jc2_macros.inc]
     1 57FC A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 57FE A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1468 5800 20 57 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1469 5803					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: jc2_macros.inc]
     1 5803 A2 03			LDX	#4-1
     2 5805 BD 00 04 9D 71 58 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 580C 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1470 580E 18 AD 71 58 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1471 5821 AD 73 58				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1472 5824 69 00				ADC	#0
  1473 5826 8D 73 58				STA	SYS_INFO_LBA+2
  1474 5829 AD 74 58				LDA	SYS_INFO_LBA+3
  1475 582C 69 00				ADC	#0
  1476 582E 8D 74 58				STA	SYS_INFO_LBA+3
  1477 						
  1478 5831 20 C6 57				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1479 5834					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: jc2_macros.inc]
     1 5834 A2 71			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5836 A0 58			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1480 5838 20 57 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1481 583B AD 28 18				LDA	DBG_PRINT
  1482 583E F0 22				BEQ	FREE_KB_UPDATE
  1483 5840					PRSTRM	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5840 A2 79			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 5842 A0 58			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 5844 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1484 5847					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: jc2_macros.inc]
     1 5847 AD EF 5C			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 584A 20 91 E0			JSR	HEXOUT
     3 584D AD EE 5C			LDA	SIS_BUFF+$01EC+2
     4 5850 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5853 AD ED 5C			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 5856 20 91 E0			JSR	HEXOUT
     3 5859 AD EC 5C			LDA	SIS_BUFF+$01EC
     4 585C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1485 585F 20 5A E0				JSR	CROUT
  1486 5862			FREE_KB_UPDATE	MVAX	4 SIS_BUFF+$01E8 FREE_KB	
Macro: MVAX [Source: jc2_macros.inc]
     1 5862 A2 03			LDX	#4-1
     2 5864 BD E8 5C 9D 75 58 + lp	MVA	SIS_BUFF+$01E8,X FREE_KB,X-
     3 586B 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1487 586D 20 CF 57				JSR	CL2KB				; Convert #clusters to KB and store in FREE_KB
  1488 5870 60					RTS
  1489 						
  1490 5871 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1491 5875 00 00 00 00		FREE_KB		.dword	$00000000
  1492 5879 46 69 72 73 74 20 + TXT_FFREE_CLST	.by	'First free cluster:$' $00
  1493 588E 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1494 5898 00			SIS_CNT		.byte	$00				; SIS counter, counts #clusters freed or allocated
  1495
  1496 				; Write Info back to System Information Sector **************************************
  1497 5899			SIS_ADD		PRSTRM	SISP
Macro: PRSTRM [Source: jc2_macros.inc]
     1 5899 A2 FD			LDX	<SISP				; MADS makes this immediate
     2 589B A0 58			LDY	>SISP
Source: boot_sys_sh.asm
     2 589D 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1498 58A0 AD E8 5C 18 6D 98 + 		ADB	SIS_BUFF+$01E8 SIS_CNT		; add SIS_CNT to #free clusters in SIS-buffer
  1499 58AA 90 03				SCC					; 'skip if C is clear' macro
  1500 58AC EE E9 5C				INC	SIS_BUFF+$01E9
  1501 58AF 90 03				SCC	
  1502 58B1 EE EA 5C				INC	SIS_BUFF+$01EA
  1503 58B4 90 03				SCC	
  1504 58B6 EE EB 5C				INC	SIS_BUFF+$01EB
  1505 58B9 AD 98 58		SIS_WRITE	LDA	SIS_CNT				; Print SIS_CNT
  1506 58BC 20 91 E0				JSR	HEXOUT
  1507 58BF 20 5A E0				JSR	CROUT
  1508 58C2					MVAX	4 FREE_CLUSTER SIS_BUFF+$01EC	; SIS First free cluster = FREE_CLUSTER
Macro: MVAX [Source: jc2_macros.inc]
     1 58C2 A2 03			LDX	#4-1
     2 58C4 BD 20 18 9D EC 5C + lp	MVA	FREE_CLUSTER,X SIS_BUFF+$01EC,X-
     3 58CB 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1509 58CD 20 C6 57				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_WRITE command
  1510 58D0					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: jc2_macros.inc]
     1 58D0 A2 71			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 58D2 A0 58			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1511 						; LDA     #CMD_WRITE			; Call Device-driver Write routine
  1512 				                ;JSR     CMDDEV				; Call device-driver
  1513 58D4 20 B5 1E				JSR	MON_RAM_BLOCK.OWN_WR_LBLK
  1514 58D7 4C 62 58				JMP	FREE_KB_UPDATE			; Update FREE_KB and return
  1515
  1516 58DA			SIS_DEL		PRSTRM	SISM
Macro: PRSTRM [Source: jc2_macros.inc]
     1 58DA A2 02			LDX	<SISM				; MADS makes this immediate
     2 58DC A0 59			LDY	>SISM
Source: boot_sys_sh.asm
     2 58DE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1517 58E1 AD E8 5C 38 ED 98 + 		SBB	SIS_BUFF+$01E8 SIS_CNT		; subtract SIS_CNT from #free clusters in SIS-buffer
  1518 58EB B0 03				SCS					; 'skip if C is set' macro
  1519 58ED CE E9 5C				DEC	SIS_BUFF+$01E9
  1520 58F0 B0 03				SCS
  1521 58F2 CE EA 5C				DEC	SIS_BUFF+$01EA
  1522 58F5 B0 03				SCS
  1523 58F7 CE EB 5C				DEC	SIS_BUFF+$01EB
  1524 58FA 4C B9 58				JMP	SIS_WRITE			; write back to disk
  1525 						
  1526 58FD 53 49 53 2B 00	SISP		.by	'SIS+' $00
  1527 5902 53 49 53 2D 00	SISM		.by	'SIS-' $00
  1528 						
  1529 				; **** Data Area ***************************************************************
  1530 				; ******************************************************************************
  1531
  1532 				; String Data Area *************************************************************
  1533 5907 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1534 5918 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1535 5929 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1536 592E 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1537 593E 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1538 5949 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)   ' $00
  1539 5954 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1540 595C 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1541 596D 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1542 597D 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1543 598D 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1544 599E 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1545 59B0 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1546 59C3 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1547 59DE 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1548 59EC 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1549
  1550 				; ############################################
  1551 59FA 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1552 5A02 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1553 5A07 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1554 5A12 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1555 5A1D 43 4F 4D		EXT_COM         .by    'COM'
  1556 5A20 45 58 45		EXT_EXE		.by    'EXE'
  1557 5A23 42 41 53		EXT_BAS		.by    'BAS'
  1558 				                
  1559 				; Command Table ****************************************************************
  1560 5A26 42 48 5A		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1561 5A29 43 5D 5A				dta	'C' , a(CMD_CD)		
  1562 5A2C 44 67 5A				dta	'D' , a(CMD_DIR)		
  1563 5A2F 45 72 5A				dta	'E' , a(CMD_ECHO)		
  1564 5A32 47 79 5A				dta	'G' , a(CMD_GOTO)		
  1565 5A35 49 80 5A				dta	'I' , a(CMD_IF)		
  1566 5A38 4C 85 5A				dta	'L' , a(CMD_LIST)		
  1567 5A3B 4D 8C 5A				dta	'M' , a(CMD_MKDIR)		
  1568 5A3E 50 99 5A				dta	'P' , a(CMD_PAUSE)		
  1569 5A41 52 A1 5A				dta	'R' , a(CMD_REM)
  1570 5A44 56 A7 5A				dta	'V' , a(CMD_VER)
  1571 5A47 00					.byte 	$00
  1572
  1573 5A48 05 41 53 49 43 1F + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1574 5A4F 05 4C 4F 41 44 06 + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1575 5A56 04 52 55 4E F1 56 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1576 5A5D 02 44 6E 52		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1577 5A61 03 4C 53 D6 53 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1578 5A67 03 49 52 13 51	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1579 5A6C 03 45 4C 53 53 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1580 5A72 04 43 48 4F E9 53 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1581 5A79 04 4F 54 4F F8 53 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1582 5A80 02 46 F9 53 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1583 5A85 04 49 53 54 7D 57 + CMD_LIST	dta	4, c'IST' , a(SH_LIST)   , $00	; 
  1584 5A8C 05 4B 44 49 52 98 + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1585 5A93 03 4F 4E 92 57 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1586 5A99 05 41 55 53 45 D9 + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1587 5AA1 03 45 4D 0F 54 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
  1588 5AA7 03 45 52 75 57 00	CMD_VER		dta	3, c'ER'  , a(SH_VER)    , $00  ;
    94 				                
    95 				; End Of Program Marker ********************************************************
    96 5AAD 00			BOOT_SYS_END    BRK
    97 5AAE					ORG ((*/256)+1)*256		; next free page
    98 = 5B00			SIS_BUFF	.ds 	512			; SIS Buffer 
    99
   100 = 5B30			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
   101
   102 						END
