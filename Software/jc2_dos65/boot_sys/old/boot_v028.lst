mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Disk Operating System for 6502 Microprocessors
     3 				;
     4 				; JC2 DOS65, Version 0.2.8 by Emile, original design (V0.2.0) by Joerg Walke
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; DOS65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0032			VERPSUB    	EQU     '2'    		; primary sub version
    24 = 0038			VERSSUB		EQU	'8'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; V0.2.4: - .BAS LOAD file now works, filename bug-fix and NUM32 bug-fix
    33 				;	  - Bug-fix MKDIR run after DIR command
    34 				;	  - SIS added + total KB printed with DIR command
    35 				; V0.2.5: - DEL command added.
    36 				; V0.2.6: - SAVE from BASIC added, CFC_SAVE, OS_CREATE, OS_CREATE_FILE changed,
    37 				;           OS_SAVE_FILE and LINK_FAT_ENTRY added.
    38 				;         - VER command added.
    39 				;         - Bug-fixes OS_LOAD_FILE when 1) #clusters = 1 2) sectors/cluster = 1
    40 				; V0.2.7: Couple of bug-fixes with path-name string and CD command.
    41 				; V0.2.8: Enabling RAM-BANK 4 for BASIC and RAM-BANK 0 for DOS. Now Basic programs
    42 				;         can load all the way up to $AFFF.
    43 				; ******************************************************************************
    44 						OPT h- ; do not add file header
    45 						OPT f+ ; save as single block
    46
    47 				;------------------------------------------------------------------------------------------------
    48 				; TERMINOLOGY AND FORMULAS USED:
    49 				; 
    50 				; Sector                : A sector consists of 512 bytes.
    51 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    52 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    53 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    54 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    55 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    56 				; 
    57 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    58 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    59 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    60 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    61 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    62 				;------------------------------------------------------------------------------------------------
    63
    64 = 0001			DBG_PRINT	EQU	1			; Set to 1 for debug print-outs
    65
    66 						ICL "macros.inc"		; boot.sys macro definitions for MADS
Source: macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTR	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    88 					LDX	#:n-1
    89 				lp	MVA	:src,X :dst,X-
    90 					BPL	lp
    91 				.endm
    92 					
    93 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
    94 					LDY	#:n-1
    95 				lp	MVA	:src,Y :dst,Y-
    96 					BPL	lp
    97 				.endm
    98
    99 				; Macros used for printing a cluster nr, which consists of 2 words
   100 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   101 						LDA	(:c),Y
   102 					ift :0>1	; st also given?
   103 						STA	:st
   104 					eif	
   105 						JSR	HEXOUT			; changes Y!
   106 				.endm		
   107
   108 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   109 						LDY	#:indx+1		; Print MSB of word
   110 					ift :0>2	; stor also given?	
   111 						PRCLB	:curr_dir :stor+1
   112 					els	
   113 						PRCLB	:curr_dir
   114 					eif
   115 						LDY	#:indx			; Print LSB of word
   116 					ift :0>2	; stor also given?	
   117 						PRCLB	:curr_dir :stor
   118 					els	
   119 						PRCLB	:curr_dir
   120 					eif
   121 				.endm
   122
   123 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   124 					ift :b2>7
   125 						ERT "Only bits 7-0 allowed"
   126 					els
   127 						LDA	:b1
   128 						AND	#(1 << :b2)
   129 						BEQ	:lbl1
   130 					eif
   131 				.endm
   132 					
   133 				; ----------------------------------------------
   134 				; Compare + Branch Macros
   135 				; ----------------------------------------------
   136 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   137 						CMP	:b1
   138 						BEQ	:lbl
   139 				.endm		; A is now not equal to b1
   140 					
   141 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   142 						CMP	:b1
   143 						BNE	:lbl
   144 				.endm		; A is now equal to b1
   145
   146 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   147 				CMP.CC	.macro ' '	b1 lbl
   148 						CMP	:b1			; 
   149 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   150 				.endm		; C is now 1 (A-b1 is >= 0)
   151
   152 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   153 				CMP.CS	.macro ' '	b1 lbl
   154 						CMP	:b1			; 
   155 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   156 				.endm		; C is now 0 (A-b1 is < 0)
   157
   158 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   159 						CPX	:b1
   160 						BEQ	:lbl
   161 				.endm		; X is now not equal to b1
   162 					
   163 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   164 						CPX	:b1
   165 						BNE	:lbl
   166 				.endm		; X is now equal to b1
   167
   168 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   169 				CPX.CC	.macro ' '	b1 lbl
   170 						CPX	:b1			; 
   171 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   172 				.endm		; C is now 1 (X-b1 is >= 0)
   173
   174 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   175 				CPX.CS	.macro ' '	b1 lbl
   176 						CPX	:b1			; 
   177 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   178 				.endm		; C is now 0 (X-b1 is < 0)
   179
   180 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   181 						CPY	:b1
   182 						BEQ	:lbl
   183 				.endm		; Y is now not equal to b1
   184 					
   185 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   186 						CPY	:b1
   187 						BNE	:lbl
   188 				.endm		; Y is now equal to b1
   189
   190 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   191 				CPY.CC	.macro ' '	b1 lbl
   192 						CPY	:b1			; 
   193 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   194 				.endm		; C is now 1 (Y-b1 is >= 0)
   195
   196 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   197 				CPY.CS	.macro ' '	b1 lbl
   198 						CPY	:b1			; 
   199 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   200 				.endm		; C is now 0 (Y-b1 is < 0)
   201
   202 				; ----------------------------------------------
   203 				; Increment/Decrement + Branch Macros
   204 				; ----------------------------------------------
   205 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   206 						DEC	:b1
   207 						BEQ	:lbl
   208 				.endm
   209
   210 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   211 						DEC	:b1
   212 						BNE	:lbl
   213 				.endm
   214
   215 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   216 						INC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   221 						INC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				; ----------------------------------------------
   226 				DEX.NE	.macro 	lbl				; DEX + BNE
   227 						DEX
   228 						BNE	:lbl
   229 				.endm
   230
   231 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   232 						DEX
   233 						BEQ	:lbl
   234 				.endm
   235
   236 				DEX.PL	.macro 	lbl				; DEX + BPL 
   237 						DEX
   238 						BPL	:lbl
   239 				.endm
   240
   241 				DEX.MI	.macro 	lbl				; DEX + BMI
   242 						DEX
   243 						BMI	:lbl
   244 				.endm
   245
   246 				DEX.CC	.macro 	lbl				; DEX + BCC 
   247 						DEX
   248 						BCC	:lbl
   249 				.endm
   250
   251 				DEX.CS	.macro 	lbl				; DEX + BCS
   252 						DEX
   253 						BCS	:lbl
   254 				.endm
   255
   256 				; ----------------------------------------------
   257 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   258 						DEY
   259 						BEQ	:lbl
   260 				.endm
   261
   262 				DEY.NE	.macro 	lbl				; DEY + BNE
   263 						DEY
   264 						BNE	:lbl
   265 				.endm
   266
   267 				DEY.PL	.macro 	lbl				; DEY + BPL 
   268 						DEY
   269 						BPL	:lbl
   270 				.endm
   271
   272 				DEY.MI	.macro 	lbl				; DEY + BMI
   273 						DEY
   274 						BMI	:lbl
   275 				.endm
   276
   277 				DEY.CC	.macro 	lbl				; DEY + BCC 
   278 						DEY
   279 						BCC	:lbl
   280 				.endm
   281
   282 				DEY.CS	.macro 	lbl				; DEY + BCS
   283 						DEY
   284 						BCS	:lbl
   285 				.endm
   286 				; ----------------------------------------------
   287
   288 				; ----------------------------------------------
   289 				; LOAD/STORE + Branch Macros
   290 				; ----------------------------------------------
   291 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   292 						LDA	:b1
   293 						BEQ	:lbl
   294 				.endm
   295
   296 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   297 						LDA	:b1
   298 						BNE	:lbl
   299 				.endm
   300
   301 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   302 						STA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   307 						STA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				; ----------------------------------------------
   312 				; AND/OR + Branch Macros
   313 				; ----------------------------------------------
   314 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   315 					ift :0>2	; LDA + AND + BEQ	
   316 						LDA	:p1
   317 						AND	:p2
   318 						BEQ	:p3
   319 					els		; AND + BEQ
   320 						AND	:p1
   321 						BEQ	:p2
   322 					eif
   323 				.endm
   324
   325 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   326 					ift :0>2	; LDA + AND + BNE	
   327 						LDA	:p1
   328 						AND	:p2
   329 						BNE	:p3
   330 					els		; AND + BNE
   331 						AND	:p1
   332 						BNE	:p2
   333 					eif
   334 				.endm
    67 						ICL "defines.inc"		; boot.sys defines
Source: defines.inc
     1 				;-------------------------------------------------
     2 				; Register Definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				; Global Constants and Variables ***********************************************
     8 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
     9 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    10 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    11 = B000			LAB_COLD	=	$B000		; BASIC cold START
    12
    13 = 00A0			ZP_BASE         EQU     $A0		; Reserved for DOS and boot.sys
    14 = 00A0			CURR_CLUSTER    EQU     ZP_BASE         ; $A0..$A3 (32 bit) - current addressed cluster
    15 = 00A4			CURR_FAT_BLK    EQU     ZP_BASE+4       ; $A4..$A7 (32 bit) - current loaded FAT LBA
    16 = 00A8			CURR_DIR_ENTRY  EQU     ZP_BASE+8       ; $A8..$A9 (16 bit) - pointer to current addressed directory entry
    17 = 00AA			MASK            EQU     ZP_BASE+10	; $AA Mask for FAT table
    18 = 00AB			BCNT            EQU     ZP_BASE+11      ; $AB Block Counter
    19 = 00AC			NCNT            EQU     ZP_BASE+12	; $AC
    20 = 00AD			SCNT            EQU     ZP_BASE+13	; $AD Sector counter within a cluster
    21 = 00AE			RES             EQU     ZP_BASE+14	; $AE
    22
    23 = 0078			ssptr_l		EQU	$78		; BASIC filename pointer LSB
    24 = 0079			ssptr_h		EQU	$79		; BASIC filename pointer MSB
    25
    26 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    27 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    28 = 00CC			END_PTR		EQU	$CC		; CFC_LOAD destination pointer, also used by BIOS ROM checksum routine
    29 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register (same as BIOS)
    30 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register (same as BIOS)
    31 = 00DC			BLKBUF		EQU	$DC
    32 = 00DC			BLKBUFL		EQU	$DC             ; Pointer to block buffer, same in BIOS
    33 = 00DD			BLKBUFH		EQU	$DD
    34
    35 = 00E8			STOL      	EQU   	$E8     	; Store address Low, same in BIOS
    36 = 00E9			STOH      	EQU   	$E9     	; Store address High
    37 = 00EA			PSTR            EQU     $EA		; 2-byte ACIA output pointer, same in BIOS
    38 = 00EE			PSAV            EQU     $EE             ; Saved Partition Number in ASCII, same in BIOS
    39
    40 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
    41 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
    42 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
    43
    44 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400 (same as BIOS)
    45
    46 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
    47 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
    48 = 180A			RETURN_VECT     EQU     $180A           ; return vector to monitor caller in V1.2.1 (was $0001 in V1.2.0)
    49
    50 = 1810			NEXTINDEX       EQU     $1810		; command index
    51 = 1811			TERM_CHAR       EQU     $1811
    52 = 1812			F_ATTRIBS       EQU     $1812
    53 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
    54 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
    55 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
    56 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
    57 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
    58 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
    59 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
    60 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
    61 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
    62 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
    63
    64 = 1830			BAS_JMP_CODE	EQU	$1830		; Code for Basic Warm/Cold start JMP ($20 bytes reserved)
    65 = 1841			DOS_RET_CODE	EQU	BAS_JMP_CODE + DOS_JMP_RET - BAS_JMP	; Address for DOS return code
    66
    67 				; External Routines ************************************************************
    68
    69 = E003			MON_WARM_START  EQU     $E003
    70
    71 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    72 = E052			COUT            EQU     $E052
    73 = E05A			CROUT           EQU     $E05A
    74 = E05E			SPCOUT          EQU     $E05E
    75 = E047			CIN             EQU     $E047
    76 = E062			STRIN           EQU     $E062
    77 = E083			STROUT          EQU     $E083
    78 = E085			WRSTR           EQU     $E085
    79 = E091			HEXOUT          EQU     $E091
    80 = E09A			HEXDIG          EQU     $E09A
    81 = E0BD			DEC2STR         EQU     $E0BD
    82 = E0B5			CLRSCRN         EQU     $E0B5
    83 = E0BA			CMDDEV          EQU     $E0BA
    84 = E1AA			OPEN_DEVICE     EQU     $E1AA
    85 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    86 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    87 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    88 = FD53			SET_RAMBANK	EQU	$FD53			; BIOS v1.2.4
    89 = FD7D			MON2ROM		EQU	$FD7D			; Monitor to ROM
    90 = FD86			MON2RAM		EQU	$FD86			; Monitor to RAM, enable RAM behind it
    91
    92 				; Tables and Buffers ***********************************************************
    93 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
    94 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
    95 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
    96
    97 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor
    98 = 0420			FILE_TABLE      EQU     CURR_VOLUME+$20  	; File Descriptor Table
    99 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices
   100 = 0600			BLOCK_BUFF      EQU     $0600           	; Data Block Buffer
   101
   102 = 5830			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
   103
   104 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   105 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   106
   107 				; Device IDs *******************************************************************
   108 = 0000			NULL_ID		EQU	$00             	; the NULL device
   109 = 0022			FDD1_ID         EQU     $22             	; Floppy drive 1 device ID
   110 = 0023			FDD2_ID         EQU     $23             	; Floppy drive 2 device ID
   111 = 0024			SDC_ID		EQU     $24             	; SD-Card device ID
   112 = 0025			HDD1_ID		EQU     $25             	; CF-Card device ID
   113
   114 				; FAT Types ********************************************************************
   115 = 0002			FAT12_Type      EQU     $02
   116 = 0001			FAT16_Type      EQU     $01
   117 = 0000			FAT32_Type      EQU     $00
   118
   119 				; Device Driver Commands *******************************************************
   120 = 0022			CMD_READ	EQU	34              	; Read data block from device
   121 = 0023			CMD_WRITE	EQU	35              	; Write data block to device
   122 = 0025			CMD_READ_BUF	EQU	37              	; Read data block from device to standard buffer
   123 = 0026			CMD_WRITE_BUF	EQU	38              	; Write data block to device from standard buffer
   124
   125 				; Miscellaneous Constants ******************************************************
   126 = 000D			CR              EQU     $0D             	; Carriage Return ASCII Code
   127 = 0020			SPC             EQU     $20             	; Space ASCII Code
   128 = 005C			BSLASH          EQU     '\'             	; Backslash ASCII Code
   129 = 002F			FSLASH		EQU     '/'             	; Forward slash ASCII Code
   130 = 002E			DOT             EQU     '.'             	; Dot ASCII Code
   131 = 003A			COLON           EQU     ':'             	; Colon ASCII Code
   132 = 002C			COMMA           EQU     ','             	; Comma ASCII Code
   133 = 002D			MINUS           EQU     '-'             	; Minus ASCII Code
   134 = 005F			ULINE           EQU     '_'             	; Underline ASCII Code
   135
   136 				; Interchangeable Chars ********************************************************
   137 = 003E			PROMPT          EQU     '>'             	; Command Line Prompt Char
   138 = 002E			NUM_SEP         EQU     DOT	           	; Thousand Seperator Char
   139 = 005C			PATH_SEP        EQU     BSLASH          	; Path Seperator Char
   140 = 002F			OPT_SEP         EQU     FSLASH           	; Option Prefix Char
   141
   142 				; File Attributes **************************************************************
   143 = 0001			FA_READONLY     EQU     $01             	; file is read only
   144 = 0002			FA_HIDDEN       EQU     $02             	; file is hidden
   145 = 0004			FA_SYSTEM       EQU     $04             	; file is a system file
   146 = 0008			FA_LABEL        EQU     $08             	; file is a volume label
   147 = 0010			FA_DIRECTORY    EQU     $10             	; file is a directory
   148 = 0020			FA_ARCHIVE      EQU     $20             	; file is modified
   149 = 0040			FA_RESERVED1    EQU     $40
   150 = 0080			FA_LINK         EQU     $80             	; file is a link
   151
   152 				; Device Attributes ************************************************************
   153 = 0080			DA_DIRTY        EQU     $80             ; current FAT block is modified
   154
   155 				; Current Volume Descriptor (32 Bytes) *****************************************
   156 				; The BOOT routine in BIOS has already loaded the MBR into $0600, laoded the
   157 				; Volume-ID sector into $0400 and did set (most of) these variables.
   158 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   159 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   160 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   161 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte
   162 										;           or Partition Number in ASCII if harddisk
   163 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   164 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   165 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   166 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   167 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   168 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   169 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   170 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   171 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   172
   173 = 0420			D_SUBDIR_NAME	EQU	FILE_TABLE+$00		; 11 Bytes - Name of entire path (root dir is \)
   174 					
   175 				; Directory Descriptor (32 Bytes) **********************************************
   176
   177 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   178 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   179 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   180 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   181 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   182 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   183 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   184 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   185 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   186 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   187 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   188
   189
    68 						
    69 				.if	USE_XMODEM = 1
    70 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    71 				.endif
    72
    73 				; ******************************************************************************
    74 				; Start of 1st Block of BOOT.SYS ***********************************************
    75 				; ******************************************************************************
    76 = 4000			LOAD_ADDRESS	EQU	$4000
    77 						ORG	LOAD_ADDRESS		; the program start address
    78 				PROG_START					; Program Start Address
    79 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				; V0.1: 22-05-25, Emile first version
    11 				;-------------------------------------------------------------------------------
    12
    13 				; subtract two clusters from START_CLUSTER address *****************************
    14 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    15 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    16 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    17 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    18 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    19 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    20 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    21 4012 A2 01		                LDX     #$01
    22 4014 A0 03		                LDY     #$03
    23 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    24 4019 E9 00		                SBC     #$00
    25 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    26 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    27 				                
    28 				; initialize current FAT block value with 0 ************************************
    29 4022 84 A4		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    30 4024 84 A5		                STY     CURR_FAT_BLK+1
    31 4026 84 A6		                STY     CURR_FAT_BLK+2
    32 4028 84 A7		                STY     CURR_FAT_BLK+3
    33 				                
    34 				; set first cluster of BOOT.SYS as the current cluster *************************
    35 402A A0 15		INIT3           LDY     #$15
    36 402C A2 03		                LDX     #$03
    37 402E 20 74 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    38 4031 A0 1B		                LDY     #$1B
    39 4033 20 74 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    40 				                
    41 				; calculate BOOTS.SYS file size in blocks **************************************
    42 4036 A9 57		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    43 4038 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    44 403B 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    45 403C 85 AB		                STA     BCNT                	; store result into block counter
    46 403E			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: macros.inc]
     1 403E A9 F3				LDA	#<BOOT_SYS_END
     2 4040 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    47 4042 E6 AB		                INC     BCNT                	; some bytes are left, so increment block counter
    48 				                
    49 				; load all blocks of BOOT.SYS file into memory *********************************
    50 4044			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 4044 C6 AB				DEC	BCNT
     2 4046 F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    51 4048 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    52 404D			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: macros.inc]
     1 404D C6 AD				DEC	SCNT
     2 404F F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    53 4051 20 81 41		                JSR     INC_32              	; no, increment block address
    54 4054			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: macros.inc]
     1 4054 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4056 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    55 4058 20 4B 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    56 405B			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 405B C6 AB				DEC	BCNT
     2 405D F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    57 405F D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    58
    59 				; next cluster needs to be loaded considering the volume FAT type **************
    60 4061 20 7E 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    61 4064 B0 0B		                BCS     OS_START            	; if EOF then start OS
    62 						
    63 4066 20 F8 40		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    64 4069 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    65 406E 4C 54 40		                JMP     LOAD_BLK            	; load first block of cluster
    66 				                
    67 4071 4C 22 42		OS_START        JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 4074 20 77 40		SET_WORD        JSR     SET_BYTE
    74 4077 B1 EA 88 95 A0 CA	SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 407D 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 407E			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 407E A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 4080 A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 4082 20 61 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 4085			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: macros.inc]
     1 4085 AD 0A 04				LDA	D_FAT_TYPE
     2 4088 F0 14				BEQ	FAT32
Source: boot_sys_block1.asm
    85 408A					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: macros.inc]
     1 408A C9 01				CMP	#FAT16_TYPE
     2 408C F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 408E 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 408F A6 A1		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 4091 20 83 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 4094 20 1D 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 4097 A5 A0		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 4099 A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 409B 4C BE 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 409E			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: macros.inc]
     1 409E A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40A0 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40A2 20 5B 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40A5 A2 00 86 C7				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40A9 A0 03		                LDY     #$03
   106 40AB A5 A0		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40AD 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40AE 48			                PHA                         	; save entry index to stack
   109 40AF 36 C4 E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40B2			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 40B2 88					DEY
     2 40B3 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40B5 20 8F 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40B8 20 1D 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40BB 68			                PLA                         	; restore entry index
   116 40BC A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40BE			READ_FAT_ENTRY  
   127 40BE A0 FF 84 AA				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40C2 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40C3 A8			                TAY                         	; store entry index into Y
   130 40C4 86 AC		                STX     NCNT                	; store length of entry
   131 40C6 A2 00 86 AE		                MVX     #$00 RES		;
   132 40CA 20 EA 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40CD 95 A0		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40CF 08			                PHP                         	; save carry flag
   135 40D0			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: macros.inc]
     1 40D0 E0 03				CPX	#$03
     2 40D2 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40D4 A2 0F 86 AA		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40D8			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: macros.inc]
     1 40D8 C5 AA				CMP	MASK
     2 40DA D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40DC 85 AE		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40DE 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40DF C8			                INY
   141 40E0 E8			                INX
   142 40E1			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 40E1 C6 AC				DEC	NCNT
     2 40E3 D0 E5				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40E5 A5 AE		                LDA     RES
   144 40E7 C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40E9 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40EA			READ_ENTRY_BYTE AND.NE  #$01 CURR_CLUSTER+1 RD_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 40EA A9 01				LDA	#$01
     3 40EC 25 A1				AND	CURR_CLUSTER+1
     4 40EE D0 04				BNE	RD_UPPER_PAGE
Source: boot_sys_block1.asm
   152 40F0 B9 00 06		                LDA     BLOCK_BUFF,Y        			; read entry byte from lower half of block buffer
   153 40F3 60			                RTS			    			; return
   154 40F4 B9 00 07		RD_UPPER_PAGE   LDA     BLOCK_BUFF+256,Y    			; read entry byte from upper half of block buffer
   155 40F7 60			                RTS			    			; return
   156 				                
   157 				; **** Calculate LBA From Given Cluster Address ********************************
   158 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   159 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   160 				;
   161 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   162 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   163 				; ******************************************************************************
   164 40F8			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: macros.inc]
     1 40F8 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 40FA A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   165 40FC 20 61 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   166 40FF AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   167 4102 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   168 4103 F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   169 						
   170 4105 A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   171 4107 A0 04		                LDY     #$04
   172 4109 18			                CLC
   173 410A 36 C0 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   174 410D			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 410D 88					DEY
     2 410E D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   175 						
   176 4110 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   177 4111 D0 F2		                BNE     LOOP1		     	; 
   178 						
   179 4113			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: macros.inc]
     1 4113 A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 4115 A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   180 4117 20 5B 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   181 411A 4C 8F 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   182
   183 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   184 				; Input: NUM32: LBA number of FAT sector to load
   185 				; ******************************************************************************
   186 411D A2 03		LOAD_FAT_BLK    LDX     #$03
   187 411F 86 AE		                STX     RES                 	; initialize byte counter
   188 				                
   189 				; check if current FAT block and last loaded FAT block are identical ***********
   190 4121 B5 C0		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   191 4123			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: macros.inc]
     1 4123 D5 A4				CMP	CURR_FAT_BLK,X
     2 4125 D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   192 						
   193 4127 C6 AE		                DEC     RES                 	; if equal decrement number of unequal bytes
   194 4129 95 A4 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   195 412C 10 F3		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   196 						
   197 412E A5 AE		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   198 4130 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   199 				                
   200 4132			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: macros.inc]
     1 4132 A5 DC			LDA	BLKBUF
     2 4134 48				PHA
     3 4135 A5 DD			LDA	BLKBUF+1
     4 4137 48				PHA
Source: boot_sys_block1.asm
   201 4138			                LDXYI   NUM32
Macro: LDXYI [Source: macros.inc]
     1 4138 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 413A A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   202 413C 20 46 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($600)
   203 413F					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: macros.inc]
     1 413F 68				PLA
     2 4140 85 DD			STA	BLKBUF+1
     3 4142 68				PLA
     4 4143 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   204 4145 60			LOAD_FAT_END    RTS
   205 				                
   206 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   207 				; Input: [X,Y] points to 32-bit LBA
   208 				; ******************************************************************************
   209 4146 A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   210 4148 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   211 				                
   212 				; **** Read Logical Block ******************************************************
   213 				; Input: [X,Y] points to 32-bit LBA
   214 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   215 				; ******************************************************************************
   216 414B A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   217 414D 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   218 				                
   219 				; Arithmetic Functions *********************************************************
   220 				; ******************************************************************************
   221
   222 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   223 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   224 				; ******************************************************************************
   225 4150			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: macros.inc]
     1 4150 86 C0			STX	NUM32
     2 4152 84 C1			STY	NUM32+1
Source: boot_sys_block1.asm
   226 4154 A2 00 86 C2 86 C3			MWX	#0 NUM32+2		; Zero upper 16-bits
   227 415A 60			                RTS			   	; return
   228 				                
   229 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   230 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   231 				; ******************************************************************************
   232 415B 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   233 415D A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   234 415F D0 04		                BNE     LOAD_32_1	   	; branch always
   235
   236 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   237 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   238 				; ******************************************************************************
   239 4161 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   240 4163 A2 03		                LDX     #$03
   241 4165 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   242 4167 A0 03		                LDY     #$03
   243 4169 B1 E8 95 C0 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   244 416E			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 416E 88					DEY
     2 416F 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   245 4171 60			                RTS			   	; return
   246 				                
   247 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   248 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   249 				; ******************************************************************************
   250 4172			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: macros.inc]
     1 4172 86 E8			STX	STOL
     2 4174 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   251 4176 A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   252 4178 B9 C0 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   253 417E 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   254 4180 60			                RTS			   	; return
   255
   256 				; **** Increment a 32 Bit Value ************************************************
   257 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   258 				; ******************************************************************************
   259 4181 A2 01		INC_32          LDX     #$01
   260
   261 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   262 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   263 				; ******************************************************************************
   264 4183 A0 00		ADD_32_8        LDY     #$00
   265
   266 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   267 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   268 				; ******************************************************************************
   269 4185			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: macros.inc]
     1 4185 86 C4			STX	SUM32
     2 4187 84 C5			STY	SUM32+1
Source: boot_sys_block1.asm
   270 4189 A2 00 86 C6 86 C7			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   271
   272 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   273 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   274 				; ******************************************************************************
   275 418F 18			ADD_32_32       CLC			   	; clear carry flag
   276 4190 A2 00		                LDX     #$00		   	; start with byte 0
   277 4192 08			                PHP			   	; save carry flag
   278 4193 28			ADD_LOOP        PLP			   	; get carry flag back
   279 4194 B5 C4		                LDA     SUM32,X		   	; Get SUM32 byte
   280 4196 75 C0 95 C0		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   281 419A 08			                PHP			   	; save carry flag
   282 419B E8			                INX			   	; next byte
   283 419C			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: macros.inc]
     1 419C E0 04				CPX	#$04
     2 419E D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   284 41A0 28			                PLP			   	; restore stack
   285 41A1 60			                RTS			   	; return
    80 				               
    81 				; ******************************************************************************
    82 				; Start of remaining BOOT.SYS blocks *******************************************
    83 				; ******************************************************************************
    84 41A2					ORG     LOAD_ADDRESS + $0200
    85 4200			BLOCK_2
    86 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; NUM32 shl X
    10 				; ******************************************************************************
    11 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: macros.inc]
     1 4200 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4202 26 C1		        ROL     NUM32+1		  
     3 4204 26 C2		        ROL     NUM32+2
     4 4206 26 C3		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    12 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    13 420B 60			                RTS			  	; return
    14
    15 				; ******************************************************************************
    16 				; NUM32 shr X
    17 				; ******************************************************************************
    18 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: macros.inc]
     1 420C 46 C3			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 C2		        ROR     NUM32+2
     3 4210 66 C1		        ROR     NUM32+1
     4 4212 66 C0		        ROR     NUM32
Source: boot_sys_os.asm
    19 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    20 4217 60			                RTS			  	; return
    21 				                
    22 				; **** Write Logical Block From Standard Buffer ********************************
    23 				; Input: [X,Y] points to 32-bit LBA
    24 4218 A9 26		DEV_WR_LBLK_BUF  LDA    #CMD_WRITE_BUF	  	; Call Device-driver Write routine
    25 421A 4C BA E0		                 JMP    CMDDEV
    26
    27 				; **** Write Logical Block *****************************************************
    28 				; Input: [X,Y] points to 32-bit destination LBA
    29 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
    30 421D A9 23		DEV_WR_LBLK      LDA     #CMD_WRITE		; Call Device-driver Write routine
    31 421F 4C BA E0		                 JMP     CMDDEV
    32
    33 				; ******************************************************************************
    34 				; *                               OS Entry Point                               *
    35 				; ******************************************************************************
    36 4222			OS_MAIN         PRSTR	MSG_BOOT			; Print boot-message
Macro: PRSTR [Source: macros.inc]
     1 4222 A2 36			LDX	<MSG_BOOT				; MADS makes this immediate
     2 4224 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 4226 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    37 4229 20 44 49		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    38 				                
    39 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    40 422C A9 67 8D 06 18 A9 + 		MWA	#CFC_LOAD CF_LOAD_VEC		; macro CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    41 4236 A9 9D 8D 08 18 A9 + 		MWA	#CFC_SAVE CF_SAVE_VEC		; macro CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    42 4240 20 36 54				JSR	CP_BAS_JMP			; Copy BASIC Jump program and return into $1830 RAM-area
    43 4243 A9 41 8D 0A 18 A9 + 		MWA	#DOS_RET_CODE RETURN_VECT	; Return-vector for Monitor and BASIC
    44 424D A2 00 86 01 86 02			MWX	#0 Wrmjpl			; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    45 				                
    46 				; Clear Mount Table ************************************************************
    47 4253 18			                CLC
    48 4254 A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    49 4259 8A					TXA                          		; index to mount table into A
    50 425A 69 20		                ADC     #$20                 		; set to next entry
    51 425C AA			                TAX
    52 425D 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    53 				                
    54 				; Set Boot Device As Current Device ********************************************
    55 425F A2 00		                LDX     #$00		     	; X=0
    56 4261 A0 00		                LDY     #$00                 	; set index to mount table = 0
    57 4263 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    58 4266			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: macros.inc]
     1 4266 C9 22				CMP	#FDD1_ID
     2 4268 F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    59 426A E8			                INX		     	     	; X=2
    60 426B A0 20		                LDY     #$20                 	; set index to mount table = 32
    61 426D			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: macros.inc]
     1 426D C9 23				CMP	#FDD2_ID
     2 426F F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    62 4271 E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    63 4272 A0 40		                LDY     #$40                 	; set index to mount table = 64
    64 4274 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    65
    66 				; Add Boot Device To Mount Table ***********************************************
    67 4277 A2 00		                LDX     #$00
    68 4279 BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    69 4281			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: macros.inc]
     1 4281 E0 20				CPX	#32
     2 4283 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    70 4285 A9 F8		                LDA     #$F8
    71 4287			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: macros.inc]
     1 4287 CD 09 04				CMP	D_MEDIUM_DESCR
     2 428A D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    72 428C A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    73 4291			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: macros.inc]
     1 4291 AD 0A 04				LDA	D_FAT_TYPE
     2 4294 F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    74 4296 A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    75 4298			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: macros.inc]
     1 4298 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 429B 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    76 429E					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 429E CA					DEX
     2 429F D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    77 				                
    78 				; TODO: ADD MORE DEVICES #######################################################
    79
    80 				; **** Shell Entry Point *******************************************************
    81 				; ******************************************************************************
    82 42A1 20 4E 55		OS_SHELL_ENTRY  JSR	GET_SIS		     		; Get sys. info sector		
    83 42A4 4C A9 4B				JMP     SH_CMD_PROMPT			; start of command shell
    84
    85 				; **** Read First Block Of Actual Directory ************************************
    86 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    87 				; ******************************************************************************
    88 42A7			OS_FIRST_DIR_BLK
    89 42A7			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 42A7 AD 0A 04				LDA	D_FAT_TYPE
     2 42AA F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    90 42AC 20 33 49		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    91 42AF 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    92
    93 42B1					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: macros.inc]
     1 42B1 A2 03			LDX	#4-1
     2 42B3 BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42BA 10 F7			BPL	lp
Source: boot_sys_os.asm
    94 42BC AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    95 42BF D0 17		                BNE     SET_NUM_BLOCKS       		; branch always
    96
    97 42C1			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: macros.inc]
     1 42C1 A2 03			LDX	#4-1
     2 42C3 BD 04 04 95 A0 CA	lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C9 10 F8			BPL	lp
Source: boot_sys_os.asm
    98 42CB 20 F8 40		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
    99 42CE			                LDXYI   CURR_DIR_BLK			; LBA of current directory
Macro: LDXYI [Source: macros.inc]
     1 42CE A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42D0 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   100 42D2 20 72 41		                JSR     STORE_32             		; and save result as current directory block
   101 42D5 AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
   102 42D8 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
   103
   104 				; **** Load Directory Block ****************************************************
   105 				; This routine reads a directory block into DIR_BLK_BUF.
   106 				; It is called from OS_NEXT_DIR_BLK.
   107 				; ******************************************************************************
   108 42DB A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
   109 42E3					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: macros.inc]
     1 42E3 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42E5 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   110 42E7 4C 4B 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
   111
   112 				; **** Read Next Directory Block ***********************************************
   113 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   114 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   115 				; ******************************************************************************
   116 42EA A2 00		OS_NEXT_DIR_BLK LDX     #$00
   117 42EC			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 42EC FE 24 18				INC	CURR_DIR_BLK,X
     2 42EF D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   118 42F1 E8			                INX                          		; overflow, increment next byte
   119 42F2			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: macros.inc]
     1 42F2 C9 04				CMP	#$04
     2 42F4 D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   120 42F6 F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   121
   122 				; **** Read Next Directory Cluster *********************************************
   123 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   124 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   125 				; ******************************************************************************
   126 42F8			OS_NEXT_DIR_CLSTR
   127 42F8 20 7E 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   128 42FB 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   129 42FD 60			                RTS			     ; return
   130 				                
   131 				; **** Save Directory Block ****************************************************
   132 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   133 				; Input: X,Y = Pointer to LBA nr.
   134 				; ******************************************************************************
   135 42FE 86 D8		OS_SAVE_DIR     STX	SAVEX			; TODO: remove SAVEX, SAVEY ?
   136 4300 84 D9				STY	SAVEY
   137 4302 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; set source block buffer to DIR_BLK_BUF
   138 430A A6 D8		                LDX     SAVEX       		; pointer to block number (LBA) to be saved
   139 430C A4 D9		                LDY     SAVEY
   140 430E 4C 1D 42		                JMP     DEV_WR_LBLK          	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   141 				                
   142 				; **** Save FAT Block **********************************************************
   143 				; Write FAT table in BLOCK_BUFF ($0600) to disk with LBA nr in X,Y.
   144 				; Input: X,Y = Pointer to LBA nr.
   145 				; ******************************************************************************
   146 4311			OS_SAVE_FAT     LDXYI	CURR_FAT_BLK		; LBA nr of FAT
Macro: LDXYI [Source: macros.inc]
     1 4311 A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 4313 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   147 4315 4C 18 42		                JMP     DEV_WR_LBLK_BUF        	; write FAT buffer and return
   148
   149 				; **** Create New File on Disk *************************************************
   150 				; Input: FILENAME = String8_3
   151 				;        A        = File Attributes
   152 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   153 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   154 				; ******************************************************************************
   155 4318 AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   156 4319 A0 00		                LDY     #D_FILENAME         		; set index to filename
   157 431B B9 9D 4B 91 A8 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   158 4321			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: macros.inc]
     1 4321 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4323 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   159 						
   160 						; Write Attribute
   161 4325 8A			                TXA                         	; yes, get attribute back to A
   162 4326 91 A8		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   163 4328 A9 00		                LDA     #$00                	; and clear all following bytes to 0
   164 432A C8			                INY
   165 432B			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: macros.inc]
     1 432B C0 20				CPY	#$20			; 
     2 432D 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   166 						
   167 						; Write create-Date and Last-write Date
   168 432F 20 B9 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   169 4332 98			                TYA				; Y = MSB
   170 4333 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   171 4335 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   172 4337 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   173 4339 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   174 433C 8A			                TXA				; X = LSB
   175 433D 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   176 433F A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   177 4341 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   178
   179 						; Write create-Time and last-write Time
   180 4343 20 94 43		                JSR     OS_FILETIME         	; get current time as file time
   181 4346 98			                TYA				; Y = MSB
   182 4347 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   183 4349 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   184 434B A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   185 434D 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   186 4350 8A			                TXA				; X = LSB
   187 4351 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   188 4353 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   189 4355 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   190
   191 						; Write File Cluster Nr High and Low
   192 4357 A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   193 4359 AD 23 18 91 A8 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   194 435F AD 22 18 91 A8			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   195 4364 A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   196 4366 AD 21 18 91 A8 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   197 436C AD 20 18 91 A8			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   198 						
   199 4371 AD 12 18				LDA     F_ATTRIBS				; Get file/dir attributes again
   200 4374					AND.NE  #FA_DIRECTORY OS_CR_SAV			; create a dir? Branch if it is a dir
Macro: AND.NE [Source: macros.inc]
     6 4374 29 10				AND	#FA_DIRECTORY
     7 4376 D0 15				BNE	OS_CR_SAV
Source: boot_sys_os.asm
   201
   202 4378 A0 1C		                LDY     #D_FILE_SIZE      			; index to file size in dir. entry
   203 437A AD 53 52 91 A8 C8 + 		MWA	SAVE_LEN (CURR_DIR_ENTRY),Y+		; Save file-length in current dir. entry
   204 4386 A9 00 91 A8 C8 91 + 		MWA	#0 (CURR_DIR_ENTRY),Y			; Set high-word of file-size to 0
   205 						
   206 438D			OS_CR_SAV	LDXYI	CURR_DIR_BLK				; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: macros.inc]
     1 438D A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 438F A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   207 4391 4C FE 42		                JMP     OS_SAVE_DIR	    			; write this dir entry back to disk and return
   208 				                
   209 				; **** Get Current Time As File Time *******************************************
   210 				; Output: File Time = Word[X,Y]
   211 				; ******************************************************************************
   212 4394 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   213
   214 				; **** Convert Time To File Time ***********************************************
   215 				; Input:  A - HOUR 	in BCD ($00-$23)
   216 				;	  X - MINUTE 	in BCD ($00-$59)
   217 				;	  Y - SECONDS	in BCD ($00-$59)
   218 				; Output: File Time = Word[X,Y]
   219 				; ******************************************************************************
   220 4397			OS_TIME_TO_FILETIME
   221 4397 20 E0 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   222 439A 85 C0		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   223 439C A9 00 85 C1				MVA	#$00 NUM32+1	    ; clear upper byte of result
   224 43A0 A2 06		                LDX     #$06
   225 43A2 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   226 43A5 A5 C5		                LDA     SUM32+1             ; load MINUTE into A
   227 43A7 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   228 43AB A2 05		                LDX     #$05
   229 43AD 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   230 43B0 A5 C6		                LDA     SUM32+2             ; load SECONDS into A
   231 43B2 6A			                ROR                         ; divide SECONDS by 2
   232 43B3 05 C0		                ORA     NUM32               ; and add value into result
   233 43B5 AA			                TAX
   234 43B6 A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   235 43B8 60			                RTS
   236 				                
   237 				; **** Get Current Date As File Date *******************************************
   238 				; Output: File Date = Word[X,Y]
   239 				; ******************************************************************************
   240 43B9 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   241
   242 				; **** Convert Date To File Date ***********************************************
   243 				; Input:  A - YEAR 	in BCD ($00-$99)
   244 				; 	  X - MONTH 	in BCD ($01-$12)
   245 				; 	  Y - DAY	in BCD ($01-$31)
   246 				; Output: File Date = Word[X,Y]
   247 				; ******************************************************************************
   248 43BC			OS_DATE_TO_FILEDATE
   249 43BC 20 E0 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   250 43BF 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   251 43C2 85 C0		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   252 43C4 A9 00 85 C1		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   253 43C8 A2 04		                LDX     #$04
   254 43CA 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   255 43CD A5 C5		                LDA     SUM32+1             ; load MONTH into A
   256 43CF 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   257 43D3 A2 05		                LDX     #$05
   258 43D5 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   259 43D8 A5 C6		                LDA     SUM32+2             ; load DAY into A
   260 43DA 05 C0		                ORA     NUM32               ; and add value into result
   261 43DC AA			                TAX
   262 43DD A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   263 43DF 60			                RTS
   264 				                
   265 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   266 43E0			CONVERT_DATETIME
   267 43E0 85 C4		                STA     SUM32		    ; Year or Hour
   268 43E2					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: macros.inc]
     1 43E2 86 C5			STX	SUM32+1
     2 43E4 84 C6			STY	SUM32+1+1
Source: boot_sys_os.asm
   269 43E6 A0 02		                LDY     #$02		    ; 3 bytes to convert
   270 43E8 B9 C4 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   271 43EB 20 87 4E		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   272 43EE 99 C4 00 88		                STA     SUM32,Y-	    ; Store result back
   273 43F2 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   274 43F4 60			                RTS			    ; return
   275
   276 				; **** Copy First block of File to memory **************************************
   277 				; Input:
   278 				; ******************************************************************************
   279 43F5 20 79 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   280 43F8					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: macros.inc]
     1 43F8 AD 6F 44				LDA	FTYPE
     2 43FB F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   281 43FD					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: macros.inc]
     1 43FD C9 01				CMP	#1
     2 43FF F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   282 						
   283 						; .EXE file (FTYPE=2)
   284 4401 AD 00 5A 8D 12 45			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   285 4407 85 CC				STA	END_PTR			; destination address LSB
   286 4409 AD 01 5A 8D 13 45			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   287 440F 85 CD				STA	END_PTR+1		; destination address MSB
   288 4411 A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   289 4415 D0 1C				BNE	COPY_BLK_DEST		; branch always
   290 						
   291 						; .COM file  (FTYPE=1)
   292 4417 A9 00 8D 12 45	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   293 441C 85 CC				STA	END_PTR			 ; destination address LSB
   294 441E A9 30 8D 13 45			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   295 4423 85 CD				STA	END_PTR+1		 ; destination address MSB
   296 4425 D0 0C				BNE	COPY_BLK_DEST		 ; branch always
   297 						
   298 						; .BAS file (FTYPE=0)
   299 4427 A9 00 85 CC A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR END_PTR	; destination = BAS_LOAD_ADDR, 1st 2 bytes contain end-address
   300 442F A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; skip first 2 bytes of .BAS file (contains $00 $20)
   301 						
   302 				; **** Copy Second and other blocks of File to Memory **************************
   303 				; Input:
   304 				; ******************************************************************************
   305 4433			COPY_BLK_DEST	PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 4433 A9 5B			LDA	#'['
     2 4435 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   306 4438					PRHEX16	PSTR
Macro: PRHEX16 [Source: macros.inc]
     1 4438 A5 EB			LDA	PSTR+1				; print MSB
     2 443A 20 91 E0			JSR	HEXOUT
     3 443D A5 EA			LDA	PSTR
     4 443F 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   307 4442					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 4442 A9 2C			LDA	#','
     2 4444 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   308 4447					PRHEX16	END_PTR
Macro: PRHEX16 [Source: macros.inc]
     1 4447 A5 CD			LDA	END_PTR+1				; print MSB
     2 4449 20 91 E0			JSR	HEXOUT
     3 444C A5 CC			LDA	END_PTR
     4 444E 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   309 4451					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4451 A9 5D			LDA	#']'
     2 4453 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   310 4456 A0 00				LDY	#0
   311 4458 B1 EA 91 CC		CP_BLK0_LP	MVA	(PSTR),Y (END_PTR),Y		; Get byte from buffer and store in destination
   312 445C E6 CC D0 02 E6 CD			INW	END_PTR				; Increment destination pointer (macro)
   313 4462 E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
   314 4468 A5 EB				LDA	PSTR+1				; MSB of buffer pointer
   315 446A					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: macros.inc]
     1 446A C9 5C				CMP	#>FILE_BUFF+2
     2 446C D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_os.asm
   316 446E 60					RTS					; return
   317 						
   318 446F 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   319
   320 				; **** Init File Buffer ********************************************************
   321 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   322 				; ******************************************************************************
   323 4470 A9 00 85 DC A9 5A + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   324 4478 60					RTS				; return
   325 						
   326 				; **** Init File-buffer pointer ************************************************
   327 				; This routine sets PSTR to FILE_BUFF
   328 				; ******************************************************************************
   329 4479 A9 00 85 EA A9 5A + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   330 4481 60					RTS				; return
   331
   332 				; **** Load BAS/COM/EXE File ***************************************************
   333 				; Input: CURR_CLUSTER: cluster nr of file to load
   334 				; ******************************************************************************
   335 4482 20 46 48		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       		; check if filesize is 0
   336 4485 90 01		                BCC     OS_LOAD_COM2			; branch if file is not empty
   337 						
   338 4487 60			                RTS                         		; filesize is 0, just do nothing
   339 						
   340 4488			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      		; current cluster nr
Macro: LDXYI [Source: macros.inc]
     1 4488 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 448A A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   341 448C 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   342 448F A9 00 85 AB		                MVA     #$00 BCNT              		; init. block counter
   343 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   344 4493 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   345 4498 A0 1D		                LDY     #D_FILE_SIZE+1      		; index to file size in dir. entry
   346 449A B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file size byte 1
   347 449C 4A			                LSR                         		; check if bit 0 is set (bytes 256-511 of buffer)
   348 449D 48			                PHA			    		; save byte: now contains file-size in blocks of 512 bytes
   349 449E B0 06		                BCS     LOAD_COM1           		; yes, add one block
   350 						
   351 44A0 88			                DEY					; now points to D_FILE_SIZE LSB
   352 44A1			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: macros.inc]
     1 44A1 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44A3 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   353 44A5 38			                SEC                         		; yes, add one block
   354 44A6 68			LOAD_COM1       PLA
   355 44A7 65 AB 85 AB		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   356 44AB			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: macros.inc]
     1 44AB C9 59				CMP	#89			; 
     2 44AD B0 28				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   357 						
   358 44AF A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   359 44B1			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44B1 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B3 D0 22				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   360 44B5 C8			                INY					; D_FILE_SIZE+3
   361 44B6			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44B6 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B8 D0 1D				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   362 						
   363 						; Read first part of file into FILE_BUFF
   364 44BA 20 70 44				JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   365 44BD			                LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44BD A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44BF A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   366 44C1 20 4B 41		                JSR     DEV_RD_LBLK         		; Read first block of file into FILE_BUFF
   367 44C4 20 F5 43				JSR	COPY_BLK0_DEST			; Copy first block to destination
   368 44C7					DEC.EQ	BCNT OS_EXEC_CHK		; Branch if #blocks to read is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44C7 C6 AB				DEC	BCNT
     2 44C9 F0 3E				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   369 44CB					DEC.EQ  SCNT NEXT_CLUSTER0     		; Branch if sectors/cluster is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44CB C6 AD				DEC	SCNT
     2 44CD F0 2A				BEQ	NEXT_CLUSTER0
Source: boot_sys_os.asm
   370 						
   371 44CF 20 DE 44		                JSR     LOAD_NEXT_BLKS	    		; Load next blocks of file and execute it
   372 44D2 A9 25		                LDA     #HDD1_ID   	    		; Replace by D_DEV_ID?
   373 44D4 4C AA E1				JMP     OPEN_DEVICE			; Init. device driver again and return
   374 						
   375 44D7			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      		; load error message...
Macro: LDXYI [Source: macros.inc]
     1 44D7 A2 8E			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 44D9 A0 4B			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   376 44DB 4C C8 49		                JMP     OS_PRINT_ERR			; Print it
   377
   378 				; **** Read Next File Blocks ***************************************************
   379 				; ******************************************************************************
   380 44DE 20 81 41		LOAD_NEXT_BLKS  JSR     INC_32              		; Increment LBA block address in NUM32
   381 44E1 20 70 44		LOAD_BLK0       JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   382 44E4					LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44E4 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44E6 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   383 44E8 20 4B 41		                JSR     DEV_RD_LBLK         		; and read next block of file into FILE_BUFF
   384 44EB 20 79 44				JSR	INIT_FBUF_PTR			; reset file-buffer pointer PSTR to FILE_BUFF again
   385 44EE 20 33 44				JSR	COPY_BLK_DEST	    		; Copy block to destination
   386 44F1			                DEC.EQ  BCNT OS_EXEC_CHK      		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 44F1 C6 AB				DEC	BCNT
     2 44F3 F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   387 44F5					DEC.NE  SCNT LOAD_NEXT_BLKS    		; branch if more blocks in cluster to read
Macro: DEC.NE [Source: macros.inc]
     1 44F5 C6 AD				DEC	SCNT
     2 44F7 D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   388
   389 				; next cluster needs to be loaded considering the volume FAT type **************
   390 44F9 20 7E 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   		; Get next cluster from FAT table in CURR_CLUSTER.
   391 44FC B0 0B		                BCS     OS_EXEC_CHK	    		; C=1, EOF, go execute File
   392 							
   393 44FE 20 F8 40		                JSR     CLUSTER_TO_BLK	    		; convert CURR_CLUSTER to LBA number in NUM32.
   394 4501 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   395 4506 4C E1 44		                JMP     LOAD_BLK0	    		; branch always
   396 						
   397 				; Run file if needed ***********************************************************
   398 				; ******************************************************************************
   399 4509			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: macros.inc]
     1 4509 AD 6F 44				LDA	FTYPE
     2 450C D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   400 450E 60					RTS					; return in case of a .BAS file
   401
   402 				; **** Execute File ************************************************************
   403 				; Input:  Ptr[OS_PROG] to Start Address
   404 				; Output: A - Result Code
   405 				; ******************************************************************************
   406 450F 6C 12 45		OS_EXECUTE      JMP     (OS_PROG)           		; run .com or .exe file
   407 4512 00 00		OS_PROG         .word      $0000
   408 				                
   409 				; **** Save the contents of a file to disk *************************************
   410 				; OS_CREATE/OS_CREATE_FILE has already created an entry in the current directory
   411 				; and allocated the first free cluster (in CURR_CLUSTER) to the file. If the file
   412 				; existed, it was deleted first, so you always have a new first cluster number. 
   413 				; This routine writes all sectors of this file and updates (=links clusters 
   414 				; together) the FAT table. 
   415 				; Input: FREE_CLUSTER: first cluster nr of file to save
   416 				; ******************************************************************************
   417 4514			OS_SAVE_FILE	LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 4514 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4516 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   418 4518 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   419 451B A9 FE 8D A8 45 A9 + 		MWA	#$1FFE FSAVE_PTR		; Init. BLKBUF to start of .BAS file to save
   420 4525 20 86 FD				JSR	MON2RAM				; Enable RAM behind Monitor ROM ($1C00-$1FFF)
   421 4528 A9 00 8D FE 1F A9 + 		MWA	#$2000 $1FFE			; Set first word of Basic file to start-address
   422 4532 AD 55 52 85 AB	                MVA     SAVE_SECS BCNT      		; init. block counter, SAVE_SECS was calculated by CFC_SAVE
   423 4537 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   424 453C A9 01 8D E8 55			MVA	#1 SIS_CNT			; #clusters allocated
   425
   426 				; Write sectors/cluster until --BCNT = 0
   427 4541 AD A8 45 85 DC AD + SAVE_NXT_BLK	MWA	FSAVE_PTR BLKBUF		; BLKBUF = FSAVE_PTR
   428 454B					LDXYI	NUM32				; LBA number
Macro: LDXYI [Source: macros.inc]
     1 454B A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 454D A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   429 454F 20 1D 42				JSR	DEV_WR_LBLK			; Write another sector to disk
   430 4552 EE A9 45 EE A9 45		:2	INC	FSAVE_PTR+1			; BLKBUF += $0200, points to next block in memory to save
   431 4558			                DEC.EQ  BCNT OS_SAVE_X      		; branch if no more blocks to write
Macro: DEC.EQ [Source: macros.inc]
     1 4558 C6 AB				DEC	BCNT
     2 455A F0 2F				BEQ	OS_SAVE_X
Source: boot_sys_os.asm
   432 455C					DEC.EQ  SCNT SAVE_NXT_CLSTR    		; branch if more blocks in cluster to write
Macro: DEC.EQ [Source: macros.inc]
     1 455C C6 AD				DEC	SCNT
     2 455E F0 06				BEQ	SAVE_NXT_CLSTR
Source: boot_sys_os.asm
   433 4560 20 81 41				JSR     INC_32				; Increment LBA block address in NUM32
   434 4563 4C 41 45				JMP	SAVE_NXT_BLK			; branch always
   435 						
   436 				; next cluster needs to be allocated considering the volume FAT type **************
   437 4566			SAVE_NXT_CLSTR	MVAX	4 FREE_CLUSTER PREV_CLUSTER	; PREV_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4566 A2 03			LDX	#4-1
     2 4568 BD 20 18 9D 8E 45 + lp	MVA	FREE_CLUSTER,X PREV_CLUSTER,X-
     3 456F 10 F7			BPL	lp
Source: boot_sys_os.asm
   438 4571 20 A5 47				JSR     OS_ADD_CLUSTER	   		; Find next free cluster in FAT and allocates it (does NOT write FAT back to disk)
   439 4574 20 AA 45				JSR	LINK_FAT_ENTRY			; Link new FREE_CLUSTER to PREV_CLUSTER (does NOT write FAT back to disk)
   440 4577 20 11 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   441 457A EE E8 55				INC	SIS_CNT				; #clusters allocated += 1
   442 457D					LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 457D A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 457F A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   443 4581 20 FC 40		                JSR     CLSTR_TO_BLK	    		; convert FREE_CLUSTER to LBA number in NUM32.
   444 4584 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   445 4589 D0 B6		                BNE     SAVE_NXT_BLK	    		; branch always
   446
   447 458B 4C 7D FD		OS_SAVE_X	JMP	MON2ROM				; Switch back to Monitor ROM and return
   448
   449 458E 00 00 00 00		PREV_CLUSTER	.dword 	$00000000			; Previous cluster nr of file
   450 4592 4C 69 6E 6B 5F 46 + TXT_LINK	.by	'Link_FAT_Entry: ' $00
   451 45A3 20 74 6F 20 00	TXT_LINK2	.by	' to ' $00
   452 45A8 00 00		FSAVE_PTR	.word	$0000				; File-save Pointer
   453
   454 				; ******************************************************************************
   455 				; Links a new cluster (FREE_CLUSTER) to the current cluster (PREV_CLUSTER) of a file.
   456 				; It also updates (writes) the FAT table.
   457 				; ******************************************************************************
   458 45AA			LINK_FAT_ENTRY	PRSTR	TXT_LINK
Macro: PRSTR [Source: macros.inc]
     1 45AA A2 92			LDX	<TXT_LINK				; MADS makes this immediate
     2 45AC A0 45			LDY	>TXT_LINK
Source: boot_sys_os.asm
     2 45AE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   459 45B1					PRHEX32	PREV_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45B1 AD 91 45			LDA	PREV_CLUSTER+2+1				; print MSB
     2 45B4 20 91 E0			JSR	HEXOUT
     3 45B7 AD 90 45			LDA	PREV_CLUSTER+2
     4 45BA 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45BD AD 8F 45			LDA	PREV_CLUSTER+1				; print MSB
     2 45C0 20 91 E0			JSR	HEXOUT
     3 45C3 AD 8E 45			LDA	PREV_CLUSTER
     4 45C6 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   460 45C9					PRSTR	TXT_LINK2
Macro: PRSTR [Source: macros.inc]
     1 45C9 A2 A3			LDX	<TXT_LINK2				; MADS makes this immediate
     2 45CB A0 45			LDY	>TXT_LINK2
Source: boot_sys_os.asm
     2 45CD 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   461 45D0					PRHEX32	FREE_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45D0 AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 45D3 20 91 E0			JSR	HEXOUT
     3 45D6 AD 22 18			LDA	FREE_CLUSTER+2
     4 45D9 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45DC AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 45DF 20 91 E0			JSR	HEXOUT
     3 45E2 AD 20 18			LDA	FREE_CLUSTER
     4 45E5 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   462 45E8 20 5A E0				JSR	CROUT				; Print CR
   463 45EB AD 8E 45				LDA	PREV_CLUSTER			; get LSB of PREV_CLUSTER
   464 45EE 0A 0A			:2	ASL					; SHL2, DWORD index in FAT page
   465 45F0 A8					TAY					; Y = DWORD byte 0 in FAT page
   466 45F1 AD 8F 45				LDA	PREV_CLUSTER+1
   467 45F4 4A					LSR					; check bit 0 of PREV_CLUSTER[1]
   468 45F5 B0 19				BCS	LINK_UPPER_PAGE			; if bit 0 = 1 then write byte to upper half of block
   469 						
   470 						; lower half block of Buffer
   471 45F7 AD 20 18 99 00 06 + 		MWA	FREE_CLUSTER   BLOCK_BUFF,Y	; Write CURR_CLUSTER nr into PREV_CLUSTER FAT entry
   472 4603 AD 22 18 99 02 06 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+2,Y
   473 460F 60					RTS					; return
   474 						
   475 						; upper half block of Buffer
   476 4610 AD 20 18 99 00 07 + LINK_UPPER_PAGE	MWA	FREE_CLUSTER   BLOCK_BUFF+256,Y
   477 461C AD 22 18 99 02 07 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+258,Y
   478 4628 60					RTS					; return
   479
   480 				; ******************************************************************************
   481 4629			INIT_FREE_CLUSTER
   482 4629 A9 02 8D 20 18 A9 + 		MWA	#$02 FREE_CLUSTER		; first data cluster is $000002
   483 4633 8D 22 18				STA     FREE_CLUSTER+2
   484 4636 8D 23 18		                STA     FREE_CLUSTER+3
   485 4639 60			                RTS
   486 				                
   487 				; ******************************************************************************
   488 				; Input: FREE_CLUSTER: number of possible free cluster
   489 				; Output: C=1: CURR_CLUSTER is free ; C=0: 
   490 				; ******************************************************************************
   491 463A			OS_NEXT_FREE_CLUSTER
   492 463A			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 463A A2 03			LDX	#4-1
     2 463C BD 20 18 95 A0 CA	lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 4642 10 F8			BPL	lp
Source: boot_sys_os.asm
   493 4644 20 7E 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   494 4647 A2 03		                LDX     #$03
   495 4649			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: macros.inc]
     1 4649 B5 A0				LDA	CURR_CLUSTER,X
     2 464B D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   496 464D			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: macros.inc]
     1 464D CA					DEX
     2 464E 10 F9				BPL	CHK_FREE
Source: boot_sys_os.asm
   497 4650 38			                SEC                         		; cluster is free, exit with C = 1
   498 4651 60			                RTS
   499
   500 				; ******************************************************************************
   501 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   502 				; ******************************************************************************
   503 4652 A2 00		SET_NEXT_CLSTR  LDX     #$00
   504 4654			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 4654 FE 20 18				INC	FREE_CLUSTER,X
     2 4657 D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   505 4659 E8			                INX						; next byte of FREE_CLUSTER
   506 465A			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 465A E0 04				CPX	#$04
     2 465C D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   507 						
   508 465E A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   509 4660 B5 A4		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   510 4662			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: macros.inc]
     1 4662 DD 18 04				CMP	D_START_FAT2,X			; 
     2 4665 90 D3				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   511 4667			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4667 CA					DEX
     2 4668 10 F6				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   512 466A 18			                CLC                         			; no emtpy cluster found, exit with error
   513 466B 60			                RTS
   514
   515 				; ******************************************************************************
   516 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   517 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   518 				; BLOCK_BUFF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   519 				; in FREE_CLUSTER needs to be allocated in the FAT table.
   520 				; ******************************************************************************
   521 466C			UPDATE_FAT_TABLE
   522 466C					PRCH	'['			; Print [
Macro: PRCH [Source: macros.inc]
     1 466C A9 5B			LDA	#'['
     2 466E 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   523 4671					PRHEX16	FREE_CLUSTER		; Print FREE_CLUSTER
Macro: PRHEX16 [Source: macros.inc]
     1 4671 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4674 20 91 E0			JSR	HEXOUT
     3 4677 AD 20 18			LDA	FREE_CLUSTER
     4 467A 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   524 467D					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 467D A9 5D			LDA	#']'
     2 467F 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   525 4682 AD 20 18				LDA	FREE_CLUSTER		; get LSB of cluster nr
   526 4685 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   527 4687 A8					TAY				; Y = DWORD byte 0 in FAT page
   528 					.rept 3					; Write 3 x $FF into FAT entry
   529 						LDA	#$FF			
   530 						JSR	WRITE_ENTRY_BYTE	
   531 						INY				
   532 					.endr	
Source: REPT
   529 4688 A9 FF				LDA	#$FF			
   529 468A 20 9F 46				JSR	WRITE_ENTRY_BYTE	
   529 468D C8					INY				
   529 468E A9 FF				LDA	#$FF			
   529 4690 20 9F 46				JSR	WRITE_ENTRY_BYTE	
   529 4693 C8					INY				
   529 4694 A9 FF				LDA	#$FF			
   529 4696 20 9F 46				JSR	WRITE_ENTRY_BYTE	
   529 4699 C8					INY				
Source: boot_sys_os.asm
   533 469A A9 0F				LDA	#$0F			; write end marker
   534 469C 4C 9F 46				JMP	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   535 						
   536 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   537 				; INPUT : A = Write Data
   538 				;         Y - Index To FAT Entry Byte
   539 				; ******************************************************************************
   540 469F			WRITE_ENTRY_BYTE
   541 469F AA					TAX
   542 46A0 AD 21 18		                LDA     FREE_CLUSTER+1
   543 46A3 4A			                LSR				; check bit 0 of free_cluster[1]
   544 46A4 8A			                TXA
   545 46A5 B0 04		                BCS     WR_UPPER_PAGE       	; if bit 0 = 1 then write byte to upper half of block
   546 						
   547 46A7 99 00 06		                STA     BLOCK_BUFF,Y		; write entry byte to lower half of block buffer
   548 46AA 60					RTS				
   549 						
   550 46AB 99 00 07		WR_UPPER_PAGE   STA     BLOCK_BUFF+256,Y	; write entry byte to upper half of block buffer
   551 46AE 60					RTS
   552 				                
   553 				; **** Add Date and Time to subdir entry ***************************************
   554 				; ******************************************************************************
   555 46AF			ADD_DATE_TIME	; Write create-Date and Last-write Date
   556 46AF 20 B9 43				JSR     OS_FILEDATE         	; get current date as file date
   557 46B2 98			                TYA				; Y = MSB
   558 46B3 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   559 46B5 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   560 46B7 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   561 46B9 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   562 46BC 8A			                TXA				; X = LSB
   563 46BD 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   564 46BF A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   565 46C1 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   566
   567 						; Write create-Time and last-write Time
   568 46C3 20 94 43		                JSR     OS_FILETIME         	; get current time as file time
   569 46C6 98			                TYA				; Y = MSB
   570 46C7 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   571 46C9 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   572 46CB A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   573 46CD 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   574 46D0 8A			                TXA				; X = LSB
   575 46D1 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   576 46D3 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   577 46D5 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   578 46D7 60					RTS
   579 						
   580 				; **** Add new subdirectory entry to dir buffer ********************************
   581 				; Input: X=1: . subdir, X=2: .. subdir
   582 				; ******************************************************************************
   583 46D8 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   584 46D9 48					PHA					; save it
   585 46DA A0 00				LDY	#D_FILENAME			; Filename entry
   586 46DC A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   587 46E1			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: macros.inc]
     1 46E1 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 46E3 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   588
   589 46E5 A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   590 46E9 A0 00				LDY	#D_FILENAME			; Filename entry
   591 46EB A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   592 46ED 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   593 46F0					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: macros.inc]
     1 46F0 CA					DEX
     2 46F1 D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   594
   595 46F3 20 AF 46				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   596 46F6 68					PLA
   597 46F7					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: macros.inc]
     1 46F7 C9 01				CMP	#1
     2 46F9 D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   598 					
   599 						; Current subdir .: Write File Cluster Nr High and Low
   600 46FB A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   601 46FD AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   602 4703 AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   603 4708 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   604 470A AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   605 4710 AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   606 4715 60					RTS					; return
   607 						
   608 						; Parent subdir ..: Write File Cluster Nr High and Low
   609 4716 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   610 4718 AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   611 471E AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   612 4723 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   613 4725 AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   614 472B AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   615 4730 60					RTS
   616 						
   617 				; **** Add new Directory Cluster to Disk ***************************************
   618 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   619 				; ******************************************************************************
   620 4731			ADD_NEW_DIR_CLST
   621 4731 A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   622 4739 A2 01				LDX	#1
   623 473B A9 00				LDA	#0
   624 473D			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: macros.inc]
     1 473D 91 DC C8				STA	(BLKBUF),Y+
     2 4740 D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   625 4742 E6 DD				INC	BLKBUF+1		; next page
   626 4744					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: macros.inc]
     1 4744 CA					DEX
     2 4745 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   627 						
   628 4747 A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   629 474B A2 01				LDX	#1			; 1 = . subdir entry
   630 474D 20 D8 46				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   631 4750 A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   632 4757 A2 02				LDX	#2			; 2 = .. subdir entry
   633 4759 20 D8 46				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   634
   635 						; and write it to disk
   636 				.if	DBG_PRINT = 1
   637 475C					PRSTR	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTR [Source: macros.inc]
     1 475C A2 8C			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 475E A0 47			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 4760 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   638 4763					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: macros.inc]
     1 4763 AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 4766 20 91 E0			JSR	HEXOUT
     3 4769 AD 22 18			LDA	FREE_CLUSTER+2
     4 476C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 476F AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4772 20 91 E0			JSR	HEXOUT
     3 4775 AD 20 18			LDA	FREE_CLUSTER
     4 4778 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   639 477B 20 5A E0				JSR	CROUT			; Print CR
   640 				.endif
   641 477E					LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: macros.inc]
     1 477E A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4780 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   642 4782 20 FC 40				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   643 4785					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: macros.inc]
     1 4785 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4787 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   644 4789 4C FE 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   645 						
   646 478C 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   647
   648 				; **** Add First Cluster To Empty File *****************************************
   649 				; Note: does NOT write FAT table back to disk, only FAT table in memory is updated.
   650 				; ******************************************************************************
   651 47A5 20 29 46		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   652 47A8 20 3A 46				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   653 47AB 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   654 						
   655 47AD 20 6C 46		                JSR     UPDATE_FAT_TABLE	; Allocate FREE_CLUSTER, does NOT write FAT block back to disk
   656 47B0 60			ADD_CLUSTER_END RTS
   657
   658 				; **** Create New File *********************************************************
   659 				; Input:  A = File Attributes
   660 				; Output: C = 0 - Error; C = 1 - No Error
   661 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   662 				; ******************************************************************************
   663 47B1 8D 12 18		OS_CREATE       STA     F_ATTRIBS           		; save attributes
   664 47B4			                AND.EQ  #FA_DIRECTORY ADD_FILE 		; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: macros.inc]
     6 47B4 29 10				AND	#FA_DIRECTORY
     7 47B6 F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   665 						
   666 						; Find directory
   667 47B8 20 5B 48		                JSR     OS_DIR_EXISTS       		; C=1: dirname already exists
   668 47BB 90 21				BCC	OS_CREATE_CONT			; branch if dirname does not exist yet
   669 47BD B0 4E				BCS	OS_CREATE_ERR			; branch on error
   670
   671 						; Find file
   672 47BF 20 61 48		ADD_FILE        JSR     OS_FILE_EXISTS      		; check if file already exists
   673 47C2 90 1A				BCC	OS_CREATE_CONT			; branch if file does not exist
   674 						
   675 						; delete file (SH_DEL)	
   676 47C4					PRSTR	TXT_OVERWRITE			; Print 'File exists, overwrite (y/n)?'
Macro: PRSTR [Source: macros.inc]
     1 47C4 A2 0F			LDX	<TXT_OVERWRITE				; MADS makes this immediate
     2 47C6 A0 48			LDY	>TXT_OVERWRITE
Source: boot_sys_os.asm
     2 47C8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   677 47CB 20 47 E0				JSR 	CIN           			; get character
   678 47CE 29 DF				AND 	#$DF            		; uppercase chars only
   679 47D0					CMP.NE 	#'Y' OS_CREATE_ERR    		; if not Y then exit with error
Macro: CMP.NE [Source: macros.inc]
     1 47D0 C9 59				CMP	#'Y'
     2 47D2 D0 39				BNE	OS_CREATE_ERR
Source: boot_sys_os.asm
   680 47D4					PRSTR	TXT_SH_DEL			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47D4 A2 3E			LDX	<TXT_SH_DEL				; MADS makes this immediate
     2 47D6 A0 48			LDY	>TXT_SH_DEL
Source: boot_sys_os.asm
     2 47D8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   681 47DB 20 B3 53				JSR	SH_DEL_FILE			; Delete file and update FAT table
   682
   683 47DE 20 A5 47		OS_CREATE_CONT	JSR	OS_ADD_CLUSTER			; Return free cluster in FREE_CLUSTER (does NOT write FAT back to disk)
   684 47E1 20 11 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   685 						; Find a Free dir. entry and fill it with file info and save it to disk
   686 47E4 20 55 48				JSR 	OS_FIND_FREE			; Find a free directory entry in the current directory
   687 				.if	DBG_PRINT = 1
   688 47E7					PRSTR	TXT_FFREE1			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47E7 A2 2D			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 47E9 A0 48			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 47EB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   689 47EE					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 47EE A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 47F0 20 91 E0			JSR	HEXOUT
     3 47F3 A5 A8			LDA	CURR_DIR_ENTRY
     4 47F5 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   690 47F8 20 5A E0				JSR	CROUT				; Print CR
   691 				.endif
   692 47FB AD 12 18		                LDA     F_ATTRIBS			; Get file/dir attributes
   693 47FE 20 18 43				JSR	OS_CREATE_FILE			; create the file/dir on disk
   694 4801 AD 12 18				LDA     F_ATTRIBS			; Get file/dir attributes again
   695 4804					AND.EQ  #FA_DIRECTORY OS_CREATE_X	; create a file? Branch if it is a file
Macro: AND.EQ [Source: macros.inc]
     6 4804 29 10				AND	#FA_DIRECTORY
     7 4806 F0 03				BEQ	OS_CREATE_X
Source: boot_sys_os.asm
   696 						
   697 4808 20 31 47				JSR	ADD_NEW_DIR_CLST		; Add new dir cluster with . and .. and save it to disk
   698 480B 38			OS_CREATE_X	SEC					; C=1, OK
   699 480C 60			                RTS					; and return
   700 480D 18			OS_CREATE_ERR   CLC					; C=0, error
   701 480E 60			OS_CREATE_END   RTS					; return
   702 				                
   703 480F 46 69 6C 65 20 65 + TXT_OVERWRITE	.by	'File exists, overwrite (y/n)?' $00
   704 482D 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   705 483E 53 48 5F 44 45 4C + TXT_SH_DEL	.by	'SH_DEL' CR $00
   706
   707 				; **** Test If File Is Empty ************** ************************************
   708 				; Input:  Ptr(CURR_DIR_ENTRY)
   709 				; Output: C = 1 - File is empty; C = 0 - File not empty
   710 				; ******************************************************************************
   711 4846 A2 04		OS_FILE_EMPTY   LDX     #$04
   712 4848 A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   713 484A 18			                CLC
   714 484B			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: macros.inc]
     1 484B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 484D D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   715 484F C8			                INY
   716 4850			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: macros.inc]
     1 4850 CA					DEX
     2 4851 D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   717 4853 38			                SEC			    			; C=1: File is empty
   718 4854 60			OS_FILE_EMPTY2  RTS			    			; return
   719
   720 				; **** Check If a directory entry is free or deleted ***************************
   721 				; ******************************************************************************
   722 4855			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: macros.inc]
     1 4855 A2 16			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 4857 A0 4B			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   723 4859 D0 1A		                BNE     OS_FIND			; branch always
   724
   725 				; **** Check If Directory Already Exists ***************************************
   726 				; ******************************************************************************
   727 485B			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 485B A2 CA			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 485D A0 4A			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   728 485F D0 14		                BNE     OS_FIND			; branch always
   729 				                
   730 				; **** Check If Directory Is Available *****************************************
   731 				; ******************************************************************************
   732 4861			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 4861 A2 EE			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 4863 A0 4A			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   733 4865 D0 0E		                BNE     OS_FIND			; branch always
   734
   735 				; **** Find Directory **********************************************************
   736 				; ******************************************************************************
   737 4867			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 4867 A2 CD			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 4869 A0 4A			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   738 486B D0 08		                BNE     OS_FIND			; branch always
   739
   740 				; **** Find File ***************************************************************
   741 				; ******************************************************************************
   742 486D			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: macros.inc]
     1 486D A2 F1			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 486F A0 4A			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   743 				                                           ; fall through to OS_FIND
   744 				                                           
   745 				; **** Find All Files **********************************************************
   746 				; ******************************************************************************
   747 4871 A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   748 4873 D0 02		                BNE     OS_FIND2
   749
   750 				; **** Main Find Routine *******************************************************
   751 				; ******************************************************************************
   752 4875 A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   753 4877			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: macros.inc]
     1 4877 8E 34 4B			STX	CMD_ADDR
     2 487A 8C 35 4B			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   754 				                                            ; fall through to OS_DIR_LOOP
   755
   756 				; **** Loop Through Actual Directory *******************************************
   757 				; Input:  Ptr[X:Y] = Address to command specific function
   758 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   759 				; Output: C = 1 - Found; C = 0 - Not Found
   760 				; ******************************************************************************
   761 487D 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   762 4880 A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   763 4888 20 A7 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   764 488B			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 488B A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 488D A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   765 488F			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: macros.inc]
     1 488F 86 A8			STX	CURR_DIR_ENTRY
     2 4891 84 A9			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   766 4893 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   767 4895 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   768 4897 AA			                TAX                         			; load attributes into X
   769 4898 A0 00		                LDY     #D_FILENAME         			; index to filename
   770 489A			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: macros.inc]
     1 489A B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 489C F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   771 489E 20 CA 4B		                JSR     CMD_EXECUTE         			; call command routine
   772 48A1 B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   773 						
   774 48A3			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: macros.inc]
     1 48A3 AD 13 18				LDA	TERM_FLAG
     2 48A6 D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   775 48A8 EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   776 48B0 A5 A8 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   777 48B7 90 DA		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   778 						
   779 48B9 A9 00		                LDA     #$00
   780 48BB 65 A9 85 A9		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   781 48BF			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: macros.inc]
     1 48BF C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 48C1 D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   782
   783 48C3			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: macros.inc]
     1 48C3 CE 1D 18				DEC	CURR_BLK_NUM
     2 48C6 D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   784 48C8			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 48C8 AD 0A 04				LDA	D_FAT_TYPE
     2 48CB F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   785 48CD 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   786 48CF B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   787
   788 48D1 20 F8 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   ; load next directory cluster from device
   789 48D4 90 B5		                BCC     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   790 48D6 B0 0D		                BCS     OS_DIR_LOOP_EOF     ; directory EOF reached. Exit
   791
   792 48D8 20 EA 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     ; load next directory block from device
   793 48DB 4C 8B 48		                JMP     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   794
   795 48DE			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        ; set pointer to upper page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 48DE A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 48E0 A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   796 48E2 4C 8F 48		                JMP     SET_CURR_ENTRY	    ; branch to begin of loop
   797
   798 48E5 18			OS_DIR_LOOP_EOF CLC			    ; C=1: not found
   799 48E6 60			OS_DIR_LOOP_END RTS			    ; return
   800
   801 				; **** Set Drive Command *******************************************************
   802 				; Input:  A = Drive Number (0..25)
   803 				; Output: C = 0 - Error
   804 				; ******************************************************************************
   805 48E7			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: macros.inc]
     1 48E7 CD 1E 18				CMP	CURR_DRIVE
     2 48EA F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   806 48EC			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: macros.inc]
     1 48EC C9 08				CMP	#$08			; 
     2 48EE B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   807 48F0 AA			                TAX                         		; save actual drive number to Y
   808 48F1 AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   809 48F4 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   810 48F9 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   811 48FB A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   812 48FF					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: macros.inc]
     1 48FF A0 1F			LDY	#$20-1
     2 4901 B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 4907 10 F8			BPL	lp
Source: boot_sys_os.asm
   813 4909 8A			                TXA
   814 490A 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   815 490F 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   816 4911 A0 08		                LDY     #$08                		; set index to D_DEV_ID
   817 4913			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: macros.inc]
     1 4913 B1 E8				LDA	(STOL),Y
     2 4915 F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   818
   819 4917					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: macros.inc]
     1 4917 A0 1F			LDY	#$20-1
     2 4919 B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 491F 10 F8			BPL	lp
Source: boot_sys_os.asm
   820 4921 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   821 4924 AD 08 04		                LDA     D_DEV_ID            	; get current device id
   822 4927 20 AA E1		                JSR     OPEN_DEVICE         	; and open the device driver
   823 492A 38			SET_DRIVE_END   SEC			    	; C=1: no error
   824 492B 60			                RTS
   825
   826 492C			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: macros.inc]
     1 492C A2 AC			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 492E A0 56			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   827 4930 4C C8 49		                JMP     OS_PRINT_ERR	    	; Print 'Drive not found'
   828
   829 				; **** Test If Root Directory **************************************************
   830 				; Input:
   831 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   832 				; ******************************************************************************
   833 4933 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   834 4935 B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   835 4938			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: macros.inc]
     1 4938 D9 1C 04				CMP	D_START_DIR,Y
     2 493B D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   836 493D			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: macros.inc]
     1 493D 88					DEY
     2 493E 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   837 						
   838 4940 38			                SEC			     		; C=1 => is root dir.
   839 4941 60			                RTS
   840 4942 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   841 4943 60			                RTS
   842
   843 				; **** Set Root Directory Command **********************************************
   844 				; ******************************************************************************
   845 4944 A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   846 4946 BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   847 494C 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   848 4950 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   849 						
   850 4952 A9 5C 8D 20 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   851 495C 60					RTS					; return
   852
   853 				; **** Set Directory Command ***************************************************
   854 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   855 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   856 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   857 				; considered to be the root-dir and cluster number is set to 2.
   858 				; ******************************************************************************
   859 495D			OS_SET_DIR      PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 495D A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 495F 20 91 E0			JSR	HEXOUT
     3 4962 A5 A8			LDA	CURR_DIR_ENTRY
     4 4964 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   860 4967					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 4967 A9 2C			LDA	#','
     2 4969 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   861 496C					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: macros.inc]
     1 496C A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 496E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4970 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4973 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4975 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4977 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   862 497A					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: macros.inc]
     1 497A A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 497C B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 497E 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4981 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4983 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4985 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   863 4988					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4988 A9 5D			LDA	#']'
     2 498A 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   864 498D A0 15				LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   865 498F A2 04		                LDX     #$04				; Copy 4 bytes
   866 4991 8E B6 49				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   867 4994 CA					DEX					; Copy bytes 3..0
   868 4995 20 A3 49				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   869 4998 A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   870 499A 20 A3 49				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   871 499D					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: macros.inc]
     1 499D AD B6 49				LDA	OS_DWORD0
     2 49A0 F0 A2				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   872 49A2 60			                RTS			     		; return
   873 				                
   874 				;-------------------------------------------------------------------------------------------------
   875 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   876 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   877 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   878 				;-------------------------------------------------------------------------------------------------
   879 49A3 20 A6 49		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   880 49A6 B1 A8 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   881 49AB					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: macros.inc]
     1 49AB 9D 24 18				STA	CURR_DIR_BLK,X
     2 49AE D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   882 49B0 CE B6 49				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   883 49B3 88			SET_BYTE_NOT0	DEY				
   884 49B4 CA					DEX
   885 49B5 60					RTS				; return
   886 49B6 00			OS_DWORD0	.byte	$00
   887
   888 				; **** Read Input String *******************************************************
   889 				; Output: Null terminated string in STRBUF
   890 				; ******************************************************************************
   891 49B7 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   892 49BA A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   893 49C2 A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   894 49C7 60			                RTS
   895
   896 				; **** Print Error Message *****************************************************
   897 				; Input:  Ptr[X:Y] = Pointer to Error Message
   898 				; Output: C = 0
   899 				; ******************************************************************************
   900 49C8 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   901 49CB 18			                CLC
   902 49CC 60			                RTS
   903 				                
   904 				; **** Parse Full Path String **************************************************
   905 				; Input:  Ptr[X:Y] to Path String
   906 				; Output: C = 0 - Error; C = 1 - No Error
   907 				;         A = $00       - End Of String
   908 				;           = $FF       - Path Not Found
   909 				;           = ?         - Wildcard Included
   910 				;           = PATH_SEP  - No Trailing Name
   911 				; ******************************************************************************
   912 49CD			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: macros.inc]
     1 49CD 86 EA			STX	PSTR
     2 49CF 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   913 49D1 A0 00		                LDY     #$00
   914 49D3 8C 11 18		                STY     TERM_CHAR
   915 49D6 A9 5C		                LDA     #PATH_SEP
   916 49D8			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: macros.inc]
     1 49D8 D1 EA				CMP	(PSTR),Y
     2 49DA D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   917 49DC 20 44 49		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   918 49DF A0 00		                LDY     #$00
   919 49E1 C8			PARSE_PATH      INY
   920 49E2			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: macros.inc]
     1 49E2 B1 EA				LDA	(PSTR),Y
     2 49E4 F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   921 49E6			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: macros.inc]
     1 49E6 C9 20				CMP	#SPC
     2 49E8 F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   922 						
   923 49EA 20 14 4A		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   924 49ED 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   925 						
   926 49EF			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: macros.inc]
     1 49EF C9 5C				CMP	#PATH_SEP
     2 49F1 D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   927 49F3 84 EE		                STY     PSAV                ; save string index
   928 49F5 20 67 48		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   929 49F8 A4 EE		                LDY     PSAV                ; restore string index
   930 49FA 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   931 49FC B0 E3		                BCS     PARSE_PATH          ; branch always
   932 				                
   933 49FE 18			PARSE_TERM      CLC
   934 49FF			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: macros.inc]
     1 49FF AD 11 18				LDA	TERM_CHAR
     2 4A02 D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   935 4A04 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   936 4A09 D0 04		                BNE     PARSE_PATH_OK			; branch always
   937 				                
   938 4A0B			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: macros.inc]
     1 4A0B A9 FF				LDA	#$FF
     2 4A0D D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   939 4A0F 38			PARSE_PATH_OK   SEC
   940 4A10 AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   941 4A13 60			PARSE_PATH_END2 RTS
   942
   943 				; **** Parse A Partial Path Name String ****************************************
   944 				; Input:  A = First Char Of Partial Path
   945 				;         Y = Index Into Path String
   946 				; Output: C = 0 - Error; C = 1 - No Error
   947 				;         TERM_CHAR = NULL      - Filename
   948 				;                   = ?         - Wildcard Chars Included
   949 				;                   = PATH_SEP  - Subdirectory Name
   950 				; ******************************************************************************
   951 4A14 A2 08		OS_PARSE_NAME   LDX     #8
   952 4A16 86 AB		                STX     BCNT                	; set max char count to 8
   953 4A18 A2 00		                LDX     #$00                	; reset index to name string buffer
   954 4A1A 8E 11 18		                STX     TERM_CHAR
   955 4A1D			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A1D C9 2E				CMP	#DOT
     2 4A1F D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   956 4A21 9D 9D 4B E8		                STA     FILENAME,X+         	; yes, store it
   957 4A25 C8			                INY
   958 4A26 B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   959 4A28			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A28 C9 2E				CMP	#DOT
     2 4A2A D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   960 4A2C 9D 9D 4B		SET_CHAR        STA     FILENAME,X          	; yes, store it
   961 4A2F E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   962 4A30 C8			NEXT_CHAR2      INY                         	; point to next char of input string
   963 4A31			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: macros.inc]
     1 4A31 B1 EA				LDA	(PSTR),Y
     2 4A33 F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   964 4A35			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: macros.inc]
     1 4A35 C9 20				CMP	#SPC
     2 4A37 F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   965 4A39			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: macros.inc]
     1 4A39 C9 5C				CMP	#PATH_SEP
     2 4A3B F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   966 4A3D			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: macros.inc]
     1 4A3D C9 2E				CMP	#DOT
     2 4A3F F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   967 4A41			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: macros.inc]
     1 4A41 C9 2A				CMP	#'*'
     2 4A43 F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   968
   969 4A45			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: macros.inc]
     1 4A45 E4 AB				CPX	BCNT			; 
     2 4A47 B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   970 4A49 20 65 4C		                JSR     UPPERCASE           	; convert chars to upper case
   971 4A4C			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: macros.inc]
     1 4A4C C9 3F				CMP	#'?'
     2 4A4E D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   972 4A50 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   973 4A53 F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   974
   975 4A55			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A55 C9 2D				CMP	#MINUS
     2 4A57 F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   976 4A59			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A59 C9 5F				CMP	#ULINE
     2 4A5B F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   977 4A5D					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A5D C9 7E				CMP	#'~'
     2 4A5F F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   978 4A61					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A61 C9 30				CMP	#'0'			; 
     2 4A63 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   979 4A65			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A65 C9 3A				CMP	#':'			; 
     2 4A67 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   980 4A69			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A69 C9 41				CMP	#'A'			; 
     2 4A6B 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   981 4A6D			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A6D C9 5B				CMP	#'['			; 
     2 4A6F 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   982
   983 4A71 A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   984 4A76 20 8D 4A		                JSR     FILL_CHAR           ; fill with ? chars
   985 4A79 B0 B5		                BCS     NEXT_CHAR2          ; branch always
   986
   987 4A7B 20 8B 4A		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
   988 4A7E A9 0B 85 AB		                MVA     #11 BCNT            ; set max char count to 11
   989 4A82 B0 AC		                BCS     NEXT_CHAR2          ; branch always
   990
   991 4A84 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
   992 4A87 A9 0B 85 AB		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
   993 4A8B A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
   994 4A8D			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: macros.inc]
     1 4A8D E4 AB				CPX	BCNT			; 
     2 4A8F B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   995 4A91 9D 9D 4B E8		                STA     FILENAME,X+         ; no, store char in name buffer
   996 4A95 90 F6		                BCC     FILL_CHAR           ; and repeat
   997
   998 4A97 AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
   999 4A9A 60			                RTS
  1000 				                
  1001 				; **** Compare File Name With Mask *********************************************
  1002 				; Output: C = 0 - Names not equal; C = 1 - Names equal
  1003 				; ******************************************************************************
  1004 4A9B A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
  1005 4A9D B9 9D 4B		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
  1006 4AA0			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: macros.inc]
     1 4AA0 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4AA2 D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1007 4AA4			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: macros.inc]
     1 4AA4 88					DEY
     2 4AA5 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
  1008 						
  1009 4AA7 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
  1010 4AA8 60			                RTS
  1011 4AA9 18			COMPARE_NEQ     CLC					; C=0, filename is different
  1012 4AAA 60			                RTS
  1013 				                
  1014 				; **** Delete File *************************************************************
  1015 				; Input : A - First character of filename
  1016 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
  1017 				; ******************************************************************************
  1018 4AAB			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: macros.inc]
     1 4AAB C9 E5				CMP	#$E5
     2 4AAD D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1019 4AAF AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
  1020 4AB2 D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
  1021
  1022 4AB4 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
  1023 4AB7					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: macros.inc]
     1 4AB7 A0 05			LDY	#6-1
     2 4AB9 B9 24 18 99 C4 4A + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4AC0 10 F7			BPL	lp
Source: boot_sys_os.asm
  1024 4AC2 38			                SEC
  1025 4AC3 60			                RTS
  1026 				                
  1027 4AC4 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
  1028 4AC8 00 00		SEL_DIR_ENTRY   .byte $00, $00
  1029 				                
  1030 				; **** Directory Loop Call Back Functions **************************************
  1031 				; Input : A - First character of filename
  1032 				;         X - File Attributes
  1033 				; Output: C = 1 - File found; C = 0 - File not found
  1034 				; ******************************************************************************
  1035
  1036 				; **** Directory Exists - Call Back Routine ************************************
  1037 4ACA 20 AB 4A		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
  1038
  1039 				; **** Find Sub Directory Name - Call Back Routine *****************************
  1040 4ACD			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4ACD E0 0F				CPX	#$0F
     2 4ACF F0 43				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1041 4AD1 AD 9D 4B		                LDA     FILENAME            	; do we search for the . directory?
  1042 4AD4			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: macros.inc]
     1 4AD4 C9 2E				CMP	#DOT
     2 4AD6 D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
  1043 						
  1044 4AD8 AD 9E 4B		                LDA     FILENAME+1		; get next byte
  1045 4ADB			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: macros.inc]
     1 4ADB C9 20				CMP	#SPC
     2 4ADD F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
  1046 						
  1047 4ADF 8A			FIND_SUBDIR     TXA
  1048 4AE0			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: macros.inc]
     6 4AE0 29 10				AND	#FA_DIRECTORY
     7 4AE2 F0 30				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1049 4AE4 20 9B 4A		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
  1050 4AE7 90 2C		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
  1051
  1052 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
  1053 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
  1054 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
  1055 						;    with $1C & $1D not being cluster nr bytes.
  1056 4AE9 20 5D 49		                JSR     OS_SET_DIR          	; make this directory the actual directory
  1057 4AEC 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
  1058 4AED 60			                RTS				; return
  1059 				                
  1060 				; **** File Exists - Call Back Routine *****************************************
  1061 4AEE 20 AB 4A		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
  1062
  1063 				; **** Find File Name - Call Back Routine **************************************
  1064 4AF1			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4AF1 E0 0F				CPX	#$0F
     2 4AF3 F0 1F				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1065 4AF5 8A			                TXA
  1066 4AF6			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: macros.inc]
     6 4AF6 29 10				AND	#FA_DIRECTORY
     7 4AF8 D0 1A				BNE	CB_FIND_END
Source: boot_sys_os.asm
  1067 4AFA 20 9B 4A		                JSR     OS_COMP_NAME        			; compare name with search mask
  1068 4AFD 90 16		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
  1069 						
  1070 4AFF A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
  1071 4B01 A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
  1072 4B03 B1 A8 C8 95 A0 E8	GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
  1073 4B09			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B09 E0 02				CPX	#$02			; 
     2 4B0B 90 F6				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1074 4B0D A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
  1075 4B0F			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B0F E0 04				CPX	#$04			; 
     2 4B11 90 F0				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1076 4B13 60			                RTS                         			; yes, file found
  1077
  1078 4B14 18			CB_FIND_END     CLC                         			; file not found
  1079 4B15 60			CB_FIND_END2    RTS
  1080 				                
  1081 				; **** Find Free or Deleted Dir. Entry **************************************
  1082 4B16			CB_FIND_FREE_DIR_ENTRY
  1083 4B16 A0 00				LDY	#D_FILENAME			; set index to filename
  1084 4B18 B1 A8				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
  1085 4B1A					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: macros.inc]
     1 4B1A C9 E5				CMP	#$E5
     2 4B1C F0 09				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1086 4B1E			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: macros.inc]
     1 4B1E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4B20 D0 10				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1087 4B22 C8					INY
  1088 4B23			                CPY.CC  #D_ATTRIBUTES FFD_LP1  		; branch if not all characters copied
Macro: CPY.CC [Source: macros.inc]
     1 4B23 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4B25 90 F7				BCC	FFD_LP1			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
  1089 4B27 A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1090 4B29 91 A8 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1091 4B2C					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: macros.inc]
     1 4B2C C0 20				CPY	#$20
     2 4B2E D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1092 						
  1093 4B30 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1094 4B31 60			                RTS                         		; return
  1095 4B32 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1096 4B33 60					RTS					; return
  1097
  1098 				; **** Data Area ***************************************************************
  1099 				; ******************************************************************************
  1100
  1101 				; Indirect Jump Pointer Of Current Command Address *****************************
  1102 4B34 00 00		CMD_ADDR        .word      $0000
  1103 				                
  1104 				; String Data Area *************************************************************
  1105 4B36 0D 20 57 65 6C 63 + MSG_BOOT        .by    CR ' Welcome to DOS65 for the JC2, V'
  1106 4B57 30 2E 32 2E 38	                .byte  VERMAIN,DOT,VERPSUB,DOT,VERSSUB
  1107 4B5C 2C 20 32 30 32 35 +                 .by    ', 2025 by Emile' CR
  1108 4B6C 20 4F 72 69 67 69 + 		.by    ' Original design by Joerg Walke' CR CR $00
  1109 4B8E 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1110 = 4B9D			FILENAME        .ds 	12
    87 4BA9					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; Main Loop Of Command Interpreter *********************************************
    10 				; ******************************************************************************
    11 4BA9 A9 63 8D 34 4B A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    12 4BB3 20 A1 4C		                JSR     PRINT_PROMPT
    13 4BB6 20 B7 49		                JSR  	OS_STRING_IN         ; read input string
    14 4BB9 20 CD 4B				JSR     GET_CMD              ; parse string
    15 4BBC 90 06				BCC     CMD_EXTERNAL
    16 						
    17 4BBE 20 CA 4B		                JSR     CMD_EXECUTE          ; execute internal command
    18 4BC1 4C A9 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    19 						
    20 4BC4 20 71 54		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    21 4BC7 4C A9 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    22 						
    23 4BCA 6C 34 4B		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    24 						
    25 				; Get Command String ***********************************************************
    26 4BCD 20 ED 4E		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    27 4BD0 D0 03		                BNE     GET_CMD0
    28
    29 4BD2 4C 63 4C		                JMP     CMD_FOUND            ; empty command if first char is NULL
    30
    31 4BD5 20 65 4C		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    32 4BD8 AA			                TAX
    33 4BD9 A0 00		                LDY     #$00
    34 4BDB 8A			GET_CMD1        TXA                          	; try to find command in command table
    35 4BDC					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4BDC D9 76 57				CMP	CHARS,Y
     2 4BDF F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    36 4BE1			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4BE1 B9 76 57				LDA	CHARS,Y
     2 4BE4 F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    37 4BE6 8A			                TXA
    38 4BE7 C8 C8 C8		        :3      INY			     	; Y += 3
    39 4BEA 4C DB 4B		                JMP     GET_CMD1	     	; branch always
    40
    41 4BED C8			GET_CMD2        INY
    42 4BEE B9 76 57 C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    43 4BF4 B9 76 57 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    44 4BF9 A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    45 4BFE A6 AC		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    46 4C00			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: macros.inc]
     1 4C00 B1 E8				LDA	(STOL),Y
     2 4C02 F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    47 4C04 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    48 4C0B E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    49 4C0C C8			                INY                          	; point to next char in command table
    50 4C0D			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: macros.inc]
     1 4C0D CC 10 18				CPY	NEXTINDEX
     2 4C10 F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    51
    52 4C12 BD 00 14		                LDA     STRBUF,X             	; load char from command string
    53 4C15 20 65 4C		                JSR     UPPERCASE	     	; and convert it to uppercase
    54 4C18					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4C18 D1 E8				CMP	(STOL),Y
     2 4C1A F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    55
    56 4C1C AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    57 4C1F C8 C8		        :2      INY			     	; Y += 2
    58 4C21 8C 10 18		                STY     NEXTINDEX
    59 4C24 4C FE 4B		                JMP     GET_CMD_LOOP1	     	; branch always
    60
    61 4C27 B1 E8 8D 34 4B C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    62 4C32			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4C32 BD 00 14				LDA	STRBUF,X
     2 4C35 F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    63 4C37			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: macros.inc]
     1 4C37 C9 20				CMP	#SPC
     2 4C39 F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    64 4C3B 18			CMD_NOT_FOUND   CLC
    65 4C3C 60			                RTS
    66 				                
    67 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    68 4C3D A6 AC		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    69 4C3F BD 00 14		                LDA     STRBUF,X
    70 4C42 20 65 4C		                JSR     UPPERCASE            ; convert it to upper case
    71 4C45			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: macros.inc]
     1 4C45 C9 41				CMP	#'A'			; 
     2 4C47 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    72 4C49			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: macros.inc]
     1 4C49 C9 5B				CMP	#'['			; 
     2 4C4B B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    73
    74 4C4D A8			                TAY
    75 4C4E BD 01 14		                LDA     STRBUF+1,X
    76 4C51			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: macros.inc]
     1 4C51 C9 3A				CMP	#':'
     2 4C53 D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    77 4C55 38			                SEC
    78 4C56 98			                TYA
    79 4C57 E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    80 4C59			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: macros.inc]
     1 4C59 A2 E7			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4C5B A0 48			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    81 4C5D			                STXY    CMD_ADDR
Macro: STXY [Source: macros.inc]
     1 4C5D 8E 34 4B			STX	CMD_ADDR
     2 4C60 8C 35 4B			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    82 4C63 38			CMD_FOUND       SEC
    83 4C64 60			                RTS
    84 				                
    85 				; **** Return Uppercase Character **********************************************
    86 				; Input:  A - Character
    87 				; Output: A - Uppercase Character
    88 				; ******************************************************************************
    89 4C65			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: macros.inc]
     1 4C65 C9 61				CMP	#'a'			; 
     2 4C67 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    90 4C69			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: macros.inc]
     1 4C69 C9 7B				CMP	#'z'+1			; 
     2 4C6B B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    91 4C6D 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    92 4C6F 60			UPPERCASE_END   RTS				; return
    93
    94 				; **** Print Two Digit Number **************************************************
    95 				; Input: A - Number (0..99)
    96 				; ******************************************************************************
    97 4C70 20 BD E0		NUMOUT          JSR     DEC2STR			; Converts into DIG0, DIG1 and DIG2
    98 4C73 A2 01		                LDX     #$01
    99 4C75 B5 F8		NEXT_NUMOUT     LDA     DIG0,X			
   100 4C77 20 52 E0		                JSR     COUT
   101 4C7A					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4C7A CA					DEX
     2 4C7B 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   102 4C7D 60			                RTS				; return
   103 				                
   104 				; **** Print Current Drive *****************************************************
   105 				;
   106 				; ******************************************************************************
   107 4C7E AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   108 4C81 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   109 4C84 20 52 E0		                JSR     COUT		   ; print char
   110 4C87 A9 3A		                LDA     #COLON		   ; ':'
   111 4C89 4C 52 E0		                JMP     COUT		   ; print char and return
   112 				                
   113 				; **** Print Current Path ******************************************************
   114 				;
   115 				; ******************************************************************************
   116 4C8C A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   117 4C90 A6 D8		PR_PATH_LP	LDX	SAVEX
   118 4C92 BD 20 04				LDA     D_SUBDIR_NAME,X		; 
   119 4C95 48					PHA
   120 4C96 20 52 E0		                JSR     COUT		    	; print char
   121 4C99 68					PLA
   122 4C9A F0 04				BEQ	PR_PATH_DN		; End-of-String?
   123 						
   124 4C9C					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: macros.inc]
     1 4C9C E6 D8				INC	SAVEX
     2 4C9E D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   125 4CA0 60			PR_PATH_DN      RTS				; return
   126
   127 				; **** Print Drive and Path Prompt *********************************************
   128 				;
   129 				; ******************************************************************************
   130 4CA1 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   131 4CA4 20 7E 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   132 4CA7 20 8C 4C		                JSR     PRINT_PATH	   ; '\'
   133 4CAA A9 3E		                LDA     #PROMPT		   ; '>'
   134 4CAC 4C 52 E0		                JMP     COUT		   ; print char and return
   135 				                
   136 				; **** Print Drive Label *******************************************************
   137 				;
   138 				; ******************************************************************************
   139 4CAF 48			PRINT_LABEL     PHA			   ; save A
   140 4CB0			                PHY			   ; save Y
Macro: PHY [Source: macros.inc]
     1 4CB0 98				TYA
     2 4CB1 48				PHA
Source: boot_sys_sh.asm
   141 4CB2			                PRSTR   MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTR [Source: macros.inc]
     1 4CB2 A2 68			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4CB4 A0 56			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4CB6 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4CB9 20 7E 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   143 4CBC			                PRSTR   MSG_LABEL2	   ; ' is '
Macro: PRSTR [Source: macros.inc]
     1 4CBC A2 79			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4CBE A0 56			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4CC0 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   144 4CC3 20 D9 4C		                JSR     PRINT_FILENAME1    ; print volume-label
   145 4CC6 20 5A E0		                JSR     CROUT		   ; CR 2x
   146 4CC9 20 5A E0		                JSR     CROUT
   147 4CCC					PLY			   ; restore Y
Macro: PLY [Source: macros.inc]
     1 4CCC 68				PLA
     2 4CCD A8				TAY
Source: boot_sys_sh.asm
   148 4CCE 68			                PLA			   ; restore A
   149 4CCF 60			                RTS
   150 				                
   151 				; **** Print Filename **********************************************************
   152 				;
   153 				; ******************************************************************************
   154 4CD0 A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   155 4CD2					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CD2 AD 12 18				LDA	F_ATTRIBS
     3 4CD5 29 10				AND	#FA_DIRECTORY
     4 4CD7 F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   156 4CD9 A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   157 4CDB A0 00		PRINT_FILENAME2 LDY     #$00
   158 4CDD			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: macros.inc]
     1 4CDD C0 08				CPY	#$08
     2 4CDF D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   159 4CE1 20 5E E0		                JSR     SPCOUT		    		; print space
   160 4CE4 8A			                TXA
   161 4CE5 20 52 E0		                JSR     COUT                		; yes, print divider char
   162 4CE8 B1 A8		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   163 4CEA 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   164 4CED C8			                INY
   165 4CEE			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: macros.inc]
     1 4CEE C0 0B				CPY	#D_ATTRIBUTES
     2 4CF0 D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   166 4CF2 60			                RTS			    		; return
   167 				                
   168 				; **** Print File Info *********************************************************
   169 				; Input: F_ATTRIBS = File Attributes
   170 				; ******************************************************************************
   171 4CF3			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CF3 AD 12 18				LDA	F_ATTRIBS
     3 4CF6 29 10				AND	#FA_DIRECTORY
     4 4CF8 F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   172 				                
   173 				; Print Directory Attribute ****************************************************
   174 4CFA			                PRSTR   MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTR [Source: macros.inc]
     1 4CFA A2 7E			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4CFC A0 56			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4CFE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   175 4D01 EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   176 4D09 4C 36 4D				JMP     PRINT_ATTRIB
   177
   178 				; Print File Size **************************************************************
   179 4D0C 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   180 4D0F 20 5E E0		                JSR     SPCOUT
   181 4D12 EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   182 4D1A A2 00		NO_FCNT_CARRY   LDX     #$00
   183 4D1C A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   184 4D1E 18			                CLC
   185 4D1F 08			                PHP
   186 4D20 28			LOAD_SIZE       PLP
   187 4D21 B1 A8 95 C0		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   188 4D25 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   189 4D2B 08			                PHP
   190 4D2C C8			                INY
   191 4D2D E8			                INX
   192 4D2E					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4D2E E0 04				CPX	#$04
     2 4D30 D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   193 4D32 28			                PLP
   194 4D33 20 2E 4E		                JSR     PRINT_INT32         		; print file size
   195 				                
   196 				; Print File Attributes ********************************************************
   197 4D36 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   198 4D39					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: macros.inc]
     4 4D39 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4D3C 29 02				AND	#(1 << 1)
     6 4D3E F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   199 4D40 A2 07		                LDX     #$07
   200 4D42 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   201 4D45			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: macros.inc]
     1 4D45 BD 4A 57				LDA	ATTRIB_VAL,X
     2 4D48 F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   202 4D4A B0 02		                BCS     SET_ATTRIB			; branch if printable
   203
   204 4D4C A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   205 4D4E 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   206 4D51			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: macros.inc]
     1 4D51 CA					DEX
     2 4D52 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   207 4D54 20 5E E0		                JSR     SPCOUT
   208 				                
   209 				; Print Date *******************************************************************
   210 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   211 				;              08-05 Month of year (1-12)
   212 				;              04-00 Day of month (1-32)
   213 				; ******************************************************************************
   214 4D57 A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   215 4D59 B1 A8 8D 25 4E	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   216 4D5E 29 1F		                AND     #$1F                		; mask day value
   217 4D60 8D 26 4E		                STA     DAY
   218 4D63 C8			                INY
   219 4D64 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   220 4D66 4A			                LSR                         ; year in A
   221 4D67 6E 25 4E		                ROR     MONTH
   222 4D6A 4E 25 4E 4E 25 4E +         :4      LSR     MONTH		    ; LSR 4
   223 4D76 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   224 4D79 8D 24 4E		                STA     YEAR
   225 4D7C AD 26 4E		                LDA     DAY
   226 4D7F 20 70 4C		                JSR     NUMOUT
   227 4D82			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D82 A9 2E			LDA	#'.'
     2 4D84 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   228 4D87 AD 25 4E		                LDA     MONTH
   229 4D8A 20 70 4C		                JSR     NUMOUT
   230 4D8D			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D8D A9 2E			LDA	#'.'
     2 4D8F 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   231 4D92 AC 24 4E		                LDY     YEAR
   232 4D95			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: macros.inc]
     1 4D95 C0 64				CPY	#100			; 
     2 4D97 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   233
   234 4D99 A9 14		                LDA     #20
   235 4D9B 20 70 4C		                JSR     NUMOUT
   236 4D9E 98			                TYA
   237 4D9F 38 E9 64				SUB	#100		    ; same as SEC + SBC
   238 4DA2 4C AB 4D		                JMP     PRINT_YEAR
   239
   240 4DA5 A9 13		CENTURY_19      LDA     #19
   241 4DA7 20 70 4C		                JSR     NUMOUT
   242 4DAA 98			                TYA
   243 4DAB 20 70 4C		PRINT_YEAR      JSR     NUMOUT
   244 4DAE 20 5E E0		                JSR     SPCOUT
   245 				                
   246 				; Print Time *******************************************************************
   247 				; Time Format: 15-11 Hours (0-23)
   248 				;              10-05 Minutes (0-59)
   249 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   250 				; ******************************************************************************
   251 4DB1 A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   252 4DB3 B1 A8 8D 27 4E	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   253 4DB8 C8			                INY
   254 4DB9 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file last write time high byte
   255 				        .rept 3
   256 						LSR     
   257 				                ROR     MINUTE
   258 					.endr	
Source: REPT
   256 4DBB 4A					LSR     
   256 4DBC 6E 27 4E		                ROR     MINUTE
   256 4DBF 4A					LSR     
   256 4DC0 6E 27 4E		                ROR     MINUTE
   256 4DC3 4A					LSR     
   256 4DC4 6E 27 4E		                ROR     MINUTE
Source: boot_sys_sh.asm
   259 4DC7 4E 27 4E 4E 27 4E	        :2      LSR     MINUTE
   260 4DCD 20 70 4C		                JSR     NUMOUT
   261 4DD0			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: macros.inc]
     1 4DD0 A9 3A			LDA	#':'
     2 4DD2 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   262 4DD5 AD 27 4E		                LDA     MINUTE
   263 4DD8 20 70 4C		                JSR     NUMOUT		    ; print minutes
   264
   265 				; Print Cluster Number *********************************************************
   266 				; Only with /C parameter: Prints Cluster number AND LBA number
   267 				; ******************************************************************************
   268 4DDB					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: macros.inc]
     4 4DDB AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DDE 29 08				AND	#(1 << 3)
     6 4DE0 F0 41				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   269 4DE2 20 5E E0		                JSR	SPCOUT		    			; Print space
   270 4DE5					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DE5 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4DE7 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DE9 85 C3				STA	NUM32+2+1
     5 4DEB 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DEE A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4DF0 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DF2 85 C2				STA	NUM32+2
     5 4DF4 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   271 4DF7					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DF7 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4DF9 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DFB 85 C1				STA	NUM32+1
     5 4DFD 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4E00 A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4E02 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4E04 85 C0				STA	NUM32
     5 4E06 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   272 4E09 20 5E E0				JSR	SPCOUT
   273 4E0C 20 FF 40				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   274 4E0F					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 4E0F A5 C3			LDA	NUM32+2+1				; print MSB
     2 4E11 20 91 E0			JSR	HEXOUT
     3 4E14 A5 C2			LDA	NUM32+2
     4 4E16 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4E19 A5 C1			LDA	NUM32+1				; print MSB
     2 4E1B 20 91 E0			JSR	HEXOUT
     3 4E1E A5 C0			LDA	NUM32
     4 4E20 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   275 4E23 60			PRINT_EXIT	RTS
   276
   277 4E24 00			YEAR		.byte 	$00
   278 4E25 00			MONTH		.byte 	$00
   279 4E26 00			DAY 		.byte	$00
   280 4E27 00			MINUTE		.byte 	$00
   281 				                
   282 				; **** Print 16 Bit Number *****************************************************
   283 				; Input: X,Y = Int16
   284 				; ******************************************************************************
   285 4E28 20 9C 4E		PRINT_INT16     JSR     BIN16_TO_BCD
   286 4E2B 4C 31 4E		                JMP     PRINT_NUM
   287 				                
   288 				; **** Print 32 Bit Number *****************************************************
   289 				; Input: NUM32[0..3] = Int32
   290 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   291 				; ******************************************************************************
   292 4E2E 20 A6 4E		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   293 4E31 A2 00		PRINT_NUM       LDX     #$00
   294 4E33 A0 0A		                LDY     #10
   295 4E35 18			                CLC                         ; save status bits
   296 4E36 08			PRINT_NUM1      PHP                         ; store current carry flag
   297 4E37 20 6D 4E		                JSR     PRINT_SEPARATOR
   298 4E3A BD 52 57		                LDA     BCD_VAL,X           ; load two decimal digits
   299 4E3D 48			                PHA                         ; store A
   300 4E3E 98			                TYA                         ; move digit counter into A
   301 4E3F 4A			                LSR                         ; bit one into carry
   302 4E40 68			                PLA                         ; restore A
   303 4E41 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   304 						
   305 4E43 E8			                INX                         ; no, process digit 2
   306 4E44 29 0F		                AND     #$0F
   307 4E46 10 04		                BPL     SET_DIGIT2
   308 4E48 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   309 4E4C 28			SET_DIGIT2      PLP
   310 4E4D B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   311 						
   312 4E4F			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: macros.inc]
     6 4E4F 29 0F				AND	#$0F
     7 4E51 D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   313 4E53 98			                TYA
   314 4E54			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: macros.inc]
     1 4E54 C9 01				CMP	#1
     2 4E56 D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   315 4E58 A9 30		                LDA     #48                 ; yes, print 0
   316 4E5A 20 9A E0		                JSR     HEXDIG
   317 4E5D 18			                CLC                         ; number is 0
   318 4E5E 60			                RTS
   319 						
   320 4E5F 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   321 4E62 18			                CLC
   322 4E63 90 04		                BCC     NEXT_DIGIT	    ; branch always
   323 						
   324 4E65 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   325 4E68 38			                SEC                         ; no more leading 0s
   326 4E69			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: macros.inc]
     1 4E69 88					DEY
     2 4E6A D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   327 4E6C 60			                RTS
   328 				                
   329 				; Print Thousands Separator ****************************************************
   330 4E6D 08			PRINT_SEPARATOR PHP                         ; save status bits
   331 4E6E			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E6E C0 09				CPY	#$09
     2 4E70 F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   332 4E72			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E72 C0 06				CPY	#$06
     2 4E74 F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   333 4E76			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: macros.inc]
     1 4E76 C0 03				CPY	#$03
     2 4E78 D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   334 						
   335 4E7A 28			PRINT_SEP       PLP                         ; restore status bits
   336 4E7B 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   337 						
   338 4E7D A9 2E		                LDA     #NUM_SEP
   339 4E7F 4C 52 E0		                JMP     COUT                ; print thousands seperator
   340 						
   341 4E82 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   342 4E85 28			NO_SEP          PLP                         ; clean up stack
   343 4E86 60			                RTS
   344 				                
   345 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   346 				; INPUT:  A = BCD Number
   347 				; Output: A = Binary Number
   348 				; ******************************************************************************
   349 4E87 85 C0		BCD_TO_BIN      STA     NUM32               ; save BCD number
   350 4E89 29 F0		                AND     #$F0                ; and clear ones digit in A
   351 4E8B 4A			                LSR                         ; calc tens digit * 8
   352 4E8C 85 C1		                STA     NUM32+1             ; and store result
   353 4E8E 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   354 4E90 18 65 C1 85 C1			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   355 4E95 A5 C0		                LDA     NUM32               ; reload BCD number int A
   356 4E97 29 0F		                AND     #$0F                ; and clear tens digit in A
   357 4E99 65 C1		                ADC     NUM32+1             ; finally add both result
   358 4E9B 60			                RTS			    ; return
   359 				                
   360 				;**** Convert 16 Bit Binary Number To BCD **************************************
   361 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   362 				; OUTPUT: BCD_VAL[4..0] = Result
   363 				; ******************************************************************************
   364 4E9C			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: macros.inc]
     1 4E9C 86 C0			STX	NUM32
     2 4E9E 84 C1			STY	NUM32+1
Source: boot_sys_sh.asm
   365 4EA0 A2 00 86 C2 86 C3			MWX	#$00 NUM32+2	    ; clear upper word
   366 				                
   367 				;**** Convert 32 Bit Binary Number To BCD **************************************
   368 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   369 				; OUTPUT: BCD_VAL[4..0] = Result
   370 				;*******************************************************************************
   371 4EA6 F8			BIN32_TO_BCD    SED                         ; set decimal mode
   372 4EA7 A2 04		                LDX     #$04
   373 4EA9 A9 00		                LDA     #$00                ; clear BCD result value
   374 4EAB 9D 52 57 CA		CLEAR_BCD       STA     BCD_VAL,X-
   375 4EAF 10 FA		                BPL     CLEAR_BCD
   376
   377 4EB1 A2 20		                LDX     #$20                ; 32 source bits
   378 4EB3			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: macros.inc]
     1 4EB3 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4EB5 26 C1		        ROL     NUM32+1		  
     3 4EB7 26 C2		        ROL     NUM32+2
     4 4EB9 26 C3		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   379 4EBB AD 56 57 6D 56 57 + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   380 4EC4 AD 55 57 6D 55 57 + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   381 4ECD AD 54 57 6D 54 57 + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   382 4ED6 AD 53 57 6D 53 57 + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   383 4EDF AD 52 57 6D 52 57 + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   384 4EE8			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: macros.inc]
     1 4EE8 CA					DEX
     2 4EE9 D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   385 4EEB D8			                CLD                         ; reset to binary mode
   386 4EEC 60			                RTS
   387
   388 				; **** Get Command String ******************************************************
   389 				;
   390 				; ******************************************************************************
   391 4EED A2 01		GET_CMD_STR     LDX     #$01
   392 4EEF			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4EEF BD 00 14				LDA	STRBUF,X
     2 4EF2 F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   393 4EF4			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: macros.inc]
     1 4EF4 C9 20				CMP	#SPC
     2 4EF6 D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   394 4EF8 E8			SKIP_SPC_CHAR   INX
   395 4EF9 4C EF 4E		                JMP     GET_CMD_CHAR
   396 				                
   397 				; **** Get Parameter String ****************************************************
   398 				; Output: C = 1: Parameter; C = 0: Path
   399 				;         A    = $00 : End of parameter string
   400 				;         NCNT = Index to parameter
   401 				; ******************************************************************************
   402 4EFC A6 AC		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   403 4EFE 20 0C 4F		                JSR     GET_PARM_CHAR
   404 4F01					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: macros.inc]
     1 4F01 C9 2F				CMP	#OPT_SEP
     2 4F03 D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   405 4F05 E8			                INX			    ; next char
   406 4F06 BD 00 14		                LDA     STRBUF,X	    ; load parameter
   407 4F09 4C 20 4F		                JMP     PARAM_STR	    ; OK and return
   408
   409 4F0C			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4F0C BD 00 14				LDA	STRBUF,X
     2 4F0F F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   410 4F11					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: macros.inc]
     1 4F11 C9 20				CMP	#SPC
     2 4F13 F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   411 4F15					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: macros.inc]
     1 4F15 C9 2F				CMP	#OPT_SEP
     2 4F17 F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   412 4F19 E8			                INX			    
   413 4F1A 4C 0C 4F		                JMP     GET_PARM_CHAR
   414
   415 4F1D 18			PATH_STR        CLC			    ; C=0, it is a path
   416 4F1E 90 01		                BCC     END_PARAM	    ; branch always
   417
   418 4F20 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   419 4F21 86 AC		END_PARAM       STX     NCNT		    ; save index in parameter string
   420 4F23 48			                PHA
   421 4F24 68			                PLA
   422 4F25 60			                RTS			    ; return
   423
   424 				; **** Internal Command Handlers ***********************************************
   425
   426 				; **** Directory Loop Call Back Functions **************************************
   427 				; Input : A - First character of filename
   428 				;         X - File Attributes
   429 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   430 				; ******************************************************************************
   431
   432 				; **** Print Directory Entry - Call Back Routine *******************************
   433 4F26			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4F26 E0 0F				CPX	#$0F
     2 4F28 F0 5C				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   434 4F2A					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: macros.inc]
     1 4F2A C9 E5				CMP	#$E5
     2 4F2C F0 58				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   435 4F2E 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   436 4F31 8A			                TXA
   437 4F32 4A			                LSR     
   438 4F33 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   439 4F34 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   440
   441 4F36			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: macros.inc]
     4 4F36 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F39 29 04				AND	#(1 << 2)
     6 4F3B F0 49				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   442 4F3D 4A			CHK_SYSTEM      LSR                         		; check if system file
   443 4F3E 4A			CHK_LABEL       LSR                         		; check if disk label
   444 				                ; #### PRINT LABEL DISABLED ####################################
   445 4F3F B0 45		                BCS     CB_PRINT_CONT       		; it's a label, skip to next entry
   446
   447 				                ;BCC     PRINT_DIR_ENTRY
   448 				                ;JSR     PRINT_LABEL         		; print disk label
   449 				                ;INC     LINE_CNT
   450 				                ;BNE     CHK_LINE_COUNT     		 ; branch always
   451 				                ; ##############################################################
   452 4F41			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: macros.inc]
     1 4F41 AD 11 18				LDA	TERM_CHAR
     2 4F44 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   453 4F46 20 CD 4A		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   454 4F49 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   455
   456 4F4B A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   457 4F50 20 7D 48		                JSR     OS_DIR_LOOP         		; list files of sub directory
   458 4F53 38			                SEC                         		; directory list finished
   459 4F54 60			                RTS                         		; exit
   460
   461 4F55 20 88 4F		COMP_MASK       JSR     SH_COMP_MASK
   462 4F58 90 2D		                BCC     CB_PRINT_END
   463
   464 4F5A A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   465 4F5E 20 D0 4C		                JSR     PRINT_FILENAME      		; print filename
   466 4F61 20 F3 4C		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   467 4F64 20 5A E0		                JSR     CROUT
   468 4F67			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: macros.inc]
     4 4F67 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F6A 29 01				AND	#(1 << 0)
     6 4F6C F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   469 4F6E EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   470 4F71 A9 19		                LDA     #25
   471 4F73					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: macros.inc]
     1 4F73 CD 14 18				CMP	LINE_CNT			; 
     2 4F76 B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   472 4F78 A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   473 4F7D 20 EA 53		                JSR     SH_PAUSE            		; wait for key press
   474 4F80			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4F80 C9 1B				CMP	#27
     2 4F82 D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   475 4F84 38			                SEC                         		; break dir loop
   476 4F85 60			                RTS
   477 4F86 18			CB_PRINT_CONT   CLC                         		; get next next entry
   478 4F87 60			CB_PRINT_END    RTS
   479
   480 				; **** Compare File Name With Mask Using Wildcards *****************************
   481 				;
   482 				; ******************************************************************************
   483 4F88			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: macros.inc]
     1 4F88 C9 5C				CMP	#PATH_SEP
     2 4F8A F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   484 4F8C A0 0A		                LDY     #10                 			; compare all characters
   485 4F8E B9 9D 4B		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   486 4F91					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: macros.inc]
     1 4F91 C9 3F				CMP	#'?'
     2 4F93 F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   487 4F95					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: macros.inc]
     1 4F95 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4F97 D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   488 						
   489 4F99			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: macros.inc]
     1 4F99 88					DEY
     2 4F9A 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   490 4F9C 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   491 4F9D 60			                RTS
   492 4F9E 18			COMP_NAME_NEQ   CLC
   493 4F9F 60			                RTS
   494
   495 				; ******************************************************************************
   496 				; ******************************************************************************
   497 4FA0 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   498 4FA4 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   499 				; + DRIVE
   500 				                
   501 4FA8 A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   502 4FAA B9 04 04 99 A0 4F	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   503 4FB0 B9 24 18 99 A4 4F + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   504 4FB7 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   505 4FB9 60			                RTS					; return
   506 				                
   507 4FBA A0 03		LOAD_ACT_DIR    LDY     #$03
   508 4FBC B9 A0 4F 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   509 4FC2 B9 A4 4F 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   510 4FC9 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   511 4FCB 60			                RTS					; return
   512 				                
   513 				; **** Get Parameters from Command Line ****************************************
   514 				; Input:  Ptr[X:Y] to Parameter String
   515 				; Output: C = 0 - Error; C = 1 - No Error
   516 				; ******************************************************************************
   517 4FCC 20 39 50		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   518 4FCF A9 00		                LDA     #$00                ; set current command parameter value to 0
   519 4FD1 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   520 4FD4 A0 01 84 AA		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   521 4FD8 88			                DEY                         ; param mask pointer is set to 0
   522 4FD9 20 FC 4E		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   523 4FDC F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   524 4FDE B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   525 						
   526 4FE0 20 1B 50		                JSR     SH_GET_PATH         ; no, parse path parameter
   527 4FE3 B0 EF		                BCS     GET_PARM2           ; more parameters
   528
   529 4FE5 60			                RTS			    ; return
   530 						
   531 4FE6 20 65 4C		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   532 4FE9 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   533 4FEC B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   534 4FEE			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: macros.inc]
     1 4FEE C9 20				CMP	#SPC
     2 4FF0 F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   535 4FF2					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: macros.inc]
     1 4FF2 CD 12 18				CMP	F_ATTRIBS
     2 4FF5 D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   536 4FF7 A5 AA		                LDA     MASK                ; load bit mask
   537 4FF9 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   538 4FFC 4C D1 4F		                JMP     GET_PARM            ; get next parameter from command line
   539
   540 4FFF C8			NEXT_MASK       INY                         ; point to next char in param mask
   541 5000 06 AA		                ASL     MASK                ; shift bit mask to next position
   542 5002 D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   543
   544 5004 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   545 5007			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: macros.inc]
     1 5007 A2 DD			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 5009 A0 56			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   546 500B 20 C8 49		                JSR     OS_PRINT_ERR        ; and print it
   547 500E AD 12 18		                LDA     F_ATTRIBS
   548 5011 20 52 E0		                JSR     COUT                ; print unknown parameter char
   549 5014 20 5A E0		                JSR     CROUT		    ; print CR
   550 5017 18			                CLC			    ; C=0: error
   551 5018 60			                RTS
   552 5019 38			GET_PARMS_END   SEC			    ; C=1: OK
   553 501A 60			                RTS
   554 				                
   555 				; ******************************************************************************
   556 501B A6 AC		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   557 501D A0 14		                LDY     #> STRBUF
   558 501F 20 CD 49		                JSR     OS_PARSE_PATH
   559 5022 B0 14		                BCS     GET_PATH_END
   560 5024 D0 03		SH_ERROR        BNE     PARSE_ERR1
   561
   562 5026 4C 06 55		                JMP     SH_NAME_ERR
   563
   564 5029			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: macros.inc]
     1 5029 C9 5C				CMP	#PATH_SEP
     2 502B D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   565 502D 4C FF 54		                JMP     SH_DIR_ERR
   566
   567 5030			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: macros.inc]
     1 5030 C9 FF				CMP	#$FF
     2 5032 D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   568 5034 4C F8 54		                JMP     SH_PATH_ERR
   569 5037 18			GET_PATH_ERR    CLC
   570 5038 60			GET_PATH_END    RTS
   571
   572 				; **** Set Pointer To Parameter Mask *******************************************
   573 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   574 				; ******************************************************************************
   575 5039			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: macros.inc]
     1 5039 86 E8			STX	STOL
     2 503B 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   576 503D A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   577 5042 A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   578 5047 60			                RTS
   579
   580 				; Allowed Directory Options ****************************************************
   581 5048 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   582 504D 20			NO_PARMS        .by    ' '
   583
   584 				; **** DIR Command *************************************************************
   585 				; Prints a directory. The following optional parameters can be used:
   586 				; /P : 
   587 				; /A : Show attributes
   588 				; /H : Show hidden files
   589 				; /C : Show cluster number and LBA number
   590 				; ******************************************************************************
   591 504E 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   592 5051 20 A8 4F		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   593 5054			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: macros.inc]
     1 5054 A2 48			LDX	<DIR_PARMS				; MADS makes this immediate
     2 5056 A0 50			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   594 5058 20 CC 4F		                JSR     SH_GET_PARMS		; Get parameters from command-line
   595 505B B0 03		                BCS     SH_DIR_START		; branch if parameter found
   596
   597 505D 4C BA 4F		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   598
   599 5060 A2 00		SH_DIR_START    LDX     #$00
   600 5062 8A			                TXA
   601 5063 8D 14 18		                STA     LINE_CNT            	; reset line counter
   602 5066 85 EE		                STA     PSAV                	; reset file found flag
   603 5068 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   604 506C			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: macros.inc]
     1 506C E0 08				CPX	#$08
     2 506E D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   605 5070			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: macros.inc]
     1 5070 A2 26			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 5072 A0 4F			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   606 5074 20 71 48		                JSR     OS_FIND_ALL         	; find and print directory entries
   607 5077 20 BA 4F		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   608 507A			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: macros.inc]
     1 507A A5 EE				LDA	PSAV
     2 507C D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   609 507E 4C F1 54		                JMP     SH_FILE_ERR         	; no, print error
   610
   611 5081 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   612 5084 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   613 508A 20 6E 4F		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   614 				                
   615 				; Print Total File Count
   616 508D			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: macros.inc]
     1 508D AE 15 18			LDX	CURR_FILE_CNT
     2 5090 AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   617 5093 20 28 4E		                JSR     PRINT_INT16		; print as word
   618 5096			                PRSTR   MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTR [Source: macros.inc]
     1 5096 A2 8E			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 5098 A0 56			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 509A 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   619
   620 				; Print Total Used Bytes In Directory
   621 509D			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: macros.inc]
     1 509D A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 509F A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   622 50A1 20 61 41		                JSR     LOAD_32			; NUM32 = total filesize
   623 50A4 20 2E 4E		                JSR     PRINT_INT32		; print as int32
   624 50A7			                PRSTR   MSG_BYTE_USED		; print ' bytes'
Macro: PRSTR [Source: macros.inc]
     1 50A7 A2 A4			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 50A9 A0 56			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 50AB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   625
   626 				; Print Total Directory Count
   627 50AE					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: macros.inc]
     1 50AE AE 17 18			LDX	CURR_DIR_CNT
     2 50B1 AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   628 50B4 20 28 4E		                JSR     PRINT_INT16		; Print as word
   629 50B7			                PRSTR   MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTR [Source: macros.inc]
     1 50B7 A2 99			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 50B9 A0 56			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 50BB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   630 50BE					MVAX	4 FREE_KB NUM32		; NUM32 = #Free KB
Macro: MVAX [Source: macros.inc]
     1 50BE A2 03			LDX	#4-1
     2 50C0 BD C5 55 95 C0 CA	lp	MVA	FREE_KB,X NUM32,X-
     3 50C6 10 F8			BPL	lp
Source: boot_sys_sh.asm
   631 50C8 20 2E 4E				JSR	PRINT_INT32		; Print as decimal number
   632 50CB					PRSTR	TXT_KB			; Print ' KB free'
Macro: PRSTR [Source: macros.inc]
     1 50CB A2 DE			LDX	<TXT_KB				; MADS makes this immediate
     2 50CD A0 55			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 50CF 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   633 50D2 60					RTS				; return
   634 						
   635 				; **** Create Directory (MKDIR) Command ****************************************
   636 				;
   637 				; ******************************************************************************
   638 50D3 20 A8 4F		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   639 50D6			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: macros.inc]
     1 50D6 A2 4D			LDX	<NO_PARMS				; MADS makes this immediate
     2 50D8 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   640 50DA 20 CC 4F		                JSR     SH_GET_PARMS        	; get path
   641 50DD 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   642
   643 50DF A9 10		                LDA     #FA_DIRECTORY		; create directory
   644 50E1 20 B1 47		                JSR     OS_CREATE           	; create directory
   645 50E4 B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   646
   647 50E6			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: macros.inc]
     1 50E6 C9 FF				CMP	#$FF
     2 50E8 F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   648
   649 50EA 20 14 55		                JSR     SH_WRITE_ERR        	; it was a write error
   650 50ED 90 03		                BCC     SH_MKDIR_END        	; branch always
   651
   652 50EF 20 0D 55		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   653 50F2 4C BA 4F		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   654
   655 				; **** Check if Current Dir. ***************************************************
   656 				; Check if directory entered is current dir (..).
   657 				; Output: C=0: not a current dir, C=1: is current dir.
   658 				; ******************************************************************************
   659 50F5 A0 00		IS_FNAME_CURDIR	LDY	#0
   660 50F7 B9 9D 4B				LDA	FILENAME,Y
   661 50FA					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 50FA C9 2E				CMP	#'.'
     2 50FC D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   662 50FE C8					INY
   663 50FF					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: macros.inc]
     1 50FF B9 9D 4B				LDA	FILENAME,Y
     2 5102 D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   664 5104 F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   665
   666 				; **** Check if Parent Dir. ************************************************
   667 				; Check if current directory is parent dir (..).
   668 				; Output: C=0: not a parent dir, C=1: is parent dir.
   669 				; ******************************************************************************
   670 5106 A0 00		IS_FNAME_PARENT	LDY	#0
   671 5108 B9 9D 4B				LDA	FILENAME,Y
   672 510B					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 510B C9 2E				CMP	#'.'
     2 510D D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   673 510F C8					INY
   674 5110 B9 9D 4B				LDA	FILENAME,Y
   675 5113					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5113 C9 2E				CMP	#'.'
     2 5115 D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   676 5117 C8					INY
   677 5118					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: macros.inc]
     1 5118 B9 9D 4B				LDA	FILENAME,Y
     2 511B D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   678
   679 511D 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   680 511E 60					RTS
   681 511F 18			NOT_FNAME	CLC				; The filename is not . or ..
   682 5120 60					RTS
   683 						
   684 				; **** Convert filename to FN83 type filename **********************************
   685 				; INPUT: ssptr_l/ssptr_h pointer to filename
   686 				; OUTPUT: converted filename in FN83
   687 				; ******************************************************************************
   688 5121 A0 00		FNAME2FN83	LDY	#0
   689 5123 B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   690 5125					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: macros.inc]
     1 5125 C9 2E				CMP	#'.'
     2 5127 F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   691 						
   692 5129 C8			CPFNCNT		INY
   693 512A					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: macros.inc]
     1 512A C0 0B				CPY	#D_ATTRIBUTES
     2 512C D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   694 512E F0 18				BEQ	EXT_DN			; branch always if no dot was found
   695
   696 5130			FN83_DOTFND	; Found a dot
   697 5130 A2 08				LDX	#8
   698 5132 C8					INY				; points to char next to '.'
   699 5133 B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get char of extension
   700 5135 20 65 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   701 5138					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: macros.inc]
     1 5138 9D 9D 4B				STA	FILENAME,X
     2 513B F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   702 513D C8					INY
   703 513E E8					INX
   704 513F					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: macros.inc]
     1 513F E0 0B				CPX	#D_ATTRIBUTES
     2 5141 D0 F0				BNE	CPFN83_2
Source: boot_sys_sh.asm
   705 						
   706 5143 A9 00 9D 9D 4B			MVA	#0 FILENAME,X		; Add '\0' to filename
   707 5148 A0 00		EXT_DN		LDY	#0
   708 514A B1 78		CPFN83_3	LDA	(ssptr_l),Y		; Get char of Filename
   709 514C 20 65 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   710 514F 99 9D 4B				STA	FILENAME,Y		; Store in result
   711 5152					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: macros.inc]
     1 5152 C9 2E				CMP	#'.'
     2 5154 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   712 5156 C8					INY
   713 5157					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5157 C0 08				CPY	#8
     2 5159 D0 EF				BNE	CPFN83_3
Source: boot_sys_sh.asm
   714 515B 60					RTS				; return
   715 						
   716 515C A9 20 99 9D 4B C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   717 5162					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5162 C0 08				CPY	#8
     2 5164 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   718 5166 60			CPFN_DN		RTS				; return
   719 						
   720 				; **** CFC_LOAD routine for CF-IDE driver **************************************
   721 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP CFC_LOAD_VEC.
   722 				; ******************************************************************************
   723 5167			CFC_LOAD	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 5167 8E 9B 51			STX	FNAME_PTR
     2 516A 8C 9C 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   724 516D					PRSTR	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTR [Source: macros.inc]
     1 516D A2 90			LDX	<TXT_LOAD				; MADS makes this immediate
     2 516F A0 51			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 5171 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   725 5174 20 21 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   726 5177					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 5177 A9 5B			LDA	#'['
     2 5179 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   727 517C					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 517C A2 9D			LDX	<FILENAME				; MADS makes this immediate
     2 517E A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   728 5180 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   729 5183					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 5183 A9 5D			LDA	#']'
     2 5185 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   730 5188 20 A8 4F				JSR     SAVE_ACT_DIR        	; save actual directory LBA
   731 518B 20 80 54				JSR	SH_LOAD_BAS		; Load .bas file in memory
   732 518E 38					SEC				; C=1: OK
   733 518F 60					RTS				; return
   734
   735 5190 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
   736 519B 00 00		FNAME_PTR	.word 	$0000
   737
   738 				; **** CFC_SAVE routine for CF-IDE driver **************************************
   739 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP CFC_SAVE_VEC.
   740 				; ******************************************************************************
   741 519D			CFC_SAVE	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 519D 8E 9B 51			STX	FNAME_PTR
     2 51A0 8C 9C 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   742 51A3					PRSTR	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTR [Source: macros.inc]
     1 51A3 A2 36			LDX	<TXT_SAVE				; MADS makes this immediate
     2 51A5 A0 52			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 51A7 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   743 51AA					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: macros.inc]
     1 51AA AD 01 20			LDA	$2000+1				; print MSB
     2 51AD 20 91 E0			JSR	HEXOUT
     3 51B0 AD 00 20			LDA	$2000
     4 51B3 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   744 51B6 20 5E E0				JSR	SPCOUT		
   745 51B9 20 21 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   746 51BC					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 51BC A9 5B			LDA	#'['
     2 51BE 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   747 51C1					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 51C1 A2 9D			LDX	<FILENAME				; MADS makes this immediate
     2 51C3 A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   748 51C5 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   749 51C8					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 51C8 A9 5D			LDA	#']'
     2 51CA 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   750 51CD AD 00 20 8D 53 52 + 		MWA	$2000 SAVE_LEN		; SAVE_LEN = end-address
   751 51D9 38 AD 53 52 E9 00 + 		SBW	SAVE_LEN #$2000		; Get net file-size
   752 51EA AD 54 52 8D 55 52			MVA	SAVE_LEN+1 SAVE_SECS	; SAVE_SECS now contains #pages of 256 bytes
   753 51F0 4E 55 52				LSR	SAVE_SECS		; SAVE_SECS now contains #sectors of 512 bytes needed
   754 51F3					LDA.EQ	SAVE_LEN NO_ADD_SEC	; branch if LSB of SAVE_LEN is 0
Macro: LDA.EQ [Source: macros.inc]
     1 51F3 AD 53 52				LDA	SAVE_LEN
     2 51F6 F0 03				BEQ	NO_ADD_SEC
Source: boot_sys_sh.asm
   755
   756 51F8 EE 55 52				INC	SAVE_SECS		; Add 1 to SAVE_SECS if LSB of SAVE_LEN is not 0
   757 51FB			NO_ADD_SEC	PRSTR	TXT_SECND1		; Print ', size: '
Macro: PRSTR [Source: macros.inc]
     1 51FB A2 42			LDX	<TXT_SECND1				; MADS makes this immediate
     2 51FD A0 52			LDY	>TXT_SECND1
Source: boot_sys_sh.asm
     2 51FF 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   758 5202					LDXY	SAVE_LEN		; Size in bytes
Macro: LDXY [Source: macros.inc]
     1 5202 AE 53 52			LDX	SAVE_LEN
     2 5205 AC 54 52			LDY	SAVE_LEN+1
Source: boot_sys_sh.asm
   759 5208 20 28 4E				JSR	PRINT_INT16		; Print it
   760 520B					PRSTR	TXT_SECND2		; Print ', sec: '
Macro: PRSTR [Source: macros.inc]
     1 520B A2 4B			LDX	<TXT_SECND2				; MADS makes this immediate
     2 520D A0 52			LDY	>TXT_SECND2
Source: boot_sys_sh.asm
     2 520F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   761 5212 AD 55 52				LDA	SAVE_SECS		; Get sector count
   762 5215 20 70 4C				JSR	NUMOUT			; Print #sectors needed
   763 5218 20 5A E0				JSR	CROUT			; Print CR
   764 						
   765 521B					PRSTR	TXT_OS_CREATE		; Print 'OS_CREATE'
Macro: PRSTR [Source: macros.inc]
     1 521B A2 56			LDX	<TXT_OS_CREATE				; MADS makes this immediate
     2 521D A0 52			LDY	>TXT_OS_CREATE
Source: boot_sys_sh.asm
     2 521F 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   766 5222 A9 20				LDA	#FA_ARCHIVE		; File is modified 
   767 5224 20 B1 47				JSR	OS_CREATE		; Create file in current dir. and update FAT
   768 5227					PRSTR	TXT_OS_SAVFILE		; Print 'OS_SAVE_FILE'
Macro: PRSTR [Source: macros.inc]
     1 5227 A2 61			LDX	<TXT_OS_SAVFILE				; MADS makes this immediate
     2 5229 A0 52			LDY	>TXT_OS_SAVFILE
Source: boot_sys_sh.asm
     2 522B 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   769 522E 20 14 45				JSR	OS_SAVE_FILE		; Save contents of file
   770 5231 20 2A 56				JSR	SIS_DEL			; Subtract #allocated clusters from SIS and write back to disk
   771 5234 38					SEC				; C=1: OK
   772 5235 60					RTS				; return
   773
   774 5236 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
   775 5242 2C 20 73 69 7A 65 + TXT_SECND1	.by	', size: ' $00
   776 524B 2C 20 73 65 63 3A + TXT_SECND2	.by	', sec: ' $00
   777 5253 00 00		SAVE_LEN	.word	$0000			; #bytes to save
   778 5255 00			SAVE_SECS	.byte	$00			; #sectors (of 512 B) to save
   779 5256 4F 53 5F 43 52 45 + TXT_OS_CREATE	.by	'OS_CREATE' CR $00
   780 5261 4F 53 5F 53 41 56 + TXT_OS_SAVFILE 	.by	'OS_SAVE_FILE' CR $00
   781
   782 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   783 				; Check if directory entered is current dir (..).
   784 				; Output: C=0: not a current dir, C=1: is current dir.
   785 				; ******************************************************************************
   786 526F A0 00		ADD_SUBDIR_NAME	LDY	#0
   787 5271			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5271 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5274 F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   788 5276 C8					INY
   789 5277 D0 F8				BNE	FIND_EOS			; branch always
   790 5279 60					RTS
   791
   792 527A			SUBDIR_EOS	CPY.EQ	#1 CP_INIT			; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 527A C0 01				CPY	#1
     2 527C F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   793 527E A9 5C 99 20 04			MVA	#BSLASH D_SUBDIR_NAME,Y		; add '\' to subdir name
   794 5283 C8					INY
   795 5284 A2 00		CP_INIT		LDX	#0
   796 5286 BD 9D 4B 99 20 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   797 528C F0 06				BEQ	SUBDIR_X			; exit if $00 found
   798 						
   799 528E C8					INY					; index in D_SUBDIR_NAME
   800 528F E8					INX					; index in FILENAME
   801 5290					CPX.NE	#D_ATTRIBUTES CP_FNAME		; branch if not at max filename yet
Macro: CPX.NE [Source: macros.inc]
     1 5290 E0 0B				CPX	#D_ATTRIBUTES
     2 5292 D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   802 5294 60			SUBDIR_X	RTS					; return if done
   803 						
   804 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   805 				; ******************************************************************************
   806 5295 A0 00		DEL_SUBDIR_NAME	LDY	#0
   807 5297			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_LP1	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5297 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 529A F0 04				BEQ	SUBDIR_LP1
Source: boot_sys_sh.asm
   808 529C C8					INY
   809 529D D0 F8				BNE	FIND_EOS2			; branch always
   810 529F 60			DEL_SUBDIR_X	RTS
   811
   812 52A0 B9 20 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y			; get char from D_SUBDIR_NAME
   813 52A3					CMP.EQ	#BSLASH BSLASH_FND		; branch if filename separator found
Macro: CMP.EQ [Source: macros.inc]
     1 52A3 C9 5C				CMP	#BSLASH
     2 52A5 F0 04				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   814 52A7					DEY.NE	SUBDIR_LP1			; branch always
Macro: DEY.NE [Source: macros.inc]
     1 52A7 88					DEY
     2 52A8 D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   815 52AA C8					INY					; Y = 0->1, leave '\' for root-dir
   816 52AB A9 00 99 20 04	BSLASH_FND	MVA	#0 D_SUBDIR_NAME,Y		; Replace '\' with \0 for subdirs in D_SUBDIR_NAME
   817 52B0 60			DSNM_X		RTS					; and return
   818
   819 				; **** Change Directory Command ************************************************
   820 				;
   821 				; ******************************************************************************
   822 52B1 20 A8 4F		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   823 52B4			                LDXYI   NO_PARMS
Macro: LDXYI [Source: macros.inc]
     1 52B4 A2 4D			LDX	<NO_PARMS				; MADS makes this immediate
     2 52B6 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   824 52B8 20 CC 4F		                JSR     SH_GET_PARMS		; get subdir name
   825 52BB 90 26		                BCC     SH_CD_END		; C=0: no name entered
   826
   827 52BD			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: macros.inc]
     1 52BD AD 11 18				LDA	TERM_CHAR
     2 52C0 D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   828 52C2 20 67 48		                JSR     OS_FIND_PATH		; loop through dir to find path
   829 52C5 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   830 						
   831 52C7 A0 00				LDY	#0			; add '\0' to string
   832 52C9 B9 9D 4B		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   833 52CC					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: macros.inc]
     1 52CC C9 20				CMP	#' '
     2 52CE F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   834 52D0 C8					INY
   835 52D1					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: macros.inc]
     1 52D1 C0 0B				CPY	#D_ATTRIBUTES
     2 52D3 D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   836 						
   837 52D5 A9 00 99 9D 4B	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   838 52DA 20 06 51				JSR	IS_FNAME_PARENT		; is dir .. ?
   839 52DD 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   840 						
   841 52DF 20 95 52				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   842 52E2 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   843 52E3 60			SH_CD_END	RTS
   844
   845 52E4 20 F5 50		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   846 52E7 B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   847 						
   848 52E9 20 6F 52				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   849 52EC 4C E2 52				JMP	SH_CD_EXIT_OK		; branch always
   850 						
   851 52EF 20 BA 4F		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   852 52F2 20 5A E0		                JSR     CROUT			; print CR
   853 52F5 4C F8 54		                JMP     SH_PATH_ERR		; Print 'Path not found'
   854
   855 				; **** Release the FAT clusters for a file  ************************************
   856 				; Algorithm:
   857 				;       SCNT = 1;
   858 				; loop: CURR_CLUSTER = FAT[CURR_CLUSTER];
   859 				;       FAT[CURR_CLUSTER] = 0L; // 0L = free entry
   860 				;       if (CURR_CLUSTER == 0FFFFFFF) SCNT++; goto loop;
   861 				; ******************************************************************************
   862 52F8 A2 00 8E E8 55	CLR_FAT32_FILE 	MVX 	#0 SIS_CNT			; #clusters cleared
   863 52FD			CLR_FAT32_LP1	LDXYI   D_START_FAT1      		; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 52FD A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 52FF A0 04			LDY	>D_START_FAT1
Source: boot_sys_sh.asm
   864 5301 20 61 41		                JSR     LOAD_32		    		; NUM32 = LBA nr. of FAT
   865 5304					LDXYI	(CURR_CLUSTER+1)			; SUM32 = CURR_CLUSTER into SUM32
Macro: LDXYI [Source: macros.inc]
     1 5304 A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 5306 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_sh.asm
   866 5308 20 5B 41				JSR     LOAD_S32            		; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   867 530B 20 71 53				JSR	PRTST1				; DEBUG
   868 530E A2 00 86 C7				MVX	#$00 SUM32+3			; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   869 5312 A0 03		                LDY     #$03
   870 5314 A5 A0		                LDA     CURR_CLUSTER        		; load CURR_CLUSTER[0] = FAT entry index byte
   871 5316 0A			                ASL                         		; shift bit 7 into carry flag and multiply entry index by 2
   872 5317 48			                PHA                         		; save entry index to stack
   873 5318 36 C4 E8		CLR32_LP        ROL     SUM32,X+             		; shift bit 7 of entry index into bit 0 of block index
   874 531B			                DEY.NE  CLR32_LP	    		; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 531B 88					DEY
     2 531C D0 FA				BNE	CLR32_LP
Source: boot_sys_sh.asm
   875 						
   876 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   877 531E 20 8F 41		                JSR     ADD_32_32	    		; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   878 5321 20 1D 41		                JSR     LOAD_FAT_BLK	    		; Load FAT sector into standard buffer ($600)
   879 5324 68			                PLA                         		; restore entry index
   880 5325 A2 04		                LDX     #$04                		; four bytes to read for a FAT32 entry
   881 5327 0A			                ASL                         		; multiply entry index by 2 (4 in total now)
   882 5328 A8			                TAY                         		; store entry index into Y
   883 5329 20 91 E0				JSR	HEXOUT				; DEBUG
   884 532C A2 04 86 AC		                MVX	#4 NCNT				; 1 FAT entry = 4 bytes
   885 5330 A2 00				LDX	#0				; init. CURR_CLUSTER index
   886 5332 20 EA 40		LP_FAT_ENTRY    JSR     READ_ENTRY_BYTE     		; read entry byte
   887 5335 9D 6D 53				STA     TEMP_CLUSTER,X      		; store byte in TEMP_CLUSTER to follow link
   888 5338 20 90 53				JSR	WR_ENTRY_BYTE			; FAT[CURR_CLUSTER] = 0
   889 533B C8					INY					; Increment FAT index counter
   890 533C E8			                INX					; Increment CURR_CLUSTER counter
   891 533D			                DEC.NE  NCNT LP_FAT_ENTRY   		; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 533D C6 AC				DEC	NCNT
     2 533F D0 F1				BNE	LP_FAT_ENTRY
Source: boot_sys_sh.asm
   892 5341					MVAX	4 TEMP_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = TEMP_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 5341 A2 03			LDX	#4-1
     2 5343 BD 6D 53 95 A0 CA	lp	MVA	TEMP_CLUSTER,X CURR_CLUSTER,X-
     3 5349 10 F8			BPL	lp
Source: boot_sys_sh.asm
   893 534B EE E8 55				INC	SIS_CNT				; #clusters cleared + 1
   894 534E A9 0F C5 A3 D0 10 + 		CPD	#$0FFFFFFF CURR_CLUSTER		; CURR_CLUSTER == $0FFFFFFF ?
   895 5364 D0 97				BNE	CLR_FAT32_LP1			; branch if file has more clusters to clear
   896 						
   897 5366					LDXYI	CURR_FAT_BLK			; LBA of current FAT block
Macro: LDXYI [Source: macros.inc]
     1 5366 A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 5368 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_sh.asm
   898 536A 4C 18 42				JMP	DEV_WR_LBLK_BUF			; write FAT block back to disk and return
   899
   900 536D 00 00 00 00		TEMP_CLUSTER	.dword	$00000000
   901 						
   902 5371			PRTST1		PRCH	'<'
Macro: PRCH [Source: macros.inc]
     1 5371 A9 3C			LDA	#'<'
     2 5373 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   903 5376					PRHEX32	CURR_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 5376 A5 A3			LDA	CURR_CLUSTER+2+1				; print MSB
     2 5378 20 91 E0			JSR	HEXOUT
     3 537B A5 A2			LDA	CURR_CLUSTER+2
     4 537D 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5380 A5 A1			LDA	CURR_CLUSTER+1				; print MSB
     2 5382 20 91 E0			JSR	HEXOUT
     3 5385 A5 A0			LDA	CURR_CLUSTER
     4 5387 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   904 538A					PRCH	'>'
Macro: PRCH [Source: macros.inc]
     1 538A A9 3E			LDA	#'>'
     2 538C 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   905 538F 60					RTS
   906
   907 				; **** Write a Single FAT Entry Byte From Block Buffer *************************
   908 				; INPUT : Y - Index To FAT Entry Byte
   909 				; OUTPUT: A = Read Byte from FAT table
   910 				; ******************************************************************************
   911 5390			WR_ENTRY_BYTE 	AND.NE  #$01 CURR_CLUSTER+1 CLR_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 5390 A9 01				LDA	#$01
     3 5392 25 A1				AND	CURR_CLUSTER+1
     4 5394 D0 06				BNE	CLR_UPPER_PAGE
Source: boot_sys_sh.asm
   912 5396 A9 00 99 00 06	                MVA	#0 BLOCK_BUFF,Y				; write entry byte from lower half of block buffer
   913 539B 60			                RTS			    			; return
   914 539C A9 00 99 00 07	CLR_UPPER_PAGE  MVA     #0 BLOCK_BUFF+256,Y    			; write entry byte from upper half of block buffer
   915 53A1 60			                RTS			    			; return
   916
   917 				; **** Delete Command **********************************************************
   918 				;
   919 				; ******************************************************************************
   920 53A2 20 A8 4F		SH_DEL          JSR     SAVE_ACT_DIR        			; save actual directory LBA
   921 53A5			                LDXYI   NO_PARMS          			; we don't need parameters, just the filename
Macro: LDXYI [Source: macros.inc]
     1 53A5 A2 4D			LDX	<NO_PARMS				; MADS makes this immediate
     2 53A7 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   922 53A9 20 CC 4F		                JSR     SH_GET_PARMS        			; get path
   923 53AC 90 33		                BCC     SH_DEL_X	    			; branch if no filename was given
   924
   925 53AE 20 6D 48		                JSR     OS_FIND_FILE				; Now find file to delete
   926 53B1 90 31		                BCC     SH_DEL_ERR				; branch if file not found
   927
   928 						; OS_FIND_FILE did already set CURR_CLUSTER to the file starting-cluster
   929 53B3 A0 00		SH_DEL_FILE	LDY	#D_FILENAME
   930 53B5 A9 E5 91 A8				MVA	#$E5 (CURR_DIR_ENTRY),Y			; $E5 first char. is a deleted file
   931 53B9 A0 14				LDY	#D_START_CLSTH
   932 53BB A9 00 91 A8 C8 91 + 		MWA	#$00 (CURR_DIR_ENTRY),Y			; delete high word of file-size
   933 53C2					PRHEX16	CURR_DIR_BLK
Macro: PRHEX16 [Source: macros.inc]
     1 53C2 AD 25 18			LDA	CURR_DIR_BLK+1				; print MSB
     2 53C5 20 91 E0			JSR	HEXOUT
     3 53C8 AD 24 18			LDA	CURR_DIR_BLK
     4 53CB 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   934 53CE					LDXYI	CURR_DIR_BLK				; CURR_DIR_BLK is LBA of current dir block
Macro: LDXYI [Source: macros.inc]
     1 53CE A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 53D0 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_sh.asm
   935 53D2 20 FE 42		                JSR     OS_SAVE_DIR	    			; write this dir entry back to disk
   936 						
   937 53D5 20 F8 52				JSR	CLR_FAT32_FILE				; Set all FAT entries for this file to 00000000 (free)
   938 53D8 20 29 46				JSR	INIT_FREE_CLUSTER			; FREE_CLUSTER = 2L
   939 53DB 20 3A 46				JSR     OS_NEXT_FREE_CLUSTER			; Get first free cluster in FREE_CLUSTER
   940
   941 						; Update SIS with #clusters freed and first-free cluster nr
   942 53DE 20 E9 55				JSR	SIS_ADD					; Update SIS and write back
   943 53E1 4C BA 4F		SH_DEL_X        JMP     LOAD_ACT_DIR        			; error - restore actual directory LBA and return
   944
   945 53E4 4C F1 54		SH_DEL_ERR	JMP	SH_FILE_ERR				; Print 'File not found' and return
   946
   947 				; **** Clear Screen Command ****************************************************
   948 				;
   949 				; ******************************************************************************
   950 53E7 4C B5 E0		SH_CLS          JMP     CLRSCRN
   951
   952 				; **** Pause Command ***********************************************************
   953 				; Output: A - pressed key char
   954 				;         C = 0 ESC key pressed, C = 1 else
   955 				; ******************************************************************************
   956 53EA			SH_PAUSE        PRSTR   MSG_PAUSE          	; print pause message
Macro: PRSTR [Source: macros.inc]
     1 53EA A2 57			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 53EC A0 56			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 53EE 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   957 53F1 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   958 53F4 48			                PHA
   959 53F5 20 5A E0		                JSR     CROUT
   960 53F8 68			                PLA
   961 53F9 60			                RTS
   962 				                
   963 				; **** Echo Command ************************************************************
   964 				;
   965 				; ******************************************************************************
   966 53FA			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 53FA BD 00 14				LDA	STRBUF,X
     2 53FD F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   967 53FF 8A			                TXA
   968 5400 A8			                TAY
   969 5401 C8			                INY
   970 5402 20 85 E0		                JSR     WRSTR
   971 5405 20 5A E0		                JSR     CROUT
   972 5408 60			SH_ECHO_END     RTS
   973
   974 				; **** Goto Command ************************************************************
   975 				;
   976 				; ******************************************************************************
   977 5409 60			SH_GOTO         RTS
   978
   979 				; **** If Command **************************************************************
   980 				;
   981 				; ******************************************************************************
   982 540A 20 29 46		SH_IF           JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   983 540D 20 3A 46		                JSR 	OS_NEXT_FREE_CLUSTER
   984 5410 A0 03				LDY 	#3
   985 5412			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: macros.inc]
     1 5412 98				TYA
     2 5413 48				PHA
Source: boot_sys_sh.asm
   986 5414 B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   987 5417 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   988 541A					PLY				; restore Y
Macro: PLY [Source: macros.inc]
     1 541A 68				PLA
     2 541B A8				TAY
Source: boot_sys_sh.asm
   989 541C					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 541C 88					DEY
     2 541D 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   990 541F 60					RTS
   991
   992 				; **** Rem Command *************************************************************
   993 				;
   994 				; ******************************************************************************
   995 5420			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: macros.inc]
     1 5420 A5 DC			LDA	BLKBUF
     2 5422 48				PHA
     3 5423 A5 DD			LDA	BLKBUF+1
     4 5425 48				PHA
Source: boot_sys_sh.asm
   996 5426 20 4E 55				JSR	GET_SIS
   997 5429					PLW	BLKBUF
Macro: PLW [Source: macros.inc]
     1 5429 68				PLA
     2 542A 85 DD			STA	BLKBUF+1
     3 542C 68				PLA
     4 542D 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
   998 542F 60			SH_REM_X	RTS
   999 				                
  1000 				; **** BASIC Command ***********************************************************
  1001 				; Executes Basic in ROM. Return with 'DOS' command. 
  1002 				; ******************************************************************************
  1003 5430 20 0A E0		SH_BASIC        JSR	SWITCH_TO_ROM		; Make sure BASIC ROM is enabled
  1004 5433 4C 30 18				JMP	BAS_JMP_CODE		; Run BAS_JMP_CODE from $1830 RAM area
  1005
  1006 				; ------------------------------------------------------------------------------
  1007 				; This routine copies the BAS_JMP code below to the RAM-area at $1820. This is
  1008 				; done during at OS MAIN, the OS Entry-point.
  1009 				; ------------------------------------------------------------------------------
  1010 5436 A2 19		CP_BAS_JMP	LDX	#BAS_JMP_END - BAS_JMP	; Amount of bytes to copy
  1011 5438 BD 42 54		SH_BAS_LP	LDA	BAS_JMP,X		; Get byte to copy
  1012 543B 9D 30 18				STA	BAS_JMP_CODE,X		; Store in $1830 RAM area
  1013 543E CA					DEX
  1014 543F 10 F7				BPL	SH_BAS_LP		; Branch if not done yet
  1015 5441 60					RTS				; return
  1016 						
  1017 				;--------------------------------------------------------------------------------
  1018 				; This function gets copied to BAS_JMP_CODE in memory, so that a RAM-BANK switch
  1019 				; does not affect the boot.sys code (which is in page 0 of the RAM-BANK area).
  1020 				;--------------------------------------------------------------------------------
  1021 5442 A2 04		BAS_JMP		LDX	#4			; RAM-BANK 4 is the 1st RAM-BANK
  1022 5444 20 53 FD				JSR	SET_RAMBANK		; Enable RAM-BANK for BASIC-programs
  1023 5447 A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
  1024 5449					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: macros.inc]
     1 5449 C9 B1				CMP	#$B1
     2 544B D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
  1025 						
  1026 544D 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
  1027 5450 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
  1028
  1029 				;--------------------------------------------------------------------------------
  1030 				; The RAM-BANK MUST be switched to MAIN RAM-bank 0, because the DOS code is there.
  1031 				; If the switch back is not done, the return jump will crash.
  1032 				;--------------------------------------------------------------------------------
  1033 5453 A2 00		DOS_JMP_RET	LDX	#0			; RAM-BANK 0 is the main RAM-BANK and used by DOS
  1034 5455 20 53 FD				JSR	SET_RAMBANK		; Enable main RAM-BANK for DOS
  1035 5458 4C A1 42				JMP	OS_SHELL_ENTRY		; Default return for Monitor and BASIC
  1036 545B			BAS_JMP_END
  1037
  1038 				; **** BRUN Command ************************************************************
  1039 				;
  1040 				; ******************************************************************************
  1041 545B 20 A8 4F		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1042 545E			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 545E A2 4D			LDX	<NO_PARMS				; MADS makes this immediate
     2 5460 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1043 5462 20 CC 4F		                JSR     SH_GET_PARMS
  1044 5465 90 05		                BCC     SH_BRUN_END
  1045
  1046 5467 20 6D 48		                JSR     OS_FIND_FILE
  1047 546A 90 00		                BCC     SH_BRUN_END		; branch if file not found
  1048
  1049 				                ;JSR     OS_LOAD_BIN
  1050 546C 20 BA 4F		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1051 546F 60			                RTS
  1052 				                
  1053 				; **** BLOAD Command ***********************************************************
  1054 				;
  1055 				; ******************************************************************************
  1056 5470 60			SH_BLOAD        RTS
  1057
  1058 				; ******************************************************************************
  1059 5471 20 A8 4F		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
  1060 5474			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 5474 A2 4D			LDX	<NO_PARMS				; MADS makes this immediate
     2 5476 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1061 5478 20 39 50		                JSR     SET_PARM_MASK
  1062 547B 20 1B 50		                JSR     SH_GET_PATH         ; get file path
  1063 547E 90 5C		                BCC     SH_RUN_END
  1064
  1065 						; This is the entry-point for loading a .BAS file into memory
  1066 5480 AD A5 4B		SH_LOAD_BAS     LDA     FILENAME+8
  1067 5483			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: macros.inc]
     1 5483 C9 20				CMP	#SPC
     2 5485 D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
  1068 5487					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: macros.inc]
     1 5487 A0 02			LDY	#3-1
     2 5489 B9 6D 57 99 A5 4B + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 5490 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1069
  1070 						; Check for .COM file
  1071 5492 A0 02		SH_RUN1         LDY     #$02
  1072 5494 B9 6D 57		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
  1073 5497					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: macros.inc]
     1 5497 D9 A5 4B				CMP	FILENAME+8,Y
     2 549A D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
  1074 549C			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 549C 88					DEY
     2 549D 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
  1075 				                
  1076 549F A9 01 8D 6F 44			MVA	#1 FTYPE	    	; 1 = .COM file
  1077 54A4 D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
  1078
  1079 54A6 A0 02		CHK_BASF	LDY     #$02
  1080 54A8 B9 73 57		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
  1081 54AB			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: macros.inc]
     1 54AB D9 A5 4B				CMP	FILENAME+8,Y
     2 54AE D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
  1082 54B0			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54B0 88					DEY
     2 54B1 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
  1083 				                
  1084 54B3 A9 00 8D 6F 44			MVA	#0 FTYPE	    	; 0 = .BAS file
  1085 54B8 F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
  1086
  1087 54BA A0 02		CHK_EXEF	LDY     #$02
  1088 54BC B9 70 57		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
  1089 54BF			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: macros.inc]
     1 54BF D9 A5 4B				CMP	FILENAME+8,Y
     2 54C2 D0 18				BNE	SH_RUN_END
Source: boot_sys_sh.asm
  1090 54C4			                DEY.PL	CMP_EXT_EXE	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54C4 88					DEY
     2 54C5 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
  1091 				                
  1092 54C7 A9 02 8D 6F 44			MVA	#2 FTYPE	    	; 2 = .EXE file
  1093 54CC 20 6D 48		SH_RUN_FF       JSR     OS_FIND_FILE        	; check if file with this extension exists
  1094 54CF B0 08		                BCS     SH_RUN3             	; yes, load file
  1095
  1096 54D1 20 5A E0		SH_RUN_ERR      JSR     CROUT		    	; print CR
  1097 54D4 20 F1 54		                JSR     SH_FILE_ERR         	; file does not exist
  1098 54D7 90 03		                BCC     SH_RUN_END	    	; branch always
  1099
  1100 54D9 20 82 44		SH_RUN3         JSR     OS_LOAD_FILE	    	; Load .bas file or load/run .com/.exe file
  1101 54DC 4C BA 4F		SH_RUN_END      JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
  1102 				                
  1103 				; **** Print version info  *****************************************************
  1104 				; Output: -
  1105 				; ******************************************************************************
  1106 54DF			SH_VER		PRSTR	MSG_BOOT			; Print Title Info
Macro: PRSTR [Source: macros.inc]
     1 54DF A2 36			LDX	<MSG_BOOT				; MADS makes this immediate
     2 54E1 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_sh.asm
     2 54E3 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1107 54E6 60					RTS
  1108 						
  1109 				; **** Monitor call-back Routine ************************************************
  1110 54E7			SH_MONITOR      PRSTR   MSG_MONITOR
Macro: PRSTR [Source: macros.inc]
     1 54E7 A2 2E			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 54E9 A0 57			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 54EB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1111 54EE 4C 03 E0		                JMP     MON_WARM_START
  1112 				                
  1113 				.macro	PR_ERR	msg
  1114 						LDXYI	:msg
  1115 						JMP	OS_PRINT_ERR
  1116 				.endm
  1117 				; **** Error Routines **********************************************************
  1118 54F1			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54F1 A2 BD			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 54F3 A0 56			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 54F5 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1119 54F8			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54F8 A2 CD			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 54FA A0 56			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 54FC 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1120 54FF			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54FF A2 00			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 5501 A0 57			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 5503 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1121 5506			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5506 A2 EE			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 5508 A0 56			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 550A 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1122 550D			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 550D A2 13			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 550F A0 57			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 5511 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1123 5514			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 5514 A2 3C			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 5516 A0 57			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 5518 4C C8 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1124 				                
  1125 				; Inits BLKBUF to SIS_BUFF **************************************
  1126 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1127 				; ***************************************************************
  1128 551B A9 00 85 DC A9 58 + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1129 5523 60					RTS
  1130
  1131 				;-------------------------------------------------------------------------------
  1132 				; Convert #Clusters to KB in FREE_KB
  1133 				; D_SECT_PER_CLST = 1: 2 CL =  2 SEC = 1 KB: SHR 1
  1134 				;                   2: 2 CL =  4 SEC = 2 KB: -
  1135 				;		    4: 2 CL =  8 SEC = 4 KB: SHL 1
  1136 				;		    8: 2 CL = 16 SEC = 8 KB: SHL 2 etcetera
  1137 				;-------------------------------------------------------------------------------
  1138 5524 AD 0B 04		CL2KB		LDA	D_SECT_PER_CLST			; #sectors per cluster
  1139 5527					CMP.EQ	#2 CL2KB_X			; 2 sec/cl, just exit
Macro: CMP.EQ [Source: macros.inc]
     1 5527 C9 02				CMP	#2
     2 5529 F0 22				BEQ	CL2KB_X
Source: boot_sys_sh.asm
  1140 552B					CMP.EQ	#1 CL2KB_1			; 1 sec/cl, SHR 1
Macro: CMP.EQ [Source: macros.inc]
     1 552B C9 01				CMP	#1
     2 552D F0 12				BEQ	CL2KB_1
Source: boot_sys_sh.asm
  1141 552F 4A 4A			:2	LSR					; init nr of shifts		
  1142 5531			CL2KB_SHL	ASL32	FREE_KB				; SHL 1 of FREE_KB
Macro: ASL32 [Source: macros.inc]
     1 5531 0E C5 55			ASL     FREE_KB		  		; SHL with C=0
     2 5534 2E C6 55		        ROL     FREE_KB+1		  
     3 5537 2E C7 55		        ROL     FREE_KB+2
     4 553A 2E C8 55		        ROL     FREE_KB+3		  
Source: boot_sys_sh.asm
  1143 553D 4A					LSR
  1144 553E D0 F1				BNE	CL2KB_SHL			; branch if not done with shifting
  1145 5540 60					RTS					; return
  1146 						
  1147 5541			CL2KB_1		LSR32	FREE_KB				; SHR 1 of FREE_KB
Macro: LSR32 [Source: macros.inc]
     1 5541 4E C8 55			LSR     FREE_KB+3		  		; SHR with C=0
     2 5544 6E C7 55		        ROR     FREE_KB+2
     3 5547 6E C6 55		        ROR     FREE_KB+1
     4 554A 6E C5 55		        ROR     FREE_KB
Source: boot_sys_sh.asm
  1148 554D 60			CL2KB_X		RTS					; return
  1149 						
  1150 				; Get Info from System Information Sector **************************************
  1151 554E 20 1B 55		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1152 5551					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START
Macro: LDXYI [Source: macros.inc]
     1 5551 A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 5553 A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1153 5555 20 4B 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1154 5558					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: macros.inc]
     1 5558 A2 03			LDX	#4-1
     2 555A BD 00 04 9D C1 55 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 5561 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1155 5563 18 AD C1 55 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1156 5576 AD C3 55				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1157 5579 69 00				ADC	#0
  1158 557B 8D C3 55				STA	SYS_INFO_LBA+2
  1159 557E AD C4 55				LDA	SYS_INFO_LBA+3
  1160 5581 69 00				ADC	#0
  1161 5583 8D C4 55				STA	SYS_INFO_LBA+3
  1162 						
  1163 5586 20 1B 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1164 5589					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: macros.inc]
     1 5589 A2 C1			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 558B A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1165 558D 20 4B 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1166 5590					PRSTR	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTR [Source: macros.inc]
     1 5590 A2 C9			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 5592 A0 55			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 5594 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1167 5597					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: macros.inc]
     1 5597 AD EF 59			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 559A 20 91 E0			JSR	HEXOUT
     3 559D AD EE 59			LDA	SIS_BUFF+$01EC+2
     4 55A0 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 55A3 AD ED 59			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 55A6 20 91 E0			JSR	HEXOUT
     3 55A9 AD EC 59			LDA	SIS_BUFF+$01EC
     4 55AC 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1168 55AF 20 5A E0				JSR	CROUT
  1169 55B2			FREE_KB_UPDATE	MVAX	4 SIS_BUFF+$01E8 FREE_KB	
Macro: MVAX [Source: macros.inc]
     1 55B2 A2 03			LDX	#4-1
     2 55B4 BD E8 59 9D C5 55 + lp	MVA	SIS_BUFF+$01E8,X FREE_KB,X-
     3 55BB 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1170 55BD 20 24 55				JSR	CL2KB				; Convert #clusters to KB and store in FREE_KB
  1171 55C0 60					RTS
  1172 						
  1173 55C1 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1174 55C5 00 00 00 00		FREE_KB		.dword	$00000000
  1175 55C9 46 69 72 73 74 20 + TXT_FFREE_CLST	.by	'First free cluster:$' $00
  1176 55DE 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1177 55E8 00			SIS_CNT		.byte	$00				; SIS counter, counts #clusters freed or allocated
  1178
  1179 				; Write Info back to System Information Sector **************************************
  1180 55E9			SIS_ADD		PRSTR	SISP
Macro: PRSTR [Source: macros.inc]
     1 55E9 A2 4D			LDX	<SISP				; MADS makes this immediate
     2 55EB A0 56			LDY	>SISP
Source: boot_sys_sh.asm
     2 55ED 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1181 55F0 AD E8 59 18 6D E8 + 		ADB	SIS_BUFF+$01E8 SIS_CNT		; add SIS_CNT to #free clusters in SIS-buffer
  1182 55FA 90 03				SCC					; 'skip if C is clear' macro
  1183 55FC EE E9 59				INC	SIS_BUFF+$01E9
  1184 55FF 90 03				SCC	
  1185 5601 EE EA 59				INC	SIS_BUFF+$01EA
  1186 5604 90 03				SCC	
  1187 5606 EE EB 59				INC	SIS_BUFF+$01EB
  1188 5609 AD E8 55		SIS_WRITE	LDA	SIS_CNT				; Print SIS_CNT
  1189 560C 20 91 E0				JSR	HEXOUT
  1190 560F 20 5A E0				JSR	CROUT
  1191 5612					MVAX	4 FREE_CLUSTER SIS_BUFF+$01EC	; SIS First free cluster = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 5612 A2 03			LDX	#4-1
     2 5614 BD 20 18 9D EC 59 + lp	MVA	FREE_CLUSTER,X SIS_BUFF+$01EC,X-
     3 561B 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1192 561D 20 1B 55				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_WRITE command
  1193 5620					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: macros.inc]
     1 5620 A2 C1			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5622 A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1194 5624 20 1D 42				JSR 	DEV_WR_LBLK           		; Write SIS to disk
  1195 5627 4C B2 55				JMP	FREE_KB_UPDATE			; Update FREE_KB and return
  1196
  1197 562A			SIS_DEL		PRSTR	SISM
Macro: PRSTR [Source: macros.inc]
     1 562A A2 52			LDX	<SISM				; MADS makes this immediate
     2 562C A0 56			LDY	>SISM
Source: boot_sys_sh.asm
     2 562E 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1198 5631 AD E8 59 38 ED E8 + 		SBB	SIS_BUFF+$01E8 SIS_CNT		; subtract SIS_CNT from #free clusters in SIS-buffer
  1199 563B B0 03				SCS					; 'skip if C is set' macro
  1200 563D CE E9 59				DEC	SIS_BUFF+$01E9
  1201 5640 B0 03				SCS
  1202 5642 CE EA 59				DEC	SIS_BUFF+$01EA
  1203 5645 B0 03				SCS
  1204 5647 CE EB 59				DEC	SIS_BUFF+$01EB
  1205 564A 4C 09 56				JMP	SIS_WRITE			; write back to disk
  1206 						
  1207 564D 53 49 53 2B 00	SISP		.by	'SIS+' $00
  1208 5652 53 49 53 2D 00	SISM		.by	'SIS-' $00
  1209 						
  1210 				; **** Data Area ***************************************************************
  1211 				; ******************************************************************************
  1212
  1213 				; String Data Area *************************************************************
  1214 5657 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1215 5668 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1216 5679 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1217 567E 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1218 568E 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1219 5699 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)   ' $00
  1220 56A4 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1221 56AC 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1222 56BD 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1223 56CD 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1224 56DD 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1225 56EE 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1226 5700 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1227 5713 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1228 572E 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1229 573C 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1230
  1231 				; ############################################
  1232 574A 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1233 5752 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1234 5757 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1235 5762 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1236 576D 43 4F 4D		EXT_COM         .by    'COM'
  1237 5770 45 58 45		EXT_EXE		.by    'EXE'
  1238 5773 42 41 53		EXT_BAS		.by    'BAS'
  1239 				                
  1240 				; Command Table ****************************************************************
  1241 5776 42 95 57		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1242 5779 43 AA 57				dta	'C' , a(CMD_CD)		
  1243 577C 44 B4 57				dta	'D' , a(CMD_DIR)		
  1244 577F 45 BF 57				dta	'E' , a(CMD_ECHO)		
  1245 5782 47 C6 57				dta	'G' , a(CMD_GOTO)		
  1246 5785 49 CD 57				dta	'I' , a(CMD_IF)		
  1247 5788 4D D2 57				dta	'M' , a(CMD_MKDIR)		
  1248 578B 50 DF 57				dta	'P' , a(CMD_PAUSE)		
  1249 578E 52 E7 57				dta	'R' , a(CMD_REM)
  1250 5791 56 ED 57				dta	'V' , a(CMD_VER)
  1251 5794 00					.byte 	$00
  1252
  1253 5795 05 41 53 49 43 30 + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1254 579C 05 4C 4F 41 44 70 + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1255 57A3 04 52 55 4E 5B 54 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1256 57AA 02 44 B1 52		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1257 57AE 03 4C 53 E7 53 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1258 57B4 03 49 52 4E 50	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1259 57B9 03 45 4C A2 53 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1260 57BF 04 43 48 4F FA 53 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1261 57C6 04 4F 54 4F 09 54 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1262 57CD 02 46 0A 54 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1263 57D2 05 4B 44 49 52 D3 + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1264 57D9 03 4F 4E E7 54 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1265 57DF 05 41 55 53 45 EA + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1266 57E7 03 45 4D 20 54 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
  1267 57ED 03 45 52 DF 54 00	CMD_VER		dta	3, c'ER'  , a(SH_VER)    , $00  ;
    88 				                
    89 				; End Of Program Marker ********************************************************
    90 57F3 00			BOOT_SYS_END    BRK
    91 57F4					ORG ((*/256)+1)*256		; next free page
    92 = 5800			SIS_BUFF	.ds 	512			; SIS Buffer 
    93 = 5A00			FILE_BUFF	.ds	512			; .exe file buffer
    94 						END
