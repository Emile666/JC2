mads 2.1.7 build 33 (1 Aug 24)
Source: bootcf.asm
     1 				; ******************************************************************************
     2 				; The Disk Operating System for 6502 Microprocessors
     3 				;
     4 				; JC2 DOS65, Version 0.2.7 by Emile, original design (V0.2.0) by Joerg Walke
     5 				;
     6 				; Developed for the Junior Computer ][
     7 				;
     8 				; First implementation 6.7.2023, updated 20.06.2024, by Joerg Walke
     9 				; Assembled with A65, Converted to MADS by Emile
    10 				;
    11 				; DOS65 is primarily a small Disk Operation System (DOS) based on the FAT
    12 				; filesystem. This version is for the CF-IDE interface with FAT32 only.
    13 				; A CF-Card can be partitioned with up to four primary partitions.
    14 				; Using the MKBOOTCF program you can write the needed Partition Boot Block and
    15 				; the Master Boot Record which then holds a menu program to select one of the
    16 				; available partitions for booting.
    17 				;
    18 				; This code is freely available under the Creative Commons Attribution 4.0
    19 				; International license, see https://creativecommons.org/licenses/by/4.0/
    20 				; ******************************************************************************
    21
    22 = 0030			VERMAIN   	EQU     '0'    		; main version
    23 = 0032			VERPSUB    	EQU     '2'    		; primary sub version
    24 = 0037			VERSSUB		EQU	'7'		; secondary sub version
    25
    26 				; List Of Changes **************************************************************
    27 				; V0.2.1: 11-04-25 Emile boot.asm renamed in bootcf.asm and adapted for CF-IDE interface.
    28 				; V0.2.2: 19-05-25 ZP-vars reorganised, too much overlap with BIOS
    29 				; V0.2.3: - OS_LOAD_COM renamed in OS_LOAD_FILE, now loads .bas, .com and .exe files
    30 				;         - Macro's added, start of code-reorganisation.
    31 				;	  - File (3350 lines) split in separate smaller files.
    32 				; V0.2.4: - .BAS LOAD file now works, filename bug-fix and NUM32 bug-fix
    33 				;	  - Bug-fix MKDIR run after DIR command
    34 				;	  - SIS added + total KB printed with DIR command
    35 				; V0.2.5: - DEL command added.
    36 				; V0.2.6: - SAVE from BASIC added, CFC_SAVE, OS_CREATE, OS_CREATE_FILE changed,
    37 				;           OS_SAVE_FILE and LINK_FAT_ENTRY added.
    38 				;         - VER command added.
    39 				;         - Bug-fixes OS_LOAD_FILE when 1) #clusters = 1 2) sectors/cluster = 1
    40 				; V0.2.7: Couple of bug-fixes with path-name string and CD command.
    41 				; ******************************************************************************
    42 						OPT h- ; do not add file header
    43 						OPT f+ ; save as single block
    44
    45 				;------------------------------------------------------------------------------------------------
    46 				; TERMINOLOGY AND FORMULAS USED:
    47 				; 
    48 				; Sector                : A sector consists of 512 bytes.
    49 				; Cluster               : Consists of one or more sectors as defined by D_SECT_PER_CLST.
    50 				;                         This is a 24-bit number relative to the cluster_begin_lba number.
    51 				; LBA                   : Logical Block Address, a 32-bit address for a sector on the CF/SD-card.
    52 				; Cluster_nr            : number of a cluster relative to the cluster_begin_lba Number
    53 				; root_dir_1st_cluster  : the 1st cluster in a partition, contains the root directory
    54 				; 
    55 				; fat_begin_lba         : D_START_FAT1 = partition_lba_begin + nr_of_reserved_sectors
    56 				; cluster_begin_lba     : D_START_CLS_LBA = fat_begin_lba + (number_of_FATs * Sectors_per_FAT)
    57 				; Sectors_per_Cluster   : D_SECT_PER_CLST (written by bootcode.fat32 during boot)
    58 				; root_dir_first_cluster: D_START_DIR, this is usually 2
    59 				; lba_addr = cluster_begin_lba + (cluster_nr - 2) * sectors_per_cluster
    60 				;------------------------------------------------------------------------------------------------
    61
    62 = 0001			DBG_PRINT	EQU	1			; Set to 1 for debug print-outs
    63
    64 						ICL "macros.inc"		; boot.sys macro definitions for MADS
Source: macros.inc
     1 				;-------------------------------------------------
     2 				; Macro-definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				.macro	PRHEX16	b16				; Print WORD (16-bit) as 2 hex-bytes
     8 					LDA	:b16+1				; print MSB
     9 					JSR	HEXOUT
    10 					LDA	:b16
    11 					JSR	HEXOUT				; print LSB
    12 				.endm
    13
    14 				.macro	PRHEX32	b32				; Print DWORD (32-bit) as 4 hex-bytes
    15 					PRHEX16	:b32+2				; Print MSB word first
    16 					PRHEX16	:b32				; Print LSB word
    17 				.endm
    18
    19 				.macro	LDXYI	b16
    20 					LDX	<:b16				; MADS makes this immediate
    21 					LDY	>:b16
    22 				.endm
    23
    24 				.macro	LDXY	b16				; Load [X,Y] Pointer
    25 					LDX	:b16
    26 					LDY	:b16+1
    27 				.endm
    28
    29 				.macro	STXY	b16				; Store [X,Y] Pointer
    30 					STX	:b16
    31 					STY	:b16+1
    32 				.endm
    33
    34 				.macro	PRSTR	str				; Print String
    35 					LDXYI	:str
    36 					JSR	OS_STRING_OUT
    37 				.endm
    38
    39 				.macro	PRCH	ch				; Print single character
    40 					LDA	#:ch
    41 					JSR	COUT
    42 				.endm
    43 					
    44 				.macro	ASL32	b32				; ASL of 32-bit DWORD
    45 					ASL     :b32		  		; SHL with C=0
    46 				        ROL     :b32+1		  
    47 				        ROL     :b32+2
    48 				        ROL     :b32+3		  
    49 				.endm
    50
    51 				.macro	LSR32	b32				; LSR of 32-bit DWORD
    52 					LSR     :b32+3		  		; SHR with C=0
    53 				        ROR     :b32+2
    54 				        ROR     :b32+1
    55 				        ROR     :b32
    56 				.endm
    57
    58 				.macro	LSR16	b16				; LSR of 16-bit WORD
    59 					LSR	:b16+1
    60 					ROR	:b16
    61 				.endm
    62
    63 				.macro	PHW	b16				; Push WORD onto stack
    64 					LDA	:b16
    65 					PHA
    66 					LDA	:b16+1
    67 					PHA
    68 				.endm
    69
    70 				.macro	PLW	b16				; Pull WORD from stack
    71 					PLA
    72 					STA	:b16+1
    73 					PLA
    74 					STA	:b16
    75 				.endm
    76
    77 				.macro	PHY					; Push Y-register
    78 					TYA
    79 					PHA
    80 				.endm
    81
    82 				.macro	PLY					; Pull Y-register
    83 					PLA
    84 					TAY
    85 				.endm
    86
    87 				.macro	MVAX	n src dst			; Move n bytes from SRC to DST using X as index
    88 					LDX	#:n-1
    89 				lp	MVA	:src,X :dst,X-
    90 					BPL	lp
    91 				.endm
    92 					
    93 				.macro	MVAY	n src dst			; Move n bytes from SRC to DST using Y as index
    94 					LDY	#:n-1
    95 				lp	MVA	:src,Y :dst,Y-
    96 					BPL	lp
    97 				.endm
    98
    99 				; Macros used for printing a cluster nr, which consists of 2 words
   100 				.macro	PRCLB	c st				; This prints a byte and optionally saves it
   101 						LDA	(:c),Y
   102 					ift :0>1	; st also given?
   103 						STA	:st
   104 					eif	
   105 						JSR	HEXOUT			; changes Y!
   106 				.endm		
   107
   108 				.macro	PRCLW	indx	curr_dir stor		; Print a word of a cluster nr and save it (optional)
   109 						LDY	#:indx+1		; Print MSB of word
   110 					ift :0>2	; stor also given?	
   111 						PRCLB	:curr_dir :stor+1
   112 					els	
   113 						PRCLB	:curr_dir
   114 					eif
   115 						LDY	#:indx			; Print LSB of word
   116 					ift :0>2	; stor also given?	
   117 						PRCLB	:curr_dir :stor
   118 					els	
   119 						PRCLB	:curr_dir
   120 					eif
   121 				.endm
   122
   123 				BTST	.macro ' '	b1 b2 lbl1		; Bit test (7-0) combined with branch if equal
   124 					ift :b2>7
   125 						ERT "Only bits 7-0 allowed"
   126 					els
   127 						LDA	:b1
   128 						AND	#(1 << :b2)
   129 						BEQ	:lbl1
   130 					eif
   131 				.endm
   132 					
   133 				; ----------------------------------------------
   134 				; Compare + Branch Macros
   135 				; ----------------------------------------------
   136 				CMP.EQ	.macro ' '	b1 lbl			; Compare A with b1 and branch if equal
   137 						CMP	:b1
   138 						BEQ	:lbl
   139 				.endm		; A is now not equal to b1
   140 					
   141 				CMP.NE	.macro ' '	b1 lbl			; Compare A with b1 and branch if not equal
   142 						CMP	:b1
   143 						BNE	:lbl
   144 				.endm		; A is now equal to b1
   145
   146 					; Compare A with b1 and branch if Carry is 0 (A-b1 < 0)
   147 				CMP.CC	.macro ' '	b1 lbl
   148 						CMP	:b1			; 
   149 						BCC	:lbl			; branch if C=0 (A-b1 < 0)
   150 				.endm		; C is now 1 (A-b1 is >= 0)
   151
   152 					; Compare A with b1 and branch if Carry is 1 (A-b1 >= 0)
   153 				CMP.CS	.macro ' '	b1 lbl
   154 						CMP	:b1			; 
   155 						BCS	:lbl			; branch if C=1 (A-b1 >= 0)
   156 				.endm		; C is now 0 (A-b1 is < 0)
   157
   158 				CPX.EQ	.macro ' '	b1 lbl			; Compare X with b1 and branch if equal
   159 						CPX	:b1
   160 						BEQ	:lbl
   161 				.endm		; X is now not equal to b1
   162 					
   163 				CPX.NE	.macro ' '	b1 lbl			; Compare X with b1 and branch if not equal
   164 						CPX	:b1
   165 						BNE	:lbl
   166 				.endm		; X is now equal to b1
   167
   168 					; Compare X with b1 and branch if Carry is 0 (A-b1 < 0)
   169 				CPX.CC	.macro ' '	b1 lbl
   170 						CPX	:b1			; 
   171 						BCC	:lbl			; branch if C=0 (X-b1 < 0)
   172 				.endm		; C is now 1 (X-b1 is >= 0)
   173
   174 					; Compare X with b1 and branch if Carry is 1 (X-b1 >= 0)
   175 				CPX.CS	.macro ' '	b1 lbl
   176 						CPX	:b1			; 
   177 						BCS	:lbl			; branch if C=1 (X-b1 >= 0)
   178 				.endm		; C is now 0 (X-b1 is < 0)
   179
   180 				CPY.EQ	.macro ' '	b1 lbl			; Compare Y with b1 and branch if equal
   181 						CPY	:b1
   182 						BEQ	:lbl
   183 				.endm		; Y is now not equal to b1
   184 					
   185 				CPY.NE	.macro ' '	b1 lbl			; Compare Y with b1 and branch if not equal
   186 						CPY	:b1
   187 						BNE	:lbl
   188 				.endm		; Y is now equal to b1
   189
   190 					; Compare Y with b1 and branch if Carry is 0 (Y-b1 < 0)
   191 				CPY.CC	.macro ' '	b1 lbl
   192 						CPY	:b1			; 
   193 						BCC	:lbl			; branch if C=0 (Y-b1 < 0)
   194 				.endm		; C is now 1 (Y-b1 is >= 0)
   195
   196 					; Compare Y with b1 and branch if Carry is 1 (Y-b1 >= 0)
   197 				CPY.CS	.macro ' '	b1 lbl
   198 						CPY	:b1			; 
   199 						BCS	:lbl			; branch if C=1 (Y-b1 >= 0)
   200 				.endm		; C is now 0 (Y-b1 is < 0)
   201
   202 				; ----------------------------------------------
   203 				; Increment/Decrement + Branch Macros
   204 				; ----------------------------------------------
   205 				DEC.EQ	.macro 	' '	b1 lbl			; DEC + BEQ
   206 						DEC	:b1
   207 						BEQ	:lbl
   208 				.endm
   209
   210 				DEC.NE	.macro 	' '	b1 lbl			; DEC + BNE
   211 						DEC	:b1
   212 						BNE	:lbl
   213 				.endm
   214
   215 				INC.EQ	.macro 	' '	b1 lbl			; INC + BEQ
   216 						INC	:b1
   217 						BEQ	:lbl
   218 				.endm
   219
   220 				INC.NE	.macro 	' '	b1 lbl			; INC + BNE
   221 						INC	:b1
   222 						BNE	:lbl
   223 				.endm
   224
   225 				; ----------------------------------------------
   226 				DEX.NE	.macro 	lbl				; DEX + BNE
   227 						DEX
   228 						BNE	:lbl
   229 				.endm
   230
   231 				DEX.EQ	.macro 	lbl				; DEX + BEQ
   232 						DEX
   233 						BEQ	:lbl
   234 				.endm
   235
   236 				DEX.PL	.macro 	lbl				; DEX + BPL 
   237 						DEX
   238 						BPL	:lbl
   239 				.endm
   240
   241 				DEX.MI	.macro 	lbl				; DEX + BMI
   242 						DEX
   243 						BMI	:lbl
   244 				.endm
   245
   246 				DEX.CC	.macro 	lbl				; DEX + BCC 
   247 						DEX
   248 						BCC	:lbl
   249 				.endm
   250
   251 				DEX.CS	.macro 	lbl				; DEX + BCS
   252 						DEX
   253 						BCS	:lbl
   254 				.endm
   255
   256 				; ----------------------------------------------
   257 				DEY.EQ	.macro 	lbl				; DEY + BEQ
   258 						DEY
   259 						BEQ	:lbl
   260 				.endm
   261
   262 				DEY.NE	.macro 	lbl				; DEY + BNE
   263 						DEY
   264 						BNE	:lbl
   265 				.endm
   266
   267 				DEY.PL	.macro 	lbl				; DEY + BPL 
   268 						DEY
   269 						BPL	:lbl
   270 				.endm
   271
   272 				DEY.MI	.macro 	lbl				; DEY + BMI
   273 						DEY
   274 						BMI	:lbl
   275 				.endm
   276
   277 				DEY.CC	.macro 	lbl				; DEY + BCC 
   278 						DEY
   279 						BCC	:lbl
   280 				.endm
   281
   282 				DEY.CS	.macro 	lbl				; DEY + BCS
   283 						DEY
   284 						BCS	:lbl
   285 				.endm
   286 				; ----------------------------------------------
   287
   288 				; ----------------------------------------------
   289 				; LOAD/STORE + Branch Macros
   290 				; ----------------------------------------------
   291 				LDA.EQ	.macro 	' '	b1 lbl			; LDA + BEQ
   292 						LDA	:b1
   293 						BEQ	:lbl
   294 				.endm
   295
   296 				LDA.NE	.macro 	' '	b1 lbl			; LDA + BNE
   297 						LDA	:b1
   298 						BNE	:lbl
   299 				.endm
   300
   301 				STA.EQ	.macro 	' '	b1 lbl			; STA + BEQ
   302 						STA	:b1
   303 						BEQ	:lbl
   304 				.endm
   305
   306 				STA.NE	.macro 	' '	b1 lbl			; STA + BNE
   307 						STA	:b1
   308 						BNE	:lbl
   309 				.endm
   310
   311 				; ----------------------------------------------
   312 				; AND/OR + Branch Macros
   313 				; ----------------------------------------------
   314 				AND.EQ	.macro 	' '	p1 p2 p3		; LDA + AND + BEQ
   315 					ift :0>2	; LDA + AND + BEQ	
   316 						LDA	:p1
   317 						AND	:p2
   318 						BEQ	:p3
   319 					els		; AND + BEQ
   320 						AND	:p1
   321 						BEQ	:p2
   322 					eif
   323 				.endm
   324
   325 				AND.NE	.macro 	' '	p1 p2 p3		; LDA + AND + BNE
   326 					ift :0>2	; LDA + AND + BNE	
   327 						LDA	:p1
   328 						AND	:p2
   329 						BNE	:p3
   330 					els		; AND + BNE
   331 						AND	:p1
   332 						BNE	:p2
   333 					eif
   334 				.endm
    65 						ICL "defines.inc"		; boot.sys defines
Source: defines.inc
     1 				;-------------------------------------------------
     2 				; Register Definitions for BOOT.SYS file.
     3 				; Assembler: MADS-Assembler
     4 				; V0.1: 22-05-25, Emile first version
     5 				;-------------------------------------------------
     6
     7 				; Global Constants and Variables ***********************************************
     8 = 0000			LAB_WARM	= 	$00		; BASIC warm start entry point
     9 = 0001			Wrmjpl 		= 	LAB_WARM+1	; BASIC warm start vector jump low byte
    10 = 0002			Wrmjph 		= 	LAB_WARM+2	; BASIC warm start vector jump high byte
    11 = B000			LAB_COLD	=	$B000		; BASIC cold START
    12
    13 = 00A0			ZP_BASE         EQU     $A0		; Reserved for DOS and boot.sys
    14 = 00A0			CURR_CLUSTER    EQU     ZP_BASE         ; $A0..$A3 (32 bit) - current addressed cluster
    15 = 00A4			CURR_FAT_BLK    EQU     ZP_BASE+4       ; $A4..$A7 (32 bit) - current loaded FAT LBA
    16 = 00A8			CURR_DIR_ENTRY  EQU     ZP_BASE+8       ; $A8..$A9 (16 bit) - pointer to current addressed directory entry
    17 = 00AA			MASK            EQU     ZP_BASE+10	; $AA Mask for FAT table
    18 = 00AB			BCNT            EQU     ZP_BASE+11      ; $AB Block Counter
    19 = 00AC			NCNT            EQU     ZP_BASE+12	; $AC
    20 = 00AD			SCNT            EQU     ZP_BASE+13	; $AD Sector counter within a cluster
    21 = 00AE			RES             EQU     ZP_BASE+14	; $AE
    22
    23 = 0078			ssptr_l		EQU	$78		; BASIC filename pointer LSB
    24 = 0079			ssptr_h		EQU	$79		; BASIC filename pointer MSB
    25
    26 = 00C0			NUM32      	EQU   	$C0     	; low 32 bit number byte (moved from $F8)
    27 = 00C4			SUM32           EQU     $C4             ; low 32 bit number byte (moved from $FC)
    28 = 00CC			END_PTR		EQU	$CC		; CFC_LOAD destination pointer, also used by BIOS ROM checksum routine
    29 = 00D8			SAVEX		EQU 	$D8		; Temp. save X register (same as BIOS)
    30 = 00D9			SAVEY		EQU	$D9		; Temp. save Y register (same as BIOS)
    31 = 00DC			BLKBUF		EQU	$DC
    32 = 00DC			BLKBUFL		EQU	$DC             ; Pointer to block buffer, same in BIOS
    33 = 00DD			BLKBUFH		EQU	$DD
    34
    35 = 00E8			STOL      	EQU   	$E8     	; Store address Low, same in BIOS
    36 = 00E9			STOH      	EQU   	$E9     	; Store address High
    37 = 00EA			PSTR            EQU     $EA		; 2-byte ACIA output pointer, same in BIOS
    38 = 00EE			PSAV            EQU     $EE             ; Saved Partition Number in ASCII, same in BIOS
    39
    40 = 00F8			DIG0      	EQU   	$F8     	; 10^0 digit, used by NUMOUT and DEC2STR
    41 = 00F9			DIG1	  	EQU   	$F9	 	; 10^1 digit, used by NUMOUT and DEC2STR
    42 = 00FA			DIG2      	EQU   	$FA     	; 10^2 digit, used by NUMOUT and DEC2STR
    43
    44 = 1400			STRBUF	  	EQU   	$1400    	; input string buffer at $1400 (same as BIOS)
    45
    46 = 1806			CF_LOAD_VEC	EQU	$1806		; 2-byte vector for CF-card LOAD vector
    47 = 1808			CF_SAVE_VEC	EQU	$1808		; 2-byte vector for CF-card SAVE vector
    48 = 180A			RETURN_VECT     EQU     $180A           ; return vector to monitor caller in V1.2.1 (was $0001 in V1.2.0)
    49
    50 = 1810			NEXTINDEX       EQU     $1810		; command index
    51 = 1811			TERM_CHAR       EQU     $1811
    52 = 1812			F_ATTRIBS       EQU     $1812
    53 = 1813			TERM_FLAG       EQU     $1813		; set/clear counter termination flag
    54 = 1814			LINE_CNT        EQU     $1814		; line-counter for DIR command
    55 = 1815			CURR_FILE_CNT   EQU     $1815      	; (16 bit) - total number of files in dir
    56 = 1817			CURR_DIR_CNT    EQU     $1817      	; (16 bit) - total number of directories in dir
    57 = 1819			CURR_USED_SIZE  EQU     $1819      	; (32 bit) - total number of bytes in dir
    58 = 181D			CURR_BLK_NUM    EQU     $181D      	; directory block counter
    59 = 181E			CURR_DRIVE      EQU     $181E      	; current selected drive
    60 = 181F			CURR_CMD_PARAM  EQU     $181F      	; current command parameter
    61 = 1820			FREE_CLUSTER    EQU     $1820           ; (32 bit) - last free cluster
    62 = 1824			CURR_DIR_BLK    EQU     $1824       	; (32 bit) - current directory LBA
    63
    64 				; External Routines ************************************************************
    65
    66 = E003			MON_WARM_START  EQU     $E003
    67
    68 = E00A			SWITCH_TO_ROM	EQU	$E00A			; Switch Basic to ROM Page ($B000-$DFFF)
    69 = E052			COUT            EQU     $E052
    70 = E05A			CROUT           EQU     $E05A
    71 = E05E			SPCOUT          EQU     $E05E
    72 = E047			CIN             EQU     $E047
    73 = E062			STRIN           EQU     $E062
    74 = E083			STROUT          EQU     $E083
    75 = E085			WRSTR           EQU     $E085
    76 = E091			HEXOUT          EQU     $E091
    77 = E09A			HEXDIG          EQU     $E09A
    78 = E0BD			DEC2STR         EQU     $E0BD
    79 = E0B5			CLRSCRN         EQU     $E0B5
    80 = E0BA			CMDDEV          EQU     $E0BA
    81 = E1AA			OPEN_DEVICE     EQU     $E1AA
    82 = E2DE			READTIME        EQU     $E2DE			; BIOS v1.2.1
    83 = E2E2			READDATE        EQU     $E2E2			; BIOS v1.2.1
    84 = F682			OS_STRING_OUT	EQU	$F682			; SPRINT in BIOS v1.2.1, but same routine
    85 = FD7D			MON2ROM		EQU	$FD7D			; Monitor to ROM
    86 = FD86			MON2RAM		EQU	$FD86			; Monitor to RAM, enable RAM behind it
    87
    88 				; Tables and Buffers ***********************************************************
    89 = 0200			DIR_BLK_BUF     EQU     $0200           	; Directory Block Buffer
    90 = 0200			DIR_BLK_BUFL    EQU     DIR_BLK_BUF     	; Lower page of directory buffer
    91 = 0300			DIR_BLK_BUFH    EQU     DIR_BLK_BUF+$100	; upper page of directory buffer
    92
    93 = 0400			CURR_VOLUME     EQU     $0400           	; Current Volume Descriptor
    94 = 0420			FILE_TABLE      EQU     CURR_VOLUME+$20  	; File Descriptor Table
    95 = 0500			MOUNT_TABLE     EQU     $0500           	; Table of mounted devices
    96 = 0600			BLOCK_BUFF      EQU     $0600           	; Data Block Buffer
    97
    98 = 5830			SIS_OFFSET	EQU	SIS_BUFF+$30		; 2-bytes: System Information Sector Offset
    99
   100 = 2000			BAS_LOAD_ADDR	EQU	$2000			; .BAS Load-address
   101 = 3000			COM_RUN_ADDR	EQU	$3000			; .COM load- and run-address
   102
   103 				; Device IDs *******************************************************************
   104 = 0000			NULL_ID		EQU	$00             	; the NULL device
   105 = 0022			FDD1_ID         EQU     $22             	; Floppy drive 1 device ID
   106 = 0023			FDD2_ID         EQU     $23             	; Floppy drive 2 device ID
   107 = 0024			SDC_ID		EQU     $24             	; SD-Card device ID
   108 = 0025			HDD1_ID		EQU     $25             	; CF-Card device ID
   109
   110 				; FAT Types ********************************************************************
   111 = 0002			FAT12_Type      EQU     $02
   112 = 0001			FAT16_Type      EQU     $01
   113 = 0000			FAT32_Type      EQU     $00
   114
   115 				; Device Driver Commands *******************************************************
   116 = 0022			CMD_READ	EQU	34              	; Read data block from device
   117 = 0023			CMD_WRITE	EQU	35              	; Write data block to device
   118 = 0025			CMD_READ_BUF	EQU	37              	; Read data block from device to standard buffer
   119 = 0026			CMD_WRITE_BUF	EQU	38              	; Write data block to device from standard buffer
   120
   121 				; Miscellaneous Constants ******************************************************
   122 = 000D			CR              EQU     $0D             	; Carriage Return ASCII Code
   123 = 0020			SPC             EQU     $20             	; Space ASCII Code
   124 = 005C			BSLASH          EQU     '\'             	; Backslash ASCII Code
   125 = 002F			FSLASH		EQU     '/'             	; Forward slash ASCII Code
   126 = 002E			DOT             EQU     '.'             	; Dot ASCII Code
   127 = 003A			COLON           EQU     ':'             	; Colon ASCII Code
   128 = 002C			COMMA           EQU     ','             	; Comma ASCII Code
   129 = 002D			MINUS           EQU     '-'             	; Minus ASCII Code
   130 = 005F			ULINE           EQU     '_'             	; Underline ASCII Code
   131
   132 				; Interchangeable Chars ********************************************************
   133 = 003E			PROMPT          EQU     '>'             	; Command Line Prompt Char
   134 = 002E			NUM_SEP         EQU     DOT	           	; Thousand Seperator Char
   135 = 005C			PATH_SEP        EQU     BSLASH          	; Path Seperator Char
   136 = 002F			OPT_SEP         EQU     FSLASH           	; Option Prefix Char
   137
   138 				; File Attributes **************************************************************
   139 = 0001			FA_READONLY     EQU     $01             	; file is read only
   140 = 0002			FA_HIDDEN       EQU     $02             	; file is hidden
   141 = 0004			FA_SYSTEM       EQU     $04             	; file is a system file
   142 = 0008			FA_LABEL        EQU     $08             	; file is a volume label
   143 = 0010			FA_DIRECTORY    EQU     $10             	; file is a directory
   144 = 0020			FA_ARCHIVE      EQU     $20             	; file is modified
   145 = 0040			FA_RESERVED1    EQU     $40
   146 = 0080			FA_LINK         EQU     $80             	; file is a link
   147
   148 				; Device Attributes ************************************************************
   149 = 0080			DA_DIRTY        EQU     $80             ; current FAT block is modified
   150
   151 				; Current Volume Descriptor (32 Bytes) *****************************************
   152 				; The BOOT routine in BIOS has already loaded the MBR into $0600, laoded the
   153 				; Volume-ID sector into $0400 and did set (most of) these variables.
   154 = 0400			D_PART_START	EQU	CURR_VOLUME+$00		; 4 Bytes - Volume ID sector LBA
   155 = 0404			D_ACTUAL_DIR    EQU     CURR_VOLUME+$04     	; 4 Bytes - Actual Directory cluster number
   156 = 0408			D_DEV_ID        EQU     CURR_VOLUME+$08 	; 1 Byte  - Device ID
   157 = 0409			D_MEDIUM_DESCR  EQU     CURR_VOLUME+$09 	; 1 Byte  - Medium Descriptor Byte
   158 										;           or Partition Number in ASCII if harddisk
   159 = 040A			D_FAT_TYPE      EQU     CURR_VOLUME+$0A 	; 1 Byte  - FAT Type (0=FAT32)
   160 = 040B			D_SECT_PER_CLST EQU     CURR_VOLUME+$0B 	; 1 Byte  - Sectors/Cluster
   161 = 040C			D_NUM_OF_FAT    EQU     CURR_VOLUME+$0C 	; 1 Byte  - Number of FATs
   162 = 040D			D_NUM_ROOT_DIR  EQU     CURR_VOLUME+$0D 	; 2 Bytes - Number of Root directory Entries
   163 = 040F			D_DEV_ATTRIBS   EQU     CURR_VOLUME+$0F 	; 1 Byte  - Device Attributes
   164 = 0410			D_START_CLS_LBA EQU     CURR_VOLUME+$10 	; 4 Bytes - Start LBA of Cluster Area (= cluster_begin_lba - 2)
   165 = 0414			D_START_FAT1    EQU     CURR_VOLUME+$14 	; 4 Bytes - Start LBA of FAT1
   166 = 0418			D_START_FAT2    EQU     CURR_VOLUME+$18 	; 4 Bytes - Start LBA of FAT2
   167 = 041C			D_START_DIR     EQU     CURR_VOLUME+$1C 	; 4 Bytes - root_dir_first_cluster (usually 2), also LBA nr for FAT16/12
   168
   169 = 0420			D_SUBDIR_NAME	EQU	FILE_TABLE+$00		; 11 Bytes - Name of entire path (root dir is \)
   170 					
   171 				; Directory Descriptor (32 Bytes) **********************************************
   172
   173 = 0000			D_FILENAME      EQU     $00             	; 8 Bytes - 8 Character Filename
   174 = 0008			D_FILEEXT       EQU     $08             	; 3 Bytes - 3 Character File Extension
   175 = 000B			D_ATTRIBUTES    EQU     $0B             	; 1 Byte  - File Attributes
   176 = 000E			D_CREATE_TIME   EQU     $0E             	; 2 Bytes - Creation Time
   177 = 0010			D_CREATE_DATE	EQU	$10			; 2 Bytes - Create Date 
   178 = 0012			D_ACCESS_DATE   EQU     $12             	; 2 Bytes - Last Accessed Date
   179 = 0014			D_START_CLSTH   EQU     $14             	; 2 Bytes - Start Cluster High Word (FAT32)
   180 = 0016			D_LAST_WR_TIME  EQU     $16             	; 2 Bytes - Last Write Time
   181 = 0018			D_LAST_WR_DATE  EQU     $18             	; 2 Bytes - Last Write Date
   182 = 001A			D_START_CLST    EQU     $1A             	; 2 Bytes - Start Cluster Low Word
   183 = 001C			D_FILE_SIZE     EQU     $1C             	; 4 Bytes - File Size
   184
   185
    66 						
    67 				.if	USE_XMODEM = 1
    68 					.word	PROG_START			; Needed for XMODEM lm command loading .bin files
    69 				.endif
    70
    71 				; ******************************************************************************
    72 				; Start of 1st Block of BOOT.SYS ***********************************************
    73 				; ******************************************************************************
    74 = 4000			LOAD_ADDRESS	EQU	$4000
    75 						ORG	LOAD_ADDRESS		; the program start address
    76 				PROG_START					; Program Start Address
    77 						ICL 	"boot_sys_block1.asm"	; boot.sys first block (< 512 bytes)
Source: boot_sys_block1.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the first block of the BOOT.SYS file. This first block
     3 				; MUST fit into a single sector of 512 bytes. This first sector is already
     4 				; loaded into memory by the boot-block loader on the CF-card.
     5 				;
     6 				; The main purpose of this first block is to load the remainder of BOOT.sys
     7 				; into memory and then to execute it.
     8 				; 
     9 				; Assembler: MADS-Assembler
    10 				; V0.1: 22-05-25, Emile first version
    11 				;-------------------------------------------------------------------------------
    12
    13 				; subtract two clusters from START_CLUSTER address *****************************
    14 4000 AD 0B 04		INIT            LDA     D_SECT_PER_CLST		; Written by FAT32 boot-code
    15 4003 0A			                ASL     			; A = 2 * D_SECT_PER_CLST
    16 4004 AA			                TAX				; X = 2 * D_SECT_PER_CLST 
    17 4005 AD 10 04		                LDA     D_START_CLS_LBA		; This is cluster_begin_lba
    18 4008 8E 10 04		                STX     D_START_CLS_LBA		; D_START_CLS_LBA = 2 * D_SECT_PER_CLST
    19 400B 38 ED 10 04				SUB	D_START_CLS_LBA		; A = D_START_CLS_LBA - 2 * D_SECT_PER_CLST
    20 400F 8D 10 04		                STA     D_START_CLS_LBA		; D_START_CLS_LBA -= 2 * D_SECT_PER_CLST
    21 4012 A2 01		                LDX     #$01
    22 4014 A0 03		                LDY     #$03
    23 4016 BD 10 04		INIT2           LDA     D_START_CLS_LBA,X	; D_START_CLS_LBA is 32-bits
    24 4019 E9 00		                SBC     #$00
    25 401B 9D 10 04 E8		                STA     D_START_CLS_LBA,X+
    26 401F			                DEY.NE	INIT2			; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 401F 88					DEY
     2 4020 D0 F4				BNE	INIT2
Source: boot_sys_block1.asm
    27 				                
    28 				; initialize current FAT block value with 0 ************************************
    29 4022 84 A4		                STY     CURR_FAT_BLK		; CURR_FAT_BLK = 0L
    30 4024 84 A5		                STY     CURR_FAT_BLK+1
    31 4026 84 A6		                STY     CURR_FAT_BLK+2
    32 4028 84 A7		                STY     CURR_FAT_BLK+3
    33 				                
    34 				; set first cluster of BOOT.SYS as the current cluster *************************
    35 402A A0 15		INIT3           LDY     #$15
    36 402C A2 03		                LDX     #$03
    37 402E 20 74 40		                JSR     SET_WORD            	; store cluster start byte [3:2]
    38 4031 A0 1B		                LDY     #$1B
    39 4033 20 74 40		                JSR     SET_WORD            	; store cluster start byte [1:0]
    40 				                
    41 				; calculate BOOTS.SYS file size in blocks **************************************
    42 4036 A9 57		INIT4           LDA     #>BOOT_SYS_END      	; Cal. total nr of blocks needed to load the complete
    43 4038 38 E9 40		                SUB     #>PROG_START        	; BOOT.SYS file into memory
    44 403B 4A			                LSR     		    	; 2 pages = 1 sector of 512 bytes
    45 403C 85 AB		                STA     BCNT                	; store result into block counter
    46 403E			                LDA.EQ  #<BOOT_SYS_END BOOT_SYS	; branch if LSB is 0
Macro: LDA.EQ [Source: macros.inc]
     1 403E A9 D5				LDA	#<BOOT_SYS_END
     2 4040 F0 02				BEQ	BOOT_SYS
Source: boot_sys_block1.asm
    47 4042 E6 AB		                INC     BCNT                	; some bytes are left, so increment block counter
    48 				                
    49 				; load all blocks of BOOT.SYS file into memory *********************************
    50 4044			BOOT_SYS        DEC.EQ  BCNT OS_START          	; first block is already read in, branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 4044 C6 AB				DEC	BCNT
     2 4046 F0 29				BEQ	OS_START
Source: boot_sys_block1.asm
    51 4048 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    52 404D			LOAD_NEXT_BLK   DEC.EQ  SCNT NEXT_CLUSTER      	; branch if all blocks in cluster read
Macro: DEC.EQ [Source: macros.inc]
     1 404D C6 AD				DEC	SCNT
     2 404F F0 10				BEQ	NEXT_CLUSTER
Source: boot_sys_block1.asm
    53 4051 20 81 41		                JSR     INC_32              	; no, increment block address
    54 4054			LOAD_BLK        LDXYI   NUM32			; NUM32 contains LBA of a boot.sys cluster
Macro: LDXYI [Source: macros.inc]
     1 4054 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4056 A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
    55 4058 20 4B 41		                JSR     DEV_RD_LBLK         	; and read next block of BOOT.SYS
    56 405B			                DEC.EQ  BCNT OS_START		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 405B C6 AB				DEC	BCNT
     2 405D F0 12				BEQ	OS_START
Source: boot_sys_block1.asm
    57 405F D0 EC		                BNE     LOAD_NEXT_BLK       	; yes, read next block in cluster
    58
    59 				; next cluster needs to be loaded considering the volume FAT type **************
    60 4061 20 7E 40		NEXT_CLUSTER    JSR     GET_NEXT_CLSTR      	; get next cluster in chain in CURR_CLUSTER
    61 4064 B0 0B		                BCS     OS_START            	; if EOF then start OS
    62 						
    63 4066 20 F8 40		                JSR     CLUSTER_TO_BLK      	; convert CURR_CLUSTER to LBA number in NUM32
    64 4069 AD 0B 04 85 AD	                MVA	D_SECT_PER_CLST SCNT	; SCNT = D_SECT_PER_CLST
    65 406E 4C 54 40		                JMP     LOAD_BLK            	; load first block of cluster
    66 				                
    67 4071 4C 22 42		OS_START        JMP     OS_MAIN             	; jump to OS entry point
    68
    69 				;-------------------------------------------------------------------------------
    70 				; Copy a word, that is part of a cluster nr for boot.sys, into CURR_CLUSTER.
    71 				; PSTR is already set by the FAT boot-block routine.
    72 				;-------------------------------------------------------------------------------
    73 4074 20 77 40		SET_WORD        JSR     SET_BYTE
    74 4077 B1 EA 88 95 A0 CA	SET_BYTE        MVA	(PSTR),Y- CURR_CLUSTER,X- 	; load a byte from dir entry and store in CURR_CLUSTER
    75 407D 60			                RTS
    76 						
    77 				; **** Get Next Cluster Of Cluster Chain ***************************************
    78 				; Input:  CURR_CLUSTER[0:3] - current cluster
    79 				; Output: C = 0 valid cluster in CURR_CLUSTER[0:3]; C = 1 EOF
    80 				; ******************************************************************************
    81 407E			GET_NEXT_CLSTR  LDXYI   D_START_FAT1      	; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 407E A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 4080 A0 04			LDY	>D_START_FAT1
Source: boot_sys_block1.asm
    82 4082 20 61 41		                JSR     LOAD_32		    	; NUM32 = LBA nr. of FAT
    83
    84 4085			                LDA.EQ  D_FAT_TYPE  FAT32      	; check FAT type and branch if FAT32 (0)
Macro: LDA.EQ [Source: macros.inc]
     1 4085 AD 0A 04				LDA	D_FAT_TYPE
     2 4088 F0 14				BEQ	FAT32
Source: boot_sys_block1.asm
    85 408A					CMP.EQ	#FAT16_Type FAT16	; branch if FAT16
Macro: CMP.EQ [Source: macros.inc]
     1 408A C9 01				CMP	#FAT16_TYPE
     2 408C F0 01				BEQ	FAT16
Source: boot_sys_block1.asm
    86 				                
    87 				; **** Decode FAT12 Entry ******************************************************
    88 				; **** Two FAT12 entries A and B coded together as AA BA BB ********************
    89 408E 60			FAT12           RTS				; Removed for DEBUG
    90
    91 				; **** Decode FAT16 Entry ******************************************************
    92 				; **** a FAT16 cluster C is coded as CC CC *************************************
    93 408F A6 A1		FAT16           LDX     CURR_CLUSTER+1      	; load byte 2 of current cluster
    94 4091 20 83 41		                JSR     ADD_32_8            	; and add it to FAT base block address
    95 4094 20 1D 41		                JSR     LOAD_FAT_BLK        	; load this block
    96 4097 A5 A0		                LDA     CURR_CLUSTER        	; load index into the FAT block
    97 4099 A2 02		                LDX     #$02                	; two bytes to read for a FAT16 entry
    98 409B 4C BE 40				JMP	READ_FAT_ENTRY
    99 						
   100 				; **** Decode FAT32 Entry ******************************************************
   101 				; **** a FAT32 cluster C is coded as CC CC CC 0C *******************************
   102 409E			FAT32           LDXYI	(CURR_CLUSTER+1)		; Get CURR_CLUSTER+1 into SUM32
Macro: LDXYI [Source: macros.inc]
     1 409E A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 40A0 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_block1.asm
   103 40A2 20 5B 41				JSR     LOAD_S32            	; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   104 40A5 A2 00 86 C7				MVX	#$00 SUM32+3		; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   105 40A9 A0 03		                LDY     #$03
   106 40AB A5 A0		                LDA     CURR_CLUSTER        	; load CURR_CLUSTER[0] = FAT entry index byte
   107 40AD 0A			                ASL                         	; shift bit 7 into carry flag and multiply entry index by 2
   108 40AE 48			                PHA                         	; save entry index to stack
   109 40AF 36 C4 E8		FAT32_LOOP      ROL     SUM32,X+             	; shift bit 7 of entry index into bit 0 of block index
   110 40B2			                DEY.NE  FAT32_LOOP	    	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 40B2 88					DEY
     2 40B3 D0 FA				BNE	FAT32_LOOP
Source: boot_sys_block1.asm
   111 						
   112 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   113 40B5 20 8F 41		                JSR     ADD_32_32	    	; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   114 40B8 20 1D 41		                JSR     LOAD_FAT_BLK	    	; Load FAT sector into standard buffer ($600)
   115 40BB 68			                PLA                         	; restore entry index
   116 40BC A2 04		                LDX     #$04                	; four bytes to read for a FAT32 entry
   117 				;               JMP     (RW_FAT_ENTRY)      	; Fall-through to READ_FAT_ENTRY
   118 				                
   119 				; **** Read FAT 16 or FAT 32 Entry *********************************************
   120 				; INPUT : X - Length of FAT Entry in Bytes
   121 				; OUTPUT: C = 0: Valid Cluster in CURR_CLUSTER[0:3]; C = 1: EOF
   122 				; example: 08000000 => next cluster = 8: A=RES=$00, C=0
   123 				;          FFFFFF0F => EOF: A=RES=$FF, C=1 
   124 				; ******************************************************************************
   125 				;RW_FAT_ENTRY    .word      READ_FAT_ENTRY
   126 40BE			READ_FAT_ENTRY  
   127 40BE A0 FF 84 AA				MVY     #$FF MASK              	; standard EOF mask is $FF
   128 40C2 0A			                ASL                         	; multiply entry index by 2 (4 in total now)
   129 40C3 A8			                TAY                         	; store entry index into Y
   130 40C4 86 AC		                STX     NCNT                	; store length of entry
   131 40C6 A2 00 86 AE		                MVX     #$00 RES		;
   132 40CA 20 EA 40		LOOP_FAT_ENTRY  JSR     READ_ENTRY_BYTE     	; read entry byte
   133 40CD 95 A0		SET_ENTRY_BYTE  STA     CURR_CLUSTER,X      	; store byte in curr_cluster
   134 40CF 08			                PHP                         	; save carry flag
   135 40D0			                CPX.NE  #$03 CMP_MASK          	; branch if not the upper byte of a FAT32 entry
Macro: CPX.NE [Source: macros.inc]
     1 40D0 E0 03				CPX	#$03
     2 40D2 D0 04				BNE	CMP_MASK
Source: boot_sys_block1.asm
   136 40D4 A2 0F 86 AA		                MVX     #$0F MASK              	; yes, we must change the mask to $0F
   137 40D8			CMP_MASK        CMP.NE 	MASK READ_FAT_ENTRY1   	; cluster byte = EOF mask? Read next byte if not
Macro: CMP.NE [Source: macros.inc]
     1 40D8 C5 AA				CMP	MASK
     2 40DA D0 02				BNE	READ_FAT_ENTRY1
Source: boot_sys_block1.asm
   138 40DC 85 AE		                STA     RES                 	; compare cluster byte is equal EOF mask
   139 40DE 28			READ_FAT_ENTRY1 PLP                         	; restore carry flag
   140 40DF C8			                INY
   141 40E0 E8			                INX
   142 40E1			                DEC.NE  NCNT LOOP_FAT_ENTRY   	; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 40E1 C6 AC				DEC	NCNT
     2 40E3 D0 E5				BNE	LOOP_FAT_ENTRY
Source: boot_sys_block1.asm
   143 40E5 A5 AE		                LDA     RES
   144 40E7 C9 FF		                CMP     #$FF                	; check if result cluster is $FFFF or $0FFFFFFF (EOF)
   145 40E9 60			                RTS
   146 				                
   147 				; **** Read a Single FAT Entry Byte From Block Buffer **************************
   148 				; INPUT : Y - Index To FAT Entry Byte
   149 				; OUTPUT: A = Read Byte from FAT table
   150 				; ******************************************************************************
   151 40EA			READ_ENTRY_BYTE AND.NE  #$01 CURR_CLUSTER+1 RD_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 40EA A9 01				LDA	#$01
     3 40EC 25 A1				AND	CURR_CLUSTER+1
     4 40EE D0 04				BNE	RD_UPPER_PAGE
Source: boot_sys_block1.asm
   152 40F0 B9 00 06		                LDA     BLOCK_BUFF,Y        			; read entry byte from lower half of block buffer
   153 40F3 60			                RTS			    			; return
   154 40F4 B9 00 07		RD_UPPER_PAGE   LDA     BLOCK_BUFF+256,Y    			; read entry byte from upper half of block buffer
   155 40F7 60			                RTS			    			; return
   156 				                
   157 				; **** Calculate LBA From Given Cluster Address ********************************
   158 				; At the start of boot.sys, 2 clusters were already subtracted from D_START_CLS_LBA.
   159 				; Used formula: lba_addr = cluster_begin_lba + (cluster_number-2) * sectors_per_cluster.
   160 				;
   161 				; INPUT : CURR_CLUSTER[0:3] - Current File Cluster number
   162 				; OUTPUT: NUM32[0:3]        - LBA of current file cluster number
   163 				; ******************************************************************************
   164 40F8			CLUSTER_TO_BLK  LDXYI   CURR_CLUSTER
Macro: LDXYI [Source: macros.inc]
     1 40F8 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 40FA A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_block1.asm
   165 40FC 20 61 41		CLSTR_TO_BLK    JSR     LOAD_32		     	; NUM32 = CURR_CLUSTER
   166 40FF AD 0B 04		CLSTR_TO_LBA    LDA     D_SECT_PER_CLST
   167 4102 4A			                LSR      		     	; A = D_SECT_PER_CLST / 2
   168 4103 F0 0E		                BEQ     ADD_START_CLSTR	     	; branch if D_SECT_PER_CLST = 1
   169 						
   170 4105 A2 00		LOOP1           LDX     #$00		     	; NUM32 = CURR_CLUSTER * D_SECT_PER_CLST
   171 4107 A0 04		                LDY     #$04
   172 4109 18			                CLC
   173 410A 36 C0 E8		LOOP2           ROL     NUM32,X+	     	; NUM32 <<= 1
   174 410D			                DEY.NE	LOOP2		     	; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 410D 88					DEY
     2 410E D0 FA				BNE	LOOP2
Source: boot_sys_block1.asm
   175 						
   176 4110 4A			                LSR      		     	; A = D_SECT_PER_CLST >>= 1
   177 4111 D0 F2		                BNE     LOOP1		     	; 
   178 						
   179 4113			ADD_START_CLSTR LDXYI   D_START_CLS_LBA    	; D_START_CLS_LBA = Cluster_begin_lba
Macro: LDXYI [Source: macros.inc]
     1 4113 A2 10			LDX	<D_START_CLS_LBA				; MADS makes this immediate
     2 4115 A0 04			LDY	>D_START_CLS_LBA
Source: boot_sys_block1.asm
   180 4117 20 5B 41		                JSR     LOAD_S32	     	; NUM32 = Cluster_begin_lba
   181 411A 4C 8F 41		                JMP     ADD_32_32	     	; NUM32 = Cluster_begin_lba + CURR_CLUSTER * D_SECT_PER_CLST
   182
   183 				; **** Load A Block From FAT Into The Std Buffer ($600) ************************
   184 				; Input: NUM32: LBA number of FAT sector to load
   185 				; ******************************************************************************
   186 411D A2 03		LOAD_FAT_BLK    LDX     #$03
   187 411F 86 AE		                STX     RES                 	; initialize byte counter
   188 				                
   189 				; check if current FAT block and last loaded FAT block are identical ***********
   190 4121 B5 C0		CHK_FAT_BLK     LDA     NUM32,X             		; load one byte of new block pointer
   191 4123			                CMP.NE 	CURR_FAT_BLK,X SET_CURR_FATBLK	; branch if not the same as the old one
Macro: CMP.NE [Source: macros.inc]
     1 4123 D5 A4				CMP	CURR_FAT_BLK,X
     2 4125 D0 02				BNE	SET_CURR_FATBLK
Source: boot_sys_block1.asm
   192 						
   193 4127 C6 AE		                DEC     RES                 	; if equal decrement number of unequal bytes
   194 4129 95 A4 CA		SET_CURR_FATBLK STA     CURR_FAT_BLK,X-      	; store new block pointer byte as current byte
   195 412C 10 F3		                BPL     CHK_FAT_BLK         	; compare and store more bytes if X >= 0
   196 						
   197 412E A5 AE		                LDA     RES                 	; RES is decremented down to -1 if all bytes equal
   198 4130 30 13		                BMI     LOAD_FAT_END        	; RES = $FF -> FAT block is already loaded, just exit
   199 				                
   200 4132			                PHW	BLKBUF			; save old memory pointer to stack
Macro: PHW [Source: macros.inc]
     1 4132 A5 DC			LDA	BLKBUF
     2 4134 48				PHA
     3 4135 A5 DD			LDA	BLKBUF+1
     4 4137 48				PHA
Source: boot_sys_block1.asm
   201 4138			                LDXYI   NUM32
Macro: LDXYI [Source: macros.inc]
     1 4138 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 413A A0 00			LDY	>NUM32
Source: boot_sys_block1.asm
   202 413C 20 46 41		                JSR     DEV_RD_LBLK_BUF     	; load FAT block into standard buffer ($600)
   203 413F					PLW	BLKBUF			; restore old memory pointer from stack
Macro: PLW [Source: macros.inc]
     1 413F 68				PLA
     2 4140 85 DD			STA	BLKBUF+1
     3 4142 68				PLA
     4 4143 85 DC			STA	BLKBUF
Source: boot_sys_block1.asm
   204 4145 60			LOAD_FAT_END    RTS
   205 				                
   206 				; **** Read Logical Block To Standard Buffer ($0600) ***************************
   207 				; Input: [X,Y] points to 32-bit LBA
   208 				; ******************************************************************************
   209 4146 A9 25		DEV_RD_LBLK_BUF  LDA    #CMD_READ_BUF	        ; Read sector with LBA nr into $0600
   210 4148 4C BA E0		                 JMP    CMDDEV			; Call Device-driver Read routine
   211 				                
   212 				; **** Read Logical Block ******************************************************
   213 				; Input: [X,Y] points to 32-bit LBA
   214 				;        BLKBUF,BLKBUFH = 16 Bit Destination Address
   215 				; ******************************************************************************
   216 414B A9 22		DEV_RD_LBLK     LDA     #CMD_READ	        ; Read sector with LBA nr into BLKBUF
   217 414D 4C BA E0		                JMP     CMDDEV			; Call Device-driver Read routine
   218 				                
   219 				; Arithmetic Functions *********************************************************
   220 				; ******************************************************************************
   221
   222 				; **** Load a 16 Bit Value Into NUM32 ******************************************
   223 				; Input:  UInt16[X,Y] = 16 Bit Unsigned Integer
   224 				; ******************************************************************************
   225 4150			LOAD_16         STXY	NUM32			; Load LSB in NUM32 and MSB in NUM32+1
Macro: STXY [Source: macros.inc]
     1 4150 86 C0			STX	NUM32
     2 4152 84 C1			STY	NUM32+1
Source: boot_sys_block1.asm
   226 4154 A2 00 86 C2 86 C3			MWX	#0 NUM32+2		; Zero upper 16-bits
   227 415A 60			                RTS			   	; return
   228 				                
   229 				; **** Load a 32 Bit Value Into SUM32 ******************************************
   230 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   231 				; ******************************************************************************
   232 415B 86 E8		LOAD_S32        STX     STOL		   	; store pointer LSB
   233 415D A2 07		                LDX     #$07		   	; SUM32 is 4 bytes above NUM32 in memory
   234 415F D0 04		                BNE     LOAD_32_1	   	; branch always
   235
   236 				; **** Load a 32 Bit Value Into NUM32 ******************************************
   237 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   238 				; ******************************************************************************
   239 4161 86 E8		LOAD_32         STX     STOL		   	; store pointer LSB
   240 4163 A2 03		                LDX     #$03
   241 4165 84 E9		LOAD_32_1       STY     STOH		   	; store pointer MSB
   242 4167 A0 03		                LDY     #$03
   243 4169 B1 E8 95 C0 CA	LOOP_LOAD_32    MVA 	(STOL),Y NUM32,X-	; get byte and store in NUM32 (or SUM32)
   244 416E			                DEY.PL  LOOP_LOAD_32	   	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 416E 88					DEY
     2 416F 10 F8				BPL	LOOP_LOAD_32
Source: boot_sys_block1.asm
   245 4171 60			                RTS			   	; return
   246 				                
   247 				; **** Store 32 Bit Value In NUM32 To Destination At Ptr[X,Y] ******************
   248 				; Input:  X,Y = Ptr[LO:HI] to 32 Bit Integer
   249 				; ******************************************************************************
   250 4172			STORE_32        STXY	STOL			; store pointer LSB and MSB
Macro: STXY [Source: macros.inc]
     1 4172 86 E8			STX	STOL
     2 4174 84 E9			STY	STOL+1
Source: boot_sys_block1.asm
   251 4176 A0 03		STORE_32_D      LDY     #$03		   	; 1 DWORD = 4 bytes
   252 4178 B9 C0 00 91 E8 88	LOOP_STORE_32   MVA     NUM32,Y (STOL),Y-   	; get number and store it
   253 417E 10 F8		                BPL     LOOP_STORE_32	   	; branch if not done yet
   254 4180 60			                RTS			   	; return
   255
   256 				; **** Increment a 32 Bit Value ************************************************
   257 				; NUM32[0:3] = 32 Bit Integer - NUM32 = NUM32 + 1
   258 				; ******************************************************************************
   259 4181 A2 01		INC_32          LDX     #$01
   260
   261 				; **** Add a 8 Bit Value To a 32 Bit Value *************************************
   262 				; Input X = 8 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X] + NUM32
   263 				; ******************************************************************************
   264 4183 A0 00		ADD_32_8        LDY     #$00
   265
   266 				; **** Add a 16 Bit Value To a 32 Bit Value ************************************
   267 				; Input X,Y = 16 Bit Integer, NUM32[0:3] = 32 Bit Integer - NUM32 = UInt[X,Y] + NUM32
   268 				; ******************************************************************************
   269 4185			ADD_32_16       STXY	SUM32			; Store byte or word in lower word
Macro: STXY [Source: macros.inc]
     1 4185 86 C4			STX	SUM32
     2 4187 84 C5			STY	SUM32+1
Source: boot_sys_block1.asm
   270 4189 A2 00 86 C6 86 C7			MWX	#0 SUM32+2		; Clear upper 16-bits of DWORD
   271
   272 				; **** Add a 32 Bit Value To a 32 Bit Value ************************************
   273 				; Input SUM32[0:3] = 32 Bit Integer, NUM32[0:3] = 32 Bit Integer  - NUM32 = SUM32 + NUM32
   274 				; ******************************************************************************
   275 418F 18			ADD_32_32       CLC			   	; clear carry flag
   276 4190 A2 00		                LDX     #$00		   	; start with byte 0
   277 4192 08			                PHP			   	; save carry flag
   278 4193 28			ADD_LOOP        PLP			   	; get carry flag back
   279 4194 B5 C4		                LDA     SUM32,X		   	; Get SUM32 byte
   280 4196 75 C0 95 C0		                ADC:STA NUM32,X		   	; num32 = num32 + sum32, save in num32
   281 419A 08			                PHP			   	; save carry flag
   282 419B E8			                INX			   	; next byte
   283 419C			                CPX.NE  #$04 ADD_LOOP		; branch if not all bytes done yet
Macro: CPX.NE [Source: macros.inc]
     1 419C E0 04				CPX	#$04
     2 419E D0 F3				BNE	ADD_LOOP
Source: boot_sys_block1.asm
   284 41A0 28			                PLP			   	; restore stack
   285 41A1 60			                RTS			   	; return
    78 				               
    79 				; ******************************************************************************
    80 				; Start of remaining BOOT.SYS blocks *******************************************
    81 				; ******************************************************************************
    82 41A2					ORG     LOAD_ADDRESS + $0200
    83 4200			BLOCK_2
    84 4200					ICL 	"boot_sys_os.asm"	; OS portion of boot.sys
Source: boot_sys_os.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the OS portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; NUM32 shl X
    10 				; ******************************************************************************
    11 4200			SHL_32          ASL32	NUM32		  	; SHL with C=0
Macro: ASL32 [Source: macros.inc]
     1 4200 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4202 26 C1		        ROL     NUM32+1		  
     3 4204 26 C2		        ROL     NUM32+2
     4 4206 26 C3		        ROL     NUM32+3		  
Source: boot_sys_os.asm
    12 4208			                DEX.NE	SHL_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4208 CA					DEX
     2 4209 D0 F5				BNE	SHL_32
Source: boot_sys_os.asm
    13 420B 60			                RTS			  	; return
    14
    15 				; ******************************************************************************
    16 				; NUM32 shr X
    17 				; ******************************************************************************
    18 420C			SHR_32          LSR32	NUM32			; SHR with C=0
Macro: LSR32 [Source: macros.inc]
     1 420C 46 C3			LSR     NUM32+3		  		; SHR with C=0
     2 420E 66 C2		        ROR     NUM32+2
     3 4210 66 C1		        ROR     NUM32+1
     4 4212 66 C0		        ROR     NUM32
Source: boot_sys_os.asm
    19 4214			                DEX.NE  SHR_32		  	; decrement #shifts, branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 4214 CA					DEX
     2 4215 D0 F5				BNE	SHR_32
Source: boot_sys_os.asm
    20 4217 60			                RTS			  	; return
    21 				                
    22 				; **** Write Logical Block From Standard Buffer ********************************
    23 				; Input: [X,Y] points to 32-bit LBA
    24 4218 A9 26		DEV_WR_LBLK_BUF  LDA    #CMD_WRITE_BUF	  	; Call Device-driver Write routine
    25 421A 4C BA E0		                 JMP    CMDDEV
    26
    27 				; **** Write Logical Block *****************************************************
    28 				; Input: [X,Y] points to 32-bit destination LBA
    29 				;        BLKBUF,BLKBUFH = 16 Bit Source Address
    30 421D A9 23		DEV_WR_LBLK      LDA     #CMD_WRITE		; Call Device-driver Write routine
    31 421F 4C BA E0		                 JMP     CMDDEV
    32
    33 				; ******************************************************************************
    34 				; *                               OS Entry Point                               *
    35 				; ******************************************************************************
    36 4222			OS_MAIN         PRSTR	MSG_BOOT			; Print boot-message
Macro: PRSTR [Source: macros.inc]
     1 4222 A2 33			LDX	<MSG_BOOT				; MADS makes this immediate
     2 4224 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_os.asm
     2 4226 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
    37 4229 20 41 49		                JSR     OS_SET_ROOT_DIR	     		; set D_ACTUAL_DIR and CURR_DIR_BLK to root-dir
    38 				                
    39 				; Init CFC LOAD and SAVE VECTORS ***********************************************
    40 422C A9 64 8D 06 18 A9 + 		MWA	#CFC_LOAD CF_LOAD_VEC		; macro CF_LOAD_VEC = CFC_LOAD, Used by BASIC with CMD_LOAD
    41 4236 A9 9A 8D 08 18 A9 + 		MWA	#CFC_SAVE CF_SAVE_VEC		; macro CF_SAVE_VEC = CFC_SAVE, Used by BASIC with CMD_SAVE
    42 4240 A9 9E 8D 0A 18 A9 + 		MWA	#OS_SHELL_ENTRY RETURN_VECT	; Return-vector for Monitor and BASIC
    43 424A A2 00 86 01 86 02			MWX	#0 Wrmjpl			; Reset BASIC warm-start vector, so that a reboot is also a BASIC cold-start
    44 				                
    45 				; Clear Mount Table ************************************************************
    46 4250 18			                CLC
    47 4251 A9 00 9D 08 05	CLR_MOUNT_TABLE MVA	#NULL_ID MOUNT_TABLE+8,X	; set device ID to NULL device
    48 4256 8A					TXA                          		; index to mount table into A
    49 4257 69 20		                ADC     #$20                 		; set to next entry
    50 4259 AA			                TAX
    51 425A 90 F5		                BCC     CLR_MOUNT_TABLE      		; repeat until all entries cleared
    52 				                
    53 				; Set Boot Device As Current Device ********************************************
    54 425C A2 00		                LDX     #$00		     	; X=0
    55 425E A0 00		                LDY     #$00                 	; set index to mount table = 0
    56 4260 AD 08 04		                LDA     D_DEV_ID             	; get boot device ID
    57 4263			CHECK_FDC1      CMP.EQ  #FDD1_ID SET_BOOT_DRV	; If boot drive is FDD1, set current drive to A:
Macro: CMP.EQ [Source: macros.inc]
     1 4263 C9 22				CMP	#FDD1_ID
     2 4265 F0 0A				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    58 4267 E8			                INX		     	     	; X=2
    59 4268 A0 20		                LDY     #$20                 	; set index to mount table = 32
    60 426A			CHECK_FDC2      CMP.EQ  #FDD2_ID SET_BOOT_DRV	; If boot drive is FDD2, set current drive to B:
Macro: CMP.EQ [Source: macros.inc]
     1 426A C9 23				CMP	#FDD2_ID
     2 426C F0 03				BEQ	SET_BOOT_DRV
Source: boot_sys_os.asm
    61 426E E8			                INX                          	; else set current drive (SDD or a HDD) to C:
    62 426F A0 40		                LDY     #$40                 	; set index to mount table = 64
    63 4271 8E 1E 18		SET_BOOT_DRV    STX     CURR_DRIVE	     	; 0=FDD1, 1=FDD2, 2=SD/CF card
    64
    65 				; Add Boot Device To Mount Table ***********************************************
    66 4274 A2 00		                LDX     #$00
    67 4276 BD 00 04 E8 99 00 + ADD_DEVBLK      MVA 	CURR_VOLUME,X+ MOUNT_TABLE,Y+	; read from current device block and write to mount table
    68 427E			                CPX.NE  #32 ADD_DEVBLK         		; 32 bytes to copy
Macro: CPX.NE [Source: macros.inc]
     1 427E E0 20				CPX	#32
     2 4280 D0 F4				BNE	ADD_DEVBLK
Source: boot_sys_os.asm
    69 4282 A9 F8		                LDA     #$F8
    70 4284			                CMP.NE  D_MEDIUM_DESCR CHK_FAT_TYPE	; Branch if boot device is not a harddisk
Macro: CMP.NE [Source: macros.inc]
     1 4284 CD 09 04				CMP	D_MEDIUM_DESCR
     2 4287 D0 05				BNE	CHK_FAT_TYPE
Source: boot_sys_os.asm
    71 4289 A5 EE 8D 09 04	                MVA     PSAV D_MEDIUM_DESCR  		; yes, load partition number (ASCII) and save it as medium descr. byte
    72 428E			CHK_FAT_TYPE    LDA.EQ  D_FAT_TYPE OS_SHELL_ENTRY 	; get type of FAT, branch if FAT32 (0), has no static root directory blocks
Macro: LDA.EQ [Source: macros.inc]
     1 428E AD 0A 04				LDA	D_FAT_TYPE
     2 4291 F0 0B				BEQ	OS_SHELL_ENTRY
Source: boot_sys_os.asm
    73 4293 A2 04		                LDX     #$04		     		; D_NUM_ROOT_DIR is 0 for FAT32
    74 4295			CALC_DIR_BLKS   LSR16	D_NUM_ROOT_DIR	     		; divide #root-dir entries by 16 to get total #blocks
Macro: LSR16 [Source: macros.inc]
     1 4295 4E 0E 04			LSR	D_NUM_ROOT_DIR+1
     2 4298 6E 0D 04			ROR	D_NUM_ROOT_DIR
Source: boot_sys_os.asm
    75 429B					DEX.NE	CALC_DIR_BLKS	     		; branch if not done yet
Macro: DEX.NE [Source: macros.inc]
     1 429B CA					DEX
     2 429C D0 F7				BNE	CALC_DIR_BLKS
Source: boot_sys_os.asm
    76 				                
    77 				; TODO: ADD MORE DEVICES #######################################################
    78
    79 				; **** Shell Entry Point *******************************************************
    80 				; ******************************************************************************
    81 429E 20 30 55		OS_SHELL_ENTRY  JSR	GET_SIS		     		; Get sys. info sector		
    82 42A1 4C A6 4B				JMP     SH_CMD_PROMPT			; start of command shell
    83
    84 				; **** Read First Block Of Actual Directory ************************************
    85 				; The first block of D_ACTUAL_DIR cluster is read into DIR_BLK_BUF
    86 				; ******************************************************************************
    87 42A4			OS_FIRST_DIR_BLK
    88 42A4			                LDA.EQ  D_FAT_TYPE SET_DIR_CLUSTER  	; load type of FAT, branch if FAT32 (set cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 42A4 AD 0A 04				LDA	D_FAT_TYPE
     2 42A7 F0 15				BEQ	SET_DIR_CLUSTER
Source: boot_sys_os.asm
    89 42A9 20 30 49		                JSR     OS_IS_ROOT_DIR       		; No FAT32, is it the root directory?
    90 42AC 90 10		                BCC     SET_DIR_CLUSTER      		; no, set cluster
    91
    92 42AE					MVAX	4 D_START_DIR CURR_DIR_BLK	; CURR_DIR_BLK = LBA root dir., FAT16/FAT12 only
Macro: MVAX [Source: macros.inc]
     1 42AE A2 03			LDX	#4-1
     2 42B0 BD 1C 04 9D 24 18 + lp	MVA	D_START_DIR,X CURR_DIR_BLK,X-
     3 42B7 10 F7			BPL	lp
Source: boot_sys_os.asm
    93 42B9 AE 0D 04		                LDX     D_NUM_ROOT_DIR       		; set block counter
    94 42BC D0 17		                BNE     SET_NUM_BLOCKS       		; branch always
    95
    96 42BE			SET_DIR_CLUSTER MVAX	4 D_ACTUAL_DIR CURR_CLUSTER	; CURR_CLUSTER = D_ACTUAL_DIR, FAT32 and FAT16/FAT12 subdir
Macro: MVAX [Source: macros.inc]
     1 42BE A2 03			LDX	#4-1
     2 42C0 BD 04 04 95 A0 CA	lp	MVA	D_ACTUAL_DIR,X CURR_CLUSTER,X-
     3 42C6 10 F8			BPL	lp
Source: boot_sys_os.asm
    97 42C8 20 F8 40		CONVERT_CLUSTER JSR     CLUSTER_TO_BLK       		; convert CURR_CLUSTER to LBA number in NUM32
    98 42CB			                LDXYI   CURR_DIR_BLK			; LBA of current directory
Macro: LDXYI [Source: macros.inc]
     1 42CB A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42CD A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
    99 42CF 20 72 41		                JSR     STORE_32             		; and save result as current directory block
   100 42D2 AE 0B 04		                LDX     D_SECT_PER_CLST      		; load number of blocks per clusters
   101 42D5 8E 1D 18		SET_NUM_BLOCKS  STX     CURR_BLK_NUM	     		; CURR_BLK_NUM = D_SECT_PER_CLST
   102
   103 				; **** Load Directory Block ****************************************************
   104 				; This routine reads a directory block into DIR_BLK_BUF.
   105 				; It is called from OS_NEXT_DIR_BLK.
   106 				; ******************************************************************************
   107 42D8 A9 00 85 DC A9 02 + OS_LOAD_DIR     MWA	#DIR_BLK_BUF BLKBUF  ; BLKBUF now points to dir block buffer
   108 42E0					LDXYI	CURR_DIR_BLK         ; block number (LBA) to be loaded
Macro: LDXYI [Source: macros.inc]
     1 42E0 A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 42E2 A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   109 42E4 4C 4B 41		                JMP     DEV_RD_LBLK          ; read directory block into DIR_BLK_BUF and return
   110
   111 				; **** Read Next Directory Block ***********************************************
   112 				; The LBA nr in CURR_DIR_BLK is incremented by 1. It is called from OS_DIR_LOOP
   113 				; when CURR_BLK_NUM is between D_SECT_PER_CLST and 1.
   114 				; ******************************************************************************
   115 42E7 A2 00		OS_NEXT_DIR_BLK LDX     #$00
   116 42E9			INC_DIR_BLK     INC.NE  CURR_DIR_BLK,X OS_LOAD_DIR	; increment current directory block and branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 42E9 FE 24 18				INC	CURR_DIR_BLK,X
     2 42EC D0 EA				BNE	OS_LOAD_DIR
Source: boot_sys_os.asm
   117 42EE E8			                INX                          		; overflow, increment next byte
   118 42EF			                CMP.NE  #$04 INC_DIR_BLK     		; increment next byte if not all four bytes updated
Macro: CMP.NE [Source: macros.inc]
     1 42EF C9 04				CMP	#$04
     2 42F1 D0 F6				BNE	INC_DIR_BLK
Source: boot_sys_os.asm
   119 42F3 F0 E3		                BEQ     OS_LOAD_DIR          		; branch always
   120
   121 				; **** Read Next Directory Cluster *********************************************
   122 				; Reads a first sector of a directory cluster into DIR_BLK_BUF. It is called
   123 				; from OS_DIR_LOOP and resets CURR_BLK_NUM to D_SECT_PER_CLST.
   124 				; ******************************************************************************
   125 42F5			OS_NEXT_DIR_CLSTR
   126 42F5 20 7E 40		                JSR     GET_NEXT_CLSTR       ; load next directory cluster nr from FAT
   127 42F8 90 CE		                BCC     CONVERT_CLUSTER      ; if not EOF convert it to LBA + load from disk
   128 42FA 60			                RTS			     ; return
   129 				                
   130 				; **** Save Directory Block ****************************************************
   131 				; Write directory in DIR_BLK_BUF to disk with LBA nr in X,Y.
   132 				; Input: X,Y = Pointer to LBA nr.
   133 				; ******************************************************************************
   134 42FB 86 D8		OS_SAVE_DIR     STX	SAVEX			; TODO: remove SAVEX, SAVEY ?
   135 42FD 84 D9				STY	SAVEY
   136 42FF A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; set source block buffer to DIR_BLK_BUF
   137 4307 A6 D8		                LDX     SAVEX       		; pointer to block number (LBA) to be saved
   138 4309 A4 D9		                LDY     SAVEY
   139 430B 4C 1D 42		                JMP     DEV_WR_LBLK          	; write directory block in DIR_BLK_BUF to LBA in NUM32 and return
   140 				                
   141 				; **** Save FAT Block **********************************************************
   142 				; Write FAT table in BLOCK_BUFF ($0600) to disk with LBA nr in X,Y.
   143 				; Input: X,Y = Pointer to LBA nr.
   144 				; ******************************************************************************
   145 430E			OS_SAVE_FAT     LDXYI	CURR_FAT_BLK		; LBA nr of FAT
Macro: LDXYI [Source: macros.inc]
     1 430E A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 4310 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_os.asm
   146 4312 4C 18 42		                JMP     DEV_WR_LBLK_BUF        	; write FAT buffer and return
   147
   148 				; **** Create New File on Disk *************************************************
   149 				; Input: FILENAME = String8_3
   150 				;        A        = File Attributes
   151 				;        FREE_CLUSTER: contains cluster nr for new File/Dir
   152 				; An empty dir. entry is written with: Filename, Attribute, Date, Time and Cluster Nr.
   153 				; ******************************************************************************
   154 4315 AA			OS_CREATE_FILE  TAX                         		; save attributes into X
   155 4316 A0 00		                LDY     #D_FILENAME         		; set index to filename
   156 4318 B9 9A 4B 91 A8 C8	FILL_FILENAME   MVA     FILENAME,Y (CURR_DIR_ENTRY),Y+	; copy filename into current directory entry
   157 431E			                CPY.CC  #D_ATTRIBUTES FILL_FILENAME 	; branch if not all characters copied?
Macro: CPY.CC [Source: macros.inc]
     1 431E C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4320 90 F6				BCC	FILL_FILENAME			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   158 						
   159 						; Write Attribute
   160 4322 8A			                TXA                         	; yes, get attribute back to A
   161 4323 91 A8		CLEAR_ENTRY     STA     (CURR_DIR_ENTRY),Y  	; copy attributes into current directory entry
   162 4325 A9 00		                LDA     #$00                	; and clear all following bytes to 0
   163 4327 C8			                INY
   164 4328			                CPY.CC  #$20 CLEAR_ENTRY	; branch if not everything cleared yet
Macro: CPY.CC [Source: macros.inc]
     1 4328 C0 20				CPY	#$20			; 
     2 432A 90 F7				BCC	CLEAR_ENTRY			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   165 						
   166 						; Write create-Date and Last-write Date
   167 432C 20 B6 43		GET_DATE_TIME   JSR     OS_FILEDATE         	; get current date as file date
   168 432F 98			                TYA				; Y = MSB
   169 4330 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   170 4332 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write date
   171 4334 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   172 4336 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   173 4339 8A			                TXA				; X = LSB
   174 433A 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file create date
   175 433C A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   176 433E 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file date
   177
   178 						; Write create-Time and last-write Time
   179 4340 20 91 43		                JSR     OS_FILETIME         	; get current time as file time
   180 4343 98			                TYA				; Y = MSB
   181 4344 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   182 4346 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store MSB of file last write time
   183 4348 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   184 434A 91 A8 88		                STA     (CURR_DIR_ENTRY),Y-  	; store MSB of file create date
   185 434D 8A			                TXA				; X = LSB
   186 434E 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB byte of file create time
   187 4350 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   188 4352 91 A8		                STA     (CURR_DIR_ENTRY),Y  	; store LSB of file last write time
   189
   190 						; Write File Cluster Nr High and Low
   191 4354 A0 15				LDY	#D_START_CLSTH+1			; index of MSB of 1st_cluster_high
   192 4356 AD 23 18 91 A8 88			MVA	FREE_CLUSTER+3  (CURR_DIR_ENTRY),Y-	; MSB of new cluster nr
   193 435C AD 22 18 91 A8			MVA	FREE_CLUSTER+2  (CURR_DIR_ENTRY),Y	; LSB of 1st_cluster_high
   194 4361 A0 1B				LDY	#D_START_CLST+1				; index of MSB of 1st_cluster_low
   195 4363 AD 21 18 91 A8 88			MVA	FREE_CLUSTER+1  (CURR_DIR_ENTRY),Y-	; store in MSB of 1st_cluster_low
   196 4369 AD 20 18 91 A8			MVA	FREE_CLUSTER    (CURR_DIR_ENTRY),Y	; store in LSB of 1st_cluster_low
   197 						
   198 436E AD 12 18				LDA     F_ATTRIBS				; Get file/dir attributes again
   199 4371					AND.NE  #FA_DIRECTORY OS_CR_SAV			; create a dir? Branch if it is a dir
Macro: AND.NE [Source: macros.inc]
     6 4371 29 10				AND	#FA_DIRECTORY
     7 4373 D0 15				BNE	OS_CR_SAV
Source: boot_sys_os.asm
   200
   201 4375 A0 1C		                LDY     #D_FILE_SIZE      			; index to file size in dir. entry
   202 4377 AD 50 52 91 A8 C8 + 		MWA	SAVE_LEN (CURR_DIR_ENTRY),Y+		; Save file-length in current dir. entry
   203 4383 A9 00 91 A8 C8 91 + 		MWA	#0 (CURR_DIR_ENTRY),Y			; Set high-word of file-size to 0
   204 						
   205 438A			OS_CR_SAV	LDXYI	CURR_DIR_BLK				; Write new subdir entry in current dir (CURR_DIR_BLK is LBA of current dir block)
Macro: LDXYI [Source: macros.inc]
     1 438A A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 438C A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_os.asm
   206 438E 4C FB 42		                JMP     OS_SAVE_DIR	    			; write this dir entry back to disk and return
   207 				                
   208 				; **** Get Current Time As File Time *******************************************
   209 				; Output: File Time = Word[X,Y]
   210 				; ******************************************************************************
   211 4391 20 DE E2		OS_FILETIME     JSR     READTIME            ; read current time
   212
   213 				; **** Convert Time To File Time ***********************************************
   214 				; Input:  A - HOUR 	in BCD ($00-$23)
   215 				;	  X - MINUTE 	in BCD ($00-$59)
   216 				;	  Y - SECONDS	in BCD ($00-$59)
   217 				; Output: File Time = Word[X,Y]
   218 				; ******************************************************************************
   219 4394			OS_TIME_TO_FILETIME
   220 4394 20 DD 43		                JSR     CONVERT_DATETIME    ; convert BCD date values into binary
   221 4397 85 C0		                STA     NUM32               ; store HOUR into lower byte of Word[NUM32:NUM32+1]
   222 4399 A9 00 85 C1				MVA	#$00 NUM32+1	    ; clear upper byte of result
   223 439D A2 06		                LDX     #$06
   224 439F 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 6 bits
   225 43A2 A5 C5		                LDA     SUM32+1             ; load MINUTE into A
   226 43A4 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   227 43A8 A2 05		                LDX     #$05
   228 43AA 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   229 43AD A5 C6		                LDA     SUM32+2             ; load SECONDS into A
   230 43AF 6A			                ROR                         ; divide SECONDS by 2
   231 43B0 05 C0		                ORA     NUM32               ; and add value into result
   232 43B2 AA			                TAX
   233 43B3 A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   234 43B5 60			                RTS
   235 				                
   236 				; **** Get Current Date As File Date *******************************************
   237 				; Output: File Date = Word[X,Y]
   238 				; ******************************************************************************
   239 43B6 20 E2 E2		OS_FILEDATE     JSR     READDATE            ; read current date
   240
   241 				; **** Convert Date To File Date ***********************************************
   242 				; Input:  A - YEAR 	in BCD ($00-$99)
   243 				; 	  X - MONTH 	in BCD ($01-$12)
   244 				; 	  Y - DAY	in BCD ($01-$31)
   245 				; Output: File Date = Word[X,Y]
   246 				; ******************************************************************************
   247 43B9			OS_DATE_TO_FILEDATE
   248 43B9 20 DD 43		                JSR     CONVERT_DATETIME    ; converte BCD date values into binary
   249 43BC 18 69 14		                ADD     #20                 ; file date starts from 1980, so we have to add 20 to our year 2000 based RTC date
   250 43BF 85 C0		                STA     NUM32               ; store YEAR into lower byte of Word[NUM32:NUM32+1]
   251 43C1 A9 00 85 C1		                MVA     #$00 NUM32+1	    ; clear upper byte of result
   252 43C5 A2 04		                LDX     #$04
   253 43C7 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 4 bits
   254 43CA A5 C5		                LDA     SUM32+1             ; load MONTH into A
   255 43CC 05 C0 85 C0		                ORA:STA NUM32               ; and add value into result
   256 43D0 A2 05		                LDX     #$05
   257 43D2 20 00 42		                JSR     SHL_32              ; shift left NUM32 by 5 bits
   258 43D5 A5 C6		                LDA     SUM32+2             ; load DAY into A
   259 43D7 05 C0		                ORA     NUM32               ; and add value into result
   260 43D9 AA			                TAX
   261 43DA A4 C1		                LDY     NUM32+1             ; result is in Word[X,Y]
   262 43DC 60			                RTS
   263 				                
   264 				; **** Convert BCD Date Or Time Values Into Unpacked Binary ********************
   265 43DD			CONVERT_DATETIME
   266 43DD 85 C4		                STA     SUM32		    ; Year or Hour
   267 43DF					STXY	SUM32+1		    ; X=Month/Minutes, Y=Day/Seconds
Macro: STXY [Source: macros.inc]
     1 43DF 86 C5			STX	SUM32+1
     2 43E1 84 C6			STY	SUM32+1+1
Source: boot_sys_os.asm
   268 43E3 A0 02		                LDY     #$02		    ; 3 bytes to convert
   269 43E5 B9 C4 00		CONVERT_BCD     LDA     SUM32,Y		    ; Get byte
   270 43E8 20 84 4E		                JSR     BCD_TO_BIN	    ; Convert BCD to 8-bit binary
   271 43EB 99 C4 00 88		                STA     SUM32,Y-	    ; Store result back
   272 43EF 10 F4		                BPL     CONVERT_BCD	    ; branch if not done yet
   273 43F1 60			                RTS			    ; return
   274
   275 				; **** Copy First block of File to memory **************************************
   276 				; Input:
   277 				; ******************************************************************************
   278 43F2 20 76 44		COPY_BLK0_DEST	JSR	INIT_FBUF_PTR		; PSTR = Ptr(FILE_BUFF)
   279 43F5					LDA.EQ	FTYPE BASFILE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if .BAS file
Macro: LDA.EQ [Source: macros.inc]
     1 43F5 AD 6C 44				LDA	FTYPE
     2 43F8 F0 2A				BEQ	BASFILE
Source: boot_sys_os.asm
   280 43FA					CMP.EQ	#1 COMFILE		; branch if a .COM file
Macro: CMP.EQ [Source: macros.inc]
     1 43FA C9 01				CMP	#1
     2 43FC F0 16				BEQ	COMFILE
Source: boot_sys_os.asm
   281 						
   282 						; .EXE file (FTYPE=2)
   283 43FE AD 00 5A 8D 0F 45			MVA	FILE_BUFF OS_PROG	; load- and run-address LSB = FILE_BUFF LSB
   284 4404 85 CC				STA	END_PTR			; destination address LSB
   285 4406 AD 01 5A 8D 10 45			MVA	FILE_BUFF+1 OS_PROG+1	; load- and run-address MSB = FILE_BUFF MSB
   286 440C 85 CD				STA	END_PTR+1		; destination address MSB
   287 440E A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; load-address offset: start-address = 2nd byte in FILE_BUFF
   288 4412 D0 1C				BNE	COPY_BLK_DEST		; branch always
   289 						
   290 						; .COM file  (FTYPE=1)
   291 4414 A9 00 8D 0F 45	COMFILE		MVA	#<COM_RUN_ADDR OS_PROG	 ; Load- and run-address LSB
   292 4419 85 CC				STA	END_PTR			 ; destination address LSB
   293 441B A9 30 8D 10 45			MVA	#>COM_RUN_ADDR OS_PROG+1	 ; load- and run-address MSB
   294 4420 85 CD				STA	END_PTR+1		 ; destination address MSB
   295 4422 D0 0C				BNE	COPY_BLK_DEST		 ; branch always
   296 						
   297 						; .BAS file (FTYPE=0)
   298 4424 A9 00 85 CC A9 20 + BASFILE		MWA	#BAS_LOAD_ADDR END_PTR	; destination = BAS_LOAD_ADDR, 1st 2 bytes contain end-address
   299 442C A9 02 85 EA				MVA	#<FILE_BUFF+2 PSTR	; skip first 2 bytes of .BAS file (contains $00 $20)
   300 						
   301 				; **** Copy Second and other blocks of File to Memory **************************
   302 				; Input:
   303 				; ******************************************************************************
   304 4430			COPY_BLK_DEST	PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 4430 A9 5B			LDA	#'['
     2 4432 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   305 4435					PRHEX16	PSTR
Macro: PRHEX16 [Source: macros.inc]
     1 4435 A5 EB			LDA	PSTR+1				; print MSB
     2 4437 20 91 E0			JSR	HEXOUT
     3 443A A5 EA			LDA	PSTR
     4 443C 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   306 443F					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 443F A9 2C			LDA	#','
     2 4441 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   307 4444					PRHEX16	END_PTR
Macro: PRHEX16 [Source: macros.inc]
     1 4444 A5 CD			LDA	END_PTR+1				; print MSB
     2 4446 20 91 E0			JSR	HEXOUT
     3 4449 A5 CC			LDA	END_PTR
     4 444B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   308 444E					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 444E A9 5D			LDA	#']'
     2 4450 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   309 4453 A0 00				LDY	#0
   310 4455 B1 EA 91 CC		CP_BLK0_LP	MVA	(PSTR),Y (END_PTR),Y		; Get byte from buffer and store in destination
   311 4459 E6 CC D0 02 E6 CD			INW	END_PTR				; Increment destination pointer (macro)
   312 445F E6 EA D0 02 E6 EB			INW	PSTR				; Increment buffer pointer (macro)
   313 4465 A5 EB				LDA	PSTR+1				; MSB of buffer pointer
   314 4467					CMP.NE	#>FILE_BUFF+2 CP_BLK0_LP		; branch if not 2 pages (512 bytes) increased yet
Macro: CMP.NE [Source: macros.inc]
     1 4467 C9 5C				CMP	#>FILE_BUFF+2
     2 4469 D0 EA				BNE	CP_BLK0_LP
Source: boot_sys_os.asm
   315 446B 60					RTS					; return
   316 						
   317 446C 00			FTYPE		.byte  	$00				; 0 = .BAS, 1=.COM, 2=.EXE
   318
   319 				; **** Init File Buffer ********************************************************
   320 				; This routine sets BLKBUFL/BLKBUFH to FILE_BUFF
   321 				; ******************************************************************************
   322 446D A9 00 85 DC A9 5A + INIT_FILE_BUFF	MWA	#FILE_BUFF BLKBUFL	; macro BLKBUF = FILE_BUFF
   323 4475 60					RTS				; return
   324 						
   325 				; **** Init File-buffer pointer ************************************************
   326 				; This routine sets PSTR to FILE_BUFF
   327 				; ******************************************************************************
   328 4476 A9 00 85 EA A9 5A + INIT_FBUF_PTR	MWA	#FILE_BUFF PSTR		; macro PSTR = FILE_BUFF
   329 447E 60					RTS				; return
   330
   331 				; **** Load BAS/COM/EXE File ***************************************************
   332 				; Input: CURR_CLUSTER: cluster nr of file to load
   333 				; ******************************************************************************
   334 447F 20 43 48		OS_LOAD_FILE    JSR     OS_FILE_EMPTY       		; check if filesize is 0
   335 4482 90 01		                BCC     OS_LOAD_COM2			; branch if file is not empty
   336 						
   337 4484 60			                RTS                         		; filesize is 0, just do nothing
   338 						
   339 4485			OS_LOAD_COM2    LDXYI   CURR_CLUSTER      		; current cluster nr
Macro: LDXYI [Source: macros.inc]
     1 4485 A2 A0			LDX	<CURR_CLUSTER				; MADS makes this immediate
     2 4487 A0 00			LDY	>CURR_CLUSTER
Source: boot_sys_os.asm
   340 4489 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   341 448C A9 00 85 AB		                MVA     #$00 BCNT              		; init. block counter
   342 						; Emile: This was apparently an error: SCNT was not initialized, now added here
   343 4490 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   344 4495 A0 1D		                LDY     #D_FILE_SIZE+1      		; index to file size in dir. entry
   345 4497 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file size byte 1
   346 4499 4A			                LSR                         		; check if bit 0 is set (bytes 256-511 of buffer)
   347 449A 48			                PHA			    		; save byte: now contains file-size in blocks of 512 bytes
   348 449B B0 06		                BCS     LOAD_COM1           		; yes, add one block
   349 						
   350 449D 88			                DEY					; now points to D_FILE_SIZE LSB
   351 449E			                LDA.EQ  (CURR_DIR_ENTRY),Y LOAD_COM1	; load file size byte 0, branch if 0
Macro: LDA.EQ [Source: macros.inc]
     1 449E B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44A0 F0 01				BEQ	LOAD_COM1
Source: boot_sys_os.asm
   352 44A2 38			                SEC                         		; yes, add one block
   353 44A3 68			LOAD_COM1       PLA
   354 44A4 65 AB 85 AB		                ADC:STA BCNT                		; calc used blocks, BCNT now contains number of blocks
   355 44A8			                CMP.CS  #89 OS_SIZE_ERR         	; branch if file is too big (>88 blocks, 44 KB, $3000-$E000)
Macro: CMP.CS [Source: macros.inc]
     1 44A8 C9 59				CMP	#89			; 
     2 44AA B0 28				BCS	OS_SIZE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   356 						
   357 44AC A0 1E		                LDY     #D_FILE_SIZE+2      		; index to file size entry
   358 44AE			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR	; load file size byte 2, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44AE B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B0 D0 22				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   359 44B2 C8			                INY					; D_FILE_SIZE+3
   360 44B3			                LDA.NE  (CURR_DIR_ENTRY),Y OS_SIZE_ERR 	; load D_FILE_SIZE+3, branch if > 0 -> file is too big
Macro: LDA.NE [Source: macros.inc]
     1 44B3 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 44B5 D0 1D				BNE	OS_SIZE_ERR
Source: boot_sys_os.asm
   361 						
   362 						; Read first part of file into FILE_BUFF
   363 44B7 20 6D 44				JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   364 44BA			                LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44BA A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44BC A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   365 44BE 20 4B 41		                JSR     DEV_RD_LBLK         		; Read first block of file into FILE_BUFF
   366 44C1 20 F2 43				JSR	COPY_BLK0_DEST			; Copy first block to destination
   367 44C4					DEC.EQ	BCNT OS_EXEC_CHK		; Branch if #blocks to read is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44C4 C6 AB				DEC	BCNT
     2 44C6 F0 3E				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   368 44C8					DEC.EQ  SCNT NEXT_CLUSTER0     		; Branch if sectors/cluster is 1
Macro: DEC.EQ [Source: macros.inc]
     1 44C8 C6 AD				DEC	SCNT
     2 44CA F0 2A				BEQ	NEXT_CLUSTER0
Source: boot_sys_os.asm
   369 						
   370 44CC 20 DB 44		                JSR     LOAD_NEXT_BLKS	    		; Load next blocks of file and execute it
   371 44CF A9 25		                LDA     #HDD1_ID   	    		; Replace by D_DEV_ID?
   372 44D1 4C AA E1				JMP     OPEN_DEVICE			; Init. device driver again and return
   373 						
   374 44D4			OS_SIZE_ERR     LDXYI   MSG_SIZE_ERR      		; load error message...
Macro: LDXYI [Source: macros.inc]
     1 44D4 A2 8B			LDX	<MSG_SIZE_ERR				; MADS makes this immediate
     2 44D6 A0 4B			LDY	>MSG_SIZE_ERR
Source: boot_sys_os.asm
   375 44D8 4C C5 49		                JMP     OS_PRINT_ERR			; Print it
   376
   377 				; **** Read Next File Blocks ***************************************************
   378 				; ******************************************************************************
   379 44DB 20 81 41		LOAD_NEXT_BLKS  JSR     INC_32              		; Increment LBA block address in NUM32
   380 44DE 20 6D 44		LOAD_BLK0       JSR	INIT_FILE_BUFF			; Set BLKBUF pointer to FILE_BUFF
   381 44E1					LDXYI   NUM32		    		; NUM32 contains LBA of cluster to read
Macro: LDXYI [Source: macros.inc]
     1 44E1 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 44E3 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   382 44E5 20 4B 41		                JSR     DEV_RD_LBLK         		; and read next block of file into FILE_BUFF
   383 44E8 20 76 44				JSR	INIT_FBUF_PTR			; reset file-buffer pointer PSTR to FILE_BUFF again
   384 44EB 20 30 44				JSR	COPY_BLK_DEST	    		; Copy block to destination
   385 44EE			                DEC.EQ  BCNT OS_EXEC_CHK      		; branch if no more blocks to read
Macro: DEC.EQ [Source: macros.inc]
     1 44EE C6 AB				DEC	BCNT
     2 44F0 F0 14				BEQ	OS_EXEC_CHK
Source: boot_sys_os.asm
   386 44F2					DEC.NE  SCNT LOAD_NEXT_BLKS    		; branch if more blocks in cluster to read
Macro: DEC.NE [Source: macros.inc]
     1 44F2 C6 AD				DEC	SCNT
     2 44F4 D0 E5				BNE	LOAD_NEXT_BLKS
Source: boot_sys_os.asm
   387
   388 				; next cluster needs to be loaded considering the volume FAT type **************
   389 44F6 20 7E 40		NEXT_CLUSTER0   JSR     GET_NEXT_CLSTR	   		; Get next cluster from FAT table in CURR_CLUSTER.
   390 44F9 B0 0B		                BCS     OS_EXEC_CHK	    		; C=1, EOF, go execute File
   391 							
   392 44FB 20 F8 40		                JSR     CLUSTER_TO_BLK	    		; convert CURR_CLUSTER to LBA number in NUM32.
   393 44FE AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   394 4503 4C DE 44		                JMP     LOAD_BLK0	    		; branch always
   395 						
   396 				; Run file if needed ***********************************************************
   397 				; ******************************************************************************
   398 4506			OS_EXEC_CHK	LDA.NE	FTYPE OS_EXECUTE		; 0 = .BAS, 1=.COM, 2=.EXE, branch if an executable file
Macro: LDA.NE [Source: macros.inc]
     1 4506 AD 6C 44				LDA	FTYPE
     2 4509 D0 01				BNE	OS_EXECUTE
Source: boot_sys_os.asm
   399 450B 60					RTS					; return in case of a .BAS file
   400
   401 				; **** Execute File ************************************************************
   402 				; Input:  Ptr[OS_PROG] to Start Address
   403 				; Output: A - Result Code
   404 				; ******************************************************************************
   405 450C 6C 0F 45		OS_EXECUTE      JMP     (OS_PROG)           		; run .com or .exe file
   406 450F 00 00		OS_PROG         .word      $0000
   407 				                
   408 				; **** Save the contents of a file to disk *************************************
   409 				; OS_CREATE/OS_CREATE_FILE has already created an entry in the current directory
   410 				; and allocated the first free cluster (in CURR_CLUSTER) to the file. If the file
   411 				; existed, it was deleted first, so you always have a new first cluster number. 
   412 				; This routine writes all sectors of this file and updates (=links clusters 
   413 				; together) the FAT table. 
   414 				; Input: FREE_CLUSTER: first cluster nr of file to save
   415 				; ******************************************************************************
   416 4511			OS_SAVE_FILE	LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 4511 A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 4513 A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   417 4515 20 FC 40		                JSR     CLSTR_TO_BLK        		; convert cluster number to LBA number in NUM32
   418 4518 A9 FE 8D A5 45 A9 + 		MWA	#$1FFE FSAVE_PTR		; Init. BLKBUF to start of .BAS file to save
   419 4522 20 86 FD				JSR	MON2RAM				; Enable RAM behind Monitor ROM ($1C00-$1FFF)
   420 4525 A9 00 8D FE 1F A9 + 		MWA	#$2000 $1FFE			; Set first word of Basic file to start-address
   421 452F AD 52 52 85 AB	                MVA     SAVE_SECS BCNT      		; init. block counter, SAVE_SECS was calculated by CFC_SAVE
   422 4534 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   423 4539 A9 01 8D CA 55			MVA	#1 SIS_CNT			; #clusters allocated
   424
   425 				; Write sectors/cluster until --BCNT = 0
   426 453E AD A5 45 85 DC AD + SAVE_NXT_BLK	MWA	FSAVE_PTR BLKBUF		; BLKBUF = FSAVE_PTR
   427 4548					LDXYI	NUM32				; LBA number
Macro: LDXYI [Source: macros.inc]
     1 4548 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 454A A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   428 454C 20 1D 42				JSR	DEV_WR_LBLK			; Write another sector to disk
   429 454F EE A6 45 EE A6 45		:2	INC	FSAVE_PTR+1			; BLKBUF += $0200, points to next block in memory to save
   430 4555			                DEC.EQ  BCNT OS_SAVE_X      		; branch if no more blocks to write
Macro: DEC.EQ [Source: macros.inc]
     1 4555 C6 AB				DEC	BCNT
     2 4557 F0 2F				BEQ	OS_SAVE_X
Source: boot_sys_os.asm
   431 4559					DEC.EQ  SCNT SAVE_NXT_CLSTR    		; branch if more blocks in cluster to write
Macro: DEC.EQ [Source: macros.inc]
     1 4559 C6 AD				DEC	SCNT
     2 455B F0 06				BEQ	SAVE_NXT_CLSTR
Source: boot_sys_os.asm
   432 455D 20 81 41				JSR     INC_32				; Increment LBA block address in NUM32
   433 4560 4C 3E 45				JMP	SAVE_NXT_BLK			; branch always
   434 						
   435 				; next cluster needs to be allocated considering the volume FAT type **************
   436 4563			SAVE_NXT_CLSTR	MVAX	4 FREE_CLUSTER PREV_CLUSTER	; PREV_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4563 A2 03			LDX	#4-1
     2 4565 BD 20 18 9D 8B 45 + lp	MVA	FREE_CLUSTER,X PREV_CLUSTER,X-
     3 456C 10 F7			BPL	lp
Source: boot_sys_os.asm
   437 456E 20 A2 47				JSR     OS_ADD_CLUSTER	   		; Find next free cluster in FAT and allocates it (does NOT write FAT back to disk)
   438 4571 20 A7 45				JSR	LINK_FAT_ENTRY			; Link new FREE_CLUSTER to PREV_CLUSTER (does NOT write FAT back to disk)
   439 4574 20 0E 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   440 4577 EE CA 55				INC	SIS_CNT				; #clusters allocated += 1
   441 457A					LDXYI   FREE_CLUSTER      		; free cluster nr, first cluster of created file
Macro: LDXYI [Source: macros.inc]
     1 457A A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 457C A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   442 457E 20 FC 40		                JSR     CLSTR_TO_BLK	    		; convert FREE_CLUSTER to LBA number in NUM32.
   443 4581 AD 0B 04 85 AD	                MVA     D_SECT_PER_CLST SCNT   		; SCNT = numbers of sectors per cluster
   444 4586 D0 B6		                BNE     SAVE_NXT_BLK	    		; branch always
   445
   446 4588 4C 7D FD		OS_SAVE_X	JMP	MON2ROM				; Switch back to Monitor ROM and return
   447
   448 458B 00 00 00 00		PREV_CLUSTER	.dword 	$00000000			; Previous cluster nr of file
   449 458F 4C 69 6E 6B 5F 46 + TXT_LINK	.by	'Link_FAT_Entry: ' $00
   450 45A0 20 74 6F 20 00	TXT_LINK2	.by	' to ' $00
   451 45A5 00 00		FSAVE_PTR	.word	$0000				; File-save Pointer
   452
   453 				; ******************************************************************************
   454 				; Links a new cluster (FREE_CLUSTER) to the current cluster (PREV_CLUSTER) of a file.
   455 				; It also updates (writes) the FAT table.
   456 				; ******************************************************************************
   457 45A7			LINK_FAT_ENTRY	PRSTR	TXT_LINK
Macro: PRSTR [Source: macros.inc]
     1 45A7 A2 8F			LDX	<TXT_LINK				; MADS makes this immediate
     2 45A9 A0 45			LDY	>TXT_LINK
Source: boot_sys_os.asm
     2 45AB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   458 45AE					PRHEX32	PREV_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45AE AD 8E 45			LDA	PREV_CLUSTER+2+1				; print MSB
     2 45B1 20 91 E0			JSR	HEXOUT
     3 45B4 AD 8D 45			LDA	PREV_CLUSTER+2
     4 45B7 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45BA AD 8C 45			LDA	PREV_CLUSTER+1				; print MSB
     2 45BD 20 91 E0			JSR	HEXOUT
     3 45C0 AD 8B 45			LDA	PREV_CLUSTER
     4 45C3 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   459 45C6					PRSTR	TXT_LINK2
Macro: PRSTR [Source: macros.inc]
     1 45C6 A2 A0			LDX	<TXT_LINK2				; MADS makes this immediate
     2 45C8 A0 45			LDY	>TXT_LINK2
Source: boot_sys_os.asm
     2 45CA 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   460 45CD					PRHEX32	FREE_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 45CD AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 45D0 20 91 E0			JSR	HEXOUT
     3 45D3 AD 22 18			LDA	FREE_CLUSTER+2
     4 45D6 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 45D9 AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 45DC 20 91 E0			JSR	HEXOUT
     3 45DF AD 20 18			LDA	FREE_CLUSTER
     4 45E2 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   461 45E5 20 5A E0				JSR	CROUT				; Print CR
   462 45E8 AD 8B 45				LDA	PREV_CLUSTER			; get LSB of PREV_CLUSTER
   463 45EB 0A 0A			:2	ASL					; SHL2, DWORD index in FAT page
   464 45ED A8					TAY					; Y = DWORD byte 0 in FAT page
   465 45EE AD 8C 45				LDA	PREV_CLUSTER+1
   466 45F1 4A					LSR					; check bit 0 of PREV_CLUSTER[1]
   467 45F2 B0 19				BCS	LINK_UPPER_PAGE			; if bit 0 = 1 then write byte to upper half of block
   468 						
   469 						; lower half block of Buffer
   470 45F4 AD 20 18 99 00 06 + 		MWA	FREE_CLUSTER   BLOCK_BUFF,Y	; Write CURR_CLUSTER nr into PREV_CLUSTER FAT entry
   471 4600 AD 22 18 99 02 06 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+2,Y
   472 460C 60					RTS					; return
   473 						
   474 						; upper half block of Buffer
   475 460D AD 20 18 99 00 07 + LINK_UPPER_PAGE	MWA	FREE_CLUSTER   BLOCK_BUFF+256,Y
   476 4619 AD 22 18 99 02 07 + 		MWA	FREE_CLUSTER+2 BLOCK_BUFF+258,Y
   477 4625 60					RTS					; return
   478
   479 				; ******************************************************************************
   480 4626			INIT_FREE_CLUSTER
   481 4626 A9 02 8D 20 18 A9 + 		MWA	#$02 FREE_CLUSTER		; first data cluster is $000002
   482 4630 8D 22 18				STA     FREE_CLUSTER+2
   483 4633 8D 23 18		                STA     FREE_CLUSTER+3
   484 4636 60			                RTS
   485 				                
   486 				; ******************************************************************************
   487 				; Input: FREE_CLUSTER: number of possible free cluster
   488 				; Output: C=1: CURR_CLUSTER is free ; C=0: 
   489 				; ******************************************************************************
   490 4637			OS_NEXT_FREE_CLUSTER
   491 4637			                MVAX	4 FREE_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 4637 A2 03			LDX	#4-1
     2 4639 BD 20 18 95 A0 CA	lp	MVA	FREE_CLUSTER,X CURR_CLUSTER,X-
     3 463F 10 F8			BPL	lp
Source: boot_sys_os.asm
   492 4641 20 7E 40		                JSR     GET_NEXT_CLSTR      		; get FAT entry for current cluster
   493 4644 A2 03		                LDX     #$03
   494 4646			CHK_FREE        LDA.NE  CURR_CLUSTER,X SET_NEXT_CLSTR	; branch if cluster is not free
Macro: LDA.NE [Source: macros.inc]
     1 4646 B5 A0				LDA	CURR_CLUSTER,X
     2 4648 D0 05				BNE	SET_NEXT_CLSTR
Source: boot_sys_os.asm
   495 464A			                DEX.PL	CHK_FREE	    		; branch if not all bytes checked
Macro: DEX.PL [Source: macros.inc]
     1 464A CA					DEX
     2 464B 10 F9				BPL	CHK_FREE
Source: boot_sys_os.asm
   496 464D 38			                SEC                         		; cluster is free, exit with C = 1
   497 464E 60			                RTS
   498
   499 				; ******************************************************************************
   500 				; This routines increments FREE_CLUSTER by 1, called from OS_NEXT_FREE_CLUSTER.
   501 				; ******************************************************************************
   502 464F A2 00		SET_NEXT_CLSTR  LDX     #$00
   503 4651			INC_FREE_CLSTR  INC.NE  FREE_CLUSTER,X CHK_MAX_FAT 		; increment FREE_CLUSTER[0:3], branch if no overflow
Macro: INC.NE [Source: macros.inc]
     1 4651 FE 20 18				INC	FREE_CLUSTER,X
     2 4654 D0 05				BNE	CHK_MAX_FAT
Source: boot_sys_os.asm
   504 4656 E8			                INX						; next byte of FREE_CLUSTER
   505 4657			                CPX.NE  #$04 INC_FREE_CLSTR	 		; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4657 E0 04				CPX	#$04
     2 4659 D0 F6				BNE	INC_FREE_CLSTR
Source: boot_sys_os.asm
   506 						
   507 465B A2 03		CHK_MAX_FAT     LDX     #03					; 3 bytes to check
   508 465D B5 A4		CHK_MAX_FAT2    LDA     CURR_FAT_BLK,X	    			; LBA of current FAT block
   509 465F			                CMP.CC  D_START_FAT2,X OS_NEXT_FREE_CLUSTER	; end of FAT1 reached? No, check next FAT entry
Macro: CMP.CC [Source: macros.inc]
     1 465F DD 18 04				CMP	D_START_FAT2,X			; 
     2 4662 90 D3				BCC	OS_NEXT_FREE_CLUSTER			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   510 4664			                DEX.PL  CHK_MAX_FAT2	      			; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4664 CA					DEX
     2 4665 10 F6				BPL	CHK_MAX_FAT2
Source: boot_sys_os.asm
   511 4667 18			                CLC                         			; no emtpy cluster found, exit with error
   512 4668 60			                RTS
   513
   514 				; ******************************************************************************
   515 				; This routine sets a DWORD in the FAT sector from free to allocated, it is 
   516 				; called from OS_ADD_CLUSTER. The correct FAT page has already been loaded into 
   517 				; BLOCK_BUFF ($600) by OS_NEXT_FREE_CLUSTER -> GET_NEXT_CLUSTER. So the cluster nr
   518 				; in FREE_CLUSTER needs to be allocated in the FAT table.
   519 				; ******************************************************************************
   520 4669			UPDATE_FAT_TABLE
   521 4669					PRCH	'['			; Print [
Macro: PRCH [Source: macros.inc]
     1 4669 A9 5B			LDA	#'['
     2 466B 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   522 466E					PRHEX16	FREE_CLUSTER		; Print FREE_CLUSTER
Macro: PRHEX16 [Source: macros.inc]
     1 466E AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 4671 20 91 E0			JSR	HEXOUT
     3 4674 AD 20 18			LDA	FREE_CLUSTER
     4 4677 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   523 467A					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 467A A9 5D			LDA	#']'
     2 467C 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   524 467F AD 20 18				LDA	FREE_CLUSTER		; get LSB of cluster nr
   525 4682 0A 0A			:2	ASL				; SHL2, DWORD index in FAT page
   526 4684 A8					TAY				; Y = DWORD byte 0 in FAT page
   527 					.rept 3					; Write 3 x $FF into FAT entry
   528 						LDA	#$FF			
   529 						JSR	WRITE_ENTRY_BYTE	
   530 						INY				
   531 					.endr	
Source: REPT
   528 4685 A9 FF				LDA	#$FF			
   528 4687 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 468A C8					INY				
   528 468B A9 FF				LDA	#$FF			
   528 468D 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 4690 C8					INY				
   528 4691 A9 FF				LDA	#$FF			
   528 4693 20 9C 46				JSR	WRITE_ENTRY_BYTE	
   528 4696 C8					INY				
Source: boot_sys_os.asm
   532 4697 A9 0F				LDA	#$0F			; write end marker
   533 4699 4C 9C 46				JMP	WRITE_ENTRY_BYTE	; Write 4th byte ($0F) and return
   534 						
   535 				; **** Write a Single FAT Entry Byte To Block Buffer ***************************
   536 				; INPUT : A = Write Data
   537 				;         Y - Index To FAT Entry Byte
   538 				; ******************************************************************************
   539 469C			WRITE_ENTRY_BYTE
   540 469C AA					TAX
   541 469D AD 21 18		                LDA     FREE_CLUSTER+1
   542 46A0 4A			                LSR				; check bit 0 of free_cluster[1]
   543 46A1 8A			                TXA
   544 46A2 B0 04		                BCS     WR_UPPER_PAGE       	; if bit 0 = 1 then write byte to upper half of block
   545 						
   546 46A4 99 00 06		                STA     BLOCK_BUFF,Y		; write entry byte to lower half of block buffer
   547 46A7 60					RTS				
   548 						
   549 46A8 99 00 07		WR_UPPER_PAGE   STA     BLOCK_BUFF+256,Y	; write entry byte to upper half of block buffer
   550 46AB 60					RTS
   551 				                
   552 				; **** Add Date and Time to subdir entry ***************************************
   553 				; ******************************************************************************
   554 46AC			ADD_DATE_TIME	; Write create-Date and Last-write Date
   555 46AC 20 B6 43				JSR     OS_FILEDATE         	; get current date as file date
   556 46AF 98			                TYA				; Y = MSB
   557 46B0 A0 19		                LDY     #D_LAST_WR_DATE+1     	; set index to last write date MSB
   558 46B2 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write date
   559 46B4 A0 11		                LDY     #D_CREATE_DATE+1     	; set index to create date MSB
   560 46B6 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   561 46B9 8A			                TXA				; X = LSB
   562 46BA 91 DC		                STA     (BLKBUF),Y  		; store LSB of file create date
   563 46BC A0 18		                LDY     #D_LAST_WR_DATE     	; set index to last write date LSB
   564 46BE 91 DC		                STA     (BLKBUF),Y  		; store LSB of file date
   565
   566 						; Write create-Time and last-write Time
   567 46C0 20 91 43		                JSR     OS_FILETIME         	; get current time as file time
   568 46C3 98			                TYA				; Y = MSB
   569 46C4 A0 17		                LDY     #D_LAST_WR_TIME+1     	; set index to last write time MSB
   570 46C6 91 DC		                STA     (BLKBUF),Y  		; store MSB of file last write time
   571 46C8 A0 0F		                LDY     #D_CREATE_TIME+1     	; set index to create time MSB
   572 46CA 91 DC 88		                STA     (BLKBUF),Y-  		; store MSB of file create date
   573 46CD 8A			                TXA				; X = LSB
   574 46CE 91 DC		                STA     (BLKBUF),Y  		; store LSB byte of file create time
   575 46D0 A0 16		                LDY     #D_LAST_WR_TIME     	; set index to last write time LSB
   576 46D2 91 DC		                STA     (BLKBUF),Y  		; store LSB of file last write time
   577 46D4 60					RTS
   578 						
   579 				; **** Add new subdirectory entry to dir buffer ********************************
   580 				; Input: X=1: . subdir, X=2: .. subdir
   581 				; ******************************************************************************
   582 46D5 8A			ADD_NEW_SUBDIR	TXA					; . or .. subdir
   583 46D6 48					PHA					; save it
   584 46D7 A0 00				LDY	#D_FILENAME			; Filename entry
   585 46D9 A9 20 91 DC C8	ANS_FILL_FN	MVA     #' ' (BLKBUF),Y+			; Fill filename entry with spaces
   586 46DE			                CPY.CC  #D_ATTRIBUTES ANS_FILL_FN	; branch if not all chars copied
Macro: CPY.CC [Source: macros.inc]
     1 46DE C0 0B				CPY	#D_ATTRIBUTES			; 
     2 46E0 90 F7				BCC	ANS_FILL_FN			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
   587
   588 46E2 A9 10 91 DC				MVA	#FA_DIRECTORY (BLKBUF),Y		; set directory attribute
   589 46E6 A0 00				LDY	#D_FILENAME			; Filename entry
   590 46E8 A9 2E				LDA	#'.'				; 1 or 2 dots for subdir name
   591 46EA 91 DC C8		ANS_LP1		STA	(BLKBUF),Y+
   592 46ED					DEX.NE	ANS_LP1				; branch if name not done yet
Macro: DEX.NE [Source: macros.inc]
     1 46ED CA					DEX
     2 46EE D0 FA				BNE	ANS_LP1
Source: boot_sys_os.asm
   593
   594 46F0 20 AC 46				JSR	ADD_DATE_TIME			; Add date and time to subdir entry
   595 46F3 68					PLA
   596 46F4					CMP.NE	#1 PARENT_DIR			; branch if .. Subdir
Macro: CMP.NE [Source: macros.inc]
     1 46F4 C9 01				CMP	#1
     2 46F6 D0 1B				BNE	PARENT_DIR
Source: boot_sys_os.asm
   597 					
   598 						; Current subdir .: Write File Cluster Nr High and Low
   599 46F8 A0 15				LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   600 46FA AD 23 18 91 DC 88			MVA	FREE_CLUSTER+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   601 4700 AD 22 18 91 DC			MVA	FREE_CLUSTER+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   602 4705 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   603 4707 AD 21 18 91 DC 88			MVA	FREE_CLUSTER+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   604 470D AD 20 18 91 DC			MVA	FREE_CLUSTER   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   605 4712 60					RTS					; return
   606 						
   607 						; Parent subdir ..: Write File Cluster Nr High and Low
   608 4713 A0 15		PARENT_DIR	LDY	#D_START_CLSTH+1		; index of MSB of 1st_cluster_high
   609 4715 AD 07 04 91 DC 88			MVA	D_ACTUAL_DIR+3 (BLKBUF),Y-	; store in MSB of 1st_cluster_high
   610 471B AD 06 04 91 DC			MVA	D_ACTUAL_DIR+2 (BLKBUF),Y	; store in LSB of 1st_cluster_high
   611 4720 A0 1B				LDY	#D_START_CLST+1			; index of MSB of 1st_cluster_low
   612 4722 AD 05 04 91 DC 88			MVA	D_ACTUAL_DIR+1 (BLKBUF),Y-	; store in MSB of 1st_cluster_low
   613 4728 AD 04 04 91 DC			MVA	D_ACTUAL_DIR   (BLKBUF),Y	; store in LSB of 1st_cluster_low
   614 472D 60					RTS
   615 						
   616 				; **** Add new Directory Cluster to Disk ***************************************
   617 				; Create a new Directory Cluster in DIR_BLK_BUF and write . and .. subdirs in it.
   618 				; ******************************************************************************
   619 472E			ADD_NEW_DIR_CLST
   620 472E A9 00 85 DC A9 02 + 		MWA	#DIR_BLK_BUF BLKBUF	; BLKBUF now points to dir block buffer
   621 4736 A2 01				LDX	#1
   622 4738 A9 00				LDA	#0
   623 473A			ANDIR_LP1	STA.NE	(BLKBUF),Y+ ANDIR_LP1	; Clear dir block buffer (512 bytes) and loop
Macro: STA.NE [Source: macros.inc]
     1 473A 91 DC C8				STA	(BLKBUF),Y+
     2 473D D0 FB				BNE	ANDIR_LP1
Source: boot_sys_os.asm
   624 473F E6 DD				INC	BLKBUF+1		; next page
   625 4741					DEX.PL	ANDIR_LP1		; branch always
Macro: DEX.PL [Source: macros.inc]
     1 4741 CA					DEX
     2 4742 10 F6				BPL	ANDIR_LP1
Source: boot_sys_os.asm
   626 						
   627 4744 A9 02 85 DD				MVA	#>DIR_BLK_BUF BLKBUF+1	; Set to begin of buffer again
   628 4748 A2 01				LDX	#1			; 1 = . subdir entry
   629 474A 20 D5 46				JSR	ADD_NEW_SUBDIR		; add subdir . (current dir)
   630 474D A5 DC 18 69 20 85 + 		ADB	BLKBUFL #$20		; BLKBUF += $20, next dir entry
   631 4754 A2 02				LDX	#2			; 2 = .. subdir entry
   632 4756 20 D5 46				JSR	ADD_NEW_SUBDIR		; add subdir .. (parent dir)
   633
   634 						; and write it to disk
   635 				.if	DBG_PRINT = 1
   636 4759					PRSTR	TXT_CURR_CLST3		; Print 'ADD_NEW_DIR, FREE=$'
Macro: PRSTR [Source: macros.inc]
     1 4759 A2 89			LDX	<TXT_CURR_CLST3				; MADS makes this immediate
     2 475B A0 47			LDY	>TXT_CURR_CLST3
Source: boot_sys_os.asm
     2 475D 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   637 4760					PRHEX32	FREE_CLUSTER		; print FREE_CLUSTER in hex
Macro: PRHEX32 [Source: macros.inc]
     1 4760 AD 23 18			LDA	FREE_CLUSTER+2+1				; print MSB
     2 4763 20 91 E0			JSR	HEXOUT
     3 4766 AD 22 18			LDA	FREE_CLUSTER+2
     4 4769 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
     1 476C AD 21 18			LDA	FREE_CLUSTER+1				; print MSB
     2 476F 20 91 E0			JSR	HEXOUT
     3 4772 AD 20 18			LDA	FREE_CLUSTER
     4 4775 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   638 4778 20 5A E0				JSR	CROUT			; Print CR
   639 				.endif
   640 477B					LDXYI	FREE_CLUSTER		; Write new subdir in cluster with FREE_CLUSTER nr
Macro: LDXYI [Source: macros.inc]
     1 477B A2 20			LDX	<FREE_CLUSTER				; MADS makes this immediate
     2 477D A0 18			LDY	>FREE_CLUSTER
Source: boot_sys_os.asm
   641 477F 20 FC 40				JSR	CLSTR_TO_BLK		; Convert FREE_CLUSTER nr to LBA nr in num32
   642 4782					LDXYI	NUM32			; LBA nr
Macro: LDXYI [Source: macros.inc]
     1 4782 A2 C0			LDX	<NUM32				; MADS makes this immediate
     2 4784 A0 00			LDY	>NUM32
Source: boot_sys_os.asm
   643 4786 4C FB 42				JMP	OS_SAVE_DIR		; Save new subdir to disk and return
   644 						
   645 4789 41 44 44 5F 4E 45 + TXT_CURR_CLST3	.by	'ADD_NEW_DIR_CLST, Free=$' $00
   646
   647 				; **** Add First Cluster To Empty File *****************************************
   648 				; Note: does NOT write FAT table back to disk, only FAT table in memory is updated.
   649 				; ******************************************************************************
   650 47A2 20 26 46		OS_ADD_CLUSTER  JSR	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   651 47A5 20 37 46				JSR     OS_NEXT_FREE_CLUSTER	; Get free cluster in FREE_CLUSTER
   652 47A8 90 03		                BCC     ADD_CLUSTER_END     	; no free cluster found
   653 						
   654 47AA 20 69 46		                JSR     UPDATE_FAT_TABLE	; Allocate FREE_CLUSTER, does NOT write FAT block back to disk
   655 47AD 60			ADD_CLUSTER_END RTS
   656
   657 				; **** Create New File *********************************************************
   658 				; Input:  A = File Attributes
   659 				; Output: C = 0 - Error; C = 1 - No Error
   660 				;         A = $FF - File/Directory already exists; A <> $FF Write Error Codes
   661 				; ******************************************************************************
   662 47AE 8D 12 18		OS_CREATE       STA     F_ATTRIBS           		; save attributes
   663 47B1			                AND.EQ  #FA_DIRECTORY ADD_FILE 		; create a directory? Branch if not (add a file)
Macro: AND.EQ [Source: macros.inc]
     6 47B1 29 10				AND	#FA_DIRECTORY
     7 47B3 F0 07				BEQ	ADD_FILE
Source: boot_sys_os.asm
   664 						
   665 						; Find directory
   666 47B5 20 58 48		                JSR     OS_DIR_EXISTS       		; C=1: dirname already exists
   667 47B8 90 21				BCC	OS_CREATE_CONT			; branch if dirname does not exist yet
   668 47BA B0 4E				BCS	OS_CREATE_ERR			; branch on error
   669
   670 						; Find file
   671 47BC 20 5E 48		ADD_FILE        JSR     OS_FILE_EXISTS      		; check if file already exists
   672 47BF 90 1A				BCC	OS_CREATE_CONT			; branch if file does not exist
   673 						
   674 						; delete file (SH_DEL)	
   675 47C1					PRSTR	TXT_OVERWRITE			; Print 'File exists, overwrite (y/n)?'
Macro: PRSTR [Source: macros.inc]
     1 47C1 A2 0C			LDX	<TXT_OVERWRITE				; MADS makes this immediate
     2 47C3 A0 48			LDY	>TXT_OVERWRITE
Source: boot_sys_os.asm
     2 47C5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   676 47C8 20 47 E0				JSR 	CIN           			; get character
   677 47CB 29 DF				AND 	#$DF            		; uppercase chars only
   678 47CD					CMP.NE 	#'Y' OS_CREATE_ERR    		; if not Y then exit with error
Macro: CMP.NE [Source: macros.inc]
     1 47CD C9 59				CMP	#'Y'
     2 47CF D0 39				BNE	OS_CREATE_ERR
Source: boot_sys_os.asm
   679 47D1					PRSTR	TXT_SH_DEL			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47D1 A2 3B			LDX	<TXT_SH_DEL				; MADS makes this immediate
     2 47D3 A0 48			LDY	>TXT_SH_DEL
Source: boot_sys_os.asm
     2 47D5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   680 47D8 20 B1 53				JSR	SH_DEL_FILE			; Delete file and update FAT table
   681
   682 47DB 20 A2 47		OS_CREATE_CONT	JSR	OS_ADD_CLUSTER			; Return free cluster in FREE_CLUSTER (does NOT write FAT back to disk)
   683 47DE 20 0E 43				JSR	OS_SAVE_FAT			; Write updated FAT buffer back to disk
   684 						; Find a Free dir. entry and fill it with file info and save it to disk
   685 47E1 20 52 48				JSR 	OS_FIND_FREE			; Find a free directory entry in the current directory
   686 				.if	DBG_PRINT = 1
   687 47E4					PRSTR	TXT_FFREE1			; DEBUG
Macro: PRSTR [Source: macros.inc]
     1 47E4 A2 2A			LDX	<TXT_FFREE1				; MADS makes this immediate
     2 47E6 A0 48			LDY	>TXT_FFREE1
Source: boot_sys_os.asm
     2 47E8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_os.asm
   688 47EB					PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 47EB A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 47ED 20 91 E0			JSR	HEXOUT
     3 47F0 A5 A8			LDA	CURR_DIR_ENTRY
     4 47F2 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   689 47F5 20 5A E0				JSR	CROUT				; Print CR
   690 				.endif
   691 47F8 AD 12 18		                LDA     F_ATTRIBS			; Get file/dir attributes
   692 47FB 20 15 43				JSR	OS_CREATE_FILE			; create the file/dir on disk
   693 47FE AD 12 18				LDA     F_ATTRIBS			; Get file/dir attributes again
   694 4801					AND.EQ  #FA_DIRECTORY OS_CREATE_X	; create a file? Branch if it is a file
Macro: AND.EQ [Source: macros.inc]
     6 4801 29 10				AND	#FA_DIRECTORY
     7 4803 F0 03				BEQ	OS_CREATE_X
Source: boot_sys_os.asm
   695 						
   696 4805 20 2E 47				JSR	ADD_NEW_DIR_CLST		; Add new dir cluster with . and .. and save it to disk
   697 4808 38			OS_CREATE_X	SEC					; C=1, OK
   698 4809 60			                RTS					; and return
   699 480A 18			OS_CREATE_ERR   CLC					; C=0, error
   700 480B 60			OS_CREATE_END   RTS					; return
   701 				                
   702 480C 46 69 6C 65 20 65 + TXT_OVERWRITE	.by	'File exists, overwrite (y/n)?' $00
   703 482A 46 72 65 65 20 44 + TXT_FFREE1	.by	'Free Dir Entry $' $00
   704 483B 53 48 5F 44 45 4C + TXT_SH_DEL	.by	'SH_DEL' CR $00
   705
   706 				; **** Test If File Is Empty ************** ************************************
   707 				; Input:  Ptr(CURR_DIR_ENTRY)
   708 				; Output: C = 1 - File is empty; C = 0 - File not empty
   709 				; ******************************************************************************
   710 4843 A2 04		OS_FILE_EMPTY   LDX     #$04
   711 4845 A0 1C		                LDY     #D_FILE_SIZE        			; index to file size
   712 4847 18			                CLC
   713 4848			NEXT_SIZE_BYTE  LDA.NE  (CURR_DIR_ENTRY),Y OS_FILE_EMPTY2	; branch if file-size byte > 0 (file is not empty)
Macro: LDA.NE [Source: macros.inc]
     1 4848 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 484A D0 05				BNE	OS_FILE_EMPTY2
Source: boot_sys_os.asm
   714 484C C8			                INY
   715 484D			                DEX.NE	NEXT_SIZE_BYTE      			; test next byte
Macro: DEX.NE [Source: macros.inc]
     1 484D CA					DEX
     2 484E D0 F8				BNE	NEXT_SIZE_BYTE
Source: boot_sys_os.asm
   716 4850 38			                SEC			    			; C=1: File is empty
   717 4851 60			OS_FILE_EMPTY2  RTS			    			; return
   718
   719 				; **** Check If a directory entry is free or deleted ***************************
   720 				; ******************************************************************************
   721 4852			OS_FIND_FREE   	LDXYI	CB_FIND_FREE_DIR_ENTRY
Macro: LDXYI [Source: macros.inc]
     1 4852 A2 13			LDX	<CB_FIND_FREE_DIR_ENTRY				; MADS makes this immediate
     2 4854 A0 4B			LDY	>CB_FIND_FREE_DIR_ENTRY
Source: boot_sys_os.asm
   722 4856 D0 1A		                BNE     OS_FIND			; branch always
   723
   724 				; **** Check If Directory Already Exists ***************************************
   725 				; ******************************************************************************
   726 4858			OS_DIR_EXISTS   LDXYI   CB_DIR_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 4858 A2 C7			LDX	<CB_DIR_EXISTS				; MADS makes this immediate
     2 485A A0 4A			LDY	>CB_DIR_EXISTS
Source: boot_sys_os.asm
   727 485C D0 14		                BNE     OS_FIND			; branch always
   728 				                
   729 				; **** Check If Directory Is Available *****************************************
   730 				; ******************************************************************************
   731 485E			OS_FILE_EXISTS  LDXYI   CB_FILE_EXISTS
Macro: LDXYI [Source: macros.inc]
     1 485E A2 EB			LDX	<CB_FILE_EXISTS				; MADS makes this immediate
     2 4860 A0 4A			LDY	>CB_FILE_EXISTS
Source: boot_sys_os.asm
   732 4862 D0 0E		                BNE     OS_FIND			; branch always
   733
   734 				; **** Find Directory **********************************************************
   735 				; ******************************************************************************
   736 4864			OS_FIND_PATH    LDXYI   CB_FIND_SUBDIR
Macro: LDXYI [Source: macros.inc]
     1 4864 A2 CA			LDX	<CB_FIND_SUBDIR				; MADS makes this immediate
     2 4866 A0 4A			LDY	>CB_FIND_SUBDIR
Source: boot_sys_os.asm
   737 4868 D0 08		                BNE     OS_FIND			; branch always
   738
   739 				; **** Find File ***************************************************************
   740 				; ******************************************************************************
   741 486A			OS_FIND_FILE    LDXYI   CB_FIND_FILE
Macro: LDXYI [Source: macros.inc]
     1 486A A2 EE			LDX	<CB_FIND_FILE				; MADS makes this immediate
     2 486C A0 4A			LDY	>CB_FIND_FILE
Source: boot_sys_os.asm
   742 				                                           ; fall through to OS_FIND
   743 				                                           
   744 				; **** Find All Files **********************************************************
   745 				; ******************************************************************************
   746 486E A9 FF		OS_FIND_ALL     LDA     #$FF                ; disable total file counting
   747 4870 D0 02		                BNE     OS_FIND2
   748
   749 				; **** Main Find Routine *******************************************************
   750 				; ******************************************************************************
   751 4872 A9 00		OS_FIND         LDA     #$00                ; enable total file counting
   752 4874			OS_FIND2        STXY    CMD_ADDR            ; set command function address
Macro: STXY [Source: macros.inc]
     1 4874 8E 31 4B			STX	CMD_ADDR
     2 4877 8C 32 4B			STY	CMD_ADDR+1
Source: boot_sys_os.asm
   753 				                                            ; fall through to OS_DIR_LOOP
   754
   755 				; **** Loop Through Actual Directory *******************************************
   756 				; Input:  Ptr[X:Y] = Address to command specific function
   757 				;         A = $00 - Enable total file counting; A <> $00 - counting disabled
   758 				; Output: C = 1 - Found; C = 0 - Not Found
   759 				; ******************************************************************************
   760 487A 8D 13 18		OS_DIR_LOOP     STA     TERM_FLAG           			; set/clear counter termination flag
   761 487D A9 00 8D 15 18 8D +                 MWA	#0 CURR_FILE_CNT    			; clear total file counter
   762 4885 20 A4 42		                JSR     OS_FIRST_DIR_BLK    			; load first block of actual directory
   763 4888			LOWER_DIR_BLK   LDXYI   DIR_BLK_BUFL        			; set pointer to lower page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 4888 A2 00			LDX	<DIR_BLK_BUFL				; MADS makes this immediate
     2 488A A0 02			LDY	>DIR_BLK_BUFL
Source: boot_sys_os.asm
   764 488C			SET_CURR_ENTRY  STXY	CURR_DIR_ENTRY	    			; select current directory entry
Macro: STXY [Source: macros.inc]
     1 488C 86 A8			STX	CURR_DIR_ENTRY
     2 488E 84 A9			STY	CURR_DIR_ENTRY+1
Source: boot_sys_os.asm
   765 4890 A0 0B		GET_CURR_ENTRY  LDY     #D_ATTRIBUTES       			; index to file attributes
   766 4892 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  			; load file attributes
   767 4894 AA			                TAX                         			; load attributes into X
   768 4895 A0 00		                LDY     #D_FILENAME         			; index to filename
   769 4897			                LDA.EQ  (CURR_DIR_ENTRY),Y OS_DIR_LOOP_EOF	; load first char of filename and branch if NULL (= last entry)
Macro: LDA.EQ [Source: macros.inc]
     1 4897 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4899 F0 47				BEQ	OS_DIR_LOOP_EOF
Source: boot_sys_os.asm
   770 489B 20 C7 4B		                JSR     CMD_EXECUTE         			; call command routine
   771 489E B0 43		                BCS     OS_DIR_LOOP_END	    			; C=1: OK and return
   772 						
   773 48A0			NEXT_ITEM       LDA.NE  TERM_FLAG END_LOOP_CHK           	; check if count is terminated, branch if flag > 0
Macro: LDA.NE [Source: macros.inc]
     1 48A0 AD 13 18				LDA	TERM_FLAG
     2 48A3 D0 08				BNE	END_LOOP_CHK
Source: boot_sys_os.asm
   774 48A5 EE 15 18 D0 03 EE + 		INW	CURR_FILE_CNT	    			; yes, increment total file counter
   775 48AD A5 A8 18 69 20 85 + END_LOOP_CHK    ADB	CURR_DIR_ENTRY #$20 			; CURR_DIR_ENTRY += $20, next dir. entry
   776 48B4 90 DA		                BCC     GET_CURR_ENTRY	    			; LSB overflow?
   777 						
   778 48B6 A9 00		                LDA     #$00
   779 48B8 65 A9 85 A9		                ADC:STA	CURR_DIR_ENTRY+1    			; MSB +1
   780 48BC			                CMP.NE  #(> DIR_BLK_BUFH)+1 UPPER_DIR_BLK	; branch if we are in 2nd page above 512 B dir buffer
Macro: CMP.NE [Source: macros.inc]
     1 48BC C9 04				CMP	#(> DIR_BLK_BUFH)+1
     2 48BE D0 1B				BNE	UPPER_DIR_BLK
Source: boot_sys_os.asm
   781
   782 48C0			                DEC.NE  CURR_BLK_NUM LOAD_DIR_BLK	    	; CURR_BLK_NUM counts from D_SECT_PER_CLST down to 0, load next block if > 0
Macro: DEC.NE [Source: macros.inc]
     1 48C0 CE 1D 18				DEC	CURR_BLK_NUM
     2 48C3 D0 10				BNE	LOAD_DIR_BLK
Source: boot_sys_os.asm
   783 48C5			                LDA.EQ  D_FAT_TYPE LOAD_DIR_CLSTR          	; get FAT type, branch if FAT32 (load next dir cluster)
Macro: LDA.EQ [Source: macros.inc]
     1 48C5 AD 0A 04				LDA	D_FAT_TYPE
     2 48C8 F0 04				BEQ	LOAD_DIR_CLSTR
Source: boot_sys_os.asm
   784 48CA 24 0B		                BIT     D_ATTRIBUTES        			; else check if root directory
   785 48CC B0 14		                BCS     OS_DIR_LOOP_EOF     			; if root dir and not FAT32, all directory blocks read. Exit
   786
   787 48CE 20 F5 42		LOAD_DIR_CLSTR  JSR     OS_NEXT_DIR_CLSTR   ; load next directory cluster from device
   788 48D1 90 B5		                BCC     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   789 48D3 B0 0D		                BCS     OS_DIR_LOOP_EOF     ; directory EOF reached. Exit
   790
   791 48D5 20 E7 42		LOAD_DIR_BLK    JSR     OS_NEXT_DIR_BLK     ; load next directory block from device
   792 48D8 4C 88 48		                JMP     LOWER_DIR_BLK       ; and reset read pointer to lower page of block buffer
   793
   794 48DB			UPPER_DIR_BLK   LDXYI   DIR_BLK_BUFH        ; set pointer to upper page of block buffer
Macro: LDXYI [Source: macros.inc]
     1 48DB A2 00			LDX	<DIR_BLK_BUFH				; MADS makes this immediate
     2 48DD A0 03			LDY	>DIR_BLK_BUFH
Source: boot_sys_os.asm
   795 48DF 4C 8C 48		                JMP     SET_CURR_ENTRY	    ; branch to begin of loop
   796
   797 48E2 18			OS_DIR_LOOP_EOF CLC			    ; C=1: not found
   798 48E3 60			OS_DIR_LOOP_END RTS			    ; return
   799
   800 				; **** Set Drive Command *******************************************************
   801 				; Input:  A = Drive Number (0..25)
   802 				; Output: C = 0 - Error
   803 				; ******************************************************************************
   804 48E4			OS_SET_DRIVE    CMP.EQ  CURR_DRIVE SET_DRIVE_END	; Branch (just exit) if actual drive equals current drive
Macro: CMP.EQ [Source: macros.inc]
     1 48E4 CD 1E 18				CMP	CURR_DRIVE
     2 48E7 F0 3E				BEQ	SET_DRIVE_END
Source: boot_sys_os.asm
   805 48E9			                CMP.CS  #$08       SET_DRIVE_ERR  	; show error message if actual drive number exceeds max drive?
Macro: CMP.CS [Source: macros.inc]
     1 48E9 C9 08				CMP	#$08			; 
     2 48EB B0 3C				BCS	SET_DRIVE_ERR			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_os.asm
   806 48ED AA			                TAX                         		; save actual drive number to Y
   807 48EE AD 1E 18		                LDA     CURR_DRIVE          		; load current drive number into A
   808 48F1 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   809 48F6 85 E8		                STA     STOL           	    		; and save it to indirect pointer low byte
   810 48F8 A9 05 85 E9		                MVA	#>MOUNT_TABLE STOH  		; set high byte of mount table
   811 48FC					MVAY	$20 CURR_VOLUME (STOL)		; update device descriptor in mount table
Macro: MVAY [Source: macros.inc]
     1 48FC A0 1F			LDY	#$20-1
     2 48FE B9 00 04 91 E8 88	lp	MVA	CURR_VOLUME,Y (STOL),Y-
     3 4904 10 F8			BPL	lp
Source: boot_sys_os.asm
   812 4906 8A			                TXA
   813 4907 0A 0A 0A 0A 0A	        :5      ASL             	    		; multiply current drive number by 32
   814 490C 85 E8		                STA     STOL                		; and save it to indirect pointer low byte
   815 490E A0 08		                LDY     #$08                		; set index to D_DEV_ID
   816 4910			                LDA.EQ  (STOL),Y SET_DRIVE_ERR		; load device ID, if NULL then show error message
Macro: LDA.EQ [Source: macros.inc]
     1 4910 B1 E8				LDA	(STOL),Y
     2 4912 F0 15				BEQ	SET_DRIVE_ERR
Source: boot_sys_os.asm
   817
   818 4914					MVAY    $20 (STOL) CURR_VOLUME	; load device descriptor into CURR_VOLUME
Macro: MVAY [Source: macros.inc]
     1 4914 A0 1F			LDY	#$20-1
     2 4916 B1 E8 99 00 04 88	lp	MVA	(STOL),Y CURR_VOLUME,Y-
     3 491C 10 F8			BPL	lp
Source: boot_sys_os.asm
   819 491E 8E 1E 18		                STX     CURR_DRIVE          	; store actual drive as current drive
   820 4921 AD 08 04		                LDA     D_DEV_ID            	; get current device id
   821 4924 20 AA E1		                JSR     OPEN_DEVICE         	; and open the device driver
   822 4927 38			SET_DRIVE_END   SEC			    	; C=1: no error
   823 4928 60			                RTS
   824
   825 4929			SET_DRIVE_ERR   LDXYI   MSG_DRIVE_ERR	
Macro: LDXYI [Source: macros.inc]
     1 4929 A2 8E			LDX	<MSG_DRIVE_ERR				; MADS makes this immediate
     2 492B A0 56			LDY	>MSG_DRIVE_ERR
Source: boot_sys_os.asm
   826 492D 4C C5 49		                JMP     OS_PRINT_ERR	    	; Print 'Drive not found'
   827
   828 				; **** Test If Root Directory **************************************************
   829 				; Input:
   830 				; Output: C = 1 - is root dir; C = 0 - is not root dir
   831 				; ******************************************************************************
   832 4930 A0 03		OS_IS_ROOT_DIR  LDY     #$03
   833 4932 B9 04 04		COMP_DIR        LDA     D_ACTUAL_DIR,Y	     		; contains cluster nr of actual dir.
   834 4935			                CMP.NE  D_START_DIR,Y OS_IS_ROOT_END	; branch if not a root dir.
Macro: CMP.NE [Source: macros.inc]
     1 4935 D9 1C 04				CMP	D_START_DIR,Y
     2 4938 D0 05				BNE	OS_IS_ROOT_END
Source: boot_sys_os.asm
   835 493A			                DEY.PL	COMP_DIR             		; test next cluster byte
Macro: DEY.PL [Source: macros.inc]
     1 493A 88					DEY
     2 493B 10 F5				BPL	COMP_DIR
Source: boot_sys_os.asm
   836 						
   837 493D 38			                SEC			     		; C=1 => is root dir.
   838 493E 60			                RTS
   839 493F 18			OS_IS_ROOT_END  CLC			     		; C=0 => not a root dir.
   840 4940 60			                RTS
   841
   842 				; **** Set Root Directory Command **********************************************
   843 				; ******************************************************************************
   844 4941 A2 03		OS_SET_ROOT_DIR LDX	#3				; 4 byte to copy
   845 4943 BD 1C 04 9D 04 04	OS_SET_RDIR_LP	MVA 	D_START_DIR,X D_ACTUAL_DIR,X	; D_ACTUAL_DIR = root dir cluster nr
   846 4949 9D 24 18 CA				STA	CURR_DIR_BLK,X-			; Save in CURR_DIR_BLK
   847 494D 10 F4				BPL	OS_SET_RDIR_LP			; branch if not done yet
   848 						
   849 494F A9 5C 8D 20 04 A9 + 		MWA	#BSLASH	D_SUBDIR_NAME		; Add '\'and '\0' to D_SUBDIR_NAME
   850 4959 60					RTS					; return
   851
   852 				; **** Set Directory Command ***************************************************
   853 				; Input : CURR_DIR_ENTRY: Pointer into current directory block
   854 				; Copy the directory cluster number to D_ACTUAL_DIR and CURR_DIR_BLK.
   855 				; A cluster number cannot be < 2. If a cluster number is 0, then it is 
   856 				; considered to be the root-dir and cluster number is set to 2.
   857 				; ******************************************************************************
   858 495A			OS_SET_DIR      PRHEX16	CURR_DIR_ENTRY
Macro: PRHEX16 [Source: macros.inc]
     1 495A A5 A9			LDA	CURR_DIR_ENTRY+1				; print MSB
     2 495C 20 91 E0			JSR	HEXOUT
     3 495F A5 A8			LDA	CURR_DIR_ENTRY
     4 4961 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_os.asm
   859 4964					PRCH	','
Macro: PRCH [Source: macros.inc]
     1 4964 A9 2C			LDA	#','
     2 4966 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   860 4969					PRCLW	D_START_CLSTH CURR_DIR_ENTRY	; Print 1st cluster HIGH word
Macro: PRCLW [Source: macros.inc]
     1 4969 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 496B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 496D 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 4970 A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4972 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4974 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   861 4977					PRCLW	D_START_CLST  CURR_DIR_ENTRY	; Print 1st cluster LOW  word
Macro: PRCLW [Source: macros.inc]
     1 4977 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4979 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 497B 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
     7 497E A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4980 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     5 4982 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_os.asm
Source: boot_sys_os.asm
   862 4985					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 4985 A9 5D			LDA	#']'
     2 4987 20 52 E0			JSR	COUT
Source: boot_sys_os.asm
   863 498A A0 15				LDY     #D_START_CLSTH+1		; MSB of 1st cluster HIGH word
   864 498C A2 04		                LDX     #$04				; Copy 4 bytes
   865 498E 8E B3 49				STX	OS_DWORD0			; Flag for zero all 4 bytes 
   866 4991 CA					DEX					; Copy bytes 3..0
   867 4992 20 A0 49				JSR	OS_SET_WORD			; Save 1st cluster HIGH word
   868 4995 A0 1B				LDY	#D_START_CLST+1			; MSB of 1st cluster LOW word
   869 4997 20 A0 49				JSR	OS_SET_WORD			; Save 1st cluster LOW word
   870 499A					LDA.EQ	OS_DWORD0 OS_SET_ROOT_DIR	; branch if flag is 0 (all 4 bytes are 0), branch to set actual dir to D_START_DIR
Macro: LDA.EQ [Source: macros.inc]
     1 499A AD B3 49				LDA	OS_DWORD0
     2 499D F0 A2				BEQ	OS_SET_ROOT_DIR
Source: boot_sys_os.asm
   871 499F 60			                RTS			     		; return
   872 				                
   873 				;-------------------------------------------------------------------------------------------------
   874 				; Used by OS_SET_DIR to copy a cluster nr in a dir. entry to D_ACTUAL_DIR and CURR_DIR_BLK
   875 				; A cluster nr is stored in two words in a dir. entry: a High word in $14 and a Low word in $1A.
   876 				; A flag (OS_DWORD0) is used to check if all 4 bytes are zero.
   877 				;-------------------------------------------------------------------------------------------------
   878 49A0 20 A3 49		OS_SET_WORD	JSR	OS_SET_BYTE				; Store word in D_ACTUAL_DIR and CURR_DIR_BLK
   879 49A3 B1 A8 9D 04 04	OS_SET_BYTE	MVA	(CURR_DIR_ENTRY),Y D_ACTUAL_DIR,X	; Get byte from D_START_CLSTH or D_START_CLST and save in D_ACTUAL_DIR
   880 49A8					STA.NE	CURR_DIR_BLK,X SET_BYTE_NOT0		; Save in CURR_DIR_BLK and branch if > 0
Macro: STA.NE [Source: macros.inc]
     1 49A8 9D 24 18				STA	CURR_DIR_BLK,X
     2 49AB D0 03				BNE	SET_BYTE_NOT0
Source: boot_sys_os.asm
   881 49AD CE B3 49				DEC	OS_DWORD0				; decrement flag for zero all 4 bytes
   882 49B0 88			SET_BYTE_NOT0	DEY				
   883 49B1 CA					DEX
   884 49B2 60					RTS				; return
   885 49B3 00			OS_DWORD0	.byte	$00
   886
   887 				; **** Read Input String *******************************************************
   888 				; Output: Null terminated string in STRBUF
   889 				; ******************************************************************************
   890 49B4 20 62 E0		OS_STRING_IN    JSR     STRIN                ; input string into string buffer
   891 49B7 A9 00 85 EA A9 14 +                 MWA	#STRBUF PSTR	     ; set string pointer to buffer
   892 49BF A9 00 9D 00 14	                MVA     #$00    STRBUF,X     ; terminate string with NULL
   893 49C4 60			                RTS
   894
   895 				; **** Print Error Message *****************************************************
   896 				; Input:  Ptr[X:Y] = Pointer to Error Message
   897 				; Output: C = 0
   898 				; ******************************************************************************
   899 49C5 20 82 F6		OS_PRINT_ERR    JSR     OS_STRING_OUT
   900 49C8 18			                CLC
   901 49C9 60			                RTS
   902 				                
   903 				; **** Parse Full Path String **************************************************
   904 				; Input:  Ptr[X:Y] to Path String
   905 				; Output: C = 0 - Error; C = 1 - No Error
   906 				;         A = $00       - End Of String
   907 				;           = $FF       - Path Not Found
   908 				;           = ?         - Wildcard Included
   909 				;           = PATH_SEP  - No Trailing Name
   910 				; ******************************************************************************
   911 49CA			OS_PARSE_PATH   STXY    PSTR                	; save string pointer
Macro: STXY [Source: macros.inc]
     1 49CA 86 EA			STX	PSTR
     2 49CC 84 EB			STY	PSTR+1
Source: boot_sys_os.asm
   912 49CE A0 00		                LDY     #$00
   913 49D0 8C 11 18		                STY     TERM_CHAR
   914 49D3 A9 5C		                LDA     #PATH_SEP
   915 49D5			                CMP.NE  (PSTR),Y PARSE_PATH2	; check if first char is the path seperator. Branch if not, just check the path
Macro: CMP.NE [Source: macros.inc]
     1 49D5 D1 EA				CMP	(PSTR),Y
     2 49D7 D0 06				BNE	PARSE_PATH2
Source: boot_sys_os.asm
   916 49D9 20 41 49		                JSR     OS_SET_ROOT_DIR     	; yes, switch to root directory
   917 49DC A0 00		                LDY     #$00
   918 49DE C8			PARSE_PATH      INY
   919 49DF			PARSE_PATH2     LDA.EQ  (PSTR),Y PARSE_TERM     ; load next char from path string, branch if NULL (set termination char)
Macro: LDA.EQ [Source: macros.inc]
     1 49DF B1 EA				LDA	(PSTR),Y
     2 49E1 F0 18				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   920 49E3			                CMP.EQ  #SPC     PARSE_TERM     ; Set termination char if it is a SPACE char
Macro: CMP.EQ [Source: macros.inc]
     1 49E3 C9 20				CMP	#SPC
     2 49E5 F0 14				BEQ	PARSE_TERM
Source: boot_sys_os.asm
   921 						
   922 49E7 20 11 4A		PARSE_NAME      JSR     OS_PARSE_NAME       ; no, parse partial path name
   923 49EA 90 21		                BCC     PARSE_PATH_END      ; filename includes forbidden chars, exit with error
   924 						
   925 49EC			                CMP.NE  #PATH_SEP PARSE_PATH_OK	; is termination char the path seperator? No, trailing name, exit withour error
Macro: CMP.NE [Source: macros.inc]
     1 49EC C9 5C				CMP	#PATH_SEP
     2 49EE D0 1C				BNE	PARSE_PATH_OK
Source: boot_sys_os.asm
   926 49F0 84 EE		                STY     PSAV                ; save string index
   927 49F2 20 64 48		                JSR     OS_FIND_PATH        ; yes, find and switch patch
   928 49F5 A4 EE		                LDY     PSAV                ; restore string index
   929 49F7 90 0F		                BCC     PARSE_PATH_ERR      ; path not found, exit with error
   930 49F9 B0 E3		                BCS     PARSE_PATH          ; branch always
   931 				                
   932 49FB 18			PARSE_TERM      CLC
   933 49FC			                LDA.NE  TERM_CHAR PARSE_PATH_END2	; branch if TERM_CHAR > 0
Macro: LDA.NE [Source: macros.inc]
     1 49FC AD 11 18				LDA	TERM_CHAR
     2 49FF D0 0F				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   934 4A01 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR		; TERM_CHAR = PATH_SEP
   935 4A06 D0 04		                BNE     PARSE_PATH_OK			; branch always
   936 				                
   937 4A08			PARSE_PATH_ERR  LDA.NE  #$FF PARSE_PATH_END2    ; path not found error
Macro: LDA.NE [Source: macros.inc]
     1 4A08 A9 FF				LDA	#$FF
     2 4A0A D0 04				BNE	PARSE_PATH_END2
Source: boot_sys_os.asm
   938 4A0C 38			PARSE_PATH_OK   SEC
   939 4A0D AD 11 18		PARSE_PATH_END  LDA     TERM_CHAR           	; load termination char as error status into A
   940 4A10 60			PARSE_PATH_END2 RTS
   941
   942 				; **** Parse A Partial Path Name String ****************************************
   943 				; Input:  A = First Char Of Partial Path
   944 				;         Y = Index Into Path String
   945 				; Output: C = 0 - Error; C = 1 - No Error
   946 				;         TERM_CHAR = NULL      - Filename
   947 				;                   = ?         - Wildcard Chars Included
   948 				;                   = PATH_SEP  - Subdirectory Name
   949 				; ******************************************************************************
   950 4A11 A2 08		OS_PARSE_NAME   LDX     #8
   951 4A13 86 AB		                STX     BCNT                	; set max char count to 8
   952 4A15 A2 00		                LDX     #$00                	; reset index to name string buffer
   953 4A17 8E 11 18		                STX     TERM_CHAR
   954 4A1A			CHK_DOT         CMP.NE  #DOT GET_CHAR       	; is first char a . char? (. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A1A C9 2E				CMP	#DOT
     2 4A1C D0 10				BNE	GET_CHAR
Source: boot_sys_os.asm
   955 4A1E 9D 9A 4B E8		                STA     FILENAME,X+         	; yes, store it
   956 4A22 C8			                INY
   957 4A23 B1 EA		                LDA     (PSTR),Y            	; get next char from input string
   958 4A25			                CMP.NE  #DOT GET_CHAR       	; is second char a . char? (.. dir?), branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4A25 C9 2E				CMP	#DOT
     2 4A27 D0 05				BNE	GET_CHAR
Source: boot_sys_os.asm
   959 4A29 9D 9A 4B		SET_CHAR        STA     FILENAME,X          	; yes, store it
   960 4A2C E8			NEXT_CHAR       INX                         	; point to next char of parsed name
   961 4A2D C8			NEXT_CHAR2      INY                         	; point to next char of input string
   962 4A2E			GET_CHAR        LDA.EQ  (PSTR),Y  FILL_ALL   	; get next char from input string, branch if end of line.
Macro: LDA.EQ [Source: macros.inc]
     1 4A2E B1 EA				LDA	(PSTR),Y
     2 4A30 F0 52				BEQ	FILL_ALL
Source: boot_sys_os.asm
   963 4A32			                CMP.EQ  #SPC      FILL_ALL     	; Terminate if it is a space char
Macro: CMP.EQ [Source: macros.inc]
     1 4A32 C9 20				CMP	#SPC
     2 4A34 F0 4E				BEQ	FILL_ALL
Source: boot_sys_os.asm
   964 4A36			                CMP.EQ  #PATH_SEP SET_TERM_CHAR	; is it a path seperator char? If so, terminate
Macro: CMP.EQ [Source: macros.inc]
     1 4A36 C9 5C				CMP	#PATH_SEP
     2 4A38 F0 47				BEQ	SET_TERM_CHAR
Source: boot_sys_os.asm
   965 4A3A			                CMP.EQ  #DOT      FILL_NAME     ; is it a . char? If so, fill name with spaces
Macro: CMP.EQ [Source: macros.inc]
     1 4A3A C9 2E				CMP	#DOT
     2 4A3C F0 3A				BEQ	FILL_NAME
Source: boot_sys_os.asm
   966 4A3E			                CMP.EQ  #'*'      FILL_WILDCARD ; is it a * char? If so, fill name with '?'
Macro: CMP.EQ [Source: macros.inc]
     1 4A3E C9 2A				CMP	#'*'
     2 4A40 F0 2C				BEQ	FILL_WILDCARD
Source: boot_sys_os.asm
   967
   968 4A42			                CPX.CS  BCNT NEXT_CHAR          ; branch if name length exceeds max length
Macro: CPX.CS [Source: macros.inc]
     1 4A42 E4 AB				CPX	BCNT			; 
     2 4A44 B0 E6				BCS	NEXT_CHAR			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   969 4A46 20 62 4C		                JSR     UPPERCASE           	; convert chars to upper case
   970 4A49			                CMP.NE  #'?' GET_CHAR2      	; is it a ? char? Branch if not, check next allowed char
Macro: CMP.NE [Source: macros.inc]
     1 4A49 C9 3F				CMP	#'?'
     2 4A4B D0 05				BNE	GET_CHAR2
Source: boot_sys_os.asm
   971 4A4D 8D 11 18		                STA     TERM_CHAR           	; yes, store ? as termination char
   972 4A50 F0 D7		                BEQ     SET_CHAR            	; and char in name buffer
   973
   974 4A52			GET_CHAR2       CMP.EQ  #MINUS SET_CHAR     ; is it a - char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A52 C9 2D				CMP	#MINUS
     2 4A54 F0 D3				BEQ	SET_CHAR
Source: boot_sys_os.asm
   975 4A56			                CMP.EQ  #ULINE SET_CHAR     ; is it a _ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A56 C9 5F				CMP	#ULINE
     2 4A58 F0 CF				BEQ	SET_CHAR
Source: boot_sys_os.asm
   976 4A5A					CMP.EQ	#'~' SET_CHAR       ; is it a ~ char? Yes, store char in name buffer
Macro: CMP.EQ [Source: macros.inc]
     1 4A5A C9 7E				CMP	#'~'
     2 4A5C F0 CB				BEQ	SET_CHAR
Source: boot_sys_os.asm
   977 4A5E					CMP.CC  #'0' PARSE_NAME_END ; is char in range 0..9? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A5E C9 30				CMP	#'0'			; 
     2 4A60 90 32				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   978 4A62			                CMP.CC  #':' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A62 C9 3A				CMP	#':'			; 
     2 4A64 90 C3				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   979 4A66			                CMP.CC  #'A' PARSE_NAME_END ; is char in range A..Z? Branch if not, show error message
Macro: CMP.CC [Source: macros.inc]
     1 4A66 C9 41				CMP	#'A'			; 
     2 4A68 90 2A				BCC	PARSE_NAME_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   980 4A6A			                CMP.CC  #'[' SET_CHAR	    ; yes, store char in name buffer
Macro: CMP.CC [Source: macros.inc]
     1 4A6A C9 5B				CMP	#'['			; 
     2 4A6C 90 BB				BCC	SET_CHAR			; branch if C=0 (A-b1 < 0)
Source: boot_sys_os.asm
   981
   982 4A6E A9 3F 8D 11 18	FILL_WILDCARD   MVA     #'?' TERM_CHAR      ; store ? as termination char
   983 4A73 20 8A 4A		                JSR     FILL_CHAR           ; fill with ? chars
   984 4A76 B0 B5		                BCS     NEXT_CHAR2          ; branch always
   985
   986 4A78 20 88 4A		FILL_NAME       JSR     SET_SPC_CHAR        ; fill with space chars
   987 4A7B A9 0B 85 AB		                MVA     #11 BCNT            ; set max char count to 11
   988 4A7F B0 AC		                BCS     NEXT_CHAR2          ; branch always
   989
   990 4A81 8D 11 18		SET_TERM_CHAR   STA     TERM_CHAR           ; store termination character
   991 4A84 A9 0B 85 AB		FILL_ALL        MVA     #11 BCNT            ; set max char count to 11
   992 4A88 A9 20		SET_SPC_CHAR    LDA     #SPC                ; set space char as filling char
   993 4A8A			FILL_CHAR       CPX.CS  BCNT PARSE_NAME_END ; branch if max char count exceeded
Macro: CPX.CS [Source: macros.inc]
     1 4A8A E4 AB				CPX	BCNT			; 
     2 4A8C B0 06				BCS	PARSE_NAME_END			; branch if C=1 (X-b1 >= 0)
Source: boot_sys_os.asm
   994 4A8E 9D 9A 4B E8		                STA     FILENAME,X+         ; no, store char in name buffer
   995 4A92 90 F6		                BCC     FILL_CHAR           ; and repeat
   996
   997 4A94 AD 11 18		PARSE_NAME_END  LDA     TERM_CHAR
   998 4A97 60			                RTS
   999 				                
  1000 				; **** Compare File Name With Mask *********************************************
  1001 				; Output: C = 0 - Names not equal; C = 1 - Names equal
  1002 				; ******************************************************************************
  1003 4A98 A0 0A		OS_COMP_NAME    LDY     #10                 		; compare all characters (0..10)
  1004 4A9A B9 9A 4B		COMPARE_CHAR    LDA     FILENAME,Y          		; get char from compare mask
  1005 4A9D			                CMP.NE  (CURR_DIR_ENTRY),Y COMPARE_NEQ	; compare character
Macro: CMP.NE [Source: macros.inc]
     1 4A9D D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4A9F D0 05				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1006 4AA1			                DEY.PL	COMPARE_CHAR        		; branch if more characters to compare
Macro: DEY.PL [Source: macros.inc]
     1 4AA1 88					DEY
     2 4AA2 10 F6				BPL	COMPARE_CHAR
Source: boot_sys_os.asm
  1007 						
  1008 4AA4 38			COMPARE_EQU     SEC                         		; C=1, all characters are equal
  1009 4AA5 60			                RTS
  1010 4AA6 18			COMPARE_NEQ     CLC					; C=0, filename is different
  1011 4AA7 60			                RTS
  1012 				                
  1013 				; **** Delete File *************************************************************
  1014 				; Input : A - First character of filename
  1015 				; Output: C = 0 - File is not deleted; C = 1 - Names equal
  1016 				; ******************************************************************************
  1017 4AA8			OS_FILE_DELETED CMP.NE  #$E5 COMPARE_NEQ       		; is file deleted? Branch if not, C=0 and exit
Macro: CMP.NE [Source: macros.inc]
     1 4AA8 C9 E5				CMP	#$E5
     2 4AAA D0 FA				BNE	COMPARE_NEQ
Source: boot_sys_os.asm
  1018 4AAC AC 13 18		                LDY     TERM_FLAG           		; termination flag already set?
  1019 4AAF D0 F3		                BNE     COMPARE_EQU         		; yes, C=1 and exit
  1020
  1021 4AB1 8D 13 18		                STA     TERM_FLAG           		; no, set counter termination flag
  1022 4AB4					MVAY	6 CURR_DIR_BLK SEL_DIR_BLK	; SEL_DIR_BLK = CURR_DIR_BLK
Macro: MVAY [Source: macros.inc]
     1 4AB4 A0 05			LDY	#6-1
     2 4AB6 B9 24 18 99 C1 4A + lp	MVA	CURR_DIR_BLK,Y SEL_DIR_BLK,Y-
     3 4ABD 10 F7			BPL	lp
Source: boot_sys_os.asm
  1023 4ABF 38			                SEC
  1024 4AC0 60			                RTS
  1025 				                
  1026 4AC1 00 00 00 00		SEL_DIR_BLK     .byte $00, $00, $00, $00
  1027 4AC5 00 00		SEL_DIR_ENTRY   .byte $00, $00
  1028 				                
  1029 				; **** Directory Loop Call Back Functions **************************************
  1030 				; Input : A - First character of filename
  1031 				;         X - File Attributes
  1032 				; Output: C = 1 - File found; C = 0 - File not found
  1033 				; ******************************************************************************
  1034
  1035 				; **** Directory Exists - Call Back Routine ************************************
  1036 4AC7 20 A8 4A		CB_DIR_EXISTS   JSR     OS_FILE_DELETED
  1037
  1038 				; **** Find Sub Directory Name - Call Back Routine *****************************
  1039 4ACA			CB_FIND_SUBDIR  CPX.EQ  #$0F CB_FIND_END       	; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4ACA E0 0F				CPX	#$0F
     2 4ACC F0 43				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1040 4ACE AD 9A 4B		                LDA     FILENAME            	; do we search for the . directory?
  1041 4AD1			                CMP.NE  #DOT FIND_SUBDIR	; branch if not . or ..
Macro: CMP.NE [Source: macros.inc]
     1 4AD1 C9 2E				CMP	#DOT
     2 4AD3 D0 07				BNE	FIND_SUBDIR
Source: boot_sys_os.asm
  1042 						
  1043 4AD5 AD 9B 4B		                LDA     FILENAME+1		; get next byte
  1044 4AD8			                CMP.EQ  #SPC FIND_SUBDIR_END   	; Space? Yes, do nothing, dir = '.', just exit.
Macro: CMP.EQ [Source: macros.inc]
     1 4AD8 C9 20				CMP	#SPC
     2 4ADA F0 0D				BEQ	FIND_SUBDIR_END
Source: boot_sys_os.asm
  1045 						
  1046 4ADC 8A			FIND_SUBDIR     TXA
  1047 4ADD			                AND.EQ  #FA_DIRECTORY CB_FIND_END	; is it a directory we are looking for? Branch if not, exit
Macro: AND.EQ [Source: macros.inc]
     6 4ADD 29 10				AND	#FA_DIRECTORY
     7 4ADF F0 30				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1048 4AE1 20 98 4A		                JSR     OS_COMP_NAME        		; yes, compare name with search mask
  1049 4AE4 90 2C		                BCC     CB_FIND_END2        		; branch if C=0: name not equal, get next dir entry, just RTS
  1050
  1051 						; Emile: two errors here (corrected here and OS_SET_DIR is changed as well):
  1052 						; 1) only D_START_CLST ($1A) was used to get dir cluster nr, D_START_CLSTH ($14) also needs to be used 
  1053 						; 2) OS_SET_DIR expected 4 consecutive bytes and copied $1A, $1B, $1C & $1D into D_ACTUAL_DIR and CURR_DIR_BLK,
  1054 						;    with $1C & $1D not being cluster nr bytes.
  1055 4AE6 20 5A 49		                JSR     OS_SET_DIR          	; make this directory the actual directory
  1056 4AE9 38			FIND_SUBDIR_END SEC                         	; C=1: subdirectory found
  1057 4AEA 60			                RTS				; return
  1058 				                
  1059 				; **** File Exists - Call Back Routine *****************************************
  1060 4AEB 20 A8 4A		CB_FILE_EXISTS  JSR     OS_FILE_DELETED
  1061
  1062 				; **** Find File Name - Call Back Routine **************************************
  1063 4AEE			CB_FIND_FILE    CPX.EQ  #$0F CB_FIND_END        		; branch if a long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4AEE E0 0F				CPX	#$0F
     2 4AF0 F0 1F				BEQ	CB_FIND_END
Source: boot_sys_os.asm
  1064 4AF2 8A			                TXA
  1065 4AF3			                AND.NE  #FA_DIRECTORY CB_FIND_END 		; is it a directory? Branch if so, get next dir entry
Macro: AND.NE [Source: macros.inc]
     6 4AF3 29 10				AND	#FA_DIRECTORY
     7 4AF5 D0 1A				BNE	CB_FIND_END
Source: boot_sys_os.asm
  1066 4AF7 20 98 4A		                JSR     OS_COMP_NAME        			; compare name with search mask
  1067 4AFA 90 16		                BCC     CB_FIND_END2        			; name not equal, get next dir entry
  1068 						
  1069 4AFC A2 00		                LDX     #$00					; init. index in CURR_CLUSTER
  1070 4AFE A0 1A		                LDY     #D_START_CLST       			; get low bytes of start cluster address
  1071 4B00 B1 A8 C8 95 A0 E8	GET_FILE_CLST   MVA     (CURR_DIR_ENTRY),Y+  CURR_CLUSTER,X+	; and store it into current cluster
  1072 4B06			                CPX.CC  #$02 GET_FILE_CLST     			; branch if not first two address bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B06 E0 02				CPX	#$02			; 
     2 4B08 90 F6				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1073 4B0A A0 14		                LDY     #D_START_CLSTH      			; yes, get high bytes of start cluster address
  1074 4B0C			                CPX.CC  #$04 GET_FILE_CLST     			; branch if not all four bytes read
Macro: CPX.CC [Source: macros.inc]
     1 4B0C E0 04				CPX	#$04			; 
     2 4B0E 90 F0				BCC	GET_FILE_CLST			; branch if C=0 (X-b1 < 0)
Source: boot_sys_os.asm
  1075 4B10 60			                RTS                         			; yes, file found
  1076
  1077 4B11 18			CB_FIND_END     CLC                         			; file not found
  1078 4B12 60			CB_FIND_END2    RTS
  1079 				                
  1080 				; **** Find Free or Deleted Dir. Entry **************************************
  1081 4B13			CB_FIND_FREE_DIR_ENTRY
  1082 4B13 A0 00				LDY	#D_FILENAME			; set index to filename
  1083 4B15 B1 A8				LDA	(CURR_DIR_ENTRY),Y		; 1st char of filename
  1084 4B17					CMP.EQ	#$E5 FND_EMPTY			; Branch if deleted entry found
Macro: CMP.EQ [Source: macros.inc]
     1 4B17 C9 E5				CMP	#$E5
     2 4B19 F0 09				BEQ	FND_EMPTY
Source: boot_sys_os.asm
  1085 4B1B			FFD_LP1		LDA.NE	(CURR_DIR_ENTRY),Y NOT_EMPTY	; branch if dir. entry is in use
Macro: LDA.NE [Source: macros.inc]
     1 4B1B B1 A8				LDA	(CURR_DIR_ENTRY),Y
     2 4B1D D0 10				BNE	NOT_EMPTY
Source: boot_sys_os.asm
  1086 4B1F C8					INY
  1087 4B20			                CPY.CC  #D_ATTRIBUTES FFD_LP1  		; branch if not all characters copied
Macro: CPY.CC [Source: macros.inc]
     1 4B20 C0 0B				CPY	#D_ATTRIBUTES			; 
     2 4B22 90 F7				BCC	FFD_LP1			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_os.asm
  1088 4B24 A9 00		FND_EMPTY	LDA	#$00				; empty rest of subdir, just to be sure
  1089 4B26 91 A8 C8		FFD_LP2		STA	(CURR_DIR_ENTRY),Y+
  1090 4B29					CPY.NE	#$20 FFD_LP2			; branch if not all 32 bytes cleared yet
Macro: CPY.NE [Source: macros.inc]
     1 4B29 C0 20				CPY	#$20
     2 4B2B D0 F9				BNE	FFD_LP2
Source: boot_sys_os.asm
  1091 						
  1092 4B2D 38			FF_EMPTY	SEC					; C=1, dir. entry is free or deleted
  1093 4B2E 60			                RTS                         		; return
  1094 4B2F 18			NOT_EMPTY     	CLC                         		; C=0, dir. entry is not empty
  1095 4B30 60					RTS					; return
  1096
  1097 				; **** Data Area ***************************************************************
  1098 				; ******************************************************************************
  1099
  1100 				; Indirect Jump Pointer Of Current Command Address *****************************
  1101 4B31 00 00		CMD_ADDR        .word      $0000
  1102 				                
  1103 				; String Data Area *************************************************************
  1104 4B33 0D 20 57 65 6C 63 + MSG_BOOT        .by    CR ' Welcome to DOS65 for the JC2, V'
  1105 4B54 30 2E 32 2E 37	                .byte  VERMAIN,DOT,VERPSUB,DOT,VERSSUB
  1106 4B59 2C 20 32 30 32 35 +                 .by    ', 2025 by Emile' CR
  1107 4B69 20 4F 72 69 67 69 + 		.by    ' Original design by Joerg Walke' CR CR $00
  1108 4B8B 4F 75 74 20 6F 66 + MSG_SIZE_ERR    .by    'Out of memory' CR $00
  1109 = 4B9A			FILENAME        .ds 	12
    85 4BA6					ICL 	"boot_sys_sh.asm"	; Shell portion of boot.sys
Source: boot_sys_sh.asm
     1 				;-------------------------------------------------------------------------------
     2 				; This file contains the SHELL portion of the BOOT.SYS file.
     3 				; 
     4 				; Assembler: MADS-Assembler
     5 				; V0.1: 22-05-25, Emile first version
     6 				;-------------------------------------------------------------------------------
     7
     8 				; ******************************************************************************
     9 				; Main Loop Of Command Interpreter *********************************************
    10 				; ******************************************************************************
    11 4BA6 A9 60 8D 31 4B A9 + SH_CMD_PROMPT   MWA	#CMD_FOUND CMD_ADDR  ; CMD_ADDR = CMD_FOUND
    12 4BB0 20 9E 4C		                JSR     PRINT_PROMPT
    13 4BB3 20 B4 49		                JSR  	OS_STRING_IN         ; read input string
    14 4BB6 20 CA 4B				JSR     GET_CMD              ; parse string
    15 4BB9 90 06				BCC     CMD_EXTERNAL
    16 						
    17 4BBB 20 C7 4B		                JSR     CMD_EXECUTE          ; execute internal command
    18 4BBE 4C A6 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    19 						
    20 4BC1 20 53 54		CMD_EXTERNAL    JSR     SH_RUN               ; internal command not found, load executable file from drive
    21 4BC4 4C A6 4B		                JMP     SH_CMD_PROMPT        ; endless loop
    22 						
    23 4BC7 6C 31 4B		CMD_EXECUTE     JMP     (CMD_ADDR)           ; indirect jump to internal command call back function
    24 						
    25 				; Get Command String ***********************************************************
    26 4BCA 20 EA 4E		GET_CMD         JSR     GET_CMD_STR          ; skip leading spaces
    27 4BCD D0 03		                BNE     GET_CMD0
    28
    29 4BCF 4C 60 4C		                JMP     CMD_FOUND            ; empty command if first char is NULL
    30
    31 4BD2 20 62 4C		GET_CMD0        JSR     UPPERCASE	     ; uppercase chars only
    32 4BD5 AA			                TAX
    33 4BD6 A0 00		                LDY     #$00
    34 4BD8 8A			GET_CMD1        TXA                          	; try to find command in command table
    35 4BD9					CMP.EQ	CHARS,Y GET_CMD2     	; branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4BD9 D9 58 57				CMP	CHARS,Y
     2 4BDC F0 0C				BEQ	GET_CMD2
Source: boot_sys_sh.asm
    36 4BDE			                LDA.EQ  CHARS,Y SH_CMD_SET_DRV	; get [X,Y] pointer, branch if at end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4BDE B9 58 57				LDA	CHARS,Y
     2 4BE1 F0 57				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    37 4BE3 8A			                TXA
    38 4BE4 C8 C8 C8		        :3      INY			     	; Y += 3
    39 4BE7 4C D8 4B		                JMP     GET_CMD1	     	; branch always
    40
    41 4BEA C8			GET_CMD2        INY
    42 4BEB B9 58 57 C8 85 E8	                MVA     CHARS,Y+ STOL        	; store in pointer LSB
    43 4BF1 B9 58 57 85 E9	                MVA     CHARS,Y  STOH	     	; store in pointer MSB
    44 4BF6 A0 00 8C 10 18			MVY	#$00 NEXTINDEX	     	; init. command index
    45 4BFB A6 AC		GET_CMD_LOOP1   LDX     NCNT                 	; reset string index to first command char
    46 4BFD			                LDA.EQ  (STOL),Y SH_CMD_SET_DRV	; branch if command length is 0 (command not found)
Macro: LDA.EQ [Source: macros.inc]
     1 4BFD B1 E8				LDA	(STOL),Y
     2 4BFF F0 39				BEQ	SH_CMD_SET_DRV
Source: boot_sys_sh.asm
    47 4C01 18 6D 10 18 8D 10 +                 ADD:STA NEXTINDEX		; set index to start of next command
    48 4C08 E8			GET_CMD_LOOP2   INX                          	; point to next char in command string
    49 4C09 C8			                INY                          	; point to next char in command table
    50 4C0A			                CPY.EQ  NEXTINDEX GET_CMD3   	; branch if y is pointing to the next command
Macro: CPY.EQ [Source: macros.inc]
     1 4C0A CC 10 18				CPY	NEXTINDEX
     2 4C0D F0 15				BEQ	GET_CMD3
Source: boot_sys_sh.asm
    51
    52 4C0F BD 00 14		                LDA     STRBUF,X             	; load char from command string
    53 4C12 20 62 4C		                JSR     UPPERCASE	     	; and convert it to uppercase
    54 4C15					CMP.EQ	(STOL),Y  GET_CMD_LOOP2	; compare char with char in command table and branch if equal
Macro: CMP.EQ [Source: macros.inc]
     1 4C15 D1 E8				CMP	(STOL),Y
     2 4C17 F0 EF				BEQ	GET_CMD_LOOP2
Source: boot_sys_sh.asm
    55
    56 4C19 AC 10 18		                LDY     NEXTINDEX            	; else point y to next command
    57 4C1C C8 C8		        :2      INY			     	; Y += 2
    58 4C1E 8C 10 18		                STY     NEXTINDEX
    59 4C21 4C FB 4B		                JMP     GET_CMD_LOOP1	     	; branch always
    60
    61 4C24 B1 E8 8D 31 4B C8 + GET_CMD3        MWA	(STOL),Y CMD_ADDR    	; CMD_ADDR = (STOL),Y (STOL),Y+1
    62 4C2F			                LDA.EQ  STRBUF,X CMD_FOUND	; branch if STRBUF,X contains end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4C2F BD 00 14				LDA	STRBUF,X
     2 4C32 F0 2C				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    63 4C34			                CMP.EQ	#SPC     CMD_FOUND	; branch if space found
Macro: CMP.EQ [Source: macros.inc]
     1 4C34 C9 20				CMP	#SPC
     2 4C36 F0 28				BEQ	CMD_FOUND
Source: boot_sys_sh.asm
    64 4C38 18			CMD_NOT_FOUND   CLC
    65 4C39 60			                RTS
    66 				                
    67 				; Check If Set-Drive Command (A: .. Z:) ****************************************
    68 4C3A A6 AC		SH_CMD_SET_DRV  LDX     NCNT                 ; get first command char
    69 4C3C BD 00 14		                LDA     STRBUF,X
    70 4C3F 20 62 4C		                JSR     UPPERCASE            ; convert it to upper case
    71 4C42			                CMP.CC  #'A' CMD_NOT_FOUND   ; branch if char is not between 'A' and 'Z'
Macro: CMP.CC [Source: macros.inc]
     1 4C42 C9 41				CMP	#'A'			; 
     2 4C44 90 F2				BCC	CMD_NOT_FOUND			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    72 4C46			                CMP.CS  #'[' CMD_NOT_FOUND
Macro: CMP.CS [Source: macros.inc]
     1 4C46 C9 5B				CMP	#'['			; 
     2 4C48 B0 EE				BCS	CMD_NOT_FOUND			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    73
    74 4C4A A8			                TAY
    75 4C4B BD 01 14		                LDA     STRBUF+1,X
    76 4C4E			                CMP.NE  #':' CMD_NOT_FOUND   ; branch if second char is not a ':'
Macro: CMP.NE [Source: macros.inc]
     1 4C4E C9 3A				CMP	#':'
     2 4C50 D0 E6				BNE	CMD_NOT_FOUND
Source: boot_sys_sh.asm
    77 4C52 38			                SEC
    78 4C53 98			                TYA
    79 4C54 E9 41		                SBC     #'A'                 ; make a drive (0..25) number out of drive letter (A..Z)
    80 4C56			                LDXYI   OS_SET_DRIVE         ; set call back function for set drive command
Macro: LDXYI [Source: macros.inc]
     1 4C56 A2 E4			LDX	<OS_SET_DRIVE				; MADS makes this immediate
     2 4C58 A0 48			LDY	>OS_SET_DRIVE
Source: boot_sys_sh.asm
    81 4C5A			                STXY    CMD_ADDR
Macro: STXY [Source: macros.inc]
     1 4C5A 8E 31 4B			STX	CMD_ADDR
     2 4C5D 8C 32 4B			STY	CMD_ADDR+1
Source: boot_sys_sh.asm
    82 4C60 38			CMD_FOUND       SEC
    83 4C61 60			                RTS
    84 				                
    85 				; **** Return Uppercase Character **********************************************
    86 				; Input:  A - Character
    87 				; Output: A - Uppercase Character
    88 				; ******************************************************************************
    89 4C62			UPPERCASE       CMP.CC  #'a'   UPPERCASE_END	; exit if A < 'a'
Macro: CMP.CC [Source: macros.inc]
     1 4C62 C9 61				CMP	#'a'			; 
     2 4C64 90 06				BCC	UPPERCASE_END			; branch if C=0 (A-b1 < 0)
Source: boot_sys_sh.asm
    90 4C66			                CMP.CS  #'z'+1 UPPERCASE_END	; exit if A > 'z'
Macro: CMP.CS [Source: macros.inc]
     1 4C66 C9 7B				CMP	#'z'+1			; 
     2 4C68 B0 02				BCS	UPPERCASE_END			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
    91 4C6A 29 DF		                AND     #$DF			; make lower-case if 'a'..'z'
    92 4C6C 60			UPPERCASE_END   RTS				; return
    93
    94 				; **** Print Two Digit Number **************************************************
    95 				; Input: A - Number (0..99)
    96 				; ******************************************************************************
    97 4C6D 20 BD E0		NUMOUT          JSR     DEC2STR			; Converts into DIG0, DIG1 and DIG2
    98 4C70 A2 01		                LDX     #$01
    99 4C72 B5 F8		NEXT_NUMOUT     LDA     DIG0,X			
   100 4C74 20 52 E0		                JSR     COUT
   101 4C77					DEX.PL	NEXT_NUMOUT		; branch if not done yet
Macro: DEX.PL [Source: macros.inc]
     1 4C77 CA					DEX
     2 4C78 10 F8				BPL	NEXT_NUMOUT
Source: boot_sys_sh.asm
   102 4C7A 60			                RTS				; return
   103 				                
   104 				; **** Print Current Drive *****************************************************
   105 				;
   106 				; ******************************************************************************
   107 4C7B AD 1E 18		PRINT_DRIVE     LDA     CURR_DRIVE	   ; 0=FDD1, 1=FDD2, @=SD/CF card
   108 4C7E 18 69 41				ADD	#'A'		   ; 'A', 'B', 'C', ...
   109 4C81 20 52 E0		                JSR     COUT		   ; print char
   110 4C84 A9 3A		                LDA     #COLON		   ; ':'
   111 4C86 4C 52 E0		                JMP     COUT		   ; print char and return
   112 				                
   113 				; **** Print Current Path ******************************************************
   114 				;
   115 				; ******************************************************************************
   116 4C89 A2 00 86 D8		PRINT_PATH      MVX	#0 SAVEX		; SAVEX = 0
   117 4C8D A6 D8		PR_PATH_LP	LDX	SAVEX
   118 4C8F BD 20 04				LDA     D_SUBDIR_NAME,X		; 
   119 4C92 48					PHA
   120 4C93 20 52 E0		                JSR     COUT		    	; print char
   121 4C96 68					PLA
   122 4C97 F0 04				BEQ	PR_PATH_DN		; End-of-String?
   123 						
   124 4C99					INC.NE	SAVEX PR_PATH_LP	; Get next char, branch if not done yet
Macro: INC.NE [Source: macros.inc]
     1 4C99 E6 D8				INC	SAVEX
     2 4C9B D0 F0				BNE	PR_PATH_LP
Source: boot_sys_sh.asm
   125 4C9D 60			PR_PATH_DN      RTS				; return
   126
   127 				; **** Print Drive and Path Prompt *********************************************
   128 				;
   129 				; ******************************************************************************
   130 4C9E 20 5A E0		PRINT_PROMPT    JSR     CROUT		   ; CR
   131 4CA1 20 7B 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C:'
   132 4CA4 20 89 4C		                JSR     PRINT_PATH	   ; '\'
   133 4CA7 A9 3E		                LDA     #PROMPT		   ; '>'
   134 4CA9 4C 52 E0		                JMP     COUT		   ; print char and return
   135 				                
   136 				; **** Print Drive Label *******************************************************
   137 				;
   138 				; ******************************************************************************
   139 4CAC 48			PRINT_LABEL     PHA			   ; save A
   140 4CAD			                PHY			   ; save Y
Macro: PHY [Source: macros.inc]
     1 4CAD 98				TYA
     2 4CAE 48				PHA
Source: boot_sys_sh.asm
   141 4CAF			                PRSTR   MSG_LABEL	   ; 'Volume in drive '
Macro: PRSTR [Source: macros.inc]
     1 4CAF A2 4A			LDX	<MSG_LABEL				; MADS makes this immediate
     2 4CB1 A0 56			LDY	>MSG_LABEL
Source: boot_sys_sh.asm
     2 4CB3 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   142 4CB6 20 7B 4C		                JSR     PRINT_DRIVE	   ; e.g. 'C'
   143 4CB9			                PRSTR   MSG_LABEL2	   ; ' is '
Macro: PRSTR [Source: macros.inc]
     1 4CB9 A2 5B			LDX	<MSG_LABEL2				; MADS makes this immediate
     2 4CBB A0 56			LDY	>MSG_LABEL2
Source: boot_sys_sh.asm
     2 4CBD 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   144 4CC0 20 D6 4C		                JSR     PRINT_FILENAME1    ; print volume-label
   145 4CC3 20 5A E0		                JSR     CROUT		   ; CR 2x
   146 4CC6 20 5A E0		                JSR     CROUT
   147 4CC9					PLY			   ; restore Y
Macro: PLY [Source: macros.inc]
     1 4CC9 68				PLA
     2 4CCA A8				TAY
Source: boot_sys_sh.asm
   148 4CCB 68			                PLA			   ; restore A
   149 4CCC 60			                RTS
   150 				                
   151 				; **** Print Filename **********************************************************
   152 				;
   153 				; ******************************************************************************
   154 4CCD A2 2E		PRINT_FILENAME  LDX     #DOT					; Check if directory
   155 4CCF					AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_FILENAME2	; branch if F_ATTRIBS & FA_DIRECTORY = 0  (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CCF AD 12 18				LDA	F_ATTRIBS
     3 4CD2 29 10				AND	#FA_DIRECTORY
     4 4CD4 F0 02				BEQ	PRINT_FILENAME2
Source: boot_sys_sh.asm
   156 4CD6 A2 20		PRINT_FILENAME1 LDX     #SPC                			; yes, set divider to ' '
   157 4CD8 A0 00		PRINT_FILENAME2 LDY     #$00
   158 4CDA			PRINT_FILENAME3 CPY.NE  #$08 PRINT_NEXT_CHAR			; branch if not at start of file extension
Macro: CPY.NE [Source: macros.inc]
     1 4CDA C0 08				CPY	#$08
     2 4CDC D0 07				BNE	PRINT_NEXT_CHAR
Source: boot_sys_sh.asm
   159 4CDE 20 5E E0		                JSR     SPCOUT		    		; print space
   160 4CE1 8A			                TXA
   161 4CE2 20 52 E0		                JSR     COUT                		; yes, print divider char
   162 4CE5 B1 A8		PRINT_NEXT_CHAR LDA     (CURR_DIR_ENTRY),Y  		; load next character
   163 4CE7 20 52 E0		                JSR     COUT                		; print character (does not affect Y)
   164 4CEA C8			                INY
   165 4CEB			                CPY.NE  #D_ATTRIBUTES PRINT_FILENAME3	; repeat if not all characters printed
Macro: CPY.NE [Source: macros.inc]
     1 4CEB C0 0B				CPY	#D_ATTRIBUTES
     2 4CED D0 EB				BNE	PRINT_FILENAME3
Source: boot_sys_sh.asm
   166 4CEF 60			                RTS			    		; return
   167 				                
   168 				; **** Print File Info *********************************************************
   169 				; Input: F_ATTRIBS = File Attributes
   170 				; ******************************************************************************
   171 4CF0			PRINT_FILE_INFO AND.EQ	F_ATTRIBS #FA_DIRECTORY PRINT_SIZE	; branch if F_ATTRIBS & FA_DIRECTORY = 0 (not a dir.)
Macro: AND.EQ [Source: macros.inc]
     2 4CF0 AD 12 18				LDA	F_ATTRIBS
     3 4CF3 29 10				AND	#FA_DIRECTORY
     4 4CF5 F0 12				BEQ	PRINT_SIZE
Source: boot_sys_sh.asm
   172 				                
   173 				; Print Directory Attribute ****************************************************
   174 4CF7			                PRSTR   MSG_DIR_ENTRY	    ; print <DIR>
Macro: PRSTR [Source: macros.inc]
     1 4CF7 A2 60			LDX	<MSG_DIR_ENTRY				; MADS makes this immediate
     2 4CF9 A0 56			LDY	>MSG_DIR_ENTRY
Source: boot_sys_sh.asm
     2 4CFB 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   175 4CFE EE 17 18 D0 03 EE + 		INW	CURR_DIR_CNT	    ; increment total dir count
   176 4D06 4C 33 4D				JMP     PRINT_ATTRIB
   177
   178 				; Print File Size **************************************************************
   179 4D09 20 5E E0		PRINT_SIZE      JSR     SPCOUT
   180 4D0C 20 5E E0		                JSR     SPCOUT
   181 4D0F EE 15 18 D0 03 EE +                 INW  	CURR_FILE_CNT       ; increment total file count (word)
   182 4D17 A2 00		NO_FCNT_CARRY   LDX     #$00
   183 4D19 A0 1C		                LDY     #D_FILE_SIZE        ; index to file size
   184 4D1B 18			                CLC
   185 4D1C 08			                PHP
   186 4D1D 28			LOAD_SIZE       PLP
   187 4D1E B1 A8 95 C0		                MVA     (CURR_DIR_ENTRY),Y NUM32,X	; load file size into NUM32
   188 4D22 7D 19 18 9D 19 18	                ADC:STA CURR_USED_SIZE,X    		; add file size to total file size
   189 4D28 08			                PHP
   190 4D29 C8			                INY
   191 4D2A E8			                INX
   192 4D2B					CPX.NE	#$04 LOAD_SIZE			; branch if not done yet
Macro: CPX.NE [Source: macros.inc]
     1 4D2B E0 04				CPX	#$04
     2 4D2D D0 EE				BNE	LOAD_SIZE
Source: boot_sys_sh.asm
   193 4D2F 28			                PLP
   194 4D30 20 2B 4E		                JSR     PRINT_INT32         		; print file size
   195 				                
   196 				; Print File Attributes ********************************************************
   197 4D33 20 5E E0		PRINT_ATTRIB    JSR     SPCOUT
   198 4D36					BTST	CURR_CMD_PARAM 1 PRINT_DATE	; skip printing attributes is /A param is set
Macro: BTST [Source: macros.inc]
     4 4D36 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4D39 29 02				AND	#(1 << 1)
     6 4D3B F0 17				BEQ	PRINT_DATE
Source: boot_sys_sh.asm
   199 4D3D A2 07		                LDX     #$07
   200 4D3F 0E 12 18		GET_ATTRIB      ASL     F_ATTRIBS           		; move attribute bit into carry
   201 4D42			                LDA.EQ  ATTRIB_VAL,X NEXT_ATTRIB	; branch if attribute is not printable
Macro: LDA.EQ [Source: macros.inc]
     1 4D42 BD 2C 57				LDA	ATTRIB_VAL,X
     2 4D45 F0 07				BEQ	NEXT_ATTRIB
Source: boot_sys_sh.asm
   202 4D47 B0 02		                BCS     SET_ATTRIB			; branch if printable
   203
   204 4D49 A9 2D		CLEAR_ATTRIB    LDA     #'-'                		; attribute not set, print -
   205 4D4B 20 52 E0		SET_ATTRIB      JSR     COUT                		; print attribute
   206 4D4E			NEXT_ATTRIB     DEX.PL	GET_ATTRIB          		; repeat until all attributes printed
Macro: DEX.PL [Source: macros.inc]
     1 4D4E CA					DEX
     2 4D4F 10 EE				BPL	GET_ATTRIB
Source: boot_sys_sh.asm
   207 4D51 20 5E E0		                JSR     SPCOUT
   208 				                
   209 				; Print Date *******************************************************************
   210 				; Date Format: 15-09 Years from 1980 (0-127 -> 1980-2107)
   211 				;              08-05 Month of year (1-12)
   212 				;              04-00 Day of month (1-32)
   213 				; ******************************************************************************
   214 4D54 A0 18		PRINT_DATE      LDY     #D_LAST_WR_DATE     		; index to file last write date
   215 4D56 B1 A8 8D 22 4E	                MVA     (CURR_DIR_ENTRY),Y MONTH	; load file creation date low byte
   216 4D5B 29 1F		                AND     #$1F                		; mask day value
   217 4D5D 8D 23 4E		                STA     DAY
   218 4D60 C8			                INY
   219 4D61 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  ; load file creation date high byte
   220 4D63 4A			                LSR                         ; year in A
   221 4D64 6E 22 4E		                ROR     MONTH
   222 4D67 4E 22 4E 4E 22 4E +         :4      LSR     MONTH		    ; LSR 4
   223 4D73 18 69 50				ADD	#80		    ; same as CLC + ADC, year correction value (add 1980)
   224 4D76 8D 21 4E		                STA     YEAR
   225 4D79 AD 23 4E		                LDA     DAY
   226 4D7C 20 6D 4C		                JSR     NUMOUT
   227 4D7F			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D7F A9 2E			LDA	#'.'
     2 4D81 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   228 4D84 AD 22 4E		                LDA     MONTH
   229 4D87 20 6D 4C		                JSR     NUMOUT
   230 4D8A			                PRCH    '.'
Macro: PRCH [Source: macros.inc]
     1 4D8A A9 2E			LDA	#'.'
     2 4D8C 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   231 4D8F AC 21 4E		                LDY     YEAR
   232 4D92			                CPY.CC  #100 CENTURY_19	    ; branch if < 100
Macro: CPY.CC [Source: macros.inc]
     1 4D92 C0 64				CPY	#100			; 
     2 4D94 90 0C				BCC	CENTURY_19			; branch if C=0 (Y-b1 < 0)
Source: boot_sys_sh.asm
   233
   234 4D96 A9 14		                LDA     #20
   235 4D98 20 6D 4C		                JSR     NUMOUT
   236 4D9B 98			                TYA
   237 4D9C 38 E9 64				SUB	#100		    ; same as SEC + SBC
   238 4D9F 4C A8 4D		                JMP     PRINT_YEAR
   239
   240 4DA2 A9 13		CENTURY_19      LDA     #19
   241 4DA4 20 6D 4C		                JSR     NUMOUT
   242 4DA7 98			                TYA
   243 4DA8 20 6D 4C		PRINT_YEAR      JSR     NUMOUT
   244 4DAB 20 5E E0		                JSR     SPCOUT
   245 				                
   246 				; Print Time *******************************************************************
   247 				; Time Format: 15-11 Hours (0-23)
   248 				;              10-05 Minutes (0-59)
   249 				;              04-00 Seconds (0-29), 2-second intervals, so 29 gives 58 seconds.
   250 				; ******************************************************************************
   251 4DAE A0 16		PRINT_TIME      LDY     #D_LAST_WR_TIME     		; index to file Last write time
   252 4DB0 B1 A8 8D 24 4E	                MVA     (CURR_DIR_ENTRY),Y MINUTE	; load file last write time low byte
   253 4DB5 C8			                INY
   254 4DB6 B1 A8		                LDA     (CURR_DIR_ENTRY),Y  		; load file last write time high byte
   255 				        .rept 3
   256 						LSR     
   257 				                ROR     MINUTE
   258 					.endr	
Source: REPT
   256 4DB8 4A					LSR     
   256 4DB9 6E 24 4E		                ROR     MINUTE
   256 4DBC 4A					LSR     
   256 4DBD 6E 24 4E		                ROR     MINUTE
   256 4DC0 4A					LSR     
   256 4DC1 6E 24 4E		                ROR     MINUTE
Source: boot_sys_sh.asm
   259 4DC4 4E 24 4E 4E 24 4E	        :2      LSR     MINUTE
   260 4DCA 20 6D 4C		                JSR     NUMOUT
   261 4DCD			                PRCH     ':'		    ; Print :
Macro: PRCH [Source: macros.inc]
     1 4DCD A9 3A			LDA	#':'
     2 4DCF 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   262 4DD2 AD 24 4E		                LDA     MINUTE
   263 4DD5 20 6D 4C		                JSR     NUMOUT		    ; print minutes
   264
   265 				; Print Cluster Number *********************************************************
   266 				; Only with /C parameter: Prints Cluster number AND LBA number
   267 				; ******************************************************************************
   268 4DD8					BTST	CURR_CMD_PARAM 3 PRINT_EXIT		; Skip printing cluster nr if /C parameter is set
Macro: BTST [Source: macros.inc]
     4 4DD8 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4DDB 29 08				AND	#(1 << 3)
     6 4DDD F0 41				BEQ	PRINT_EXIT
Source: boot_sys_sh.asm
   269 4DDF 20 5E E0		                JSR	SPCOUT		    			; Print space
   270 4DE2					PRCLW	D_START_CLSTH CURR_DIR_ENTRY NUM32+2	; Print cluster nr (32-bit) and save it in NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DE2 A0 15				LDY	#D_START_CLSTH+1		; Print MSB of word
     1 4DE4 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DE6 85 C3				STA	NUM32+2+1
     5 4DE8 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DEB A0 14				LDY	#D_START_CLSTH			; Print LSB of word
     1 4DED B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DEF 85 C2				STA	NUM32+2
     5 4DF1 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   271 4DF4					PRCLW	D_START_CLST  CURR_DIR_ENTRY NUM32
Macro: PRCLW [Source: macros.inc]
     1 4DF4 A0 1B				LDY	#D_START_CLST+1		; Print MSB of word
     1 4DF6 B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4DF8 85 C1				STA	NUM32+1
     5 4DFA 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
     7 4DFD A0 1A				LDY	#D_START_CLST			; Print LSB of word
     1 4DFF B1 A8				LDA	(CURR_DIR_ENTRY),Y
     3 4E01 85 C0				STA	NUM32
     5 4E03 20 91 E0				JSR	HEXOUT			; changes Y!
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   272 4E06 20 5E E0				JSR	SPCOUT
   273 4E09 20 FF 40				JSR	CLSTR_TO_LBA	   			; Convert NUM32 Cluster nr into NUM32 LBA
   274 4E0C					PRHEX32	NUM32			        	; and print as 32-bit hex number
Macro: PRHEX32 [Source: macros.inc]
     1 4E0C A5 C3			LDA	NUM32+2+1				; print MSB
     2 4E0E 20 91 E0			JSR	HEXOUT
     3 4E11 A5 C2			LDA	NUM32+2
     4 4E13 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 4E16 A5 C1			LDA	NUM32+1				; print MSB
     2 4E18 20 91 E0			JSR	HEXOUT
     3 4E1B A5 C0			LDA	NUM32
     4 4E1D 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   275 4E20 60			PRINT_EXIT	RTS
   276
   277 4E21 00			YEAR		.byte 	$00
   278 4E22 00			MONTH		.byte 	$00
   279 4E23 00			DAY 		.byte	$00
   280 4E24 00			MINUTE		.byte 	$00
   281 				                
   282 				; **** Print 16 Bit Number *****************************************************
   283 				; Input: X,Y = Int16
   284 				; ******************************************************************************
   285 4E25 20 99 4E		PRINT_INT16     JSR     BIN16_TO_BCD
   286 4E28 4C 2E 4E		                JMP     PRINT_NUM
   287 				                
   288 				; **** Print 32 Bit Number *****************************************************
   289 				; Input: NUM32[0..3] = Int32
   290 				; Output: C = 0 - Number is 0; C = 1 - Number <> 0
   291 				; ******************************************************************************
   292 4E2B 20 A3 4E		PRINT_INT32     JSR     BIN32_TO_BCD        ; convert NUM32 into BCD
   293 4E2E A2 00		PRINT_NUM       LDX     #$00
   294 4E30 A0 0A		                LDY     #10
   295 4E32 18			                CLC                         ; save status bits
   296 4E33 08			PRINT_NUM1      PHP                         ; store current carry flag
   297 4E34 20 6A 4E		                JSR     PRINT_SEPARATOR
   298 4E37 BD 34 57		                LDA     BCD_VAL,X           ; load two decimal digits
   299 4E3A 48			                PHA                         ; store A
   300 4E3B 98			                TYA                         ; move digit counter into A
   301 4E3C 4A			                LSR                         ; bit one into carry
   302 4E3D 68			                PLA                         ; restore A
   303 4E3E 90 05		                BCC     SET_DIGIT1          ; is it a even digit?
   304 						
   305 4E40 E8			                INX                         ; no, process digit 2
   306 4E41 29 0F		                AND     #$0F
   307 4E43 10 04		                BPL     SET_DIGIT2
   308 4E45 4A 4A 4A 4A		SET_DIGIT1 :4   LSR                         ; LSR4, shift upper digit of BCD into lower nibble
   309 4E49 28			SET_DIGIT2      PLP
   310 4E4A B0 16		                BCS     PRINT_DIGIT         ; check if we processed at least one digit <> 0
   311 						
   312 4E4C			                AND.NE  #$0F PRINT_DIGIT    ; branch if not a leading 0, print digit
Macro: AND.NE [Source: macros.inc]
     6 4E4C 29 0F				AND	#$0F
     7 4E4E D0 12				BNE	PRINT_DIGIT
Source: boot_sys_sh.asm
   313 4E50 98			                TYA
   314 4E51			                CMP.NE  #1 PRINT_SPACE      ; is it the last digit? Branch if not, just print space char
Macro: CMP.NE [Source: macros.inc]
     1 4E51 C9 01				CMP	#1
     2 4E53 D0 07				BNE	PRINT_SPACE
Source: boot_sys_sh.asm
   315 4E55 A9 30		                LDA     #48                 ; yes, print 0
   316 4E57 20 9A E0		                JSR     HEXDIG
   317 4E5A 18			                CLC                         ; number is 0
   318 4E5B 60			                RTS
   319 						
   320 4E5C 20 5E E0		PRINT_SPACE     JSR     SPCOUT              ; print space
   321 4E5F 18			                CLC
   322 4E60 90 04		                BCC     NEXT_DIGIT	    ; branch always
   323 						
   324 4E62 20 9A E0		PRINT_DIGIT     JSR     HEXDIG              ; print single digit
   325 4E65 38			                SEC                         ; no more leading 0s
   326 4E66			NEXT_DIGIT      DEY.NE	PRINT_NUM1          ; repeat if more digits
Macro: DEY.NE [Source: macros.inc]
     1 4E66 88					DEY
     2 4E67 D0 CA				BNE	PRINT_NUM1
Source: boot_sys_sh.asm
   327 4E69 60			                RTS
   328 				                
   329 				; Print Thousands Separator ****************************************************
   330 4E6A 08			PRINT_SEPARATOR PHP                         ; save status bits
   331 4E6B			                CPY.EQ  #$09 PRINT_SEP      ; branch if at 9th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E6B C0 09				CPY	#$09
     2 4E6D F0 08				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   332 4E6F			                CPY.EQ  #$06 PRINT_SEP      ; branch if at 6th digit, print separator
Macro: CPY.EQ [Source: macros.inc]
     1 4E6F C0 06				CPY	#$06
     2 4E71 F0 04				BEQ	PRINT_SEP
Source: boot_sys_sh.asm
   333 4E73			                CPY.NE  #$03 NO_SEP         ; branch if not at 3rd digit, exit
Macro: CPY.NE [Source: macros.inc]
     1 4E73 C0 03				CPY	#$03
     2 4E75 D0 0B				BNE	NO_SEP
Source: boot_sys_sh.asm
   334 						
   335 4E77 28			PRINT_SEP       PLP                         ; restore status bits
   336 4E78 90 05		                BCC     PRINT_SPC           ; leading zero, just print a space char
   337 						
   338 4E7A A9 2E		                LDA     #NUM_SEP
   339 4E7C 4C 52 E0		                JMP     COUT                ; print thousands seperator
   340 						
   341 4E7F 4C 5E E0		PRINT_SPC       JMP     SPCOUT
   342 4E82 28			NO_SEP          PLP                         ; clean up stack
   343 4E83 60			                RTS
   344 				                
   345 				;**** Convert BCD Number To 8 Bit Binary ***************************************
   346 				; INPUT:  A = BCD Number
   347 				; Output: A = Binary Number
   348 				; ******************************************************************************
   349 4E84 85 C0		BCD_TO_BIN      STA     NUM32               ; save BCD number
   350 4E86 29 F0		                AND     #$F0                ; and clear ones digit in A
   351 4E88 4A			                LSR                         ; calc tens digit * 8
   352 4E89 85 C1		                STA     NUM32+1             ; and store result
   353 4E8B 4A 4A		        :2      LSR     		    ; calc tens digit * 2
   354 4E8D 18 65 C1 85 C1			ADD:STA	NUM32+1		    ; add it with tens digit * 8 and store result
   355 4E92 A5 C0		                LDA     NUM32               ; reload BCD number int A
   356 4E94 29 0F		                AND     #$0F                ; and clear tens digit in A
   357 4E96 65 C1		                ADC     NUM32+1             ; finally add both result
   358 4E98 60			                RTS			    ; return
   359 				                
   360 				;**** Convert 16 Bit Binary Number To BCD **************************************
   361 				; INPUT:  Int[X:Y]      = 16 Bit Binary
   362 				; OUTPUT: BCD_VAL[4..0] = Result
   363 				; ******************************************************************************
   364 4E99			BIN16_TO_BCD    STXY	NUM32		    ; Store [X:Y] in lower word
Macro: STXY [Source: macros.inc]
     1 4E99 86 C0			STX	NUM32
     2 4E9B 84 C1			STY	NUM32+1
Source: boot_sys_sh.asm
   365 4E9D A2 00 86 C2 86 C3			MWX	#$00 NUM32+2	    ; clear upper word
   366 				                
   367 				;**** Convert 32 Bit Binary Number To BCD **************************************
   368 				; INPUT:  NUM32[0..3]   = 32 Bit Binary
   369 				; OUTPUT: BCD_VAL[4..0] = Result
   370 				;*******************************************************************************
   371 4EA3 F8			BIN32_TO_BCD    SED                         ; set decimal mode
   372 4EA4 A2 04		                LDX     #$04
   373 4EA6 A9 00		                LDA     #$00                ; clear BCD result value
   374 4EA8 9D 34 57 CA		CLEAR_BCD       STA     BCD_VAL,X-
   375 4EAC 10 FA		                BPL     CLEAR_BCD
   376
   377 4EAE A2 20		                LDX     #$20                ; 32 source bits
   378 4EB0			CONV_BITS       ASL32	NUM32		    ; shift MSB of NUM32 into carry flag
Macro: ASL32 [Source: macros.inc]
     1 4EB0 06 C0			ASL     NUM32		  		; SHL with C=0
     2 4EB2 26 C1		        ROL     NUM32+1		  
     3 4EB4 26 C2		        ROL     NUM32+2
     4 4EB6 26 C3		        ROL     NUM32+3		  
Source: boot_sys_sh.asm
   379 4EB8 AD 38 57 6D 38 57 + 		LDA:ADC:STA BCD_VAL+4	    ; and shift carry back into BCD result
   380 4EC1 AD 37 57 6D 37 57 + 		LDA:ADC:STA BCD_VAL+3	    ; by adding BCD_VAL = BCD_VAL + BCD_VAL + C
   381 4ECA AD 36 57 6D 36 57 + 		LDA:ADC:STA BCD_VAL+2	    ; ...
   382 4ED3 AD 35 57 6D 35 57 + 		LDA:ADC:STA BCD_VAL+1	    ; ...
   383 4EDC AD 34 57 6D 34 57 + 		LDA:ADC:STA BCD_VAL	    ; uses more code, but faster than looping
   384 4EE5			                DEX.NE	CONV_BITS           ; repeat until all 32 bits done
Macro: DEX.NE [Source: macros.inc]
     1 4EE5 CA					DEX
     2 4EE6 D0 C8				BNE	CONV_BITS
Source: boot_sys_sh.asm
   385 4EE8 D8			                CLD                         ; reset to binary mode
   386 4EE9 60			                RTS
   387
   388 				; **** Get Command String ******************************************************
   389 				;
   390 				; ******************************************************************************
   391 4EEA A2 01		GET_CMD_STR     LDX     #$01
   392 4EEC			GET_CMD_CHAR    LDA.EQ  STRBUF,X END_PARAM	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4EEC BD 00 14				LDA	STRBUF,X
     2 4EEF F0 2D				BEQ	END_PARAM
Source: boot_sys_sh.asm
   393 4EF1			                CMP.NE	#SPC     END_PARAM	; branch if not a space
Macro: CMP.NE [Source: macros.inc]
     1 4EF1 C9 20				CMP	#SPC
     2 4EF3 D0 29				BNE	END_PARAM
Source: boot_sys_sh.asm
   394 4EF5 E8			SKIP_SPC_CHAR   INX
   395 4EF6 4C EC 4E		                JMP     GET_CMD_CHAR
   396 				                
   397 				; **** Get Parameter String ****************************************************
   398 				; Output: C = 1: Parameter; C = 0: Path
   399 				;         A    = $00 : End of parameter string
   400 				;         NCNT = Index to parameter
   401 				; ******************************************************************************
   402 4EF9 A6 AC		GET_NEXT_PARAM  LDX     NCNT                ; get actual index into command line
   403 4EFB 20 09 4F		                JSR     GET_PARM_CHAR
   404 4EFE					CMP.NE	#OPT_SEP PATH_STR   ; branch if not a '/'
Macro: CMP.NE [Source: macros.inc]
     1 4EFE C9 2F				CMP	#OPT_SEP
     2 4F00 D0 18				BNE	PATH_STR
Source: boot_sys_sh.asm
   405 4F02 E8			                INX			    ; next char
   406 4F03 BD 00 14		                LDA     STRBUF,X	    ; load parameter
   407 4F06 4C 1D 4F		                JMP     PARAM_STR	    ; OK and return
   408
   409 4F09			GET_PARM_CHAR   LDA.EQ  STRBUF,X PATH_STR   	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 4F09 BD 00 14				LDA	STRBUF,X
     2 4F0C F0 0C				BEQ	PATH_STR
Source: boot_sys_sh.asm
   410 4F0E					CMP.EQ	#SPC     SKIP_SPC_CHAR	; branch if a space
Macro: CMP.EQ [Source: macros.inc]
     1 4F0E C9 20				CMP	#SPC
     2 4F10 F0 E3				BEQ	SKIP_SPC_CHAR
Source: boot_sys_sh.asm
   411 4F12					CMP.EQ	#OPT_SEP PARAM_STR	; branch if a '/'
Macro: CMP.EQ [Source: macros.inc]
     1 4F12 C9 2F				CMP	#OPT_SEP
     2 4F14 F0 07				BEQ	PARAM_STR
Source: boot_sys_sh.asm
   412 4F16 E8			                INX			    
   413 4F17 4C 09 4F		                JMP     GET_PARM_CHAR
   414
   415 4F1A 18			PATH_STR        CLC			    ; C=0, it is a path
   416 4F1B 90 01		                BCC     END_PARAM	    ; branch always
   417
   418 4F1D 38			PARAM_STR       SEC			    ; C=1, it is a parameter
   419 4F1E 86 AC		END_PARAM       STX     NCNT		    ; save index in parameter string
   420 4F20 48			                PHA
   421 4F21 68			                PLA
   422 4F22 60			                RTS			    ; return
   423
   424 				; **** Internal Command Handlers ***********************************************
   425
   426 				; **** Directory Loop Call Back Functions **************************************
   427 				; Input : A - First character of filename
   428 				;         X - File Attributes
   429 				; Output: C = 0 - Continue print loop, C = 1 - Break print loop
   430 				; ******************************************************************************
   431
   432 				; **** Print Directory Entry - Call Back Routine *******************************
   433 4F23			CB_PRINT_DIR    CPX.EQ  #$0F CB_PRINT_CONT		; skip to next entry if long filename entry
Macro: CPX.EQ [Source: macros.inc]
     1 4F23 E0 0F				CPX	#$0F
     2 4F25 F0 5C				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   434 4F27					CMP.EQ  #$E5 CB_PRINT_CONT  		; branch (skip to next entry) if entry is deleted
Macro: CMP.EQ [Source: macros.inc]
     1 4F27 C9 E5				CMP	#$E5
     2 4F29 F0 58				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   435 4F2B 8E 12 18		                STX     F_ATTRIBS           		; save attributes
   436 4F2E 8A			                TXA
   437 4F2F 4A			                LSR     
   438 4F30 4A			CHK_HIDDEN      LSR                         		; check if hidden file
   439 4F31 90 07		                BCC     CHK_SYSTEM	    		; branch if not a hidden file
   440
   441 4F33			                BTST	CURR_CMD_PARAM 2 CB_PRINT_CONT	; Skip line counting if dir /H (display hidden files) is set
Macro: BTST [Source: macros.inc]
     4 4F33 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F36 29 04				AND	#(1 << 2)
     6 4F38 F0 49				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   442 4F3A 4A			CHK_SYSTEM      LSR                         		; check if system file
   443 4F3B 4A			CHK_LABEL       LSR                         		; check if disk label
   444 				                ; #### PRINT LABEL DISABLED ####################################
   445 4F3C B0 45		                BCS     CB_PRINT_CONT       		; it's a label, skip to next entry
   446
   447 				                ;BCC     PRINT_DIR_ENTRY
   448 				                ;JSR     PRINT_LABEL         		; print disk label
   449 				                ;INC     LINE_CNT
   450 				                ;BNE     CHK_LINE_COUNT     		 ; branch always
   451 				                ; ##############################################################
   452 4F3E			PRINT_DIR_ENTRY LDA.NE  TERM_CHAR COMP_MASK		; check the termination char, if >0 then just compare file names
Macro: LDA.NE [Source: macros.inc]
     1 4F3E AD 11 18				LDA	TERM_CHAR
     2 4F41 D0 0F				BNE	COMP_MASK
Source: boot_sys_sh.asm
   453 4F43 20 CA 4A		                JSR     CB_FIND_SUBDIR      		; TC = 0, so check if directory entry
   454 4F46 90 3B		                BCC     CB_PRINT_CONT       		; name is a file entry or includes wildcard chars, just exit
   455
   456 4F48 A9 5C 8D 11 18	                MVA     #PATH_SEP TERM_CHAR 		; TERM_CHAR = name compared equal with a directory entry
   457 4F4D 20 7A 48		                JSR     OS_DIR_LOOP         		; list files of sub directory
   458 4F50 38			                SEC                         		; directory list finished
   459 4F51 60			                RTS                         		; exit
   460
   461 4F52 20 85 4F		COMP_MASK       JSR     SH_COMP_MASK
   462 4F55 90 2D		                BCC     CB_PRINT_END
   463
   464 4F57 A9 01 85 EE		PRINT_ITEM      MVA     #1 PSAV		    		; set file found flag
   465 4F5B 20 CD 4C		                JSR     PRINT_FILENAME      		; print filename
   466 4F5E 20 F0 4C		                JSR     PRINT_FILE_INFO     		; print file size, date and time
   467 4F61 20 5A E0		                JSR     CROUT
   468 4F64			                BTST    CURR_CMD_PARAM 0 CB_PRINT_CONT	; Skip line counting if dir /P parameter is set
Macro: BTST [Source: macros.inc]
     4 4F64 AD 1F 18				LDA	CURR_CMD_PARAM
     5 4F67 29 01				AND	#(1 << 0)
     6 4F69 F0 18				BEQ	CB_PRINT_CONT
Source: boot_sys_sh.asm
   469 4F6B EE 14 18		CHK_LINE_COUNT  INC     LINE_CNT
   470 4F6E A9 19		                LDA     #25
   471 4F70					CMP.CS	LINE_CNT CB_PRINT_CONT		; reached one screen page? Branch if not, just exit
Macro: CMP.CS [Source: macros.inc]
     1 4F70 CD 14 18				CMP	LINE_CNT			; 
     2 4F73 B0 0E				BCS	CB_PRINT_CONT			; branch if C=1 (A-b1 >= 0)
Source: boot_sys_sh.asm
   472 4F75 A9 00 8D 14 18	                MVA     #$00 LINE_CNT       		; reset line counter
   473 4F7A 20 E8 53		                JSR     SH_PAUSE            		; wait for key press
   474 4F7D			                CMP.NE	#27 CB_PRINT_CONT   		; ESC pressed? Branch if not
Macro: CMP.NE [Source: macros.inc]
     1 4F7D C9 1B				CMP	#27
     2 4F7F D0 02				BNE	CB_PRINT_CONT
Source: boot_sys_sh.asm
   475 4F81 38			                SEC                         		; break dir loop
   476 4F82 60			                RTS
   477 4F83 18			CB_PRINT_CONT   CLC                         		; get next next entry
   478 4F84 60			CB_PRINT_END    RTS
   479
   480 				; **** Compare File Name With Mask Using Wildcards *****************************
   481 				;
   482 				; ******************************************************************************
   483 4F85			SH_COMP_MASK    CMP.EQ	#PATH_SEP COMP_NAME_EQU			; Termination char = path separator? Branch if it is, skip compare
Macro: CMP.EQ [Source: macros.inc]
     1 4F85 C9 5C				CMP	#PATH_SEP
     2 4F87 F0 10				BEQ	COMP_NAME_EQU
Source: boot_sys_sh.asm
   484 4F89 A0 0A		                LDY     #10                 			; compare all characters
   485 4F8B B9 9A 4B		COMP_NAME_CHAR  LDA     FILENAME,Y          			; get char from compare mask
   486 4F8E					CMP.EQ	#'?' SKIP_NAME_CHAR			; Skip comparing with a '?' char
Macro: CMP.EQ [Source: macros.inc]
     1 4F8E C9 3F				CMP	#'?'
     2 4F90 F0 04				BEQ	SKIP_NAME_CHAR
Source: boot_sys_sh.asm
   487 4F92					CMP.NE	(CURR_DIR_ENTRY),Y COMP_NAME_NEQ	; Compare char, if not equal, exit with C=0
Macro: CMP.NE [Source: macros.inc]
     1 4F92 D1 A8				CMP	(CURR_DIR_ENTRY),Y
     2 4F94 D0 05				BNE	COMP_NAME_NEQ
Source: boot_sys_sh.asm
   488 						
   489 4F96			SKIP_NAME_CHAR  DEY.PL	COMP_NAME_CHAR      			; more character to compare
Macro: DEY.PL [Source: macros.inc]
     1 4F96 88					DEY
     2 4F97 10 F2				BPL	COMP_NAME_CHAR
Source: boot_sys_sh.asm
   490 4F99 38			COMP_NAME_EQU   SEC                         			; all characters are equal, set Carry = 1
   491 4F9A 60			                RTS
   492 4F9B 18			COMP_NAME_NEQ   CLC
   493 4F9C 60			                RTS
   494
   495 				; ******************************************************************************
   496 				; ******************************************************************************
   497 4F9D 00 00 00 00		SAVED_ACT_DIR   .byte      $00, $00, $00, $00
   498 4FA1 00 00 00 00		SAVED_DIR_BLK   .byte      $00, $00, $00, $00
   499 				; + DRIVE
   500 				                
   501 4FA5 A0 03		SAVE_ACT_DIR    LDY     #$03		   		; Save D_ACTUAL_DIR and CURR_DIR_BLK
   502 4FA7 B9 04 04 99 9D 4F	SAVE_DIR_ADDR   MVA	D_ACTUAL_DIR,Y SAVED_ACT_DIR,Y	; SAVED_ACT_DIR = D_ACTUAL_DIR
   503 4FAD B9 24 18 99 A1 4F + 		MVA	CURR_DIR_BLK,Y SAVED_DIR_BLK,Y-	; SAVED_DIR_BLK = CURR_DIR_BLK
   504 4FB4 10 F1		                BPL     SAVE_DIR_ADDR			; branch if not finished
   505 4FB6 60			                RTS					; return
   506 				                
   507 4FB7 A0 03		LOAD_ACT_DIR    LDY     #$03
   508 4FB9 B9 9D 4F 99 04 04	LOAD_DIR_ADDR   MVA	SAVED_ACT_DIR,Y D_ACTUAL_DIR,Y	; D_ACTUAL_DIR = SAVED_ACTUAL_DIR
   509 4FBF B9 A1 4F 99 24 18 + 		MVA	SAVED_DIR_BLK,Y CURR_DIR_BLK,Y-	; CURR_DIR_BLK = SAVED_DIR_BLK
   510 4FC6 10 F1		                BPL     LOAD_DIR_ADDR			; branch if not finished
   511 4FC8 60			                RTS					; return
   512 				                
   513 				; **** Get Parameters from Command Line ****************************************
   514 				; Input:  Ptr[X:Y] to Parameter String
   515 				; Output: C = 0 - Error; C = 1 - No Error
   516 				; ******************************************************************************
   517 4FC9 20 36 50		SH_GET_PARMS    JSR     SET_PARM_MASK	    ; set pointer to parameter mask
   518 4FCC A9 00		                LDA     #$00                ; set current command parameter value to 0
   519 4FCE 8D 1F 18		GET_PARM        STA     CURR_CMD_PARAM
   520 4FD1 A0 01 84 AA		GET_PARM2       MVY     #$01 MASK           ; reset bit mask to 00000001
   521 4FD5 88			                DEY                         ; param mask pointer is set to 0
   522 4FD6 20 F9 4E		                JSR     GET_NEXT_PARAM      ; find next command parameter in command line
   523 4FD9 F0 3B		                BEQ     GET_PARMS_END       ; reached end of command line
   524 4FDB B0 06		                BCS     PARSE_PARM          ; C=1: parameter found? branch if parameter
   525 						
   526 4FDD 20 18 50		                JSR     SH_GET_PATH         ; no, parse path parameter
   527 4FE0 B0 EF		                BCS     GET_PARM2           ; more parameters
   528
   529 4FE2 60			                RTS			    ; return
   530 						
   531 4FE3 20 62 4C		PARSE_PARM      JSR     UPPERCASE	    ; convert to uppercase
   532 4FE6 8D 12 18		                STA     F_ATTRIBS           ; no, save current parameter as F_ATTRIBS
   533 4FE9 B1 E8		COMP_PARM       LDA     (STOL),Y            ; load a char from param mask (STOL = Ptr to param mask)
   534 4FEB			                CMP.EQ	#SPC PARM_ERR	    ; is it a ' '? Branch if all allowed param chars are compared -> unknown param
Macro: CMP.EQ [Source: macros.inc]
     1 4FEB C9 20				CMP	#SPC
     2 4FED F0 12				BEQ	PARM_ERR
Source: boot_sys_sh.asm
   535 4FEF					CMP.NE  F_ATTRIBS NEXT_MASK ; Compare actual parameter char with param mask. Branch if not equal, get next char from param mask
Macro: CMP.NE [Source: macros.inc]
     1 4FEF CD 12 18				CMP	F_ATTRIBS
     2 4FF2 D0 08				BNE	NEXT_MASK
Source: boot_sys_sh.asm
   536 4FF4 A5 AA		                LDA     MASK                ; load bit mask
   537 4FF6 0D 1F 18		                ORA     CURR_CMD_PARAM      ; and set actual parameter bit
   538 4FF9 4C CE 4F		                JMP     GET_PARM            ; get next parameter from command line
   539
   540 4FFC C8			NEXT_MASK       INY                         ; point to next char in param mask
   541 4FFD 06 AA		                ASL     MASK                ; shift bit mask to next position
   542 4FFF D0 E8		                BNE     COMP_PARM	    ; branch if more to do
   543
   544 5001 20 5A E0		PARM_ERR        JSR     CROUT		    ; print CR
   545 5004			                LDXYI   MSG_PARAM_ERR       ; load error message
Macro: LDXYI [Source: macros.inc]
     1 5004 A2 BF			LDX	<MSG_PARAM_ERR				; MADS makes this immediate
     2 5006 A0 56			LDY	>MSG_PARAM_ERR
Source: boot_sys_sh.asm
   546 5008 20 C5 49		                JSR     OS_PRINT_ERR        ; and print it
   547 500B AD 12 18		                LDA     F_ATTRIBS
   548 500E 20 52 E0		                JSR     COUT                ; print unknown parameter char
   549 5011 20 5A E0		                JSR     CROUT		    ; print CR
   550 5014 18			                CLC			    ; C=0: error
   551 5015 60			                RTS
   552 5016 38			GET_PARMS_END   SEC			    ; C=1: OK
   553 5017 60			                RTS
   554 				                
   555 				; ******************************************************************************
   556 5018 A6 AC		SH_GET_PATH     LDX     NCNT                ; get pointer path string into X:Y
   557 501A A0 14		                LDY     #> STRBUF
   558 501C 20 CA 49		                JSR     OS_PARSE_PATH
   559 501F B0 14		                BCS     GET_PATH_END
   560 5021 D0 03		SH_ERROR        BNE     PARSE_ERR1
   561
   562 5023 4C E8 54		                JMP     SH_NAME_ERR
   563
   564 5026			PARSE_ERR1      CMP.NE  #PATH_SEP PARSE_ERR2
Macro: CMP.NE [Source: macros.inc]
     1 5026 C9 5C				CMP	#PATH_SEP
     2 5028 D0 03				BNE	PARSE_ERR2
Source: boot_sys_sh.asm
   565 502A 4C E1 54		                JMP     SH_DIR_ERR
   566
   567 502D			PARSE_ERR2      CMP.NE  #$FF GET_PATH_ERR
Macro: CMP.NE [Source: macros.inc]
     1 502D C9 FF				CMP	#$FF
     2 502F D0 03				BNE	GET_PATH_ERR
Source: boot_sys_sh.asm
   568 5031 4C DA 54		                JMP     SH_PATH_ERR
   569 5034 18			GET_PATH_ERR    CLC
   570 5035 60			GET_PATH_END    RTS
   571
   572 				; **** Set Pointer To Parameter Mask *******************************************
   573 				; Input: Ptr[X:Y] = Pointer to Parameter Mask
   574 				; ******************************************************************************
   575 5036			SET_PARM_MASK   STXY	STOL			; save pointer to command param mask
Macro: STXY [Source: macros.inc]
     1 5036 86 E8			STX	STOL
     2 5038 84 E9			STY	STOL+1
Source: boot_sys_sh.asm
   576 503A A9 00 8D 1F 18			MVA	#0 CURR_CMD_PARAM	; set current command parameter value to 0
   577 503F A9 5C 8D 11 18			MVA	#PATH_SEP TERM_CHAR	; TERM_CHAR = PATH_SEP
   578 5044 60			                RTS
   579
   580 				; Allowed Directory Options ****************************************************
   581 5045 50 41 48 43 20	DIR_PARMS       .by    'PAHC '               	; param mask for DIR command
   582 504A 20			NO_PARMS        .by    ' '
   583
   584 				; **** DIR Command *************************************************************
   585 				; Prints a directory. The following optional parameters can be used:
   586 				; /P : 
   587 				; /A : Show attributes
   588 				; /H : Show hidden files
   589 				; /C : Show cluster number and LBA number
   590 				; ******************************************************************************
   591 504B 20 5A E0		SH_DIR          JSR     CROUT			; print CR
   592 504E 20 A5 4F		                JSR     SAVE_ACT_DIR        	; save actual-dir cluster nr
   593 5051			                LDXYI   DIR_PARMS
Macro: LDXYI [Source: macros.inc]
     1 5051 A2 45			LDX	<DIR_PARMS				; MADS makes this immediate
     2 5053 A0 50			LDY	>DIR_PARMS
Source: boot_sys_sh.asm
   594 5055 20 C9 4F		                JSR     SH_GET_PARMS		; Get parameters from command-line
   595 5058 B0 03		                BCS     SH_DIR_START		; branch if parameter found
   596
   597 505A 4C B7 4F		                JMP     LOAD_ACT_DIR        	; restore actual directory LBA
   598
   599 505D A2 00		SH_DIR_START    LDX     #$00
   600 505F 8A			                TXA
   601 5060 8D 14 18		                STA     LINE_CNT            	; reset line counter
   602 5063 85 EE		                STA     PSAV                	; reset file found flag
   603 5065 9D 15 18 E8		CLEAR_CNT       STA     CURR_FILE_CNT,X+     	; clear file count, dir count and byte count
   604 5069			                CPX.NE  #$08 CLEAR_CNT		; branch if not 8 bytes cleared yet
Macro: CPX.NE [Source: macros.inc]
     1 5069 E0 08				CPX	#$08
     2 506B D0 F8				BNE	CLEAR_CNT
Source: boot_sys_sh.asm
   605 506D			                LDXYI   CB_PRINT_DIR  		; print call-back routine
Macro: LDXYI [Source: macros.inc]
     1 506D A2 23			LDX	<CB_PRINT_DIR				; MADS makes this immediate
     2 506F A0 4F			LDY	>CB_PRINT_DIR
Source: boot_sys_sh.asm
   606 5071 20 6E 48		                JSR     OS_FIND_ALL         	; find and print directory entries
   607 5074 20 B7 4F		                JSR     LOAD_ACT_DIR        	; restore actual directory LBA
   608 5077			                LDA.NE  PSAV PRINT_RESULT      	; Branch if any files found, print dir. result
Macro: LDA.NE [Source: macros.inc]
     1 5077 A5 EE				LDA	PSAV
     2 5079 D0 03				BNE	PRINT_RESULT
Source: boot_sys_sh.asm
   609 507B 4C D3 54		                JMP     SH_FILE_ERR         	; no, print error
   610
   611 507E 20 5A E0		PRINT_RESULT    JSR     CROUT			; Print CR
   612 5081 EE 14 18 EE 14 18	        :2      INC     LINE_CNT		; LINE_CNT += 2
   613 5087 20 6B 4F		                JSR     CHK_LINE_COUNT		; if LINE_CNT > 25 then SH_PAUSE
   614 				                
   615 				; Print Total File Count
   616 508A			                LDXY	CURR_FILE_CNT		; [X,Y] = Current nr of files
Macro: LDXY [Source: macros.inc]
     1 508A AE 15 18			LDX	CURR_FILE_CNT
     2 508D AC 16 18			LDY	CURR_FILE_CNT+1
Source: boot_sys_sh.asm
   617 5090 20 25 4E		                JSR     PRINT_INT16		; print as word
   618 5093			                PRSTR   MSG_FILE_COUNT		; print 'file(s) '
Macro: PRSTR [Source: macros.inc]
     1 5093 A2 70			LDX	<MSG_FILE_COUNT				; MADS makes this immediate
     2 5095 A0 56			LDY	>MSG_FILE_COUNT
Source: boot_sys_sh.asm
     2 5097 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   619
   620 				; Print Total Used Bytes In Directory
   621 509A			                LDXYI   CURR_USED_SIZE		; Total filesize
Macro: LDXYI [Source: macros.inc]
     1 509A A2 19			LDX	<CURR_USED_SIZE				; MADS makes this immediate
     2 509C A0 18			LDY	>CURR_USED_SIZE
Source: boot_sys_sh.asm
   622 509E 20 61 41		                JSR     LOAD_32			; NUM32 = total filesize
   623 50A1 20 2B 4E		                JSR     PRINT_INT32		; print as int32
   624 50A4			                PRSTR   MSG_BYTE_USED		; print ' bytes'
Macro: PRSTR [Source: macros.inc]
     1 50A4 A2 86			LDX	<MSG_BYTE_USED				; MADS makes this immediate
     2 50A6 A0 56			LDY	>MSG_BYTE_USED
Source: boot_sys_sh.asm
     2 50A8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   625
   626 				; Print Total Directory Count
   627 50AB					LDXY	CURR_DIR_CNT		; nr of directories
Macro: LDXY [Source: macros.inc]
     1 50AB AE 17 18			LDX	CURR_DIR_CNT
     2 50AE AC 18 18			LDY	CURR_DIR_CNT+1
Source: boot_sys_sh.asm
   628 50B1 20 25 4E		                JSR     PRINT_INT16		; Print as word
   629 50B4			                PRSTR   MSG_DIR_COUNT		; print ' dir(s)'
Macro: PRSTR [Source: macros.inc]
     1 50B4 A2 7B			LDX	<MSG_DIR_COUNT				; MADS makes this immediate
     2 50B6 A0 56			LDY	>MSG_DIR_COUNT
Source: boot_sys_sh.asm
     2 50B8 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   630 50BB					MVAX	4 FREE_KB NUM32		; NUM32 = #Free KB
Macro: MVAX [Source: macros.inc]
     1 50BB A2 03			LDX	#4-1
     2 50BD BD A7 55 95 C0 CA	lp	MVA	FREE_KB,X NUM32,X-
     3 50C3 10 F8			BPL	lp
Source: boot_sys_sh.asm
   631 50C5 20 2B 4E				JSR	PRINT_INT32		; Print as decimal number
   632 50C8					PRSTR	TXT_KB			; Print ' KB free'
Macro: PRSTR [Source: macros.inc]
     1 50C8 A2 C0			LDX	<TXT_KB				; MADS makes this immediate
     2 50CA A0 55			LDY	>TXT_KB
Source: boot_sys_sh.asm
     2 50CC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   633 50CF 60					RTS				; return
   634 						
   635 				; **** Create Directory (MKDIR) Command ****************************************
   636 				;
   637 				; ******************************************************************************
   638 50D0 20 A5 4F		SH_MKDIR        JSR     SAVE_ACT_DIR        	; save actual directory LBA
   639 50D3			                LDXYI   NO_PARMS          	; we don't need parameters, evtl. /H hidden /S system
Macro: LDXYI [Source: macros.inc]
     1 50D3 A2 4A			LDX	<NO_PARMS				; MADS makes this immediate
     2 50D5 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   640 50D7 20 C9 4F		                JSR     SH_GET_PARMS        	; get path
   641 50DA 90 13		                BCC     SH_MKDIR_END	    	; branch if no dirname was given
   642
   643 50DC A9 10		                LDA     #FA_DIRECTORY		; create directory
   644 50DE 20 AE 47		                JSR     OS_CREATE           	; create directory
   645 50E1 B0 0C		                BCS     SH_MKDIR_END        	; if no errors, clean up and exit
   646
   647 50E3			MKDIR_ERR       CMP.EQ  #$FF DIR_EXISTS_ERR    	; if error code = -1 then dir already exists
Macro: CMP.EQ [Source: macros.inc]
     1 50E3 C9 FF				CMP	#$FF
     2 50E5 F0 05				BEQ	DIR_EXISTS_ERR
Source: boot_sys_sh.asm
   648
   649 50E7 20 F6 54		                JSR     SH_WRITE_ERR        	; it was a write error
   650 50EA 90 03		                BCC     SH_MKDIR_END        	; branch always
   651
   652 50EC 20 EF 54		DIR_EXISTS_ERR  JSR     SH_D_EXIST_ERR		; Print 'Dir already exists'
   653 50EF 4C B7 4F		SH_MKDIR_END    JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
   654
   655 				; **** Check if Current Dir. ***************************************************
   656 				; Check if directory entered is current dir (..).
   657 				; Output: C=0: not a current dir, C=1: is current dir.
   658 				; ******************************************************************************
   659 50F2 A0 00		IS_FNAME_CURDIR	LDY	#0
   660 50F4 B9 9A 4B				LDA	FILENAME,Y
   661 50F7					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 50F7 C9 2E				CMP	#'.'
     2 50F9 D0 21				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   662 50FB C8					INY
   663 50FC					LDA.NE	FILENAME,Y NOT_FNAME	; Load filename char, branch if not a current dir (.)
Macro: LDA.NE [Source: macros.inc]
     1 50FC B9 9A 4B				LDA	FILENAME,Y
     2 50FF D0 1B				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   664 5101 F0 17				BEQ	IS_FNAME		; branch always if it is a current dir (.)
   665
   666 				; **** Check if Parent Dir. ************************************************
   667 				; Check if current directory is parent dir (..).
   668 				; Output: C=0: not a parent dir, C=1: is parent dir.
   669 				; ******************************************************************************
   670 5103 A0 00		IS_FNAME_PARENT	LDY	#0
   671 5105 B9 9A 4B				LDA	FILENAME,Y
   672 5108					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5108 C9 2E				CMP	#'.'
     2 510A D0 10				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   673 510C C8					INY
   674 510D B9 9A 4B				LDA	FILENAME,Y
   675 5110					CMP.NE	#'.' NOT_FNAME
Macro: CMP.NE [Source: macros.inc]
     1 5110 C9 2E				CMP	#'.'
     2 5112 D0 08				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   676 5114 C8					INY
   677 5115					LDA.NE	FILENAME,Y NOT_FNAME	; get filename char, branch if not end-of-string
Macro: LDA.NE [Source: macros.inc]
     1 5115 B9 9A 4B				LDA	FILENAME,Y
     2 5118 D0 02				BNE	NOT_FNAME
Source: boot_sys_sh.asm
   678
   679 511A 38			IS_FNAME	SEC				; C=1: is parent (..) directory
   680 511B 60					RTS
   681 511C 18			NOT_FNAME	CLC				; The filename is not . or ..
   682 511D 60					RTS
   683 						
   684 				; **** Convert filename to FN83 type filename **********************************
   685 				; INPUT: ssptr_l/ssptr_h pointer to filename
   686 				; OUTPUT: converted filename in FN83
   687 				; ******************************************************************************
   688 511E A0 00		FNAME2FN83	LDY	#0
   689 5120 B1 78		CPFN83_1	LDA	(ssptr_l),Y		; BASIC pointer to filename
   690 5122					CMP.EQ	#'.' FN83_DOTFND	; branch if a dot is found
Macro: CMP.EQ [Source: macros.inc]
     1 5122 C9 2E				CMP	#'.'
     2 5124 F0 07				BEQ	FN83_DOTFND
Source: boot_sys_sh.asm
   691 						
   692 5126 C8			CPFNCNT		INY
   693 5127					CPY.NE	#D_ATTRIBUTES CPFN83_1	; branch if not at end-of-filename yet
Macro: CPY.NE [Source: macros.inc]
     1 5127 C0 0B				CPY	#D_ATTRIBUTES
     2 5129 D0 F5				BNE	CPFN83_1
Source: boot_sys_sh.asm
   694 512B F0 18				BEQ	EXT_DN			; branch always if no dot was found
   695
   696 512D			FN83_DOTFND	; Found a dot
   697 512D A2 08				LDX	#8
   698 512F C8					INY				; points to char next to '.'
   699 5130 B1 78		CPFN83_2	LDA	(ssptr_l),Y		; Get char of extension
   700 5132 20 62 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   701 5135					STA.EQ	FILENAME,X EXT_DN	; Store in extension, branch if '\0' (done)
Macro: STA.EQ [Source: macros.inc]
     1 5135 9D 9A 4B				STA	FILENAME,X
     2 5138 F0 0B				BEQ	EXT_DN
Source: boot_sys_sh.asm
   702 513A C8					INY
   703 513B E8					INX
   704 513C					CPX.NE	#D_ATTRIBUTES CPFN83_2	; branch if not done with extension
Macro: CPX.NE [Source: macros.inc]
     1 513C E0 0B				CPX	#D_ATTRIBUTES
     2 513E D0 F0				BNE	CPFN83_2
Source: boot_sys_sh.asm
   705 						
   706 5140 A9 00 9D 9A 4B			MVA	#0 FILENAME,X		; Add '\0' to filename
   707 5145 A0 00		EXT_DN		LDY	#0
   708 5147 B1 78		CPFN83_3	LDA	(ssptr_l),Y		; Get char of Filename
   709 5149 20 62 4C				JSR	UPPERCASE		; Convert to upper-case (only affects A)
   710 514C 99 9A 4B				STA	FILENAME,Y		; Store in result
   711 514F					CMP.EQ	#'.' CPFN83_4		; branch if filename copied
Macro: CMP.EQ [Source: macros.inc]
     1 514F C9 2E				CMP	#'.'
     2 5151 F0 06				BEQ	CPFN83_4
Source: boot_sys_sh.asm
   712 5153 C8					INY
   713 5154					CPY.NE	#8 CPFN83_3		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 5154 C0 08				CPY	#8
     2 5156 D0 EF				BNE	CPFN83_3
Source: boot_sys_sh.asm
   714 5158 60					RTS				; return
   715 						
   716 5159 A9 20 99 9A 4B C8	CPFN83_4	MVA	#' ' FILENAME,Y+	; fill remainder with spaces
   717 515F					CPY.NE	#8   CPFN83_4		; branch if not all chars copied
Macro: CPY.NE [Source: macros.inc]
     1 515F C0 08				CPY	#8
     2 5161 D0 F6				BNE	CPFN83_4
Source: boot_sys_sh.asm
   718 5163 60			CPFN_DN		RTS				; return
   719 						
   720 				; **** CFC_LOAD routine for CF-IDE driver **************************************
   721 				; Called with a CMD_LOAD from the CFC Device-driver through a JMP CFC_LOAD_VEC.
   722 				; ******************************************************************************
   723 5164			CFC_LOAD	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 5164 8E 98 51			STX	FNAME_PTR
     2 5167 8C 99 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   724 516A					PRSTR	TXT_LOAD		; Print 'CFC_LOAD'
Macro: PRSTR [Source: macros.inc]
     1 516A A2 8D			LDX	<TXT_LOAD				; MADS makes this immediate
     2 516C A0 51			LDY	>TXT_LOAD
Source: boot_sys_sh.asm
     2 516E 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   725 5171 20 1E 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   726 5174					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 5174 A9 5B			LDA	#'['
     2 5176 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   727 5179					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 5179 A2 9A			LDX	<FILENAME				; MADS makes this immediate
     2 517B A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   728 517D 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   729 5180					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 5180 A9 5D			LDA	#']'
     2 5182 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   730 5185 20 A5 4F				JSR     SAVE_ACT_DIR        	; save actual directory LBA
   731 5188 20 62 54				JSR	SH_LOAD_BAS		; Load .bas file in memory
   732 518B 38					SEC				; C=1: OK
   733 518C 60					RTS				; return
   734
   735 518D 43 46 43 5F 4C 4F + TXT_LOAD	.by	'CFC_LOAD: ' $00
   736 5198 00 00		FNAME_PTR	.word 	$0000
   737
   738 				; **** CFC_SAVE routine for CF-IDE driver **************************************
   739 				; Called with a CMD_SAVE from the CFC Device-driver through a JMP CFC_SAVE_VEC.
   740 				; ******************************************************************************
   741 519A			CFC_SAVE	STXY	FNAME_PTR
Macro: STXY [Source: macros.inc]
     1 519A 8E 98 51			STX	FNAME_PTR
     2 519D 8C 99 51			STY	FNAME_PTR+1
Source: boot_sys_sh.asm
   742 51A0					PRSTR	TXT_SAVE		; Print 'CFC_SAVE'
Macro: PRSTR [Source: macros.inc]
     1 51A0 A2 33			LDX	<TXT_SAVE				; MADS makes this immediate
     2 51A2 A0 52			LDY	>TXT_SAVE
Source: boot_sys_sh.asm
     2 51A4 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   743 51A7					PRHEX16	$2000			; Print end-address
Macro: PRHEX16 [Source: macros.inc]
     1 51A7 AD 01 20			LDA	$2000+1				; print MSB
     2 51AA 20 91 E0			JSR	HEXOUT
     3 51AD AD 00 20			LDA	$2000
     4 51B0 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   744 51B3 20 5E E0				JSR	SPCOUT		
   745 51B6 20 1E 51				JSR	FNAME2FN83		; Convert filename to FN83 filename
   746 51B9					PRCH	'['
Macro: PRCH [Source: macros.inc]
     1 51B9 A9 5B			LDA	#'['
     2 51BB 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   747 51BE					LDXYI	FILENAME		; 
Macro: LDXYI [Source: macros.inc]
     1 51BE A2 9A			LDX	<FILENAME				; MADS makes this immediate
     2 51C0 A0 4B			LDY	>FILENAME
Source: boot_sys_sh.asm
   748 51C2 20 82 F6				JSR	OS_STRING_OUT		; Print FN83 filename
   749 51C5					PRCH	']'
Macro: PRCH [Source: macros.inc]
     1 51C5 A9 5D			LDA	#']'
     2 51C7 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   750 51CA AD 00 20 8D 50 52 + 		MWA	$2000 SAVE_LEN		; SAVE_LEN = end-address
   751 51D6 38 AD 50 52 E9 00 + 		SBW	SAVE_LEN #$2000		; Get net file-size
   752 51E7 AD 51 52 8D 52 52			MVA	SAVE_LEN+1 SAVE_SECS	; SAVE_SECS now contains #pages of 256 bytes
   753 51ED 4E 52 52				LSR	SAVE_SECS		; SAVE_SECS now contains #sectors of 512 bytes needed
   754 51F0					LDA.EQ	SAVE_LEN NO_ADD_SEC	; branch if LSB of SAVE_LEN is 0
Macro: LDA.EQ [Source: macros.inc]
     1 51F0 AD 50 52				LDA	SAVE_LEN
     2 51F3 F0 03				BEQ	NO_ADD_SEC
Source: boot_sys_sh.asm
   755
   756 51F5 EE 52 52				INC	SAVE_SECS		; Add 1 to SAVE_SECS if LSB of SAVE_LEN is not 0
   757 51F8			NO_ADD_SEC	PRSTR	TXT_SECND1		; Print ', size: '
Macro: PRSTR [Source: macros.inc]
     1 51F8 A2 3F			LDX	<TXT_SECND1				; MADS makes this immediate
     2 51FA A0 52			LDY	>TXT_SECND1
Source: boot_sys_sh.asm
     2 51FC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   758 51FF					LDXY	SAVE_LEN		; Size in bytes
Macro: LDXY [Source: macros.inc]
     1 51FF AE 50 52			LDX	SAVE_LEN
     2 5202 AC 51 52			LDY	SAVE_LEN+1
Source: boot_sys_sh.asm
   759 5205 20 25 4E				JSR	PRINT_INT16		; Print it
   760 5208					PRSTR	TXT_SECND2		; Print ', sec: '
Macro: PRSTR [Source: macros.inc]
     1 5208 A2 48			LDX	<TXT_SECND2				; MADS makes this immediate
     2 520A A0 52			LDY	>TXT_SECND2
Source: boot_sys_sh.asm
     2 520C 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   761 520F AD 52 52				LDA	SAVE_SECS		; Get sector count
   762 5212 20 6D 4C				JSR	NUMOUT			; Print #sectors needed
   763 5215 20 5A E0				JSR	CROUT			; Print CR
   764 						
   765 5218					PRSTR	TXT_OS_CREATE		; Print 'OS_CREATE'
Macro: PRSTR [Source: macros.inc]
     1 5218 A2 53			LDX	<TXT_OS_CREATE				; MADS makes this immediate
     2 521A A0 52			LDY	>TXT_OS_CREATE
Source: boot_sys_sh.asm
     2 521C 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   766 521F A9 20				LDA	#FA_ARCHIVE		; File is modified 
   767 5221 20 AE 47				JSR	OS_CREATE		; Create file in current dir. and update FAT
   768 5224					PRSTR	TXT_OS_SAVFILE		; Print 'OS_SAVE_FILE'
Macro: PRSTR [Source: macros.inc]
     1 5224 A2 5E			LDX	<TXT_OS_SAVFILE				; MADS makes this immediate
     2 5226 A0 52			LDY	>TXT_OS_SAVFILE
Source: boot_sys_sh.asm
     2 5228 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   769 522B 20 11 45				JSR	OS_SAVE_FILE		; Save contents of file
   770 522E 20 0C 56				JSR	SIS_DEL			; Subtract #allocated clusters from SIS and write back to disk
   771 5231 38					SEC				; C=1: OK
   772 5232 60					RTS				; return
   773
   774 5233 43 46 43 5F 53 41 + TXT_SAVE	.by	'CFC_SAVE: $' $00
   775 523F 2C 20 73 69 7A 65 + TXT_SECND1	.by	', size: ' $00
   776 5248 2C 20 73 65 63 3A + TXT_SECND2	.by	', sec: ' $00
   777 5250 00 00		SAVE_LEN	.word	$0000			; #bytes to save
   778 5252 00			SAVE_SECS	.byte	$00			; #sectors (of 512 B) to save
   779 5253 4F 53 5F 43 52 45 + TXT_OS_CREATE	.by	'OS_CREATE' CR $00
   780 525E 4F 53 5F 53 41 56 + TXT_OS_SAVFILE 	.by	'OS_SAVE_FILE' CR $00
   781
   782 				; **** Add subdir name to D_SUBDIR_NAME ****************************************
   783 				; Check if directory entered is current dir (..).
   784 				; Output: C=0: not a current dir, C=1: is current dir.
   785 				; ******************************************************************************
   786 526C A0 00		ADD_SUBDIR_NAME	LDY	#0
   787 526E			FIND_EOS	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 526E B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5271 F0 04				BEQ	SUBDIR_EOS
Source: boot_sys_sh.asm
   788 5273 C8					INY
   789 5274 D0 F8				BNE	FIND_EOS			; branch always
   790 5276 60					RTS
   791
   792 5277			SUBDIR_EOS	CPY.EQ	#1 CP_INIT		; branch if root-dir
Macro: CPY.EQ [Source: macros.inc]
     1 5277 C0 01				CPY	#1
     2 5279 F0 06				BEQ	CP_INIT
Source: boot_sys_sh.asm
   793 527B A9 5C 99 20 04			MVA	#BSLASH D_SUBDIR_NAME,Y	; add '\' to subdir name
   794 5280 C8					INY
   795 5281 A2 00		CP_INIT		LDX	#0
   796 5283 BD 9A 4B 99 20 04	CP_FNAME	MVA	FILENAME,X D_SUBDIR_NAME,Y
   797 5289 F0 06				BEQ	SUBDIR_X		; exit if $00 found
   798 						
   799 528B C8					INY				; index in D_SUBDIR_NAME
   800 528C E8					INX				; index in FILENAME
   801 528D					CPX.NE	#D_ATTRIBUTES CP_FNAME	; branch if not at max filename yet
Macro: CPX.NE [Source: macros.inc]
     1 528D E0 0B				CPX	#D_ATTRIBUTES
     2 528F D0 F2				BNE	CP_FNAME
Source: boot_sys_sh.asm
   802 5291 60			SUBDIR_X	RTS				; return if done
   803 						
   804 				; **** Del subdir name from D_SUBDIR_NAME **************************************
   805 				; ******************************************************************************
   806 5292 A0 00		DEL_SUBDIR_NAME	LDY	#0
   807 5294			FIND_EOS2	LDA.EQ	D_SUBDIR_NAME,Y SUBDIR_EOS2	; get char of subdir name, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 5294 B9 20 04				LDA	D_SUBDIR_NAME,Y
     2 5297 F0 04				BEQ	SUBDIR_EOS2
Source: boot_sys_sh.asm
   808 5299 C8					INY
   809 529A D0 F8				BNE	FIND_EOS2			; branch always
   810 529C 60			DEL_SUBDIR_X	RTS
   811
   812 529D 88			SUBDIR_EOS2	DEY				; goto last char before $00
   813 529E B9 20 04		SUBDIR_LP1	LDA	D_SUBDIR_NAME,Y		; get char from D_SUBDIR_NAME
   814 52A1					CMP.EQ	#BSLASH BSLASH_FND	; branch if filename separator found
Macro: CMP.EQ [Source: macros.inc]
     1 52A1 C9 5C				CMP	#BSLASH
     2 52A3 F0 03				BEQ	BSLASH_FND
Source: boot_sys_sh.asm
   815 52A5					DEY.NE	SUBDIR_LP1		; branch always
Macro: DEY.NE [Source: macros.inc]
     1 52A5 88					DEY
     2 52A6 D0 F6				BNE	SUBDIR_LP1
Source: boot_sys_sh.asm
   816
   817 52A8 C8			BSLASH_FND	INY				; Y = 0 (should be a '\') or at '\', now goto next char
   818 52A9 A9 00 99 20 04			MVA	#0 D_SUBDIR_NAME,Y	; add '\0' next to '\' in D_SUBDIR_NAME
   819 52AE 60			DSNM_X		RTS				; and return
   820
   821 				; **** Change Directory Command ************************************************
   822 				;
   823 				; ******************************************************************************
   824 52AF 20 A5 4F		SH_CD           JSR     SAVE_ACT_DIR        	; save actual directory LBA
   825 52B2			                LDXYI   NO_PARMS
Macro: LDXYI [Source: macros.inc]
     1 52B2 A2 4A			LDX	<NO_PARMS				; MADS makes this immediate
     2 52B4 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   826 52B6 20 C9 4F		                JSR     SH_GET_PARMS		; get subdir name
   827 52B9 90 26		                BCC     SH_CD_END		; C=0: no name entered
   828
   829 52BB			                LDA.NE  TERM_CHAR SH_CD_END	; branch if termination char > 0
Macro: LDA.NE [Source: macros.inc]
     1 52BB AD 11 18				LDA	TERM_CHAR
     2 52BE D0 21				BNE	SH_CD_END
Source: boot_sys_sh.asm
   830 52C0 20 64 48		                JSR     OS_FIND_PATH		; loop through dir to find path
   831 52C3 90 28		                BCC     SH_CD_ERR		; branch if subdir name was not found
   832 						
   833 52C5 A0 00				LDY	#0			; add '\0' to string
   834 52C7 B9 9A 4B		TERM_FNAME_LP	LDA	FILENAME,Y		; find end-of-string first
   835 52CA					CMP.EQ	#' ' TERM_FNAME		; branch if a space found
Macro: CMP.EQ [Source: macros.inc]
     1 52CA C9 20				CMP	#' '
     2 52CC F0 05				BEQ	TERM_FNAME
Source: boot_sys_sh.asm
   836 52CE C8					INY
   837 52CF					CPY.NE	#D_ATTRIBUTES TERM_FNAME_LP	; branch if not at max. len of filename
Macro: CPY.NE [Source: macros.inc]
     1 52CF C0 0B				CPY	#D_ATTRIBUTES
     2 52D1 D0 F4				BNE	TERM_FNAME_LP
Source: boot_sys_sh.asm
   838 						
   839 52D3 A9 00 99 9A 4B	TERM_FNAME	MVA	#$00 FILENAME,Y		; terminate string with \0
   840 52D8 20 03 51				JSR	IS_FNAME_PARENT		; is dir .. ?
   841 52DB 90 05				BCC	TST_CURDIR		; branch if not . or .. entered
   842 						
   843 52DD 20 92 52				JSR	DEL_SUBDIR_NAME		; remove last subdir from D_SUBDIR_NAME
   844 52E0 38			SH_CD_EXIT_OK	SEC				; C=1: OK
   845 52E1 60			SH_CD_END	RTS
   846
   847 52E2 20 F2 50		TST_CURDIR	JSR	IS_FNAME_CURDIR		; is dir . ?
   848 52E5 B0 F9				BCS	SH_CD_EXIT_OK		; branch if dir is . (current dir)
   849 						
   850 52E7 20 6C 52				JSR	ADD_SUBDIR_NAME		; Normal subdir name, add to D_SUBDIR_NAME
   851 52EA 4C E0 52				JMP	SH_CD_EXIT_OK		; branch always
   852 						
   853 52ED 20 B7 4F		SH_CD_ERR       JSR     LOAD_ACT_DIR        	; error - restore actual directory LBA
   854 52F0 20 5A E0		                JSR     CROUT			; print CR
   855 52F3 4C DA 54		                JMP     SH_PATH_ERR		; Print 'Path not found'
   856
   857 				; **** Release the FAT clusters for a file  ************************************
   858 				; Algorithm:
   859 				;       SCNT = 1;
   860 				; loop: CURR_CLUSTER = FAT[CURR_CLUSTER];
   861 				;       FAT[CURR_CLUSTER] = 0L; // 0L = free entry
   862 				;       if (CURR_CLUSTER == 0FFFFFFF) SCNT++; goto loop;
   863 				; ******************************************************************************
   864 52F6 A2 00 8E CA 55	CLR_FAT32_FILE 	MVX 	#0 SIS_CNT			; #clusters cleared
   865 52FB			CLR_FAT32_LP1	LDXYI   D_START_FAT1      		; load base block address of FAT into NUM32[0:3]
Macro: LDXYI [Source: macros.inc]
     1 52FB A2 14			LDX	<D_START_FAT1				; MADS makes this immediate
     2 52FD A0 04			LDY	>D_START_FAT1
Source: boot_sys_sh.asm
   866 52FF 20 61 41		                JSR     LOAD_32		    		; NUM32 = LBA nr. of FAT
   867 5302					LDXYI	(CURR_CLUSTER+1)			; SUM32 = CURR_CLUSTER into SUM32
Macro: LDXYI [Source: macros.inc]
     1 5302 A2 A1			LDX	<(CURR_CLUSTER+1)				; MADS makes this immediate
     2 5304 A0 00			LDY	>(CURR_CLUSTER+1)
Source: boot_sys_sh.asm
   868 5306 20 5B 41				JSR     LOAD_S32            		; load CURR_CLUSTER[1:3] into SUM[0:2] = FAT block index
   869 5309 20 6F 53				JSR	PRTST1				; DEBUG
   870 530C A2 00 86 C7				MVX	#$00 SUM32+3			; clear garbage byte SUM[3]: SUM32 = CURR_CLUSTER / 256
   871 5310 A0 03		                LDY     #$03
   872 5312 A5 A0		                LDA     CURR_CLUSTER        		; load CURR_CLUSTER[0] = FAT entry index byte
   873 5314 0A			                ASL                         		; shift bit 7 into carry flag and multiply entry index by 2
   874 5315 48			                PHA                         		; save entry index to stack
   875 5316 36 C4 E8		CLR32_LP        ROL     SUM32,X+             		; shift bit 7 of entry index into bit 0 of block index
   876 5319			                DEY.NE  CLR32_LP	    		; branch if not done yet
Macro: DEY.NE [Source: macros.inc]
     1 5319 88					DEY
     2 531A D0 FA				BNE	CLR32_LP
Source: boot_sys_sh.asm
   877 						
   878 						; A FAT entry is 4 bytes and there are 128 FAT entries in one FAT-sector
   879 531C 20 8F 41		                JSR     ADD_32_32	    		; NUM32 = START_FAT1 + CURR_CLUSTER / 128
   880 531F 20 1D 41		                JSR     LOAD_FAT_BLK	    		; Load FAT sector into standard buffer ($600)
   881 5322 68			                PLA                         		; restore entry index
   882 5323 A2 04		                LDX     #$04                		; four bytes to read for a FAT32 entry
   883 5325 0A			                ASL                         		; multiply entry index by 2 (4 in total now)
   884 5326 A8			                TAY                         		; store entry index into Y
   885 5327 20 91 E0				JSR	HEXOUT				; DEBUG
   886 532A A2 04 86 AC		                MVX	#4 NCNT				; 1 FAT entry = 4 bytes
   887 532E A2 00				LDX	#0				; init. CURR_CLUSTER index
   888 5330 20 EA 40		LP_FAT_ENTRY    JSR     READ_ENTRY_BYTE     		; read entry byte
   889 5333 9D 6B 53				STA     TEMP_CLUSTER,X      		; store byte in TEMP_CLUSTER to follow link
   890 5336 20 8E 53				JSR	WR_ENTRY_BYTE			; FAT[CURR_CLUSTER] = 0
   891 5339 C8					INY					; Increment FAT index counter
   892 533A E8			                INX					; Increment CURR_CLUSTER counter
   893 533B			                DEC.NE  NCNT LP_FAT_ENTRY   		; loop until all bytes copied
Macro: DEC.NE [Source: macros.inc]
     1 533B C6 AC				DEC	NCNT
     2 533D D0 F1				BNE	LP_FAT_ENTRY
Source: boot_sys_sh.asm
   894 533F					MVAX	4 TEMP_CLUSTER CURR_CLUSTER	; CURR_CLUSTER = TEMP_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 533F A2 03			LDX	#4-1
     2 5341 BD 6B 53 95 A0 CA	lp	MVA	TEMP_CLUSTER,X CURR_CLUSTER,X-
     3 5347 10 F8			BPL	lp
Source: boot_sys_sh.asm
   895 5349 EE CA 55				INC	SIS_CNT				; #clusters cleared + 1
   896 534C A9 0F C5 A3 D0 10 + 		CPD	#$0FFFFFFF CURR_CLUSTER		; CURR_CLUSTER == $0FFFFFFF ?
   897 5362 D0 97				BNE	CLR_FAT32_LP1			; branch if file has more clusters to clear
   898 						
   899 5364					LDXYI	CURR_FAT_BLK			; LBA of current FAT block
Macro: LDXYI [Source: macros.inc]
     1 5364 A2 A4			LDX	<CURR_FAT_BLK				; MADS makes this immediate
     2 5366 A0 00			LDY	>CURR_FAT_BLK
Source: boot_sys_sh.asm
   900 5368 4C 18 42				JMP	DEV_WR_LBLK_BUF			; write FAT block back to disk and return
   901
   902 536B 00 00 00 00		TEMP_CLUSTER	.dword	$00000000
   903 						
   904 536F			PRTST1		PRCH	'<'
Macro: PRCH [Source: macros.inc]
     1 536F A9 3C			LDA	#'<'
     2 5371 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   905 5374					PRHEX32	CURR_CLUSTER
Macro: PRHEX32 [Source: macros.inc]
     1 5374 A5 A3			LDA	CURR_CLUSTER+2+1				; print MSB
     2 5376 20 91 E0			JSR	HEXOUT
     3 5379 A5 A2			LDA	CURR_CLUSTER+2
     4 537B 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 537E A5 A1			LDA	CURR_CLUSTER+1				; print MSB
     2 5380 20 91 E0			JSR	HEXOUT
     3 5383 A5 A0			LDA	CURR_CLUSTER
     4 5385 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
   906 5388					PRCH	'>'
Macro: PRCH [Source: macros.inc]
     1 5388 A9 3E			LDA	#'>'
     2 538A 20 52 E0			JSR	COUT
Source: boot_sys_sh.asm
   907 538D 60					RTS
   908
   909 				; **** Write a Single FAT Entry Byte From Block Buffer *************************
   910 				; INPUT : Y - Index To FAT Entry Byte
   911 				; OUTPUT: A = Read Byte from FAT table
   912 				; ******************************************************************************
   913 538E			WR_ENTRY_BYTE 	AND.NE  #$01 CURR_CLUSTER+1 CLR_UPPER_PAGE	; check bit 0 (= bit 7 of CURR_CLUSTER[0:3] because of ASL in FAT32 routine)
Macro: AND.NE [Source: macros.inc]
     2 538E A9 01				LDA	#$01
     3 5390 25 A1				AND	CURR_CLUSTER+1
     4 5392 D0 06				BNE	CLR_UPPER_PAGE
Source: boot_sys_sh.asm
   914 5394 A9 00 99 00 06	                MVA	#0 BLOCK_BUFF,Y				; write entry byte from lower half of block buffer
   915 5399 60			                RTS			    			; return
   916 539A A9 00 99 00 07	CLR_UPPER_PAGE  MVA     #0 BLOCK_BUFF+256,Y    			; write entry byte from upper half of block buffer
   917 539F 60			                RTS			    			; return
   918
   919 				; **** Delete Command **********************************************************
   920 				;
   921 				; ******************************************************************************
   922 53A0 20 A5 4F		SH_DEL          JSR     SAVE_ACT_DIR        			; save actual directory LBA
   923 53A3			                LDXYI   NO_PARMS          			; we don't need parameters, just the filename
Macro: LDXYI [Source: macros.inc]
     1 53A3 A2 4A			LDX	<NO_PARMS				; MADS makes this immediate
     2 53A5 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
   924 53A7 20 C9 4F		                JSR     SH_GET_PARMS        			; get path
   925 53AA 90 33		                BCC     SH_DEL_X	    			; branch if no filename was given
   926
   927 53AC 20 6A 48		                JSR     OS_FIND_FILE				; Now find file to delete
   928 53AF 90 31		                BCC     SH_DEL_ERR				; branch if file not found
   929
   930 						; OS_FIND_FILE did already set CURR_CLUSTER to the file starting-cluster
   931 53B1 A0 00		SH_DEL_FILE	LDY	#D_FILENAME
   932 53B3 A9 E5 91 A8				MVA	#$E5 (CURR_DIR_ENTRY),Y			; $E5 first char. is a deleted file
   933 53B7 A0 14				LDY	#D_START_CLSTH
   934 53B9 A9 00 91 A8 C8 91 + 		MWA	#$00 (CURR_DIR_ENTRY),Y			; delete high word of file-size
   935 53C0					PRHEX16	CURR_DIR_BLK
Macro: PRHEX16 [Source: macros.inc]
     1 53C0 AD 25 18			LDA	CURR_DIR_BLK+1				; print MSB
     2 53C3 20 91 E0			JSR	HEXOUT
     3 53C6 AD 24 18			LDA	CURR_DIR_BLK
     4 53C9 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
   936 53CC					LDXYI	CURR_DIR_BLK				; CURR_DIR_BLK is LBA of current dir block
Macro: LDXYI [Source: macros.inc]
     1 53CC A2 24			LDX	<CURR_DIR_BLK				; MADS makes this immediate
     2 53CE A0 18			LDY	>CURR_DIR_BLK
Source: boot_sys_sh.asm
   937 53D0 20 FB 42		                JSR     OS_SAVE_DIR	    			; write this dir entry back to disk
   938 						
   939 53D3 20 F6 52				JSR	CLR_FAT32_FILE				; Set all FAT entries for this file to 00000000 (free)
   940 53D6 20 26 46				JSR	INIT_FREE_CLUSTER			; FREE_CLUSTER = 2L
   941 53D9 20 37 46				JSR     OS_NEXT_FREE_CLUSTER			; Get first free cluster in FREE_CLUSTER
   942
   943 						; Update SIS with #clusters freed and first-free cluster nr
   944 53DC 20 CB 55				JSR	SIS_ADD					; Update SIS and write back
   945 53DF 4C B7 4F		SH_DEL_X        JMP     LOAD_ACT_DIR        			; error - restore actual directory LBA and return
   946
   947 53E2 4C D3 54		SH_DEL_ERR	JMP	SH_FILE_ERR				; Print 'File not found' and return
   948
   949 				; **** Clear Screen Command ****************************************************
   950 				;
   951 				; ******************************************************************************
   952 53E5 4C B5 E0		SH_CLS          JMP     CLRSCRN
   953
   954 				; **** Pause Command ***********************************************************
   955 				; Output: A - pressed key char
   956 				;         C = 0 ESC key pressed, C = 1 else
   957 				; ******************************************************************************
   958 53E8			SH_PAUSE        PRSTR   MSG_PAUSE          	; print pause message
Macro: PRSTR [Source: macros.inc]
     1 53E8 A2 39			LDX	<MSG_PAUSE				; MADS makes this immediate
     2 53EA A0 56			LDY	>MSG_PAUSE
Source: boot_sys_sh.asm
     2 53EC 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
   959 53EF 20 47 E0		                JSR     CIN                  	; wait until any key pressed
   960 53F2 48			                PHA
   961 53F3 20 5A E0		                JSR     CROUT
   962 53F6 68			                PLA
   963 53F7 60			                RTS
   964 				                
   965 				; **** Echo Command ************************************************************
   966 				;
   967 				; ******************************************************************************
   968 53F8			SH_ECHO         LDA.EQ  STRBUF,X SH_ECHO_END	; get char, branch if end-of-string
Macro: LDA.EQ [Source: macros.inc]
     1 53F8 BD 00 14				LDA	STRBUF,X
     2 53FB F0 09				BEQ	SH_ECHO_END
Source: boot_sys_sh.asm
   969 53FD 8A			                TXA
   970 53FE A8			                TAY
   971 53FF C8			                INY
   972 5400 20 85 E0		                JSR     WRSTR
   973 5403 20 5A E0		                JSR     CROUT
   974 5406 60			SH_ECHO_END     RTS
   975
   976 				; **** Goto Command ************************************************************
   977 				;
   978 				; ******************************************************************************
   979 5407 60			SH_GOTO         RTS
   980
   981 				; **** If Command **************************************************************
   982 				;
   983 				; ******************************************************************************
   984 5408 20 26 46		SH_IF           JSR 	INIT_FREE_CLUSTER	; FREE_CLUSTER = 2L
   985 540B 20 37 46		                JSR 	OS_NEXT_FREE_CLUSTER
   986 540E A0 03				LDY 	#3
   987 5410			PRINT_CURR_CLST PHY				; save Y
Macro: PHY [Source: macros.inc]
     1 5410 98				TYA
     2 5411 48				PHA
Source: boot_sys_sh.asm
   988 5412 B9 20 18				LDA 	FREE_CLUSTER,Y		; 
   989 5415 20 91 E0		                JSR 	HEXOUT			; Print FREE_CLUSTER
   990 5418					PLY				; restore Y
Macro: PLY [Source: macros.inc]
     1 5418 68				PLA
     2 5419 A8				TAY
Source: boot_sys_sh.asm
   991 541A					DEY.PL	PRINT_CURR_CLST		; print if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 541A 88					DEY
     2 541B 10 F3				BPL	PRINT_CURR_CLST
Source: boot_sys_sh.asm
   992 541D 60					RTS
   993
   994 				; **** Rem Command *************************************************************
   995 				;
   996 				; ******************************************************************************
   997 541E			SH_REM          PHW	BLKBUF			; DEBUG: For testing SIS routines
Macro: PHW [Source: macros.inc]
     1 541E A5 DC			LDA	BLKBUF
     2 5420 48				PHA
     3 5421 A5 DD			LDA	BLKBUF+1
     4 5423 48				PHA
Source: boot_sys_sh.asm
   998 5424 20 30 55				JSR	GET_SIS
   999 5427					PLW	BLKBUF
Macro: PLW [Source: macros.inc]
     1 5427 68				PLA
     2 5428 85 DD			STA	BLKBUF+1
     3 542A 68				PLA
     4 542B 85 DC			STA	BLKBUF
Source: boot_sys_sh.asm
  1000 542D 60			SH_REM_X	RTS
  1001 				                
  1002 				; **** BASIC Command ***********************************************************
  1003 				; Executes Basic in ROM. Return with 'DOS' command. 
  1004 				; ******************************************************************************
  1005 542E 20 0A E0		SH_BASIC        JSR	SWITCH_TO_ROM		; Make sure BASIC ROM is enabled
  1006 5431 A5 02				LDA	Wrmjph	    	    	; Is BASIC Warm-start vector already set?
  1007 5433					CMP.NE	#$B1 SH_BCOLD 	    	; If not in this range, branch and do a BASIC cold start
Macro: CMP.NE [Source: macros.inc]
     1 5433 C9 B1				CMP	#$B1
     2 5435 D0 03				BNE	SH_BCOLD
Source: boot_sys_sh.asm
  1008 						
  1009 5437 6C 01 00				JMP	(Wrmjpl)	    	; Basic Warm-start
  1010 543A 4C 00 B0		SH_BCOLD	JMP	LAB_COLD	    	; Basic Cold-start
  1011
  1012 				; **** BRUN Command ************************************************************
  1013 				;
  1014 				; ******************************************************************************
  1015 543D 20 A5 4F		SH_BRUN         JSR     SAVE_ACT_DIR        	; save actual directory LBA
  1016 5440			                LDXYI   NO_PARMS            	; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 5440 A2 4A			LDX	<NO_PARMS				; MADS makes this immediate
     2 5442 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1017 5444 20 C9 4F		                JSR     SH_GET_PARMS
  1018 5447 90 05		                BCC     SH_BRUN_END
  1019
  1020 5449 20 6A 48		                JSR     OS_FIND_FILE
  1021 544C 90 00		                BCC     SH_BRUN_END		; branch if file not found
  1022
  1023 				                ;JSR     OS_LOAD_BIN
  1024 544E 20 B7 4F		SH_BRUN_END     JSR     LOAD_ACT_DIR        	; restore actual directory LBA
  1025 5451 60			                RTS
  1026 				                
  1027 				; **** BLOAD Command ***********************************************************
  1028 				;
  1029 				; ******************************************************************************
  1030 5452 60			SH_BLOAD        RTS
  1031
  1032 				; ******************************************************************************
  1033 5453 20 A5 4F		SH_RUN          JSR     SAVE_ACT_DIR        ; save actual directory LBA
  1034 5456			                LDXYI   NO_PARMS            ; no command parameters
Macro: LDXYI [Source: macros.inc]
     1 5456 A2 4A			LDX	<NO_PARMS				; MADS makes this immediate
     2 5458 A0 50			LDY	>NO_PARMS
Source: boot_sys_sh.asm
  1035 545A 20 36 50		                JSR     SET_PARM_MASK
  1036 545D 20 18 50		                JSR     SH_GET_PATH         ; get file path
  1037 5460 90 5C		                BCC     SH_RUN_END
  1038
  1039 						; This is the entry-point for loading a .BAS file into memory
  1040 5462 AD A2 4B		SH_LOAD_BAS     LDA     FILENAME+8
  1041 5465			                CMP.NE  #SPC SH_RUN1        	; branch if given filename has no extension
Macro: CMP.NE [Source: macros.inc]
     1 5465 C9 20				CMP	#SPC
     2 5467 D0 0B				BNE	SH_RUN1
Source: boot_sys_sh.asm
  1042 5469					MVAY	3 EXT_COM FILENAME+8	; copy .COM extension to FILENAME
Macro: MVAY [Source: macros.inc]
     1 5469 A0 02			LDY	#3-1
     2 546B B9 4F 57 99 A2 4B + lp	MVA	EXT_COM,Y FILENAME+8,Y-
     3 5472 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1043
  1044 						; Check for .COM file
  1045 5474 A0 02		SH_RUN1         LDY     #$02
  1046 5476 B9 4F 57		CMP_EXT_COM     LDA     EXT_COM,Y           	; check if COM file
  1047 5479					CMP.NE	FILENAME+8,Y CHK_BASF	; Not a .COM file, check .BAS file next
Macro: CMP.NE [Source: macros.inc]
     1 5479 D9 A2 4B				CMP	FILENAME+8,Y
     2 547C D0 0A				BNE	CHK_BASF
Source: boot_sys_sh.asm
  1048 547E			                DEY.PL	CMP_EXT_COM	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 547E 88					DEY
     2 547F 10 F5				BPL	CMP_EXT_COM
Source: boot_sys_sh.asm
  1049 				                
  1050 5481 A9 01 8D 6C 44			MVA	#1 FTYPE	    	; 1 = .COM file
  1051 5486 D0 26				BNE	SH_RUN_FF	    	; branch always, check if file exists
  1052
  1053 5488 A0 02		CHK_BASF	LDY     #$02
  1054 548A B9 55 57		CMP_EXT_BAS     LDA     EXT_BAS,Y           	; check if .BAS file
  1055 548D			                CMP.NE  FILENAME+8,Y CHK_EXEF	; Not a .BAS file, check .EXE file next
Macro: CMP.NE [Source: macros.inc]
     1 548D D9 A2 4B				CMP	FILENAME+8,Y
     2 5490 D0 0A				BNE	CHK_EXEF
Source: boot_sys_sh.asm
  1056 5492			                DEY.PL  CMP_EXT_BAS	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 5492 88					DEY
     2 5493 10 F5				BPL	CMP_EXT_BAS
Source: boot_sys_sh.asm
  1057 				                
  1058 5495 A9 00 8D 6C 44			MVA	#0 FTYPE	    	; 0 = .BAS file
  1059 549A F0 12				BEQ	SH_RUN_FF	    	; branch always, check if file exists
  1060
  1061 549C A0 02		CHK_EXEF	LDY     #$02
  1062 549E B9 52 57		CMP_EXT_EXE     LDA     EXT_EXE,Y           	; check if .EXE file
  1063 54A1			                CMP.NE  FILENAME+8,Y SH_RUN_END	; all 3 extensions do not exist
Macro: CMP.NE [Source: macros.inc]
     1 54A1 D9 A2 4B				CMP	FILENAME+8,Y
     2 54A4 D0 18				BNE	SH_RUN_END
Source: boot_sys_sh.asm
  1064 54A6			                DEY.PL	CMP_EXT_EXE	    	; branch if not done yet
Macro: DEY.PL [Source: macros.inc]
     1 54A6 88					DEY
     2 54A7 10 F5				BPL	CMP_EXT_EXE
Source: boot_sys_sh.asm
  1065 				                
  1066 54A9 A9 02 8D 6C 44			MVA	#2 FTYPE	    	; 2 = .EXE file
  1067 54AE 20 6A 48		SH_RUN_FF       JSR     OS_FIND_FILE        	; check if file with this extension exists
  1068 54B1 B0 08		                BCS     SH_RUN3             	; yes, load file
  1069
  1070 54B3 20 5A E0		SH_RUN_ERR      JSR     CROUT		    	; print CR
  1071 54B6 20 D3 54		                JSR     SH_FILE_ERR         	; file does not exist
  1072 54B9 90 03		                BCC     SH_RUN_END	    	; branch always
  1073
  1074 54BB 20 7F 44		SH_RUN3         JSR     OS_LOAD_FILE	    	; Load .bas file or load/run .com/.exe file
  1075 54BE 4C B7 4F		SH_RUN_END      JMP     LOAD_ACT_DIR        	; restore actual directory LBA and return
  1076 				                
  1077 				; **** Print version info  *****************************************************
  1078 				; Output: -
  1079 				; ******************************************************************************
  1080 54C1			SH_VER		PRSTR	MSG_BOOT			; Print Title Info
Macro: PRSTR [Source: macros.inc]
     1 54C1 A2 33			LDX	<MSG_BOOT				; MADS makes this immediate
     2 54C3 A0 4B			LDY	>MSG_BOOT
Source: boot_sys_sh.asm
     2 54C5 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1081 54C8 60					RTS
  1082 						
  1083 				; **** Monitor call-back Routine ************************************************
  1084 54C9			SH_MONITOR      PRSTR   MSG_MONITOR
Macro: PRSTR [Source: macros.inc]
     1 54C9 A2 10			LDX	<MSG_MONITOR				; MADS makes this immediate
     2 54CB A0 57			LDY	>MSG_MONITOR
Source: boot_sys_sh.asm
     2 54CD 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1085 54D0 4C 03 E0		                JMP     MON_WARM_START
  1086 				                
  1087 				.macro	PR_ERR	msg
  1088 						LDXYI	:msg
  1089 						JMP	OS_PRINT_ERR
  1090 				.endm
  1091 				; **** Error Routines **********************************************************
  1092 54D3			SH_FILE_ERR     PR_ERR	MSG_FILE_ERR		; 'File not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54D3 A2 9F			LDX	<MSG_FILE_ERR				; MADS makes this immediate
     2 54D5 A0 56			LDY	>MSG_FILE_ERR
Source: boot_sys_sh.asm
     2 54D7 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1093 54DA			SH_PATH_ERR     PR_ERR  MSG_PATH_ERR  		; 'Path not Found' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54DA A2 AF			LDX	<MSG_PATH_ERR				; MADS makes this immediate
     2 54DC A0 56			LDY	>MSG_PATH_ERR
Source: boot_sys_sh.asm
     2 54DE 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1094 54E1			SH_DIR_ERR      PR_ERR  MSG_DIR_ERR  		; 'Invalid Directory' error message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54E1 A2 E2			LDX	<MSG_DIR_ERR				; MADS makes this immediate
     2 54E3 A0 56			LDY	>MSG_DIR_ERR
Source: boot_sys_sh.asm
     2 54E5 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1095 54E8			SH_NAME_ERR     PR_ERR  MSG_NAME_ERR  		; 'Invalid Filename' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54E8 A2 D0			LDX	<MSG_NAME_ERR				; MADS makes this immediate
     2 54EA A0 56			LDY	>MSG_NAME_ERR
Source: boot_sys_sh.asm
     2 54EC 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1096 54EF			SH_D_EXIST_ERR  PR_ERR  MSG_D_EXIST_ERR 	; 'Directory already exists' error message...
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54EF A2 F5			LDX	<MSG_D_EXIST_ERR				; MADS makes this immediate
     2 54F1 A0 56			LDY	>MSG_D_EXIST_ERR
Source: boot_sys_sh.asm
     2 54F3 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1097 54F6			SH_WRITE_ERR    PR_ERR  MSG_WRITE_ERR 		; 'Write error' message
Macro: PR_ERR [Source: boot_sys_sh.asm]
     1 54F6 A2 1E			LDX	<MSG_WRITE_ERR				; MADS makes this immediate
     2 54F8 A0 57			LDY	>MSG_WRITE_ERR
Source: boot_sys_sh.asm
     2 54FA 4C C5 49				JMP	OS_PRINT_ERR
Source: boot_sys_sh.asm
  1098 				                
  1099 				; Inits BLKBUF to SIS_BUFF **************************************
  1100 				; Prepare for DEV_RD_LBLK and DEV_WR_LBLK routines
  1101 				; ***************************************************************
  1102 54FD A9 00 85 DC A9 58 + INIT_SIS_BUF	MWA	#SIS_BUFF BLKBUF	; macro BLKBUF = SIS_BUF
  1103 5505 60					RTS
  1104
  1105 				;-------------------------------------------------------------------------------
  1106 				; Convert #Clusters to KB in FREE_KB
  1107 				; D_SECT_PER_CLST = 1: 2 CL =  2 SEC = 1 KB: SHR 1
  1108 				;                   2: 2 CL =  4 SEC = 2 KB: -
  1109 				;		    4: 2 CL =  8 SEC = 4 KB: SHL 1
  1110 				;		    8: 2 CL = 16 SEC = 8 KB: SHL 2 etcetera
  1111 				;-------------------------------------------------------------------------------
  1112 5506 AD 0B 04		CL2KB		LDA	D_SECT_PER_CLST			; #sectors per cluster
  1113 5509					CMP.EQ	#2 CL2KB_X			; 2 sec/cl, just exit
Macro: CMP.EQ [Source: macros.inc]
     1 5509 C9 02				CMP	#2
     2 550B F0 22				BEQ	CL2KB_X
Source: boot_sys_sh.asm
  1114 550D					CMP.EQ	#1 CL2KB_1			; 1 sec/cl, SHR 1
Macro: CMP.EQ [Source: macros.inc]
     1 550D C9 01				CMP	#1
     2 550F F0 12				BEQ	CL2KB_1
Source: boot_sys_sh.asm
  1115 5511 4A 4A			:2	LSR					; init nr of shifts		
  1116 5513			CL2KB_SHL	ASL32	FREE_KB				; SHL 1 of FREE_KB
Macro: ASL32 [Source: macros.inc]
     1 5513 0E A7 55			ASL     FREE_KB		  		; SHL with C=0
     2 5516 2E A8 55		        ROL     FREE_KB+1		  
     3 5519 2E A9 55		        ROL     FREE_KB+2
     4 551C 2E AA 55		        ROL     FREE_KB+3		  
Source: boot_sys_sh.asm
  1117 551F 4A					LSR
  1118 5520 D0 F1				BNE	CL2KB_SHL			; branch if not done with shifting
  1119 5522 60					RTS					; return
  1120 						
  1121 5523			CL2KB_1		LSR32	FREE_KB				; SHR 1 of FREE_KB
Macro: LSR32 [Source: macros.inc]
     1 5523 4E AA 55			LSR     FREE_KB+3		  		; SHR with C=0
     2 5526 6E A9 55		        ROR     FREE_KB+2
     3 5529 6E A8 55		        ROR     FREE_KB+1
     4 552C 6E A7 55		        ROR     FREE_KB
Source: boot_sys_sh.asm
  1122 552F 60			CL2KB_X		RTS					; return
  1123 						
  1124 				; Get Info from System Information Sector **************************************
  1125 5530 20 FD 54		GET_SIS		JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1126 5533					LDXYI	D_PART_START			; macro Ptr(X,Y) = D_PART_START
Macro: LDXYI [Source: macros.inc]
     1 5533 A2 00			LDX	<D_PART_START				; MADS makes this immediate
     2 5535 A0 04			LDY	>D_PART_START
Source: boot_sys_sh.asm
  1127 5537 20 4B 41				JSR 	DEV_RD_LBLK           		; Read Volume ID again
  1128 553A					MVAX	4 D_PART_START SYS_INFO_LBA	; SYS_INFO_LBA = D_PART_START
Macro: MVAX [Source: macros.inc]
     1 553A A2 03			LDX	#4-1
     2 553C BD 00 04 9D A3 55 + lp	MVA	D_PART_START,X SYS_INFO_LBA,X-
     3 5543 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1129 5545 18 AD A3 55 6D 30 + 		ADW	SYS_INFO_LBA SIS_OFFSET		; SYS_INFO_LBA = D_PART_START + *SIS_OFFSET
  1130 5558 AD A5 55				LDA	SYS_INFO_LBA+2			; update high word of SYS_INFO_LBA
  1131 555B 69 00				ADC	#0
  1132 555D 8D A5 55				STA	SYS_INFO_LBA+2
  1133 5560 AD A6 55				LDA	SYS_INFO_LBA+3
  1134 5563 69 00				ADC	#0
  1135 5565 8D A6 55				STA	SYS_INFO_LBA+3
  1136 						
  1137 5568 20 FD 54				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_READ command
  1138 556B					LDXYI	SYS_INFO_LBA			; Read Sys. Info. Sector into SIS-buffer
Macro: LDXYI [Source: macros.inc]
     1 556B A2 A3			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 556D A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1139 556F 20 4B 41				JSR 	DEV_RD_LBLK           		; Read SIS sector
  1140 5572					PRSTR	TXT_FFREE_CLST			; print 'First Free Cluster:$'
Macro: PRSTR [Source: macros.inc]
     1 5572 A2 AB			LDX	<TXT_FFREE_CLST				; MADS makes this immediate
     2 5574 A0 55			LDY	>TXT_FFREE_CLST
Source: boot_sys_sh.asm
     2 5576 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1141 5579					PRHEX32	SIS_BUFF+$01EC
Macro: PRHEX32 [Source: macros.inc]
     1 5579 AD EF 59			LDA	SIS_BUFF+$01EC+2+1				; print MSB
     2 557C 20 91 E0			JSR	HEXOUT
     3 557F AD EE 59			LDA	SIS_BUFF+$01EC+2
     4 5582 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
     1 5585 AD ED 59			LDA	SIS_BUFF+$01EC+1				; print MSB
     2 5588 20 91 E0			JSR	HEXOUT
     3 558B AD EC 59			LDA	SIS_BUFF+$01EC
     4 558E 20 91 E0			JSR	HEXOUT				; print LSB
Source: boot_sys_sh.asm
Source: boot_sys_sh.asm
  1142 5591 20 5A E0				JSR	CROUT
  1143 5594			FREE_KB_UPDATE	MVAX	4 SIS_BUFF+$01E8 FREE_KB	
Macro: MVAX [Source: macros.inc]
     1 5594 A2 03			LDX	#4-1
     2 5596 BD E8 59 9D A7 55 + lp	MVA	SIS_BUFF+$01E8,X FREE_KB,X-
     3 559D 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1144 559F 20 06 55				JSR	CL2KB				; Convert #clusters to KB and store in FREE_KB
  1145 55A2 60					RTS
  1146 						
  1147 55A3 00 00 00 00		SYS_INFO_LBA	.dword	$00000000
  1148 55A7 00 00 00 00		FREE_KB		.dword	$00000000
  1149 55AB 46 69 72 73 74 20 + TXT_FFREE_CLST	.by	'First free cluster:$' $00
  1150 55C0 20 4B 42 20 66 72 + TXT_KB		.by	' KB free' CR $00
  1151 55CA 00			SIS_CNT		.byte	$00				; SIS counter, counts #clusters freed or allocated
  1152
  1153 				; Write Info back to System Information Sector **************************************
  1154 55CB			SIS_ADD		PRSTR	SISP
Macro: PRSTR [Source: macros.inc]
     1 55CB A2 2F			LDX	<SISP				; MADS makes this immediate
     2 55CD A0 56			LDY	>SISP
Source: boot_sys_sh.asm
     2 55CF 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1155 55D2 AD E8 59 18 6D CA + 		ADB	SIS_BUFF+$01E8 SIS_CNT		; add SIS_CNT to #free clusters in SIS-buffer
  1156 55DC 90 03				SCC					; 'skip if C is clear' macro
  1157 55DE EE E9 59				INC	SIS_BUFF+$01E9
  1158 55E1 90 03				SCC	
  1159 55E3 EE EA 59				INC	SIS_BUFF+$01EA
  1160 55E6 90 03				SCC	
  1161 55E8 EE EB 59				INC	SIS_BUFF+$01EB
  1162 55EB AD CA 55		SIS_WRITE	LDA	SIS_CNT				; Print SIS_CNT
  1163 55EE 20 91 E0				JSR	HEXOUT
  1164 55F1 20 5A E0				JSR	CROUT
  1165 55F4					MVAX	4 FREE_CLUSTER SIS_BUFF+$01EC	; SIS First free cluster = FREE_CLUSTER
Macro: MVAX [Source: macros.inc]
     1 55F4 A2 03			LDX	#4-1
     2 55F6 BD 20 18 9D EC 59 + lp	MVA	FREE_CLUSTER,X SIS_BUFF+$01EC,X-
     3 55FD 10 F7			BPL	lp
Source: boot_sys_sh.asm
  1166 55FF 20 FD 54				JSR	INIT_SIS_BUF			; Init SIS Buffer for CMD_WRITE command
  1167 5602					LDXYI	SYS_INFO_LBA 			; Sys. Info. Sector LBA
Macro: LDXYI [Source: macros.inc]
     1 5602 A2 A3			LDX	<SYS_INFO_LBA				; MADS makes this immediate
     2 5604 A0 55			LDY	>SYS_INFO_LBA
Source: boot_sys_sh.asm
  1168 5606 20 1D 42				JSR 	DEV_WR_LBLK           		; Write SIS to disk
  1169 5609 4C 94 55				JMP	FREE_KB_UPDATE			; Update FREE_KB and return
  1170
  1171 560C			SIS_DEL		PRSTR	SISM
Macro: PRSTR [Source: macros.inc]
     1 560C A2 34			LDX	<SISM				; MADS makes this immediate
     2 560E A0 56			LDY	>SISM
Source: boot_sys_sh.asm
     2 5610 20 82 F6			JSR	OS_STRING_OUT
Source: boot_sys_sh.asm
  1172 5613 AD E8 59 38 ED CA + 		SBB	SIS_BUFF+$01E8 SIS_CNT		; subtract SIS_CNT from #free clusters in SIS-buffer
  1173 561D B0 03				SCS					; 'skip if C is set' macro
  1174 561F CE E9 59				DEC	SIS_BUFF+$01E9
  1175 5622 B0 03				SCS
  1176 5624 CE EA 59				DEC	SIS_BUFF+$01EA
  1177 5627 B0 03				SCS
  1178 5629 CE EB 59				DEC	SIS_BUFF+$01EB
  1179 562C 4C EB 55				JMP	SIS_WRITE			; write back to disk
  1180 						
  1181 562F 53 49 53 2B 00	SISP		.by	'SIS+' $00
  1182 5634 53 49 53 2D 00	SISM		.by	'SIS-' $00
  1183 						
  1184 				; **** Data Area ***************************************************************
  1185 				; ******************************************************************************
  1186
  1187 				; String Data Area *************************************************************
  1188 5639 50 72 65 73 73 20 + MSG_PAUSE       .by    'Press any key...' $00
  1189 564A 56 6F 6C 75 6D 65 + MSG_LABEL       .by    'Volume in drive ' $00
  1190 565B 20 69 73 20 00	MSG_LABEL2      .by    ' is ' $00
  1191 5660 20 20 20 20 20 20 + MSG_DIR_ENTRY   .by    '          <DIR>' $00
  1192 5670 20 46 69 6C 65 28 + MSG_FILE_COUNT  .by    ' File(s)  ' $00
  1193 567B 20 44 69 72 28 73 + MSG_DIR_COUNT   .by    ' Dir(s)   ' $00
  1194 5686 20 62 79 74 65 73 + MSG_BYTE_USED   .by    ' bytes' CR $00
  1195 568E 44 72 69 76 65 20 + MSG_DRIVE_ERR   .by    'Drive not found' CR $00
  1196 569F 46 69 6C 65 20 6E + MSG_FILE_ERR    .by    'File not found' CR $00
  1197 56AF 50 61 74 68 20 6E + MSG_PATH_ERR    .by    'Path not found' CR $00
  1198 56BF 55 6E 6B 6E 6F 77 + MSG_PARAM_ERR   .by    'Unknown option ' OPT_SEP $00
  1199 56D0 49 6E 76 61 6C 69 + MSG_NAME_ERR    .by    'Invalid filename' CR $00
  1200 56E2 49 6E 76 61 6C 69 + MSG_DIR_ERR     .by    'Invalid directory' CR $00
  1201 56F5 0D 44 69 72 65 63 + MSG_D_EXIST_ERR .by    CR 'Directory already exists' CR $00
  1202 5710 0D 48 65 78 20 4D + MSG_MONITOR     .by    CR 'Hex Monitor' CR $00
  1203 571E 0D 57 72 69 74 65 + MSG_WRITE_ERR   .by    CR 'Write Error' CR $00
  1204
  1205 				; ############################################
  1206 572C 52 48 53 00 00 41 + ATTRIB_VAL      .byte      82, 72, 83, 0, 0, 65, 0, 0
  1207 5734 00 00 00 00 00	BCD_VAL         .byte      $00, $00, $00, $00, $00
  1208 5739 53 59 53 54 45 4D + SYSTEM_DIR      .by    'SYSTEM     '
  1209 5744 2E 2E 2E 2E 2E 2E + NAME_SAVE       .by    '...........'
  1210 574F 43 4F 4D		EXT_COM         .by    'COM'
  1211 5752 45 58 45		EXT_EXE		.by    'EXE'
  1212 5755 42 41 53		EXT_BAS		.by    'BAS'
  1213 				                
  1214 				; Command Table ****************************************************************
  1215 5758 42 77 57		CHARS		dta	'B' , a(CMD_BASIC)		; byte, word
  1216 575B 43 8C 57				dta	'C' , a(CMD_CD)		
  1217 575E 44 96 57				dta	'D' , a(CMD_DIR)		
  1218 5761 45 A1 57				dta	'E' , a(CMD_ECHO)		
  1219 5764 47 A8 57				dta	'G' , a(CMD_GOTO)		
  1220 5767 49 AF 57				dta	'I' , a(CMD_IF)		
  1221 576A 4D B4 57				dta	'M' , a(CMD_MKDIR)		
  1222 576D 50 C1 57				dta	'P' , a(CMD_PAUSE)		
  1223 5770 52 C9 57				dta	'R' , a(CMD_REM)
  1224 5773 56 CF 57				dta	'V' , a(CMD_VER)
  1225 5776 00					.byte 	$00
  1226
  1227 5777 05 41 53 49 43 2E + CMD_BASIC	dta	5, c'ASIC', a(SH_BASIC)		; byte, string, word, EOT
  1228 577E 05 4C 4F 41 44 52 + CMD_BLOAD	dta	5, c'LOAD', a(SH_BLOAD)		; 
  1229 5785 04 52 55 4E 3D 54 + CMD_BRUN	dta	4, c'RUN' , a(SH_BRUN)   , $00	; 
  1230 578C 02 44 AF 52		CMD_CD		dta	2, c'D'   , a(SH_CD) 		; 
  1231 5790 03 4C 53 E5 53 00	CMD_CLS		dta	3, c'LS'  , a(SH_CLS)    , $00	; 
  1232 5796 03 49 52 4B 50	CMD_DIR		dta	3, c'IR'  , a(SH_DIR) 		; 
  1233 579B 03 45 4C A0 53 00	CMD_DEL		dta	3, c'EL'  , a(SH_DEL)    , $00	; 
  1234 57A1 04 43 48 4F F8 53 + CMD_ECHO	dta	4, c'CHO' , a(SH_ECHO)   , $00	; 
  1235 57A8 04 4F 54 4F 07 54 + CMD_GOTO	dta	4, c'OTO' , a(SH_GOTO)   , $00	; 
  1236 57AF 02 46 08 54 00	CMD_IF		dta	2, c'F'   , a(SH_IF)     , $00	; 
  1237 57B4 05 4B 44 49 52 D0 + CMD_MKDIR	dta	5, c'KDIR', a(SH_MKDIR)		; 
  1238 57BB 03 4F 4E C9 54 00	CMD_MON		dta	3, c'ON'  , a(SH_MONITOR), $00	; 
  1239 57C1 05 41 55 53 45 E8 + CMD_PAUSE	dta	5, c'AUSE', a(SH_PAUSE)  , $00	; 
  1240 57C9 03 45 4D 1E 54 00	CMD_REM		dta	3, c'EM'  , a(SH_REM)    , $00	; 
  1241 57CF 03 45 52 C1 54 00	CMD_VER		dta	3, c'ER'  , a(SH_VER)    , $00  ;
    86 				                
    87 				; End Of Program Marker ********************************************************
    88 57D5 00			BOOT_SYS_END    BRK
    89 57D6					ORG ((*/256)+1)*256		; next free page
    90 = 5800			SIS_BUFF	.ds 	512			; SIS Buffer 
    91 = 5A00			FILE_BUFF	.ds	512			; .exe file buffer
    92 						END
