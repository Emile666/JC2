mads 2.1.7 build 33 (1 Aug 24)
Source: Junior_Computer_Monitor_Mads_v01.asm
     1 				;----------------------------------------------------------------------------
     2 				; SOURCE LISTING OF ELEKTOR'S JUNIOR COMPUTER
     3 				;
     4 				; Written by: A. NACHTMANN
     5 				; Date      :  7 FEB. 1980
     6 				;
     7 				; The features of Junior's monitor program are:
     8 				; - Hex address data display (entry via RST)
     9 				; - Hex editor (start address is $1CB5)
    10 				; - Hex assembler (start address is $1F51)
    11 				;----------------------------------------------------------------------------
    12 				; Original code restored and adapted for the 
    13 				; TASM (Telemark Assembler) by : A.J. Prosman, October 26, 2019
    14 				; MADS (MAD-Assembler) by : E. v.d. Logt,      December 2024
    15 				;----------------------------------------------------------------------------
    16 						OPT h- ; do not add file header
    17 						OPT f+ ; save as single block
    18
    19 				; Editor's pointers and temps in page zero
    20 = 00E1			        KEY     EQU     $00E1   ;1-byte
    21 = 00E2			        BEGADR  EQU     $00E2   ;2-byte Begin Address Pointer
    22 = 00E4			        ENDADR  EQU     $00E4   ;2-byte End Address Pointer
    23 = 00E6			        CURADR  EQU     $00E6   ;2-byte Current Address Pointer
    24 = 00E8			        CENDADR EQU     $00E8   ;2-byte Current End Address Pointer
    25 = 00EA			        MOVADR  EQU     $00EA   ;2-byte 
    26 = 00EC			        TABLEA  EQU     $00EC   ;2-byte
    27 = 00EE			        LABELS  EQU     $00EE   ;1-byte
    28
    29 				;       MPU registers in page zero
    30 = 00EF			        PCL     EQU     $00EF   ;1-byte Program-counter low
    31 = 00F0			        PCH     EQU     $00F0   ;1-byte Program-counter high
    32 = 00F1			        PREG    EQU     $00F1   ;1-byte Flags
    33 = 00F2			        SPUSER  EQU     $00F2   ;1-byte 
    34 = 00F3			        ACC     EQU     $00F3   ;1-byte 
    35 = 00F4			        YREG    EQU     $00F4   ;1-byte 
    36 = 00F5			        XREG    EQU     $00F5   ;1-byte 
    37
    38 = 00F6			        BYTES   EQU     $00F6   ;1-byte Number of bytes to be displayed
    39 = 00F7			        COUNT   EQU     $00F7   ;1-byte
    40
    41 				;       Hex display buffers in page zero
    42 = 00F8			        INL     EQU     $00F8   ;1-byte
    43 = 00F9			        INH     EQU     $00F9   ;1-byte
    44 = 00FA			        POINT   EQU     $00FA   ;2-byte
    45 				        
    46 				;       Temporary data-buffers in page zero
    47 = 00FC			        TEMP    EQU     $00FC   ;1-byte
    48 = 00FD			        TEMPX   EQU     $00FD   ;1-byte
    49 = 00FE			        NIBBLE  EQU     $00FE   ;1-byte
    50 = 00FF			        MODE    EQU     $00FF   ;1-byte
    51
    52 				;------------------------------------------------------------------------------
    53 				;       6532 RIOT IC memory locations
    54 				;------------------------------------------------------------------------------
    55 = 1A80			        PAD     EQU     $1A80   ; Port A Data register 
    56 = 1A81			        PADD    EQU     $1A81   ; Port A Data direction register 
    57 = 1A82			        PBD     EQU     $1A82   ; Port B Data register
    58 = 1A83			        PBDD    EQU     $1A83   ; Port B Data direction register
    59
    60 				;       Write edge detect control
    61 = 1AE4			        EDETA   EQU     $1AE4   ; Negative edge detection disable PA7-IRQ
    62 = 1AE5			        EDETB   EQU     $1AE5   ; Positive edge detection disable PA7-IRQ
    63 = 1AE6			        WDETC   EQU     $1AE6   ; Negative edge detection enable PA7-IRQ
    64 = 1AE7			        EDETD   EQU     $1AE7   ; Positive edge detection enable PA7-IRQ
    65
    66 				;       Read flag register and clear timer & IRQ flag
    67 = 1AD5			        RDFLAG  EQU     $1AD5   ; BIT6=PA7-FLAG; BIT7=TIMER-FLAG
    68
    69 				;       Write count into timer, disable timer-IRQ
    70 = 1AF4			        CNTA    EQU     $1AF4   ; CLK1T
    71 = 1AF5			        CNTB    EQU     $1AF5   ; CLK8T
    72 = 1AF6			        CNTC    EQU     $1AF6   ; CLK64T
    73 = 1AF7			        CNTD    EQU     $1AF7   ; CLK1024T
    74
    75 				;       Write count into timer, enable timer-IRQ
    76 = 1AFC			        CNTE    EQU     $1AFC   ; CLK1T
    77 = 1AFD			        CNTF    EQU     $1AFD   ; CLK8T
    78 = 1AFE			        CNTG    EQU     $1AFE   ; CLK64T
    79 = 1AFF			        CNTH    EQU     $1AFF   ; CLK1024T
    80
    81 				;       Interrupt vectors: IRQ & NMI vectors should be loaded into the
    82 				;       following memory locations for proper system operation.
    83 = 1A7A			        NMIL    EQU     $1A7A   ; NMI LOWER BYTE
    84 = 1A7B			        NMIH    EQU     $1A7B   ; NMI HIGHER BYTE
    85 = 1A7E			        IRQL    EQU     $1A7E   ; IRQ LOWER BYTE
    86 = 1A7F			        IRQH    EQU     $1A7F   ; IRQ HIGHER BYTE
    87
    88 				;       Beginners may load these locations
    89 				;       $1C00 for step by step modus and BRK command
    90
    91 				;----------------------------------------------------------------------------
    92 				;        JUNIOR'S MAIN ROUTINES
    93 				;----------------------------------------------------------------------------
    94 				        ORG $1C00, $FC00
    95
    96 FC00 85 F3		SAVE    STA     ACC         ; Save ACCU
    97 1C02 68			        PLA                 ; Get current P-Register
    98 1C03 85 F1		        STA     PREG        ; Save P-Register
    99
   100 1C05 68			SAVEA   PLA                 ; Get current PCL
   101 1C06 85 EF		        STA		PCL         ; Save current PCL
   102 1C08 85 FA		        STA     POINT       ; PCL to display buffer
   103 1C0A 68			        PLA                 ; Get current PCH
   104 1C0B 85 F0		        STA     PCH         ; Save current PCH
   105 1C0D 85 FB		        STA     POINT+1     ; PCH to display buffer
   106
   107 1C0F 84 F4		SAVEB   STY     YREG        ; Save current Y-Register
   108 1C11 86 F5		        STX     XREG        ; Save current X-Register 
   109 1C13 BA			        TSX                 ; Get current SP
   110 1C14 86 F2		        STX     SPUSER      ; Save current SP
   111 1C16 A2 01		        LDX     #$01        ; Set AD-Mode
   112 1C18 86 FF		        STX     MODE
   113 1C1A 4C 33 1C		        JMP     START
   114
   115 				; RESET vector 6502
   116 1C1D A9 1E		RESET   LDA     #$1E        ; PB1---PB4
   117 1C1F 8D 83 1A		        STA     PBDD        ; IS output
   118 1C22 A9 04		        LDA     #$04        ; Reset P-Register
   119 1C24 85 F1		        STA     PREG
   120 1C26 A9 03		        LDA     #$03
   121 1C28 85 FF		        STA     MODE        ; Set AD-Mode
   122 1C2A 85 F6		        STA     BYTES       ; Display POINT, INH
   123 1C2C A2 FF		        LDX     #$FF
   124 1C2E 9A			        TXS 
   125 1C2F 86 F2		        STX     SPUSER
   126 1C31 D8			        CLD 
   127 1C32 78			        SEI 
   128
   129 1C33 20 88 1D		START   JSR     SCAND       ; Display data specified by POINT
   130 1C36 D0 FB		        BNE     START       ; Wait until key is released
   131
   132 1C38 20 88 1D		STARA   JSR     SCAND       ; Display data specified by point
   133 1C3B F0 FB		        BEQ     STARA       ;  Any key pressed
   134 1C3D 20 88 1D		        JSR     SCAND       ;  Debounce key
   135 1C40 F0 F6		        BEQ     STARA       ; Any key still pressed
   136 1C42 20 F9 1D		        JSR     GETKEY      ; If Yes, decode key, return with key in ACC
   137
   138 1C45 C9 13		GOEXEC  CMP     #$13        ; GO-Key ?
   139 1C47 D0 13		        BNE     ADMODE
   140 1C49 A6 F2		        LDX     SPUSER      ; Get current SP
   141 1C4B 9A			        TXS 
   142 1C4C A5 FB		        LDA     POINT+1     ; Start execution at POINT
   143 1C4E 48			        PHA 
   144 1C4F A5 FA		        LDA     POINT
   145 1C51 48			        PHA 
   146 1C52 A5 F1		        LDA     PREG        ; Restore current P register
   147 1C54 48			        PHA 
   148 1C55 A6 F5		        LDX     XREG
   149 1C57 A4 F4		        LDY     YREG
   150 1C59 A5 F3		        LDA     ACC
   151 1C5B 40			        RTI                 ; Execute program
   152
   153 1C5C C9 10		ADMODE  CMP     #$10        ; AD-Key ?
   154 1C5E D0 06		        BNE     DAMODE
   155 1C60 A9 03		        LDA     #$03        ; Set AD-Mode
   156 1C62 85 FF		        STA     MODE
   157 1C64 D0 14		        BNE     STEPA       ; Always
   158 				        
   159 1C66 C9 11		DAMODE  CMP     #$11        ; DA-Key ?
   160 1C68 D0 06		        BNE     STEP
   161 1C6A A9 00		        LDA     #$00        ; Set DA-Mode
   162 1C6C 85 FF		        STA     MODE
   163 1C6E F0 0A		        BEQ     STEPA
   164
   165 1C70 C9 12		STEP    CMP     #$12        ; PLUS-Key ?
   166 1C72 D0 09		        BNE     PCKEY
   167 1C74 E6 FA		        INC     POINT
   168 1C76 D0 02		        BNE     STEPA
   169 1C78 E6 FB		        INC     POINT+1
   170
   171 1C7A 4C 33 1C		STEPA   JMP     START
   172
   173 1C7D C9 14		PCKEY   CMP     #$14        ; PC-Key
   174 1C7F D0 0B		        BNE     ILLKEY
   175 1C81 A5 EF		        LDA     PCL
   176 1C83 85 FA		        STA     POINT      ; Last PC to display buffer
   177 1C85 A5 F0		        LDA     PCH
   178 1C87 85 FB		        STA     POINT+1
   179 1C89 4C 7A 1C		        JMP     STEPA
   180 				        
   181 1C8C C9 15		ILLKEY  CMP     #$15        ; Illegal key?
   182 1C8E 10 EA		        BPL     STEPA       ; If Yes, ignore it
   183
   184 1C90 85 E1		DATA    STA     KEY         ; Save key
   185 1C92 A4 FF		        LDY     MODE        ; Y=0 Is data mode, else address mode
   186 1C94 D0 0D		        BNE     ADDRESS
   187 1C96 B1 FA		        LDA     (POINT),Y   ; Get Data specified
   188 1C98 0A			        ASL                 ; by point
   189 1C99 0A			        ASL                 ; shift low order
   190 1C9A 0A			        ASL                 ; nibble into high order nibble
   191 1C9B 0A			        ASL      
   192 1C9C 05 E1		        ORA     KEY         ; Data with key
   193 1C9E 91 FA		        STA     (POINT),Y   ; Restore data
   194 1CA0 4C 7A 1C		        JMP     STEPA
   195
   196 1CA3 A2 04		ADDRESS LDX     #$04        ; 4 Shifts
   197 1CA5 06 FA		ADLOOP  ASL     POINT       ; POINT+1, POINT 4 Positions to the left
   198 1CA7 26 FB		        ROL     POINT+1
   199 1CA9 CA			        DEX 
   200 1CAA D0 F9		        BNE     ADLOOP
   201 1CAC A5 FA		        LDA     POINT
   202 1CAE 05 E1		        ORA     KEY         ; Restore address
   203 1CB0 85 FA		        STA     POINT
   204 1CB2 4C 7A 1C		        JMP     STEPA
   205
   206 				;-------------------------------------------------------------------------------
   207 				;       JUNIOR'S HEX EDITOR
   208 				;
   209 				;       FOLLOWING COMMANDS ARE VALID:
   210 				;       "INSERT": INSERT A NEW LINE JUST BEFORE DISPLAYED LINE
   211 				;       "INPUT": INSERT A NEW LINE JUST BEHIND THE DISPLAYED LINE
   212 				;       "SEARCH": SEARCH IN WORKSPACE FOR A GIVEN 2BYTE PATTERN
   213 				;       "SKIP": SKIP TO NEXT INSTRUCTION
   214 				;       "DELETE": DELETE CURRENT DISPLAYED INSTRUCTION
   215 				;
   216 				;       AN ERROR IS INDICATED, IF THE INSTRUCTION POINTER CURAD IS OUT OF RANGE
   217 				;-------------------------------------------------------------------------------
   218 1CB5 20 D3 1E		EDITOR  JSR     BEGIN       ; CURAD := BEGAD
   219 1CB8 A4 E3		        LDY     BEGADR+1
   220 1CBA A6 E2		        LDX     BEGADR
   221 1CBC E8			        INX 
   222 1CBD D0 01		        BNE     EDIT
   223 1CBF C8			        INY 
   224
   225 1CC0 86 E8		EDIT    STX     CENDADR     ; CEND := BEGAD + 1
   226 1CC2 84 E9		        STY     CENDADR+1
   227 1CC4 A9 77		        LDA     #$77        ; Display "77"
   228 1CC6 A0 00		        LDY     #$00
   229 1CC8 91 E6		        STA     (CURADR),Y
   230 1CCA 20 4D 1D		CMND    JSR     SCAN        ; Display current instruction,
   231 				                            ; wait for a key
   232 1CCD C9 14		SEARCH  CMP     #$14        ; Search command ?
   233 1CCF D0 2A		        BNE     INSERT
   234 1CD1 20 6F 1D		        JSR     GETBYT      ; Read 1st byte
   235 1CD4 10 F7		        BPL     SEARCH      ; COM. Key ?
   236 1CD6 85 FB		        STA     POINT+1     ; Discard data
   237 1CD8 20 6F 1D		        JSR     GETBYT      ; Read 2nd byte
   238 1CDB 10 F0		        BPL     SEARCH      ; COM. Key ?
   239 1CDD 85 FA		        STA     POINT       ; Discard data
   240 1CDF 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   241
   242 1CE2 A0 00		SELOOP  LDY     #$00
   243 1CE4 B1 E6		        LDA     (CURADR),Y  ; Compare instruction
   244 1CE6 C5 FB		        CMP     POINT+1     ; against data to be searched
   245 1CE8 D0 07		        BNE     SEARA       ; Skip to the next instruction, if not equal
   246 1CEA C8			        INY 
   247 1CEB B1 E6		        LDA     (CURADR),Y
   248 1CED C5 FA		        CMP     POINT
   249 1CEF F0 D9		        BEQ     CMND        ; Return if 2byte pattern is found
   250
   251 1CF1 20 5C 1E		SEARA   JSR     OPLEN       ; Get length of the current instruction
   252 1CF4 20 F8 1E		        JSR     NEXT        ; Skip to the next instruction
   253 1CF7 30 E9		        BMI     SELOOP      ; Search again, if CURAD is less than CEND
   254 1CF9 10 3E		        BPL     ERRA
   255
   256 1CFB C9 10		INSERT  CMP     #$10        ; Insert command ?
   257 1CFD D0 0A		        BNE     INPUT
   258 1CFF 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   259 1D02 10 C9		        BPL     SEARCH      ; COM. key?
   260 1D04 20 47 1E		        JSR     FILLWS      ; Move data in WS downward by the amount in bytes
   261 1D07 F0 C1		        BEQ     CMND        ; Return to display the inserted instruction
   262
   263 1D09 C9 13		INPUT   CMP     #$13        ; Input command ?
   264 1D0B D0 14		        BNE     SKIP
   265 1D0D 20 20 1E		        JSR     RDINST      ; Read instruction and compute length
   266 1D10 10 BB		        BPL     SEARCH      ; COM. key ?
   267 1D12 20 5C 1E		        JSR     OPLEN       ; Length of the current instruction
   268 1D15 20 F8 1E		        JSR     NEXT        ; Return with N=1, if CURAD is less than CEND
   269 1D18 A5 FD		        LDA     TEMPX       ; Length of instr. to be inserted
   270 1D1A 85 F6		        STA     BYTES
   271 1D1C 20 47 1E		        JSR     FILLWS      ; Move data in ws downward by the amount in bytes
   272 1D1F F0 A9		        BEQ     CMND        ; Return to display the inserted data
   273
   274 1D21 C9 12		SKIP    CMP     #$12        ; Skip command ?
   275 1D23 D0 07		        BNE     DELETE
   276 1D25 20 F8 1E		        JSR     NEXT        ; Skip to next instruction. CURAD less than CEND?
   277 1D28 30 A0		        BMI     CMND
   278 1D2A 10 0D		        BPL     ERRA
   279
   280 1D2C C9 11		DELETE  CMP     #$11        ; Delete command ?
   281 1D2E D0 09		        BNE     ERRA
   282 1D30 20 83 1E		        JSR     UP          ; Delete current instruction by moving up the WS
   283 1D33 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   284 1D36 4C CA 1C		        JMP     CMND
   285
   286 1D39 A9 EE		ERRA    LDA     #$EE
   287 1D3B 85 FB		        STA     POINT+1
   288 1D3D 85 FA		        STA     POINT
   289 1D3F 85 F9		        STA     INH
   290 1D41 A9 03		        LDA     #$03
   291 1D43 85 F6		        STA     BYTES
   292
   293 1D45 20 8E 1D		ERRB    JSR     SCANDS      ; Display "EEEEEE" until key is released
   294 1D48 D0 FB		        BNE     ERRB
   295 1D4A 4C CA 1C		        JMP     CMND
   296
   297 				;----------------------------------------------------------------------------
   298 				;       EDITOR'S SUBROUTINES
   299 				;
   300 				;       SCAN is a subroutine, filling up the display-buffer determined by
   301 				;       CURADR. Then the display is scanned depending on the length of the  
   302 				;       instruction pointed to by CURADR if a keypress is detected.
   303 				;----------------------------------------------------------------------------
   304
   305 				;       SCAN RETURNS WITH VALUE IN A
   306 1D4D A2 02		SCAN    LDX     #$02        ; Fill up the display buffer
   307 1D4F A0 00		        LDY     #$00
   308
   309 1D51 B1 E6		FILBUF  LDA     (CURADR),Y  ; Start filling at OPCode
   310 1D53 95 F9		        STA     INH,X
   311 1D55 C8			        INY 
   312 1D56 CA			        DEX 
   313 1D57 10 F8		        BPL     FILBUF
   314 1D59 20 5C 1E		        JSR     OPLEN       ; Store instruction length in bytes
   315
   316 1D5C 20 8E 1D		SCANA   JSR     SCANDS      ; Display current instruction
   317 1D5F D0 FB		        BNE     SCANA       ; Key released ?
   318
   319 1D61 20 8E 1D		SCANB   JSR     SCANDS      ; Display current instruction
   320 1D64 F0 FB		        BEQ     SCANB       ; Any key pressed
   321 1D66 20 8E 1D		        JSR     SCANDS      ; Display current instruction
   322 1D69 F0 F6		        BEQ     SCANB       ; Any key still pressed ?
   323 1D6B 20 F9 1D		        JSR     GETKEY      ; If yes, return with key in ACC
   324 1D6E 60			        RTS 
   325
   326 				;----------------------------------------------------------------------------
   327 				;       GETBYT reads 2 hex-keys and composes their values in the A register.
   328 				;       If only hex-keys were pressed, it returns with N=1. If a command-key
   329 				;       was pressed, it returns with N=0;
   330 				;----------------------------------------------------------------------------
   331 1D6F 20 5C 1D		GETBYT  JSR     SCANA       ; Read high order nibble
   332 1D72 C9 10		        CMP     #$10
   333 1D74 10 11		        BPL     BYTEND      ; Command key ?
   334 1D76 0A			        ASL     
   335 1D77 0A			        ASL                 ; If not, save high order nibble
   336 1D78 0A			        ASL     
   337 1D79 0A			        ASL     
   338 1D7A 85 FE		        STA     NIBBLE
   339 1D7C 20 5C 1D		        JSR     SCANA       ; Read low order nibble
   340 1D7F C9 10		        CMP     #$10
   341 1D81 10 04		        BPL     BYTEND      ; Command key ?
   342 1D83 05 FE		        ORA     NIBBLE      ; If not, compose byte
   343 1D85 A2 FF		        LDX     #$FF        ; Set N=1
   344 1D87 60			BYTEND  RTS 
   345
   346 				;----------------------------------------------------------------------------
   347 				;       SCAND is a subroutine showing data specified by POINT.
   348 				;       SCANDS is a subroutine showing the contents of the display-buffer as
   349 				;       a function of BYTES.
   350 				;       The next subroutine AK scans the keyboard, it returns with A=0 if no
   351 				;       key was pressed and with A > 0 if a key was pressed.
   352 				;       When SCAND or SCANDS are exit, PA0..PA7 are set to input.
   353 				;----------------------------------------------------------------------------
   354 1D88			SCAND
   355 1D88 A0 00		        LDY     #$00
   356 1D8A B1 FA		        LDA     (POINT),Y   ; Get data specified by point
   357 1D8C 85 F9		        STA     INH
   358
   359 1D8E A9 7F		SCANDS  LDA     #$7F
   360 1D90 8D 81 1A		        STA     PADD        ; PA0..PA6 is output
   361 1D93 A2 08		        LDX     #$08        ; Enable display
   362 1D95 A4 F6		        LDY     BYTES       ; Fetch length from bytes
   363
   364 1D97 A5 FB		SCDSA   LDA     POINT+1     ; Output 1st byte
   365 1D99 20 CC 1D		        JSR     SHOW
   366 1D9C 88			        DEY 
   367 1D9D F0 0D		        BEQ     SCDSB       ; More bytes ?
   368 1D9F A5 FA		        LDA     POINT
   369 1DA1 20 CC 1D		        JSR     SHOW        ; If yes, output 2nd byte
   370 1DA4 88			        DEY 
   371 1DA5 F0 05		        BEQ     SCDSB       ; More bytes ?
   372 1DA7 A5 F9		        LDA     INH
   373 1DA9 20 CC 1D		        JSR     SHOW        ; If yes, output 3rd byte
   374
   375 1DAC A9 00		SCDSB   LDA     #$00
   376 1DAE 8D 81 1A		        STA     PADD        ; PA0..PA7 is input
   377 1DB1 A0 03		AK      LDY     #$03        ; Scan 3 rows
   378 1DB3 A2 00		        LDX     #$00        ; Reset row counter
   379
   380 1DB5 A9 FF		ONEKEY  LDA     #$FF
   381 1DB7 8E 82 1A		AKA     STX     PBD         ; Output row number
   382 1DBA E8			        INX                 ; Enable next row
   383 1DBB E8			        INX 
   384 1DBC 2D 80 1A		        AND     PAD         ; Input row pattern
   385 1DBF 88			        DEY                 ; All rows scanned ?
   386 1DC0 D0 F5		        BNE     AKA
   387 1DC2 A0 06		        LDY     #$06        ; Turn display off
   388 1DC4 8C 82 1A		        STY     PBD
   389 1DC7 09 80		        ORA     #$80        ; Set BIT7=1
   390 1DC9 49 FF		        EOR     #$FF        ; Invert key pattern
   391 1DCB 60			        RTS 
   392
   393 				;----------------------------------------------------------------------------
   394 				;       Subroutine SHOW copies the contents of a display-buffer to the display.
   395 				;       The X-register is used as a scan-counter. It determines if POINT+1,
   396 				;       POINT or INH is transported to the displays.
   397 				;----------------------------------------------------------------------------
   398 1DCC			SHOW
   399 1DCC 48			        PHA                 ; Save display 
   400 1DCD 84 FC		        STY     TEMP        ; Save Y register
   401 1DCF 4A			        LSR     
   402 1DD0 4A			        LSR                 ; Get high order nibble
   403 1DD1 4A			        LSR     
   404 1DD2 4A			        LSR     
   405 1DD3 20 DF 1D		        JSR     CONVD       ; Output high order nibble
   406 1DD6 68			        PLA                 ; Get display again
   407 1DD7 29 0F		        AND     #$0F        ; Mask off high order nibble
   408 1DD9 20 DF 1D		        JSR     CONVD       ; Output low order nibble
   409 1DDC A4 FC		        LDY     TEMP
   410 1DDE 60			        RTS 
   411
   412 				;----------------------------------------------------------------------------
   413 				;       Subroutine CONVD controls the display scanning. It converts the
   414 				;       contents of the display-buffer to be displayed into a segment pattern.
   415 				;----------------------------------------------------------------------------
   416 1DDF A8			CONVD   TAY                 ; Use nibble as index
   417 1DE0 B9 0F 1F		        LDA     LOOK,Y      ; Fetch segment pattern
   418 1DE3 8D 80 1A		        STA     PAD         ; Output segment pattern
   419 1DE6 8E 82 1A		        STX     PBD         ; Output digit enable
   420 1DE9 A0 7F		        LDY     #$7F
   421
   422 1DEB 88			DELAY   DEY                 ; Delay 500uS approx
   423 1DEC 10 FD		        BPL     DELAY
   424 1DEE 8C 80 1A		        STY     PAD         ; Turns segments off
   425 1DF1 A0 06		        LDY     #$06
   426 1DF3 8C 82 1A		        STY     PBD         ; Turn display off
   427 1DF6 E8			        INX                 ; Enable next digit
   428 1DF7 E8			        INX 
   429 1DF8 60			        RTS 
   430
   431 				;----------------------------------------------------------------------------
   432 				;       GETKEY converts a key-press into a hex number. It returns with the
   433 				;       key value in A. 
   434 				;       If an invalid key was pressed ?
   435 				;----------------------------------------------------------------------------
   436 1DF9 A2 21		GETKEY  LDX     #$21        ; Start at row 0
   437 1DFB A0 01		GETKEA  LDY     #$01        ; Get one row
   438 1DFD 20 B5 1D		        JSR     ONEKEY      ; A=0, No key pressed
   439 1E00 D0 07		        BNE     KEYIN
   440 1E02 E0 27		        CPX     #$27
   441 1E04 D0 F5		        BNE     GETKEA      ; Each row scanned ?
   442 1E06 A9 15		        LDA     #$15        ; Return if invalid key
   443 1E08 60			        RTS 
   444
   445 1E09 A0 FF		KEYIN   LDY     #$FF
   446 1E0B 0A			KEYINA  ASL                 ; Shift left until Y=Key number
   447 1E0C B0 03		        BCS     KEYINB
   448 1E0E C8			        INY 
   449 1E0F 10 FA		        BPL     KEYINA
   450
   451 1E11 8A			KEYINB  TXA 
   452 1E12 29 0F		        AND     #$0F        ; Mask MSD
   453 1E14 4A			        LSR                 ; Divide by 2
   454 1E15 AA			        TAX 
   455 1E16 98			        TYA 
   456 1E17 10 03		        BPL     KEYIND
   457
   458 1E19 18			KEYINC  CLC 
   459 1E1A 69 07		        ADC     #$07        ; Add row offset
   460 1E1C CA			KEYIND  DEX 
   461 1E1D D0 FA		        BNE     KEYINC
   462 1E1F 60			        RTS 
   463
   464 				;----------------------------------------------------------------------------
   465 				;       RDINST transfers an instruction from the keyboard to the display-buffer. 
   466 				;       It returns with N=0 if a command-key was pressed. Once the entire
   467 				;       instruction is read, RDINST returns with N=1;
   468 				;----------------------------------------------------------------------------
   469 1E20 20 6F 1D		RDINST  JSR     GETBYT      ; Read OPCode
   470 1E23 10 21		        BPL     RDB         ; Return if it is the command key
   471 1E25 85 FB		        STA     POINT+1     ; Store OP cod in the display buffer
   472 1E27 20 60 1E		        JSR     LENACC      ; Calculate instruction length
   473 1E2A 84 F7		        STY     COUNT
   474 1E2C 84 FD		        STY     TEMPX
   475 1E2E C6 F7		        DEC     COUNT
   476 1E30 F0 12		        BEQ     RDA         ; 1 Byte instruction ?
   477 1E32 20 6F 1D		        JSR     GETBYT      ; If not, read first operand
   478 1E35 10 0F		        BPL     RDB         ; Return if it is the command key
   479 				        
   480 1E37 85 FA		        STA     POINT       ; Store 1st operand in the display buffer
   481 1E39 C6 F7		        DEC     COUNT
   482 1E3B F0 07		        BEQ     RDA         ; 2 Byte instruction ?
   483 				        
   484 1E3D 20 6F 1D		        JSR     GETBYT      ; If not, read second operand
   485 1E40 10 04		        BPL     RDB         ; Return if it is the command key
   486 				        
   487 1E42 85 F9		        STA     INH         ; Store 2nd operand in the display buffer
   488 1E44 A2 FF		RDA     LDX     #$FF        ; N=1
   489 1E46 60			RDB     RTS 
   490
   491 				;----------------------------------------------------------------------------
   492 				;       WILLWS transfers data from the display to the workspace. It always
   493 				;       returns with Z=1.
   494 				;----------------------------------------------------------------------------
   495 1E47 20 A6 1E		FILLWS  JSR     DOWN        ; Move data down by the amount in bytes
   496 1E4A 20 DC 1E		        JSR     ADCEND      ; Adjust current end address
   497 1E4D A2 02		        LDX     #$02
   498 1E4F A0 00		        LDY     #$00
   499 1E51 B5 F9		WS      LDA     INH,X       ; Fetch data from display buffer
   500 1E53 91 E6		        STA     (CURADR),Y  ; Insert data into the data field
   501 1E55 CA			        DEX 
   502 1E56 C8			        INY 
   503 1E57 C4 F6		        CPY     BYTES       ; All inserted ?
   504 1E59 D0 F6		        BNE     WS          ; If not, continue
   505 1E5B 60			        RTS 
   506
   507 				;----------------------------------------------------------------------------
   508 				;       OPLEN calculates the length of a 6502 instruction.
   509 				;       Instruction length is saved in BYTES.
   510 				;----------------------------------------------------------------------------
   511 1E5C A0 00		OPLEN   LDY     #$00
   512 1E5E B1 E6		        LDA     (CURADR),Y  ; Fetch OPCode from WS
   513 1E60 A0 01		LENACC  LDY     #$01        ; Length of the OPCode is 1 byte
   514 1E62 C9 00		        CMP     #$00
   515 1E64 F0 1A		        BEQ     LENEND      ; BRK Instruction ?
   516 				        
   517 1E66 C9 40		        CMP     #$40
   518 1E68 F0 16		        BEQ     LENEND      ; TRI Instruction ?
   519 				        
   520 1E6A C9 60		        CMP     #$60
   521 1E6C F0 12		        BEQ     LENEND      ; RTS Instruction ?
   522 				        
   523 1E6E A0 03		        LDY     #$03
   524 1E70 C9 20		        CMP     #$20
   525 1E72 F0 0C		        BEQ     LENEND      ; JSR Instruction ?
   526 				        
   527 1E74 29 1F		        AND     #$1F        ; Strip to 5 bits
   528 1E76 C9 19		        CMP     #$19
   529 1E78 F0 06		        BEQ     LENEND      ; Any ABS,Y instruction ?
   530 				        
   531 1E7A 29 0F		        AND     #$0F        ; Strip to 4 bits
   532 1E7C AA			        TAX                 ; Use nibble as index
   533 1E7D BC 1F 1F		        LDY     LEN,X       ; Fetch length from LEN
   534 1E80 84 F6		LENEND  STY     BYTES       ; Discard length in bytes
   535 1E82 60			        RTS 
   536
   537 				;----------------------------------------------------------------------------
   538 				;       UP moves a data-field between CURADR and CENDADR upwards by the
   539 				;       amount in BYTES.
   540 				;----------------------------------------------------------------------------
   541 1E83 A5 E6		UP      LDA     CURADR
   542 1E85 85 EA		        STA     MOVADR
   543 1E87 A5 E7		        LDA     CURADR+1    ; MOVAD := CURADR
   544 1E89 85 EB		        STA     MOVADR+1
   545 1E8B A4 F6		UPLOOP  LDY     BYTES
   546 1E8D B1 EA		        LDA     (MOVADR),Y  ; Move upward by the number of bytes
   547 1E8F A0 00		        LDY     #$00
   548 1E91 91 EA		        STA     (MOVADR),Y
   549 1E93 E6 EA		        INC     MOVADR
   550 1E95 D0 02		        BNE     UPA
   551 				        
   552 1E97 E6 EB		        INC     MOVADR+1    ; MOVADR+1 := MOVADR+1 + 1
   553 1E99 A5 EA		UPA     LDA     MOVADR
   554 1E9B C5 E8		        CMP     CENDADR
   555 1E9D D0 EC		        BNE     UPLOOP      ; All data moved ?
   556 1E9F A5 EB		        LDA     MOVADR+1    ; If not continue
   557 1EA1 C5 E9		        CMP     CENDADR+1
   558 1EA3 D0 E6		        BNE     UPLOOP
   559 1EA5 60			        RTS 
   560
   561 				;----------------------------------------------------------------------------
   562 				;       DOWN moves a data-field between CURADR and CENDADR downwards by the
   563 				;       amount in BYTES.
   564 				;----------------------------------------------------------------------------
   565 1EA6 A5 E8		DOWN    LDA     CENDADR
   566 1EA8 85 EA		        STA     MOVADR      ; MOVAD := CEND
   567 1EAA A5 E9		        LDA     CENDADR+1
   568 1EAC 85 EB		        STA     MOVADR+1
   569 1EAE A0 00		DNLOOP  LDY     #$00
   570 1EB0 B1 EA		        LDA     (MOVADR),Y  ; Move downward by the number of bytes
   571 1EB2 A4 F6		        LDY     BYTES
   572 1EB4 91 EA		        STA     (MOVADR),Y
   573 1EB6 A5 EA		        LDA     MOVADR
   574 1EB8 C5 E6		        CMP     CURADR
   575 1EBA D0 06		        BNE     DNA         ; All data moved ?
   576 				        
   577 1EBC A5 EB		        LDA     MOVADR+1    ; If not, continue
   578 1EBE C5 E7		        CMP     CURADR+1
   579 1EC0 F0 10		        BEQ     DNEND
   580 1EC2 38			DNA     SEC 
   581 1EC3 A5 EA		        LDA     MOVADR
   582 1EC5 E9 01		        SBC     #$01
   583 1EC7 85 EA		        STA     MOVADR
   584 1EC9 A5 EB		        LDA     MOVADR+1    ; MOVAD := MOVAD - 1
   585 1ECB E9 00		        SBC     #$00
   586 1ECD 85 EB		        STA     MOVADR+1
   587 1ECF 4C AE 1E		        JMP     DNLOOP
   588 1ED2 60			DNEND   RTS 
   589
   590 				;----------------------------------------------------------------------------
   591 				;       BEGIN sets CURADR TO BEGADR
   592 				;----------------------------------------------------------------------------
   593 1ED3			BEGIN
   594 1ED3 A5 E2		        LDA     BEGADR
   595 1ED5 85 E6		        STA     CURADR
   596 1ED7 A5 E3		        LDA     BEGADR+1    ; CURAD := BEGADR
   597 1ED9 85 E7		        STA     CURADR+1
   598 1EDB 60			        RTS 
   599
   600 				;----------------------------------------------------------------------------
   601 				;       ADCEND increases the current end-address by the number in BYTES.
   602 				;----------------------------------------------------------------------------
   603 1EDC 18			ADCEND  CLC 
   604 1EDD A5 E8		        LDA     CENDADR
   605 1EDF 65 F6		        ADC     BYTES       ; CEND := CEND + BYTES
   606 1EE1 85 E8		        STA     CENDADR
   607 1EE3 A5 E9		        LDA     CENDADR+1
   608 1EE5 69 00		        ADC     #$00
   609 1EE7 85 E9		        STA     CENDADR+1
   610 1EE9 60			        RTS 
   611
   612 				;----------------------------------------------------------------------------
   613 				;       RECEND decreases the current end-address by the number in BYTES.
   614 				;----------------------------------------------------------------------------
   615 1EEA 38			RECEND  SEC 
   616 1EEB A5 E8		        LDA     CENDADR
   617 1EED E5 F6		        SBC     BYTES       ; CEND := CEND - BYTES
   618 1EEF 85 E8		        STA     CENDADR
   619 1EF1 A5 E9		        LDA     CENDADR+1
   620 1EF3 E9 00		        SBC     #$00
   621 1EF5 85 E9		        STA     CENDADR+1
   622 1EF7 60			        RTS 
   623
   624 				;----------------------------------------------------------------------------
   625 				;       NEXT increases the current displayed address by the number in BYTES.
   626 				;----------------------------------------------------------------------------
   627 1EF8 18			NEXT    CLC 
   628 1EF9 A5 E6		        LDA     CURADR
   629 1EFB 65 F6		        ADC     BYTES       ; CURAD := CURAD + BYTES
   630 1EFD 85 E6		        STA     CURADR
   631 1EFF A5 E7		        LDA     CURADR+1
   632 1F01 69 00		        ADC     #$00
   633 1F03 85 E7		        STA     CURADR+1
   634 1F05 38			        SEC 
   635 1F06 A5 E6		        LDA     CURADR
   636 1F08 E5 E8		        SBC     CENDADR
   637 1F0A A5 E7		        LDA     CURADR+1
   638 1F0C E5 E9		        SBC     CENDADR+1
   639 1F0E 60			        RTS 
   640
   641 				;----------------------------------------------------------------------------
   642 				;       Lookup table "LOOK"" is used to convert a hex number into a pattern
   643 				;       for the seven-segment displays. 
   644 				;       Lookup table "LEN" is used to convert an instruction into an 
   645 				;       instruction length.
   646 				;----------------------------------------------------------------------------
   647 1F0F 40			LOOK    .byte   $40         ; "0"
   648 1F10 79			        .byte   $79         ; "1"
   649 1F11 24			        .byte   $24         ; "2"
   650 1F12 30			        .byte   $30         ; "3"
   651 1F13 19			        .byte   $19         ; "4"
   652 1F14 12			        .byte   $12         ; "5"
   653 1F15 02			        .byte   $02         ; "6"
   654 1F16 78			        .byte   $78         ; "7"
   655 1F17 00			        .byte   $00         ; "8"
   656 1F18 10			        .byte   $10         ; "9"
   657 1F19 08			        .byte   $08         ; "A"
   658 1F1A 03			        .byte   $03         ; "B"
   659 1F1B 46			        .byte   $46         ; "C"
   660 1F1C 21			        .byte   $21         ; "D"
   661 1F1D 06			        .byte   $06         ; "E"
   662 1F1E 0E			        .byte   $0E         ; "F"
   663
   664 1F1F 02			LEN     .byte   $02
   665 1F20 02			        .byte   $02
   666 1F21 02			        .byte   $02
   667 1F22 01			        .byte   $01
   668 1F23 02			        .byte   $02
   669 1F24 02			        .byte   $02
   670 1F25 02			        .byte   $02
   671 1F26 01			        .byte   $01
   672 1F27 01			        .byte   $01
   673 1F28 02			        .byte   $02
   674 1F29 01			        .byte   $01
   675 1F2A 01			        .byte   $01
   676 1F2B 03			        .byte   $03
   677 1F2C 03			        .byte   $03
   678 1F2D 03			        .byte   $03
   679 1F2E 03			        .byte   $03
   680
   681 1F2F 6C 7A 1A		NMI     JMP     (NMIL)      ; Jump to a user selectable NMI vector
   682 1F32 6C 7E 1A		IRQ     JMP     (IRQL)      ; Jump to a user selectable IRQ vector
   683
   684 				;----------------------------------------------------------------------------
   685 				;       GETLBL is an assembler subroutine. It searches for labels on the
   686 				;       symbol pseudo stack. If this stack contains a valid label, it returns
   687 				;       with the high-order label address in X and the low-order label
   688 				;       address in A. If no valid label is found, it returns with Z=1.
   689 				;----------------------------------------------------------------------------
   690 1F35			GETLBL
   691 1F35 B1 E6		        LDA     (CURADR),Y  ; Fetch current label number from WS
   692 1F37 A0 FF		        LDY     #$FF        ; Reset pseudo stack
   693 1F39 C4 EE		SYMA    CPY     LABELS      ; Upper most symbol table address ?
   694 1F3B F0 0D		        BEQ     SYMB        ; If yes, return, no label on pseudo stack
   695 				        
   696 1F3D D1 EC		        CMP     (TABLEA),Y  ; Label Nr. in WS = Label Nr. on pseudo stack
   697 1F3F D0 0A		        BNE     SYMNXT
   698 				        
   699 1F41 88			        DEY                 ; If yes, get high order address
   700 1F42 B1 EC		        LDA     (TABLEA),Y
   701 1F44 AA			        TAX                 ; Discard high order, add in X
   702 1F45 88			        DEY 
   703 1F46 B1 EC		        LDA     (TABLEA),Y  ; Get low order add
   704 1F48 A0 01		        LDY     #$01        ; Prepare Y register
   705 1F4A 60			SYMB    RTS 
   706
   707 1F4B 88			SYMNXT  DEY                 ; *********   *********
   708 1F4C 88			        DEY                 ; * X=ADH *   * A=ADL *
   709 1F4D 88			        DEY                 ; *********   *********
   710 1F4E D0 E9		        BNE     SYMA
   711 1F50 60			        RTS 
   712
   713 				;----------------------------------------------------------------------------
   714 				;       ASSEMBLER main routine.
   715 				;
   716 				;       The following instructions are assembled:
   717 				;       - JSR instruction
   718 				;       - JMP instruction 
   719 				;       - BRANCH instructions
   720 				;----------------------------------------------------------------------------
   721 1F51 38			ASSEMB  SEC 
   722 1F52 A5 E4		        LDA     ENDADR
   723 1F54 E9 FF		        SBC     #$FF
   724 1F56 85 EC		        STA     TABLEA      ; TABLE := ENDAD - $FF
   725 1F58 A5 E5		        LDA     ENDADR+1
   726 1F5A E9 00		        SBC     #$00
   727 1F5C 85 ED		        STA     TABLEA+1
   728 1F5E A9 FF		        LDA     #$FF
   729 1F60 85 EE		        STA     LABELS
   730 1F62 20 D3 1E		        JSR     BEGIN       ; CURAD := BEGAD
   731
   732 1F65 20 5C 1E		PASSA   JSR     OPLEN       ; Start pass one, get current instruction
   733 1F68 A0 00		        LDY     #$00
   734 1F6A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   735 1F6C C9 FF		        CMP     #$FF        ; Is the current instruction a label ? 
   736 1F6E D0 1D		        BNE     NXTINS
   737 				        
   738 1F70 C8			        INY 
   739 1F71 B1 E6		        LDA     (CURADR),Y  ; If yes, fetch label number
   740 1F73 A4 EE		        LDY     LABELS
   741 1F75 91 EC		        STA     (TABLEA),Y  ; Push label number on symbol stack
   742 1F77 88			        DEY 
   743 1F78 A5 E7		        LDA     CURADR+1    ; Get high order address
   744 1F7A 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   745 1F7C 88			        DEY 
   746 1F7D A5 E6		        LDA     CURADR      ; Get high order address
   747 1F7F 91 EC		        STA     (TABLEA),Y  ; Push on symbol stack
   748 1F81 88			        DEY 
   749 1F82 84 EE		        STY     LABELS      ; Adjust pseudo stack pointer
   750 1F84 20 83 1E		        JSR     UP          ; Delete current label in ws
   751 1F87 20 EA 1E		        JSR     RECEND      ; Adjust current end address
   752 1F8A 4C 65 1F		        JMP     PASSA       ; Look for more labels
   753
   754 1F8D 20 F8 1E		NXTINS  JSR     NEXT        ; If no label skip to the next instruction
   755 1F90 30 D3		        BMI     PASSA       ; All labels in WS collected ?
   756 1F92 20 D3 1E		        JSR     BEGIN       ; Start pass 2
   757 				        
   758 1F95 20 5C 1E		PASSB   JSR     OPLEN       ; Get length of the current instruction
   759 1F98 A0 00		        LDY     #$00
   760 1F9A B1 E6		        LDA     (CURADR),Y  ; Fetch current instruction
   761 1F9C C9 4C		        CMP     #$4C        ; JMP instruction ?
   762 1F9E F0 16		        BEQ     JUMPS
   763 				        
   764 1FA0 C9 20		        CMP     #$20        ; JSR Instruction ?
   765 1FA2 F0 12		        BEQ     JUMPS
   766 				        
   767 1FA4 29 1F		        AND     #$1F        ; Strip to 5 bits
   768 1FA6 C9 10		        CMP     #$10        ; Any branch instruction ?
   769 1FA8 F0 1A		        BEQ     BRINST
   770 				        
   771 1FAA 20 F8 1E		PB      JSR     NEXT        ; If not, return
   772 1FAD 30 E6		        BMI     PASSB       ; All labels between CURAD and ENDAD assembled ?
   773 				        
   774 1FAF A9 03		        LDA     #$03        ; Enable 3 display buffers
   775 1FB1 85 F6		        STA     BYTES
   776 1FB3 4C 33 1C		        JMP     START       ; Exit here
   777
   778 1FB6 C8			JUMPS   INY                 ; Set pointer to label number
   779 1FB7 20 35 1F		        JSR     GETLBL      ; Get label address
   780 1FBA F0 EE		        BEQ     PB          ; Return if not found
   781 				        
   782 1FBC 91 E6		        STA     (CURADR),Y  ; Store low order address
   783 1FBE 8A			        TXA 
   784 1FBF C8			        INY 
   785 1FC0 91 E6		        STA     (CURADR),Y  ; Store high order address
   786 1FC2 D0 E6		        BNE     PB
   787
   788 1FC4 C8			BRINST  INY                 ; Set pointer to label number
   789 1FC5 20 35 1F		        JSR     GETLBL      ; Get label address
   790 1FC8 F0 E0		        BEQ     PB          ; Return if label not found
   791 				        
   792 1FCA 38			        SEC 
   793 1FCB E5 E6		        SBC     CURADR      ; Calculate branch offset
   794 1FCD 38			        SEC 
   795 1FCE E9 02		        SBC     #$02        ; DESTINATION - SOURCE - 2 = OFFSET
   796 1FD0 91 E6		        STA     (CURADR),Y  ; Insert branch offset in WS
   797 1FD2 4C AA 1F		        JMP     PB
   798
   799 				;----------------------------------------------------------------------------
   800 				;       BRANCH calculates the offset of branch instructions. The 2 right-hand
   801 				;       displays show the calculated offset defined by the 4 left-hand
   802 				;       displays. The program must be stopped by the RESET key.
   803 				;----------------------------------------------------------------------------
   804 1FD5			BRANCH
   805 1FD5 D8			        CLD 
   806 1FD6 A9 00		        LDA     #$00        ; Reset display buffer
   807 1FD8 85 FB		        STA     POINT+1
   808 1FDA 85 FA		        STA     POINT
   809 1FDC 85 F9		        STA     INH
   810 1FDE 20 6F 1D		BR      JSR     GETBYT      ; Read source
   811 1FE1 10 F2		        BPL     BRANCH      ; Command key ?
   812 				        
   813 1FE3 85 FB		        STA     POINT+1    ; Save source in buffer
   814 1FE5 20 6F 1D		        JSR     GETBYT      ; Read destination
   815 1FE8 10 EB		        BPL     BRANCH      ; Command key ?
   816
   817 1FEA 85 FA		        STA     POINT       ; Save destination in buffer
   818 1FEC 18			        CLC 
   819 1FED A5 FA		        LDA     POINT       ; Fetch destination
   820 1FEF E5 FB		        SBC     POINT+1     ; Substract source
   821 1FF1 85 F9		        STA     INH
   822 1FF3 C6 F9		        DEC     INH         ; Equalize and save offset in buffer
   823 1FF5 4C DE 1F		        JMP     BR
   824
   825 				;----------------------------------------------------------------------------
   826 				;       VECTORS AT THE END OF THE MEMORY
   827 				;----------------------------------------------------------------------------
   828 1FF8			        ORG    $1FFA, $FFFA
   829 1FFA			NMI_VECTOR
   830 1FFA 2F 1F		        .word  NMI          ; $1F2F in Junior Computer Monitor program
   831
   832 1FFC			RESET_VECTOR
   833 1FFC 1D 1C		        .word  RESET        ; $1C1D in Junior Computer Monitor program
   834
   835 1FFE			IRQ_BRK_VECTOR
   836 1FFE 32 1F		        .word  IRQ          ; $1F32 in Junior Computer Monitor program
   837
   838 				;----------------------------------------------------------------------------
   839 				;       END OF JUNIOR'S MONITOR
   840 				;----------------------------------------------------------------------------
